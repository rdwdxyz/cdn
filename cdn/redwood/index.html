<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df203a5df2df0bfdae565b7fe9c653ac89be75f832586619c214fb76e8772d76d94c08666e3d4c9b26db6ef5cfa55be3e896146225febdf363ab05d4009d110544efccaa10e0283a06ec3cc39e7f3d244dc6592585f7a0deb13721d59e25380abfda65e13b41355386a17e7f5de6e963327f0ac9f87b075c10054e7e03bde7d133a03d077f2a011528ce0a9685b6bed28ccd865407e4c28e1def9f1752c7ffcbbf761662d279d14bf9f509de47ac1cf98aa425ebf7218d7222ec0a71ae17f509d053a7ffe7c3c45fe7fae4769e6814128f439dc8b79c4d7c392180417857d4855903929a9ca9a79c71316b2379eb54fe697208fe0042c623b0f09e54712a4ef09704f8be5fd38f43b2cdafd49649db98313dd9b6cc1636d3515e60b6da5390e212adb19e1ebd6c7e67aa32075b1cf977b997e564056cc7935fa2b73e9179adbc915c927992109d867c3f648e3dbf2051ebe011c9de7ea3b807246e8052894dfba7366b21791830caa6caedcd93269736ea50dd727e032cde3788256d85cf21d753f6cbb649ffea40373f06041c3f238dcb2c5ef397ef0c8053c8c2638d0b376d9f48f46027a43b5183a4232d9fe558e39208323205733480dc7ccf02f9b45bc1066cbd1c6c604f9fc0b4d10012eacf751879b607f79ce6a315e0ed7567ee1351248a799e2da7ddf1eb633954f932798c2629a39524976192e546babfefa0dc5436fc49ee67314e26c6233c7b8320bbe8847aa59113e935ba9c86bb034f7ae6a332fc6f161b5093a570c6fecf87a31e2578104f607b63b9e6212d3be42bafee9e80ffaab4be9450a2e537976f35a541079c0f9ab692bc7a1e1e40349c80ab887ef36a70f0737af09cc52f9d20634bf73eac87a2e9247647449aba25a3d0a4df5cc8dfb92e4ab22f572ba0dc39c97f25fe7a0a05216452c42c9a51737e228220baab95c18344663ec05846b84d520ae4bec41b4877edc64de40bd6cd076a009f7aec73cbc218599f5cfc40a0bc7efbc0a638d30b6a3009f4b3d6892d9c8193c377671983df9b2b9f10a73f823e62a0fe4d769d502f70f2d844ef039d5b927b15a7f36aa3a75aef719b6a1d4b8aacaa73a0a2aec88f5001644d05251d511c150fefe36d1a1854965446a6962f4757d200685db2cd2b504cfb64c981ca944838e6a95cc1d55b37dc29f3882ca6204d2a1fead4a0bdba9dd622165972590dce3d28bb46c50fd7ad8d4648da4ea6030dec549ad3f1032d0ba43849f62dbc07ac565ac2344d72157277e165ae8e4215fcbb474e72a46aada2577719ce0e9bb063379e9c45b0556fb58920e1f0bbac097cc803dcbcefeb269046aae72d61b388dcbda028043071abe0546b6aa4c40f3abd6e40c34cd1cf9301df4a066c125e7ab852cf114627f3a60d1476d241ce8b9d81e959a0178b1b95fff774d270174d6eed8bb38fd2c882d31064d53c61c40179125049a7a04dabf0f826c513beda7409cde4d38cdbaa48879903ba99894aab6b65635d076e89697bf149fd98ca5da0095261d1c1b0f81c46eb0f0d77f635e725448152b2043bc91c25bfa959c284685adb082faa68e5dd39abad511f936c1e4c3a7aac53e37ac1f1961b3208b99ec2e77f3c416641d7fa296a72659ec43eda9366ac3a5870cfdc7e7e832104209a6486775e654788296877ffcc170291ae19eb4d758993ad625b9f631aa14148619b3dc89c43dd1bc3ad14d2eda027cf2992c920bee3b11b82a21b766f95f6f063acc871cd167ceec6889bc6168098e72498b970d73eb3af66d4c166d58994abd9940586b2030c7d3a5d21521746456a1190668579015b5f435bb9d10c4f02a975099b10a6f6968c7f86549bcbc404515354c8554586d75303220cbb3bd7c8cd729863860e0efaef583c481f66d9a8842fd39709950508f86ba47572bdac3973b2e24031585e3e76fe653cb2c76087ce35e27a4774aa087c33eb06128aec8e22cb4e12b35fd0f21a73461923a0586fc7fe2a810f2cf4b80961c5688899228d2fc327cafe9182511eb3aea9518e43d7ae16fa620b9fb3ad5ec326f191c493cddd5134660986ce0bc1a9ebd14ededf15630d055eeff617775b053fef7f9ef4e78c1f38b75579a96c98dac6af2d8362b6975755be3a456e18cc72daada210bf0d0c95a47823517c433d56bb31aa6e1bb8f5166c9075e687f5ebef8f08eead6ed79e3880ba62552bc9a8bdeb5cf47ebdeb695612608495ebd5d0a1b236965e1a6b112a48fbf55e4fbcc9988ef5c261ec581e6427b70d10e017ffaca8f8badd16122dba1cbfbf31b36fff88bea03718ff04c558219765d3160322f52d93e750958d42b4ddde048907066ed62759a8a8d8196599b94ff2a2f68fc59cf81dfbccfb8f606931104a77d060269effffb08efec9cecf30e3298ea06f98de7294e4f18ae7a17cab83458862f132098ebeb720bcf36c896e17126c343a91dedc4ee0de24c2b83c8d143f92555088a948f9cd89c4928534855473c08fdf5e364cdbe4dcc7c5b3d641402136862bf654d1597a6ffc993d1deaeaa540138cefd3aaad5b633659343db92be86693461276ac839375809eff8fef0b15a1e840cb60d390ee5c4c63f4b759aa8395af986a916f59f102a2f03be6d00b7b4b683d39f84caeb01d96d51c60f2d2892de83ee4141c0a3001c3bcb608a7fbe6f30a5760a67cbddafc5c186a6e65b425b8013babfb7f8af887b6c1e94ed49224ad6f8ce4f0e7b819b0a2b23b46e7431b94c25de0cda05a1fb66c1a6a8f0b31530c4497cf9bcd5ecd3ba783635ed2a07428164d16a245ce129b925b67dc595638ee445e6dfee30c30d2bad5f0c41045a9220dc40f2f62f0385df86ebcacc0a322417a71a6b169dc3f73db752b96e565afac144ea1fc57696b07fda3a417d14bba551b99f1e59f22622f6924031aecdc386f358ba966fc01465951611fae95815434888fe919a2bf2da655b9f41bd2bdb9a9f5e442d010ec256b1b9a0ac1be6a076cff1dbb329d255a71211a64cc97de1318c5114de18d88cac929617d0cf8aa8894917ee269c65d34946384184c323ac4146e4e4102c28e6294936358e6f6e50dbca424f1b96c066719a2f407119bda8dfad7ec8f9f115d0a4f7caf629486932a90a7312fc8bc464830eb0a670510efa2d3640a7a042577e4205723d2e9eeebf7e91bcc5eddc4d64c98919c38c26c0bf41f0d9b4e25c8272f84c416f95720c396d10bc92e5c46ad1823669ce5d961e4510df31d40a7db6ad30edbd795008cc4fbc216790ce99d70d84422f412b8ef5b070ed757c6e19603afd6918d684a5fffdfc67181d88af3e80822dc39c67f8f1db6fad259ac5add27408ace9b73828270dc9a9d54b8e4f0a731c014a1d3e34a22495cd763fddb6b9d9c303fdfa54b190f7d59aa432532b55c5fa2e3f04b57f4980c3f002db45baf85bfd0ebfafb506952c4da24a8608f71bb0069f805f16a754cee5410332f2598a65be6b8e5f182c6a9ff0da21a108e042f28f2d2b7248605968b1e2568bcc51c331922e30e4db8bf194c3a9ddb382da2fe98f91c361ad571f15d9168bbb1075db4fa13204aae26fe83bb5355510ba94233a13e9c8e490f9932c18159158ee7fd9f58d6537543e9c47c5b07f966f1f73ae30e327180288606f96dbea98e9960d88368afe04e166790ccaa53757ac4e4ce58e9677afa44b461f35ae1b46da597a9923485140984d546dbe93e7d0ee5099119fad0c96079ff61dba65478deaf30975689d653063c3cd3f374df30b32f45cc1cd056d780475f3cab11878af6aba933c9ea7ec6a271cc9de760dea689344cf548181531e868d2d9922a8b34484d21ceb3926866537f33b46821e55c2c16c456331e1d990ffcd0d76ccb1cb4f028563e7d2e65161069e5b2fd23ee7e290f111eb4bbe6dcc5be7c2f58507c04959f5bfef234acaa6b8be980084ad28b26ace3f205590a08cbe0f686674534cf62cf7d90e019ebed6669e702810e554e5fbbae5ec6cda43c63d83a374f66b92d2a10492398a15bd4f4ef59ac5ad569618442e3fca1515ee303c4a0ec281b11f4c69b9b3fb5d60443a4ab18561f8c06456df2f4ae881c7c866238659f05c8f8b091f5ba8edda1210ac239c020634e90819005b9e00a2405456362c5a85514da4731b24c201ca705055fd2083f46558401a3516bcac67fcb5c1bcc8372a89ab4722bba7a0d2cb388e6e7436cb5108b11eff6b71832e62cbb710660b7bab2e36c7f54ed54918e76f2cef4c48cd3125482ed4c83ae78a34481a9de9425b839b96b4fc7fcfeaad3e5149238dc4526ad97ee1a5b95eba34b4fe33bfbdb1a08f7c7c40db8a4ed70964a4afcd3407a736a3962f9da05f71b02dc018416ea389379d2085dd3f6d28f08b6f849295bb1a31d1f263f20c40ef0a52ec6885a786f7db0d64b8d1682b694ee6a63bb51f5860393c8e0013051b13771a06957b90e1ca3863c094714e257430d756ae4d8679bd667d46df5490caa07863cba37c6c15bb5bc918f51ed5e63b7dbcafd8130b54e157c9f46d58dbafa8c7fbd2738903b715cc133e715ff428181e9975c7547eb7765870868d59ae4b584657aaf93f89ff21013214dda69a5785472c2b284c959bdbb7360fe53fdce3336c4c86dabc8c9b1740f233dc2189be0dd90681ab5541d32b5a1f3bdf7803308bcb9257af8d9c9b211db76da3dc444b7d2315adc502a0c720e1f3a3ed60b4e8c84db89f8781f6bab414b7cd871f96324702393a9fabb463216e3e0ac8d120a40190efd0f164119d26e61bd63eeec7eff7710fc1727787cbfd8c9b5b32c5216f0491a257f4cf55e871d0e87b4b1c0972eeb27235c694a032f7172f43c5d5bb2c7b14eb86273abf5e387ecf32bd49b942f0e4a0a806008a25e0397e7b046f25579d34d51599cb200209a5a7b799c976bd18476ac9372265a1ce179045ccbefb2e04c3b7199987ff2fe4d815d925dc31acc7e519580d0a7d29fcb153d808933ac52b01f1aa1a52a7ac0bfc09737c3fabab1fa40eca937809c50e6dbd1bd75c127629a820ef7ea54cafb20dab2ca9461a80c77f4afc99a22dff2250722f73b4ece57e705e8b7721e0467a5716749bd3f8be416c84e41695e32db8959c866b0806e904e74995d97eb7d1c3c55da822c386b6495f956cd16529d21a1b9516e22803fb1154d7d9ccb883eeeb8612a79567a3e72c3461ca43688997fc66ca5e1f7a9a39d9931eaa418154d14980241e8bccb768c04e3324d2ce5dbf1ad8a22388bad46369a750685be619406a3ae9ef73ab8a8012db77fd6ebd26e1708689423274a8eaad84627bc0300d35f9ad59a4b93fca3c036997f3f59346e73506d41c3c223b66147c06dd1faec4c4b62c3f42d7c070522e91850ceccebd97214c501cb5c40835b38c4613ab6d5cbc6542c177c168bd0f59472d26fec26ea76f9a238d03ec4335b27e7c078d75cbeff8e25f77962233af0d1259b08b5435f4218469ac57f7f6dba38df01149704318f0fa2d60aef2ef41cbc868bc59b0fabedf0ac12c75fa8498f3c77149cc796ea4e0eeff8e0c90dd8da4b67ecdb3acddbd12ad8b6b440fa90779580673f92658fb51a7daaca6495db6638441d92344b75c4b7fdd73f05cd2201d04964460de7b5ae53486bc737491df515aa2613a59e2fcf32f15fd277f53bc1aa5c101847e3476c57422cc096890d0879123667fa457a21532e6815ede5dba2b2ebcb88fd5b5360c72b1628dffc34c77ecd54f25415103e93e3eda2f21bfdeda5d27625be7b44c2694c8ff51e4d82fce40aed5f72f1928644b75d3412348fcd64d8d448c41e28a838bbbdb5b37ced8074d18c6124253c3d5c76f32f0cc8bf0aac179ffa0ceb86537cba9a2ed19ede4ef8581ec7b205da39ab6a4cbbec01e40cf9aef57efa3c083fbbe1f38022e6156cd06b8304ac12a1ef7f2079c03b7efa556e1ac1af8e6bfd514cfd70df7ae3d46a5d963fba278bbbc892f203458a71f20d15a88c795dc97e609965791a3a4f0ceded6b7660139391273acc3a5b781070fce295dcccded561ed329dcc39c260e38be7ab41a1c59e609f82dfc4634b2b83d3fa400ff188402262d89c6284fab43dab9eb88dc7ad422a27771b3fa7112b6e1a0e4234e75a55cfc455abdcb1fd31a168f3ee54f82ac5d2166fa7812364aa522ac486ad21c19dc4959469f098c93f03057091d264c8b5ab61717400f83e4d562e54c64242b9ce26c77ecc3cdf60ad67f8f70e14081d6d9646d88da866db110e2459a5dee9fe03d4f3ad958790f99b7fdfac26d4d72da645a435e4b10d622a3edde83d4548f3d15131530e6a10cc27c2c67baf947cc84472ff5286936283fd84e74eda1a7e2cd0cb43902e793f7a37895996be7eb6606d2db199398e440eddf891f3d51410ece6aab7e4ec80221747b506c53a18a0bafafaa7260967c0a929d0f243f819db00c65692d4482e94a45c4f225fc265d9489bb0a4f893fa4f5f2bcdb9a9e00e04cc709c57f402da519a861c61e07a748e5052b5dc3dd9cfbf79ca310178a52fbacc0192b324fbb74d8243a281c4bbcbcb805268fec80b7da5e2871297ebc928f71dab21c71c67aef3f051b4c028538b4f0a09b960bf4afc8718bcf6d9520980b6706bc65d86dfe6f581f8f03c49ecde564787ddaaef1741aac0bc0823466a50c7ba1ec4b002bc4995c1126147d67598a56be87d2659ecd038c766cc838c6e6aa228225ae1b42558b8485e6647b81365a5979e362ebd325fed95905e8dde8c435b24d9bad16e4db005e54c65d87baf7f4793a1a17ab55af6a8541f310f0f8a7cae7d4655fe36a2a7a2ec412c1418982bda6e275e8370fb0ba115bee123aab3599bf8962601e9e01a0d880222f3d1bf08d8d7379b4ce5a61fa070d20206ed5da7712b31cf09c9a96123d7eea7a0e26d066f894926a64b7e0369c097c9ba19a25a1b35bfd41bc5d54b56be7509274a2e3d1519252ce6ad8261d7d47fd54b4fc17c524b732c4ae4536a79b87e6567c625db83747e30c6bf67d1520e488d4ff00b8abb1434a5e0909725e586ce84684a34ade125f92754eece96fb9ba39311931c1da29582bf72dbfdbc65b1b9ffa5e6e1c450c8bdab898d1948fbec64adf67692dcb6255709937c5203335a65df0f4f1e77e68cdb163597a9eaa04cf8053d4d287d4d31d4fd8de7e6304da4dd39ffaf745d73a32501cd3e42ec6c1d4a25164d1b2d83963385adca61bc1d7ce28a1a5dec95c479017ef4a391aeb4e5f25546f92710a92361439ab21ee0583857608d2e8c50522f5b5424ebdbde622f6d9d5ffa4e4fa366b00800b6bf286f4243ed9327911a53ab2d57a222f9af1db964ed58f99f717d1586ba8ddebd28fbfde84f3d2ee59492d6b4b65c844019488d7e2de8e3be15df5cc183ac81ffe62f0c5682a6c01786c1eca27343ab32165b3c19a916f4028d97704aff135268cf18aaf42135279bc8433c98c1fdd8ff861981ee4ab90706ab1d65ba2d6f1f7af0bfb6790772430e24b703127222763edb4685876dac46c9fe7a81312fc61d07c4a5b6c8413786bd105585787b8cc24150d5c01e6c603d60fad3d38a7c28a1a30e36c38aaf297c969ebe6cc0f22e0070263b5ab84a1252fd15d545fb5f65b68414b19f8b14f5e5baaf836f89b821b433af67baed60cc3f7af9d2ec3b974f3ea584b7c7922b274004941f17d3477286610b4ce4f84967f581cf5ba4baf4116f7633339a22b224b4abb180f588b1468d97bb8e98ef4b0284ac966b27a3862715ae27f82ab99bbe6f3a0c874683a23cab7286ff6bac45a99be9426879759b0e8c25045eab58088b8a38759b90217bbcad1ed166d3a018bfbc8626d5bc336ab713bb6a84ca2ce9d782c0a3dcdb31228c3d1bdb5e260432d12937e079ad786cb95868b14b397ceae32c66257df8b6fd90cd6066d0a10d45238de2916845f414760e299b8cfee6e49239a797feceeffd2dd9bc6850e87ef8ea89b67661262a5c1a0bcee965125660a94380a03e39195a684989a7fa37ebe81c255c1193ac7cc9dd930999ed26ff6a322d9b9aba53d3d42266af25b5e7208a5158e717bc38fab4d3369692c05f9ed387b37703fad61d2dacf7c97ad46c537d2e9b9ad4934fa1248f4504b0ffc73464dc0188724ae03a12410c99d03a4e3e91c0401b0772bdfe4ba4b042df36f805d74be3e76c7c7615756aa16d6531d303160165291ba08ff5f224548023de77b5f73e81c3a4fa2474c8f5bb8be0057873e2fa3d01178bc059b0b1d0afda7d1b04f560bd29cbe73c495e4808e08a9f0f8af57f89018b768d72b52ca3a23664282296b1037c4ae6805d5bdcb4e04088e85bb38e995d333f100b424803fbc81657d73b732858330668b494f077ee2712934aba2800efde58e635d84c02eb13a4ec28b3cd5684bc1bbb3407dee8aabb4894f5a7eb430a9e2fb596be4a1978262a26eba9fd9bef6d0c511dba0cfaecac91256022b989b332f8e6dfbe6dc39740ca8b8eae5545a1ba6c3504f0f742f5a9a5b23c797cf639e7b3cc8105b15cf4c600b34fb5eee6b6c4b0bc06d5554a47e46fcc93fb41201312eae96e85ec4f0d159df64e88af8fdf0a51073c90b125a623ea84be093ebf64322f93f06991cbd1dda813caeb73722e05a45aef982fb1d395247eb0ace323bd8f6682674b53826ec3923266e8afa2116769e4d76189ad5c9cb79f179a0355fce61dd0193f223b7da28b020f182fff4c374c5c603f9511adbf0b206bb5ca6f891054e2d9299be77f54ff72b60d438fd56e5b354f9fb8d90b4861ff8cf2f53445e67cbbf9ebd4a6a87665a2f78935adf9aa391caf2a925537e3e6c1a5b687403b53bde0098666d8f610fa13f2bdca03d887d5fecc9f3e27d636b2e1dd2f6d447a804362ae4c2df67bde89b5763ec11d635896805b778aa6db7f0212bfbcd47cb8cf4bd557f921784ddf547ffc9633f0e9d3261b49361fe2ed973ccc5ecf62597435893da109d81093a8fbce46de0ab4b0be233dd59da90961ea53b8937d41eeed380ed8aa8f2d0669fc08798fd2381f8c11da435a44be10fa2a121ca28ac06b6a2221c73ffdc538891acee1c2cdbe8551437f079cd4d72b7148cc7199282c49e3eef07d70fb0c982f54a9ed184b1bf2157a22f3b3327015b4b022a7b71907bdcaf725c16f11528a19e271687b43e20f3b4f7333d7ff9159e51fa54b890cb2260a4f0d4c96367100a585e4ed71dda7482e586030b18293cda058e657c6f583bc042624ded45beb62caf9ad213528a4fbdd734bcc82a60598c0900b6acc1b02fdf16ffd4e337bd6725c77e10f99d2e13d76ae1df1d085bb7c98909460f159329bec3941dfc4e31f48ce76ec49d3f600b14d5f0795eaa871745cb6a0f1c02e4c626121e3c354bea073e719fa4ff9d5e90e8db6e8ca410d2f8e2437b5477fb6e300233bcd48d7f8df45c3548bd0dff9cc1ca9ef34ff3adfe35d859296441783b119e951617b47498863ad2e00601851c48cab2592df28108582692cbb5c0ac48860539226f12652f5ad4ff011ed242da59409ebdc3e8b14dea370645a5ae7f15b718a5f53f36e3802e11d2b749a64d10919354740c623f8c33aff5c9235d580c344fc88134d3e1beaf775579cf04679c772ff7577ec5ab59f0ab53dfd8eb4486b7db9cb05ff5dae765afe544bd171140b74c770f0509f07c7e9a96c1c8864722873748213f9d2fa7cc069eb6ba0a6dffc2585cd304dfb149b56ad9bb6793510615e972c07a40759ffaab43f761e206c5bb33515c21d71901137da76ffb3aacc83fa841c799f37b590ec812b2e52cd51cdb186711023c99e63aae6133ca4a72f822378e256553960744111fa4730e98df18567c641f59fa8563dcc2c9644562c7e1fd8cf8891b8636d763d66c9ff54ea784eb87e9e340ac9adfe2b017e791b62f91874df7403852d2fdb48482a03970765b35ab7030a258d55adb65245d06613aeb032c84bd73209c071e8cc291d2d579bee592ba4907347a9b9a18b2cf1b26e8d85d89bec26bbbe269185410f7456f9ca23c44c5c6917b8415ac238a4228ce7ce96636ffa85e386e634283a471140a91914970ade4c54a979ce446f3d630c60f7ca4add292610767acebb29ecb3502db7da3419848617fe852502bdfe4c95ee07e26ce2e7905201638b0c64a54e9782fd40a52e6b37bcfb8daa6a64da60382c4ec28f6c6e6c8d9bfc97aeede3747f4cc317e874c19172bc9919a07354ba268754c51a565fdfd9ffbcea506ebaef6593624c97db3f7da35a9059913c26e60efda2fc2b700576c198ec92dcef7fd260d3d82ae91d45b8fce52b187c559643a32285895e923cf5e170400ce01a9f88dd0d9c2911cd78c632014ee310a46c9ca2ec219128b9ac0dace78b7713022a469c488814a621e241343d408d2ac77163f9c1a3c2d28833e68f7177463a99fcc4b6cc4d7025a4ea0b6a521f219f34bea67c3102a90024ea52e3ab505b9e6ea9ee2fccda6d0ba75059721565fb1e4b2d69493226844074e86ff27fbf3de0da86e61f517dd74aa69828c126f12d62c4172c86907adb64f8d2ecb70b70815237dd937b837330371750d9174b2832c822cc955c46183b2bee5565a94d79b3abb22267fc1414c12dffcb3be353ff05e33dcd4cf6fded75635ed3df1f095f88c35c2ecc605a3600c62a2c503babdca2276d92115c46cb94eeaa7fe450543fd5dfc84a409e4efb5ce20134dbb32e42fac000ab8e60d31ae86fd897d7031ad84006ce9b773ee68a52d933dff95ec9402dd7eec3398857082fde09df29bce5315c08f1ac8b63c5a1452f2874a386519493b8f8c5c617a4ce5cc7525f3a39e2b1552f26c21632b411cfc063787fa184dceff17a3d2c9e1051ae1f512368bcabd7f30eeafac044493253c2756ca92daa291e8822eb2bb136312030e781f31ef3e9b6f5f0cee7fb3b2948da1a5b69b40a600c4839a2f2c0644fbba225f328fb776ba47c090623fff67a13582341c9932cf0200093bf655387beff683c9a86d400e266e2b7dc8f4fe349d2cb5765326ff51f44454e99b3c25806de32c6e5f858c34930bba16d8e93f326d297ee24347ef5e9e48851f01dbd8996d62c0decb746904a0aa23aa55fed53591ea97a6a1d9798f609bf68a744beb319112de352a0b7c1a8f1c3799d144be6f72d103128573a3c4ad5673fd3e07aac4224d698349d8d7a643461839ec7a71c7efc8164db5e378fa85ce60435a09ca40490b8bccdb382cdb7007f0979e98b665bbeaee5ee2629b6e797f4329282f5b7b0391ecfaef0a205b46e112b84b33591d3cbb11b2d702f1c7d4f5756b6dd3e8e8c1c9fdbb6d4f9f2d447bbd355441fb5dd8fe59dea194419acb5073507cced2dab32fc926bded213115c09170dfe4a58feb22873c9f96f057e157d2d52cb8fac20e7811767d357ebe9bedb743e3c3304b421a7194aefecd770a620822b6c1a1383a808bf778610e6f0aa37cae66e9320e9b20a6cdab8b153d22868b438daf99a022e71a522b588c50fcd8e2a29e79ffcffd97ce594a381db0b4391501068a4c644fc1e14d274c47489b7716556225a59a0760f4d5e0b72d2ed7ad3338b46ab36a1981ed0ca2ba9fba152005ad945635d83d7580134558fb22f4530f79cae5530d35dd1df8a7b29d1387e22ef97e0a2484b3533f30dfbaea0e8aab86d1b0eba8e567d484de300d38e00660953c5ea612fe3dd9054a827efd52bcb6e7b9179cd67aea592c7fbc993bbba9a4a03de707f53492c56c6872d3dec65a53e8a82f578e8d631454e798a5e170a93074473ab6382ab78bf9fe1e3955ae35939092471b98c6ef12aedd2e7551c22866758ad4798ada41e7bc343401ae847eea3d2e05691d951649e522ec96928931edad522ec793e2e5694d8d4d55e5736cb42e87ac5480bdecdc681c597db222f25143499bf1823c0cdde5dd403d5c6301def3b5921231b9dd46973862481f54c878ac19e538902faf2eb1002738ffc729608208fa37d6d8c8c527dc3d6a91791b667a51858eeb2aaad6abf52bcc5c3470cd28764765e7771cbfd374d770aed0f77f56bebb897ebbc850ca3d129273e3dbf474da0c874e9052100b60d236d87d5ff3d7ed5fc682015f3bf82b5dbc8088d1671aad0cfb5cbb70e49df13dfe550e1b186ff761ea04b966e0dd4dd642afc9f24234ed6b47d0ba75ef3188d170f8d4ce6313cf3c6adcf4e6abea52340b92a099da7d3c6c816c596602ae5c31bb8af23f19d16a90532aad160aaee96d9407185ca2fbe1fb9206c954fa183bdc109bb974bf060f196fd28a93af0faadf5c85280a4c08838db5a722ef16abec41734249f11cc59c164b4116ff262446d2f2155ac90585cdde68bee37b8bf27c3b4f17a11fce316937d3c143a3f00b9019c197cb5bd3a1409bf235a59fc210e6bbf9a233e033d3375fc47c5fcf8a99185b97dcbd3456f6dbdadf6f3711867e8c05c9870a681ad81003ab6bb4415a01096ad6f781a5a56ebe1883bde77fa349f77a861196f34a44e96a8b57ff8e2d225e01372c3551ae5934c6fe4e6697332963e9030c5c1859096455388e57a4965ededae71d33afb55755fbc36773751232290e0bdebe843a150f92ebdbc279752c5754435c3992f14c40185b74b8e08a1028843f3f2b904591595b2ccda239b596b4b824b43b241df8d58f46ac71b3f1457615cc7e3905ccc95d61d51471cb2da7c750405432f5c3c47e8b64a48e0ea5f607e2f34493a1fbf64b760951e05f84343687d2eb000a8e2057b7995cef531f1c0403d78981d029479d8179e55759b53c824eeb0634dfef56343506f697a4747a4a24fb32666365c7ef5e3a5aaad6cee5d9b97928457c35bdcdc41487d8058c569c2f1a1fbe4c4475dc65214afa53154a17c6fa77688763d047ade65f50b0dd176accfa05fa72ab2f0b7a548dbbae52b8672b5f5848b43e67aafdfb0f29f69cc799401e95ba8309ab9ad758ca88319412cae44a2fd9e8982d9d730bbffe12bce78e8519211659f81efeb5578769683e1e41d1475d3ed0cdc7d7a1d8df99751d184981f403f4ea618fc4698ab7e645383652d3653333ab83fd9771b7be6b276846df63f211882eddb4f5db7c23679a0a386ac767bb99d04bdfbd58f79e38eba92594a20c01ff2d46ba767769491548a18559f41354a4f8305ec9542b5cc687e548ee91531c274d8ea88ae7184af2d3df9b2ccfcf5d3e9930aace58c3fb0357cdae3ca103832ae11666d83a5b034dfbf4f49b837f4bd3d441aa4bfad648d291cc93f6129003d5c2118e180632de996e5a790d6af622f93de8caa1968ea610b47ddf017d565fd44d69e78d55772ec62c1eabf51e1c63d833ff474c4311975ac32055154b820b2a5f1a6f1c7b8f5df31515e67912b57dd0668a0085c46b9d682aec831c37abb99c751aeb39e069e1c1b1b06c43a93c732624fbc39e38bcd592587904063d4774f2310754ddd6745c1babc753fa972ac6cf386529b199f866b487d65b9e3c9c237227f2140e88d84f517557d404951ca1325999975c3e923e55228b15eab89265da15d402fed5ac2e8c6b8a737bdcf45204c0cf3e90d9c0d7d756c6818b7c03054da8f5d2557ac91ef7ebac42dbaf647c470f272d0e2f56821ba4b7ddb5a7aaf1595b0f6f6344fbdbe7f2eaa0b34443ebbec9862886acd27f07b81e00037a087e9fef4dc155f72fc847a04d9590532ccbf3ac1bb498b5b81aeb302a180cea7aef50a4362eb81f0b7b0bfc49a396ae35249d842b6ec6288748b0132f4f549a08c2dae72f626cc9db52845c1e4f4ec890ccf8732638c275863c41640b7c3a770949802a05e8f27f509aff58585ef83dff551e6be26397ee240af95170ccaba09f1f64895d4217220b789a57a0ac32b8dcf58a6ce0e417f201bd53122e684cb1440b39fe54de58d3ca9df51cdb5040fb2e5ae29207b7540bfd761eab85274c5e39c87494471cfdb06b06ee7a45d539f713cf54e73af526765833b7f49c2919f4c525b282c15792deefda20704f61ec307e3ddeae482f406f1785e3330dc5d2ac03b73c4a12f3ea30b6bda7815a60c3a40dc8e52e5ec0bca0db25bb11e54518cc2683ccd60c3413b8317afc8deef4d16d1d34b89f32aa3e7dd8218fdb243823e6f912d5b96db90d93efa32e003955c1ad7bf3370620f39c3e209d9b287acace34c760fbd8326d86b925f2184f82f8dd1eaa5a6578a5ccdf61b022c5c623d2914af01c6ecc214766e30ede508342fa9e62b04164550450f343196e3478322467725474f75f5b98dfe2f1d3c52df1bc95aff04121dd9f9047b0626941983c5049639b7100d536bf1610a4e9b2929104fd803225f979965940821af0ce1fdacbbff1a805e121fc20bda2aa87d131afe92927db5b5aecf5e63ced8553eb788151837852ee30231fdc0f2220e26260229566fb51a68d4e84aef7a757366d62664cedee2942c20d0189b51eb97be988ed64d5acf86c82b44beb14d34823a344b841aa936cc07d2f39fa7a8fd1cd975db649f84de6344d5f9a8b88c78c5fce827fbba60ad0c7590547420aae7c298b1ffb0c37c41fd5745d5c8b5e4ab0b8ca6e9d8431089dd2ec2e9204e15105678b8817c63570ec13be9a9e04dbcda8668fedbc8a7435501bb6274ecca34f86fd31a009e784abe607d637070a8d0bce8e4a957bc060f9234ae072e8967db53543f415d7dc40fd05d1c2a83f0c257af197933e443d6bd5143d4810eeb8a0d95186ecb8962bd4920758d5e321866a94c99f60e8a8f48653c7e1bd6680249c83ca8b8d56eee9c15c214e779bce0f7435481e50640899b172b946fcde02095c2027c106eded3f4286440a09e077215fc14311c921f4e922f4d48b55ba62cc1b3dda7b64245756bf206211c398dd1375c51eeb78a990d3f9314d95f37f043faf503a616b078ba7f7b2a12b1e753cc32aa115691e35073c0bae7fafe2b85b7d2cabd2efabb173d4a03a97a94dba0b283c595f114429ac0f16f27f95bf75b0dc4587f82c542906ae48b83bebe0f16b5cfe2d50748817dc72a4e083b70924199edee8927a782ef795c9268396eee8c7cb139757a9484de5c2620a8e448d20ec61a835a28474eb6ebc2693d7d36f33f86c909d846a8509dbcc7fee7de2ad74f5145819e06802f97dcaad70508ef277b915cbe95b91f92c58788e1789c00db0a59afeb7448366fa085a5bed5c3db7179286814570390370ba84f491b3fc123cae1de0a8ebd280a07dc616096247fd3614a5e3df0d34919087cb7126727c13312e7719d08e5de49356c7c35c9c293855c627ffa12bbff0434ff59497751a49574b0d0c2b1cc38c6fe97ac6c4fee819275b5acb5d72d46096d0c37ab3de734920ca4ee2d572f0c9929c3d46bece0b34e8e82d07aa66eb247e00957418a103870081677f21ff4f0a5042b40a370aad2234973ad18144aa27857c0ef22750ba136f00ff94c79a91696a4fd8e04fe6017c9c2ac3a2e9eda628dc85b55c2232f2557cd7b763d2df3689d6d9fa301dad0a5cc7508b036cc71f623b0e6833bcf1468b1df835e5cf8a6ecd5d3aab0ea1e7f6477bffe08dad8d4ccc1c90b5ca89659bf779f4a34a01e227fa21b4598a9ff70f8a5d90680ad6055271a72076a1f4770ca21ad948d213bcc33436f93974a33c0542cdc023560609b429df2ff9b144d287f32cf390733cf341cbc746e8df2bd2fe6732f17a41a5b17038889f445d301dd44d0ee3467bfd717acdb6b04c8125692c5d79b878e4f0f5d71731d757f2b69879075f03d47d46dbfddced474cda8f18fefa99f7f61cbd45cdf4507eb084b0ca9adab2197d7e3b43000d100646205870858c25afaff60d4ab99f5a5b9c3d2220289cdcd57efcdc6b2056583643843e1cac758f663e8095720e08a2f92ec951c8766b27bcc149dde34c1c7ba93fc2aad2c4d1ef7e2b67201009704379bc7322f6efdcbd75e6133343e8a4b36ad0eded7fcb887f5e5a782526ea51be0f6fe7b6225e1fab6a666fe6e4d8f70a7c44ae59ae3650745f3516f9b1665116da1243f1240aeb6f494ee6f7124f886c443a2860a3676c72aa471e6f9d1ffdf45c7828ea7a5e79db035f48efc5827b0119c76163757118086af70390821fdde59f51b8a97fc3a241ca8774655268eed88d21c02c056c999912d8c7035c651e3475bfd49a64673b60ad96f05749f3aa8f4a9f0cb97ab6754ff50ff7eb1141ee7ad52bb95c19508ef2aa334b24090ef06b57271d33499f4cb7147095ffb6519c71e9f7c2fd9a2e9963fac5d6e938a844ad8351f0f02f41a57b9e4995a651a778f65d706a629d5f0dbd390bb3fc80638e9f3cba1e59f2db4b48afb1b9f1a781cece776ed6a56fdf774c02af6ebf0388406e3538d35336f15e4ca486783942a099850c15ee941f25914c50d723c552b5b5ad3847c5f826a916c04e74160fd373856b5c454c948b165b370878f019a03ddc1a1fa2fd37db6b43c22e39289f021f42b24389f6e76b4cd2a6307d6454f9297e464ced0929bfb95c317497467c75f7d52e97ee33f4f2fe233f8d28794c89fc63be4bb2571fd90681d027de8a576e01ef5046aca2c112ba40dc785be0b48f241a5a9213b66bf906dbd51b0e4fee91db08357502ccf4bc910213d5f39d66597da13c62f5e705467f00070357b3e8e53361136d0d06e46cb379ea8d8ef98c37dbc266f872746d77019cffd9433206bc051b6c3f26b34d59b9fd76920e37af50dd1834dcb957af57c487a6a1bd9dd364df0754447261ef1f407f1d42ac3e478c1653ea1c59ce07fe03558b58518adec73d02cd64dd4220be6d51340d14027d9ad4234ae3f3ff40ea2fe719f6c07d090d7e47ce528c549b261fad720af4a31b1786bdda3bfcb5e74687c470835b5e90c5dc846871300a4d7389e6cf6ffab3fccbe8c1ca2c76f168995f4b875d5753d2be809e0cc9b6db1fb4230adc97246993bb81059bd053243920fad23260e387ecc65b0458554365bdb4751a16a1ffd508ed175ffe4d3935156eb0ee96559220ac27c455c9cea402e90e5ff1811a24f25f7a4c065b694736e37e98f3a01a178dc314a2d701292f32f8b8639090de16fa369b0c244fe160ad0766029e579597d9f3aceb550d6e628dd89e8f7b4ce18eef1120bdc59ee455a9f4cbe2a2f2203fedcfc651e00b3eafd3c934a19d839173b3bd8fc8c715c2a7bc0f965ba144f4f5f5b9096f831af1d393cb35a23aa775438462b94c2a44310c4effb306a943d89ff7a279dfeac632855433863dc2af526bc25689ead1344fdee4e833944f33adfc6e66945d84b3da4b464108eea56590fc2ba1ccdb667ddc696a991cb42c0181d1eff57797cd4959dd4170064d94c76eabd4336a50e67d873a649b414c47a40cd396f0104249f6dab1f49d22241900d7b83696eba6c2a114cc304ea8a6b2dd2bede5a8517091fc39d3770eff280bdf68badd172e3b122ac0ac6e161dc3038df06cd0a3e0a7f72a6e638ced43775576e1ddebd651c9ec5985c4baf1a0d28fa21e524f5cb0cfef2edb6f2ee714e03def39b35cab5a2a89903a5413905dbb91d0bc5224515a65c0266e5b223803cbe4e5c4e524b2c485a49d5aae5843ba5ba04e3440618e8498213a0ef6f4789edb85d30a7d985d140bdf45356b28e63b1a3987c333c0176d677bb7ad40a313897e3b4459f289da457fab9b03cbc28bbc2707fa1f17dde9f8c64623da91cb54017ed9d4e277d8646c6a17dfd95ddea6c2d0f69167b8bba89fbc021918663c9d65d5e9a21345a889a3bf6ebd4f0af188b5be7947dad4797f3ab3044fe976bd0eacbb9560cc09cf408d158e2014ba4ed574db62c6e96a4939d4a81ca7a7853ee0db1641f252193e5e8f6aa5e278180c8811fe30d571a85d32b339978f4b6d76b7426afbdc24f54ddcc97589acc44add1102233342b3e2bda1df05bebb5ff03acd0aab8bc30eea3a3aaeb04a7bf9a96aa81290ed45d0c3bb9de89eed344b8257958e9390a3e03ca134c4a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
