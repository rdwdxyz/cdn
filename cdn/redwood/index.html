<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6bca405de8429d8779ac68a98567d4d3bf58e6c227dc62376923175aa6feeb3e8348fa5d8cd68f18a37b31747e311b4475f8bf497397fc566226950c3780a5e5fac05a309caf7831e6d69b57967e2b2d7f7aabf9d5cb748ed810dbdb88698650f6b42b377db1753ef515ced09d3da338db2c9c783b60900408804256bdcf31780c05afd3fecf9bbbdf50f4c9e166286e8978b57828426dac275b023bc3e87a1e5f32997c27a2e075c764a5100b9042ad5e88e1d4ae5e25390c13cc20d6e4c08a02c4e82fceef5a837bb30e1017b62b6a8ee0e0e6a58b5159089b11a9cb279ffa07152219d6a236182d7d29616612b8bdd4fcbfb3e3234e12d8b4a32dcd07251a12c1b11f90b2baae1dc79930dbad23ec451fa3faf261d9704c9f1435dd0463ac2442b4c0aefec0034e0d5e84cb7ea44d352ce7a6f5ff708ed5cc5b13faf07807e01a8fc13ccb42c9e2ca52ddb526a5d6282f5c900ae75f787d1d827f3c8219dcebe1ed763ce18204a1a8e2a51e0456d26cbf894ceaca89a6d8c679c86d1f8cea899fc3b16a60eed37870e0ee577afab2eb975ff40e2a09edbc483766e870cb37cb51d984ddc728fdeaf9b1b6c1fe7a81ccf12ad837acf0cbc96e3a151668e16406381be2883511062ec52c5e9823a7e2c1c8601a591d460a840c5e3382575a195a3259001f81a1e00ac609f91c7d507aea2690120673744f85d7ef31ac307fd44daba52cb101d8d0d3aa84fc8c57fada7cd21134885815d8fec3b61d0e41fb034c5ab2022ed6839572df3e172e4159526d54e216c0c9ecb86e9ed8132bcba718337782a222d5c272ab5972eeacb02e586cf3e4d4097ca18e63eba8f4c10a784bc55c5f0e38ff036f932edb37bb8468458239e55de025add7878163aaeb6fb449cdecdd1bdc1c798d87a7fd94046fcada28c29ae2a2fee8c1d20e00ab03025eff0c18ba8cced08e6181ea9cb43590dfec62d762503f41383cbb0387e05d3765b5dee1cafab4e20ac41f671334b33c1bb66c527013e96a49f2b69531205ea2dee5b64f25edabb052879e403d7fbc332834b5d8e6394797397c355eef4d07e1287368bb9105033d26938d16fa4a1f55b7d488aaf7d2b5a7fdfb5e12a2fca5a2c2cdfc6ff4143e753c634dd40e2e61b0f77149f1036d85634580d47d8c7e64f3ce4c616b11124009ddc5dea946d00f5f9feb0166037b096b95cb419dd9619f28100ebe37a5fec98ad37374f69a67af5cf865e923d131b6dad1c4d01e69a6aa884d985616db43bfac05e3de49ee1539f3518b87a83058b8622ea493f470d9377dac8b5dc7a25bcc98a21d39d553d6ddc8179eaa8f09cfe97ead5d14d94800a2bc14cf29541224b7456a273fdb7f33ea70d044406fcb5003141b680b9d94a40a3fb92ec4fcab92e4a73ef28e6feb348bcb4916d043d0291913da6bc82b8c310e4714ecd1e3932da90ef5495a4203505ffe6e102589cc39d95a2304154d59e81d8c910f2d055bd6358e09c18ad5fef614b1717077632f6a0b9b786f5812820f8e50dc3376228afaa2088d505fc6d371dd2cd4dfc96661378e2def79ce742f397ce4e8a484ed95bd440fdda3ebd8a14866842c01bfef7d68ffbc5092d62251220d4d7ff0d9e849681161e220b10f62cc4fade0972e819c5dcf99450ba0f2befef43b59dd52c45046204ab4d90333e6bfe6b05c0d0c91a0f647f1f79006ae11a9830766d56dc7c56e8487ff845287e108f52f399f2a3fc7d1ab9db613ff699eb42a24b95a9b0f499bb3ad892d830495ac69c5835e53dc52d4552ed78506d2de57faa73f9100499d3243f8adafa65e888d254b01d23f1bc7c410af510481a97b642947574f78d8fdaa3866b6e49ef2a8c0e079441e6d953a69954a520d28533cff285d5d408462efc6a0dd451cdf6facb6463bddd963f4743c73115805275707d06dd3dd229639c568a68d95b9ce8fc1ae71e1a67e224e2b7c5e24d7a8d9ba362d66cd40f49539f3a80feb6b8e7d2d00ee9dac8019f1ede421e22ee2828087b8ff9730e8cd222c3377dce17521db0ae16cd258f03183a8120bdc32e033f4179c7f8dda818627989ed70a9c58c36543b152e33e73d82972b710267b7d5a4ad96110568bb208f983eb82f16fbcdeda98054ec0fb5422336fd8e60967b21f9b058cb335b64eaa730c9531093f7c074a63d91d0eeac1010529542d13c3aef4585bf77e283415a02927ca676c92d98ee23db26576d442f65f5db2baaf22d0d59fede6a38d43ea8c2f91529a952930defbf75357f4a0c5edeca43a87de21a03b5bdfccfcabdd26d0defdd2dbdd83da82da8cf1364b593bbe17ff79cae0ebc2d227534db50ae139357bfa8fcc43c574cd07e0c30ce63feed3288668c3c34b2876b42f9daa5916c186023f3f3ea5818e09a1a486c16dea461688cb485464f25f096e3d288684af4368f785f145b4c90d6abbcd9900e2cd30e5b79802c017c52192a6df0d3e1fdee6a0507918482e895f35d033d09bcd69dd01f00150866d64494b9e72e870d3afafb311b255cc1dd0d010719e8123bb63f505819266025d19b5a87cec67f9e801d6e4b2d790550d99e9793dc0b4d964b49f05761a0d303ab627cc78decafb35593275c1e83aa2b5ee9812e6755805c09a9508204dcbdfa8555ac8ef446fa66256f6186ac92a5d5e3170232e0e8e5ea29cb97442527b71a07be52dea582ecd6959cc2412498ef307c34427044e0be0531d4dcd60bebe4b7e9c7f9c9dc4df28ef12bd897512eb845c3942a53d143fb180c7c62ea40d608a88b385a310428a928683ea6b576f7300ebc7de0d4a00927a0c9ad5799533eff358932d2f9fc15a8892d154201bd7404ed3874e7b2515632fb75aa0255218369b220d3c5a2b160b6cb50d15aad900b60c705311b8c2dcc26bf152be1a97f53de3480adcad26b78fd6013592f58c0cae421a5857a60c0bdfa53c703f65530064649fe703ee85c00ac7ac2c8f538e66fec59e567a0fea8d8b57508c1ff962f33989c6c3441c8f35a8e924abdcff669ae601ff7610cdc995f4fc52d7736f00bcea3fe531950456a7036eca0f524c2e036411e41735eca4945801f5c0da27852120d85cd6ed65465b71ab1427b4344258d4f31b633cefd16abd044c1f47fcacc23502f962317e76edbbbf5f8b66c852aa7c1029630e5f682e0c066ae11ba94f7fe587a972b44ac83df875377e8fd1808323b1452e2f1137864fd912bc652b14a8c33961c7d6c4b525c83ff66cb0fdeed9ec9d3860436ac0c142c0da0eb9698a39b2836c37fe0c9a44e66cf2a90751e2d3470b83a267302e56ec98a6764d2397f2774ec6287ddc0388cca88d7410a0f57a7e94ad5a8b169fb5f0affc263d66d5bbb996626db7a22428c78402203a5bb22c05dc953ebdf4833fb4a1212b81f53add7fbe3eceedbda2ca2205f0119d5c64a6a135722c5ecce4304648f7a791f8f371d053292fe54c0e5e1f6f927b9f689b273da1f434445494f2e2ab42272dbeaaf5e41602907a36987090c0200168b0830fcc415b21a28e618eb5080dafb1540f3ab877f16223bd495ee3adcce99d388c8fa441e286008fdde01620409bf1a5179779557120e10acb5cdb6cdf236fbe8d1dd877c761d6918a684f5c340a4c64e928e630c69b850b2d7f8185442ebd8865c4b44536e2f35a8f94946850dba3d583f860fac7a08031089bbcece3ad6210f34cfeecf34e7c473de1c88d8553e4889598e941aa82ef4fc949b3f99a6627924dd2763f3711e390a6ed0478cb528bcb527a2d4c408f47176704fdddff8b6071639e76c75044f9ad1b1716baabd38b0b0ba75176202664fab0f86850219e80c1cd3ca3c5837d56718f08bc69e3ac38ba5157b4de862e96a4e4972ffe458507824410a24758bee8c2de3bfaafe9ad49296cc61f6ccabe2eabbb12ae5ee9af92c867904a80a36c9df7c7a5cad688ad1ed799468f76b7fb1cd560ebc0ebac746aecd58ce196325e119779df7edca920c9d866b90af3a81e4114c5578b301aeba244a0cd1f4d7e449fd2edd9bd4532dd48dab655f376553fe22c6559ac9cb5626e9140fb7218eccc89790c2c3ae54f811b78b6a50a7f086fea7ec49d0eb41d6496c56671c94c54f2343515e7d9f380e32660161cc6191ec79d03eb3b1c4805ffe479cdd94d868dd58a4139a60dd8db55f04137dd1d08d52bbba1f5b81f5ad2009f08c1bed7a09925bb05285b70a57c1f5170352367cc803226a229ca1c5def6cc0c4c17017e96b6d2baeb88d0e658b543a089e075ec860ad9dd814b4ebc74245f32da200ca75f508c698ef5b1b1039206c5240fd6cf962ee4a1946b43bf08f8e0878dc83e3146a61a91388ccd9988a1e71a89744aee8bdc0832a07a0ee5e03bef63360d53aa43c63c68a1e6840ca8df5fb61f2aa42068832174412de40881df74d235c0214cfbedd21a25ec85a0f5b62bd62b7ae3eaeeb41b4ae008333179e1b227cd0fd694f1cd3e8b9c2d9dbaa7988f9f0b79686a719485ef354a05af1e9b333111752b13ab3dda37deba73ec373d826dcfd0c6f81fc255b8c1912b58807f7ed00797c3d962261dda2cfc7321a9df9c48d67e15cd50ad2d4783e46f40028e4c65a6f9017f0d521ff524c82078bc767ad03e283acb8f398cb3c4a43cd03f44a0319978b81bfba61bbf05e0f2112d281b9a3a65251e3c191be78e87a4b1c190484aa062320f3549ea751243add889792d2c2b57cbbab258236be2d45350b0797940ac473862a8ae5bb5d38474a05392471b2bec5dc05a3382aea7c9b27a0417d225017eec3ec9aeeee494c0e94e7c305e95588ddf4168de0c49116cffd2dc612ec5da2de22af510900bf71168b10b6139c9f6cc532459cb620a34ec87319e1173f6285517d209e5bfab2e3abea61b9f895109dfdb0ddf95eb7fda529e6927954217c6fbd4b7eeb6773aa2b028089cb88e9cb7daebd1f7c5325b2d9e0bbd6399d27c671c9edbb0d22411517cb009de69507543df2ad6fc2b1900cf65cdfdd24906ce5155cd540bba45b9437410fa4aad37b56ce66636ea684db38094d9ae0b6444796dede4d1c0f90b5ba1891fe4cf90285b6ec9f68840fafc6533000eb834f2456adedc21cf2e0a580f05994a2904e7339cdc96525133c2230e16333876803c119dce4734eafad74d6295f1f4eb0713f4e378b5c174d69278998708505c40abff366727de153b9858b7ff9d2aecd0a0665c7e5758c9ba3dc6efba9c23144eaf3530fc78ececc0d15aa3edd3ef385c457ac1989a9f511e93f0441dd41e6e696a43428862bc559786f0773919f89ac4c1555853b9eea25bf4814af6f6bce1166bb145565c5e8f6e67c6ce8a49e71c1b790699a0e5f966d9b627f0893f5eb50c3ef995d711d8f3d5c33757aca6fea3ca18da0da9aa9bc97bcbe39013aab648a3819e6b717744c15d271cf5c0ba1b9ff3a3340ea0c899ea31f5deaa4ee7b0f0736294aff510ba6aca2303e3fa3657b66c0367f808c67cd74e6be73c7d6d3065da5b6117f2a2b65ca4e22af2e258de4f46e9186c957a5438c2831e72e3fe8be77079260b0396e86b8f10a15f2fc6557fd0f1c88dde31139e619c3fd3bef1b2482f71d6be2f5ba70e6dc2588413526fe7e16ea8c7a4332e170ef20b2258a299bdeec00b8909e8c84d5fc86d5cccaa87721b95c04eb49288e1d4e529fc30c61a15fda2d1606a8d8713822bf7428fe67e316d58bcef0aca001cb204d088c1b3bb107f37df60efa1633b1f609aa2b84d1b12697101f272c9df7651b16ee2dee1ec1eb888446f90944c9ecc1db56827e6bffc72b4ceae8935597150ec104a4accf4e28507a3b1c59cb12d5e7ac45939663557fcc1962ab0536649cc36d0e519d785c50ed5d0997163ce7fdaecae822cd2856106ead32e9e48d30a14147765d214fe88d71358f7730ba7be62cd0575ccbf3b9e5c9678c3382733069fdf8ae2f042d32d6802bdc728fdb25c6a3eaebfa9e16dd17b8c045e6ace98ca25f92f4fbcb7282363259747a1712846f4e6f83982054dc97e0375fc6695114beea5bb7a001c5d2c164f1f4837efa4ce98dd4814d726b43991c19573a3e7a76c46a63d666204c535372ed7695b926993be0023063ecf891387e30ddca13d68bfaeeadd21789f05b184a04ca0ecd9ce3fccfd2b67c07eb99b19f15de8e22a47cecc490262d206a617c06d72583a2b808f182ec8059b71735fa0aa6ad940e4d54ab5358ae6de1c25470be761c64da32a3e9974a05e50c6d863dc480858dd4399c518762e077b393764559f86be6ae2f1d4801bcc29703f49bcbd071b152cd41d038ef7ecb3a09a48d8bbdda4a7c0296ec55b058ebd93e4da03de6875437edff15c060c166f565b7252f81cb5e57a15f31486b206a7fda43e7182f3d9e56653c83e21c815557227f2bac015ef397b19015acce5ee0c3ba08b4d4604a4aa4749d35580fb987cf36146936d23b23fa2576757499a96fe60bcdc97141c0acae9bc0092cbe66e6d4f38d135ca2ed997cff683471c98b1c47fce718e215ee2835eb892e303c811357a74846deb2bf66475c878dbaa8a29d29986c31079cb553a91b242159ae46394347eaa5bdf5f1549251824c14c8ccba2ec65076a80ccd7719fa6a1fd592d4c395e272c7d7772b7a925a594ce869899e90c25d675e009a8df1905a30290ffa29d59ae749f5c0fafba3d3431ee003c7ffe76a0948c9d7d136b6d3b5902e3c4e614927ddd8254f85153681ee3bd69ef8f3e451c4962e5e1417bf2bfaf225aa9f403dc90add5146527a4228d4010ea569b133798b717e927594d1fc59bec40aefe5a99edcf83fe4f6d983f1df30b70241e6df6b33a6b9dc2f7c637c830bcef4938a17f45d90cc6cb15fc706277348e891b7cb645fee2fa40e949b2166df1ca0a67ac50e2821c4da0da06fdebdb347efcd889446da99f7a1bad8ea6613c2b81aaa4ae84edb5c8c9f67152f3a8e5c5cba7ebe7ba2e08c7d4bdf9dd8db92656cadc7b0202db9cc10387e67caeebcfe70ac87a0f9545252887dbe9ddaaaafcff444d75e69dfc8740e63ced1bef0f92186b7e5ff7649faaf8fbc791c8f5109e9d4e3b92bb95645241a525e207ff490e52d01019ade0cad6b672c2dc141026d373c2df25d7cca2c80fc38e99fcc6851744d70b04ba1dfaadc116bfc3b9400cc9cf004543d0871f8d96796b73a3e15443ac066ee5a67886eb9e69abcadc406aa40426fde8bea059b6134b79126eb3e6742e71cc0f04b951f90efa3aed6bb91de703b51aa38617bc2986d9c5cbcede98baba62ec8cdcc5bfd661b77ce246a4b62fc30f33a9c12bb7a62851760962f2c4d64b345e3ba73e1d148d06cd06b961b555ed4ee133c590dfd36c375ddfc4f312817fba1a64bee7bfc6269ad9b036a9a48f122622a99eb84828dc9f69a5cbcf3325a0b29d1832729b0d8b1049f4f59027f62fe800ceca220c7c52e955ba5160dae2fc866a5808cf4c8148265f09a3de46a3f6e278eb676b18521b9b1dec51f06ef38558eeafbb1f255261088096c2fb91690006f1cb65be417b3b284e5d8540bc055a7e8d5c9399c58ee9e3ed4faf7e1092423edcf950586907b76473e2bcc9fd53b07507af1e034008b5c2b6f2d6811a1ec6d3345bbf572085cdfd4fb3e3a8809c1c489302fcdadcc4b9332db09f657149db3fd17a4a6c987ac1bb8106793cc6a5ed9abc9df0d8b9f595cfc74b341e8e32875614f2762fc7101012dbfffcaebf1724ca380379717e9aa7dda312cfaec134e67f1424757c35fec7286cf28a414e9f22f641a18f706443c4b8c4c8888eafed7a63d8540a66b8f3ff29e28dc2e2f320fd222118ca2e30000f09bbb89272cb92b9d2e466e231b96f02dcbb3449df5bb442c337ca24f66bc1b9c577d6b93c4bed8d536e853ebc8305958dd8e915ee764af0d19a1cf37edf49b985e6e782f7405da34ad6e9a07a1e9daac2e4d4a1ef39ee4725dd3abbfa0b03ce09ea4316027be262fecc512efd94b9c12a746f70ba38df4fbd825b01457c0c72d435a9d10be7017455736b1375bef050c5b790ec8db755605180d1ca25e159ff9c2e20fbd654ca5634751a91f1b83645e10f2034d25064876c551dfbd4a0d157f96cb7700b180d9e9775bb558bd36e6951c007119cb8445460e98ca127665f047483512cefe84e59a3e27a42409d316be7961d62d59a6ee67f76984b7dba3fa97b92473060997a1b923c5c83f53fc77d6fe1b12a319caacb9a72aa65ca6d033939ae9c08885b91124411f007a976d4c29fdec59cb2c8a1742b4e98c18019fe78e8787b85cf0c21557fcc8b3584c5cabfb016495733026557312091cad53f7f11fc273764da1d140160bc5f7faf4a9f75cc8aa5179efa071190098526db1e8d1c55bda79fb88913f916cfa397cc6f5cb970cced8e77f02f015174d60d21164034c57e8c4c25f8dc4b74c83e0457518d220cd9ec3a763e4addccbdeaf2d7be8d0c8120cae375deb0224641eae56662d909d37689fa7e670bdb9161c4fed4a07bb053a7d27760b683301b79f3d7037d76dd091a44395f2ebcda56413d535cfd6a15fc5e00cd9c3b3479a1e9e84537e305e5a9fd748643bcbe581cb9d76b6f3e048e7d088e2c9c99483d406f56788b50f49b8bd4b9b3dc1cfaa5c63756a728d5ee93530f595029d41f99988669b67e839937518e29725248659d96cf96d736282798fd7093294329bec92cd759e57d2bfb471a9471786c1459990249ac65a1abd43c09f0d6e4822e598c1e7d5b2ddeaf3f81575cf78cd49f9d810403b96f437017cc81c9e115e681f2fe9af88f7a55d41951bc1355ee56d4f3c6106322f91345d17b8aa81bd32150c74c6cfc18a1ec825eda9742dd9e52a09120f6516a6558dfca414dbe216f6b8ea59e092ab44a21d2016117d609c0d897c3e32414c197782d67fb6c05f850fefb11f82301c21a04b2ba12ac03ca59be1bba7e7fd9ec50618eff263deee683469cbb1993f4b4c23bbd94273796aa4f4065e219c9ec7a37ee0b1a98c7044a606cf22ce5314f3d1a76f39dbc1e3007153d2e52afad89e9bbe0d1fad8d52cf0292b96c8b7cb5a62be990ebee2883c43a57b2fb71aaa8ef581a6b623171f368a6e79321b52d05ebf0d5bd1cbc1d0642664f056dabb5b7d6e5a467bd41b858aca46e037d607e5571ab4e181b40a11e80a08d4361d931b82139eab94efe33c38f53d07b4de8e94667de66b2f07a70312b5b1eafe1c0bcf2199411d03a096ba467f86a424a3f8fbea5eaa2a63011d3853aa5e14708e52ca8a368138f7035d049a17c8b467ea7a7837e394282e2ae3a0470bcfd9702c1aa22691bbac377d3439fef0b0222de75b2604684d0521585ab406540a9d4c12927911bf320a63aeb61035d81d0574bb8a21419ef597005746ca8f4aa213821f2ee694c1b83918cfcc7d347d37664d5bc19ec3e9be25069b37a50733f54df7bc2ec583dc0f68a68a3d0bb76aed6fd206c27ffe9f1b3642c7bb94c530f1314c2f02edd7c391373e5dd9e6d0a318f4b3641ca491a77ce7cf33101c225eacfb92b7e80569ab24c677b3fdb9f66de84afa2abf14c17ef7e64f48cd0ef9645418b6933d28d93d44c0ef5c31f61ace26a47f2b628ed5bf8e3c629dd53a2bc2c1c98c83494abcf289c7ec3568f0d246de95561485f9e62f6751c3a26d1cb9cb8a10ad197b5c86520868973b9f22a1c9c8c9d54b1df6c756a564d03bdca58f4185849d0e3c62fbce381cf3fd7a2df173fc4adeaf6fedca46673136eaf284ca49a6a3f5519c592a0e50b67bce934b4cfd293125abf8d73e28320c7c6e12e0d3c7d1fa6dc7633bd51af4e7227ab8427a51d8ee6d33c1f0930cfa2e050516e98e5a529b3fd91a905d15205a41c4ee31d6d269eb21e0daf1db83c410ec040c7455581626920ce193a3067d750dd817260275c88fe0a82ace9aeb9ba575ef27df66a530263429145b7d5b09949593bb7c930f0b496958a16d656ad9098c38d4f83d10d3d42d619a93246ad8109ffbf75d34ca3d80d4438b42057a1db5430e862430d0204caa6b99c245d7b660e36eac6546e2a6a914c4e042caabada11c4d6aeaa735eeb7c3db91ef7fcdd5a6b50cad2bff80276098ed8c2c3e5b993ab347a70ab3817715cc178b4bc23f5ff9b7c8b2965293ea64dc063f5092df2020a81efce6a9c562cf380509c4aff267afba13460d809ea8dff247038b8c0349219159a0f2068322d9c6d479d2c6a786685b985649126b38a0b2ed468c6617f37b57ddaf043d93b99f879523f6de0f46a14b4087f026be2f3184f94d2b0a0946d683496c846bc12eaf8fec95a90b8d4b3b53a6aa1fb79be939a167982c7aa0489852bd2e06250ace20e9e7b463ac823f30662d024c86834ec88cd3f36cbce89f935cd530b6cd7475aec1b3385beeca986e8f305e792edcd2e56f901521c6abb7f00bc777e23445aec67c3f92b062011186ee265deabf2d2eb437f2328ea4b6a02b54461f07fa600bea116a65df6d6c7cab944ff09af0ba02bb6d606270bd785647f1d7974e822919e1b0925383d8a0a9c02cdd544a66e98350c961d1ba32526e80a6a20cb695b1cf79ada488fb35fd28a4081eed9fcae9a129254a55277c444c263a2c51321080621383b723e8575399c86c516a6ed1f8a9ee9630ea9f93be920b4fa8cdb19a31f8902150882a15cc16f6cc6690718207df8154e8b35e3532dcc6e8c4e379c9d6406da0ef13f59ff8a6a6406e8c44219f8e04efec672dae3b01cb8f459c049c863b74a2b82ce0e306c267c9ef6c5d24ef75dbc484b64ed0832aac0700110386f6e5fdc5307a411a44bd90ffbd5259a738a82447279aeaaca0d200809f8832cc7a6004548f10a8a6633da007303511a228db7201146a82cee949e648068df69a1e01ab183f47c3391632a27b8b96a79b173d761309b20fe64340e2d524e776785f010fab7387675ef0a154a22136104370c7dcbd741fab32898b99961f969fc74cf984c2e14c16adaf65fa3d1fc5f9c7728c57e45a35bd810cf2c7d7ad57cd8a06f38a7b5d7e43ab2d6b3e074d83c498226308b85b6f6f5128d4f800faaa2135e0ef7ae921219e32b8752f4d6f4f38b2456694f0ec031c3f9397fea1c8ba92d588e8507bc26f684dd6692a95a6f9d89ddbeb247009d1f91cc503da766a38e3b509d2d8aedff79452c239ad075552c391658537684642c88571a714ee01093256d2d19536344335a47ef86b10bbed20df38dc9e1565cfddcd9db0f448e8ab4b3d9a5f8b84d9f2dbaa6f8643ef9d973ea0a39e0b62218848fbaa7be4393d5e31efab19418a84e773900a0d6718f434faf0884b4898e68cbcbee05de59933ba3ea3603fa838b3c96fff83e3b4f2c95f215b5c899823e0e55da3b3f44d37b381946a6ee4c1473094dfbd3240f1e697060b9f9ec7587b08350a55665a839bcc31c08dfa910d1ae8fa7a49359ddf1df6129dfacc42cfdabb718116bb90a07cb5c733087cc531f5447759da90f7edda9151847af5bac3255c190bc9e81ff2d1a1314cc839dd5d3af72867112f193ba5813b3eb05ae3cb7060d7f15e3f22da6576455aa23c9a98cc513de652e1d78dd17d81843f9430ee4becdabbbf07b77ddf971b68a81292c6b6a87e24c448c8121f4146d76841b9897c39d04c5f93df83d86f1c98a1b2f19047341be4db58bacc3a620a2009cefac7aab04b95b7dad2ebed99541354e9e3eb891944f9c89470142ea0347e90d1f24a79670195d2eb4dfe7ccb3c970c8a2ca299861b051ac1d1a7b65bd406872c1cb01129fb8f89bf533b6f354ee07aaa2aaab4113803fc3ca1c95045a0b55c2bced3929d2a09c507b7de55e9c5a258247ee6190aaa1bb8868c204dab9a47f1a0a3d1f1cee7699397fc8231f55a51338023d609f21beab9c3df1e58d63e178417a2bec2d3540265676a629e4948333141d383e813e87ee365dfde3a5a0fab846576eddc283025705c4ebe82005edcfd606896957c8d40abb005ddb67ad2ed7d654df9df8a2a44fb094fd744d91ef3cefc2c33765452222495eecccae479014ed7557dffa0ad5d5e3c537727cd1ea96771f2b298d0b8bd480b40be9a53ef88ba179e1fc7c40591e502f737a219566f55590fb3224ecafc65b6f130b060a7f23f5489fda904d698a7b2cbf088ed6dd515b4d0843da44bd22d44f94ea5403bd7588c4b713e396366efc37f47815cf70dc3a4396f0f7d4a0648ce695337e51da2660e6433d5f739060ac1753751a74cffb12bac16181f1b7df9f8128ed11271d7c2fc4eb929ff35ab07b663faffca137f9f926bda6380ec04e024d722f5e961f5e2f54295bae0822595bfc5cfe608c4428160b04c9b599dbe145ac31417fa6d3945a08077a507873783bc24a437bb2eef1890f5e18431cda92021b3e6b4b55ffc2b809ba012c45eca4047308e24f2c7602612ca9afdcdfcc218bb428abc65fa7182eb6750b7b9789222600c4f274900ed0d5d38b43f0d32e21f45bca6c732abb36e7e954410ee979ecac14df87a5b252bab0c8fd2186bdf2e88266dad2cf3c9c945303b7dc62a5ddaf89aefe7cd39d53c8ea53ef9bf288aa90c00ccaf21b7a38d4860199144621ed6c066dc2fde789d2d41701719381c881440b4d755b0aa933b272fcb9263845fc52ecf4d7c409cf90f14bb7bfb9d7925e6172b01bbd2a80c95c1cb5f58991e1ca451a3bced7fd186d1635887c20d328aecf89dbcec05babe6946d57835ea5744afb2b5232e0cd08da90e78a0da0d892666b94f4b0ea8c6596f80f280545e22eb87600c3f446f118d04edc2e785447fbd2eb507cc450738322bef2b62d09adb22cec5f5546fd37af5888dc20b3c0fb01f984b2ed7253d365ad388933453cd0ab37269539698a37b4270c6bc05554cd79e33820361319b7c8d500507ca10b81f2388f0fef3ffdf3bf9a5f1cc3fea5356e45d3bfab0bf3a9b3b29ca7e3e718e4c778f3407327a74e3b828c90df5888d6787d2fb4e79c90b45bcda39ef263b5c5ff50c15f63f8f192af658f69f307a624001afa648d019e0cce0ef4353aba69360e3562a2cf61a55b0e36f23edd259f27cc22a573fa97711b45cadc66f7c49708cb46b62f5e83278bc5d160903e97ac38472c33da4ab76853a3fb42264f852f36dae2210704e0e2bea68eecfeb149865c2dbc4a309dcf4a5623df43ddc6bcc9a234303f782b630af63c550be988c6da973553b20bc5655ac7c61f797b6c389ebbbc4d4099a94491f3cde300a9275b51b71baf3973d4924a00c7bf67b3b84ce344ee727a84c246509b1f508dc89035978c9767356262f99a7251ad2b960451cb5f80e1170ac9d4186e78442c0703df39a46a8556c6a60b18fe34c262248baf12ecf591ac3c1039cd0cf9af642ca6a760e9e04aa1491c873a9893f45315472f24e44ca7a51deda4dc3bba9765ca0be9e3da322fc5c569f125006960b6145da8517b26dd4a2d32e0521547902d3d201ae5c6a39a527547564f8f7c02ba4de237add1d03af9def49ae2c71f3ab417b56fb978dff17a3bf3b6ac852b8f363251e6f9a4720bb368b2ce102bab5bbae5243f559f78093354f8f47c2c333a7969925430c3cd2154324483f180e5ef9c4bef3db2d93db04743b5668154821d309a0745e61c06a3135c63176dc5d7f82a433458e70d7f2d4f34b341e67a3e847f277133211476fdd3dc3e0f1bd2c868b40d7891cf6a80c8a74e43c5a718ad9f27d7ffb8b9c17e289a2790ed248519ad8c3a466b3f3c90a88332a3dde4a92910e17441c52f78af6b631900eb7b3f667e674a57c208f5423f64068a073b1ef5629778f251d7ae4dae477d3d5661796e1320ea60f9ca5607bfc26da34e384e1eca486292c2d1f456c354a361ff9322a0a09be479d7970e9b853269dc038a49c2c65faee42faa35c5a7023eee4e8b3a2c127d0e87b8b800c1632ed527afcb33362a8c232edb06c198a94c29507e10e25eb5db192554b695258b5d184ebbea49afb2e8bbfd6fda942363e7ac925b979af578bbff6637d6248186dbd86ea9eebcda5478e0b49b383ed99b1697d61d43df8b75cd64fd32e6d7ec6ce8ed0bc67941b6af51d522b5bebfd4468e250ffd0d3c3d2091e5e6b1e52f49c4fa7dee35812062ee38fa2beaf015ca98c2344cdb876d0a0a0b3a8e87ccedcb68950973b0625332f2441914bc8ab5ada7c64c77ebe24ab39ac1e89db25db09397a6584d46537af4a6cb8dc6eb4b7cde21cfdf59352677c3c39531cad35a43be363ccc6a14c0d9704a62cd1e6a9c91fa1c28e8a457c1fc75e4f4b6dfef77aa7f6be14f1556b011be35a38ffebf8070e4d332d6fcf26d1f96515a32a4cfaa8da9396993f675a1139251debca3f3edcffa295f46228070912092b3830b8e9a97d9d19cc5e2645165a36bcf774a83480911d51c7c6831c663e0c81913ca9d4ae3c6c8a20e5b9e93e9a6c8aef453a81ffa99ecd1eb96f136ebcd609e51280f16984762f84d883cf2b29b5121944eee679f0699a3005eebabae83479ebbf75ee7563da69b111b8fa59cfa71be5b531df3e31924976aabdab886ffb0a26c86a53d1f7527c952571fc85ba6d2adae3c85c2ae68289d348f1e86ef796a8486e2da4d1577ebf5a20117d74d0738b1d5b194e4583b7032feb9ab219ef4a7ad08c62faf1acf5b3669b8f5251816fe959d47b1b59c8d142ac4a041e1352ff681a09db528012841a860950749696b4315d14ef5418bb17476e8ac344280eabab59e88cba393917aed12c87205e4e506aee24ec974f22ffed0555b03b3e22548c2b1a94e9fab3b5ce5f078eb8a952f5bdd28f31b182e08275396a4f38557ac7a4e321a8ec2eee1c02f7cf3bfec057c114895243f9dc17941877bb4f01edcf28540196ce855f1d08c6c56ef6dda2a3a3d47816d30b5f5d0987ff07f6545241a25556a5b99f494ca1ee9341cd2dea56dfb3678203c597d4089e990d795f458aa9f71656d58a20acfd12a1e11e43aaf2dd6edcb1e54bc8e8c270816878a9c51442e45e88673a246e735ff09f64f8c997aad5cf9c237bd365fb04595d4d5cf0aca382cd8242f201e1fb7efa34c9a343f36a13d61cf3119c1c13d68d648c843429bd6506ef9f85da5e811ad97f38d1456d35299aeed2700b1ea92b4b8913463a4f492a8a7959bf4dd1e19f6c9cd5ed1dcf806d7563e5ad4fb8bfce09d23eac93fe4bef292bca976622cf8aadef039146d48c4f3f3318d7fe91ec1c068645dd32e05d7fe19bfea38c16b3eb6d1458e9c138322caf49a032afc98f785c438ceb19d224709bdf80cebb6fd7a567c9c247dcce76f2d1fc2a69132053a9992c566114d0ef23dd551fe7392629fac7af425cafe9356f99822b7eb12481aeaed3708dfa310ed6f7f7d0572b0f10bbd5c03591fc79168a7006c61cf4872d6b341c8eae19a26d1968e78dab2327edc12b02fe2784d5ead210de380ab8ca03a32fe76ec4c7b545dd3321e0a6e5fcc7a0aead1ff8d86625e379ccdb1219c7bdc96c645901f0c9ec3f1717e08c5b952cefcf9c547c8128261ad487be75b963222386296ff8414f605a2478ce72b99d6557a74391c3db49caa2d04d996ebfa7424e9b3ceb78c721c55d7a50ce182df23854aab06c27ec58aa93c5d62f9056b5d47d94bb243acd494d5dab001236ac938aee5ca974b273b4ea51db7c900c877dc6fc5b481f82a1a164b836016e0e7941364fa6d8b05a5e3670ae575fec0d56a1e47443b02d99f9f2b04fa41ff85df84fe445d10034c55443e1e9657350047ddcdd3ad8ed39d8a7b7dae4095e568554c5f1521d938ac4f596e9382975c955ae692b79bbdd268d2a6bd9e1ab41de6030a5eebd2ebe695394020f6a8931cee4f6017f56dc090bd80391929d7bf20f86d98e110bffed8f8a2eedcc52bb6ddc3d7a5d20959bc66ea932e4389f04506ed580428d713aac308b1b68d7792d9894fe800e96fb1ac79227a97e7b468f58b0bfd2567d60a32252f064a486dd17e9ea74acb53aca359f4750ead14f734b32ef05c2403ac1e104770858c250119da4b77e6d2fd683aeeed0286c04d6edb5501b70d865456c7b114f7087f695a7bb78fde907c26863cb2da3343cd0766678695268ffadf824c7a4cc48361e3da6ca04e7a244f343c3512d924d8af3fea71788e09041241c87067e97a99f85979f5ece0d523bc27c401d200dff1652440239e7cde7b2ca3eb66fcaa29494fe2590491f304f3281ef4f43d942f82baf237710277c641b1d437e17b9ab7b8f8e4a5e202d15a7128112a919b1879b67e839041b3acf503bee814aa4bc5cf5c5a68c0b43434b8e22ff1e80e98e1b6ee3f7c710d327de9bdf05d47a22b14f42df6095fa39e29c596929efdd73595df7589af080f073f88560efff2e4e242a4a12d46f572af98a7adf62248b5e4a58ea9301fcea795352b66a541efa0ee079986af75f23c9f9b3810ca349ad6b875b48c54dbaf8a9da13f9d6f8dabf2d8c07e7fd1d974a425c85fb852ac7fae9fb9082867c6be5afee956f4d6d4f755cb16bc607eb4897abaedc407e99e1f20563b1f9616e028eb54661c22e00b668b06550a08a217c4b7400149c224a98aed7f1b9e719bac23760c3b9b2402eba86b3c7045a026ffda7b36e5a73bfe5cd3fada155563079ec67cf162e025b5f6600ce1a228dd7c0872e67170bf05252788821f30c8966046a2f5a5a85aea2e71574c8d7dffd193c76edf8a4fb05ead25d1eba6fdcb584e73a60355f9ff3efb2a1b744330c041c15f15c53f4b4cc30b5a57a45331f239b877783eccae89a0913761b6eda1c7188c65b6f9b3d4e61c22bc3dd9862df93a015048dc7b101f37f4050bbce65ec949d655686690041f0c255405bf048eccfcbebcf8ec2f485cf013e8025553cd100d4ae39d5d75e586ea6128798784a56a4c08093581ac95fe7d1b72830c7e504b8f67306f69d3a74cac894a93bf730724a0724ffaaeab32c404ebdebbe1ac4ab3cc1370cb39ef5687bdbd4c7d177888dd1dfb0535de5c62d07be7902f7516653fdf59389ce21c263aa0030f33f65655d8f41a2d190f3a3f52caa4ae6afb2552a9a2a3ae73a6628879bf87334b610952274fc1495e7c57d3b7a3dd2df531fa96ffb2fe167f64427d0e1360bf2c9f9f3f6680abaa73847d94485be30381db3203b3adabbddf884f0468e56f0e4ebd8892c58deb2705502b77ceaf4b993714ace8cd43dd1af7a5671edfef6f53151d1fab9ca71066d5078ab9d2605acefe04f2039b195c38f46eda765c7b8123b78c0d3fc13cf2f0d06bdc6a9f6602586e65b195278e8c1911f49fd76bff317f05e35acd1c6c003378ff1a7ea38321ed153436d5098ffe4d41a5cd3a6f418e59b469d3e8f71a632ed80b704f9f7b6d0794d244e99e66174f8dd32b8db541dedaff5d8503c66f6771bff8bfd9d1c3259d6aba61c0a12ef0aaad3b16645ac99ff25ab793eb31925e91226e958343ff0790d10cd09b2db60334bee85b63177c97fe6e8249b34a12d388d4e7bd24ab678e858fb78934861dd61a1a59b3737c6e720ab67947dde0f0e74a2564775ad2bb8bfae493f74edc6d7507d7cebf26020ea91643a0744ded34eb0c1965d9a7b948f4707699ec529ac80be4ee841b590108f7285b4b6ea0c533f6d7cfd47dd66b0cdd0c8691eb60366137c8d8171ca0372d5f7f26a9f8a1bfb79bd28a32ba4260607ffd1cb655ebff1d10656d8108405edb935e40a1c085bee947a9d94785a3070da132953141eee39375c30d3cc563d8bc4630748fa517151ccede7f6cb927245c7682bf18e488151e004b33bc3258f15bb7dc7131d564d2f1f133ff8f08185be2c8cb5ddcd7a146a83ca27f166414efa166ee6b88e6bc6df2387bf9e1f9faa3db4b1e550006b120bda5ca6ae49975022238c49b6469fdd1c69076a8c7833b9771442d5f1554ee6fbe3eb7267999302b7dbb9d9c29e41369f29e89c46de1676490987e07d09bc5b46df0b26629eaaa0ae70e0564804afce6bdda271eae595a03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
