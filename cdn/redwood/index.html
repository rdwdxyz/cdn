<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e879824ca71362177f5a6f511cd2be0805ba81d1a14a177b53a762facd393d047a3512f4bf4a284ca032b17bf302082ff16d875a47015226de96dc258df81a784aa975862588a21534cc565831362d53ee9f44465bd4b0220389f8914a5e2ce866561887fa174cc02a0041b4903935ae70cd563850b1afa4dd5ce0695390e632cad06d3c5bad85674fb0a51cfa29f42e887227a6c03e2bed5a70064e4b8b4ae033f4e5b13edbe52a0d3a05b2fded4da07d37d156fc1a4d9fa1d50a691c40626de85029da927fb0918233d90b2b91db8fb807b35d753f36fb0b56d19063279f85c7c282527ac343033c2cc16f6c8a8e4b47450240255d3e2f1cb9fdbedc1394e67ff234de95ddf17aa094a6a412c3f0f6ca65273b242667d9672933d63002152711a84db114fdafd423967d686bb913f053d67d75168da6384ba897fd8884d84df7edfe7b3e337a4c9410035fb43e00a5fc9eb7b163669834c91f5040d0a9e402339716ae407e9a228d0c60c45677d228327bf449a7c3d6e56f1a6775e3946632792cfe61aaef7fc54e692e1c2d311eab60d853f841ad3e1533e5b3ffe8c722f3a7ddc63497696db156fc68bf17cdf005d5d02ff6759e9cb879a9b4aeb13bdbd0e233b5f9ec3f697e6aaec931e73f7a06566d33d7fe43c6a53c77d15d44ec333f94d132adf72f0615d0afcb11bdd02272f24204a83d3e0802a398fc67e66426bb3a36930ef2ee6a130476e012964f6f6d22b17c3a10724041d7b9790f7b116f4c82febea36ef0dca63a3efdcb1d47f97dac38078515e13cf92a0c3a110dd13c56aa112db900293e28579c24316bffac2443eae4f127339e039cc0f689246706023a3ff437023d1532f6d1d041ff1cf5b0d0a428be7a603c75b576b578b3b67ec70a4fa0586239ba7de672a64e2d236e63da4187d30986e1d5fc74ed47974203e346571e23cae49cc9e4e8af02abeae2cd3406f52a860b855fe0ca361aeed65301cd6c9d130f67a2d59a45a73e13bba04730232f202483373bbff101a64975a24e739b77dd718c7a9e2e3c99632172b0a6635fed25bc240e0b6a8a9c3d719d8782397a29096e313bbdea44f65f26580b4e3aa5c8477dad2a62fa3a27b1180aec6393257aaabe666aa694bb9d1d985f46efbe9bcb56ef1d08c993bfd0f827be11189e03895221668e3b0c1b9a824836851b35225e463139c09ae12e116cfe52cd7488fa8a57890e5c5d6dbe2b4b81eb6f0c83f1bf3fa227efa9e161c5c4eaa7797549ea008b67950c1a78b373fcd0745921ba1d1864035a38d2272825176d943a9d649f8f9ec67e7467892b76cdd89574b30995d5901b497c8c45e4d636a3e0bb375ccd6605903b1ac97fccc083f22107b2e0e46e22b98b66e13b0f337537d45db2ab8f50787f0662522763110c1efaae569abce07d90a24ebd86468efe89a2b8761036783fe1e8e9a005951b87e5535d10a5e13a91b56400ba63d74e5aec987d7b33f91be83e2c9e78f9daffa747405431cbd77329547b6835730cd740839640373c7c6036e6cfb4712d1ec3a8dd3898d582a33cb181b8d26a968853e3e0143e91c09a7d894c2a340bd2edba205681170d1b35cb4f10d20004f0790c706b09607e60aad5c83a0805b375ec764ad8184eef2a1154f1da520e14d9ecf1e70a72718f6ffcf5e160527db8eb6b524f021c27fcee01a6385373ba930bba6492d5d90f9004577607d2841fb2f10f50710aeb2f82aa84b78d7f482763ea36067a765ac8421b0c82946396953ebae0112799b16d45cbee750ff5ccd0b9c9f457a561aec3d997da4bf7ee99a3da03b32f85fa2a6ef1a7257951d9d25a03dccaa4c416a1ecb5a5aac739bebce28fca6e90723a41e85f71d6c86e72122050d4f7f7685fd4c918afdbfa9626de23b66926a92aae400c13ca3d65f3bd06b33878be0435e4e57e9e907340391ed6bc3eac50fefccde0760cb68df9029709252cb09e7af3b0e62475ea30da6b6d893f3f7ed8595f49c9556b60530ff9b45db951da39a833911774c6c24fb2ccee482fa3b2765458543162f4bfe53f98b66acf290a2f83c041ccda50480c7edf962cb3bade620a00bb820cfc7f4440891f7f81701adba3ae1c107603488d4ae12891e9cf188d89493f74dd470b31606424b9642174817e01a8bcf17631e64fcdc8373201b2fef69d01cbd8f5388a2f6d424fe3cb2fdb15991f0e558a72750a3d6b3518b4232d730f641d7839e92e224861c02765d85fe0dc601758f22f6d11e3d8d7638e4de5ad78c8cd3b3ae9211b57e8244e5b4bba0bce85375fc2b2f02ae3e405a9c0cc3515c45d6541de9a38b5160907c04adaec24499db23db5b087ab31979d0808ee78338e8eda9143aa245ec86e1b7fa49407c5ed2506b914c0a9129c06790d079a6da3f1df061b8621981579724748f914f5abb855bef10f2e11ccc4dd9d6749d3f5d7327794b79934b538952120418de624bae47e958ca2742fca56386e7cc6226ffe3ae62ae299f3a2a2a8b6eb3dc8344f19e44d1691af9587f3b6873aec6797329ec7afd9388a82bc7483bea578d1bf61e4f6eefb13572c0608faf6f6e69ce9055e9786e3c307aea7d856b78a745cbf0ab1d08b92ab6025e99614bcca99f8a98711a341a06628f7c3407b5b7c4a8afc1be64aca4eec4d6fd90b865ebba0a5d53b4b11b7a2714c448e05c99d55a2e0303a1b9cee8f3b574686e8b5a0b4b46c85af33efb700124a89e62052ba720312e6ebdfedd08bdc15d3e769671c773de211889eff581bd8df2b0d40bfe45a529837093b1d6b5e999f2ab2647d2a36e58062120e337c2d1ad79dc48b723b74500315e59599417574805e56b00f9e218c6b2405bd60762630a9d756582e54a6ca133e05644fb0280e46b8cb92f23a631880aedede3164fdb22a0bd031c85fd58040999056a44b8c71d272a2b0c7c78a3ebe385332c0e49c8bed8e9e6f6008bea14598ebe15f7610235ef289e75737900db04f608f7ab264034c625db55d222ecba5fa226e96899cb3fa549e3a7c3e066cdf81481888f8bd2c772d81c65367b7d10647497d3200bd47a4b983156add9f23f5c4ffef5cda3b93e2fcbaa5b9c759da70022605e1b10fe47c4411182825af1d226931f36aef9edc6811a0264944462f2bd73e8189c15cfa59982f4c0e07799998acad68384c2bc96682bc8df44dc65eb556b0fc8271fb3d2fb101b7375b9a6c4ead9f29cd83bbbbeead5502aa61f16978fcfd519301caffc376454bc62dedeba2c2f0ffdb9a13621f1df590896aea710aac2a64a3cca1caaf4c398a8947894d35384342834cbe636f2a9b8a5afb301542be9b3182619e49a6b3e7d10178745d96af4a46f93a673c82b76d0779ff32d60d1a3b5323ebbed757bdc07d76773b5d189cf5cead2b62780fb07cba63ba6d1dc190ff519ac620962a0556be45377b9aa5d0506bad4e8f40ceb299d75f9a6edfd43df190f8d03b7e64935256632dcf78150142892268a1b99f26583f6deae286783b7f2dce106e84c2b90cbb66b7837fb0e0d9eed764e0d34425d88570dddf09c24a3a5e0a4b507457cdc2e1e440eff3b306983acd10ea42a9bd95f096cfed9587f194e69f321951a7e9cb02a9a7f115fa143cd1cb5bfc8eafa564b4ea23a3d72b06ac429489522432f0c4abceb253fc906f807a717c88944a92fe8d8374bb23df43467c13631e8e28b30d5e22f642e4af0b38aa89efab4e6c897a9ce2c2afda65bf0ced4ef532b8b8b8fbe95b3f4d021c32bf922f0c92525ed2405031f2a8e5a27eda11988e5ca3af198d6017a74c493c2a75e86d475470b6e6ee194dcc014d50d06a240d71600468565ae2afb3bbca7190f4aba850a2bdbf148419c5e3f7ff1ee7e84c7868acaf3537bc5ed62662eadc9f173a1c2a9dc135d448bf2a2a58a075ab78e700f6cc54e7257e1ace28371020ee1ab43ec1c38d48b05a51cc99cd163bebf6933ef8c55c9626c956095f7586d46063987ff2af896eab683693c062f80b3940ea62a6bc556a6e7c456e91c047edb6929d3af61211af964c3c903dedffb5b21724f486535abb43c6db692a2554f636d0810e4aaf7a6eced8d9354f3e27367acfc897fb8226537c4bee4ffbccf6e36ad9a7017aaa21a47091f7891dc30c7e2d45c6c27f87630084cf971d3f04f398867a5ab17d12a0aac64bec5e41917d45b6fa52ff00ba64671bffb4629104e252891b2961d02aedc5a532a54e4f56f5aead18863039b673aaf97ed56fff5b14ec1b4072556ed41dcee23a3e919f5f7192935ea878936be074fd38e4cb33da39971fc41e97418c7cfb2d597db06e9b67221a9450eb1d46f4186207139d0355b62d0677378c9ca68e21a3634e06d63ef79f75af9e9d9a3a5d3e6ed24dadead71b8dafb80d04248026e00cc4d6af38dae4529f81ee4f584ddd45f9c084deaa994b257eae91f08c10a4dd814261efdbe1ab3e06a3889e57925d5c4c24445d2118d061ce5d20507b3e2c56debf00b707ff80ddc67e78ab89c3daca5b18389490bbf6b306b8748254c24e532a9026c82078e69a93d457044de29e25e9bdccdeb00ee0e251bcb98bda9c15dfe02c946aa444285b124ee807a99a1d997b587fdf010c579f6ced32f9fbdf7f611929e9ee5421f7b5bcad03a09aeb1ec80f199b3f88b9a7d9f27695476127b92fb26c2543a43d720380e7e5247b8e71457bcf258152aab0e4781b1d7be0d63e89268ab46bf72f4b4c77c4e7f30810710314de73be5b1d99ee76fb17b9659da1c9ccf6d62dac60124e52c5975641b035479490d9e9f2ace39426b22ad5bfbd87639c9006fc77e9c59856220c5908e11d33cd7e456e8249f220a9700f64c0683a6c65d8a723c488d50f0ef46ccd691197e0f23280abab835b0bfb0fb52311c8bec65a15478e9baed63e55746372a25a39cc0a0329baf8622b59f5ba34dfaeebcd9997c9723091c8186688d48a2e9671285da158ade3ba10cb2df8b15a8381bf1822aaab86dcd7b4a3ba2fba3089f6469a7c14d9b64bd91f41c7679278c194259f0022c211bab296dee0d7eafc80d34b5e53bbc565b49d9f42d40c0147aa9b9870bdefc62515ffd98037f5df6321fd97224569fda45f5f80bf09855125e427f1741cf650be7c63fcccdc47fe0df7e4da7dbb477e3aae4ed8e7379bfe19c7ebde31e45aeb37e9104163b216928722da1d941d716d3577dcac00543a5c12b3f83e9011bd6c671963f0c452f76665d43de261b6616168140acc2b0438dfc4d87e6b5037e1dce2a4a561e84c4252b5e64bef1c3cafa7523b990f172c1d7965253f864e5bcc4cceef30db0bf98947fa77b873f8535d5147f347d77af4fbcd089ea81902c7ab4414b1a48229a298af7052ce24e1e81d9948454cf41cbf0f71d1a332cc08dcbc1b61628cfe9dae3cc721032aa0444e0b3a9dc9f725e4b5f2fc49f2e8cf8beba0e193f99bebf48d6141674452922b48af16bccdd574873df81ce51026e370c231bab3b4fcfc51fd07fd519958eb060a147f0b83e1bc74036d0db412bd67432825ac653386a7364a1c7966111dcd3fda325367b31a7d8b4245370ebf7b0ee76160e08aa37a2851f8fdcc15462084984b507ca6dad878931f241da4ec7309846684497b74d384b045fb82379d92af51eec9c369eb390db740d6569096c9916396d7077816ac346915cd8644deb4325efd6a3a34adcfc3f17ceed1a4d7834d6047c849cec9a45ef7c51f91e82660e7c42b5d83c4e30dbf3f83049ce7bde4c1c35b7b088f6a4703a4fc0c4bf0b611f3c1825adadbd9df5dcde48cfddbd982c69cb88112bd2d21ef9aed074621917f45249cd70a82f281d2f84711c42e3a8e12cd31bb29da302303a5da37da38e6cfb95746da0915b26fa41b2d27f65613b9f61e0ea1735218cd86af15840d1f75dc620f2ba467a5e941299814b7baeb2b3b36df79ec235430eb96007595c630372cfe658edbdc63e681fdfe9b3beb33d611a3b0246063c888ad19c60baf9e5ea531c69622979b6d63ada865ddf2cfbf1259e43186f34e88ff7eeb4561046d42f79b0c28ba70052f761db01d4e3476e24663efd67126d07c221699138aaaa20a04c164f9ff2c9f608ece056569b4cef9fb4cf4272331c92066a7b70cbbb3d1ae0d2c49a79e36c450f01e7f8c41125ac0289d32bdc14a4116eb37572829f1d3dc40c34a63c604e2f8d6eafcb678d850b7e46cddd968a672ce77f16c77ae622b972df3878e94f99992b30513ee1e2b5c5a971c5a84eb5e5a52d28163be306d94b32a0a7c2fb7a33ff5f02c110bb0bff90e932d8f527e5bef6bde030c0c388480cc1e6462b21b1748512a4636b53e80fdacf0cdab563963ac0db60fc08e1a1146045be63802bfdfe64930568adfd77b59505d5bbd8eec5b80842bbea1cd5b117b396f81dd15cefe3c0b242089ece7dd3a5c73a8dc2955f2baa1865beafc51befbfeb6d8ca24a7628290346e2a3d026070c6a9cad51e31393ea31442b80c4f82ddc957597a19729ec4b254c93eba40c2da5b8899303679b7fe8ea107ea8cb00c25e347501d14bcf54a2272b0753582a35f5eb595c70ac99e5f4bdcc711303d39e0fb1408909eece91b6fe27e2a480681e8cef1cb2a3fe83d2b17e592ac04e51126749477ce134d44241cf0146c7fac7abf9db8210e9ce335b3b07bb63d1f387e6daa6d7e39677c35d5fe3aaef8caa8593587a4d8b6e3656fe3b47ea11df55046047ca1111ebfba3224e29016ea2a26e294ae5cf5d1cb976c3a5d3d1b431defae8980ab87f6479ea493b4c64bf7220c4ec11779dfeada2d9ae4354977fdd2fedb3718549d8f935dcbe1423b3112a111b38ea78cb649e36b3992e81483fc312c05ad08c97a51160859779ea4f29121bf86ddf3909f675e07eba31b587c380e68eb1d8f527eb0e12839dd5a9cf6947d4bbfebac2f2036ac287415fe3b20adaa99829190f9d5d256b6b4f41a321dec026362ae573991f786cc1c4a5a93523e63e2c0c0673585e0aceb49fe5c640f382f915a24048c246cc9d8866d54e50c0b1ec43a97e3e036576f1930054491302ffa8aef4aa18658aa7c666ddececb40af1ded85d9667b7f7abaa19156442c2123a3ab8912cef91b429e39874e1c5b9a5855ed91b9b4094a8d85848294e312e19c00280925f68c6730d81181ccb64eb1f570b31eb356bf941f912d4ef93669ef1e7bb689d5338ccdc1fb16d524f838a403ccabc6f37d7c3545c7b2852444fd4905a7dd0dc8463530de8af838eaeb6eb9a75118d0102de825ffef2ff18623fbd8d1c9e1dc0c1561c83e0ef37917a6df5072e8cd41a2f5b36d3bd37a93bd45f419124d1dd794647488a43dd12f0cfced0bde6991181c2ffeece6cc02d3e5148dabad36590b7dea78cf7ce6b14de6001e3dfd92ead011b2d8edcfc38ee5358d7641aa0c37df02e2ea784d7a61783575856071085cef7de43765bb1f83d6a494738fca3ec4281a54605babc3b0a2b54b29d8fece18838d22e5c954627ab3c3fe809f70dba2fe8139b82f26efaf9ca6a726b6f1976c8374c1091e7600e507ccd36f67048652000f4a75b0c2f3cac86f069c38940c55a5664cb58e184f2b6c983eb45a6deffd8306f9b0d28798f5ec315ef15c9c46515a5fc10eb9ac385ecebe096c9ecfc77f8d077c8e267fbebff1b2b001e78a6d6360c08ad5f86412bd70e16735fa58ed62c2c41bead4d9496b0dc08886efffc0dfb383bac193b94f8dc94429a8d48bc8a6594891deaf49b7cd07716ed8c1b005c00f9a79d1dac8c5e25ebba4490f3b0519994939c9f9512e4d282f6bbea96f7e0b024dd2e4ddda33eb1ffc3f892d324c692000e89b608e76df6565fc489f4f410522bf52252918b600042067100af624ab4b33b57787838041589e0303cfc459970ab25afab2a4dfb765f382aa7d5aac1d29a0cd45d854f2dcde5f7e03daa82c7f2ced6d9fbc99d90f3870cc02e5e313718e89c3512eaf61c3cb7f1a0ec0a6d6fda004ac491aa2db2820f3c577e82d7795fd9568d8680c679e1abc164f52ac153a2bfe2b862053bedb239c4df48143b20b0cd56d800816d8d4f62e7101718da07015cca88f21f86bba3ea2d9969f74a45b07bb975dcd480e1f0e4f2d2d0d49714bf05275516e719f02a9c1a14f528fc353958ca6058c0a312127cad1ec2baefe7e453f9952805a6edb7264af34445dda1db5914b65e152549de1d33623ec9607ce16c4d81f850da393364c05e114653c648f31850705c0393567e0c96bdbe58518e174188583ace53c8e134eb884300cbd068eedd8efc98cfc08333bddbc69c6ca0155186ffeadc36fa7174d25eecf00d9381dcfb810f461942c1ccd742e51ee07868c607bcb1f1e4e3d540e47ea21481bbd64097f18396f8f74f50b66f7021d92a20a35498825eba676c951acc6ba28052da8ddb8a6088105e04b37e9477e019b485e790f0a7d0922ad97b12874bb31a574c9f24131b3e2a3c54adbb47fe1d8f41b49ef8fed08dc833fb2cad733472053552335d8ebb69797024de68ac6cbed461bb0238ebc62ff9c0093b71ad0b3a8156680b97db0a412d52436968e0225fdafc3162703454300c3e8014cba872a4b5d551ffeabad34b87562b8852702127aacba0cebec65c2c39b2d0d895824be3a6d010c806e9c0ac602665cf4c4e7729d68f65bb5f04b53a1b5819d91b034c73851b14d086ed9c691c8dda6539c82feee9cfd1631793fca237231c289066ce9c248b245734008a368dd759e062731a255545426cf1b2e85a3b19c2e03c2fa6b762a6b9dfb600bf9d113594012c04e64327862b1d1c4d68b16634968343bede428b156504de15a4e08d154739a987d46c73074f485489f062dfaed073e9d4d4ed07ca410cfee5205ce9955b546659bd93bcba604c13f47da54da4b041ffa5c8a7e942e8cc8ce377e42d3791d69cfc1dc0cff5522af986915c55e148469a924a92cc8642192fc6baf75cd3d7d7665095f9aa139512940bd83e9f23dd92fda415460aa73c50881c71826c31610c121b49baf46e426774be93e67b5c352d2af0bbf741fc9222d27a9b20b032bc28738eada3c3338a4120d3fd412ef6ddb7af987a0b85570b4e94edd2aa50702e0a0aa2939b13a55e0b108ae1f8ce071486f19575cea40b844d5ce2a395014a4c51881859828e682adf158b339d98c6ece2fcfdd03d086a901c9dabeb691857f3f8a80cad24a892ccc98bb6b3b42b5732f7f10cb543aa35ccd201ea3b8281c78ae6ee4706919fcaed0f8fffa7fbe82c82090a6732e25a78a3b5547f61228019b4d615bff0408331990d82273aadd584b35901ea884666f179eba6bebe5d3de76b00d8077f2fd512cd397da656c7272b52c251cf08f84c97d6d37383188804a1185d9eacb434925ef22ba2d57581fdd98a3858568d7346c06b63e763a1e387dc5707c2a87b6ca03d742bdc3ab7bbf593f8ff5fe73599d07a146c2156144e3bf79b1b34c7d6ba2bce1a8fe85d4f05ffe790c3faced0f47f2c481d1d1d2bb855291eb9dc2ca164135d7be438f6fb56c00a82b011ac9a1d0a4ca4fb8255f59311941370a2380c169ce7c891b44d26f7520e234b6dda6f83d0110631eda908fdb7b59e9e77f606ce6d8686c09fc37dce32da0895960fabfabf2a3c05895ca037a9a9f02d6eceb490c2714e30000e91126f4894b1b2436dd1f189d87a23baa17c624c350a5fc4777fdd1396583ed6f66ed602c12e6e024804a4a5dfb8433120deab277a4b8767d5fd8f3c60314f9c07048969a63621c655ae23ae31165b6510e352a946be7f98f245e653088429d6050e67d9d812ee6aaa3a5cab80ec72061c94d493eca73a37b550b48ae896d41673e9a21fa5e6867782e1654220c43d75d7d34d965374e2f795a95a286a066bf622fa246c90178fd97214d685ee73a6834fe3275137b480195d9c6c2eaf728d15e6d379fbc027cc003b7ff900c5cc55c6ac1306d98bbf93145d9627869e5d32874d919f0ab738d28f5cfd2cf8558a3d19a38f210f266a213c6cc2ae84fb4f91c6d0c706af776f3a6296bc40aaa52158eaa688def5564a8e4f9b72a5681e71f4f8ac870e379127bd0e577ab5b7572b49f9774973dbe18da93f23547033d0c67cbdaf8f4f6201b90f5ece94e0eb7399e3a3d04853782ebb0877a99f8b68005c92333e694e878dd95feb8c38aa8e1d7c75c1064b05fcb22c37c444dc29a712fea275c182a9a8042cf873c16e66efe4f22fd81cb1d10fbd6e75f8766434f0f4fce52cf7a35f6bd5102a3b4083ce3c5b39cd7cfca9b84af1b3c3e9c022dfb15cf423e4a328bb56deed1a3e52f8d6b3bff7fb29fd647c8f526ef73f7efbe991b25867cfc7c1260ef3d59de06738148aadd6c699c22ceaf7f749a6eb7128814bbd81fa07a32ed724dfa5eedfe3a4ecc98ddc054e9764b0b3b5013d9b09c43d6e9b715ca6d1c6c5324218444f66b0fa8acdac2e2c211bcc6679638c0ec61f15ffd43dfad8ac255cf6df85f50e8afe3fd6438ffb176e8e59678206d225c6269bcd198662b787c6e69f315ec1b5960f40495468e7dd5bf0fe833129bbe85042f86739053f261fe8cecd7ee4c846937bb901ad99c24a7779e8322dac5d07650519ae58da2fb4ca82bbe63f2a00a22e60e04f24bcb0515bba60ea5a4f4ebcf601c0588a112575216c302681f2e590e3f0cddca7061bae0d4dcfc239603c6283f00f3bd8bf80d39ad22a21c6f142fccaa63967d36a3254b50aed81022e3bcb75dbdbcaea4379b1246b105cbe47de4eb5a3b6b8db600baee5ce5b93fb1d7a307f5f2263651e3f87709fecc14d68b2a992dbe68b297aa8595c1287cdd5f5212102474ff2c7c290dbdbf9cbd1f67cccddef114472b3eaa65f096db6fe9a8eacba12f14abd1e834f0d0a20221bdf4deb4e1c4395832a9bda42ea668bea67190904645e43238a8aa82ced33750e6820a528a0415fea49464732231e1855ac127c7832535046abdba4941f54fc5f0119656832148e3f04ed9021faea30dd1b058b6e1ce58814d9a8de2ec071985f4a70c6232497b53813730b6e42be56e6a9b58e282fe182853099d29d9add8ed10fb52b8e473dc8c83cd287669b70685b23d70c801c2d106173f9b39a3e55e3fe2fd756c2b1da45df76daa940ce1ed67b7c3a775f80cf1d9496e937ce661500bbf1f2d4c44a7f5fbce0d911ffeb550b14d7580268e81423a1266fedbe497deff3e8e4c0b6ae88cfaeb7da6ff6e2996b18d379c321c1f4959f2fd6871236a8fb50109ab8fc2a54817c7098940ffeab3ae30df0d17e458f9ebd7392779ac1a01bd967a99a4ea638cc05885da6b17f00839232cea4fea28788cc24af44b01fbab07424f464b7f8927e4d9a1fe946f7c9f1fad9cc09200ef37f852a13226d96ce277205022752d073671a04570788688c3a60087fd8befab8f70bb8ee6ecab93be43f7a9c44d499cf9c48c4774decab9bdc1d6d2150a269ecc4fa312ae8d3678976219b26c45e312731c158b81ffce3cbba02f2ec7dddc23da0b0c4c609437e139c00e8cce0faf7d7a95f723255f3c2aa14d22b1a33c074a1f265b24bd42916eb61222165b6ce56809428ab19561e207d8173307153496d32e4aa4bd76a19c0089966b53897aa92a3478533d25dd3e658df2870bf2968fcbc919e8594603076c021a1de7dbc95a919534a795b9e5486fba721dde3108c6166d34c264d4fdee1da843b44fb2d0f6d1cddc40b0968373aa7e28ad4ab6472ddb67ed4c7444719e0dadb9c736ff31f388fec1bc34291a7e38df0209bfd88cdc30d3c4816b08ac13a5ed0c37b1148596bbcfc1d937a7b7bc63915f3058fff01a4540db03f15eef9278421a7f53d8257e24e5fc8d6f5bbe37fb6e9cdec4222bc1718e296d64a303080d87e6656a354486087952b278231fd5d4dd0b4d063bdffb3e02202c638e6c7f83a6ec1a0c3d6d0f69c100fc85bc2bf6395f2ed14df2036f237d171e1bff2ac7705f0159e05d8c5bfe89eab91caf433910b4d73cba0fd4934734bc6404c1bf103664ff3db3184b1b711e03a05e0f0883b97d6696b194ac9e8bb513eb496eb254ae25cbeda37ff2cf61f7952d09161168ea6278d531c66c67918ffa8d85c99a2e2ac1fd2f147d02d2ce7ec4b77d1549dfb2ab78501916c914428d0cf67fe6c71e8d56c3d7d0ff4a1b4f3953789431958ca028a7cce2ed5743337b7a77dcdac91847eecf96e4a8902d8585484964da2e718cdde9bb184e1027f9b48ee6617c5da8f7f4e124578d0a2177326c5a7fce93f032682a3557d2b41cd6dadbba3bb8d9e06c532bc6e2739737c58a3e9228798c9fd5877af4ec336b933cd87769305601344c7b2492ca02666e2f0bf20f04bc4eb2316087766bbeb0e753728b9462a1d0d4ed734c6621e760e50e28dd30be141156a8c1727f7575f54fb4c19317a9e5d3a56c71f1baeac2a3b063ac1670f48e21eba1649ec497fafaf6cff5e76276cbb61a844a9951af5a4911dc8ef717e7853753f2145d9f516a52c88366dc63e83ece29a2d4b44fb8738098c9dec0cd2245e8d3739bdd2c8653e11ccd7a22a79ed81edae55f92a17a14c9f2f94182902e509c8f4dd52a9b675a82094bfb0fc6646ef8a3113c27f7f8e5ea74c861af9e228cdff5c6fa737d9bade583c32ee661a540d3940d555169d9a8c6a89d611d1975f6790b71b9ae5db90c7f0bf49bc01314b61b8137fa23eb4035fd2400c862f5f57284a701d054a023c58e1389f501f30c45624174e8f53a5bf7f9310b09d3f9d2b9b27dac2b73f57da837945c65f25092656ae40ca1b75b1c61a0ab48024df65dbda76443f8c52e4d4c6e4b301a4f03e0db0485ab874e420ce55e28707877b1bf125f506fd6ff8fd13512695149c5a0c8353220827f5451502a01a419de67bb6ffe602e746541e378cb4b2a0d52d9ef294f93cb1b2c99de8452ad378e7e74ba392586afe95bde0be0fc9fb300dccd27055c2b10f67f0afb5d3886df8bda1144e6a3b0b39edbaa1679140d5a07283f19dd3cd4f12e7ac80a02ded0649a2ef3401ed3198bafff2be3cd9cc8cc9ad2162c16cd86150cabcf34ce04b6c01b6cc25608a1542e31a50cc25d8a46420412f78d87b59ae5cd077984c1333bc07868df7e51ef1b6e99d9924f9333b78cf8d64abaea5a4de0eaf0111b691237b85d9e9076f36a50be2f1354f671533f9178db273e7d2305d24de0f2eca021ad4f88b9b374244baf573e42626ab47837917667fa6dcdc86965f49610bc3fd9a6fd1059e89cd29ef9259e29a68a10bd823b82b54bf9fdada3f06065ecf8aaeca953fdd7359818984919012d12f51d05b71db7af882a1db32646f1118767fc30da7e9871062bc47cb86065e18a7f367a3106daf426c0107d6cceb8cb3ac58ac052cf96c2cb0d0fa3fff88e893700bae9112adeefe83b7c0f967ce03522ee40ff16c38d08880579347c7165919aee7f6b19fc42b1c0acffff0ad1d383e96b4726c195280880e639d5bb4487a361034412b844d6cd79db5cc6da342ed1139426679fec03ae951f3b2993f4ce4209ca902a707aae739b42f681826d604f16c63fe34a18d59c7c2dfbacab62fadf94b92a4b8677ce360b118a907e7cda699b4564ea97e928dcc3771015be03041c3d7dcace52f59757588930369ca18228fb8e80f2724153be81dc121a6946093b79689d97446c9c7be1832e543fe93468c7f5229e0fa4e2e5fad8a0567ba39c06eb4cec1cd98c239981c791588870321ddd76a90b950e20a3aea29e9f881c447033b1d0a86a56e97707d3701adc1dc9aa102798505d7df40a9527eed4938c3890ffb4ea519ac0292b7d44f11f572f45a288384bbfea250a0d10ad4345f602efd04e550d16626f831aebab2f5678ca9e3de988378f03adef99e94718ff287b8516ed08bae92aef1e9a33ee9385aba6b5f2ee8085f1895362f46710b088db5d94d9d9983f7637c77511a1d9ff0c840f856b4fae3beb4b0d82052e5b84c91b74e023f65a0f52fb39e0f548173d0441487763ce7ba4b05f8c6135e2ed46533318218b9c1e34614ca4890224dc097909cf741881029ccabfdd7102838ab4331c3817a3e0707e8f15bbfbad7db34c66d3091797ff7866972a3ccf909cf047778988693fdc56240fbf42ba14bde69dfe534ab5a9e60f303c520a60ed21e37ad82fbacf4bf26771442548a9ac08f5079520e6c3227303468bd573eba3e298dcbca8cba8ada72a441a3077ad03b9c8b60c5fa8cb0d0eb5d8c26bd00ad93887899bc81a8c975246add80b4a8259590b2c07d58a5f4b378b8c3e4ed0694b9a01f49ea7e5f1be6aa2549cd4f0ffd4afa1ef96103b4f015de4e11e49d6b8e300ca29356a63cb4c438c18f93442e90351c1077d857912f82f808de0752dbd4487109aa1704df65e5798202503e12fe997039a18f14820ccdd3f9983e489caae99b13b9e565cfeca21c1e438004874b2fd6371e093b4a9156b07df39d8fd6200ed3b7492535d8b9869f39535db2ae0095d0b96a066aa2d0699149170cf713de101db81f993f960b9f8ee8c82e98f7343828fa98410e5aa0fd124fbcbad5713603a44be2797c2a1619190103bb2232626abfcc16a25ed760a959929e342853fd10e839c8a654d3c808fb79964a85a1e93a166410b5d55fc1abf4d8075fccc864d9f23a1a7f58d4023b3f55aef60e50a8fda6b217c5a4fd8f9145404c783a2d6e73105f1ed4d2be349d50e930e52b8619c18b709328c377d0ad688c70e5096d1662a611f892154f00c4cd160cb7622304f4fa3e26e49d5f467b24276538f7a7a1dac36fd241659c336e5f328435d7519185cb3284c8514afe41465699994b92a1f9545705f0a7725215e976bba4f68b64f62a87ec8dc36d0ad3c994a2f8c9fbac2d4df11935741b29817550410da5a10c8fc9ae649e751e709c6df7ec6f8a7553adbe89ac9951cd304c1c634a6c2a60c8f1b3b5d639f927e798ac0e4edcadc684c48296839ea6790c56898840da619ddc90c7a65d51d010b08d72ce33efc1fa92664d5092a163ce95882319787195be8df82d799665f1412abd0124e48679befd6bf9745fc932558804e954a07aa041402908b7685a468c08616c005ba1e7fc2cbb231b45cb1cc5e3589a26a033bef622e28e302990cef7b382b391889e112b968c7e70048ac9875518a5f224dd7187d5f80c9b08510a08356e4cc559abae4e4e474264803cf30e2ec14d1f22513e9faa1fe36cc78a2a0e65fb70135daaa050e20989a15cde8701d8ba20177f2739f1febd5055fed3463cb5ac757ec94837d82a8ee7eb130fdac6c5ff9a0c98e042d02ded2a8c1d9237888bf89f32716b0235b1ac0dba7d593b808502e6842eb22ed8f4987be45efe537bddb8e1486c4a4a8ba6f681e0bf184ecb24979f7206823b3878b597adf8cf505428a663fbd959bc71e5b81461455307dd6814eb4a041b6aae5d9236f18869464283d1a39d9b97fa37be19d0c3eeb52ae635ddfd57033eb72ce993869ce315b536ea1e85ed2db8c5b16b81ccf14474cf3c5af31fb1017a7a5740dee305ae4b9e92c40cbd8e31e01c7e1357479b1a6b76d67422d6c5380e03f050dbf4be3bfbd98296c0c0139f32635023fdaee783c55f1a644f51cc814f956472dc0357c5cf9dc8210aa35cc0c13137c35d3f3b8ee5791ff2eab3e645fd95770c0dd4a3d2fcda61b8cf518fcecbf29f1f33ef93e98603434a93898b35de58392169691b18f67583c2f379a13c7217f42ae8d6d85b5eb4e78032b5d2752c4f8623acc6ece3978dc33d98fe4cdbf97add8d78a4c1fbdf6fab866c0a86bcaf5021909682977dafe053a552df9ac7762536bd1c15ac6076a99234f4acb9feb30a1eed29b900df3d35fc81365153dae96239cd007265aa5328f7a5fff23bd805113746091786c6f26566463bd8e632202be581ef5d279cc0a333441e36b9297e52d865ba553dbd78b6ff2a88af6d59469d96da3e3effa094deaa0fb77f33d7ee92f28c57c1ac2e678397128ab1e2a55cb7ebd3fb1bcfb18302033fe824829a4d08533bd61cec3f640d2be0f843107f4ba306bc922b1df0e5d2563225d271dac6e72a5fb7eece4d17a40375ddbfd0bfd0c1d8e5ba8982961e427927ef2ef695d2e65b9b48297a56ea3439e455d0be51e74ecc2f915702d3f623a1824e7dd97c19319abb0bd9fdc87098a85c015e0a63b01bef05c4b62349d8345117e61dc0483d174e4655b3b6c064df740961678b8a616b3223dc8bc027eb2d903d218733f82bf5457e0524b603fedfcc9ea886f41eccab12040cb42098b8506d6515524ac20abf546617ac384ae3bdd93a2d37ba1e3744d5694826220e61cf742d1715580223f90258eb08eae741f841357c066b35578dc677176f047407af3d47e156f9487c2274e7a3326ef23c911bc48d6da9f0721188e9d72538fa85b0550e58ffe2b6f8e4f2799cc3aaceb7bd998ad0da93ebbec6d436a9a43d62462bd007f306c0e3695ab0b3f7d1c6a0e907004bd3530a802c69ecaa01b597015346bde94f8b83ca42f923f044da7425690d9a017646f849eec161524984b4ee94634631629f98954acaea9614529f9f3d457f34f3eb4c25b40aa36371a4781d172c865efa80aeac125a59b4ebc8c2f8d89007f5128b6951790520fef77e085bea12f5c0d41303313a6cefdfc985ea2cbef9ce2d24065b2082bd7f0ec9c837011fa8fb00964b609b32f3465c052d2a6292c3f196b88f7521c0d90603e82f8cb9b0b2dc4965d4250088f40e274fbb1af8b222a816824c7ebefd00d6a3892686b68a6de8caf1b18ba054111b0d4c91d727c1acecbcd8b1e2d912a61581a13ebf9961c55e09a89b2091dfcca78a2f15f10944e03afb3a55cc50f1bab52dccd089df406d016b4f097084d070edefc809512dbdb8830d3fadce3aa79c1a619689153b9d751c92b05494fa829172a2d0d2b4e3ee74bf1a8b9c295caa4fe9c12a8e7480ba7f51672196b30986da09e809505d1064d828881a2e3d61702680eeb7598200404f488dbe6fa665a54bc3eb3f41f7d574921a887024b3e0b10845ac2191e514540959b65483ee7e26416aecf081222325b02838acc51c496481c19fc64271bb85da7bdd3674af57d4d6ee8be43adb6bd89280fe7d3dc26cd97c0320bc5174061ec73c4081355ac9bbb0819a8e354a4aef19c3c61c10d3ac39d23d7510b54321e88c8db044cd8fa87af7118964067ab86c1d87e5fb2ecbb207597bab261ce182e2972e234637610196e80373036d0a484ee8217528ffb6ab37beea49ac37017c0e297f2738c0759e85befdc6b1395ddad985cbd2a41e260b9236fdc2b44f8430a34b4c13ca5ce42cfe501db7189a41f68ac677b5111ec08ab06ca724eb0ea6e5da4dca9ad4596a215bbd3c91a895b2e4481bcd6bf435611f57f1af9450614de48136dd09d799435ecaf43de62446651a6c5dfb008641f0f8b5329aa5173d17ba0b00c569624cbbb1c5be1931a7327240ff54bb45e0c9286af05d9a810b90faee78764e167c8155046afc9f8be4723dc07e42ae69c9311f3538fbb0befcd0e4fa1247548e57609b95565235e4de0dcfe4196566112c5f5ccabefb3a91c3b40807f8fceab446be82bef119f34dc531d55b034bd9a45538d3e83f336501c4a2c1f5f641421b0fc26024066dcb33c7f382cd470ec47d00cac3a901a9fd0a69ee6f9a443df81079685534f51df4b41fc13b74a909154dc9cecc4f421dc0bcba69b458bbe2cb785a891e67af5ff93df9bde3d5ba49392ecc469046afab818fc2d5dc58820ede27cfba8216ab114fe10f9cf602d2073e4738ed04e6b933f63b765113fab6265b4750ac5f6894eaf4f2b94355cab964ed5576509f41d1b10ddd0bbd6cad06640546e02aeede4daf6a4d4d7f0b17acf423eb3ad8e55c6d0d992134fe03d93f96062e13871d9f5ac9b109309216fd68d88d8d3cecb045fe70c2f4b25fd0809bc0dedfe477e21b673b27856f803acaf7f6120906","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
