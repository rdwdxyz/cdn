<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a71c7501c15078c5157b54e51eafe69bfdaaf56a1c40cd4385e5a3d22c3e66968896379ca3395d3566d0ac78373986ed6a107e208cc93f956b284cd0cea2f539aec58197bcf10b735f6fc123ed8789f45bfd126d61c1008aeb2eea53c102e111057eb6634af8dc84e1740ee084212849790f2c38901d8580832917296be1a14ca5454f0b55c51bbd6013efb39d0b1b359f049ee60429cf69ed0da3f77034d28d4583f27aa770dda9a76d8e8abce9bfa9248208af1ecb9b053093114ae10e0816120a8df550120ed298132df80aaf24c7cb2493efc229b8916b21c31bfdf227d465172815cd14963a22d5fdfafa657f76849260397e7e077b88bd022c27f4f016fd76be570d65fbed06928677d30c847d62494070b9fbb3c4bd384ebfe5aee5a10e132a9e71140098a8056d8e2148ea91970a78a1d7e18d999d2eba198ee8b24cdc23ba70d132b88a17eb9aeab1e56a1f2715c4ef55776de5d5d642125151c28ce1646de65755d597987dbfd9b344a92b141dc38822e39d8846ec874a1939bffa724597905b2ab962868b9f6204019d9367b65c1f433a55c6126b3bddea72755231843ead785013b2c2af1f230f2f67a0499476bfafee33578a8ad72ecc8f6403409c9dcb61f34d073d160b1e84153049f3a165a911d35c5e0a5305684e553c43f572bbeca0653819c34a0929986a99413b335d3a31f2e278394baff57367127f0cab6e248077df40a145e020f4320af9852f8771f777b8278f447c8db7b976d9060a5716f73319242e27c2cb66eb4f1adf0ee2f7114877d1ad3e1598dd6eacdc4552dfdd7ebc00696d583ae367efa5000f7cf7171dfd0c6f2c7ff15531e55f3577b90051038e9a34b70eb813eda536611152f25c156b74b68bb036a00209b31881cb566725fcc00c3abf88331cb23b5537f19db2c43a3c0b61c87e976122ba0bd32fbbdc4c335064e91afce7248da79670f504b5547a247aa785d52aefcafd2b144066d67525f22f1bcebf829e0dbf15cbd70155076e059af8abd8109ab9b0c6af8fa415e98e81aaa374239b43ee9a59053d5c854e43b671a3237394ee925f68b7b4611d31494c3a6a3998d6619520a50014945565fc751930758aa9c5e6c4df97d11bfa53b779f3a1a81c4c0b8c60b6fe08b5ab02b28d7a594c6c9799638aab45156ec3ec61ccf70302617ec18e050d5942386a72ca4f5acb0507dd733eff948f00c71f1e5deba83986fe72566c13d4037d007faedaf54124c39c736c8c8fdf84be887ab985e460d35f0cd4ec695b31c8910a8f93af23240a689b2c1f8d8dc37b113dddab13e3aef3bc6fd7c1c1b8c67565027ec32da98eef8f209719b26fc0d3444783ac2cc5f15ee9549bbe25142bf22a383dfe228b49588218bcbc9b1f75bad4b3d97ecb4427a09632202e071e7264ac629b2d0b210c844c1d7464863b51933afa2b8552ec5ae951676d35fd36981d81c62b1dc938434e7ddc7078630540a5dd1f5aaadc49368c1cb4c475cde7500552b25b2c9e9025f930cb3cf9f01f36499c3490c0a82e800779d7807355ed071e46d8b729f3f1dff9e60d0962a63c51035b5001428206ab6c8aa4c473a3230c397fee3f32f6f51967d796f1b7d1374e6c028b2f1559c34b5c84480a38e2ab4fcfcce3da4656523326ab11cc3b078f768043b00b4cc130df470cd7a1b72c808d73d784238a530b6f17a4f55033e6520a121f9f4ca62cea9b86abe32b65fe13aad21e1ecfd8032a89d97930387ed3ef49c25bd49c3a5ed7be82af14e07201baa70a2ce859d81921705bf316c7f4d6f3cb4876d0c67921dea0609169323864c7942a0f54e92c7ad0c45d05bb293ab96d545b7d7d0c6527d467aea0859b8586cd3458bbc611729ab22d4044bf7d8de0f9380f87f70e20910348e4eb723a7cadc7f5c87ef7cf3701e9158d82bef99ebd6491f7faabaf67f2630cbff12b8b0673793e7a07d732f75015c523ebc25800c6c60763854ef8ba5cc6e99c6c4e26785d61f2c0617a7b90a421c2b32aa7ce4472c1088b77ac6c8de345717ba3465045f5b329b93e886dcbbcb36b22e6e2779a5b942b56388999ae6f03b3f15663be028ec4c056b83a801f5dd2616d39abd341dba84d794caf920a154b92ef992837b4586770c11228415fb352cce892440eb48e62288380c5ad5763c3b30696aff0777d462997735f90dccf39211cd7a7b263272020b484efc86fa6379b0b6eb17aba6b805324c9c40ddf7c88e1ea998c9253511ae870b32ca8b3cc228d6765202e4f899add831854e472d0d0e774d0b18da671469e576ea880d53fa0b8e1d639b8166ce6897f43bb40d59b53061b86b78844419e7d0d5917c338b2cb296fa463d74e26d611013db46fcbacd98c62da3d69f3af24ac4875267e28f899c0d0b93b74a4397cf763e37c1cd28adc4c45a88dd46ce267042c26e2f0dd34c567b7c9eae9a49eaf5fdfe4a53f17de3910bebec9be4bff079ebc07e814b10c79f60c8e11d1bcaa466fa537a7d1d4d9a9acd561a35487f81d8f3c2b9926ae4622f7ad2d958803d882266bca4253f5f695468121dad056a5f9f600c533bae96bb13e12f17f2df65fb039c13880853b61f51b9ae61bcf64bde3fdb67f1330641021a8ecafbd7e5b56b3d36ddb31ecb41c19973a2b1ca3658c40839ce4df3729b9ae850e963c713404452dda1fb3fcdb761ee80c3704e9011a382235f0b5ae6436a4ebf286d467789eebd2aac76aa7dee7bab346872f079c08c5790bbca3341d329a47213a8dbe7723f32cadb7c50452d5917ee6b2394e7f9a09cce980843f6586f0894631768702f8b84388db838e7c3d9eea3f5207629bf2c46f5975f81716aad99b12fc285d396fb2cf58a66c2b021ab4530183ff8b32f8aef3fc8308f8dc3cd1d5c8dad8d036fc7bef2ddb28720bc46cbc5fc0164a4565fdf2f6c95408de7406c9d30e5d8bbff7769de412ae9ca0dd4c92f968d59b53506b8fab3a9888ae05fe94b583163cc051b0a69504ab74445ab43e9eff9f094e77f25cf76bbf81854d4c03b96ea4d2da48ccbb0c8bc28bb2d41f72d54af961fa2e7f64559b594458d5d24420da44d72900281c427474939ad0890f30b5ca456bb6bdf416513793888fd5b400d3e60781acd95d022471a114957c9b1cdb47fe44d6763526577394df8a7c4a96ffebf16a4876750df352f7bc15ad87d0126843793ede2f585d9e95db844e5b4fc3758d89760d1cecfaf8269eb952eb1f78274d8361c913beaca54875c0c565f4784799b724454c509f37e523b2d02e7d38e3370502255f32cf3a8433b0af47ae2c526eaedca13c3ba9af1cff94968efc9dc3348421040639675d60afe9442230c70360123e821d71d0791795cc29121daa05a55b1754cdfbbf29e9120ab8dcd3dcc560e6192da4956f2f0bc077c53eaa61e49625fbf6eb5f2d4de09da62f2d2d3f6803b12fc261d3811a7d90b88a0e95f30e16286d5fbd2abe709fbbfd88908631da98eee76850acda682c79e74998faa880cde4967d0b13c53f3dc0c355bf4773fa7c6b711d75e4fec32bae362192bf57ad77a1601a420e0e9de013cc4920bca7d6266c0b5fdd668b2c0c4fa614c28825b083b11b4665c5dffbe6f37455ff0002e07263e2dabe19d459e27c2f8ced8728fa5eecb67e95c155aa6caaf6cea5d392eb49b4c184a777b72bbcf20642941cf69167f8e8468992d2307b436d1f6ee965c53c0c9c7ddb94587d4f2568fdab91282634f469c3ccfeeb46bbeea7d539fa8c4d06cb1f68b218f792c493f1d3c8816ff5a013c7d23fb911656145ec5d7262c408920ea462b3d1839b4b64b80d5169cbdc29256be692cbe852f7dcab5898a27b62fb0d9b41ecf9f315796ce1faa8814b0771d8a79a5209f8096c51ec7ae7779d652580a741686467c425f7eb38d6ae3c49589bd732981abb336cfbb021f45a304b868466d3f41b319d18494e373474b10811942c6f7417409ade2fa1ddae0fda3f4d819e01e70c8ba8668ab98899caaad8aa981e9556f81a54debada6c55a78960081c9848b3f3b1ab8011af6c029ab68bb9e22cd3c46eeb8c1428a865175b96ac6b1b5d323774860a1351794d3da462d7a1107cb108e59df5a0a874845f681513f0718213dfb76caf3d92814b01c4dad9804d76ac97cb32d9a11d0b83a86fb1fc062106a08295bdae8043e8863c8d8267086d67e5997d5600f423e0d35838f6f96d0f479fa41eaa40642e0b8e80fdefe746c12141c2c9cefe5582f1dff18fd1872f470ab1983e3bdd3fb8cb6d9598e12cb39e25edb08fd635c9a46f7adba8962dcea84f0887cc0a8c7439cb0e38bc1f141dec4b4b1b6eb26b924a472b03efb11e617c3487282a182c9beb3705444abb606b1d61e8dace7798e62b391c34757e85f41fa9e36082336d6b9734409cfe2137b57e3a279262e84a4a11e9e56946fe68a6a6c35bb6bf8ebd32b851a13aeebcf8958d25bfa17d499b6e29bdbde4d3ce40e8160bde236785bba45933aa1654cb15067692bd4b654f05bdb796e7b8154bfdfa9647412de94f251d0b5fec493dc1210c09779521d60f885e281e4b35d5003de2e351a85eac7dd8cfd6190786ac07ff8dcd61fca64520e0bcc73cbe76684049c80eb155ca098564928dd93d5a575ee8ae7e87c9139be04c6b34bd3e103f08196559b956977f310527234cd715e82e81b1bc0373b06e4ee2712b8caa5dbe007ab88c93d781c4a4274a6b8515a3047544fa9fb02aa90d6ac270d681a699d08f316bcb050347b9ae0992c5915de5b4a65e1b919c10550def45eaa4755ed65e76137dcb46d48dd43a58009a416b4bf9fab1eb80dac2eca5972ea5d050ead3e7b3b08db00354e1809941f938ee618a6e20b653b5b05e4d65e0cb1fefa5e66bb6b96e538de3f96ae8b71c5606a77efee58f6ce3a74d3f8d42f55326ccae25bd0d91d4ecd00a9743416170da79b1982f728198c00899529ce93e4a74e48e4ac1c4b9d63cfd963bcbf79eb0f4cda8cbdcf4dceb2f462119a013c2eec2ffb2b3bef19215f2a3f1bd0349921e9413cb0560f0556824e8695e9987a4c37404aa6d7942ac2f806b17b9d87d40bff13ce09c6e7e8a1a0809e6cc627573de80ead910e5965913b9407b172d077ad834c7eca4c3ab231c0d2897aeb3f870023ae6ef14f5b2077187ab6fc2a013d22265bf3750bcc0237ef1ccc9e8aaffd550a8c0aeaf7736207b89aa034f8506eb60f688e7135e2d7196c2fc797ae0e2b7d4db78a1ecfc647647831ae8add7bc8e0a4f94d98dcdb28cd30e4ef32877ebb4aed5386a01d7fc3ed47e0d33cebc93f7a088fa64fba553cfb0cd407b670600f59ee9c3ab835ca75b128296dc4700727603b9761487b60eab671066bf3ea49b3702dfda99c47788389d7c46142631edcb2ecffd40bf52af088a65165a4dd6faff356db03281c4d81ccea789c9598d32fa1eb1210df5c96e65bdfb952a712013714cc9be2a5f876c3ab169a7a94abc9f34d548aa41df89e4e83cd2b4e06a37e7b6b3597a6ac4e2ca398ab00ef910c263f5675b69152d7015c4c5eacc8196d6801d5d35095f8976d6e26389da6fcc24722a4cc08db52891660d54c180f9ed4104e6cb8e73956d0c4305c1e59a04f69613bfe9ab6116657883efaee4d9b96e3fc4230f6319c04cbe7763223ee056b863a4fd66ce22a9f4ea998fd4f2bc455f6c700f95c1ae069b65f675a68ccb9f13890138e8d750bf1492df031390cbe1da0e8c9068fad7941b7f2b21a5445c4aac7a835cb9a8e05039af39a802ab6f59de2e27c93cf0b178b52c856d841a571bba0fbe504957827461ac8404d66ea9aba5b3189619731d3e4190bca581472202f6f1481df172841285ca97a6e7c5d607c62e7cd9a24c7635258d12abe654fbd4f8259b3bef4547851dc0d14515a7a5d79a358cad01a91d21eb33e5de533a754b9f105e756e2959bfe627ae5e4cb2c2b1301cd7d500c109ff918ff04cb553291be9dbb1c9c8fdc717377c5810426ba8e4a92191e4fd96cafca4f6bc42a5c77799c3f01a89f8c4b1b967c284e282362f379b3bf5c5e4b267b465d1ac101ac3bba165fcd9015dd900e5259e2c61122ae5b1bfa015546ee07b38a46d4434e7eaade27b91e02865d0bcefde25e0f15c6fb2ffa25799582ffd279660ddf60c9cd3d56399f3b588bf55da35d086959f80d55f7af199208bae8b53629b31058f27e3e19452fa2b080309e9b5316079bb47e002c519e9610f4c3a09c0a2397f130a82aa9b28100941cfd85ee84b48e4d80461f9f12f6cbe225337d03c5cc7b369b97edea5bad15ce4fce0e7fd958837ac77edd7a9353a1243c9283f6e082c05e12b09a5e3f3bc4f3ee9cfdec0daea40522f0197819b3103e04461bc75d92b56495c01f090df8dadedd0b17f4ae646fac81bbab302d63a28e99b5e7fa0e879ee485b95f7c4946b9ae3ad1e8627e6af66356f8b62d4f174ecbced3b86c1521c6d238a2b81dce3d1a2cbd78106c4195b39577d80b4e2440832987fdd5cf28ada11507085a1823f8590a72f7be973386fca28921ba619e7d54729704cf149d07e265b41c2501a153780ce8797daf0d2a01a6bb6347cb44ffec0d79ea395ef1c843b05eafca975bcd37036eba92fa156189a949e24e8b3c023e981a09ce92c149c471f7eab83eb62cfd8c55a1213ab7e17b26386c484cd9495f7dcab7e0011fa9454c1a20d5380a89d6da0c87f143601f9b5aefc49671b36c876c79e5cc82655aee4ccc7cdea5510c8b5b43155a1f2c47deea8439b254cf3db47bdb86c5a483f1403eb1b392ea0cddd279d8ccef4d1f9fc4d44d089b240d1b6a21fc3b3157a3c184f4d635054c3ecb9e913faeac99e5da1f5cf9cf0e74d7cdf910e2fec3be38655553ea3705c17887a551de322b231d5df0676c097d5510b442f5779b511e3d4c1f8ee6a9c1ca506a6d06a23fcf8fbaa443bc6e68d88a74efdf4ccc5d21059e1383811d2dac966045a8910462c54899fa3a63e36eb404006cc13009f8e155b5e433473f0ab5ed5afee804774bb134a0bfef7ef8dec1d4aad7a4d409f91ee94d2fe8b6c39a01c6460342ab343486ac26d473df7aa686b3b3fce706a5baeee9aaf3101da7780925b16716a26dfa320d114cd15c59af8762b2074537b3c19a0b60fce7ab0a61bb047cef15ece129c095a002738a9726f6612c1b9d5b35afcad5533dd0813d5f5fa055258499b673889d8434ee7f2c19e42c7a6092d25618d78abcaf3f96214c9bb9099cbe73326b6bb97e75d4944e4322bae51e46d8841f3f6ba14d49c9cb94a09557ccbdaa15e85e6c7e967bfeaeae82cf387f63fd15d1b90a915eacdbd9a119c6d1cd416222eda5157cee138300c7fbc0c01f913a039bd6c5fcdf14515150133f07e07ab4047fa75ed4d37b4316d3721e27e5b50f5ff09d0eb04c6c682aabfc2bdc55e4ef506217fc4c44e22fd4ef66c5cfa841000491e7031260030df2f0d4b6e57b2e5efac7a98f63c3b93e6458d8d79c88ae6963819497680d5a59e37103b7f08a724e832d0f2349b123301141d912a76fcb3fde235bf28ff3d55096e19d873b6fbd442a45f2c26e587123c685fd250c2e1c5b61e9d361d7a39da774aacef44f58bc32d6c0a2faf750264563da3fc2f4007f1132bbfea2b38a0c042627800731081166afc0456a7bf909fdf777f24f515e4161d1b84e19a92134bba6ccd33be32ab2851c9a58d68792376cd248a012ed38a7ad80eb2487432d20caac1eeff94feb220a3f0e00faac29d3658637592da6c739ece7649789c1fa6c2c8d1b5de7616af9f192d9e52ff8098b3da98d3d5b09d145a025bf327892b3afaf44c6e2df2ab69a0306a29022cb4a44a4e98e5fc9930e4a4ee9a53a979b3088b6cffbd4747b9d538b5205667aa51e9c4c0381eeb45fa34e06e7e5697ccaa9a06bb0575a86336e24f179fc8dbb0e0f99e2d486d97a006e705be075a2473e5e91d99d3428cf97416903d6b6ace7e2f126d0905eca41d15a9f184becb473e8bad03b8246ef5d8d8683207c04ed4f24a0fa7be8ee3e0934f3a866dab6bbec9f1dd926e82f78e37178bd6475435d55a85956c28a99a17cd256fd7d47dc7169d7530e6a4aff4c37ad3a7154547885c2c077a8749190a9f1dab56c28c25659b5e41dd2cfedb1273159d77a2f7a50c70b7a5906eb64a736867772207334b2a2e4554aa45b62a7483a2b167a6830b6649e38314a80205f5773f2e57caef110171a01c18401ce20b1fd738830f937d7206920684adb83e55de298481b61d5e8b85d8b24fac4bdf28db9b7bd53b25445b631c96dd7e1d19c5462b57d7860c9d870dc73ff5633f8e68223fc3f6d2a1658731920f55c505a6ad5bedffc24be4e8bdf850ebc1ec7a36100bbfb87b63bd417d15a8c1b5a083f18d1aa556b4327d742f55db54e4facc381438f1d3c1923c1afc497351f94e28eb9b969887300082d9d921561c071b09aeb2e54c693638709ba48f88c20e841ca50a4f9b68ed4e807545a5063c4ad9c8983ead400131cc72f03da038c11228b2dc0927c5aa122245303bb3bb8b91367cc0ee45460032bd4a4ee429ebf1213d659d5c0cf7649107fe503e714ca63487b483c9596e209d5ccc4e2817c845fe195abef7198787d5e122d4848998b5034539581490550c3e55e0bd7e998200dab93727bbaa73d795178b12966316820a559e925a41a03a82e0ba764be762f6fb39a569d496d866c3643d23d962c769d3bf4ebf5a7be36043b9d9f1a76eaada535ab4cd63607c892b31f2ffaf470651f20b1e2c4cb1535f759f7ca69cb02f06f53fab687566b4d6513c1ea990a9108edfcfda7e9bff20d9e8e7920396e1cb1247a80bf7c9df6ffdae2bb876123ea89601aefe3eabbc01846e4a655eff73db1990f7c30ad7787eca1d80e55977cac5e91e16406a3b9d9baae11077154d9898c3096bc2c4321e6c056db175902d043c129d0c313553042328dd0c590aeb819ed05cadd4bf144304a3bd09483e53d29377efdd8566102399597ce816dce1827d12de3842b5e7e66c852799983e3c98f20dba1030f5905a1bacea5e639e7bd0e939ce26b45040702472648787ab2febd88a75746a84780d4c6354140b7284c6669fbaaf5586df63ca01d5e7b6248dc8f7d7c3ee0174e28df934514b0eee6054a5046c2f889df9b981568b5d96954f3c1a9b05516840eac39aab628f1012eeeda923347b6d815be32905b196a45a3af6e275e58d7600eee5c161d8c4ee3d7a4a9d1cffbc52070ba7ae79148b53cf1aaedd177e33ee497032d9e72b54ff7cd46745cef26b18b40222ece45600a43d17ddb2e5dab59963f49aeaaf2b14a712f9a947c1ca0c7f56eedd9189242ce83fce5cbb9bf4806f3784b3de2ba352d412f5f00d5492f24dfa09122b41c909dca2e1a8b4a4e0d526523ef41459fe6cab9e1ffe96d45c84d584c92694f1ab2727890aaa7b75b9ffb0d2632bb0ea633adced6792d9fc985b70201a4d7a01e28c76c2b653eca2f5aa3b5ddceb607f8475360e461f7911bfaad48383bf762de11db70371f7ce832b125deebb4996824d4d3614e83d66c372de7b91344801006c3326899527a79f98bd68e1e096dba6b05a344b63a966386bdf40b3bbd33f10755ec43c0eee4075dd76ef30c3aed76fcb01e3d4626441e93f7d36027685a9c091fcd6aab0f1bfcc0668b4d880ac342365515246bb44db691ac4fe296d7400eb41fbc60ea8cfd7899212914734e7ff7a19c63b9faf88f33e4dc50652a40f7a08fd1c112f491f72e3591e94bdca0e1975126f9fb6962c095920e03eb0b5161f75f1fbc0394325443db5a14244a99c68744e4b144bcaea385739ec2ace27fdc4204fa102cd18d0d9b346b09b812c066fff225a081e2903954c008a86f8b79dfef2f2917932fb0f63f4f1b441ae6726e530b208b319ad6c77dd98bb7142eec897f3fb69982bbc66f34a46598473554df207b2cb1d36f4471d995b0a7edb5b534ae37c993ba5dd66e158453f75880f82c15301b4758c8a3399df3b62c2e91c1fc58d08e0aeb744966430818bdea7f4a023c64e6b8c23a4cb834aafa335bb88a01741343a2dc7dc7c88c52cf9e3f2561f80c3610e5c788939dbe640c7b7514717f84cda117448429ca11aa6bdae23dc85cab8d2ab03a79f466af4a5bf6448570a085614aceb7ae4f6f9c52092fc35f0504310f9c5186956098b01ad0d2d434f882037df8ec9f0edcf4cd869090c5bcef287f8d380ef6a7481addab4cd08f36565b823b3e81159c8037f2abeb88c893b7c8b294e3b066c38eeccf9fdcc89b61058aae782671f0045a152ea1dd659089d3679c05031c532ddea58882004f20531b6bcfa0e652e5dbb4d7752041030424188a63e97cc1471414f0975ab7ed247079d4ccccdbb7b643c863ba6da083c090d68957c47527a7344a9f2fed74b335e2682821cc45a66d973d90595f5c01d14d9354d5c581859f0a01822247abc62da3703813d300b5fc6a93059472d80a6bfa0d87c927bc62b96f784dc0fa7e1b51847440c00488f356053be1c2bbc525ed82ade1fed1984319066a894abc3259f2baa14c2f357cec4f96e726a54ad924eb0dcd335d0df52ef3cdc6beb98d2152e9e39b8bbec56699ac2e43182f4cc66714fb2bec0375e789427938388463a7af263b162f913f57c915f25f5717710bb199dff9af181cb4b7f804da9e869d552e8584e031dbf0fc198e33743b110acf1732709ef34963bb107963d8d424d77b4325868e84579cf03a860bc42719d49e2b2ca8f26a8b74d941a783934cf95cad9813f49a6c70ac5879f15d422b2b4bd74e69b4878e07552d2dcd3e6b11491d7c5017d73b561dd7d275f2ded1342461a39694c6e4712b882b177b11b7e4c26126349d2c3f284ad10140b8be554acdd04208d21a7643ebc398ec8ec685a7b961761252d9843f12942a07ecfdc91eca14b921f60454db11f12e62cc07a51f42a94a3e3c9eeb1b9a0cd98e69cdfba3334435df00a09948eefee4bab78fbc86c1aa956d55a4c0682fe964ae1dbf00bac2fa97973b066ca5b4b474476eb14ea13bb07969d8cab2bae6566c8e42a4e51453d9aee78dad13f128e512c8dc625ab075ff545ce8b57a876ed4f5f0fba45a834b2b28cebdaf3117677cf7716419e6d85e68354ad809ec1a6b220ec031d1467696e26e764a38a0b364a145c11b46ee65ceb4608c3d552e9a8c202edd1532760b0c87bba298c271bcd7db0dca47dba3298dc32a7c6f56d3cb9bfe7468535cb0612f99a5860e894a2921c6b8513fe84c126c74925bf5a84b5656e7e99c35c2cdf634cf6f7b09673d2b6f94ad832596f0e2d0018a7aeb938baaa40289d9db7463a37183febe8a85e4a1156b029139450500c984a09ca0f6195425059083dbc30db17f95d1b8dc5876f658961f360a0ff7bc982ab919626566f2a82f207d4b56a9ba00ddeefadcdeb091bd5bb157ac234e380de4edfcc8be60a93299c0aa013a00a2087983a6b12e6ae200f0495c9aa5af3e26d8ce25257553b61ae1ab4f2a42a7c2d79b1a305cfa4b08cc101076260046ecfe7d3066e03e8252939bb68439983812832edbed7a1fda021e10379abed4388a907c821dbadc258c80738da114fd1ea2a3f93facfdc843447dbd4ca352618750850008c801915fac2dede525a05f2a3cbecf06723bb94906da2856810f59b7c822f63e073ab3ef1a8e8ceb70571c9f78ed2ef3b9021fa7817285f6bec8f6a73a44389dd4dc7118c8c06285d9f8f623c4802f2225c0f90b9d7570dbb83a8a9cf2d11c0d6be127e712f5143666d38d42d8909ef2fa03aec9db6ec6ebaeafb755e3768897daba98ae96e6595ce685771d20a71cc091cfd3919ae177df5c946b2170c6da7c4164d371836fd42e056d01635de3c56216d3b7ffc48330cec4ba1b0336400541518e3688da7b470cfea5786460bc39d7bb332c7d0c8a2bb7f9a66ce849fa92b3fa6fd301ca11e1059a9b134848ca48b0ff60cb78f0722b3f0194417f8e65b54eb3a7bac72f4779e36909fede1bf7698a08bbe38519c3737c6e56c00b7bf0b8528fcf50b1e21860fcccfd77c4cffd323b4b254cf1e4e0392de7bdcd5bd9ae0d863b18c0f2826eec3850947b37192e192fa7658b7825206aa69bebb94bf70e38ae46081949ae880280b8b16ad59ee675c2e9ed7488b141cbf215a13638a8f313daa50254eacc06f52976c514f50ca493c9da5fdd41c35117e9820b73b718faa057d876b0ae2d88094707d56508ddd2679e4e460ca1aad634a21c0d4419f684587b1204f3d1fcb301d5209df033abff328de6a0049dc6f5b9eb4a3763e40793569a989be4698b13d267a5ba3932f9fd855a677ef0e173fb4f807cb08ab4ffd24c39549e567dfad6e68d10a26b216c898498ac97c04df6bedd9f0801895a8189ecf5121ad591dcced03266061c7f224b3cdbcd706e621e60a5a8fcdfa6f61e623e801ce7f926c3242f424333a1c5e796037e9f2c2fc512a5038c96d35825ef9ce49261376bef3e95330ebc19af7bc2202f49580cb892442f0975bd1dc8f85acbb3f3f68fba5c185faff160f9a270ab6e8a6c09390dab70182b5082d35a3a14b96460f40f4f0094496ffc2394f74d962d8698ba213070006c6b5c23d042e842a91e8dca7e50a6abacc0587532aa626a1b3873e2c87253c461acf19bc020d09ed2defe8be07025bd1eb6a7568ac3c5995ac6b9c72e0c622faf9420b2c3a82ea782f004edfc4c29e69092e04bbd60453ba63a3d3b86503ca7c352eeace0d6e1ab0fe97422b5152f80fdb09bb115e04c218a87dd2c9c0a7557367776fc19f0a900a7b7f3c8d83c48818d8654ec87520a766968444bb41ff6e24cbc941f06ed28aeb133e53aa6d77e916dc7524f0de7441d7cf601efe7f192568b0b13f188a241ee1c5b02327a65df068de70f1e9ae04d2c2a562e93035104030923df7f46cbfee09c5275e248e549009dca9dc05b7c9c4d4c395e111aa8535677521be7e292cbe69ae5a6137d86dfd47fd71fe764cbad63dfcf6ffae89ff60e3b0a036e2c2dfb66fe07f9e08acd08c158a10342502c3cf923bf46fbea731ccd8ad55277125abfa44cf037543b96d047cf3bd867da7c87d2f29257c02848d7b4479d24343e9498760be04369e345987ff0330f5a739339ee1d24bacb5b9e9d96aad13bf2c1c2d925e978db07b65202520dbd8f5e8dd853f3a69d13edc448fdcce2e201303a0f8ded32d6d83682fc441ce9fdaf1084fbdd3fc0bdbc9de08372fa77671deea52dd2d9e7edccf34fefce6f2293d08c800d7f92448ed67939a9bc3cb16b720bbc2feeb4a638731dd94c708a4d35388f98def9eb91f2e8c25aa0b5fa9d3308d880c9b256e51a067f1c671aa71cea4b50f18919be628382ded06a68c00fa94293227197501850ee388a62a0770f0a263cf1f0a8e51c7f01c04beb75f4706299572f1b405f96f4c7c609edc0af1194de76c86c30a545d026b9bd5ea2923dab377f2ff25dbcc15af740647572f33899c58d20a2e36b35c9e361fb0536c01d8968f505b2f2219ec99321c215d1120d92a36a44cc9add9ed1603e688f6d4cbba10ae8d282210c665f85472e59a420e0c169dd28e75f78751588c9864e91d63f29882b418ef5f0ff542ecb5e6c3807240cf069ea29e1be085e491e8dcce67945d87e453173034895618c01d8c2398d9b1b80859fd2a2d196df9b7aa833f11b961f4e57c4005158bb84cfdc02a74ed283658e367958071bb4b34e2a6b112074a6ce0df3510b14f45fdf8d73ea6a8e4158639a59ba0e52e76d7248a426625295d2d4ca038868d75b69fc42dfa0ca4af98433f3ebfeb0458602c9ce9e155bccca73bfb6148e423f21f7694804fbeb85428dbe4f756232e8844d207d4d72d1b7ebea01c917ac2ede8f832849e656d8e682a88ef8d7f182dd5979cf69e0a348edb6fd695d48d3113b3417e0d31fa014332ea6a83a2617b8976d4a58c742ac0decd2d008040d1459f109a6ded3bc35cb23f70170ef4a370af9225730e6d239ecadf6f8ba9f16ef6b55492fe6aeb511f232320b5140dc892675927ae98b3002270cf7668c9b0e9e007c0c74b46e8edd2767a8c6e4670ca86c561d4cd7ff077007bd3d5c1fa1da3d7fdc2375f4d1ebaeb089443508c4792d26944ff4b28ebc3b9f5b64aa45325ec9e3a327f517ec3858dae77eec216ffce18d3413fc1665ec90e268c145b2c3930e275aa6547490cb759a5176a9e6687c9bc17e944157e4fff8271a2245eb9d2a4eb58ccf7615b6b394d64aaea27628eae288cfdace5f4856f4b59b5fd4fd6243bfb6936cd7902db373cdb8a9e5d3346fcbf2d9983add6663c22ffbcdeb1c0bffc594b868c2aee2da512e6f2b1be0bba570087f113c0994ee5c9459408ff3669e4e03b92bae91a4bd3d4bdca0cbc1419cba5da88da640b0baad52e6ad9edac539eee2c5e85c5fe18f7b130cfa26d10f1290e0396c42e7e7046eef7589a302ca8fa127190a71a375d91448ff045ad025a1fc14aff6d78c84b6a135112e5b5680530f7f8c5df17d34ecce1aee492d549f21c1509d26051c1a421cf64345fd1cb1f149ebcb1358328bd6247446d46160ed5bc818dece2fcb40137b3dfd4ccc70af787943711dda3345f6b67762c63c48d8a80878eea185837a86e139e50bd60206e5714c105ec64f39ce1d508f4636c073bec0d4a0bc37d8313816ca7beb2bd99b2c995eb10d720c74ea4015098c97f8c3cc9ca9b5c2d0521a202308965b588d99a09d6781176d1843e31ab33b5edfc5f3f649f78960c7e76120cfb87d76e9fae2610a20924515b1cce6361d4149aedb4356e934b5cc919d18a4351bface9572337089ece6d65a0ef32ddf9d79735855a4b73f3211b88d3958e4226bc9c4afe5bac8f67fd2ed772574320d33662e45185289849304a4ffc34c26f852c3d51e340832fccc36c88f605f3e0952c376fd72dffd0e48fa950f3f107572e0894a4b6bb24fb2a7bf3f1c98c8d5783b1a2499f8627cfe9c303224d62090235819d379b8f4147bd1662a7ded7e80ed216a77959d2c237edc79288ca90a2f08c1820463dbb8931fc86f0b78c86afdd75ca6cd5b270f08bc50d0d7c135234fff14799ffb5d3017ced9bf020f8a62964373ced76dcb0a4bda77d9aad508c22fdd5b1657626055c65b791590355f1be2c0e5e6b77ddb1572f63f14ca30f9f806788dc970f34d126609de0f66b27737ce39767cafc37d37e44f0e1ab62ed0c8d3492aa047557278b3717a1a0a4f9272173a73f21bfbb4d09a263928d384a78940beafb6a5f1781e39299ea3f3039dc404b52cc32989bb6aa20bb87beab2bd462f79b36f89e077d57a12073ba938d34c2d41d808bfbf6b7707dfab90d2fdb9a933b9b0fb1775898d3149cb717e19d0d57da81d77863f74f8a85827c61702c541ab65fa4b1a9b10d0e27dffc9e3c90fe1e56c5367b7ed53c0922d2e8b4701688331c75cf7fdf6ec78e70f6d5a64ab64d94f9c02cad500dc26bde9a15e24b8e183d62e8e0dca9359c092c7f8c2a8aac9e906ead88c081efce2d640e6b90b43d530cfcf31f971f5c7c8583edfac274101588da0d8d2ce2865184910b08a9d71dca04062b9ed1ac667db6155befe547cdf8c57e0a60cfeee91a1b2729e0d4a82c5d4c1be369260370bc80903110853b94d3084b5cd001571144d39a41518bc4d16adc5ba7c48dbd3ef833ba3e832d99bfb0aeebd4b22b7eec41a3d7c538eb6af70bf4621988845d800e0597d14104a759f62311b6968823ffb4d5af346be841525bbdf16a603eb942738ac01555f62abfcac3af729eabfecb2e71d20435357ef7667748b385c8fa1873b7fa23dad87ece8894fab48e02647412ba891262e1043839b172a079aa2f8f9862a051eefdd97f6615c7456d9c5c4c409fa813a5fc5811a6e679ce7afbfc3410b66331da4f4ae426d734117bd1e1c4216e1515e6e019795a85877dd8ac233f9b789748027378e6e8051a7454e8075658ff939278f50bc1e2c642fe6616e9bd6906376979ffb003a2d25eb7ff3c6acee33905e5b5dc1f02cf0cb399c9cb356e4a169a8be2a43d52989b26f2e3cf27bc382d0de4f724c7194672d189c655b3c077e645d52af675430dafaf9b7d0c473b18d76361c00b031c99a6520fe91799575b6c926be368aa14d1cafd39cb34c1b1d5a7c40c1ab7341120886226fa7f9950ea0120bed902767b1fe91408d75cc69e468d9143d11a9ac0862d56737e6b86f858fd804e0e533d4417d75792dccf5500f77f29e52584a37549946c181c016ee9916dca6ae8d8013ba27386a4352595f3acaeb9736fd5c5c14f054180e8ead75eb8d869193905a76f7098c51c8c885673ae95904fad0b7aa7ad30356db282266ac739a5f00d038a5e1fdf32942830d5f163fdfe4af696371cdd23d9c8886c67e302c3c88019bee50d01d9ece4ae9451b4cf9e9878e72416d4ee3f0032b077f97db68ddd25ca2fd09d273820ac3ea6bacfcf8e44be8515e6880f2650a12fa99ba0ad7c9636ce5ade76d971b8e7b519268b6faec66d429eea66b89db95c3e301d29cf4001da09c2949979e52ebec23634d145b8ef1bcc193691e3cc4f489c1f3570ec3902d9ea3031afe6d66cef33e09e8974c748f31816d2d6a90af0e763c75f65792fa287a0c83a1eb6af80f837ae8c7745f5814705d9fbf82130b6d3d6a6580f40426952f326e46b55c927c56204070e8e6d2a0094aeb133e150c68949b1fb731111e2fb53c8271577aa3b75c47e018d026c1cdba7857e37251eaa45db1c5136d7afe180644a77044493a21a6d7ab5134f5f70d18553233e256ab6ce725d27e10c00197306d511548bc85aec633f132c261162fc9057637c2dfa62b3b1cc4ee484ccc281b203ddcdab03d12592057f17e3cdf4c920344595a4a55e6497dc3e20ee1e3aa7bfddaf145826d54151c90a85b12a3b9417fe7728f47f10dee2d448bf49c380ec55a65a03c663b020e6de78eed0999be31a5a11b51d0ba4a278698f6d6bb11ba3f1885f6f640a6602b01d4edcc1e1b8facf10d4b785f6605509432a8274b471066147c7ee6430fd56088c835ad8a68595558679d6dabc913b3a1de052917b5e2a65775cd32eb37dd9ea7eef3ec53acd356de8e8e1b2b97e6ba1cc4390cc361157a64f482dc5e0b542b34f19a17b3d7135c31e134779504a94fbd80597f6d73edc97f60143261cdafc35fd8c7462b2246422fc25762037c94588b2976f11295a05877cccae0d9bc90cab2f9118e93821583abb00f5ca7297c88eb87eee68811f75a64198f260ef358c8f97bbc4186f0ca4497ca46551e680728123302da93ee65ed17a42cbf98eb874bec3bf3254c0340f1291fe0c8e61d7a75a38fe69d9cef9e7e33671e5df27c38234b491112ea720075d7ed00b44218ac60cd2f76fd62968eb194dd81eb8f27fe4592657c01cc52989a8f2ac36cbebe30a0b3eebbb0d8185102c5c692037e071cca21ac94ef751979b17b6addde15e08c44494b7d0d3316f65a0a8b33e576547db6192fd36f1289f06c76a15a8115d68dd0f5e071f73fd730704b0ad4924ffd16433f6ff6716793e4b97c2c28af9d0a112464cb2641cfa857e31ebaec8868f70066fe40f5ab9ebd443e9c59b6b8d776eeb1cea385b1ae06602ad732738a8b6175b8e84b8567ca207c6084ff682ff695a748198f5675731b2fd3edb2382ee776c47b9186a09e384695f89dd4bf5297760561968381cf6dce0245b5cdcf12ed798d1cd15f89772e69ea049c1049284f27ee886f72f5979b853dfc163de1ac604fa9ef206e6f2236d36b2d345c673999124c1e5f253f6bf42a8dde480bf079f8cd5a71ad88c388a9b6ca8d20673d46de91acc2e8572171001ed14ecce5f1b328e95379129ca79f1fc83e1e8067a268698e741171db01f7206d890d79b2e9171bc999ce2ae9a0aa3e79afb15fa1c240aa3b5f885a8c34f20a16373ed4bdf21cbf12ae64f85655b24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
