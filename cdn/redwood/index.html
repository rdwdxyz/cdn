<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1c69b1e994ef6dcad60677cfb1c019f18f38bede5b2ec7b8d2c45aafbc750f29b2de28c9e37af7ce96ec398fb977c17827aa98cd2c9e28f27922c946c6e0d1be90ea85a10d8dff9797afce322abd145f5b0b9915729a5052e9572edc736916a10e8a9fc7a3b3a87164c4d453f3023b9070449dc2c6d11eee30e6ce4a92c8b7a756f40183c0554eea177a84d24e8459c495b684a0e580dfb2ac2a914a326a2f56cf42ef8c7ecbff306b46e9e0918fe07a131f948844ef09f741135331c67f896105a9df0fe5b628cf5727d40a9677b734605df95ae492051258a916295acfd6ab30d0db7035baf010cac22e57851ee6bd40906e3e92f1f5041bffe4e3f3ad0f4085c9ad0e965c5a3a5d78bcbfe1c4b139dd163bc91a4c443b0ba0287a8bd8085c1c54374013cea7539f64ad332f1a34ebbbcbd22b054fdc2572a05f76525fdf698c8565b060881c6650d38454236858f5f31676d608fa26a2f2763e23bcf47c7121aea916dfa0a5c9886e7786ac35d688a94deeb1e47361df5f8dcd47d0ca08a9da58f66c9f7572e737c3d04774c7af20da8e16f058206f73a1596937437fc8b9f97a2bc2881795218359b26867210f991fcff4cb82c0b1d02547bb00f98c2e48b3134fa069287b7b70398674d86f781636b219c2a846e19c797ebcc55eaaecb91ffff90262d52207493bd32c1f9b15aa1a510b82707d9b8a32e0384e7efe690d001345b5870e4323ce0cd8e1535c7f638879655839464ad2ade2ac9ea78ff847563cb85c3788e42a3eaa3c0dbc2d3d2a85d4de7b57d33df79f169f1e1da739ec58e05761d84208cb5cc53708889d27e5687b2961da26495a71645ad04c4e64a55ab73ab349b91cec4f8854a4e018467da1989da28fca6b7c55a86004d55b7317f9666b5618ccb51573b55b33e78a45cdb61449214cd2c4077c1dce00a65c7c030828330525899b02519a4fbedc1e4103b2eb09f739dfb4ab20cf7e6258b5659869d691f79b8849dfeebd2f6f4ad4104a58646ee19ef606421c85840f663dd27694f690e1d0b056878c392393fb439f95ff3fbd8c4d9477519f30c37bdd52f7a97b6f4cf3a875fbf04b14458ee0156f5671c063e5d8fe15fa781d2df43a8440efd4513cce2f5978d238d54caa6a3416db8370008f2f08aa29316c577b0a72c1a45a89582f2bd46f9aed9b951080fecf898338621334f73ce3970f815646268df2b2a2a8f9ad5f973bca62eb2e02505bce17ed8a091223526ab8a29af7d58e5cca7ddd8a4885494ca03b773c97b5e52414af3bf4e20904d8a2b7bb4edbf3450bb81e06dc6246790d4c964b323b34e1a583ae1170754c79c9cf9c6247a1f971803083fe12e349cf64288e3e8bb4104c4d6f75547760aee7c1ee51d198cad959beaccd722b192d8f7e14d29c68cd32438695a64ee3f938c083de868d07ec372eb1f1d37c08588cdcd486ebe259ffa99604f6ad50c50d5efc998dcd9e0f5110963f3255d80f89047137cd5e22f66335efe8929ef07d01f599255aaa4db88c436f3250ecb72958bd1307843e2ae951515d916c37e0ce03b304f9885bb0901126fdd036d59593e77bb90f447dce736d19bb812ac2b7575b5badca38d7014a6b50cc513b2522432711cf117a2b3ab6125d49d598eeab9d03f398d1e4399b82c8b9842fa4a4540ca7dfbe2210f7cb1c4deece8589b412da5c687d73b0a036e3de60cd4ff9b036d2b875b5a2e24c7f76b89765dcbc8ed8c13491c3654d177226f8b85612ee7e106c6db92d3f18eb46261c40aae4b9cd8700df020d2eee4cda92e533248f59d7895ce66ba5eeb8959d68b964b1ecaf6adf63bfd01052608ceeecd62dae2e50985adb4537097f534f72ab19b0fe8c26fa746a3b5e96848db19617b2e2daa29cb07b3088df9e1dceec0fad3e318c9ee46a353500dae5c13845f74cfc24df5c12fd327e04cfff3b090436bec37be6bcd2beb1d58a825a14ef1567f1c926fbef45d2bbd41c1b948d538f1b25f60fe071f36cb7fcdc13d6538d53deaa7ce5bfc92a6d44a82cd047fe7d4e78d3206d3ae5480aa493bc217202d9c7064bb39170189f28816729e23d62ddcb1bd7d3b7c4a9048e3c15265b111dbeaa0517c3ec82e60701ce7fe7477c1f8178522030a3e0215380e011cdb4eaca77bcd83f8ca4b41a009cdaa383e2e714e0c2c92799c26f0436299e40e864285f6178f0995b9147f321148a54c6990694d4bad62eed44da351de08f84695dda648f2155676f51588133b3575691fbfbbe4f6a2a6c2404a0fcfd2736d9fb73489b55654be0aafadff2392015c62e92e80f6cead4b7aa9e323a2cccac8f3a639feab6a69777a35a56ea2d79255e2de914d38a15572c75627b966393a237a39649e6658cb1b7d04362eff5906238b69a497e7e1df2b0cf052f53056c418bb580349f0614d0affe76d254140f15290e8fd3049d87d7222b45d83a9a58925c2286a713b36ae3a3b0c31d681412ea21cab021de7792b28d2a9fc18dce8677ab157bcfaee1ac91b84ece30063c63509f0f1411ce516d72a17ef17400e74436f71a898867e0e5a73c27c0abc45b1c3c8964e005ac34bcc4e761d7122cf0f502a37dd18bb692588934154e8bc50fe2899d73e5958b3f730bf7127a9a0f363f8f8015734021c0c6a8c809044db3cafdcb85226202edeb330c610b9fe4a7cd0a3d9934180c1a69ed3c7e878ed72e5fb5d00932a96e140eca8d9b7277ee580839f8e2311f87156c34a315d33c3e2de6931b302bf85ffa180346ba822d9ccbb4ef250c852fc65b1efdc5ff798c066e6a0c7b202938558ddb607697ce45580d112a43371048b6b03c8b1638795f1632b4dae51196f8913885f927a0eb2194edf9a2d187841793267e7206f998fc115724848354681c352fe96d9d8b91073f12cf0612bcd054abad6ddaa860123494cc29eac0c6b783dd03c848937a0e4acbb7b149c7621dfc0cd875950bb9e47c046a6d3c188c07b558aafb069ca7bd8a864d880850355b6f2dda1b911600187a6bc865cbd2283c3c91fe175d27f173e7334545b400e4fc787acdd78033e6b8f2e348dd804a9d504820255f27979a05272902b0178f70b38e09cd5c5c2cc9a3f65e238394a5e694b9038cae8210650f83bb01ad1626d82a838b7f0af40a1545d8740e14948ae710d02de61874259083f47459a76af522f56c097d2345b7aa049f5d4dcd3120f58239399ce6fc1eaa69cb3f040cae8aac6069b8504ee6e69b46a926569aa506bd4f85dcb81b2c135129f234f84c7c2cd207be87159fdb0a238b28a5a21be981f8e83638ef81c86027db139979a3a0ff475035e3f07f0f04ba8f1a463a59d0a41cb3e97d84b3b07bbc4ff62ed925998d7f7968d0d4cdc9e6772648454f3e7e6ed292931dd3b732949a8e7d52b43e4dc8d6047c092b5ba5653d51d0476ab11f67ec85c84092953a4d136ce1899e597801eb287a8e3e1edeaf0aca635bb38359c4eef079d1474b80555777b0a26f3d0d0eee9bfbd06141182cb66409bc4ef0e0b742b9e79034aabdbcec97ddc98d84017707ef8cba04179ab5c09be0cb3cfdca84c26613af27ddaad253244287eef311fe049e13fc5a525dc70b52feb3f7967617f906d3c8aad23e58843215cdbeca9ca0de61ba054746b2f7503015a1f671f32f3f9573d34fff5be31ff826eeed56984e8eedae9b6d11d20e27dcdcd0766558fdc050affb566e94d91f1f691ffa7445197bd55c462e8e10f5f95d22fc17164454a3500beae05020eaee23b1056087025fe8d1a65f87028e740c6b0d0598ee5cbff3bcb0e5079a4ae93635869674d9d39ed127789269ac1145ac0742a0199b146a64c21ac894759adebc744e370ca3ec7f1484cd4aecb9a44b5fa0390efc2f8ff480d64d5280a4e11eae62f069df6807499acdc00868f3e829b88e005869284691ce1e902c7bf07fe12dc2322d13b7b87e56f7d062209899f903650176d75f3385998b3509c2d00b6cec31acf7e81402a3d7b79fdb881dabf8f58e6c876d8b076887de1856ba62465801447fe8cae4e858f7c5ba59e3296748ad66189ef56fa5de87b176c6f9642f2ea56db5860f0197e79ab25d4f40fb941dafee86612c7bef87ca48dfbf06841a53f61acc3801d485045b62cef02192ee6a4835a0ae9158a89b37fce2a9053c8b8332843775481286e6ba384aa3a3391709343699a68aeae397a6e5f8bfe36999de8b21c47b3c8ce705fdab84a2757d8a90fa67e7ec4eee33cfb26264dcf1d9c3356b827f30743533640a9a8222ecd945253183f5e16c3cca6b09cbae2a4488a89ce45284137822551ee63740e30b03dd644f4feae1aba14ce70de7cca4997e0fb3a13a0bec9843ff526d7bafdfeda6e73043adfe1e433cc821f8e5e705afa4348ad9094428cfe7ff370acde4eb9d02ac647b518bf7991cef92b753c0b074b48b5bdb04c68fb522386460c46553a158b0f3e5e3aa1066ab1c02dfea71bf9c45f64c0b5d714b7ddaf21afc63b5f98ae2b466569b067298ff1032f3c2b9884ba52e3f8262069c9e765b32ea6c693676fb18dd5d4764d119f315c19e33c8c7f577dac2d6f2d894e02da9a34bfdb658977aa7ac5eeea053e82fed92fc4a8bcb35f4e64c9d5c8821b720b44ea333c57949441e02d5b732a56f211abca4e5e96cca4f6b4084bedbdf566f4c9bf053af3ae08b81d1675927856fcd313e3a8fea3b5f60dab3fd4dc754df292d2dac1430ee048d1cb8c521025889ef2f072d123d602220cfdd3e85e856703c343e588bcf78acfb54471a232d1e5c0726e7214137d5c1e38f3d5fa9934822647814275330a617887c3498af3b9b3993208dad5e38d8fcdfe7586705c627e1c83dabeddcb9251faa84bfb44cd173aa4028d87e0ed5691dfc2af990f1df41449443a7e55bdf5ecf57ef034037284517cbacb8b4cf0dcd8267bfb59724c457a472fee581fc5f8cc34bdb46f18823d297fadeaf42fbf6ba6604388f49a4714a3060952439ce59f43f78ecd67e76d149ed1fadf562dcef5adb918a5def6949c876f0ab6e755db9f7419cf9fcbdb876c0cc4e57ab775b880807ec9f16572ccbc5856c7756eaf9dcf22274bf8752e26798218748af22e7390bd2e68646418351376bed90e803f240f918682d90084521f6ac7ddbc46bef176ca9b128030154e44f18be54ff9d50c589150a4f19f8583d64be85945b9c1aa685688c027aa0d2d573d83eca38904fab208f8bda47ec6201857d87ad849d3c92e36508fa227f1b62e3eaa46e34edbb6dc97b98e0d0fd225e657b08c77d2ac91e492445d8030d718d2827765730dd607e284e1205c68c49009d1abe4bedf4876b3dd963e1a4a55211ab36b3ff32efade5a2a3d4d3b7fd6ba01caa57b93568fa92e8e5270f6bf44c80f0d6609360f3569ef322379e4a397539e1ef7781fdcebcb35e021e4f4e0f2ad72cac2870514984f84d5216212fda7f690c14df43fc68a0ce3b3ccb7a7dcca4506b5a3b10d46440e4d549c6f68b1d73b4381e008437ced5af18b8f94dfd7bfd02c7939daa24018cf6d76bbfb9fae6116657001630d2a142de392bd208c8ab9b894b15664da6e37374b6aa147137641673d35febec7dff5e44cd540594810ecaf4c9a1c5396ead49804ad7c43c455c05f7830fd424d26ebaa03e0622b16d7d3d2eafcb235b7457e06589ef9112e0d3b7d941816ad460ea0c5a00c150f9bf8b0b934209934515ec7f9aea2ac65d366e6747b425d62c527029e4aa7d8840318011ee941608970b42cd0629f57970933804c13de779b59a6f2cff4ed1c36e0a5f9ebaf32efa2ba438c6a123c10dc8a180fe0151f58b8747ad71a5ae0178158febf0723c602d9e8da2410b5824d3d968a7616a76d6b842c6859d5ee2c2bcab54167c34929243eb3dfecc90f92486050ab229bb12f2a217dd29c71cbab7fbf880ed2e5641cf9c3b31b191716620ced541bcf660c07d12d3afe7a34447b19b5267b0f9f372d86eb3ea09c3c1751f2064b38044d752d1d2c56a5c0327a9aab78ff4f266054647dd44b1c3584a41b0f4c0f80d9c1a5923bb04f792947f5e167e80fa11d491f0974e0127996151743900fa4136da798272838675e9397fce14da84ae2a08be5503d62c5e09815dbf225b152656546dc424bad5b4c1de660c014f1bede165515bd975961eb4902cd256c500a539291b7abebd92861ede99f1c0ae1b317747e68dd5efa79d0dc942952f1fd09a4e68397e9140110e0481635f42e040030448dd2ff1d08f017a8c920143396a05c6d5f7efdd80dc3b61d11911e0a0a99edcb346761bc8dc085be9b91c892c9eba765c1d43a30f627dc83731ffd2728b3cae2566d56dc952a2aa04a05f41fb466246556212ce8b6815e6bbd410567eeef3947b475be4c18d774b32b7a72f37e7135b33174c69166e7e9d220a822e9fa971fb4a87f7606b2da39609763386a319f88d3ec232ab40acb26e7136f3a447c255297afe34fc69c6222416f4b58e5ac005b884819ac774e8ccb665081aede198830fce5c6eeb3ecc4265c3c02e7a6acf857dde08e4b4af31c6635b6cdd82a44f6ab8a4a03551507e7d4182b0f9f9b4532790268835d88cd03d6446ce422049ce6feb2652c73425fa12db0f5a8de929f703a0f79ff41af9dbbeb8d7ba52397c8ab6332d589008678fac2ee121ae9c24318b1ab933b8f67182139d604c78c54353204abd2afba2540a42ff73f23dc8dc4fd85578374dc4f7199e93417171868d32f74f62bd64a0c563d0a90e9bcd813b04e6b06ea0321a871ff2bc0ff68caee32171aae0b845d54a5b781230b9bcd2c5ddcc1040366b5387d71c85a123a4e700d8b055dbad9cfee32b5e5499e680f30a09e2c160cd6561f73617860373d24626a6f052091122060dd61447445181230ac010a2c302f28b0ba0b8d5caaad13e221be0ba791b6c82dde15810abe1603c26bdf1a7c5053421204269163cd7471bcc19541f64ef150f6b5db472d0474098be838f8fa67365d730d41b19679077753fb23d4e6fca32e3a8aba4c2eb9a709e00d1050e79d19ec71bd1a1204986631115938217606083cc8155a93761bc83a854b75e718e46d3b103a4e013bf4b0b02ab478fd6bc1a191f2e873d0172fa460066e70b0964d399e59dc430e9b780dc62a8df465d2a9fab201c9d3e7ec66083c39f78b11ce99f3ef8e7cc6e2f5816c551c8ee889f80975845892b8c2898d3fc9acd13b108612992fcff511371ca0242e1a6bcb692b2565798fec53dbe72cc5d9ab6549f29d3c23fc2fe9ccc93123df801ccf474871d85ffd3347e1dabc49107bd3186e516270ce02b7ca706dc39bf8413a882e0f7f3161362e2c40b51d17692da3fa405e64e29ac62e3107346dd932901cf9da535691169f792b423be773f7a17a885e960c4cfd01bcc6619433bdd8798ca5b40fcdbdc3498e059e85c9a6a63803f04646d135e98e0a6984f42b20829ddc821a1329d06816ea3c565667681295aa68ad68df9b6ac37f92e67d3c1bbced392acefe954e6510493fea389eb37f55f4408c1bc0c954b69d3dc0b7c2a9aee0410ea45879e1627a7c9079600e2cdeed0f9dea6d4e29c0e121f8b8a25b7889739c1c20e8f84dad5219e5f6b80de22db95e0ee43d0d4233a9b2e2b38058a611deb5a182b2e31465c755b95e0bc32a17949514f76e62f328ce2627458e0fe8690480c41425fb227679930c12b2a4b01e4b27782425c7b9cbecfcaf2ff81d76ea33d66e68383185f7985510c9c291255af74134d44236710dd2d1bde0c0e7d1d4318db09195bce06275f983049df5152d49b2c2ae1e7204b0b92dc9ae3bcb880971366742342164f4e8e87bd2ff023d5195915ef3cf1269eeab17d5b0675150f3ba583383a218fa6ba02d5e478933144ad247616f56363fcd062a2bc682158235c36e3307d0190e4a7f5f94716d4857bb078ab88dd4b77761086228b33ee70361407b9c5dad79a63abd4eb0e436bc7b92e67d5e28fcd3b4a6572ca4b9157292367e39854aba8cf1b0a8eb2a3a65b218654ab2fd7bb6261a2257d5e2d6e51e3ab1cdf38a52264c7b9650a30a211ce08805cd8a19e6c7f207af912c1967a5d73fde55d0a3bf3038d6c5a2abfb005fdbf80ea94a7708745424d9064c102a26aff1301580b40f3d85dd4d6a8b579ce7143a341bfd367b06cddcbbde15a3d3fa23c8d7b422e6bee6969c77b9bf5eee0860bc365f3fcdef0983e6313cdd8acfe9ed420070f0dd04a9ebd868690573a0fdb8fa734ad90bc73791ffcb8cb054ed243c36e7dd0bce413b586fcae0d02bd8a5b89033eb9df29662d9241adc866ac291d3822ba0b833cdfc06c67cdd427713d468b84add5ab0f5b020d4a5745da8e42ad76dcbcab51598808da977ff8e091b7277048f3bac7f84aae6d85f5076841ce2fa2df09911426cd0577262493a9fbb283754f23ad82c22f768518cd08405e1ca76a75477ab6d6c5072eb80a332d12e010d0cd3d2a4314efb74d0293905af119e87cbdcb8c16327023000c6a40ad27eae8fe23c9c5a221d37d94fa60bd63165afafcd3621460e9e65480a32d0e8829a21e251b8732da9ba8a8be8e327f5fdc5d5c53e43dbf5c75e03f631651575f924bea737263e53d903315999688e84f49bd6ba71fb0e71a92599c111c7a41ceb33c737c4c4aa78039ec44c635e597fa50530df46920907f327c97cff17382836b8898450a0458165edc41fb9c324fcc7385e6b0b92d691a922acc169ea3f24d6fd632e440eeb0d3fa5a425f4c1bf763703b6fed96a27b543e6fdda751177e319a7c82c3b27792acc76bb5ceadd9a0df0dad0045938bd19026808ed54cc3993e317409b536f430d393f295744e62b5895f26e3390cbaa98c2c68743a0c26d7d68fd0cfc22ef42aa25919bdd16742c0648e0c7a308fd91193e213439a822c89b5292ece1d43b41f9b4f3eb6e76be494f048dc49d828427ff2619f96f9a6d50fb3397938aadfae2ba9aa6fb9a0f2d7a89b9aa3c8bdba7579408911d4d3a07c0fcec2c7059da5a53827a3c1e3ed9658a013c27047f237b388848e315a600c6ba18a709800e73708bf41975952bbd0b7c6ca6907d2f9035cc298dccbaefbfdeb1616a911ff2d86c25ce2c310732cbf8366fbbef03040e99477997c4454ee3fb825dd25d28d7a0288a6aff7653dc16c973c29f20a04e3f2799c7fadc69713184bc42bc0801558b522f26242a83c956f785b855fc1bcc57487d2fc037c75c2248f0c949929c150e3c320681c7a56591b15ed41214f1b93dbfb520c7e8108eccae65859b74c152c8b0c0d12d91df2b94bfbf8b886ed8a6f69967fb81802819027839b77dfdc3d1be57e3521c23dc8001cf517438bd56cf54800894b114d894c9e82a2e86574a7d8d537048a07a467d084aec265f7155df963cbf0d79d117edeb5e7d5ee4038ced05896db98331de08dd7aa3f76e6a36e2e508972dbcf0a5cbeaa843f9d148e2c33ae731f72feea19faf943212e5848fd8842c1746fbdbe808df321b78d27595c83bd58eb4bd5c1cad45279b6a2421b31e801f876bdc86bd678c8447c9fdb17fb272e72b7aaf2af8573159d6f8614f52f59ff87f8f1a25af76c3ee14a4823bb5e73f7ae1eaf72a0f5027ac13a53e46e6afd4f8f4fcb53f140d60bd42677666e484e1af6a263f5082273d0511ad8e036158a9a18642c5c10dd5cfa26ab3d7d720903295b223076676e5497e3c3a93b6bbf23defb351e699e3a22d94ece2256055ff5add89c5350fd81886b2e88a88a920c13317f9001acea3118e91eee65f5144344b0f0f87561852e9eceadac921e305a9ac5f79399424794e1bdf3c46d46ebce2fa916ed0985c5550cda598a955c7c214c0caef0663909fca3960a2759bc7f702b18e15bfd1b20833ef55a4e2624d189fd87f22ca98ef6517f9b65b0981d9f0b5ccb6b66bfb977907e4647e15a1bd031b95ad68b986709c8d801c018fc35e421e977dd26c1ec98cd40128caa0055ee26ac52e29e18a663561e07cdbce772c68e54ec9ff5ba41d0104f8d1641af184fcd860f7024c9be17110dfd041cd2aa714a3f5953545f9815a52c6a682040f10185a27bc7778395384e7918fa84080221953a68fbcb43b69efce31da83776a1b7621560ae18b5bef2b193e1764696c04cd8e87953a116088c0a85dc0b1c03358f68842d5ad19bf20b55cd8136c0224e1c8b4feec4af52792c9c245ba5125ccab1d02ab2bdeab36406a468b6f7e9d056f157c018a97d054d1742e19230b7f342f54b5d6a92267a7f59379887591baaa09eb682a8d5e27dee618ec3c90317ceba143cfea63425a2951ccc049d606af3c20e15cbf9f4ca80cc1657c3c588e76079e9524f02e2065f98a2224344df9b188c9d77fd15ad2b6c8d190d63927b387d3d548d2a81cca3ad2f584e15cb190a99a0bf786e0c2fd1dece5e0b0842782394102c91f758e8ecc0ba605758d15929eaa0a76b1f4e7d76abf00fd47cb50307f86b85b2438db77c049c5a5b71441cb4b3362a7744e7d2b6b8526403254b3327c6664e58709993995aaee97469b68f95d5b1998302c72d1ea50d69959ea6be847303eb84fd44cac2f18368e35d94e22cc9348873c2fb4c096aab4fa2df7b0c2421e31707f089982806a8079b615e132d0a3e7f6ca81c1bf44f34e3c75005dba703b94009e0f493b3d6c8506521a1f7f858b924b0eac271559cb0cc257aa0429d81288ed51ae4d4f97b9606b0c919ed17aa3f8d0fc2870e82fd25f3a1a5aa98911a0d7499d9dd6e3a8300ba38605eb9ec0bcce9bbf6611c65c9b439d02eb43c8f6f77523ed0287d81b372e4688fed5920787d3742e21ea85ac0e47981c75314a62c3b045dc36abb99abb338c196429c50caa1dd24bbc37e56023a1259cf065125e7a52e495d65903a03a5c5fbedf9c9d0b9d7c20858dba674ae8b874822a0254d11081ad057656dc893054b1d7a7dbebbac677c897ca918f9e15432a458c04dccd050ac5add1b133142df67f01db4f4e7cb51578c9ce10a29c86eabcd552614af3a1a14df62cb3c128c1b62cac4a1a118f2849d9c0f986aac3f36bac98934cc29ddb7c793409cca140a6d1ff763a84f7f2af1e1d0ba896b3c53b96694c4258a09d9973e972ce515067ede75f7af18510d0af08989459f77250869ad17c54b8fff61a14d4e20f113561971061c03c594d5ef0132bbd330add315baf3038adb96889a40ca0ee7b0e53a592baa7336770136c29115f3a28085794038f254b5b584c4c444fbb66a55e3c7872c3079767f6171ff812bfec62183cdad9835658d6f661a71a2676829afb9dd63b7322ba6ed2ea15a138148acb484f2d18731276a935d2ee0116d9eedf4b42d6aa94eea6e4e0714c3daddf3d16ce27b072499bf8b8c282c36f7be885d9b2afcd7edfa81452b55653201080bc71b2dd24b316b8ad6367fbcf85409d4d0550ecc06c78a6a69a901fc9729fb235a24ad4d92eab35db0024cf865d0331031ee7f9f789ddbbdae176e280739dec756a13ed42a4ca8262eeab358d90b443d1fdbdb5de9201551797d87809b190e6181fcb9d552dea09c97f68707e9ff0f10819590f71f321fc581ce162d24e1f97e9c1e56605bd2ff7776bcc27f2f05c6734a7e887d38b239e1b18abf2b03b6c7e06368e130663553ffc5bb2ca4dcc5f2e16f50445706281cc96a25ca523706eb10e2595aa5873b72a0387444aa5947c8710cf2bda15ce6f4cc886a07821d1cd7c31f0a07cd1ae6b13d0ad960ffa37b7140e39dbcd2d11bc67c1f3bb5c348175a3dba7f3b41b798f181d84b770f0a7ecc1a1aa7d7d52f5709111bc4705f1f78aba0e7666cf73d1c33e97a32933238fc52624013d54b381f62e6c76a3fa296768c39814ec7ba205ab4aeb48d981cc6fbccb42c906fdc7b9d9af0241debae06f3d975b8eef3b9bc60be13c67e68cde739a4cc136e1daed5d7cac369ab6e43d0c0f3ae21edac3f64a9f06923b2f5afbbce1f5fba8ff5ef81bafea04db90265aed06afa5fd1d33ba5ae624127d125a5df8a04674b5f58b0f283fa81b8409e086e4da1fa8a4f7b71f14a672430ffe14d7ba23f7bbb07c26db41901cc95f9e6cbb296c8e01003b8bd614d3b155dec520545cdffff28d086709f510a13b5397737173c24add6285748a8f0dd8b4fb6d99fca3452ee10347c513f076443cb65203798e117589c62b539fc8979ab883d4c415a2552e67262dc870c15c6f5f8bdfd96dfe776eba0eebead436efce39becc86755d31461c2962cae6799543dc531438aae5acbaeeced68d6346aef336fcd29d2da3b50acb1e7c409a051731143b89b993fd365a2d1634da9a66358037f6bacef75371f485b16a59b68bb97db22cc4bdff8519c8108b7d801f637331578573625ee3afa278a605dc5d82d5a1f432ed2285787755dc4b35a5ce76f9d336c996d02dae57bb97b2897c65a6369b2313db7f05ea4ae0f3b95ac73f493e66ffcf44e6e04f8902bda5e4fd31c922d28537a1383324de951076dfdf3d5bdfd069e2587f9db41acc28d496946d4c627add802c5fce44cefffb12bd7556315e183d7490bed82c3351a697f390d171f36301ee09f31043aab93c7add2a4b2c50e498c4b8aa8f995504dc9c892467f1fb7345d4a4e0997bfb52ba2e05437ad5ce5c53a442692110d6fe7a184e0cb2bcf55bda3f002ed3eea702b845a94e2d1d2bb8b18aca2bdb5677d5326f370947cd02cf59eddc969220b9babb463b7653fef0c94567002466b46aa4b9406b1a7cccc8db91d11ead67e0e717277406ae10fd2c4f2bab76e90069b6df60f9280809dd17ec842d8a290b22a0c6078a60938e1d9a3b6eee9c3423774c3fd204f092ba3e1bee651d43d6dfd0345f631595073bd7a20b7584902fc4c29bdeabbb238646b4d3677b7fc4c2c456a557f5844b5edd13c19a09e5027e0eecbc83130ff13dc6ade89e8e79060170dee041e224512ad1b1941a848cf065230a6b11b8fabb757085fb246d3c1f9b6ed9f3b1890b9735b163f0d97fe5c59d95a078beeb2f17adc56b2fa16624bae0c7e9f8acf05564efcbd20746fc6d9d8957bb3808c3e98c5f5c95b1e813d1c0772a784931e9045203ac93d2524081f2255c28fdc045eb6d3bdd3d26de18042b551a98411416c52cebd5d726351940a51de9b20b62bc703c8353209613d2f542bcfb2bde238be09ab0c9a9e537cc758666f4789b20b81d1df4b194a9f26f585d4c81afe1f209277bbc3851dffaaabe4da23477c13d2c6cc7a9602d712191324fb3a2b9eecde7aeb1444b0ed8b79fe313de278d7e679d46c0f40f26dc83e5d68f9e458070d306bf2f46d72ad671f12bce5c81eabd600fb8bef2378abffbcdb62ae8492cf3f5c79d3a824e977f4d2c9d7945cdbd764b70dd9e0311e0ca10e6dd519a291d88fe274d068d317c7c112125800e1972e3079c71589c88a4d66d1ff50589d19b6d8c889e4abef2152f8adde496f9efdd5b4ab762709903e4edcb0cb3c6446f696e87c52fa438a5c147182fa30718ad1efcfd7c32f64bfa44c7c991d57b206e2b1bf246f82c3c55d1bd45e11bd0b3f6da74f533614d4d9c4d4294b22aa3aa64d36c2b94af2177a0359f5dc2271cce128a0e51b69206c35a9207af7aac5cd7fb681577e33565899e85b58613acc0741757a3343d7481d18ce8ccb03e243a9f3c13b3529cf476594dcb44e7db44577a980051114e3956caa986b6bf7bfb83af6ba2f57198486629170017f72f99a5833ef79c62c51b4053a3624386b247642ae1faa5cba62a630f7e54d10edde04825918ba486ddeea93593049f1b2e9b19ef2aebc6b04785bc7f7a71bba7b644367a7d42bfff65d7c0e13a86db83b83c7933ecc6491f207fd9e7c379180cf698962e930c6c2c5937ab267b17ba07d150890a9a196371a017f6d263e127339808803edda804ff598432ad84335071d4517e11ced2db624a7cda10c3a5708d3e1643c36dbc9f063fe037e7b27a94f03dce43f1d2d997d404cf6ca52729eba14ec51a1c029994f682915e9262fb8c6b59abe783ce3b6da4f83f5d57be6497a8428a2c58900babbe04747f22dcceb04efb427860bbecb9c09b39fd03ba9bf5cdc5d6f1522a845c9bb77a575dcfbd3660c1795db0070dcae29f83c9f010f80d2a7c0750745cef23cb2b144dfec3486ae9bb445f60e31abfb8e9b534231ed60d28ff2599ca43dc08e667be745d00b84d17699675858ffa3cfcd779403558dc0115e0a71e11cf7ea8bff7c948453ef1a55de5f36e30abf4a73519e69091d9443bb9f265f8a7117d3084d0244ff012dd2076adda2c4ba61d54eb3dd5c9f9d5e1503cc642ceedadeda05e6d342dbc7166aa78dca09de24ade2e3d0afb93b78f68348cbfcd6eb70f2c20a06ae2e3ae2ecac793ededa5713f90d310ad543f648eb0c5aa5fe3ec7eb76a26cd2a7d8fb3b1b8d07f53eeb1502850c45290e84f308f731840bc0e349f73d2409ecb08946c369d88973d6c69938d2088ccc3bbc08f32ff9e755f8fda956a6adb40819d37fc3b694f843db7f1de8d220db776938de3068364c3e973baa875e31293e34afa91fc0955c33313568c47429a2f39d3ea0722e67e4c87e23a4edfb75f21f0104bef3827fc2645c9fc2c056fb7b6b77bd7a35b38b6793d475aaf222b5466a2233ea1aeed417fe580fa9f40109b84445b988d4e7322ff8a2e88140010149cceb63e70d2e01b8d72d59995434dd6f6684702ee2c8162ea374f4b2e04f7f3c07c59ca2dab588c2e8223efd9dbec94c926d034bd308126d0849c8860de0fc8680906555d820eada602bd8b202e2ab31df2a35009cf1a02b8c47e5e571be437ae6fcb9b2f46ed8f60f254a0ed329d3ec702c4fa87024c81fdbd5a96c0929f830b4d7b3ac2763c438d7210c489348ab837f291c86cbb8343cbf5346161068fbbc72d77ff646682c4f0f733481fd8d37bca472fec56fdb77a539a3440e3eaaa4587d379705cafe6b6575d7f62995340ffcc3e365ef505f4ce5609634d742b8f4bea1d46615cf709ebb609a4988f2ff5691b465237483feed6fcf56ec49c0f2aed62400cf4728d57e88b293668b00f006e6b20f322394072d621c09d9a6f108b415f3e6a6ea228a8725e996e9bad5cbccc2d180276df8a2bb005dc71ccce12346f1a9f9595f895b7a2e1caa539959f6c018ad9677a7009c15f7fa0114a146b83c48a9a579fdf0b90054eb0aedbf3b6b04638773cad31b8ffcad02ef5f73e8d3f7720cafc5e3902d67a0494cb4d5e1b89cf132702d4459d405c860c003e3471be325f8f7f224d4795e14e8749d2ec28ac594119d9ee274e7058d963ab848c474720d53b66b0b49050ddadd2992661b3a645d35e8eaa36139e383af87aad3eea17b68687008d46baa7331d489652e32adf4f6c3da78bbc27d2caa474199cb41c90a007f178d710cedc424e58c55bc83f488ef0faeb952f2627d6cf6dfc7228630ae02a049ba31bd6aa15dfa3d7ae38ead6bc5f1e89668d26197d25785c9371e27c903e5d0d58cdfb133d5ba152f6497f3bedca1414bbc1e088a0e5fb398b9671b04fd59edb8c47538e133da5d26f1db7238c996a1af7254461e3768365721c4ab4fa2604f7e3d0e1c79e24d291487b6a3c94f6251df735805b8036752208b2ce70e24b024cf7bc2a6e28452a4b22ec13a6c379395dccd6f5b2bf6b4b5e45d78dd6ee8127330969bcb12850b0094bcb30e46723892a015862e361e80635177f626b6a01d601455d53c80f6dc3f6a828ad7e8e757052fcbeb80d6c142efd721d689050c7a59963c05e64f1f5c3b3ff930faca8c12641bac5861cb03b2582037464aef5c2cbf7f54f3dd0fd3d19420d21cfad829dcddb7639cf50a7ac43fe6051074109187eb42602533174f68d00472fcedbcecfd4eee5e08c109268e1a7db7e8713c235302324f805602d2db17955f0e02f100f655e973b1bdd8a4ee294aa328f38ef6985beaaa193550e8477d6902b613172f02aec76440e360243d164a030c8d080b069339593900379b788888b938cb10ecbb79cc179d6af49c3b2238422053884cf95561db29b483edd1c8c466fdb09aff1c8de6079c2e299bf346aeb7aeb92300b450cc411ea5fe96339cedb62456409679ccfcb6c49489b48a3c47d08c52775a33367d9d43773cedf14c1ac9906119a2057b0424fa26c97ac0ebab2c6b18b674c1f3214e6d65625f978a7f1671dbeb607f339fb3dd20eda930881aaec98dd3d0c606a6d27a448890e2984cc831e180062e0371eea9087d3e9349706479daac42cd8a519a081b644bfb4feac552c80a87fb60a6944f2779ecfa617c4d0564d5af1115adda3a8f4b7aac5051ad15350e984e538e14efd99dc35f20c83434f812c708ceb331002d1e2e3c9eee0429eaaeb4b920790afe77d42a0158be7c6208ecc8b06c816dadf63971a860d85e28e8cab4f9378a91e1ae9ecf1e299ae0c240533074b851751fbd138dbae4dc822869b822369a6bd448d6c1cb1d36d59477d0032da73c88ae3d3aed1e18473f30bdbdc23bdc22bfa9ec8ea54f3c5927bd4775874c7cc0ef374085b16cb1ea95752a63db20f76e0df0eed61de4c5b0a10102fa50a9345c70775a83da52a5e18fa8e016113867195fe43c94e8fd3ff47b87c4647ddaf5ad1824c9cc37d46986368581f457b11c90b81ba67f51d9b0ca4b9001ffc48a135619e6de319151a5d1358d693ca2c81bd950717af6d993cf3c89040c9d15d4c5a454cba0bb7e27ccd0a1b82be3780e7494bad61a404067ba8e9f26f04bcd47df13f13027c6b215955f8ad366f268ddaa3c2980900ed6f24aaf0dd24f011386360b3a80b5af2ff95bbc0ddb4766524de81ff0ef61897d4493bb1497411581fd2fe9c37130a3300d784d53d1e77fc2c3106cc4cd684616e4d870946db92721f47db63c54e5613984a6d4e37d8dca845d1522515b3f7dccf09bfcf55e6b2602e2c1f609949e50a1865203820f3bc6444bf88606c08bab12acd2c202227e53890e4dad0132d0f5810eb08fb9dde8830afc3da874e1960f6d24225b6ac7324abf3d72d83817a0d140e40c09df2c49f0854faad9d006635abb7672593fd6da0bdc40bbc250650ab1449b58b4f4d999b251de2ed9664dfa60426ba858bd8b5555e31451ae54247ab559add9488bae233aa0c517a50c2bb2245dd428ae8b45ad6c5d8e328a5c96559f0433630e214ad518675b2f2c8d8d04916c566ec4892cbae337206596190fa669fd4d0214150da7dd65ecd3e388968847a3bdb1f157e18c103d3d29661c2e52c341fc5a7ff750c443f6c7d2807ddaed27106f065ca7d01a2c1406a2e9a1cc8a259b72e64609a30ef9f2ab4350a7a3f4b8d7ba9f60870387c857406dee2d1539dad348aec3a5c2bd7398d6323828244763d0166262ed03c05e80706bf2043ab54fddb3c120978aa20f14de09de95081639c37f445a895e782a13cb161f6f6dc9b21f61ee8a33f65cbda723a4223bfec797766aa0fd6002005fd4de65444869cdcce46da4447252e605f3e61dd423c8dc2f8c7ae8ee0a6d07f1055cecb7ca34105ca19af18288e8ef280c954b2b865a3a904eb8351033832ae5b2ab02783d93b330e156141d55bf88b634e046f8171c64e5c44a63f96ef82abecef2ecc751871f29ca899f516b3ebca4676d747bfd7e1539b64efd5103d117d986433426d90842cc0f3812cc486cf681e2d2d67cea416071870b6ba02eb3d4ea2b64b4433fc8ae0905bdf26884d63a85178eaab9d912bda0b1c7624d65f86608c2984c7df158ad04c68d71ff394afd132190c5c342aa17996853b57c92d066db07b50621d0fbb6e6c7584da48ec43b92725b796e3e460128ae8cab90e15751d153e94e86163435608ac84c91fd0705495a57e057a52c889748ad702b7ab4a6c984abfce7a7614acaa6cc4a6ac2a115679b32826397c90a9594c7bf84df70916628bfecc10b392471796ac9ed6babcde27e8938d3640c6c1eed7fb0accddbda2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
