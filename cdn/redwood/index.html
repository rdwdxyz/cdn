<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69a41203ddc378a3c1898668ea426c5ea35a0cdd459e040dd93ac3c4012a8f104f05394fbf0da4c3cdcd3745c27b405ba46cf4ef096ce9c1d4ea58f2cb399b9489215e31e4c2554155645aeb2743542919b7f32ec5071afce0a9bae88a36740f37a0261eba01ea1a911309b7947ebf7ca0511379827f6f4b2579f49a9ceb31c7b1445fbd16b7ca5ba94c9fd642f20ce4f024281588be756d59988f5da95c687a980e55a48dc09f8ed2413452364f73ef3ba73eb8147887112ee3e8c1b3a320c46eb52531ce0d4e1c5553194434b127820b4d14c14954613c71c1489efec8991369519e844097887e04a5fb169eb7d102dca491036e029091c3bf5daccfe778ed57c7267213f14240b128ed61654b125f8744f01e4dec1b4f554ce76a43e040b4612291428cb9b994a639e2e027eaa33a1c55ac48486cf7ef75c5ae9d2894fa956a96f34118c2d6fa35b3ee74eb070e6a525d0939d11d244fd96f4f3bb9e7de7bd49c5d5375bb654d8b8c0570779b6d5d6a5b923520d12c7ec28584c77dbb4c8e81d83b2ed1929222aa809d4cb6ebcc3ddb421f6141cfd174bfe7361e4980e6da2659b31d92339ee7b258460a81bee633216c9a6abd8254077db85fe3fb0e0834b13812bbacee72588e0b4ad48895fb669ae69d17ccb4b93d0a9bfe12992fc2cef346e7df7019fecc47e95070c3b8c7fc27dac3503698cebcfb60b86bbdd46d4e78c6cbb468e7d3b2e8a2fc6ad6b419940b8eeaf572411cac8512feeef3135b04ce0328104e4045fcf70bba4e68bc7e298dda748af97ee309a2d0e773f7ba237d9b4f2448fd7da7c44297d5663637f07895cda02d4b44a03ced210c8da745ff79bf4953e9390b12e7112a5a2f844703e93bb6d353875a8e908da520f319ae480a4dcb8a88029b1a059a4e254890b896e26502fb8a70ad303327e42c60ae73f28650e5fba4c98d6dcba122be878e44ebf1231ddcc383fd3e752e8db4328af341204a1c50579713711a50bce088c2d910a166dfb5f237c2018fbf8a32e9ab50e28dad49add092dc608f6ff75a3d583dc35d4203a148692059af26dddfab788867192b3dcf2f22b4cecb079ef84220053089d6476d30018b0f17eea51f20cd7ab61853675f08f96ac1cbbb39980d3cd8c1b74d8739223f3b43ed9778115ebd69685c3e110a7408fa07eb21b67b1e88dacaf82b70b14037e0373f6bea6be93321cb972e8bce9c20b0249e9f801ca968fc2ff0d16c23b4a7958d2a50da9d77ae4b6882e88c6e8fe617b4a19ec3c2a8396763a2db7d4dc0ed0d24d8f18a3aff9cbf6aab7b49848263a2df260ce19fd615923cb736132369e107e772a6746db67ff4f8fcada571fb1177ccbc566100742f245cc3d16adcfa4c369409613833e25dee90786a67c97d1f595cf5d8b606c1e05242f766b7b4bfaa74aacb0ff9b5dee771ee54363dffd4e519340b87636bfdda0823cd2bbe04d0d5f0b6384e63d5fab121cd88f5fd6386a4c1ba6a57281dc9180ed00a96f59c4dd79148e7621d34d201c15c03b9ad52d37f284bc32916711d0e9d1047e09b77ec45f7cf5753394671a9d78b7222ef1abc930d1f756847232f579d4c44ac8e94261ae900c9550329a3b6b84c98f0729e43055797d2b9a0692d777733ef7107799f3f3eb7c18193f68768db662c074e64d19a81be7c1c36d8da4b4feb801731857435ec61f2a43f0aaf57cc90518183a75cb6b7c16b522cc4301bf89bfe20ff1c73024af78496034df72f6fe215cbdfe4b95949cd2ed712dd257b409356fac39ad09dca36b5fb45c496ef8dfdef40ff0253dc054372fb96993f3d2b731f3b87d89410a73885cce577dc3f8f5687adee42be0ba22d290c25c2c975a5c8ef34ed0f69c1e03e07fe4bde46894b201539ac637644629bb22a924aab03b926e11025b61f3f2cba4f3d79786f08d0516684a02acf5b3b6e0d137ff1a7fc9f63ab435b92bb87bfa56157151737f0b62fc931f36516c6b439b62e100ab7b13631a9a53e5ea55e0734b880723ae40f7cf08b6b625a970ffaa39bac8e4d472c53cbafaa673922c05d9f905806d7041b71bae0e929e0e18d23bd9362d5642ee14ed45ca570c6de0a188731ebd202d09312ccd588529199f77918ccabd48b1a78078b0a261d7de9d632cd08147dad38e40386e75e48003dd0cb84875bf60bfa61bbc6c9cb75a91e30a137ddf8fec25b791684e3e1c3a073a39d0a1b0ea7fa167c63136e59ab857e7c4a47d81527b8ac76ad6bb79d6458982f11239d5dd4d683caa1dfc4c65196dd97ec6bdfbde68c0574391792ea6104bca257504306fae16123a4a7a4f1f9a5a64032cfb6ca834503c1eabc26fb8d68d5c3820504ee803be336037228c6eb10954c039cb73ba64217cfdafda37e9d99ff77fdad1a1ca98cdd68c3207adcefb849f65ec8bfe610aba33410126a12fde8cc2747faffb94ea235891e558293beef517acffca74cc04f14cb9965e71c85a50060d35acc1be09d3936bd10e044c27a38b5c979a938ca0fcb4694665750404e1bf716cf71fd77c0cf3a50457225a1e95ed5e2d8ec40fc69d408fd404859e546e017ded0a9f2966403a185d3aa5d9850e49c0ddf3c9027aee5c4dde6e967adfbf594fcdd0aed93c550a5a0ab432c28b2caa72546722489b2f4b8f306e2d4b24a9e426eab353e4bef43cbac27653ce925f4a68632243bd0d927144f3d9c93d18d3d9ff4abb5e1709c3e001c827fe137fe9e33c34bf5bdaecb4ca779e68a7ff5952d7237f04d1da16a69c234888d9d435a231d3146de3ecc99a7c15b4576176974adc05387c485d4238f021b113fb4d5cdfad303584646000463ddff5be0c203e7c256b9e3a13f88bc6ee900bec7b394a878b0243fd3273b65a736b904fdf4b2c49ac33efbd15d4d531e606c868dac7e8bd5dbb64cfe6269483ae00ae9abe1261bf34c28071ddb3943bb4daaf17a6ff7f2357658b93718ee85af049ec718e6384cc9369f90a9d6534a922e74bbb6dcfb1f6910db8e0449556f02e7417ac304331f66bd1d7a0ae821b1a85947143b851be1fb65ea0e9917039979a82c17d638fdfa2f92d3a49c3cf51960de526ec753aae304b1c58f729e7f760f194f0e70b852c6cd984d14b60ac160aa2405720e1eedc9ec398410b8a14bf89a1d458fa0edcd1b4db506b6d3698b6666ee6ada34de4836461197fe837276e0840d522c77bb59e42a95fc1ddf63fc239d6c9e387168e5578662cfa089e229db7bda13c1bc509abb33bb71ec25adfb3b01b4e8229ca5ae03f052e34c3738dd884771519beac0ed3613ae23c0c253ba3e85f51746795721bb6446af6b1345b7d54a7c6b9718f4b0580e9b6ef066fcd3a4b1e70766d5339cc1cf71d6966b008b35e79822353dd039a3de717a1b07a396f352dd774efe4661a79df48c00464ad93b42f85ddb0034eed0f2514519ff6b9ee128ad1832de0d0b89d4b82b8a9b5b28ec38476d8ac8a92d6ae4e26b48a003681bf9140cbfdfc7afd7abcc986afc58e6bc513ef5ad8625a57c756c6116ec615e3ed2a1aabe015416f33c8fc36285282d2fdc62a9e45cae87d3cd4a90a6454a0be0279982cdd2c3997b81f19c6f79c4162c0e30e377aad0e9fe96e0ba821cf5e35b56f1b61d9d78c540a2b48dfd1e589a85e58028f58087ae2b359ce9216eeacbfafb040f5852323b08475d58eb80af9e1a32911f2c63f9e2c31a015bf99f2dedaece428f356e20ba75b96d380e6342c3fb5e2caab467978d2653f0289a67d5a65e494b8289b085f09914a949957365201dc703a29603fc4349291fcb916d5b68a3d416bce8999c7dc6964cf47e45f8d6df64a25f2ed66f9e1c101db4fb53b6b9e6ee5b842fe89a41ee8954d2acd246990cf165c5222ba37139115c98b7d306ca373f0541c10f95da96dd3a78a9d1b51ee647281bbeea3fe6ae9047252dfc038bfc95464c145c974f0d21531b8147c41593297ff2098553e59fb70b22b222c3e645f48f01508b07d357de7e6d0aa9f80dd32a20f656c728c0651826a913ee6b397993e6cafcec53b2f1223a288cfa889aa0aa56b0aa6a7c1ebf11f8c72941c86758cd4e1353fbc6bd516f46f8f6f023c5f9f9651f8ef75d6fcb60b193e4254ff699331434cb97585d2b9de785eb3b9d62a3adeaca7b816599303dd00233fd254215a05f2331bfe8236aa8e0ff7884963b4dddd9b87c412796d7d8dc9d257e02b6ef998481881205a4549c5bbfe32b074cd3bde65bf72ed7b3862b516865a3f1ccee257ffed8cadb755a42939df9c49f735d1fd636fe41857a91aec9c8a0d528bfffc3a2db5a118a332fbb7520d5d4021d82eb054451f7b4f5ac0d0f6e76e87e07f133fdc32cfb2c96977a1763cce9c5c8ee33245f94161b71259932ee181db9efde1b0863e7d18641ecf361029e3875c46a7b12a8dda64af2d20837b531dbd31eb1743e10638fc7d90c593246bae39eaeca069f5d95e7cac784b33302b80c50d5f750b317f589f0470dcbfbe842899d216f2fa2d1b05f362ab7f2978a06c568a1f2459cf8febd9ed0a88d0042b107124d20fc8cb0efc303c47afa8b96f03827549249c0f4f9f2e37afe23617b7c342ab67224b80cd02b442bbc37eeefb2715ccb4c71a473233a14f2386b2de311f7f38ff8130c88a97e07430343d574d28b4280764f618e267b870fddb866ec4e27584e4e2f5e739a645387dc18d2c15d7e8680bd3607c4b929bee0ae5a717506ad5d8abc1f21a3ed779e27f73ee108bad7673bd091fd0dd19fd71bc72abc4a1de8cfecdcbaa1562bf7dcd8271365188ac20b699671d88028a00000f22d7cb69a1e36a007a8b000e5977adbf3071323f9d614f67a2e3c75b2699d45e0b0ca8c37119c5d39aa4b485d9655788b9df1ca45eb1abc77bfa7386226c143240d37457d4cea9dfe57b0ae79a72b2138a8fc97719185c5e2387b2826a6b41e6d071af3426e6d43497925c4fbd7a2b3f694d852af813b4fb7047df966df1a9c5d175302b58fa436f08c7f299b808edd6be371f79043fd79b5a60a48b1191c4748ff3a56439c6f0906537aedd090d937c9288b80b2957af06fe2c180ccf686c114ebeb7297a93364671ad93c6ddc1e807e5b87c14443b79d3338e70f4ad8e985bfa707e2f6919cb0f4235a5dea7be3401858ba540cd3612b3e3f7e5e5578d31036d9ed5956a564750b2c3a86d8431f751f4ed2df4ea5496a56852d739728e8266b65bf4ba109e007968d0775d84da2c6bc8858e8b93e11c0c77610816842783262cd1f1ad6d975219c6f5c2b35ca27e4b114f01740d56ad98765d03cf8b7cad65a73b8d623bb6896789acf2a1d343a421dd1d47a4d749a88d1e77900f7d32bca55545434039b097999563fc62e35456ba00ab761b9c41740f9d4a3ad51a56e2bdbf5a178d94baca9bf23a8b191af767363bfa807166c53abd543cfbb8e4a96a37667990215b8379970c3225e9622976dbedd4f0963500ae2860d0bf9cf9e4ea4f9974c08915aa21cb9ac5ee27441db94795fce63a5ddfd1c74cff995d26d848207cb957a5a566f845c94475e8c6a6bd362df68f5a70412d311740c70b36b36bc54510ce352e9b363591df9ce437dd121e4471238754f5e1330070e3439c424fd32d079d8921e081214504629e178590d6660e863edf94cf8c0185378c6029ba240565efbaf5ef3b28fc19f17b9d1726919c04792793e25abd4c9ca7789a07d484328fd76542e81202265fc2e6ab2cda5452df50fafe67ceb4d760941fc5801d705a31499e73144de2b78ca368efdc12d91f6aa8c23337c150649c4f56ba637f54c345a398e3f49a63157f990a40fc453bab9710b544952e743034e2ffbfb9964661ac6d5d0f2567f68fcc2d38df458687374f8709d6291ded06127b39f93f0237c0d1f4c9778f73bfc8eb7f1f8aa46496dc5552134f42ee9609dcfc05589e81fbe06b16336070cd89cb612098c121bc62d7642532bcfe4b4c1009edae9190f762cfbeab17d86fc7a50a7c143dca11331b5fa25c24e4fa00eaae9254389c18997d4896463a10cbad6759c7b13b3bcabfb0e6d6097e8e34da9cb2917a6f36edd93c8f0b8c9388d22ef04c13ac207124cce71bdb408b069d85cec8261ec76a1b99b8294b867719b29a56726d92bdeb36f6c90d3cef3dd9c0bc7e0ebf63f510dbd7fe8e8dca3e2589969531ad5a81def37cf33baee047144f2a3b5172278a59599882400db2cc08d4f9b7c7c262ed50400fb83b020bae3b806596ec9b570bffbee48fda7dd345fe58c0ac422d0af7acf823020b9c2b376ede4fdcf7a49d789cee4bdc3cef6ed1baa1dbe1362b869fd99957ecead93d605f6ec06b5cd7d8fa0fda9fd8e9048b333e49ec204a3e42c50b8023fc2b64744a8e39a823596352b605514d87d53918edddb533dce52159d4ef2381a7d4bf8ec4d53bba86c47d858789289f9298c8e0df4ffac87f0cf8fb7bd24bc08164b4d275cdf708e51cd8d8fe3920ed717c2e9e4ccf733f01fa2b3b4e99b14900426b9ece1d0eaad859162d2ecaf2b067dac6cb28ad668d3a2d49a748daf106ee94fb6f5c25c3b8acf5298f4c07961a9296b3e25087b159d74605de0f27b2bd669649e57b5dd7e2e05372275347ad1ddd6e6c7872d928357c59c0347bb795d9e799ee37f7ef9208a5cf630658733c538c0cdc9e72455dae877d04cf7d4e8bd7211d887a152c7931e9b39a5dc011d057325f83e95b0322846ecdb3fcab4a0f1828ae074ab8d9e71839b063349685652e666baae8159badef35549bf1007002736ed5faf29e2c91add4b45b524b9e838ab0aa4a84805ee15d4abf08ddb8a0feda88e71451f40d69fb44bacced3af3265f6add64447e4b5ac84493e6ee27277860ec54601714cbb7ee7749d04eda89bcc0f0f7730494638ea7754308fe2fa1d4582cad8facbb5d628b87e4a6a9cb2164bb40bdd53aa1a6f7fa900c2d7753d4f8a66193b9fae102a24e0b07affb100dafc6c6349f30234c847ee9401334aa427de6efa2d488477bd50484d53bcdd83f2b5f03b5c39a82dba9338b44c8322fb6143d343b0a2de97e14f9dff4102cd74d575651754aa92318ae951b120169e1846b6327d72e98d4cb8feaea967204f5640c0aa27e51c9d0e4a8339886793bdb965894da60d227097d8f542cb93ccec8de5150caec56567997b4c3cd7ad0e24b1876583471ce84a836b99662d8be6c2c6c3bfab2ba8564c9ce663c0dbce98b4c6afecb9d6d9fe87ee0f5fc897bfb6f0558f7ea5d17e3f6d32c32e035ac5eca37cf01988ba3a0adb7adc67ac6e989c776b78b9f543af3aabff8a5758ae0733c80162eed3f0d326d483813c6f7f422c7065ab1c2335f14b143249c42642cf3a2d6e42dcf73a3fda72706938f8ee982a634333b8b2eaf7a81f091259973d1453efc23eb8fbb9d48b85a00f1e6ca564e351040cceccc29ad10c5d55453385290c713b0a192e2a4dc354cab8fbafa67761ca7d15dc7bd172ebfea359851464b3b1f82cf47fcdebfb624eca57fb0378d61d77901fc57b851e51dfcb72521ae0782046dc937de24848fb9534d0876e24b5ba348ea365bed3f733ae5b3983c34925dd10adc2eebefa28112df59f70fd3d4f2e60a1be004d30590f3f86b257fad161611b54403f8b656528bc269366e439836a4cb83f46077b1280737fbcd8035fbd7aad22b785c41e431fdf48be5cf8a23cb4f697fdf2265655f8e021b9d6ec72e8f4f73b171fe11fbbe4de4523579d1a74742ac15f74d54d00aa520d48ad651ea4e2d8bfbda1140c1badd71ea1c356cf5955b1e0707abf90a3fa3045ad436d541591dee71cdc24f3a047a1b3843325cee18f7ae56ce39d2b4c518ff2cacd4d73281dfd08aca8d354c1b1772a49bf38cf9ac12f8ffb96698129b2fe20d773a991307147f6843dc711c225cbf5ac0eb4fad011e8901d173ceb7211dc01fa5d0404cb722366c0c848602ff3d56e30f324b30b5bc4fa98fa9e4dbbb0791100c4f6bf47b058116356e4cc4440d1ac06e49c6294187de57f215cb617f4996e9ebef792f0451e8b79bc9f701de24b4734b384d2a5c789b1cdab62ef720d99fe302a81ccc7cc269a846524b08f18d9123a63847bd8ec9ebd9ef6ba99f313eca86a985e8b0b0b5616151214d40f6bef5df330cdd62ded7c253c94e2477bfe805be3a89bcbc4ddf2310d3742d7dcb13792add9e2f9d53ddf38f8b1cbe8e93f27099a46ab5796d488ddc5d5cf8afdfb99daea7a881a28fc4ddce97cc652588a062b620921bfa22d9a6107df52f44e44b5a59c64322e61dec8048060006708c491bf0cff81c383906265a86104172e923d4aec3f3693b2ffac7fb9f4006552dc4cf4310ab02ed4618a84438b4563788c64acca55a6a6acb1e112e328a1c866401b7956094e352f5b27d72ce615f773476c37250ec25e34a8043eb42352bbfc96979496a8ae6eed4bc4eae75965cf5156972b162c256f0b4b743031b3cf887277fd7f68204d929a52d2dcbc55dc2b9d57e2c31fbcd0a83a0effd0258163cc865e41b2e5ea4b7fe8cebca14ebbb0940d3e413f647bcb9407f694c62f7df343b1960c04c65d54215b5ebd23e97653afd0d3acb95db64c51d53176ac88bb87bfda05a0e493d60eec3c750dcb786a1bc37f473bb816908b85bb99a7c076e355dc35cd1b0115ad89bfebf9c45c90c354382cf841da69dcdbffc71413a838edecc375210f7f1dc44db5e4c06994f739daca6484982121dc04af379ac9bfe1b6c2d4d74c6e0ded588f0184b90f5ecdfde5422fc6c06bdbbe61c1075a28bb7c30122eb2b8de8312647c0ec4c503a6b401ca022224dec6220f88f31a21ca9a41aa82bbfc9e2266a164fb96a9f6ac32509fe5520667820cf4c39f5c8505a110a5c32e5aa84917a49174c3b36e37ce098c5f469d78eae2e82d5f98f8060efdbaae88eea66ff623fa266d1a81f9294eb852d2b6b77367fb9647b87fdccd88c5ea2177107ca8d623a6bd08fc30963a3093d91b97bb4d295b4917c42f9cbc116b015831b71f65c59108216776441481c19ba54f06643ed08a718a865a4948707d087cc48955f67089903fbbad9c03ee6304438427a3f80c917c457dee81623e04fbc575311633bc526fd254e890417fc4db1895044445cc43613612117e2e0d36b58c21bb1a02d6bb4472299073eeb81bbdc6825ff72619e5e9351c84ddb5e8eda5dd9145bf762241686c4fbe115e3d96d1365e123c361db1a1c92b7f08b445b748296ed3cf0755e318dbc2dc1501610e0b732ea40929037a251cad3c4a2ad6cf5deff777079a29146452e6e05baf3c9165c940a0827a79e65ca7625453770728c64df11d96cc12920d222c1c0c5d3ef2bac97c5831b20c02df8831a5394b12c3e714e821ea39e7a3ae01f547424a3a95e6220ea41955104984e9c54821572e8670194b392cebb0763a1c455eb183c7b8ea5b8b9069e34af8f9dcb00afa6d64101fff529e536ce25771696346711d27b81b66e8755aa15aecea88806a6ac9dde953a886e1ced4105b66353454a9facba5b46d22151bfa2e28d05331a822c5530f08f7769971a83cce1eb752a9191691591b3a765b80db276197222c00248fa0da499c5b1c05999d3025bc97a46f9c04ab442ba1d5acafdc6385cd33079c6e1b280ab3c34b912708bab248974239bbc4d5fe6e47858969f3afa6648e84b4daf90fb9d56a32d0d6d11eafada602917492784a7fd4bd1398dd52f5e8985a65ada47ef71bc0b91904f5bc4508188abe391a39511d68d27cc5653f024a82c42ee156a74d3e5328eb58e374000221f71ff84726627664150ba3be46f221df96f4f1e2624fa669f3f97d8ccf5f928d666c4c0832c0f9ce7a8bcd34b041d20c40214685afa43399939f82475e495f394ad2174be7bdf8b47a35da8c706241c4d0b6a2f2b4f2893af6d9aab842d38a5fafc1e73a36c289e1511359bf0394d2b7a349a52a63133b25b145f33bb4b4de7838c607ae2a0af40f06828af89dadfe561305285b63a0c1bc99774e5cc9314abf35454c462b0f73d49603f4135878a70ae2a064b1fd28b28ea738ef0446d803f8eaf2fdb497523a026cb960b8cb59faf6ae4fe9afc613c6f1d6e043464a21d55b40471cdcb06e265a11e429daaedbad833742989973c533dc08f595d8fc7a2b258821669d08dde93c8b68ac8ea3390951275ea3d127eb396f4c5104fdf1eba2d6dd23d46c721f4ba0e32e5e5eabd62f1e5fc73a3c5baf5152998be826818c4d7b878d997b1d3688aa901ca2bcb158b7bc861e9e88bb29b54350df4f9cd36b5f1e7c0b4b99aee9b9c56549593a09dfe9f462ea6b214620485ba60cb216fbc92555693c922beada616764b9b31a90f071a1145f19b7ced34f0481882908cad1ec16fc8c15a64725496884d353133b8d8f09f763a11c9db439a023a8843e058a8beb55ea21ba580292e06866010427c81f49c7be66e7f0f5fb6d2449b56ce0ea1ea2e123b6163be09bc12c2defb2594a4f5bc44b542d98d68d7a63761a307c0b51166630858ad9dfafdfc49158480307c65525a2aa2c2b76bbbf39733adf2bd61d474b1c29365fbd577067094a64f8ec992d752ac36031bd49ac6096e1a05ba5daf445557a38c5fea9c69216875ad8217642b375fc2ff4e6d7252b72b908206b63f21f65d21c89c379c26531b0a4a09855b9d4e389ee960444985a5b7c6bb27a078f424ccc9a81c0341f2d7cd3b1df53ee64cdd54510d6abcb92528b316e56784f393028d856f90a102a74708eb00035beb7c382c9fb3cfa2a5b013430409f99906ee17ce47d835f63ce867c9b9934d7f8d8ef9f6ef7de10989cc505bcefddd8ffcf11ae20a924a20c1e18a0953d24baba9282e61a3ae63b760e1bef7bf241b154938eabe722822b27f6935cd483efd5a033e68e3b70319dc976c8323afbee1e30475c6c3ea0981302a8b2c4ca7a86c694a749830f0fd4629b5fcf42d930901cf7232bbb71df43cda0c6f0c6a2877e21fb9c34f504c6c86006ff571c3726c434d6fe11138bbb0da5f2394a6ddcf801dbc369f5311a1932fcbca1beff09eb46c4b5962785e3c42a5f9b2af32851b1c324e58a0ecca3a48b1e7639c70b847b3d78a88db17ff54a1a2c1ab1b401ce205d331c8ef0b2ef0f3b49c3142cf3384ab76d4a62b32987de0cc22086e676f071886baba7d5e1cb18ee4b1208462e6e24cd94e3892989999e5e59ab0489e0bd2faa4725800385268ed5687915719324d83eb25eb36b29f0765a9e303635e95beaba59d9bd68c6332c59bc87894c262492f05959bf199feffa4aedf8fac5a021c869a76cce1f73c191260c6d703f0bd575b4dcae77bf1090ebcefeb3f99ae21866e49e7e7569534e0de128bd3ceab31564cdf838ef6573afd29c9a54b0b586aba7dcd8b708a1288489af65e55f23d512f8e2f15e27366d85222865616b3e31067ee4b611746def257b7409f7cb9aa868a7bdeda46d83a2f587fe38415800a0fa90e7b80d5e3d1ed8493e119337d8223ccb98dad28011505b17bc530a11ea19651f4ac604a874df3bdf8ae05ea6490b1cd7baa82a351a8edb3cce58e6af00da22d340d74498231c4c3a976cc66402d445cd41f119565dd1eedd49f761c73329d9750cac93572faf4db834bc332a4a25764770d2d0e1c616defe446468685ce860213a28dfa4ecfab1ea703e754b27fa018d61f082fd3d5096a0b7a5811ae13023d6f3ed44e4ec4fd85ad48bc090a1f5c880d45be20a0aeb8e924c1b20b64843582ecfeaf464a6e5496c9649ed798dbbea3bed8ce913c59789efd2dcdb2ea7fb9874240fee8268c7c1edc656999a5da226ffcda9e193fa519fbbad949cb680e1c7eb10f348915741a873f61959fa77af56d85fb41c999a6d6add04af754e96ce781f56a5d373227fcf5c871e6517ed5adbb52f8cf5a94c683749f89a09122cf55ba13d0203cf1a992608c4c16ed6f50f99a2f966495d248e07fe9cecf4f9c34979c4c07dcbe84086b4d8d4e3341d36f2c725dc335cd724fe0c4e93531a95023a93f55b30a355f4c6a68b6e1416c169381b97e153bf94ccaa89987302e46ea5bf5f05f2e6e4f1000973adea021f64002415a471e2f912b784f0b2c18ed4f8266d473ad0d0159b2208587dae7b895c1646b5d16e85a55bf022ddc38f55329074c6f5c9d330d2ffa7248cbdef0075baaa02f2921fd42b7f1775b08edecd95b1558e13501d42d4cedeea5b9546adbb78806ae87581900e192df4740869ba513f5f7af1f1ae1501d45dbddee9eb34cee8804f3d286b935d8877aa5b3e24356bb456193360a4fb9379c0ae12049ae058c4d75507f3bb287a7c9868a1a63e1b761f579a71f141e2584cee94303b700e009a45252678336f905dd1bb0ae6b4c4773e8edb6ed1393172da4eba131d3a014d542c2ee2d9040bf7182989eac6a6fa3dae3f45b13a34509a56d466be2f8b6a9ded244d3f1b77d992f87184f7342673ee9e71749082df2574a3d65f9543b183db39ce157cee25bf416d0ce748091cae3da229e578c619ef01b2af5c5897a6364568075805144f654e1315bdface2f09e7c4666310e683d247ed13124c24b80662298edf500727e0b00807fe78b73e4e9f0516c2c2fb74567639e3033cd308efe8f59ff512bd7e123524ef16852ce265d82e41f540950a9bb36004f6bb68a7e0792b8143fd00999c36e35533abab6b02b4bf7900480731809697c40b51137b0d41138858fd8db6f8ecc95a3a19f3f35c834b72148395799092c5fb2931d499b1e32f0660cf3a1c0bc7cea1a1984e9e9abd45ab2617f62c8120440b487f9814ce8afcb5821f333ad22638fdcc311d268bb54a5471f1d559792a29c1b4b73be7a604fda1f7ce56bb288d69bcca9d73a93966998c4dca8862bb767e2804cd9f3f111a1ff5133a9e1ced5593a44c33e158915517513b39f6e8323dead686722aef3e345a0f7ef755d162154d5b03d90d0364d236d8ba104b3605ec0516d35f6803058849d28378a16cb3c7f04a360b962d38bae5915c7813930742326b991d6bb37af76f5a3058559c0b0b0f3ae4e2ac22f33154eeb5af5755de4413822aa1ee7d22d6d7431aae7726632eed7cdf2b4a1c6c8bb683ea39ae01967aaf0bda9046c575d1ed0b461d7c2fcb506f8f3f6695ff07f86fa5e1e58700e825ba5144087fe5e915c2b4dc1dec93a66daa370d435643f0e0c9abda004dd9c0b64420e31351b0c4ba781d358dbc611e1a46ce71467a0598e0a08eea03a7ed09b5e7b5cf95490668396dcd41c6d5f0f4d51c3543945410a964953e08e19002514051208044ad29d4d76325185af4ccb4c3240d5cf3e4a44e8c0ee0521d594de4097833f227008a854d71c7bba4bf1316d4cdfcf7af1fbee581bd2a9b702d66a567c57e07a899012f402073866ba51ed0f130373c2032a26b3f318f1df2087f14cb58372f873118f622871a6355a784e727f479ee34d914e10a366922d8cc5476dd8d5227bab9d93079dd395f2b162328b61e8b609dc786c32a86e2e82aac15c54399983431b79bfeb61d3b4e6629f2d0ca60b076d0c25b5ca7dfa4153f82983de4f53c7c61b2ca5f3bc013f1676a1c2c40b995d4410d9905704cfc983e94ade07838c0d35dbefff67c8a81da559687e20d54f4b95fbb9c11f44b1d2de97b89952cd80159251f01f6b553a43ee3e53b61b7c4861fa39f6f0a7fa2322a0e0b8dd32119f1a0cd54122c118528e9fcc17a980387827671ce4c7c3d2cea663f39ad213d4185798a4bfcd765e4516bcb1607c5c68df04a6739d28544632216cb3f5cb2425f7380d8a26e638d6183aad54f3b22aefad82e16eb597d4682f6703e6e36a8d1090105aa8b31b6a7f9e8e60348030d35f6ab487ab59a2d53304ecf91b1adcf1796753fa7f264a33d1338395796b800170d081df5c7e0e41f06208ec9c68f7817f19903175fe73470b8dd625a442593fccc86b4dcd699fd43f528580c81ef590a7104b60de1f456a84838320bf58377640787b62a9c4652481ae67e2d861a50deedd9749090c467afa88104086b55613dd3b5214bf7a68d871589c63d51affecef664c6bc00a1b2ebe2bcd481b5bcbcccc6d5414b62f4bb2e8930ed8e3ad7ad97e661768344b527b81b165fc33b8c5df5c10576d704d1d52c90ee4c84a8b2d2e5b7a3c0308f1c85344aa0d921c81b204e3f3a82d08a842523737fa2f017799b7c68b42323cb1f7c1fcd90be5418b0eb69a313fc2a0738acb0cf7bf040db36bc0e777c03d6e9c1fcf32edf32c7c967e51bb4fb2784f4bf33de089de352b258c102fc2966e064c11fe268ea191087a4ddf33063b006565edc4d27ddd6c44fedd2a0e03511a3e90b17372181a8a08bbc03cfeedef729cd211f2ee726906d198e06beacdd32ab7492d525ce5e2eeb68b4f5ad31c13231609686fb1ac0747f1ff929d19cb2c55019772b1b8399eea169ac2ea46e37ba819469042a2fc3473d3ddfc062a48b074f8a7be6f458eaa268a895c8ab271d7d4b5c9c2656fa68ca4f4ca1e717e35a1e3f66a6a6deb95448def68776c94180c9b3eee1e9bde581d0868757cfbc34ba9ef27d0beeb2dec1ea27389325012839e70b25b01a3168654f58f4a4108b14ff646d2dfe318fb55334216d6b1fac679e28adb22f529f82a0598607c83282a65defab7dc91764982a376b98082768f5a5b952d8354fcce9d9b9b9e336ed746534e75e28bb984df48fb3d785a86d6fc707359095f89dbdb540fcafb1c9ada9321f874972245cb46b356712e9228ac7d626bea0d6a51766a82337e3cd40b979da72613ec4804d8f5bd3c9740c0705aa42f4c3cad7ce380c47c7f1cd2056ea22b84d7e3e92170fb35d4a9788266d619d157909425cac87db9315e17baa1a0512b86431cce940800de1a6af429670b6c0f90c233f7aaaaf97dd7dea44fa5998366599cd5653b1e8a69e013bb36bcb240b3c05dfa10ac2d314d93160523d4272e6efdef108b95a6b529692d9ea4bb57298ff1af2c66da7474d69bd31e7443f5586834ceda3742da989a8c99d0b24f34d918c5b70ce34f1ccbfbea49904bfd60b4237752635b41acb0d43507c50c8bdef914a8b60538ef44caabffaebde41280094d92d588a497378053160ad69451c574684a932c9da06210f2d6dcd6299d03d93e124b42d546a4f8309706e6c66c11458d8a8430692533bc7a2f332606ad6ed71019a4f525974ff0beb78605e588fccd23d194e1d1a0ea579ef830e567936737d4f8aab975d5896eff70f38c68fbb325c8a2d14c032dd483bff9318e2f3a8845aa736983e9f2747f26f2b6c5e6cc3060f56526b5c0a4398a41737261fc332e5cbfedf5c1cfef2aac7cafb55bc98954113b2116805a467aad6aa7d3af52afa62e9ba92a9cd86a67e7c1192c78221fc106504f328293613ae61765e42eb4e6ca91b9154e8c73e36eb807531c2334b796d1ae3c4f83f489a910e9e917964d5441ac5e57fb309394b1fd1f56fe5dcc9de843bab405b87a1aa5e40a5fe9217595d96458bb33f2f882ae8982efaa54423e4ce925acf1492929dd11e1bd15a00f9c8cabe7a521f8d9022a00f21761aec237e781276487f56c965c356843372d1d37c2bffd05ad7e4dbd85229e7b0812e79c61876335a354e045f117b38ddcb4233e8f25493188a230762abb35ddef8d9afd38f860c1248a37bbe2e6a39d110df47069d2752631e3fe63d6a5d28d5c5976ebb3a4627f11ecb0c251d4a5340dbea6f69ddf0037550a0bcb4bfe5c26a22e856c0bc9f6668cf578dafb52339132eac4dd8fb27f9b6d2d6ca5046649bb93b2f3ea2f61291b6274e086ea8b8a477634862dfa575bdf22ce34e68ed2548e9be28c0aabd9dfe7dfbaad820d6635ff22505678017761802438df035d62883d9cda4651b0e7d4d60cd08ab28a68681466161675e14ea4afacef99a601001357570be2ce4037f2e9a152db68416ac21738f117882885c5bb888467d1620d2d84a8130b568252f6054581732a08e16cadd944105aabe23fd0dedff9e44a990f97aba513c829323573ea8d1943234362eab163940052f50a345eb378398508ca87b89a3caca4f97698ff16d61b8c281b9a171f9c17bbc819a06ccd49347ca0ab4a59c7b337c763ea5449b8ebe2fa1a5d0097212d03403ef7fac6edd34aacc8363a7d1b073125458e3c36eaa5a14019d7bf568833bc040e8bdb48be25f41dab8cea6a70955505dbabc72faff0773b3842dd4be31a2c2a0c5f6aab1e510cf1bb0b1556d3a1ce80b523041293a8514709a1ce58f51f83babb30d144773f9a510582152a64db319f5c4eee02bf2f3212ae8a90d424036ebd156779976211580d1e4328c9428244fe67d3cb6c1979564fed4216d5b5d60f6b97c06117063e50c8daf8cb0c5fe1e5186ef297b2019791db404d0b64908a9e7c8c1b91c152f5824178cb9fcacfae33cd22d7038b4c6b4f670f03161511cacd499feed41f2118af6fa3667ed65c56398977af13a1e723b1da1e8c21b75fe79428d106583787b3924dc0fcfd9656d6e3d992b1353ef55524e3d69303b92449cb37695c1437a20f616050e6de6d9419ba9a0f5891691d1e08963d8c6f1ae42c79ed914dcb3f837bdcdd49ba6fc4b9c64160fc902c8f73ead5e1d6ad7f10ddfad3e0a00a3ea4fb4c6a574d0ca9f8a7e6cba7ed2557956d1262f9e3b7c1aa45798f69c73df90e1648e947abe0a799a47f6a3736c356a8621a7abe6962f2eb967c1d251ef071d26f84c691503c31bbed535153e9fa372b6f88c6df08bde5ed8fb4a894ebfcf23f4417894496a1179caa57b1bbf8d0dae2078b7090fb2c43d21ca2bd8ee6c148ea00f394dcc803787b2409699e12307a8b9e10d94456d4488678d926f219be4af5087d03f02704a47fc1e4b6c8586b30ebce86f06f024483c09cdd917588c89b70581ea0c94db960353f9f7cf479f392eb43047a76b93b7328f0548391addb122c3b3a84ae85c690ab36479905ee59c89eddd6552f8dbf1f4b69dfc59d8d3aeacf1b3de654c67403f7fe00368b6043c653b8b5d7dcb42e2e52b27b09429a29e029264ef39412a2d5b7acea976911717f881125edb85663ebb0d1d8ed15930366b99daee60e87d5dea897d9fbc34fa795e1d927718a8cf97f0419610c1c52cf10136a2dae1f71d2a997397bb5746a4568499d5f0bee72cfa575ade308e33577e744abd65cdb05a433b0fd720bf1c819a7c1c466b17e72b3b15f51941a1638e852a0b371585ced8d8b6305ed230b1043d1076b5f82cffbce59222a03a2f82139e7da3011a9d4cc882c806c482e4801ab940ea5eb6f4ff10f0b8fb788b7c703924f352c5c443893aa521ba5823fe90df72a258feca5a0591d7a381f563f6bda4680d9551a49cdbf4d2f31374e2f6a1ed330f68e02fb55893ad666b1af2f6ede29611eed11b3ce222b4e54983c8668b76459a99edf8dea0439f2e0e6c87b3907e785c2a531207bb19aede22a485d711c831bedc1086168883cd1937eb7ee21151eabd3c299451d3a9047defd94ae88a30095de6b62ee9fb0b5556329854da06a85c203a852a7fde666bd48c04e4426d593d5484dab48075efbe6a65f14d1c20b90c4f837448f428e1ffbefeb4881e2d4df38e1f4b7b942763917a6b3ae563e4abd4f811d5a4458d4260087b90a142a63ee6dfc950e8d7c03aa3cc72d302154a06223d55bdd0ade12abae85f04e4656bbb05c9c0d71ad6365d7c7aa3f29edaf833cea4731ce5bcb0e11a7e937326c1cc9356d8f4e654de0b02266375ac3003665b1640273870dd4bef10b4347182e21dca0ffa1031d0ba5e635fc4c382a7e235e281ca4593333b65d5edd02e10939acec29ab47166a24f2bd11073b2caaf99236644735b659e705da90f35df71c704c0995a5f109d9fc3d41d29521b41e86bf37f67b115f1e5a445aa1a81cf5500c0996caba34e4371c4f980042acacdf4210a049bc14b94a56e2aad52196bba8f659f317ca48cd10cd905aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
