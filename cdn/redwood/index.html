<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"997609725ab0063d875fa861e93f7765a7c465c616af08d4787a0a2b86b440d294564f4731f811a2fe55ce419373651918a7911c961b30c5d0d9d28483c70ac951f05493b776ebccadec0aaad3207c22d5cdd3054b46ce723b88e3e5050a6bc30fb34b540b1092972305d330e70476f20161be304717ee29d19a02108159961b9d7aa65ea71e3969049e854e0876d74db1fa260a52c927e66cd83c7632bb49e7cb47c05fa2aab434fc538e686033cb3564a4b7721f147741ce6e3ac7f97c8771f340a83852e7e636a9b034b1b8efe95bcca3e98cf82f78551b36d787a43d3135b48f2fe1c6bac497e3def4c0b55d9ca8fa7bc667a57d3f0a342860bf861c7a42b08dadec086bde227a5ad16c33eaea499f99a41be6174db4bd4674ca5775c738551de2b4614e2b3abef30a1e03d08cd9a4853e36079d5ddadd4deea3af01eb3623a551714ddb05f6bcc7072c8fac976ed2112107f39df47072ac042e4177def563c6d77f68dda6592d542041645997b35f5bc8222bfea4b48e9c6a6775dfdf11514d5ad792f4c976aacc11944858797f0a2f8aace69a8c196ee454f3292abdbd18b3af061ab02f80a00c5482606248522f4916dbd73d2a70db4bcd78837e9e99a6aa160c29213fa11e10c05f32c857b5bf11c4efc99fe2ed0e7ef5b623b669ca596aaf1918220404fb664c17ee91a1bd4790c6dfd0f4902e9db05e3e739dfc2a14b8cc3d2b2e3f3547e4a8973e29fbaf721446c9b979864295742a2de89b4ab447eb59170f65cc89c1503ebdf0ebecc69922254390e0d85a366165046d482bfc0bca8d061258cf353b7946455003ca4b6ca3773d82dde8025a471a397539f567f6901425ece3eac003ab04cde976b2c8890a8a7c01e7b25d41999ca08d083281287cb1746f21245861933f74616f3fd98a9b0fb01734766657ce84e0328d39b702c9b827a780adf703dbaa05f62c9e1195a3f6ee52826aaeafc3f7e244a79b98aaf826adde0e5a88e72c7e0029e73ab003072dc5e8b486435563c6d7aeaeb2bb18f68cc39c0039b343771e1ebea8f20af33046a1460607578ff771e856a9debfedb633c216a449cf9f02c355db60e24bad899ffe69b070eea33800a9043970b2a4015a0d0f04c241557e980b857dc17e8dce57dc6b374d5328e08b271c1f42e3235c5dff52c2126542a70f2aa5b8557783f5255097e9c8ef43149d9f5663e63dccc898388288480f036a2eb299de62b19eb8471e78f339be2885f1d38b863b15f6186f2764d7c7916fc2529ca742c4ea165fbf5b8e3979357f110c41f13d7d6798d19427a1fd7286bae4944ae4009e0169365b15a73ba824fb1778f6ae0de6215c94160d4249a1b495e3d326deca579051541ca63a32bbfc3a9745b970d0ca7e35c2f13b23bf00a229916e79253dbe1a5d6d2cf1a2ab3ea40dbec20152df8c447cf1981cbdc6790145ae4e17967bcdc6a17a377f0345850b2dac15ffa70ace2466e1ec59a62cb8615f63751c3ea30d91c766b24b6bfde4fbe3c58ade37abc014fb99f3d75b50a0da617c0d495437f760f561e6d64d69b79a8caa609b6c20900c5a6cfda70d1df6521d3f0e45823e7e48529ed5d48870eb8e408c7e74d7a0bde9e1419b3d1c5d35660892ea932d2b19073b828b5a4f0983dd0afb0e5b749c5ad4feec5a276b4603fe31e7710fc29a3d97493a81ad23166154c4fed1e4e7d1bb6687375f4bf09cab97775758f5f1c0b515818d189d2d5bdae5005234e8cc2e47055a5f12a038a715fe902b47e8ee3d952c33af458d6fd0eb4978964711e3d67d9038eaade28d7c6328cb821497b6a72ce06cdd3f694a0e70d5ced6b9f2dfa00dc6b782b583e5e4e01a6939645096ae93f92dc3ba2bebf35e177044610a3619a35231c4fdc839c985c830c6984b1895a2325e0b2013424af6ff863ed7a953f1591c0a170a573847ee28ac3c07796267948f3ffc1a67f90a3fe83e40b53e5d42646a581211f71beb07687410c224c32df11bf6ee571a5fc0d8fc92c5bcb4ff533bc8bed10ce370ce99d2fab12062f9dc53ebad2c94afa48a1c801a847cecfbd0f1a779dd54561122fc861b0fb6ec71591b08fc85d6f4b0e925df354952ef2e2b0bbb70a4d54ad23465d0f04211b0cbd8e6b058316e16fe7ba066bb0518a493191001cfccdbff1050e54507640d4db0c6ec11b33316a3033611696226bac7c7d65e06ee3e54dcf45c0a4ca971502c8320cee3d8c56b20bf132c9363c4f25299e8139bcd1a74d00eb5bc919d59689ca69d3a14b8644a1b64a054bdb229cc8389507f59e6edbe2035face6ddca3edc7d23df010e57276e44bda4df5d5437bf4b517b2823f58f6fd9e298a633b542fec0d668634d165e794a0237a9d1efda51d395502928546ce2ffe90d5c5f39bb8135816c48bc0fce22bcb4def578dec63bff82ffbd90067ac64bf6d9eef04ecf5c5232ce2b3e2b709943a2259a0bbae5bd372893fd897e96696f761facb387da95441637295533aa7c5ed656e92a8999433eb1bd53dcb594f6bacc55003083e531edad911f6f616202d01df62b7f8ed397223370c98c74d6f6205a764a2cb6cd430281697f3891dd4c01b20122dcdfcdf13cfa74e3df430a05a108cc7bd1152beb13f6b2dbd070920820c4d81fed45e8d2a88350f66bda6642cb94dfa9e888031e6e90f0dfd3bbee2340a2aea85c6d813a5317172a627bc9055d3138c5afd3ef690a0cd46861c139496f013a2da7e1eff201a81c8045b6a18526697e461bc0406c680e950ca546a5c16a1065d8f9d85d67d0907e92040469ab04fecaf6a802ec76d6819f3d8ed38079a5b31759b0f2b82de5883c0d787cc15007589d126d82e781de27895d195bfbc6148fe5586662f03154420c9586bfa8e235a5be0d89374a819350288a81a3d87958f0ef6ed4d6754bea3e6cd30ceb665e922f27ace55ec7a08421c9381b4c04b21221bbfa5a0d53f1c6399ca55f8abf3fb6ad7231d31fe3a2c5b75502683e600aad970c42ba6b8ae99a6e2b2dce0a94ed0095be0021c2a04fa7f6c5d537842422a23a13af68209b5557105240e9cb19968eb6c1efec43f2ca5650ac093409e67dee480be277062520b1d7732bd872dce28b27335c8ceeeef97b419d5887bbdef799311a09daba5570f61f08279d7fc3240ec8eb349cbb5869b5179ce03c5d1a4c2bbde7fc3eb1c0cb811c539f80cda80742de5c30ddbbca7dba2590ffabb837ab233e7561038f20c653c6bcd153869610931da8d55fa8a067596f9e3e6355a43cc770eb9c7c376ec26f6556039b0ec4e3be761781a75c0ac421591ec31df5493906d9daaa774d56cedee3a6a48ceea77cc1c316d8a7002475b71e201ba2509e3c95f87ee986c43f69f2f29656346ed74c912600a7b2e70a19fef40581f4b937b460e540cdcfa56d810a744d88e5b23c327b8f1081b616c00f04dbd9617c2c1299f648fbf491b9c7ad871de75d6b53a0a054342da6b5e189561f3d4007939836e0efeb0725bfeeed524837571ffa47f4c5eb7b2fa0bed1a26dc58d08eb4ff3dd69bb11479a1abf1055bc81424ead69dc7131919521a25b00787acace424eb3e5e4c2724ba129009c1667b09ada4c30231ed05b98632193656fd1ddfc2dbb68e54f879d6c22fac540b8ece5f34bbe04bedda10ff612ed35fd857e8528454857d26b42a63d7d247b2646227de7f32cfbdc79f33ea71156308e26f1221b31656ff0cc42f674bfd966b3a46d502d57212cb50cca6e18c02c7e9a17100888f5fc4db94f1f8d12207b61b4146f8a100bb7efada05b02a72cf04388c7a47f168a130c9baece690f53fba2b3ab3aa41b8bfb6a8841f1f853e8d59984027b1c261b6cd4bda7454fb9c950ecb37ce2246fc03da9f7228f2a3da62ca11d992f5e618d6d6258f0815fc1e791fb135a2a0e7960e308db5ad0390884838713b590d75b9e8285697fedc756480723f38280c95b34299ba3388cf11126e8173febc156f2280b60b6121569ff5a007ca789214a8f2863acce45db72cf405e20e9ec8c3584ed966e969e97c70e4475504c1b1a8a273f00d08ebfc5b8553eb62e6604da7d1fb9af08d771538c447693c9787e12640515d913d5bf16a2ea1f3d5d8d8a664977705fcb54ac24de6957d39c311ab0c760f1425edd6235e4af79c69ed23af452acc1cf38a0eac647df6570a1d28ad6a8e19f457b8e5415dd0bc90b035e22756d739cb46762a60859fbda4167dde0676bb9650ab33bebca096968e97d0a2e221bcbebdfff40a10eafdd5e8dfc97614147d76dee74e34408724c703f8c8ec0d3042d9721cc460a2883d6348cc3fcac6b4031b6c2c310332c8deab1f84b3a63e95c5e8327c846d7a71176fefc6b224ad8b43d1ea1855b1d46980883d5e077978e9029cc884607ba7e0a35caa3ce08ede234fc02df15893dce30e47c471ce8ca4f1b4a6ad71c2a906a4f309aed1583c1f25a7bda85f1a5218c1074ce3584c30ec7a9404042a95fcc84750ba898fa3ed74daf4b44a9a723f666cbfde80fa1ae822a88d0eae0914d88fa9afb936bfb38092ea12c9e0f8a361a033af5e7a9afb74493f42879c6d32f06ff30af0537d157c8daf1fb530831fb21bde275347beab1c894e3f8b26af75a889409c9bdc588503649e6cb77fa288c2924e380c16d737f4c31ba50b13d20d04d09186b3255cc88cb58f6e546c04e7202be14175fe749cdbf9428b8c570b23ce73be6e4643925ef716a4cdd26c5d435258a3d1d9a5298e3f5a851de542e9a715e6e2d3e3b6ba9719ccbf7cfb500dc65889f742410be08b8a7758c6626f865e94e0fbbf378cc29c495d0b39a843804638938af19b38c6a03fe75ceadd616f7dba75fead840f12a85e50db2e683c42aa4c7988f5f23c7fe25d25657cfa171e76f6257bc95c8328148f5e3d44104911afca2df758cafd362e54ad7a4f8a67a03b3449256a97bb1c50fed214c3afe913f1ad91a9f770e44355292703694a2180d2f5a86ebd1e21ecec1f824ca4ccfc969af953138d5309c46abd568fef67bb5566d3817deb209f111d15423573c50a5d55ec782827b033791c7e9416cd7dd3fdf823494e1fb480cc9767b3acea87fbc064d0b3485f4949689ad20d36177f440a1d76a3846df40242a4d767e55a79e64e68a1ee0827c34aea8c4ce19fd63d507cc844f7e455265b0d1269449a13aeb1346051892cf6a791d878b29430f039c569559c774f66eae215c66f6e4e1815ef13b3f7ff4b0609f16ea35800b29976b3d6411442a3269e82d0b5c9abc9f0a01358174e3bacfaed0a8c4c4f902856191b3545cfcf216cf7d8f0e41fc156d42e7acc7cb7c6af8a45765d2d3a60e554ddd73a0037a4ae1d118e064da45792113f0c291c2271e57c1e46e22275483497610df912f94f82e79774f2232483650e44ecef9b18f9d032d403ed79d5a552233a90ce0d6ce888d7316081151858360fd924d540554ddd8f403af6dc988054ffcdc39629fad635a1f94680de0c58954e9e924395a4e522d4dc171fe5f39c0576494fde66dc186331ea3d433cc925830974a1fc20c39bdea55eda0d0f896a19e865533d6ad7ec37f6d3fe34b1fde70cbadda6d6e00e130706505b1199072f4f309d48bb0f73f8d47f7b4e24b2fd844f3260af821ece8917796eadf4645cdace32674b013d31c7ecef8036b114513d8cdab049561e0733e048640a68cfe56cb0b72169b16d2ff543c3eca124c5151160d8c12874e7b8c3f6b52667e862b900f9be514c51ff534e7e671f08a18849abaf72ab81f671a9742e7c06a36e69c722d7c31354cf471ac4e33cbc3889c734a6c69df3986280ea19ea75d557f40119af460390568ba117fac4065c688f799ea56b40071f13e4a166731f5483576d41ad1a59ed2e25f1ae38652fda6c10557ddc985da9b8094f8e388dce1f6e45579f55b07e2bd8802759d048c67ef909b6c277194d3b5a17db34a5eeaf0677ec8938f23f5b8f1fbc62283fea34a8e59053ef2d5dbfceb1446cd4437eef98c56152ad83349bdfc31d8a1643c14d21dfbf1bf3f28c38e0bc88bd55e003f4c1dcf1e84d0a778b79fa844fcffd34d6d63bfa0173b87e5407794d861ee7e9b78670333822a1f8862c7962dceb84e164450cc1c343db8e5efd06bc3dc95e8501ae5e72146881364ee7d3dcdb6beea844dba2d0ca92420c1f0cfb38b748fadabbb49f04dd8a4bf414be9d49de80088ab0b1459feeaa3b5715ed558af740f937eb8e9a9fbea5cac071ccb9f3982b88fb1d8c33a32bf9138458412529b587617db1cd027e9ebf933fdfbcff3df0b3b5a0299afabf5837f22eea4a18d1c2fb42e9106d5a8b6ac9f9b2b7fc8df5c943189ffc81a84c436bdb574d6b93d3042a956865f05ff129c2f2874588d7370bb93ef5f2bd1497c3dae54a0650754933f4bcd11265174c15f9f4df94c805b8a626159efebe9760fe23556cda076141dfc7646ffe3be118660072a5ab08a5958d5f3c8428f5fc1199fafe90f6ffbcd1fb03d18af13597862704540aaa10b336e28afc36ce0bfb120f46a93679f6f20e3ec104b43d135bd68fdc2b441c30330df7972697f0ce6fc44a621a0329b74b3945187aa0ecf3ece2658d27480a853cbe7bafae204c8f9fbc9a23106e7180f06dbe560b2184a2a5aca23ac8c7957be4f39ef7fede462b28955ee9a7007c945350e3cc01d8bd5272292f57b3ab0d1f5aa5cca233072559d982b160d1c27e212ae90738d5ae01a8a5b797d9d357ae93c7c3a7757c2670a8ca19fd7ae320fddd04424167c2eeb7e92c2a605919fc1d5d247f6785e054f2cf7b637196c5fe4224be132a94c099439db3cee40ab9eefeb3f6e6875a838e0ea8e2b2ce51a6cb4ca45f005ed78775c64ba9551641baa4103c136bdf93c0766a1637439332cced83fb92912cffbb6d24c2c2313ab3858ec5a4f19f92cc8ba2fc9cbf0002bdb1b489e0f47bd8aa872a571909668f2d4848554238dcc10f8b6a660458861790c4987e68700bfe34d2f659cc9ae4a81f1670c59b26b72b2b228b468379127e569518838c292d128907552cffec83b3ce09c6e3e11a1fb81f4857d9f4e4304e08aa928865b4d970e5ef1649ec2ac7bc7ac2b748e9bc7b623c60818fd559e589c3ecfcde1b109e46587ef0be08e0abfef6891b391e384d39ece8354e36eb4b5f397476171fa52a2673838eddf54d651b7564337aef9203135c7fe423820d25cb7cf90163e486b1532571fff2e49be1795435e5eceeb0ff5802180bf02b4800c95e6abd51c5e907639cb9a0b3b6a02b0ff412e4090e03772c03db165e77e77b1075a9a7fdb92194b3486a6423a105615a236c8a6f2e1930131b7455b8d84bddaddde74aa0a1cde5a0f458bc898c07bc959b4c0cfeaf92cd728f4987c4f62c4a3340726a5d4a0caf64f98dea0a4b15cb03b6457417620039c5916b4f2807a342ca24f883f0251f9b9d0c2224ed21d8d0bacf99eaa320820f5e3af891e21f0a08e93744106b4b55a9c4f7893960b2e0e5f59750386f7cc1f4c166ca7758a89aa28b6853a7d7fec740a391a77b5eb31eaeb6a1755cb6b325ecb4652631a5a93806ca18bb56ba2f06d8732b0c35b026abf89ab38f029978e1049d3f35b2d1608c637edc6e9edc1d084f7c78da02d60ed13cf2faade6d596ce982b2f7facd18f4f7cf87c019f6442e8eab4f8b9a75558eeacd93b7794639f05ab96d0f96cf2df2b5be13f4633d3edcef59266fb2524bba0430e298d5f49d0cc17527464e11aabdd3a4b5b6c9bda84b76839fb5fb4265f33f7efa34e9200981c564b82ad50b4036ec8b53830316095b10abf1f6afa5b5b11da4ac821d53788388830428dd309bc644b716af306161fa0a03b7c01bb13e594c64483b69e2f4f05e5debb7bda2d844e2fb590f7af89af30a93e9a52dd88fc99c471ec11425c0c12aa4098ba138acb23f3e8c0aa9f86a068c76887f3cf3ecab86caa610458097dbb7e7f02c882a54f62d573a5b025d526f40f328a17191b9809b5d7f6f1368c762060b98635eb1e73b6a28e4cbfeefc479e329a1dc6cc7732bb9e7d2802b1465a300adaccafaca2ae33443b016e975a21793980211597a059624aaa08a84c2786e301afcbd44b78523f21b21d383b383fb631f8b5d1ace08b1d80163d0b6b74ca330bf5634cc3a7e0302d9e0c850d0d704a85d670a5c22a138e4b2e2b0daa3946082466c1a2dc0c3bd8c4f5ce48acab1dab6778378e030682a90f012b3749f2860746d1d5d478910e344dd13025a87658b42529184510e825e5f764f990baab7abed466fb9f44f2ccd956cc792f3763a9ad56ee81ca8ef4aa69e839ad4a9634a2ac5aaa46faf7947e0f1f06e1f7dac1da4fd4ab69216a6b1ee4caf6aea3a42f63b2658d53cfb74df18e89a91d6a9eb1bb54555d2a8d4cf09d190fbac3e1fbd8164952929b1ced437a986399403422f1e5f535f57197b82dc067ad1d185519e1756a09a02291d82ec7b9cda2403b0085e86847a1ab4eb9c8d175db1e102064763d5dc4f714b3e2674d9eef0fabf518aaa650d6016a37bfa5bc18c524afd0798c74e2c41ed62c6468f483f6c8601b3ad4b5b56ead82dd7fad58df02ee7b26f2e53551bfd80a9d833034ff53b5c8af73770577739e075264d21048dda154d768d2cb6d3870ce2dd7d1ec271d22fb453b8dcb3dfe14b07cc5971ba7fb34e785ddff37c3e9d0179ef74baf4e3bc849d4af9b8b7da0c1905e3829deec46af32fe5dbf7658ad743dd744e9f31e65af0715739c756c03c8a98a32e33e49b2343b0021582ca539041fa25141dbd6f0ec23c88a9c984258df6c38f7db472558e0f1704fb12d33740296f23aace340ab9c008fe58eaef3ff413d26454118bdd90fdfaf3187b979e60013b9739e81fdb36f82cdc563b0bd299cf14df06af1ca33f85aaabad69bf4de93c10c2ef12eab7394604863f81931f54783457718cb7c723708e8c5f905698f333a835a4bcfec09afd3c022d9609a2832e6154fa7ca65ba987c93e906751919bd3c6b21372e29daedd169a61a5f6deeb177a1724cdc753abf554e5b401a6d3a5401d92dbac551205b57a9231a4a8d7a06c969f7a81e72da2d3c0ca5d237ca92fc1b840d1a9953b2e0e154ac6ebd33ae62c9a6d34fc4af07cc8f61cfb47141ed573f309b6489e5ea513eab624d6a89bf1f9a8b87848384de1b9fb15847a9d49cd4033e98bffb6282d442f7cc0507e2d50f92ec6680f1d18bdac442ffcd25c4e5e57823e325eaef1a67c3dd7191ac2be8c59dea5c2e3e8ab912fc222d0d18dea591e451192b4e7f693c0fb728b4d31d248ee1a69b1190e7367251c2fc6f75f84324bd0d139e92dbedcb9ba4bf9de14c9af2ce55753b772c518b6cfb09959c9269cbc37d1bdbc6634a3dd5fcc068e9c94a37e0c42c0c7e6ace277e4289d554bc10fae387b92d6f0a83bb1bc773d9179a4f9c39b848f0a7ff00e87c68d43f849f0826a74aa80c596363ba7fdf2487941c46d2a21f35056369bcc23bca2cff117b35bc6cd14e314bb764639f768630a7110a7324c0aa137dbc32584ff502ab465517943108f0a49f060026584f26907ac3db10e52b7b277efe134ef32b16ce8565931634b3c9ea02fb045ba1c7a45e16f7c1fc53069a47b370e36910e948624f7ae88878f8f839f7f4f107880dafe9f062b93f634178f6b22f44a2acb73061634dd0fb4bbd41d12174d4c48e31af5cdad7d7a8f9944fef7a9afe1479166f6a70ba80976f476661c2a74b27981995860a4497da96a1e16bad6c64a40c97e33cb2e26a9873ddfa8a3c3cd418e58c645fc09471f827d2cfba920d1740b0c671e4a7f927645517e599dba0104a68466d3d5483eddc76f55864090fc4d05740edd5c18fa08747a4f50ee36f1af0aaeb68a7a0e3a9ca9493a7f554e01f8f8db70288cc2216884f940df3867ebd94e12a0f309e10f5cac1fffb9dd45363e2ca7ada79d0ff07e16fefdd1703bc38edb83b97b4e22f26c4cc3e290d7256142942b173617c98ff72e08eb7b006448d7893e3183c3b4552982343b98afbccb1ef39faa53d745e78d0d630752e5ce561c9ba64d5451afdf08f16373cfa04ab81b2ab8647420893be07b84ab12d6d3028b5144a8cefc6120d18554bf4fa908a9d003b5f86d589debe2195ea4770e01ce7e2a242f416d35daee4b308c1b4ee6b10ad6310eb94433573c2ed736f8547ebd531501d496014d54acdd2b0f45184b7ee0afdf58c78209dffc1f586d3addf643c067016be63680df16258689fc7a2c012f8f2663d6f4527a5e37fe7965e837361b9791dd3206d57b17c209ade3bbc6b64a861fd6d6b5853ca530ed0854f5adae6869120bc319679a92e1c76b941955e00a7f7b46fac4dc6759c01df1d55e159b34bc5e1b2705340975e1e9d1ed1a673e5ccaadb2e15606fa17d95edf7f0c6e2311dbf3727c836c8f252bbdea51fe665e81b3d79198bf3d499e83c49d8f4e73f1b759d6e8c71626bf4cd4215cd3fb77736d635806ba1a159cf4fe2c0fb056bda79704cbac2b5a8dd132f58632e1467bf4b7dea4ee223be22e1fb4e125da478e6cea447b0886025a96d56d5e91e04d100a36ec45808453cf7ee156ba5e522c5f887dc9ac4454b529904913a404ac9952ddc926e8e940f9af671dcad1ee5fae220720dcddef7b150a4cf9e41071ecadb1b0cbc1cdb136b12b840b40af0e19af3fcd21f8b8086969abb5221f9e95e078ab760c20a277e862a22ea6c0d60c9dba793e0f8996e8bd6f8319a64a2bfd5371bcba05cec8bdfcf5e558167195496c6411d96c1d88240e51811c2df5cfd80694d15185cdd7aa141c9326f0fb023b84501c25f848148291db8f5096fd6cdac0624f86f156b82e4fb6b46c691bbf1cce3239d2a2636d297e715bacca92e18c6d764b0ab4d3f8a386d0e5ed3a325a6d3d597f2b8daf15ef9967767a1536f031b83953e7394260611e622d1c2f8bedce3e9786a7c8706a7179acc3d1cb5528bf4ca279fd9476298c1e96e13d7c93b27073e944226017821fb27765980e6243fc70736b06c51e4a4a82b9f84e3be6dbe16a140d42a5b75e1698009c25b1d423da375c80780a6420d85af0d77ec4974c57b0a3e54721579ab59796c66051e70ae8d316c9d0acb24d82d71f7d07f08217d144950f15d433e0be0b82bf3ba4711e84c6eefb42ca8bafa2c163fbfea9da26ba04d976eba25341daa35e17b0263cd4312c1f2e071369570a5e644463281761a297ba4c6aa59e74168699e0ab4784afa69841bc5be08799593f9fafc45ade317b9686772228cd9996ad0f328442bc39ad9a237c8c83ca389bc242c8d7b882cd3b8756b763a2ebd9c8e3da1a819e1a0fa1e85682c6cfea613dcb5425bf8f9a1afb4481515f63740c8042081267857a12ed0cb9e9010544430447b1a4b71706e2fb016890e688a207f94f9bc6da4ae8421e46870c868c1fc1b1c40bd82513eea730e96c8839e3642f3b0555ac4a8640d147d27e588d3fa90d4076dab1d61d184f1ed9e11429124a5e189bd092d7b2721704b03d9af7e90b50767c332197d0d95b9fc0a08a798bdfb567d741414cccbde8a7856f0a8133ab3c98290a5f42a3aab8ded01eae9f8ab77433ced72129391ed3b7f73623f3048e6cb9e499792bf343d5c48397ab92eecbf25950c91a5bad70558671d77a860beb8b40f2e2804189d2d11f2194952287db87478928975dc1c9508ce75cd774f8779b02e764688cc271453171a31edbe29aaab519455bfaa1e71ab933167139b33c600c6ae81e2cb0646b0c0f3382ba085a4adfd270eb799b4da842e834cd7f3dd492e9afc7beeeacd5d9cad634717e8a70481eb217fb0964f7b2ee768729a35f5e8c53369e87e1ed4b663fbd6271b9c71b0e191e150d9a404ced8a0a604b675986504fdf8feaecdc12e8cf64376f1492d553973db8145c84f63b4faa2c27bf148994b5b326891197bd8829193b007bd9af1da31af7794f1bdb3dc8fbf23736f150196e4a8518d7b4d6769688e6dab6936d95dc10b0ea8145836ec5a7476aea64f6505d5b349c9772f487d135c556ad13c6fe6e93b6ef8aeb5c348a35e9369bedaf230c3f573764cf852b252e5df6e671a5bc9099eaff659e7958a8dec8dc5bef09d3c6ad2f899e9c14367f03d8e0402c1e72de04046ed00515127f83dc45dfbef4456adb0b5047b39ff3e8d47235b2fc587ef6cda5361b020ea081ad95aaf7d9e96077352e15d80b50227779c5a9ba5ca07defd3de6b7e6d965cb704c6afe4dd9a0a176b946823b3a5a0d2ec3c32ea9eb9bc72eb7c84fa0a0ebb2af419f8f083f092d516af1fc4fead2a8952a7566904eb6b24ee423c58f57fa95067a90bb14b14a18e3199b87a304744b09355d267367d74200f8ac1eda01252cd5a9aaf48ba1d8724a65494f8bd5480df73ea736815b3614096598489bd1501407712f559d30f168c204644fb1e5da55e51f17f52fd3811121009a7933afaf4cdf5ddd80380754e61436e2f785925a7cdfd3423330c1fee36d75720167929f20b062223eeeb8c1245384f48efeaecd6d9bbe6ff4b5410e988d4f40f66ea3657e3b6193912ca450276d939a4ddc5ac9031bfff2f36f977495424980e3f171a4701e31f48a73948025ff2f436e9c96881544e763a078431892584b627c166da5734542fc034bea1b20cec99eeddaa6a67c7e96cb236a495a0aafe19a9ab0f701d720d34559252d81eaba6c5f456403ec7c2a63b15a653b93d6feb5124c5a5ee7acad6e8f310a52cd414a21dbdf45d71cad54579de8f14959b200b25b7921f0374c08b5df1b00cc263efae447c52cb6c2204b92b877132d28f6052f8752e7ff4854eb010500fa779c5af74561ab8ffe30df47ccefe25a1394930e89de6ffc2a4bb24fba6ba31894c24998e49bb91dcc76b8f6868d5e83d6285142d34e0847d1040c0a2a9a6dd766eebaebe5bdfc3052dda9371a1be68bcf25283bb48ac649a01e01edc6951ce4e839dc66d1d30abc36217f7ebd34f673d8ad46d94e17c979e949ab6355e2923e9620d53d2eab1f005a1dc14ce1e9015d77df484314c0291042d99bdf52ea59eb8d37702d0b38b5040ecb57a421e54ae388c5f9b51565e8d7c8b4f707b8e4e78cc4473f9c784b500df74c160059464b4fe2a43224f20617d7a76878fb2a9d27f5bbfe3cdba84beb12048d6f601bc0a2045b6906c55eb59a4f35536219f35ab6ee0545433e24bb1cd2056e9f67b46433dd3201b58c161fc84d33ff4e8270a12ed5ca64188c75dfcc975f845f9a058a9c5139098dfe7cae880522e58b5210bc074d97ba0edf5bcc0ed26f8ba0b8df22c4ca42146be9f746daf7ab95a1e8143b90140826170368869f534a522872766e0e1c34b32fd899ef1ac8066ac67b48731b1148b7ccc098489ba82bb31c23d7861783d050b68785b61d8acad88099cf93686f34cc5c53f1d996cc93ebe1723df7187420dbb2899bf1d84346ad416472f1ae3b9672f47f7f7e2d1df054febbdff0f13a37a76e2fb3a9b44c5a9ad93cbdfe2f9f712926149f561d57d097ca8ad3dd2bfd290fbb3a89c695060d283312d1f22a8ce0b20e09e0d3fb7fdd5b03090b317fbf9f7ca6feba1db156ac4e8cf081171886ab9f0174443c8b2e05767a80371c533d61f23b8d89dd863267259e2f409f9fd9c95225a92ed77af59420293eaf87a4f8208a8c7d54af5047dde48bc11b758b9708adc2353bb5a07f0a4029f9dc928714febd80d5e706b465eabfdfdc42bb517a7f45d343b4d36ff891874e894549c95c663f5ba8e7a8c1542952ed82fd7767b90df79c7212409d43732ab1d4df74caac8e9f6406ea22665a2c21ae895424bc42ba2b1e54280e4f7d248eb7f636b9716720882db785e270199e406282eb0cb8f4642aac3b4d32b62372f2a26eaa3504ff45c8712e6eba7e42674660e86419435872c08fe5478fc513d8b5cbd8b8c9156cc07a29811e318550c594a4a5cabba5935fc65c82814ba89276fbbc723ea6612869bfa9007cc223c53b2bfde657a9aa1a9670fd1b7ecdfb47d42cdcaffc65b69d5505eb848bdfd4c53f5d945f53e8134a11221c8482506a98712ab3b89c26629747a17f75d3ba024e39de7fe2c65be669a1b48443e9bf63f20f1148ae861b6a90de77304e0ba2fd7d72596d8a35d42d4b707eed43a62c261db3442300d1a41f957c1ead5bd570ea407dd1ad57bf1e006577c09891b7e26910d1b544128b4513be1d42cd082ef58df2223f76dbdac6e71edb9472c960eefd0b19938ef6585cdee5380b0ec3c383bdbfffd5a846adc0fba0caebfd67ef090510fc524392e24dec6006d307201edb108e9d74c68403cc75cc246b9d7f5e7e73d1e12bc8bde595fb555c989812a15c66143915c9f678f299c687d40b26417d7abc983da48d61515433ac303f0beb51d94b79358fe0a69014a4f2b176724eeda01a1c5ae821f6749600ab95dbd5e85558eff2d5b37647bd8c334ad7290187b069ec7d41249646984c78bc51a9e65abc90eaec07da52dd18b8f219095c3f0140fd38f216617d0ace52b32e8cec443e77cdedb11867242fcc02822ea16741eed2d336d4f2c7acf5bdac09972f755537012dcfaa918c052a30e628abe644aef9463eec30a1c963c3150f2ac97297d4fd78b89e3579d8762cea6b89144ca60bfce2f775df069516ae0fb0307c186f59115877736b560fd9c215299a47a1dcd117ca89ab14a911abaea247e00672a311a9188d1f326282463f37e15fa4058d7b8410c9fb1108ea3f4d9a4c6671ce67f781f5ce3fd56a1d5633cdad55abcd6ab7416a57592ce5c131556212b2a3778278919d84067bdc7cb0faca36db7a3dd77401318a9fd6b245f57d773b082491c10f0c6da88d4375214611caa708acc680a320d3a4ea7f3341098e1d5d8c17e17a1366c4c5ac891c65bc3f3b3169741d86537f723f5dc7eb622c4785551c6a05e4cd0cbc4ac59755c45d26ca35e9470df602bd6fd8d8a2e3c3b21668e0a496185162486721ecdd39fdbd9a595bfc6077627c9f7ee5c65aa5ad96571879fd61154fc9b6e9bd63a17272727f9f86b78898713d49984c89dae99296300f7ecc5f89fe09f3f6cb22ac9032738d2ceedabbb668e0cc05bfc9ebfc679ddc2120606603353423acd194754c350f3df070c41d089517d622f8e375cd982e72f32352712da079012911175c31f7577dfbb800799287bcabf438da05013436a07d16900d37edca49f0bd801c308ab50eb2c9f0e7024daea626b2d765633844b5e5b3f4af13d5b3b6caa3c70a5af6c273dcc051fcb9a520007fdc95b0cfdf756ab8bfc73ac8ef6dc4227697eeeecf3c5d4db4612479fff2e675747e92de96e75ce5af17f81e22f59de7e360fa3f5fee4dcda2e69bd51077c2adc5c14b41e6619e1af8de7fb32e943a822c5176b7210a6d8c90049e3ce96c6f8c0d68f0a162f01c202d9c998477009ef86801f3f0f63d49d9b759cd8e7af04a9077c072797906fc5a0bf38d677a4948fdf446d5195bb77c9d01a08dd75667f8cca2bd2c303379bc1a4bd91ea1ea9bfabcbd697809aa957b0b4a08bf3ce7b595bd3f93529b4ab8e646952965b307b2e7339ca189d1d35227b0957a627e4b1807b94edc270b48969a5df03b72bd5880ae231634d2f52c673e0ce151401fd493abc05d25456dbd8cde7bb77701bafd57bdd50c6e87be2426bb50867ff3c5dd12782677854278cb2fa93125165bbaa4b62b9e24485f583c8c48c56b8a298f9275b03ba70ee142cc8f8bf0117d125277160c214c892307ff6f099b0ee594476a6cf7dac373b974b47d645043fe2f4f863b213575fad40f84eddb5dcc5f48b04f5aa69659808f0784639cf1cde7cc2aa053626059567a48aa5843d5880721ce85321fc231b07ac2e13822e4cdbf024e77b4ce048eee2d8a715ee14aeb276b990d6eb837368ad6a3a4738c94fb29ad4bd13fc732c515ea435d90653e882059e0d5ffbe3c500b9f1712ff74596c67b0b0c6451c8850cdc5e6cc8e8e789edc11530b6fd3c4c24391d34aededb271ac5d254e03d2e4f2f0b01d110ca344092e351ca132c870fc2a493cda3b7137c458b81e3599b726f256c851c903449b2fe765e83eb3a23a09fb9dc4c30de1c8f94d5023ff5c91a3146d8b0e4135bfe2e2691e50b3c06f38696542f41e85a0bcb9fad92bb8667fc90dc1ec6ea85718c7d66f99b91d06e4e3b29ddc0bb2d9498153f9ba02295731bb2fe1684d65a15f4759dd0742a0ebe336d3d5e91a8e3859b9839322859e072ac905d0f428f0d0ad418bc6d3c1c5f00cd9ed46e92f78afe13c66b5c2048cbf4646b83142f75ff9278afe8b8629d19d11922697a4d9b95de3340bac6ae64c451b8654433e065615625728c07f0502f94daff5e917faee35a4cd2db1a11df38fb9988081bae495328164df451a05f76767fe77414f03d3f27b71c1d77894994eb47e0e00f249fccd76179a3042cdb95adbef9091dfa8f44094cb013004f34c29999550074a55b8b5be2f48c12a31e2ca8c247eb3b826a04aefd97ecdc33eec7d7522696aad75a1df7b798927a56a99c57223acf264c2489ede9d7ead9c6d6944941e4cdd1d7ca458e199578bbd6b02532e12c2820fc507f1b2405edd6991bbfcc2f73ed05e00fbbb87ce00c157f19e0a9c9f48a0094db0c0cc7f769878549c6786773627d54134e686c6880a56915e4b8c4bccd27e032adfb610695691dbd826ca938e9971daf081a5194e20a3ff1d4bd2f39732537cc53ffb53b8dc2bf14f76bb8dc38143f12dd72d7c44c5e1c7ad8031206a8b2541cae7a5cfeaed6879fd981fb7abeada2993e42295bb0a1198ab4a26885b7f3bd7e78da9badc5211b0b8bbb8e1395647b5dd52c084a6e81e3e7a60ff387078c5bde63829b45a2e923f3c155d6127657f6776d8cf00f6846009674316a01044a2c41b60f11e17355b275f6e28fc0b0bef903471c69247f0840ef3e331406850eccfdd76cb89d5cf08939bb8a190e08d1bef9fdab6dbeddce0bc9801808feefe99651235bda8045e1e626f87cf293401df009adce1e01b2908c2bfce8c44704d96ea64146b74e29941b123bf9ae66260987190dd4a9b51dc1a282f8d85f826e7964386b3c327e62734e025340f9eeae91b8651cb5148dab9393926ec2f51680a054ba7d3f16f1aaa98faaea7ceca538012c018f188a6ffa68895683fef2399709fec89c4f1954babe838d70af6cda4376bb2818b43f0a63c9010f7bff9eb9bdf63de873f101a3894e2487e9febe6007adca3994ab10bbc9ed6c6fede76524f5f87b1852e272439e57de9b5d81a0d2848b07bf9c47e68be32245750e17e8f56575bb418cd076869c37337c992da7109b5f8a70cee68f19038589dca98d06508e01320b953c4a8081f7528700293897efd3cc681507f544d647a30417c3971e282f33337958805b071bd20e2b0c7bae8ff11f11f3208a6bb9b03c86e5d7551832729528a277457f767c346dd43c867418bcef3c5f76a49f764b7a097801406681618c59d46c6d980933e96c6827aa30d9d9fe2cdc8ffc854503ff221d47ee1bbd2550ad7f92cfeb350e8fd8776cd87f395471e580693d63010b6a39eb0f7dd68b129c2d6157bbb29aa2cdc503b6b9fa19ae76aec4bec6496dac0a097adfe8a92f6b4eb02b73de8d0377c247a4db0400e8368fadd941745483a11f7e78e5096083341e6db45ae1dce55d6724e7620c2fe2d5ac7de28b6e451f1850bad66d284d6e8060a1146e5a270a5e94ec0a243c89eaff4d39680eb43ab391c3c78326efbc6c8b3508f2f328b5d7dc2c6d2ba5ce74297d39ed8599055ed07a890745ef2bc39ddd476261fcf5146619ee301fb180e8d2762a87059b71d97529f5fde5a5ea91fa0e745f47e2f61195f71eb78572b7dae7651d6aa6eb02e05f65f49b7aa1c51d3107934a86937ccc6eabb321dc7942c03e7581c4877778c660ae1175540debaff3e037b209eb8edd5a1344a1e8d04e004","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
