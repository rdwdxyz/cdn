<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"febcf556e977bbff47acf5432dce428973c9c1aaeaf9e7c8bb513039f975ffdff65f5cfeb7aa3388a330a8bdd1c2ed5bb5812774ab84c319a9cf0d0e6f2ea9ea28e722478e6f44bd5fa2f1379eb6b50b06eb8eae727762a896aad35630e73fdead025bd47b65f575b867c901da4a7d886cb9cbca0d90055bba1f0fc3c2605af72ea5df342a5c9e68f674d35274c8b79b236366ddd3dfd774ed188e714f591e49060353f08d9ef56b441f562c75d7901fb54b830ffae3292bde48bcfe6bced6f401f565bbee795e1cbfea4e2a2d9014779a51b5fa7c42a5bd153aaa5962c172cc1626c4ee0901066bb24ead31c8f32feec30df874b7ccb4b7c60d9440b4c4a4c796b1833a311407262f1c2f4dc684b280657ea33cad74b3130d5df3dfcdfa3fc7bd0fd77ce6166619c3bcab8d6bba1b607359f5c04a94ffce3baeac1aec959f72af68390b4618d663e80547fec1c7742b781970c441f62b047e18dbc6c9c5fc6321e8ca346a6abb288e249115a245bcb1a705be32d0c7195abd497706fb76bf4cd9a6162451b29fbf1cd6053ce1c64e33f22ee2f0af8b91a5602731fe858d995acf436c4b17d1b325d75600c3f83811500531bd30c053aa6fafffe4e852a791deeb56d783dcfea236ffa1048eca8539b919a47aabafccca2ef10d2395d3df6743425ce26f501fc46e388b0551f09f2349e9fff78216ca6079aea3ccba7dd76ab919a2f491b7915f0ada6e37f5e94320561794fefe0d1d616357ab0ac1e21f0ba5a592ee0c9e701c6a7eb5efb174652824d79f1a9db06a6453661a601f192b51bfb5bbe1b2df460b2ef69f11e785ae1f23d2ad97bde9141f1ae3cdf860b9b796a9a33e2384a2595c37c73937cf35fcc89cbd745ca826922f830308e13758d6c3afcfdf2cf001c6309404afd880b70ee1600b7e133ceef2abedf93a1e34e7e4de72400edd16b9849acca41d684284f162662454d50fd29c77fa81bace0166f6a171adfddcacbed0a0905baf18fbcac11872cc455f1cfcab5275ecd41fe83ac6e2a455b31ddb0afd0622ac0fbeea74426e8196cab4e0c09c75768c399648a937bbd018df6550815c76768694b90eea598e5348b6aec85ac38f17b60d36675649b2beff3d6a58fd99bd6ee524ecf35c322ae2c08664b65f9eb53458269b61af2f34b0dc26ee2d4c86c7705c5e447f27d62fbd3a066b387e99eacd4e9cb4a02721dc9ed4e7bbd1e64364783b04bd2620b0af51e27c3e6ba757eedea0ae101db0b785c0b7ee287de8437dc2f8ee49b76680644457ae117e05fac41990706bf1ab783ab2481f0473a2a125b5b3ca103e556ce927d50e262851d7e97168f77f72d79f84f03de4b5468233a42497f402fd1e421b016492b3c0b4a3256c8866b62d485ff6c36030a40ed54505c3b742ef15817b56e0b4c71e90508305310224c8ffd35ea413ea9eadd0d1f006b0b38c26fe692881cb8649022bbd4d979adf132de21890a348c09f2e1e4e98ef120739c6e674d2ab222a96be25b4efeeac3696b0d5244df6fee7a196c3fcabb67a98b0de7546deba052e46bda0d7c19be05e504ad0124ec331e3442ed51c05f6b484f44c090dbf41ff049bbff864a9bd5366f82ab7275a6249645d9aa466a51b4a6a775b7c74e296b2935d4ce37b1bc9d40a1276353bf1e1c779643382769a64a680ace0e9de313b610a143e484bed734c76ca7545c9828688ff85e3bbd6b7e180bd5f6aaf2a5137bf8346f89672a920a9931dd4fcd1c7bd48c93f2614d781dc16a6cbd0bd5ea988f5230d2786bb4721be49e197f4fd75686de5c452c949f068ef765428c9b2d83332e011eeac3e23b1c5aeec7ce054b0fab53ff307871bc204b87e41016ef17c8bb07b38b49cfe16b77358b31d862127f89b3b00c8466778edb78eb61d2df4c3b943aaf1fa49ca146f4e4d3266ece76a313d60079dc4d1a47e817fa482d803358985a3dd0d819edf7d80b76272b75f22ab673ad4b198c78c41a916b72133a0cc3a79a86a4af68f353ebf03a448ccdd62fa1b3f50947c07eaad2cf7f7c2970226e60f90629e28da59759820712ac4d868969f4995aaf7c143a3ce93558119897e890cd56a06da8d34c6299df5493c12b9b9a28e01e2a1071783b78a01f7d7f8ec4922cfb02b5959ad55a1ce32003a2be34f69fa3fe9ebcbdb8840f8b54830cb48d058a454e997fed4e0a0a091bcc85ed0c10defcef96b5f231927d0f6afd832d4b4c4fdcd04a18acb5a7e8c9b578c211db93f495a4c9b89dafa4c65d63a6144f0428061ac567a63071c56c8ae43dbd257ac0e24f1721fb2ef90c502a19df05eaec6fa5e6c03353676ddbe69b00b71c7bcf947e0718adfec31088e65ea7906c82862f034e33fb97b050f1e56a9133d8c89397d95debfdce63d595422b6dc1fd86af55c70f65611f6d9d422f8d68e88a0dbe513e3e5493314356ee680862f96f17465cf21f3157d9fba6451a13a37b51833e4e342cef2c218d73da79154974aa0b93a5e5f5d588a1be206542e9b1e259735a9dba2a8d5075816862a1c816c259295c2579a93ca4a731dd2f2180aac7c05373be986adfc34416189206046513ddacc57d6d3df18a50c9b55e6a596b7da2e19bf21962fcdab168f9aa4fb649da5e176b7a0fb117ffb0064a85c6416d70036dceadda200d51ae63bc322fe4d1b78d4972359e5fb01fe48a5dedf6ac366bdad5dd093784c9cb9549881425dac6863f0c212ef50e578da654c2eece3b1ba779b612e572e88720ce64a318e584cc76f1aad9c6c8e71240842b8e82e2e7068258beafa4898229a44f2d641be029a867581e9d8ca7d48a84c8da8f513a40a81f69a16b6f3cd3635e69b9825efd9f14b9c52801cbf76a4edd343b3011de6db1723f978db4bccf52bde1df5108434c48f57378857b5a57d1ca74d485b43d09c79aae63dac011b1a2b90c956c1c966c1b052bdd7656ec9d2663ae7d5bbcec891693e762be119f5ccf1a5e7d94cf9a58a6273a5213f470db56105dd3d72be5299048bfc91328687753da40c220098261f9b4fa9c7289e2b5a071199a7b51e0108ad9de4ec686e8164a455d993c5a1800303c075403de9cfa2132f0882cfa73a6aadacb3b7c6748b5fa5db84141b6d1aefbff3e0116d7f299c3b3a5d68e6274a649aade32b70b6362080ba0cfda687788efcaefd4d96320e2950b7964f69e5e7a6433b57f2f7ee712dd993f2b6bf840cd8bcebe2e7de221f5d5d55e48d6bfedb59643980641435b77ed51d2473b5dfc396252b14f0b94999af430ce19ecf119b84e9b2d411ead03d981987756e0044ff717322fcdaa9d5f80837aa87d74ec566a40938046b8210ebf761bf644bd7296231174a174ffe05e445b34febc8fb46dcaa2c287958086fa0eb6f0508c39d9f37f5b8738e1409fa2f7ca1a588c3d26d010afab669f59cd900b3fa766b86b131e55c51fb176bc67b28fad14cc7b59b33e15ad78e097a89dee80b01c57e6b933ef9d1b136534d02cc14c422b33a6981c399387aadf3425c98be6e4cc9867b37d1a37e1e48430a61a35c69b5f9240083bfc5c666f9c49a0c0a814a0d36fc6d95e0d992b903e5bf28b2e503dfda532d027c48e66d22fee64fca11090c01ee183439e5585cf435e5d72b3d4aa77a113f82fbcfbef7da598dc5650627a004d4995aaed6106050e94bde7eecef225d0819277b06d298d8b8e3e7f512e202efa11b0bde1a60f8a90995c3cd8d571c769d19b8cef969d2926eb7b43de5a3ab138c3964cf6185c0d7d47fa2289b0aa7bb087ec718f28a25fe48c42e5a5a5b7596c96ea5889809d4c2c0192faa7061f0ca6b5cff71562aa73f5a7aa6d48f103899fba160013154eb0bcfce9692cb7460ae497b8817af3a2f6543b922c545607d0142a316069a13aa1401e8d95e5f645dc67dceeabc5882b4db4e39d22c58859ed779073cdec121a356aa9aef2d519363887319b6762047de84e13fa45c19b9eb30bf175b7793eb073f05c1b4608c579965be60046bcc868bb333d356913993d346de0115c2878e55394818a8efd4e545956cf48c3d23d8cf966e2ee5b275f1e06f150a70797873f0e896497be971deeed0887df2d452ebaf3a22509f58936eb658069a98b1f892cf4b281a493768fb838a826d6b5f2068218bc4bc979dbc5f2734d2d08aea5c60c251299420b23616c5b1838dfe108e6a08e7a31fba0b1d097dea831f1e5a07f1861dc0c3b61b56de92ba068d1bd5bdf8564c5726050f1a27cc5882592fc6d8ab5826f9eb4ffe156786b3cb54444aa8a72efc8710f633b81ba74fcb026d951959409bb486a72954d9340fe29cb14b6c5c1ccb2c95b275c15632c2e011e9664ab82a38c7a02509dff3c380adf90d6b154355c724a934e64105e475e2b08fcff0b9bf4e039243c48abf858f896bc948a18184403729ebecb3f7a5ee6231fa918377500f598aebf66854c3cb7e282ef584b2096ddcbd8d982f4b22686b0b9607b268fc8c81a41cf712a023bf4f5f2ce50e361076b44452c7625fa7f7c89b362c010c1ec1ab80cf579bd616504332f625fe2bc43f65d9f78da2802154e2cb3506ffe0e4607dd7306c82efa760167ed48ba786324ef3b49d80f0bcb31c9b5a0f79bc222f3df585391c0784bb0f87a9fc642280d48be06c9ac7339cbbc0923721f4f5651e7ddef74797315c8a8f12d882da1fd6fddd8d6fbf5b35a0e124e0e50207c7b6bf90472e6b93965fd39bb1e4ccb32a3e4f49e615c5925c8ed98474bfc5d48a1b54ae5cadd093b35f2f3ea9014b2b2ca5634be509489c15d8af69f2cf6785b7c0071e045a4259ca537c9015ef8bef846e50b366d36eef82182691355097df36d03b703f36a25e2b3caf02d7e9189ba8767868fcda0451bb1eb92da3cbca0541b0a0277c62fe20e2305bbf759e7f029b612f679ab70d714760b05fea8129dfa02c997f767fbe10c4c4eb258f999885b680d4566d9d2a28c5bc6d612e295afe8fa7c53856ff8bed5cb25faeeee7477d299e450f245c919f4c10c71f602cee6a2f81f3d56f80d310766a7b7155045924de507a4f7303297748af4a273a74f9ae5fe57d8d83e59c2bf4b57e6ec244141762bd336ea61d512e8c2ee88eb1f5a877f54c146a7e9f02a36c8e9af1b375ab678ce0de966b0d6539442a6ae0f4210c3217589770365928d6f2b0374795df12cd50315a943d97edcf14f98a49d4e9043f47820da74a887979163bd824a32b41e2a3dc5654a250e7a140eaa6f2ee4086ea443ff0a64b56039581ffe01d843a6e2f48f47281f2a5a776ea568bc075ea21682c4943607f66a9e2da08b29cbe8faf0088b4e244d3ea354b5c952d3813d3b6badd48255608daf62c5a5951c8a4ca685f46754f95f2100de09f4e90c24da99350f52b2cf3039e4e756ebd517c29f5f919c1df71162a2aae98a53fc2d5c70b5260896d95476110f3d8729416394aa7e76eb1b4b7ad8aa347f393740f57ddd56853c0fe5389632f0601a9427b49bc1ec2c3ee796ff5735a2366b55be80d83b8f9a29f5189863645dbb80de6df148460a63c0f5082158e294dbf5a8b3869240d097656d7523462123a631aac590600b8817237727d6aa219b21697771bd19145e97d146d849625b80eba34ccb99be963ac11eef0788d449524873db42effe15e4f342d3ab4cc79e6a6f09d518c1bcab7b9a3e1cc0d94968acb6a24a162e9151d38566362213692b5deb49db168e5b4f5418e1199c89b4651ee564a1e12ec11e78a4628d53969c16788fca52ad1ce5e167dbbd9236052d3ed82ec636da734b03b2b36b2dc98a58c4dba20c873722e9d498a86e7121cf1382ea93e5267206b1e179cb398837ac87e4ba4634e17301d39ecdd9ac7abfcf55161f321bf2c59154e31de8d0720316df7109b6d91c8f20fcf7f518382582c62163198535df308328243ff0a64bbae086e5343c0676424b3e4d6a69f1981b97e8bb62827836ae373743ae2634d2f5eefacc0ddf6fdd211181f18481c0e64eb48064673f1bd763483ea50e725b1dea1fa68645a1707ebca2ff8c2e713c3ef33d2091973ef161211ce6a0b30d719a8bb2b8ee671031229a903ccc912f81472ebbe941273e148f8113512e42b835e191df1f931aa28c6824609f60d376023a78acf93da2ff01e1f31a31976eca491ea67caaaea444e60611d526a693c527823c9dbc88d3465bc84a3564b9469742ed59d9232613d5fd120360089f22207179acd13e6baf0ec98ed18acb98f5b667fec728522ed9b3f77776c5952ba0120b43fbfc9c2291a48aa08e33aa040d27ca50281056e513e9aaf39568a584376085bef62b5664cc1f2e6c769f4ae2ee029bb29b6f15da450d94e064c1f9eb68c5ca2b3f6232a817dfb33804c00cc7a59f23d53655995b7dab361a66bcd4dcd35ed8b462207955878e15154671984530c6f856c86e0385a08cdb4aafe3ffb6725b1fe1bd956d78990fc0c26df56a1abac864434d3ceac1c3847c756bc927951809f8725c661d7ed45f7fdb5b6f86d3bec190150b125a71fea65acda40960490e71b0c0fd8b34f39a5f6a6b5d77d4d86c0b6eb82a230936a1255e5dae1ce9a4234ceb093e43977ea4cd4ae9452326991b7f9e2e7e80c5d5e2e8f2827fea2f6143d81446b4e8afc57375e291bb93a13ffe0d81194ed50d6b3e0a5118e09f9e77988ca9fc74062c9a57068d81e3ac4f89d522138df4a87d43e53dff203653fa22e2c1156870e8dca8435a018d77849e8b294e06106c34bd77d9dcda55bae68c45a89a079bed9995017e30288e12ed4a4f5d53488ef4fcb2f48830d4a2410070a86e0de402bfeb9e48762fae6fed2e2ba809738a42eb9440eb5988b40e977f6b608f093d15a07a2a342f1ab332fec827cb96cf4eeb6eeff51f8fa3d4a35001dfb8781314c495e00041c80eab526b0ae50f7fb4e696a1f5a6d21a916d36f1ab0a49cec91fc13041c88fc99b4a3a60643198f41855e6e52f20ec295d84fdf4a5935ef6d3ee8b8d1d82b3b87343c7a4a489c5a91e5f07062da3b98c10cf55023f5164ee51d09d2f8a2c6f8b10f49c9d3f6619021a242b786eb3104ca07c23e05d4da642c8d65283b6b2c1b77bdb60ca59c3e5b298c2a923b5c2f3a6628115afa74d7cec89dad8b82f104467ae23faee7a7182e82d7f143ab1dd10416a75de3ca14a949c5eb57fe6d8a391c8e97e69bc3639c3a58d41cb23c41ae88a7434a8704aed86709c921ff1607db2bd427b363b5312288de523fa7edf828c529481d64b0590818a1f3c00dea84645d583ea37b07ebe83eadf4fe73034a2b884b132cbff81b647f3456c3dd5df59547bbd9c1681741a7214746f02016719e75285adaf34733b9e68e2ac75b28e5cd294f22804576ef9b37eefa1674433427626f3a2c1100f44d94cc21aa9aa7ee2c15d22218a312859726f4a151bb9f2401b05c7051b8c004269bfa39f52d377a4dac4174bfb87cd0e4a819481f1e318eb1f1babe4af22fab43e36aaac45e5396f7b1e9392792d32b9ce89abddab13553bbbb73cc8c74a90c5576a6c03e5b9f8ec75bc5f7fec3bde60729c8fd91544d924f3b5ad781957738256b9ef54c85d16e2e95fc69c84de571d9ed5fbc7111a3250c235d87cc4ab8d8f95c5474f80e2cf0e67b67086ebd0ae59966d061e0da7127357a56ebe41c7870d05516914ca0d90822286b7ed4545027655434de1d72ba3d7742b322d27e40c430dd25d8245078d02e18b1e9646f5e7651c341a1b26e1222635c0d7ede385ef15d0a51fecc7404a6e73c02529447c20abbb56f0f475adbe38d368d4cc156ab2a353c7c26a3ff7c09ec486be4efb65aaafa93113634ddfb058f28113b5375d048cb2307b7dc6b0df6cd20c6019ffff7529c3f7910cb7daa0f062412f68f7fd19b8e9b26493781fd4bfc37acebd51871dddf9736fe3c9202799aba4fc936756c2feae1408ce1ffb059b389c57b690531b07363c139fd499b5f0797454f159600ae29995779e756ddda2c832a0b7345c1e4c5873bbbc14254de828c137d232411dca3718b7f1ae02ae451f1ee5e8741f830696537048cd8cfd0554ff0a1209f7117582b620efb2e071565a567768b4846087ea461acb0e67879f654e17f4b76ad43b4ede08bc3881165ba78f843009b944aa65d490d88e12988977c2f8d91893e2114c54ee84994e6078d6b9e230310d9f8962bf6e0d63187c45ee14deadbc9357845e8415328bcdfde2a59371c1220f0083e7e935c411a0583f59b6d24a50b37617549349a5c319179f9d72392d1f7636356dc316a9eeddf466e2b782f7ab5a1e0ded48d7e6f230d9b79144302e98bfcad04095fdc2e3b8e556a843702e2d1cfeafe722e3b4e69d63a444f25b503e91c55d3b2aef2212925360049656a9c9e568f52ab85a0bfdda449dc81c52d48f449289981f3745df8fb50dc54a2fff1424d22be5346f7d6c156e8d876fb38f94c5c937dcca0770e124b9d3dc9c79fead4e629ea7fc91cd05bbf82d18d5f02bd77d0778af2c6d5cfe30b087a267ff2a50289c920af9735816c87837cf972cfe772624a57c31239d94876484431e834adbe8ceb090e6de4de3dc5f31d0639d1063b7a95037e40ea3e55024d3cbf2b4dca1b59ac5af72f28994f8f9d5186460d3bfa0067fe371315d71a7f2bea02e9239fa14b1d90db3e66e2cf2f3aa2c8663274efe0d4878faa846fd9826457742e11b0e109797373a83b8d7200fd24e5de74f2963ff6873fc0a239d256ead40b66f40102359e4387e7a57aa30cde95cc71605539df7032f493c6b83ee1991d489eeda82a739fb5bf8bf53fcb0c18a9fb07548528f583e1036cd7916141455e03b226ac740473db35edb0e5a247c4abc39514f22e63bd645e60d13c83cf1d22e80cbf826012465f3406538d4b6001bb29e457b7162d406696992e946798831fa9df6a075d69152b084120a84461b00b0f2f1cb9c9ae7b23c7512101489cdcb78f8d30028a60124f72dbd8069659690050e06edfd212d185c7e8142c17fc2efc17652a332ed5e8f43ec583c8431f682d955ea194132981de1630c70beee41e49d3c26e635296b5c005de12113d3879d9f4a39d139a9f95114d5531e1f9d1177aae199e21c60ea1af40992f054aae129a44688c9e7de2368eb8723706141f785dc16add4349577a4c926366251b8953b1b9c856f2b9b41b507c9bd869abce3f1a4e2ceb672ac8f9a17528687beab406df7bd9f46a6b17a3f575bf3326a982b44261989c6861d764af98abd256ad287219bde5e6c086f2a2f2237bb49ffda51ac63c783507b1f3e01c736be380a93d6d402ab41b2c43aa2b834a6bbb25f142ca5cdae230af1bffcb33dff202f30473f74be1efb75f16a313381bf807e808da24476985ebd7400c3ae52512eb45afc3dc43d7b616f51ca4fb3e6291f0abaf7a24d12f71910286969aa521a359f4c41d2ebada00bd42862595653de361b25af530d916d1e7dac73beb7baefce56c468687a0a4d5be679d68e53265361afafb910dcb6ff63db815b7d7aa17a3a97c24d682553a9ffe3945d41ecbad034c0347c2efc586877d34fa6ef53458f26f96e489afcd08e04f790d894ca53cfbafe0ea006964229ded47b9657628b9dded6c0938c8bcd0fdb02680886e6ca1fffdb65cc52e982c4626b1497b6eb06786dbd00661126c6c6f623f07bd35391f48acba9b031f8cf35a83b77db5164d3fb8d33e3223a9644ddae027db605a78513250d5ad73e59d945f1b8d8c470e4caedd26a2f136f1a94933d799c33962b670c9e42e8da0332947f22cd67ab2c47a19d05f96e12a5bcbe0a455ba814c6cc901b7448e2f114d9abde2cb35fdd2a01ca556f7f5e89e21d16d2a7c6893abd49d07f75ea25fbdb2d10030bd4b72f33255759fff018f1a35122ad19c8f8cbc5fae3e64c4caef0e3ad875785ef854a46def3da5bc399d29640da800870f4dd396a137dbe64ee85c4e40ca5560c67dd05f52e24061fa0b030ec98f5a57f79e4129ed6ced451ba3013ebf63a364af8171f9c6e96584dde92bddb221d4158610b50cb05a3c7126904d54b60030d109ccf45f8f0ad41ffc701809029289d3d7eef5c0c34a04de5ff729575c3e0a420c8aff7ce20e4f5b51ac1c602e8bf1132920e3ac5bea5e30ff7e2456b8e377dfeeddd41afef91e17cb3a809cc969d7c1c727d316a537ba58989b5dd442e4af7f1301bdbbaea43a2adc9b5ea9d4cf5c9e07efaf46c5216c5a53a47bf89367c101f951ad8c6f0fd0a2a0ed234c35a7c490a7af5914a4a5b68c65eea980d48810311ad20a078f524ddfe59005158dabe5ba8f9b50d3d2c1a26a436bdcd9ec9fad5051f2fbd770851e0903b09f8d0c49ca271e667fd06387c2b198599388dc816c3c9a71a445b094367ce244b3bbe1687386c8c5d35f99554a9abca0cbc157683b9a6228d70c3742e3269cd630070670dd76f22b251e6daf6f87ec12d01b7c774cbfdfda999d09bd6023f54a75fa910dfb6308977b72adc3c176a2f052fca45d644eb6f9db9dc4bfa7c11bfd877d9946f936e84007f5462838cdfe9fa238c919b21de0cfc6973d54ef2f295540db742daa577dabb9aab9f146c4a5f0568b8b702df03dd107ad755b015fd3c10633021cde0c934adb3128ffc22ad7e5cdd3195b88b3e3d009c5a720c20420d713fa88c7f1bcad4622b6b3f8fcfbcea931a1be14cd7039716623b296bc2ea8d1203a73928069c89f19b4910f81d60d375c1ae9dee4bec9937209371b80c1d6eab799bb3a64e8d8eec6aaa81a6e2ad4a1fead487fa022be6b542791f0978ddfc04c0a24b0c9bc2ce18ddae836d0335357cca045a55e8abaa127951a6795e1270599201a9e7843bc30dda5f4aeb5fe645ba3373a699f77b1f4386e1e64c675863230a48b43fc2f9c206429fb0dfc5f7e06f23e1edbcde24dff1cd7113f60f9c4deabb84e24dc623b22b78fe827ca906d1ea9eaf3ed6537721d3c5691655ce08dca3249fbe64ec4f7eae06f47cc1e038baea118ef91e617bf50b057738184b091e8c0975aa5dbe3eba80dd895b50c81bb0256ec488c0327689ac5fcf9c18948f9152a189036dd108a39628d65e7c825b70bd58996ae59cf98b5605c718bc3645eff2357e28c1bf442c5fd171de636ed362ecff4f751e946d9564fe8bad9eb7ba248074605194115e2ee7077a1dbbe06db55e0a1c24be1c17faee68befae080a83729e1269e6b6911c9fc1a7cee7f114fdcee570a5406c8353f6bb7f0ca9bb8f4430a5d75421771ccf5f1721b44154cc0c7c0b7573be99bd1125c2c298e886d7cea2925f69ee70d0bf10dc5064a6fa22465e82872ba385e7ed96eb7e519ea0dc4ab18761c57c1a7a6234625f36c7ca73d876ac1e79cc9a7cf627a388513870495e8bffe1f372e0f68e5ac91f50e7de9d35a65f348477f5e7144081a3a7b28f065171912f68f0f8bad90cddd5661f0a58caa4c5d861ba8a5e11ab95eea4f20f5d73702872e2878cea17fbe929e5997f47f0286f4433f358c43f3007f0a5e7842f69a802a58fc484b7d36c852a7eb70838e326f6cabf9ab1be76484c0459b45e984850580ebf5606bafaaa637a4549dddbf42341ff63c9fdf3a27f42f82ede1dc62819a9a20f74131c8ffed1b5db6936f4831dddd87db7dd3bb41915562235981fddeea4db66a9c2d90c66898320f5d26bea47c083835a7fbaaa85882f1c61d4b97a1df69a5bc36f4d712a3aa2ae0247e4112c670bba5e1c0c82dc4110b11684a071b33a495c1547d8d6a32c187dd3b5c85f036bd15aecf17725e7cc44021ff6659ca261720b01c5cb23d0312a1884b7ec9400789cf57d7773b85272dc3eb64c018dd68668d9c0451bf4e679e1c5afdb2dd359ddf954f417f56daa75f726db82be5e987ffc2c303d7b8d535f500aeb9c9b3cdda05a6267ed8e51a274fad961e119b2988feef8eb71b2aa5900fc91b7478b1adfbb49e2db857ec51d2ef9d65e380ba5a048933fad6b5a9982f974b34b552fc39947c8e393f3451088ada16c2dd8cf1607b998d8128edf96e345927ea0b41652721b89c773cf1e1f828d21bbea85a6ccac1b6a98a0cbb8df54be979f9c9c6d972917934ea042e83107d17642de2b28ace415dbde3de725926906a3f9e0687e48956b190028732fd520ed863ab7fbc7e9452f5941af1352bf2bbb061f402c197050adfd42e17aa3184b40cda481ea88793078fab4622215acc8bb120f51a4789a9f6e1554f3afc8cc37e9e3b4c351db96649c72c9cc394e59392be64ad9d9125c5a589600937adb689e2f61620461cc4f1487a31e3648ea62244b12f95122db59ccb08ab15129e2a2675e42b91f9e9b38c3672624380cd0acf419b5947e13941884ea6f0dd80c5b1a3763c10f82c1643c14eff80998e3cf9bab90d55d86d2612307fc5f773b497c6c2bec926886c74c732311768c99f34a53e0b89debab1009ea87e81332d71cacf23cdb872ae4253420fa6060aadf6e0ee1314abf2b26a42cae3dd3d07d55237fba5db36bf185b2d6a55a82946660351e01ccff35480de0036cb6e3cbc47f8523e8695a2d81a7c4a69aec4f393d8e47ccd8ffac179f08fdf9ca0afa591ac7c5ee92eaf2e3228ad3dacec363c2cf13e9066283b04a91e85bb618918ab22e6ce94f612d8612d3619c1c46bff84cca7df823c22b7b4474de0acc9cc263e177f1b98de49a8fe3095ef2a4fb4162e73aafbb7e86f70042026e023475fed46984c7845168c1eba2b208046cb868cc9e1addb3ffe036bba09636d5f59b8d3e90913721c62c27f519bd8c772d3d72dfecffb45ef6b10bcf1b91c837af2769324082e3d79d012a257cbca41b7eaa6602c1ce81871e3e9b4c4cd839a55103e39b7e71383983495a5873447c8043358710543888721ca70801b6eb4eeb7b5eff88d791b70143a8dfa806c43671d27beb039151d28a16cc14ce4fc679d8613ca7d7520038c542ee643bf595096cde41f3280bd67272e9e22342d5d623ff5645d44be22fe6960799fe7090e3af61cad8982b345a80cc19b76c13c928609a206db01fbc3110398e264ebac5ca192da2ca3b8238e7a484953acbf3333d6e5be3a8516f068bafbaf1f13a6ee19bfa664c3c6744fe0484a2de430065cf21312699914dcb65d11d8dac5a1a1b7822b55f752e6b6684ca28a224cf2987c9b5ccf2997584f4fb5c4e4fe17139aa77541fb96ff94745f4ecd1d67c0faff2536f58a8cca4086cd408a979add69c66103b72589fecce8d91f80ab165151b60009142ca135fd3a4cacd1f1da49aecf0bf4811c3afd41fadb0cb482559326c46e029c07c11f2ef0b3103a5fa5739af43436cea3fa0fc064d9161e1238a7aa4ea1ed67a5ba00afbcc73711d9af62e1679de478f6b49050228c8e518fec9983778d3999663fac017be5539340b23ac64727a3e231faeaaf2a9f5b2a53e1580346f7305d454dcbf6f77adf4dde8a887ceca34ac30b7a96dd2979f0b7cc1bb5d99cd7ce9b1e9ad62adf2c541745685e058b18e8d5917fb1eb9461af57c0d6fe94a2471badb202a695e7a501f179b67bdc228e2629d96b33a6cee4329df3b90a32a25a8c44cc38053717930afa34901dadc1b846d440c59f71e76752c7f2f1fa8b72b66c6a269621ee29694761fe8a1beeaab4b0be80e19b57accd7f1040f35e875f49c622ebc34658c1b304defc8517a230daeadc58640a73a76d6e4e5c364dbeba50879d3c1fe1b088e84794ff81fa2e8596e16b7f08cb783cb75d19c8d3cb218fe9cb3585612c8693946acee0ff375e9938a3676fd670d3796f5bfff9be3f493efb2a79bb770ebb8fec818598e5a9a01baf034d4f31dc1db982e67f51efad6ba552b952626951109612023874bf8c5ddfa5f9dfaadae9a3d402331f8175b2a780d55ef47ed4dbbd65fcad668d6f12236c6a7394c888515727e6f87c54760e766d2891896c0142009c69e38e6b29bc8f00edc01c85f26354f3b2b02653540bf1c565faa666337fc6973fa906a8347d7ff285c7ed6dd4272a7de9e74c51742c48b2fb412d40e3ed4fbe1e5f2037ae045e2546baee60cb97418f765f1ce6ac20a5363b9661c9d14dd8bb66340d35a05f9be1a092d72134e2bf7257e6990d241a4ae000fea40233c220d446f7be774cb5f5c5a7bd950fba81512cf8a526fccb7ac3a22df380ae1efc5ac74f3f8ec5e6b0969af655e6f193d7661d50e7e7707ed9b4cf84037202afd59031857d32ef3630e3a2231b9860b6cc6782c2f69a0e1de84c160331f74b18231255efe4fc01a87d923390c6c625803ba08f682a737994188cec1c9e1bb0bbc857c0a24d5984ee1db9a29759f212589ee9e372e1fb1123fdd708c40826d91d08280195c967196827566ea4b1232ea67d0a25afbf6714aab319c78d81077fe38a7931a677365ba78b0d4696518ad12af8374991a35a400d8a43b14542208819bad7127fa86b08db96ca9dd6d936b38889c6bcf4f3475d558d35a09f4d20372114b4efb7d94737fca2262d06b96b0dd58a47497f2afb0d485c981cbdb13ed5f7e38cae254f15cb70a8ea29b0efc78df00ab98e1f606ffd811a85fdb0404b2ca8fd09d21fa4a6984ac9c86d9e2c06d8879b408abf9ee87ef23b829c228df91029f5cf7e6fc0a46ba2ffcf0d4b24887ff5134d21211c15e6069ad5cb33e82316361ac4f3f178c0633d74aeeb7b6552422a2d09b1cd9c813c8d8432abd3d1edd8883fbbdc190f7d50ae51c6dd42a59a77d9d2845b5c6a89305fb87114b0688d322a37a707dc479e0d954db2d0d2772ca1eed9c24faf1af777501d822237998aa89eb675d1fe2b687084b8395acbb4e19719b5751efcaba23a57263c852a083346c0a5c44c7c82a5da00e7f82f4c773a6c2edf5af7bbbf8f99db259f74bcfe3f73a5e7c33a1508efe6eec039b3b369c83d0ec093b703e29d213222c78fb0451c129dc33f35a916dcab216d2648ec521793a123f60b2cf42a5efe0a39cdb9008ff300fcd206b52db096bd2052b6b2f0c7464140bef5bd5ddb8714fc9ee45e846cd07df5f4b662c848484b3949789e75b09244a7c0288e4b93af2d9c44e26840a02e633bda2b6e6f8ae1feaf156ad77c13ccc4681ff9781a920a76a8d22f3207e114454c8124317b63d44e15b35afb5e750031a2e47b08e8ce08c976386ec0d8d20a3e57121347d69ae7c67c2a4be0182dbcf0522bf96734f6fd7f2f47cc451323c92e7e934883b8de8ea7924fe8503ff7d0d0d09d4be082d298f20bca9091e2f7d01aeb62aedfa18ce4fac203635102d9c5ed0fae7697b7b6e82a0f783650bf858346a2d507d7230abc4626f3ee7d04c61e5c5a2a587f86665c1777a96fb4731f65755098d0c575f66a4f576a7fe336f6f25643006a56e0ed1f12c03e6e6b2b2f74b08da2c77853ec084371e99a28eb23b47528e241772eb92cb4bdcd9206e257097381165f6da29b9a2cdc9f155a72734b0272411fc7441baa7220dc1933b045e8e58e006c4a9d053727085286871b2e013d66e13e004b4ee5889e26685c64f0ada7e6abfeca24bcec15e64f6923f837ff858ed7db526e3e40318695d6b0fa3f35ef2d7d46c34941c500318332b2d37547b0a48b96fd01e8d7f8d8f7e487c5d9fad4db14a664be67c3974cf81580e37480a9eeebfa70a7357f70c02e59ffb6f8bc616aa04bb95798c6bbc5e0409ae6de3682018c9b0238f6045d30e64d312c7c7bde2d19cf3b28f8dcf28eb71e5eec84925d6c00199850afe97332c597f25dd49ec2fb1802a2da116e4dd0f080993d0cb738d2d8924eeae5de1d3090b4f2d6c7958884c6017c186e328157482cf5df9060296220893680341ac1dd7ebeee7e9c00797e5bcdd3be738fdc4ebe234ede2eb6068ff8a026ca72730bd99fdb2c6516ed0f0572be68fff5e2424a605c71fc3a79f99f9e4d346aef830b90d6cdafeb25711ac698994b75c1b7fdc46535f34ea6b082b97154b9e6f0da8a5208e886f0ae8e4633129eab3ffa67e01555035f482cc10ab2fd6425b2640b088ab2ba273f96775d884ecd8ac2989ccbbfdc9ec17bc1a830e64e29e44fe1ee6d5002a3b924705c41985a7a7c250acf53031960b847f802a080e2ea45914c5ca4b6a4eaf9b04365d9673f26e6d93ebeeb6a023f1b60862f8438bdc99d65262f9c96839d5334d69aace9dce66a4e89e32bfcff48b3b8774aa79e99954d3fddb99897a719bb90ae46924ca5c0cc27b1bbd0c4a2cb67b07a4adfddceed8557e608e85634dc06552b343cdbb3109a7cafca9f6798647f3f10ea180ed76674c3b8daa20e1995497c19438e16dfe88f9aa30ed2a2b2e29255762b3e730620139ed5a745c2c7540a393af17c23078439de64f8efe8bc2b70c4697d24bdfd1f0681076dfeca0bc84ceee865a790d63bbbafa99b3b9470360aad093aaeb8baa79c4860b6df6e8f268f8db0b3941896ce0adf123e8e4dd50f88de4b6bc7cf86e2fff9813c4bf75368f271094522939d76111c9ff87ce281a67a5b9be07f127557b3cbee8a0b059cc9a8be46d43d1c8f6acf6cea820f4f80ff8c29fdebc116a07dc8e32977a320bd4ed9478b63e770065ac58340e0a2d459829b1431e0d62fa98e1b92020bc3f032b07a945298c895d9c596a8052e7d474569e88fa4b3cf262858b027fefad00e2465cd5a3700979e0aaaa6aeee99cca23c411d92618129463aa6fe1567b5c9962fa8acc8bded64a8aafe5d090953b4e4734e42814e6d21c8e6fc88578c33b6dd37a88573d1ae2a80b8241a1efe0c8c88d534ed53117cf4a9e1cc8a4ecb48808100e7f0f040aecc14e0f07f958468998e95081c2c488e2f4c13ab64c10da985ae628c3563f836858761816dde229bf2575657736439d7f65af518adb947530ee5c3a594d73ced1fa9eb8cb354f31fd5a12ed7326ecae623bb82b065f06c0930acf86aa21f83ca44244310694a37a073f3b4dbe65cde960487316afcaebca24737fff80f65d429eb4c0031667f9547321e0e71f1f8a09835ed60fe94aa624776787c45b5a14cf270d4bf90e7be1ed3eef0479be1451ecbe00d8919eb7070c1b4cc15d43caf696a4d0265c07d85bbd110ecfc859c89b92955b3f247549f3ffdcc3d31aa82b7cdfc63909b041e62e2496d4abe3f71eb3baaad6a7ec816dd7b06ed9ef068728f15d4caaa72f32065a0e2e9e7569070309b526bce613225bafcfa59b6aece6182e6f2d06a2f130bf6b8d28b96de6e63b5f396605202790b07549084b16f01ade23d417ecc4930f87324a6184d9c4e03bd000348334b321ca577ab4a9c09a887c67240f1f099f825ab8c6605eeded9582aad6ebbb443fcd4707b5a1bf696c2c1f936d76048d7d549f0ea2eb2c00ecfcbc86838116ebdf999c6fbfddb62637ed3bcca8fee4abcb394f769c9908be6abb266bd860558b6e3686d7e47d4ff4dd72e6ff5719a47337327a0f3fc58420a365be16839cfb0863334932e02387117ae2e2dd42d5de8eccef38f86df6fbfc8ac56c3ed61c1bcd891665983e4b5d68c7c67a6300dee998e23052365e8d89a86343d17754c5151e799c4d11e0cb52c5e886fe6409fa753153447dd07544463c613c7cdc86e8a4a7a59e782085037faaaa69bd3a1916c7d2ba520089e44004568287040fd59a3dd94bad84db85171cc25384b05bc2b0be885e3de8142bc04e3387ba2205ddd36601b4018823c81e25aed93de55d7dca948a803194c734ed777ddeaad995d70737d4c3dab3d6d873cbe358c520eb9bb5bafde1a99e62c4cf5fcce0201a19f408e3f10bf969ccad470a20914483f161e0454dbc59894dbca6a9f0695c9ebff3ab40738b32d8e154037dbea8233182a96893902b2d96ca8eadb9c7d3800b7a2613faabe48d521f432205feef7234f527faef4a954ff09b95a2ee2b8cbd453ce71216f8c6e28dfe800b4e926a04a9de5ba707c0de776e50dc2a0d7395e7f2a1f6ab6c8a863d7946166a28cd5211734e47b0c4dcb1da6d9870647c30ad618b0ade2e1cff2314229c09a462","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
