<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c02c4ef0033eb86809993088a640bcfbd55a4f006a67c6b3b5c1db0d36175c202c93e518fab59039037753d57f41d00d2c46f860eedae56fb989d9183bf9d9b8ff18b7831c27aeb9b0976c31439581895c18156646b457f0f73d525c8013d68b4da430b8c49b119ebbc7bda6e47ae1141362dea58de9933479463216033a9a733f5337758ca0af796ea27e66a24db0d378cab67b2df7af9e12710984c04178a06bde8e5e168fe4da2564f45e75d1f2f7dc5fd09d44b0c97a941b6a662af599daf59748182040896453adc55c5aa58b69da0afacce8d79432182f255e0680289cde70d1ab23fcb3504624305954c7f398dd52d48c208cd5c381634167947d4705bfefb12e6226fbf4b1d8a18ff0735860a91782578148dd5d1ddb3f1b024046dee2fd38f0e81494ceae923b5bffcb78338145521382447302133d452908884b54531c1f28363a628d3ce69674b474df4d8a6e6568a301ce6bf0708ab60659d798c3fe271992e3144361460475a767b065128b4809b6de3fea1629e44af91e4e429a38e6c9204d09b3d7b1f608103e1cc69713e62c24ed581a85cb942a0286de13350924319c5aef85cecd5ed3f6b97c71256b4945eafde587c8ab2f38b0de30c78db0adbced1e52a359089627d5b5213bb54bd8ad2d24c8e18c44480eea80d47c18fe47b9d1da50be44cda8e892099c8d5b18182e407a4cd436bb8ef2457da85580ecd475e8ed4c31bd3e6ac5211222142f9aa287dbddca291e4a18700e7d782c8cafb0ebd8098370dea8947ea3e74d0d549da995de30dea28da68b65261783ad28eb72a5135b296eee03573e32d96d60d076fc05bcd8320d379d5ea73210a6eec3121ebba3bcbedd61675b3d6763c8d9faa1cd2e53e906b4fed8deda8c0beeaad710f8b73853f249aaa21e32f686e5b95fbddf7733b2433922e62731e174c1fcc61f9502ab555cb0fdcebab29b445697d18f696068f7680fc611a241662978f39624d83a3706cdc6f60ac9fe3e511bb67b5cc8873f049bf19b350f30b16f76a27488bae2fb0c8e05815da983789f5655fcf56fdea1d7d1a5d7536bd2c7ec6cf0fc2cdac10c176e014e4083e953f3b34a94af8412b8284980dac60830f7cd671ba33a3b6e15cc677a9c4f5e616dd3e6bc1dcb10b9dbdcbf2080b764f46fae17007550fc139c795429870df3522e475e028a277017960f4b438eb9dc69354af32e31ebde923a3da68dfb97cd8c9b52e90a44985714f054fe854b2afd6b4d5afc6b844dbc2ddcd9fe7a1d24d8626387a3c9b65232e194816822f493204c11e3c64535e4513912e58a4e854b8c697d401381e7b5eb1d76ee1337a07152250e3ef35154b32d68ed155fc2c95c7303825872d39695728c88f45877dfa680af3b6874b7cacf17136014a0d9fd54d85969b05fdc57fa0676e36d005954a9a0fe477654ce53aae10270b529dd3c434497d818abcd3a847626226e37fb2ea48f7b2776fc969c81815f53470c89affdec6dc7024b691995d7a92cfbd2167e18aefa5873e697e4f82b818bc5ed32a1018a37053873a770bb90716ab1511d00c7735dce6323afcfa47350a798f90ca62bd4aab305ccb48886ca12af25536f5e89914ae701d2263501d17cdd453125555f1cffa31ab9cb40928382fdaa2e1b64016dce39de79d19c96525e328b48b4a690813135aaf0203a2a0882693390f8e81c438f8f08fba82ee84ca617f755c7de4d1010b67671d14acec35878862e752811798ea13c464de2a4985db859bdf90a9c4d62c9289b698270fc9140dd82b89b8105d877c6e2ac5229af85bc9d221f855cfa6062ca7f512e19c3e2216450e1154d26cf4acbc11a1bd49d408236d6a3443d4d054adeb8277990232232ea602581cb33744fa16eb1588ed75d006304aba5cfc10cae1dac539aa55f671a9ac6291b167efb2d46ea9c1598da90fd6b6b1446770ed19e07e57df5e8d14cfcd2415245b81525fe44a1661caeb25cbe798bff34680c4c2974c7b2edf3e7e9c527dced90f54df7528fa5802ccb4ccb5581adb51f0aae173fd22a688fc2b5256ca7294f3121637e2fb637f1701ab2075a8e3417b2c2dc01cb2472dc2c9c14746d3a6418fb5ee1884f5aaceed254dfe3205e7e4da6cc169f0859e80c3813611bdf7dd5ec6a5a49bc1081451ff7940365b1e225fb71b1928425925c19e193f8360164f795c4d3e4cd9fed92f2dab45dcec77a044dc35b285dec0f1bdf55ff236a62e0a3f13d430daa9b01d8eb1dfe5c05033437b4a30f34631a67190bd6c1713b5af163b95f6be550e943b9bc14ed70e4c4711874c207010772656e70d6151ff5e45feaf17c6433d7c519437e1e121b20867f83fada543200def354ddf0e7c2435764c99069bc4e5032df03a2f4b294a9704304966e0249e47b4b816f9bb400eb358b1f9b39a58cc33f3ce91ffe349b49f15398297b44953c084d50c71c845f3d18af6f49490780767bd47fec6e392f04911d83988bd991e52327b3f4806f66613f9e9d6b4f2600366119e5cd179f7522ef2782d5792557aa1b8e06a7f89fe8b896417cb499f9f3f910fbfd73d19f3f4f22db7183a3d0a315a6295c4471184026217e6a6d3d2935e46b9a91c62d08c591d6601bd2e12f6cf13e5581f65cd3363b08a756468b3c11c45b56064d79f9333f09bbce1851ad92f4e70a885cdbec51bd237c63da6ea8f406b71b7f55faa0c6bc2d9597d10815cd7df4912e972dc21ef6b9af8eb7bff1dbdfb7f87caa04651f2e8e5675de81b67ee90a8daf0df682a388c52829bbe606718a70a7db9a1bf4d7d33299e82751d49a490410b0923b9db209a54d4f6238fcfa32b002b52eb361d6af62edd85fbc9d8203aa3abcc5325f1b14155e709d6f9f55a44d3d91d2dcf39d253e2288e8c496e2284798bc3fd0c44832997d348bae791adde16a6b5d9d0fe64f9a333b4840412e02a774f15810a8a8498abdb883fa6b1d20bdf1c4ceb3a68a1b11c53abe1843aadc8083037b236747bd280c51a2680373a3b1f6a4f6b81ff7bba2859b9b6713bd39191c77b5b26ebf905811cc6e57bff7e98734e031adb43a041a6592078c52d40dbb10f42c92ca0d96405cf4bd8aacccaabc9321f699442a549911e45cb4c5e070b729901ba46f6c0603a3684a04100b8ef901677bd74154feab38e04092016f92c4f258c56455f00a606dcfeea609a1d15a96fa2d707df8a237eff8dc46d64853b2f48f5e03200a26acc208d4fb5fdbab407f1bcc04becb064f916c509dc46c94ad1af029b0e8e484bdab88da50aca48239a1c5322e2f6fbf3cdf4c73549ecafd0f0a1e7a79518a63196d49880fcd22bfce3fb35615fe07598f4b266b564e2bfe3e065e8056c4d5c1d90453ce5cb916765b71e582a0f480fdc2f14248430212925e18424483a979ada13e0cfef942f6c59b4dc691c33e4230e36ce4251b58d2d8892f3fa2e8984cf70aa4240e6cfc47b88c298a96c654b05cdc6ebfc9984fd9efe9f0e0b53bcfd9d87629f9f63b529b301b6e55affb0ba4f26fe0838dbaebe1d4aced72334b4bc68d27c14f3b940d35fcc5bfe6be8e84d9cbff76ea69a84d9756a9cff9de3ea43079e7e37fd7eda2a5c2dc6481c0992133cb43ea9a63fc40707a907de82226b8197180d4fa47ecbbcefaa668e404384e74f27d7fbd4550861a5031b697f5617dd00405bfb03ee7310adeb02e4cb0afd1158c6347b3479426809e20249d07212d20a98f9af64a2663a550f2a28e0f15c5cc253008227abd498ca398362bfa1448680e51c974aef749ab91da6cdf8971348f7ddd8e22e1358179bbacf273a855463d3af3b17ae972e31c0255518ac5731fdf9ea06f62204df2b1aadaf0431b8cd47f8d3cb16bfd4507d703dbf82aa08b80f3f593f1c47e64b91a76cee6216bc0de0405acad6e2ba2c39585b1cfb68c1a0ecbbef5bb0cb561309cb1cb9ac100dc2c150ff27d01c77f6c935393542941a7653110bb04dc15ea0e3e601f051c8e4fd8acff06094d5d6ce3a7a734f44cb2b39ebfbc5a765c66670de11a0d62ec85e6528e14d080c1e6a8f46641648bd7040b43077d00f3c1b82e422df6dc50cd377ab21d2ab8ff3da1a05aad15546ec5a7cd78ebfa2ee1eaac80ce8f79cc7b6c4a433565a47dff471312398223903c6634b288c7fcd98236f40ddfdd9a3e3a4c41db72ea7a6fd43a34b24c684dc236894493133461c293c6b8b0e57c47ad6bf9be33803b25c122cff2865233c36080af470ff4982ffe75713bc29fdd38ab7ce871a5e7cf91ef8e14cda10a578774bd4d88db2af9e13d92a1850ac99c18f6cae071d179e6a1b0d2c8b68136c3867b25b77f386bdc813b292616025480764834374de4621145499f51f1924ab08c630343ab47ee26e78fdf881ff06dfc5c633bc663f19037e9ab178f13602a7d21995ac704a2ca9613b8b216ac9e1337ea488d101fd09a844b0a5ffcce832a9ad445101f84e4895720f8520e8b3afe6f2c1d16d4edc7c4ecbd994020f81f83621dc7fb661296c716dacfbe6b0ae77c1c92e68939b545c83be4e31a257bd87de65753c9d36cf45661fd04337c8e5a69844556ae49f210309a1d3bfaa3f3d980b04fda7171730ca2366c78d6c5ccfaf6fb56625c9c02b01b293e15f1710adff84a3a08366051ddad5ab029ae1f126f90996038e6ccef241514d16382db8b758bde3a74574b4f7db0d07376fb63dee8150a030d2fb81caab24843f4732ba75dacd313fd114e38ac2d3366767cf17dd38ceb946cf7c2c71c5236274b9aed37e878235f8873a5beacf5aa71310d10087a828da8d65d2069db1195c418e8e8608765d5b29739c7296aa33076db0c66e763657a9e0ffec5580ea83e42a3bb05ec545503b9a67d95c6ffcdf84cf8f6bfa36dd5120e7e83e83d31b1687f16c3a3a876fbef88d0866a869ac45bb0b71b9c748c71427c17bf4d15115311f74c037109038e18dfc4a801a4fbfc64dd26126705142c824a62ac14cd3c7caa3df6aaf2142154ea31b1adcf89b3a9d6a36f08bc04507087fb97bb5b8c749c8e7ac8a7ed48d2920c7a3a2687297cb2d67f035e00e9d3c003e3534f419d5182a3f43fdf118f622f295a6aabae448a119a6b7d254e58df05592402c8c4b96c6bf543cf642dbbb472edad6fea947af84fcc33f5ac885c302ab47b13dddf6524125df5cc04aa6bb512bb82501f6efccfa226ccbad10c06a6a4491958931a2a55a4ff43d9089de0ca14d7cf1e45d89914c9215376458d3851ace4982e1f04d6076ab49ec08131e0098ac60e8d00466a1d0a1ca9382bfde8dfbf8ddfbf67923527675683fff6b52423a3ad9c2fb8e8de0e2bbeeb46e8b0c87f9d61f813fdb146dc9f66cda3e7a5f8d4a753fe26dac96f2d7d664e90bd4061106d03934ac8858cf8f7e16d1720dcdff038961c6772eca2ac9d7e42a2c2fb18474c1f5fa7cb6a26e087f9d6f926fa91791cdac42db4ee8a18a6fef5e78059d81bc6c9b9f7d39fcd59fcd0e79d912837758355dcf399eff73a5f422a7ab96afc93d556d5a9f25d7d4693e177d7b0cc6817742e0579aa09fcfd3fb3a1a688f5148a5192428e3dfea72aa82c2e46b75f1500453c6a6554cecbad1c9c8f30613beee00748dfdc61c46ab62c82e46ba8bb800e24048a297c5f59bd718f4e3b9b7ef1140be77137e0ae872296b58f1f1d8db189868d574d23392641d765764bd252b87d9763ef399cb4f6d52c13b73be8ed08f38de458c775967bb8fe98947611b8d5cd0d5f832a455cbe77002da86e4eeaf2661f762777a2f2b96c317ee982cf71fd20c62278fb3b9316af6ab005c74d2e5bd6ff52c825d7a670bdc37250a2be69a23e4211e13fab0980a7846f2c6832ad5b4877f7bfee46f96a533be2bdf0634c00497647127d09ee5d058e5b7fe78a3dfa1ee91330fdad867ee1f95201a383d4cc2ea88432b2f61a51ff15e8160b50b1a2e3377a69320f92daa3fec6a149d7e49618c8979b884791dd19bf6c4722196706307405bc19b51023cc2623f868d336e4326902c34d42ae53ff284830f47bb2243152707e25def891d169f2f5c0f8b9fab56102a3f23cd6c29b5af1c99a512e8f362a3b839a45c77a21e376eb43ce0c0c4067866d9edacc325caa7b95f9fa898c3b7dcdf1ad048aadc40561a0ee83f011623ac03d0dea96731369ceda808319aedc093393577d33f3f957f7f25432d198355ac7f60c653df5c6d34e172162990b47aaddba2ca4d587947e285ea83daeb74124d70d2ae7119fe957ce1ed1c38953ad529850d49a6160315988ba01a2715716c05a3c8a045f17e6f2472d0bc6e26dd15072ad8e7ffbf45488dd84b6b8989e29a8b0cffbfdcbe69df1b0dcf1c2d283ae33c0dc3197380f5166a6bfd9eefe3545fb593cfc9224940c60685c115c19e499961bcac9b3c5566f37b812e8ff7e4e9ad3f8b437ed04de50d7c8c6d3eb5355d44e36abff8090221b9559c2290772a71267639be36e1c399482a10a26a8a0570f2b1cd8ea3377a8d387cc22a7fbcf522751a0b88a30b5ba43cc349a78502748d9d0f78911eaf1977949b803d24b3b45712e6e1438c0daa4b34d37a4b2fdecd72fb0c8f796d328f5675c3aaa4628a9b7c09e23348b6dfa4d863e6d2f7060ee7d1f9144ca98f5dcb6abbcde9c6da333a0ae5e532e373a30be572ee6b3602e84a10a5ef9c4e2987bb706603d5bceb6dc2c5a59156d8457a37688058be9b4d13f0465f1609873ebe14e9af6fccf0d8c5d0375753ae7f8eca0296fe396594ed95c232d2c17b0b4becd9a6863ed9e4d633919d33af0a3309dbce618713db1452ab86f1abc5039d180af02a809b2f392e47925a585757aedde46dd229c9ec2b86888757be807e735ba1d9f2de9010e0c44fbde7c4ff09f503a40a5233baad0a3a69ae5c4eb3889f200ee081f1f3d40d2e0606801d76eab02f8f830cb3ba00abf7892ac6ffb44ac12e87f73127cf052ba7ee1c757531802742133b6d20f9a3ae0f02644fbab8719485fde6bca56cd3bf96f742eefd5a3f662ad11e1bd95d37fc56113b01db7d43a472086402af65fa54bf5619f0a983629816c4ac0074679ed2c04e823462faa3da42bc5f5173593aff1f9ceaa0ee79ac4478122a1825b9b205878a75f7a1fd03a4bd433db59923cb81b7eb59f70082a79ccaf4f33dff65c20b2530743a3c3ab9fc7b767620ab82f01ffa990d3f7f3b08b306caf25378ea63dbd6dc7b677f007bb3fac36fc14fb1a9955f1506121df6e02b59a9da8e3db8eebc5ebb3af8df11e5af024fa5eb63a9de1c7f47f25faa0834028b9687aa2f53dd63f177c5a676adfb48a0a87c81520683b18f377ada1ee9aab0d8080a2166076931e2e2b98b72f4ef333e52de6c293de1731b77708d8d71b734f7578aba22f7952f423497bb2f567e88c1d97b38193930735968bd9b1a744d44e9084fbc1e2b3d48fb425c752bd956a890a410878c32b8edbd4ec6485dfeef2bf7903877d9839cb2b0488a99809139ed45ade7427ba22a124533e1154977df2108003918efa3b97e2af239384bdea087cd941e7a910ed4145adee52620390d92504777303cbdc30881ddb3f028934daa0a977a673fce0571b5fff56355c0e101a313f0012dd1a8f45582027b0ee4a231771912568cf544eb2a18e503304b5171d09aa078d812cb9291c475fe5826815738e23569f60e66361d74ed7836bea17b772033662fdf39647817e34e39c4aabdd626e5b0cab1ca5fff8f990a1f5b4c051e1fe3d8923e26604613a5e02524165d8fdde76b158a8ec72b0408730a7cea064de92207540194fffea7a085d5425acbf589796e1164dcc4be8fa29313080d39a470343777c96597de296252bb80986f6ea5fc210b8b3462f7e3e1826dbd76c76ab07add774d903a9208bde253759cf9e2e3c3c4b4057fd7f1521349229518be7e0b7c40b14f47f209dcda64ccbbf499c65b681b2a77fbc5a340995a3eb22003d60d60198d745b5039a382d43b4cc0843da5dc0210fbc5274ff04bfc77a6258957eb1b1d968a0153b9c037afedbe13f21c703f4076ce157876952830a59df809040abb234b09d81fcbe8df3d37d196e61074d6741ccafe09c60c606a838c6b55c7373a73831aa2914af37b2dd92140578fbfb749e2fd7561f637f5366fbe7ce773f7355265d9121fdae98624204455b55099d9db0aafba29395ced8b9cab8e695d750b61a15351bd4d0ecff05aa211937c690d20261eb507be6c026304e0c5d78d611068971418f9168ec67e99761827aaadec0c38826201b5499c078d0ae62a0be38028c12e19c289af67c0df2da0961ad5fefb894ca72eb38e0d1f06b5f9aee6f6b7176ccc9744da43d33cbbbc22c81a10333340844e1281416f01ef8f54179c45b0360dd6d543d347d2d3fd41cbf19f80d57db2ee6bd920c2dfaa40fc78d29ad029be65054aacb764ee9bbae672515f4a41aef0267fb3f86407002c45a59b4a903a3d6b8499fce418466253f678c48399b404d2346bda05bcf4b4780e1be20216a7885983e2060bb9138e44ed365fc3a30f8d45388ec6976c22822723e94058caf07387a81824705fd024b3baf7158b047b08d6bf346b68bed408630436d9c2500c4ca64a69a4fb941b886bb75fcf34d5dd0a6133a069a5519047c7dc4b8f94a8022d40c9be84f1ca63bfc8623b18ad163795a4be3c7c134a1521964399bb26be418cdc545a1e3b289242d4c3f3a9ff0b1fbb144960993772b474dec9e840402196120dd157a16b5770801deabd2ab72639cd33b93bc4e224b7e967b0d6a91822fb22691f491919d47cd5612ca12323969cf0ab28ee8d4cb8aa4ba7c91775714a7deabc433e82b4e694261480f5d0459324d99d2850943c5521bc1a25bce345b654237969e85767f947fe3df4e5af4bd293b8bd4ce8dbfc11339bab120394f1fb6ed8628a9196a9c9577acb5d3b270fc7033b5f7177f4d4d21f4f3d409c784735ee0a314ab3ccd197cf7ae0488e8cf420fba5b5fd3ffab092de3d7e28eeddb0195332050830052152821cf08db1c83df1dcc2c91eb26335f1078310dcea5f98935428f8ba78d455bb89f98e1a54266933405e668bd9a608c8e73780debfc5da17c812a9dad06b7e1bea0148984df07b1f1dc72f2bb6f1be1431a24cd0292c1d55a402b534f91df43a94c275f6eacd675f95890745dc9f191353971f026e3a0865f15c7357f343bac58901d19f455ca1edb226a024a3459b41f00bd74dc814defa43fce2f6be2fcd908ffbf751af5ef881cac7fb4ece6763bbb226206db9848d03311a6ad82db95b937f601425bd76606476f5a42637d777f383dd6b639402b2a145487a38c03216b70772b4629985d7aa6773c91f5ea3e8c4ea0303236294e6022d151de768142255b439a6234b9baa5b77b77be86ce0156324ee5e6ca04fc6293bc0f94bb7bce84dcded90a01ab3ecfda4a438cfbe6199769e5f9a6f265051ed711d7b0d49c639b87291b0cce10a3478d909047311639c73801ad6bd65fcc3c06254dac75657ac2d47e70239d77b878a46a4caf88f1040b5ec7744be03c6206b5d30caa02465ab706eadfc062a32aa697195583a36bc9b2427403b39415d7faa07fa228a6ba4be90adb159c7a2eefd3706cfd5cc71a27212c3797f0b7a6eec04d85211b2077688a0273db1085d2be18b3fd4977719942371fc2bebfaab1d161afd926879af448de3de1abcf791a6b46721487eecfc7d6d86950619a8d8ee5763370bbfb0467ae423cb9f852d13f92c9f018a2ea138a4e263b841d24bbe3b925c71028a1a9b37fb608ba68fb164f481879e3ac49586866edc030b9719d31ef35a8df41c6018f4dd790af485fa0067ce436db4f36df30b44de5ae9fdda7ea0e31a0c490809f7bdd0dab92731218f4ea921b71ae475489212b687d8e47d6c8794d11f70017ad8a9577cc8edd4cd81e4efd29ac8ad645c8e8c2b514bae9a4a8d964a5bb799e769be1b3535aa7a653a63459d6525fcbdf8d1c9cc7c90a5efda1e37d0d8124bdc4d538f4f5774f57cedb126e95a0bc87b056b63c292617210e6415deda3abae1f4160775280726764d5f55e11f61509d0520ba5a776eb68036c98bc41377296f37aa9e2c76c11408ea8905a6424838fc7f6ecdc9c40db076a8f5381e333dd0ee09236d5029edbf2843526f4e0417562a6841e072a6182aa14779d247781306a701428afee160d3bc340780c1eb6f3e5002f7b2d420774eaa56fc69adb83c04481c8fd393c915a7337dbce0faae2bbabd67684d10c94d79e1bf1c7ac2061cd4e0e0c64f139791246478678c847f69fceb1da07ef594abe7d897d312505af41c977b132dad6c646eb458bdc5610a81d8e46c24e3b56f334a44a0d7617448ec26d0ff47add072cfc5556daebfa8a45374152206cc13da430e3d78af6efa2b4c5314a411c2915ecb08ea30aae9d0316162d066bce26dad70f1c38c16343b85eb4db25e2ace4e0c1a9024708c4db296e99cfb6b5a194586c619054e21b517b10c958a3ada9ec77218ddd7b2f8040ea081899982ed1de1a10b603104b5e703bc38655d2e2f07fa7a3eaff0da5a74de3c7b41ac7408196f26e1d0c14ec71e4a3981b603299e07cf4c1f3c13b99f41240556852143c50073f599a12bbaf7ef2f0e455ade76728739386992ce5542888f42670394481cec43886564d4d53903a033ac1c8a85c266c10eb962a70e7f13e84fcde4085080be67156ff651621851b0e7e72c05804c83b2e4381cd78c95efd5c7e132d97940cb187d6913dff86971a823ac5977ecafd18895073df50421ffc78eda9da9ae9720c8c360009b1d04252154bf4bc7e49b4a189b2eef3640ee2902ea9d2dd529cb15b3da62ebb49129497180257b5fcaee63dc03346e3113cb726729440475173d17ee3dd91bfa4a1387da7b59ab629b51814b629933ee2231e2dca74d79cc639570fdb8548ea11dfa8f586b7ad0f64d8947ef022aba2c49ac12367f2e6f4c37dd1c60b4e0c8d9819005b5536d2cdb7e452c6fb29d0410c411d6af89d3e2697e9703b9ecae469a0e3b97d78754c57b64e73a2ab831b821a95c5dbedbb06a15e53a69b72130cd59a1e0fb8d3b03b36016786ac9896816e986b69c03384498f55ca4bb5c54cad979efeefe77816df450df6c75a6a879fc57a697c3db9add62f062f961baf52ccd3deb28e62b990c25bad9e5214a2782a140e90af7ee147ac94916c8e592dc27759454191ac885c115424c4963224afe48ad873aabe9ce61a75bd902ec5aa375791e336264e81c2713627f6f9918f1730679dc92845329981d0d2a88081df4722b44e3db2ef52fcab4418c4a6036f04b0d32623f8e35d6c9a3ba36f9fa4d26eaddf4711c84a78f21b473169046955bbc43e3f760a936f32dbddc4abcb53b76ef956c093cafb166c5c5c129e6dd468fcb87edd245cc5ff611fb6dce032ac6fbea2ceaee78bd1567a50ae703b950bcacc74b315eac1d3595ed6bdc24576b02742f888c439ba261a9881a3fff11ed1ca034ed05c75d66c82115255d31c3912f01f5e18f55d24c438903b9590224872c67c8ae17955e11b0b2c4db2246aad3075af38ad58063fba3e9805da290a5929bd8a1d978363547123e6ffc975f49d89b010c479729d4c8a124ca8ea9da464bdbbb78b3e0bb38ac68aa96dde7ad1a884edda873fd5cbaba4d3635bf8eca9efea5163cf5df7429e87c7eb13ae3e05eabe6e96e6cf46d2d17a1bb49112938a21c6aeef1b0569855fc59725f390ce99aae31f75bb583613e4fca1eecb765f46548fb5d007d8611e55ba51159e0f9775534555dac1e4a803362581c65ff11fa3ed2c3d349aa707179493f0a1a3ae524ffe77bed7212e5f59a7b97ce9261a6211b1a302603585c40ab43025737802b96eaa4b86193ba3bc5993f7a8e902344e9f9c73aa129b14f24ef36f694d49b49b14fb7e445eee2f20648550e6d06a831a5612298dcc7dcafb466594e63030f266ce2d0a685cf8308170dfca4cb38080bc52834d3ca140e6a7a3b8f232cc51b0efa47eb0175d4a334f1f95e5ff333d8babbcb261fffbd04e659418e972b3c46738122d4e0443cb12a174a7fc6b89d9f19dd6c40f4338a5fafd5a40a4f44e51e03706c8bc9980c4d45d25b10ef3d9dc55cf0050f4b58cd74030d14cf579e027d45464c1b787288b62d039494a83e81f8b627b6ad68338f36ccee55b2553ecf35e01396ef554195fa07d6a615902185c3ac6a51cf1eca23af9e3315f2c218fa142ebd105dcd9b716e2f4952b95b725bd4ba0837a3687b75148d98c89e06d3b8102447c878ce10a0d005d8b7632463dea1227281be733e17863de26ea96d0a5975b5a90d11e4e58a6a917c5ce7a616b66a0e4db3f4a2f3c596e0d4b3ea71c0d7a4308d4d58955a5e11a6bbf0db695b7f37d9c161a3c63e2da139f4e22672199574826bd96e01442c9b9f6bae2960f96d9819e95917efdfdc9f1461be613c152a58a9774cff6b134e5729f238cbcce08b722f862dd1aa8393cbefcd071ca8d9c829057fce79d2830aff7047cd6389817f47c564bd21d2d215ea4bcd94f97315bf3de3776b939597b8a25ac9f3dabd5dc26736198b99596cbf789854768e1fc352567f5f5962a4c2e4ae25cd1ba6994312c43e637937bfa0385093e2a4c8fcc9bb49093745d0ff1f00b230e9be665da4bd4fe4fe06525c3152b9a06908901627b6acfceb59149239d3de0de2c3359a044933b15d016f421903ab05636c1d1ed9191b3cec2e6d72706a0b4d102df83f5b295b718c52a4fcecff74e1787a60bcaa1828aaa80487fc10f484b72a00ec2a70d56578dcce92bd71b0a53160caf700901e4aaffc0ba498a98db0f5e56bcc31fa9862a4e0dd99b6962f71119a0cdf5e9652cba325840fefea4f50440f9b38b1c21c6fdd8742d2702ec84f638f5916a13ac68dc682200e8c5363619481a43e52ef4e333cff268abbcf5da0ee78de1b42e95fae2c1dfdf007d574ac2c8fd05639413aa4331dbc2e071e8d61b77499017d2a0328b775cb380c86bfec1cb6cf1c2d24ea70e83cd3c2a79480246a9d9a0ec04bf1a0f3ada4ee0ee9b5577f7c9d4df40ffa9072b5165225071806b55ae96866d537764eb6a117ba6aad6d25678e36319066b52b20b539ab9de8d1d8de44da7c6865ffc912bb624be4c48d646921f5b1a0d4183d0de65945711b51f77e57b633a18a9b1585eedff38b018bce02429ff2d670db10c5abd48698607e7ddd2022e4393424ba7a8e8f3d9a2b4c49db9e9bfc6c34f7dbdff42df1fbc01324c0480adfa6fcf95a1827f792304782f84db9095bb70c598e01e2f1465f2b48bfe7daaa81c90c4c95bf30693d0a9daca389307233ac3875898ee96b1854e4228004a96a56c146a8d3b40318d2c202ed769d01233b04a936b7e51c7473352c58948b0ac3ff2f39f0122f3b9c531fafda714e709bbb599269c59de92aaf627a767698d6f69ba67b6dd491f65ab6afd9c4268e35c8be3d7b0648042228f2c75b767add34c607343fdc9b6f652fba028d0fcb9a9827620300be4546a954779f24974a52e86568114a7cfebcc4a52de85605bcf795280b78ee74e84f3e8cf23672920d0df534cf60d3939dd4b1cb4033f5cb0d61c92ef4f821678b843c1c5515316fd879e8527ba660c5255faa2bcb3ce62f02cf9f69d0065bd6ea9b8a090648c1a3ad87961e8e59b173fcf28878257c5ffeb945a454182620d8c9c8f073247bb068ee555fcc37e58ea4fb5a47b9f3befe2c5bebd6b205a0c56e1feb5ff112ed825a7d1915b77c9cb7c06f2c2a968a8afbbec401aa03fedcce67de58c9ee28ef76263433c59faba73a07d6aaf6d5c200f1888c8c55e8fcdeab855394436013f865801bcab134bc2d620b47a9330ea33e6a83bd1e8b8c90e039d2f192463d181cddc2ea127e38a84c5590a3c1f21d873d65d049e4e5370985807ec3a8b576cd7ecf1b7c1c680614c6e08f61b886bc1c6fc9f36ee10f54ee107a9b4efce4f1bdae505df524631e358c12329ad0c6614b034bcc005fcaa70426d7a0529c617eb972c9a742f9f146f555cf4118ebf0f76fd35e9c32c65192d569d08d192b6df200366d9ce0cb15b032b825c3cb7b150b516f5539ec089eaf6b01c77311400baa9e3ed5aa78018c389450e52aad26c965328e1720fff4fb6f070579a1dea7a03406c26a9152f38b0f5f2e8b0837d256ad692c7d5887a5c99f5ab61f90f7d907251da6d4e0de38db897a8c0567394e468fe9da7d59a7674cf5d437e71e343aa1e949e02d936b17ba6b7a76f4b261831fe90c324a3fbfda33ca3f85860e3a601bdf1d580f15146196a5bc121dd71bae1b652a64ed2329ce5b8494e1246171dfb884a0ba128e9c70f95aabbca0857e3ff0a6bff0e7de8d17ca8420c46e5ffad25b54397c03d20b76a785203139b1d5d604abddd1ef92bdba6637e52dd4d2e59f2b6dc1ae449dc87603fa8ae4e504c361e5d2719e099a7111a09b80bb24b5d5ae20643b81f7d4a61662305a73e4ac7a333630b9d4952a103e7f1a8f9fb4281849c0c495f6ad2a87a0a34bb87b11762a40c65dadd1cebcce307fe5ce44f37945d667eaf0508df914a3cc1b8ad7e1fcd56698015b292ba1a50ecadcd949d59b54cb2ec9c1808bb963ab4fd01f2b375a0119f5d102d06c74f02e4377110755b62c0e77695de03c9b016a806ce4bcc6f1f73163cc50d6d55b7a5fc1ee05a0a72b9b1903923578a615f01f5da33c8e9ef68ab3e1ee96b05a5bb52c345e99e0fd1869bdd6b2ed029a5680ff5be33cf948f0c915ab6b45b98869c657bf31c128cb0306d9f376f2dc78be57102bd117f4e618a6807a12687a0874bb5cf86bac0f4c46f9bac9c46cf234e8e4339ace06ce33ed9c8d864c87363bbbb20452846dfa2be8c751eefecee70014cde9594318b5e428b9ed887368b65a2bf924d0f0b0ee2eac48266ea01ecce8c0bf02e9096c795e61ffb45686110bcbd576d7da90513fd70bb5489724c71c118c1b51e2bbd5505611863cfa42a3000b6cf9c2b3751a07d4921ed6ca09f0e614b7c98635604d7fb868b59a34b03ed84e629062c87175b5a3928504ac76a07ce92307d70fb5f55805d959f1e9d1263c6c86fa51162f619285a04d12aad0138cff8a8f84cb2f8233962e977bb85b79b9eb4c05ccb500a58de936dc965aec30c903d7e2f8c8abd69fb42464dbf112ac6c9799a1ad3df1eb5dad0c50c102dc0a51cd8662bf89365cc7e72600a806f77a1f86de1538e4e01e0f66aa3352ae4dc473c4a85b97a11415c24d1203cb0d7477395a9053133b16e911fe05a02b2af742b62e52ff7bc27b7d66644d42662e40e45517c600d84620ea870dcfcb734e46cb7e96fd3e195a2bb24169f7296bf5265aa030cc3baa343c324003cd33c88cc2339e94303e376c6ca5bcd5b3a04463b6096f93dd12569f3249effc8bab1238404ddac4de299eed24863941425f629d142303951ea61c6f106327af082ceb8d7e4f7c67e7bee583d15480602f1b18089bfd3e42c3f550cf226937e996ec02ac604d2c7dc5100d3851e896e43514fcce083a0dbdc0bceed85b72bca06a7dd91d5e7122e661c54bbbe60139f7620c6b31f69be58223902e57d3e07ebc98e8da2998a027eb3d755a6539a6e805cde82a72f73fa2694100d933d49b621ac65766e9a1fd3b3eb9d934761bf3ab611cd4ba384bf1a403b5ccac2d1abad27e1145a96bc3444fcf1ee46912bc34edc353bdc40ca724abe0f74c1f8592f521200e425cc2a3adc29a8996be0dfca35590c8712e50a008180faed814881382c38cc34070317ecf9c2472f5b7c34bd4646c31166be7b8dcb5f43c985fb38d8b93b2f76f24e2b53dc3ac51eea561ec81499013fcc8ce42b8432b5d56402a1efbc8fa00d6628479bbf4a985b02cb33e4239f54ca818e517e007e229fb539274491801ab96fbc8577267d9efaf9a665ff945c3c140aa4c47663c6f665dbc95308b3048b99fe6c3c07730901334dd50507ef84ac9da753d74abc9b2e304736e65e56be8566f4db8a3ceff1a29950caccef08cb4e30966667f7d9363c5c5836fa731ca1893cfd6015e18f76e371f4a8767400ea05b99a1d211fa14fd95d373d7c9076e3d497ec8466b446e3443c3d39bae0c572aec4bc345d661d6a5104ef7adf25be6066bb78c2f181740959f4d479d361b8a0241bbf735f5dae5da86681eabedc002f750dbfa35bafded7d9a3dfa3cd87652fd37073cb7c27269566029d686e4d7fa7a2c4b8319907947695f85b45b19109e7989ceae55841421e8d55eded1b9e9aa4305a1924c77b914e3a69320e249639c854ae2988d7eeaba941676b7f968f71d8ee05699e1eef85cc7500f7ad3e9412de1cea241e379b9d8626739330b08b99065d528e18728e6dcd09c2801b95ff45db7cc59578fd5344bb9c98e5c47990dff764f6adc8f4d09bbd1b260c3bb8b1e8cbd52f695000dd822c1ff690ed9529a57145c8c09094a00efdc18b84a61a77c4142d310424cea059035b760342e794b2e5e781f48a1788b4714ab5a01070813d17cae33036a59e7f8e8b022c259c130498eb64499980bc37954f2d4e04e445a748e22f690023fcb81f8ecc4cea4605d568c915d859ada855c14e3aae1cfcea2b80d5feb2bff123d397df09ef9ff83e980d8b5de7b111f764cecf26ac1763af573b3072a70cfe331e675aeead21a1f6e148cd66e8aea53ed8352664b67bbc883d4ed8b9761f0ccf1774f30afffb223dd16ede25008be465d7f75222022015663bf251bc624253d89a1f7afa8ebde2ad0b0b5916339ad72552e98abd61efecd8a9dbad0348293041d40df64600a51f55a317d25f2bcec69aa6b22b12fe802c8b6266091372ede6b58f693519b6fedbdcdf8b6f1f9a8bbf0c15a142c9e053ee17fcd12473ebf3a5eef9e344fb56a273676433b1918ed9cda8944f1bfa6a7feccc1f7836f05b3d5d9b427798140e763428581bbf6177be12139c3aa30c0af6c746f591dd2baafee86487f09d74d89a9e92f0a5807823607c7d48c779373d0c225acc5a757d50adf889f56aac4dab2d0d44d54d98c6036ad47967ab1b829d91a216c0f7c245df5830e13c4552a8094c5d1ad13f9279a4970c542b709f4119a5780844c988ca62b4040e384b00f6bcf0f218eea7c270137341d09b025a79df90f73db4d23b838f6107123bd3581bd3f86c7dd23784d6e714d70c46831df35768e29ff58dd2455b955781e1c19d47aaec7167b49e59906278c9869fc321b9288c4a0141f604a5843b46b8ee2ab645606867f3d7f30795559628b02678fc579cfa565963c3ab290534c3ab500376003e98fb0fbcef4bca7850148b7236e8807bc9dcd34e6298ea185e7fc23d6b970d58b727abe636706ddd2f8b2380902cec2fa48cc562f7edce4fe49ee7b71bb32e4818162449d10d103d4d127f82426389d56e29d96edf700a333a576940db9219fd1263e842d26499e0f241c9900bc39a01b564e41dccaeba1ebad548e489a4472a9110a97848413d14b281eb4c39c9b147e5560d62009e2d0afdf74b81f6d44ee191ea2532e1b40250e41006ea7a57003e3c0faeae3e9048e099c1a86d2645b33d49a51063ad560187aad908e13ae146da0e3b878b419634447a4a8f0626af29a2f902f02f040e0f1f4ecde5176cc819a28d18246af79b6cf8d7fd847b7b47465f5707ce16770c67828ac3b56a42eac776ee8e2cdc71f87e67ba442d3bd0ba17947e3f4b748b1840a3e969f4ff57ee211b0747cbc338be88a3d90ca0cc67c48bec3dca3f92004776a42cf1648cc5ab14a70da27c4cecaa44d05d41b9c77546111a546b67a86d19146b1c1104d38f78e62ef5b2b3e1cc7c474b30cb4f738b93f79cb43b90651ccd328d80f1b5aac7795eb265868c509179b3f20ce16f22ac66039555924cf6e1a510305358c7dea37fce5b7b61b20d67afcea53a33a1a9dbc2db433ddb4b39400cbe57c1ae074fe0c23d24a2583542b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
