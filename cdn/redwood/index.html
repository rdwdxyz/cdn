<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc83abc866ab15e790792baa136db8f2473172acbf6ae438c2c4d448252ea312ddf42b9f1fc70c08b65af6089d85016db6201eb613c741c85117ba96382df0dff79099c954f0e8f54c39903885d27c38d3f74fdc23034c3ad5f2118609bbce852ef4a7af3b1597acb49a5cd9c0f6039c4c8c17fc825f3614c07b5a4fd12942a26a2f291cb8cf2a25b5a33f71dae981eda3e4abbeff468703734c67b48b40ed1c662234a58604f725dc609b68bbbc4567f5b088620e753966f4f10a09d05cfe5368c15a76f7a2f3f05c735db51e719359aaed3c5c7b1198a74d3deca6996f08c9b44ca89d3183d064b08e5f171bcb61a7412040859a512357e3eac65cb80c7211c6c2d1170c319c0ebccf09c90c82c071ff0ae607ae61d3d261f8054d3c5098fbd17e702791bff3e00f1bfb1abfac65e916d0f10d67bc64fcc2c0af2f838f74a8d6865b4644b0987909a5c7ad9500668fcf299d246c77890b59b08442418d94e09ef9996cc470c3c3ab84b50698dd2cae5ec84870201bba721f3292d613e7bdb52eda2e4de45a17ad6ebd65ab5ca463faa6e6ce48257bc42491b919d579deb321f3642b5f7ef8d34d121fd1f251752e68513d70b1e09ae705f25bd3b14ed4477d6b1ff0b78b07116440a05e84bb1500772cf6fe03a53d10382897451ee0aa256e1cee7f0aafdb35ae0d4365fac6840a5d2cc0c45a9c9d8c7be884eba543d42d31491d4ec1d1673f42faadf0b66c06fc22c2463628853185255d679a8ab80abd14dff89466d0ace9b6e32b3f56922c58d31064cfb7ac9aaa1dc63e55399085b7aad27c275d50a66e6d80b7b95c9da658890ad6d022f54155498915da501bbd2b66e8efa147c83cc47984d275ae18d893074a17c47e7461ebe03c0b06711ce94e47659a1070b59c02ea6cdb7b8557d863f1b86ab52d72012dfc144bfa44611bb51020b8a5a99df66270ab852d5170712d37bea9ad26642bc908ded9fd2796c5d87684b57e73a9f10a654b73c35f02e575bba4ede750f6202235baf07e11d2ab0ea5b4526e29bac9ac7bafa2fbf2a693824f6c1223e199d3cb7f2a3d48db577104c96b7c93e2cd69ff5f735ba72412dded38acadfe52d5b37ff9568f316222890ac68a97e5af55bb3e14aada13327cd85c98b316acc9887da922e3992ac9634b694d8bef2488a67c29083bac0eb9e63181de1737ad10c6a41a3be3312c14122ff27a7b6f1f2590c3eda5c335f4f4c26dc3142d9d6b984604b1858976c61840e98149f0bd9936cc74cbcc8e721a1974164d9bb3119123301c26e0813e5867cdeb3ab4a74e702e58d7b7a0945cf45b062ffd34a9f8aaef4d3c823f46ad1591cb191d43444a58fe7957203c6a5a59a7ec995afe0e28c21899883d54d14263f8c8c2400c5f617f66cf3171d9db0bd40693a8f015409dea964fecc1f9b91ccc53772cfc4dbe2fd3e5c5299be7e7f2d4cf0e55483eb394955eda62a0352d13385d970c83a966cda6dcf1525df10e472f509f467e114fbc35a99da4bedd252b966063b974fba4d5550c27a889c99ef84556bc009a7c8a7cc72059893524e62f049f498db0ae218cee5af22eb62591a63fe6173103f63f7e20b80aa72b1541809a57aa0739e59cfdf126bf0c8efdd9412c56820e37099105f0f5e0ad54449fb88a34f59ab96f0c3256fa2590e1367f18c4a90d22cf8aa50a86a7f9da219c78c0e8d0d8e94de997c302c03785f5c3f3dbdbf7fdbd925e73fe428a2a711f96c0b01dc1df673ff75dff88fb0b0fdc4fdf482fb1d3268c52830a7d245578e8b574adcc811fcd22ab633b46259d0c4a7ebf60ae6477e1252c458fd6c01847e33dfb2364abd0144096a799dcf27a55ca152200f40f9da7256a0f621cbadc55566f61cc1dcf1cc9568a4113172832a52e15c3513869cbe4dd44e95945a6f4b4fd7f0a8419837368ba70c0b1c092e3b93b3e5b80623e0b22c6b4ec601ca48f1fa7a53e2dd5db2cce55f5dadaac0932d8ea308bbba07d0b42da696b6fd88656f703e88d82919efa8cff6708d1eca09704869b2e4bd685902f0a3e7fef54ff488d4a1cc8cbd12ca60a32c0c8c5c5c1e6fecfaa9f0dcef3fbbd3ad6d14d4f389d23f9a68917d713b33bdc40f72863179d69235769ee875701de2a2eb89fe9fad5239546f487570ae122fe8b8e6ad22c859ebc262f89251367b0bf4458f59e19c13949afce75f82ff10be2fe9cde780aaf7bc04263f2e303fbdd0666f00e35859e7733c21dc6d4eabe9a83741d45b02ae5b5451012b8186dbd212814d94415e79303d98fe4dcda16a1dedf88cdba1bb3d9dbe82b157a895890285e3c48b6af6352c75f083346c06ad5ee9cbcc054068ade79725f4f622c97ee5b817dd40b85364ab13bd533c1a294020de2a264b219efb5de9a4d4738e2234fdd288ef750f415a7c936449d34ba419991adc9fc762631c9d469f09a68f13893108cebcb9a223f5b0fb569cea84fc60829c111ce02cf4a315691ed508df7f17324ceff2200d27d6bd654c3cf9737a8a0e7bd9949d0eb24299f31169bb97264d8a5f6a562929432ad42b576de617c1de507a6c7779713e20403d7292abfcc317a58ab93d34c375d94aa23f9b3913d0ec510908e830df9415d56e72b2212b6066cbc07a9d04b02fac98e55279831a6b31b4f11842733c92c781a20087d063670bf6d480339e0122e505364d400f4dce8cb8890b86552b3d08d713bc677fb928d4b2da8c08887888fe8aa33b558acd53b7e402fb67e5aacbf6c0de30ac0329a4e3a63fda80fb4776b455ca8b54e75111297940eebea18579ed69f4de39ca9d5f8bacc581c93f084bbe2987df6e3e33df5fcd9ac2d7289b9fdce6fb9f9dfb3d3ea95bef92e72e0c76327f3f2a33d989dc1400edaabafd6323063e8fba11c937c7922c0ac83f73a7e076f908bbb0b144eefdc700465ba4f4efebd518957ccbdb2f9c107b1d2aaf9bdbbd3082f40c2262b8c2e7c3d4f7b81961617f9b0a78e81c1f473a2b1fd9928987ffa95bf5f837e52a80449fe266555e5ed279ec807a413d398c09a55dd315454469dba3a717f0e8f51eb74615e04f75a357478d37acbd314b20f15d8035d9aedb267f2bd16461d5d9ea7256cea11bbee572c7588597f634cd49dbcde2d03ad81baed5d7364cb851799d6eb0817bbf117bd906933a3d435245c8dff7cad18d3eb1c966a04e39b3c1f76a8eddd37b33b84c624036729a24a59f40a1ea900750c3787fe61149d93ead43b5709d6449623b3fb61be42654f6cdf47625f1a5993b1af4171a2ad745406bdfaeca36f9bb0a7e187a3052159e178c80e4d73281b5dafea0a059e840badf24d25c89e2cdd40581fd1ea51e28ba7c238f5947bf8f5dc4ffc3339d539c05fe2a99d1c42bc1f08bfa87b929fcc8f4b483c8604d176e71c2dc545343f2047965fd7a2a741e9c4145791bfec63a6a4160847778d7abb6eade3654acb6afa96389a8a18e3d23a14c2cbc26211c011fdaed6d9c6002379e75a3e666285cbb1f95d8f9d42e2be553caf868559fd58411bfcc9cb5e6a3921ea678144d4d2b9e8843c5ad30675c6d2ce5597925a4631b73025d3ab66d96928c3b3df0dcf0abe8da1e3fa525c4325d54bb54337c17cd15dc7f007281873851ed3de88f0f20be346df7fd0ed13f7d64eee33a34b6705834ed872d5c9a3df4c63757ced449b5fa63792b51c747ed0b6d517cb20e28b4f7fb8a372b4a5f069e887c98e2c27d2f4be8e25b87c15f33a905910ce3d924ec8b15609461ef1121b1b326af57e9e44656ebfffb397012f458893bb647b3d5ba60a68b8ea63934b40105ace31f948df2a1289f50272225d269684a3491ed35830aeeb17d3efd93005f0bfd110dc7e7fbe40ca03b8ad0feae74036e14222954d911abb9267ecfd24bc02a1c2377a8450c4b35c3bcc213dadecc50508f070350c28d478af06e1ff423fbd07ff17a0b1f0adf6098be284103d8440a3f19e8781709dac3c5a0d3849483cbb52f20b3171974019cc2ff5557092a01983264028c0e998b5f399459f6305409b2e2a1dfdfc838ff5793e5f3d539477344f662f80af67d8ddea08310571bd6eb836c10b0ae87fb097db1e87595d0087feae4738b23e1a28282549f8b20e8efe7cfc77dcfab4c70cebd7e70218a875b9e7aa530937a6becdaa35bcdfd9c7dc367a7caa2c9a1aa1eef69a985f6d6f27b082c3e7420391b43af413084118d844f19deb72ac2d7a2a9c4be3a9df8572447f1100d66a7e6788fd24a818bc6d7c706ff8b322917c4f67587a8f44c522f26b83fe2570bb9c205373e1b765a699220909aa75256d0cf8273365aec66dc10b7ab120ee9c99ff41edb96c826586cc533a79e25ac4ca4e027cda9b9cf96a02ba275617c9bb3d5fd250847439529a705a80361ffabb5b598030a47053bb1c8d892fd0137b79a6027e643bd0e9268844899f1a608de847e26597bf9d147ade73f181c3ffa4b902d279346ff93c77e49d14411ec1ba44837ce366a4dfef36056baca389abaaad9f2c147d19eeda935e742315deeb814b16638333b0ea8f45721a3a96b2eceb53f6c74fd16be3c553629d3dc4960f40fff0aa7e7e0b88ea9b868766c09c7833d0c3bb849c70d9759b23f831e75b5af75ae95672373888c9c17d041a03e694658e9c5e6153e507a22eb66d2768de654930a8ef3e3aac42d5d6ded0e1d854fb3bf5bcbbb929e24371d749509bb1b2b63e9b1b9658ee69826913c82a4b00c9a3cfde8fca61ab2e23c6ab6e4073f27b9a032542a1052d7cf54e38d10eed53dc74beb723c7b7bd332c76a382f4d135fc8526546407773eaa6af9b62faa826eff922bbad554fe0cc9801277caab412fb98ec72c9dcd0a97d1abb18ff0698f489e1a5935a2e8e292772ad92a90333c5a804a8ad1890a9ec1701bbc86fc636f8384d8b47bb790ee047e83825c62bc84579734f5e11d7beaa5e512b49ebd9a04663cf75442111eec4bf84d2e597fcc60db7c828de6483e9a2d081d4a4d2252476585614428c77d36a3b0abb9398919599bb28fb772efaa0355eeb1786b7bfb07db6bd67648af5f33bcd76c2bbabbb3b17bb22c0561e96c915aed3f38bf394060a1cd9b5f0bdb958c86b80bbd7b85469221ce8ce9ae5a7d36d44c7098d1beb5ffb8ac709cc595dd5502eb0ccb28338a9fd4af58c07e1ffe1818a54df370d5d153161908ac7f138628d2d0023da7050ed349b3cb3fdb9eca2eff6e3c1450940ec11bcb4ca13fc277e92c4104f2c4e51138531682368fccd9ce50cdbf47d9992c33a9bb8275bfd1d216b400215eaa8e06b9c6a998c69366f4fb30a8a4947fbbf94f0275fa12d21e05dd527b366427766ccfea8f56aeebff0979b3575c4fb391d771f293466df5105f08b2029e1f702a55cbce5eaf18ca4c97779cde6262ff062780f4234af616a852e0c77b44fe72889713a28f3fe11ba5c558100bda38044662d64b95cbe0978029b6227046c6e4593206e92915944feb19202fc541fe4408ce4f6791a2b7543b7a00336cc997e6a7bb1b998e3a36deb715348b6699f0ab20230c9fa58d54829ec961db394c0f6a21e8fcba4726c3c2d725bb0a4e8974a9fc26817ce5258869fd78b8765f8c532f79094764f97e4790feff43afc054db850878f7e13414d2fb9a5023e35822a2171293920d2b787d260ec298c4a51a3440d8ccfa2e259d0be982ac7abcc87c0670dcc39f5c18db811b9bc318a532dc218d1d4dfb33566cf457976a9f4cbc0f0743406ae35192c46980ae5df7800cedf7460cbd975aa670147b69f355c57e10084381d2a16101cd3da9a645f1b852d89c4e82535748347540650580f8054bdaa0e0b06e7e3ae93d4577adc55743ecc6a39d1f92ee0c400d115fbc3ac831593d2609aa6c46107458d0ab6b8f1b79a9e92dc3c6b0bc47e5567f70d3bf6f103c340ad35e8bbe05919470dde1395ff0f97aac186f1be9dffe51079bae6f816a779f45beca82a64f0a5b481aff598a88017f88aab452d71b95014339b265a7851b88d88336e56f05f26b0136e5717cdae67eea7bd308973af0cf34bec68e33baf09359ca979d0a3336ade7488cf7b3a9251df73227c6645445f69a80fedf94bd7d8f76961e601fe838ea8a6de0b8545ed84f4d9659f21b5a7f7384e59c59d5ce95d8ba6138c8f98fbaca05cd607aa7fa6cc443c2d99744485e1e67b9c4e86aaa736248fbaeff4a38abcf49aa894ac4557e43b1d0b8a3d8802c38e32c323a93339960738d275134f5cad78569edba97d6459b248b93622c9fec37d730dce65f9505365f490fe9d3a8357a62b6ad78b4bd12cc74c5d730b3ce8879ec81e8b45935ce7856db740a15e6fcae6024b8bf1fef668c7916265f0bc6771725936818f5696eff4d1a9d596de8def972175beb3037a0018fca87529845e4d070fedf718dbfdd36589727a0b93972cae2416e06d28262f59563b05af38f8aedc9f8cf3442f519a0053843f516e0481ccf00f0e38903ca562099030e30064fe04fe1b0352c5be6bd46fa8bf9d5eb34da73b8418e29a54ec8f6ff43fad15e54d645a5e9d1ef968fba360ae25d58283e9873585986cbbe9d1e9cb519dc68671a2f4cd3a050a698a9ba1d5a7b032338928b90215a109a5d5b7bad7819ab64b2f05d9fd6050f97086f27400795c026217af2ed510507f2b0bf9c9bc336801f9157f771f1cd353d102b9d8fdc1d3c3d6eb30a7c4d797b188b11c95adc43dce8563de8efa2ace5a6ed4ae60a5d22dc1e94099becf4b8c4632a13515629130f57b6b08ee66caa3f81c5e1550c9cdce0cf8d0042e4fdce2fde8fd008651fb9922f088d12a68f5a874ba7d366b10ab1539e37a28500394bfd9764fcc43810f5922734d9bd2c57f3dce216f4d0d9d0de0d7bab8896a185c6b9035e46ba7a24b74e40726818c2aa5d661a43c36d32ac99e77ce35634461ecbcf6afc2818ccbac4b60b3ffcc8680d2aef91cb9faa4f255fc1ba8519bc4b41b12823b50d1f85aba13e14ecb26aa7947f8d3277c5dbced1f33dc3cd862f2aba4b4a948943ee3e5b4448c0a4955bcf9e7bdd1dac9ce341016e5d3550e1e5ef20d4e002e3e65cea796c5f27a1db5cf5bf2196304314c67ef8c8f2027ed60609071f36f254295421d58b0e8b7f6daee703d5849c615a5ec391083b496272718cc056ebe9c8a3f0e61e3beeb0dbad4ca2aa84246b8983d4d27171b06f421fd94cb5183f52e34a3c3b9e2db37ef46834993bcdfeadbae6391dbff1efcef9e27185c305270cd863a99ceb7ab77b99c2954dd715240421f76c406f82ef6d02b5e612bd8832b2ed779f3d02bf4d37402993964adca4a6884755c1cec05f4de7cb900f3aa45529a07f97ef7c6043766d9edd9616ceb0cb74732ee4229228e29a10e1427f4f68cb8e770b9149258cdf2f78fa582a9785c0ef655e65e88048fce5b790003c25d044cc1461b0cb9a142f0892ec83b944209629f5f3b13a6d99dca10437bacbde083cf7a9a5205b459a36e7294541cb41bc09180381699bb765bb95a7a7d223864072480c4d62f8da48a30ad4697f958e05736cdd3fab75743b48a552a766a8f2629adf11a3581f2cc847025c2e0417c70ead9dfde89af3d3f2803f6b23e43586f76a6ddf9721b49bdd6bec7081cda3ce34e93a0981277f0fa01e790ca91cb2735afe68a92a4193c44e97ceb6df3311bb1c9ec919d3064f042c67a7c63fda4d1b1ebe8e09103ada69beab30c3993cf78581486bf747b58661650f9d875b2404cf17412259cd6dff76bdebdaad5f8a1ceb277fb754c5a8e8867d450fa1c78fd8cee5d8573c6fd7c5f47a30211b95e402c5bb79088d8d92a41f23b2fdb1e1f8645a711b80fafe15fffc2085bb2a26646887d873ce0c4b5eb2c78d6d41eba8b7f124bae5f7f0ab7f786fab7a7cf6d28ec1680e471f4377bce605b840d2307689acefdc890ec3786278db12ea601df2e47b66d6111e009a0bed3d363b0578afc9fcb0c0368fc0c3e262927a3ef2142501091278bb34f25f11555d502a441f6663ccdf6299589812aa50e1d71c11711b725c6d9469b3af874adc4bda51e4d5e07373cadde55f52985e15f2c96ea7795d9f5f748256e362d7ddc0df425619892ab4516baf3d5972a1a4e8bfd1d977fa6d2f852b1e18ade171040b23214d3834f0b31708890e6e46f9a43f4ff69b14805045690f56eabccf7eac30b0e51e8b31727c9a4dc14fb0f33f9dd2f820f4bec8e7b4da70e3bbcb9b5a90b242fb76acd01162e903bd821c20db219f0627068c41a48e707c69d1687d3aefae1e27ce55527cec0afa3cf895482b8612412e2f267b624925d8827d1dd252c623d7b84282708fcd47c0a6584c913899639098ca61e53a88fdbca3dedc4ebe49781e0386f36146bd213c8b42384178a4ffd8db1bc00d1fea9879e34f5d603ff8f8832a68859c304231b4532751570f42da39569325d45d44c84a65fa2264392a6ac88abd412ffcaabf9b6e9a89f2993fefb1e5f01a1b98f8e2b723bf6974725771174ddd1c5f944b98765407d9f5c238fabe7e83fde0355afea01265134a72f4ff2d92a7dbbc8db78cfb110e823d9b4717e9b24fc667a72890adc25614048f1e6bb2941adff3b528326ceabfab98643f175056a911fdffa69daef537993c9a9d9bfbd84b6213898c076add69195656e6482c8c695cca59425fb179e5ee4a5ad9211c22d07c4a2323f91fd7ecf2294acab423bed39ee81a54eb0d5d4a742c3766326045b23a041c1f67e21f5c564206cfabd4cbf833392d8615b6c33025d187ec6340829d5253330fa8594e1675baeac89c9f1c98324ce9eed70f28b66a24ea776dee4d693cf06932cb3616e38bfccf355df1c25e2675c75e2c7b5f7e007bb784b6731622bde8bf391e0ee643d9bc37cfbb51abf83ca1f3c164fa9c580607d4b13c17eadbc4c93e416904f1b80574561ccf9db08ea51d6df651785f237167224d75ccb073e031ba2340480ca22f09dc49f8a72ec05eebc593d7e70bc6f3c06570c654be98fac960cbf2e339174c96b16b5afb0a54614afa2410e023dbcf64b3b9d0f4a354c743231a34b0d03b0dfa20d84b413fc4412b14a678d03341364f91c7e357ff477935d3e5b033d3917efe948ad5b2aa2878e196bb6158b6cad8f3bea2e1e383fb3c7c22d94b7598d4414166dc8bfcaf61640182c4f015a0e6a94fcf67d347e63b0ce17ff430e81d9b6096837f39223c51dd69e9cc0842ff2586154a39660026401eed81777953575c7b351f04a4d1f995599dcdbd286e851ff089e843fc6d461c10f08b8ce1430a119ca92086c5abf8ccb9e9c2a30affd6cac3e06a5d657439120196cf227220c84285fbeff93f11a49c49573ee29639cf79148fdf3f4ea13fbf2aba6612ed53457bf586cd999de35272fd6a1d9770fa5e6b9596af7b152b7c61c4229d58db596afd8f8f66c7a180f9cdaeba072c19c7ad3c39721b49ac1376bf112323086e1d6e9ca307932c7e57ff81145d48c58555f3b4a8421806746910bcfb34ba10fdabba6297899bf7dd1d1d2f194fa504f5b50190c41b1a7008119ef3ca446f9e32eed46d2301fad866912d251dc8e5bef4a33a8dd04669457d45e1de8e2855856c8e3d0004d16ce6eb608512f0c3bb18921e0a4211da5832e68ac1fae296afd196904593de4cedbfed7aaec38a89b1bddc45ff1383fe68f44f436bf8ff6f4276e6f90d46e8a7f21676bff690504b83270dde7a6931cf15fa397ecbc199ef983fedcef1e7822cb48d9e07aad6a9b1e3ecf9f950fe463e9c98f9b00b3d1df2d09c01633e5c3b3218da6995cf79fdcef39ef9a1b98c70294301af2af496a0a582cffd1ff2fa4aa93da2883355e1106a791cd62e74beae5515e4fd4d8c1d49e35bc7c7cb630792261aab9cc99b7cb6c92955b1fe947c58aac101ec19ea9553c42b869a71cb17546e01ecb389ebc2f9426b6637a79153e71a3a026aa714a33a55006a56b4b9438d9bfceea57782742a643f915415183754f8d963eb4dfea5f573c12a0a2913ac79da70d3daedb88f6465d8ff37008502d1ddbcefa72cd435d1051265f337b278cc48aca63295d0ea753dcdae3358ad0b577614612b1ecd58119e513104b8b42728e556e66cca5ad6ba7afe1d0b04ae92e026acc3a74aa4385cf8ea228326f70ba81127ac1e3f2f8459c5b4fbad3bfa47ea0de7bad95a2aa045fbe6b75f715d1af82db8290d8ce5db9a396ffd4789e8d857d02ab145adbd6f3197531b5410e6d099c6cd6021e44f820b745fa6c91ec2d73277f83f317741cdf86e2ecf5cc303c68195ec2ea209f97348dce1e2281be7f0a1dfed6e8d577d9ac6784b1c418bdbc5fb174a24475524bdaa0ff06e52be2a45270e1eccc8f5079bb34e2641fa060fcc75cced6fab1e2c11020c962df3cea0f46c8fc00cccdb44629498aa57e0ee2c93c091de76ec771a91b7520bb628a43efc0abad7f55d02f487681bbbcac690c75d76ac2ba312b1221ecbf9845f48c4fe8282e48e29da67eaf13fbfd3041f6c1e2f8f6c69c50be709fd86bff1c09d9e8040493809f6c736c2b8b04509d054b3240ffd395e1027d1c087dadfd4a01dc00efa05bc58d1e9e3208c4179406cb47d51c6cc8ec9a9ca7b3419f73a45a0503b78ad734cf427422d1dfd373edce158fc446cf7d2130781e4a2f479403c6a3561d0035101753182606bc44874403ba3bb3ce94c431e70706d5f6f5f69892cb0617cb363623656f90fed61fb90d6cbef6db3b84ce7f5df3c48f07ab8f4ab99521add672b5b845f0e4e0cacb3338c41c365e579441570665eeeb2cde12934a9059c10f8421cbb8559ffb6586867fd4dbe51b5a9489ad5513b86e9e4034ccf9c59366fbbc78bd38d12637086a0724150d03e6d676462f59b70f6a681952cbf189ce186608106eb9c2ce29e21434ec39771dd1d4f7894c0abfc5258e7422acd1ea3c77f7afc71e4eecbc39329fe5f7b107efce48e25fc7dd1c645db3f700f16769ecbf30f8190e0f3938f3658d2274cae597bf10219190e6b346e741516c45ea6eab16ce42df8fa1676fe5ad436ef15fa1b06ec3352908b2a724bd74a9bce79b4ccbbec1af6d2aad814793468623dbf4d06592af1b6c51ca7587c38e812f776a0c2e33d384dbdb3da7118e97c6b568545d5e6f133c3bb97cab9b5e52cd73e2efe30b7aa40f93c3995418bb06d2acf84afe13a2707d1fab547cc36586861da15afcd76df0b6b5eb969d48eee6725603e4d07da0632882445f220165171ee3ff2ab8ee1397b3b08c8d93f54460c26e7533eacbd9462bbc9ac4773e8d85a03a94830de808e7c4843486b4bf439512f78e1a40ee02a4330e87f4e667478e2735ebdd842b2aa755e7a9f9c56ebaac862557684acfabce4d7b5e71b1809d790a5da2bc7ea63efa427c0fd09e9879193d3211a888d0ed79d9ebd11bf711f2872e1634f08a27293a77c60410ed5ae5321e8987ce7882d83e22ce6ec284289af9e6551f87b4f50cf6a6648d2cf9d61b48b8266bb6c8706739a092d05a561b87cfa3752783d179aab85e947d91426954adf8685468c0473d1f53f05cea739f4b636084ca920d8d1b5beef28c7aa716113f3d6e8420c86c01d2b634565f451a3faeab339a64672009016262b9e7e27f189bcd4360b3711cfdd596a5a216f8d45f717aa94cb6f10e2bf5957ebe7a6c908ff28cd436ca944095ad6cdd1a6ad89ee48c03e0b0ccc223ce0a2a85a6df79d013282c2575f6f1e760b51fa1c02d58efcac6422ada20fff3c42cd17fe048a179e464637957272a754a276e50e21c1fd59d41d7c78b77348bf3614630928dfd6ae2c55cca5efa7d7951fa8743a53556dc1f0392a4655b81cffaff501a2c0a9f448cc30504a4a32672d1fa122924e04d0949e79fad42510f5d278520de6249bd4152056da2db97a2a035a8a9b68b69152010566de5990e90a1a70fb18a72ff9a2fbabf679bd232ffc10924d196a50c0064c621e80fdb1e15becba8b0e034e4450e268bfe596a5b7a765ae2076c73ebd70779968b7a597334b146423a82bcef91d1fe3c9e4857e456e4959de5176d0182e9488268eb64e597a830c3e5d0e84097eedc8ce3ff319b3ad7495bea65b79190b9d6aaaee48794463ef18524346f007bee8e396e2dfdf7cfb5d38c9eefb9421fc07bdd18b0533cdf1bb67610caa1fa11fe7c15560e295f8ebb2258b29eace39f528516e00af24805eba2debcc2f9556ce918afb9258b5d4970068933a8a8622ece39ab07d0871e48d66f33df604445bda4ad6d0c5a206d37dc88a6cc57a66ef681964262dedc5afc1f9b3c69d0976b311bcdd34636b0805fc08aae1e5bc6fbd630d5ce99850c71eafd29f9af99aa9727659425493fbfa9284393e2f18604a0a9b0655c73e4e5219548c5db051135c8ce9f02b6dcdc73f6cdb25be2a7afefeb2a6b207cea6b204ee6b914835ea3f2e8260d006827c60045fb41740d563d1d06fa56ae894ba7787ba3cd2f37df2fb40a7f1f16bc5a5e37c03a375c3087a1e0f67b315a0c7ccf52e4afe15dfa8222bd8ecef37333108a0c0b915ef816b158161c1b3597b7fe0cbb1799fc3bba8611b1b05397390835589a4ccce6c6c8b3da75ef62e94b72733ea81c38a9f65f7565750d5ea3494bb8d84587520b0db45db0a06ae32f693e0aec0014086a1209a8f7a67308169bfe4d5a254b6cedf8d5a634aed6f76596d9923174a3b68a7dbdbb6f3fc05a6f701b4ac5b9e5c6986586f90b8611148ae68392f14bcabd163ed0833ad5f606853d75d6e3a4b6856528161b67e55c14d0dd90ea438d80e719605af0e4519172ed2dcf4fa7740ef65a9712777cd724f9df5d2ec0c60bcce871403afd5e33fec5fb984066bb5b7e960e09d234520e228904d6de653d52cbfbb011d9993e0ab30183ff052f7fd86cb7d553d9caeba50257ca6fe075fe619faec3aed11720230c2c3950782aa1b49432725fd8a8a928f63c410f85edf7d62aacf1caccf7a2bcf5172d80b94aa4c3f7a966667c730a454ed59d005c3f7337073defff7eb26313d594d26e92d74d687abb1764cd27c5cf2246fb7c171c5d51691a8c023e43fe0115109ccf614bd63e81725e6681431e03ab71d85b8683d51f7e60ab8bddb98a4e78c51b70b7266627d2435236873a6f4cfb390e564657054ce6da165b30cc5902708d47034452c85a99ff485d1b58a073fe8ab5ca1c593de2d575c41a3883470419723ca242187586a7c50fcbe83e81d8bd5f4e49a7bdc70cf69b755aaf47c612f7c4639a992218318775af4759f82d2185749ffcb5fe9c30b2ae78bb091f4e3187312276881aac0b39a5826bc2febcd158c0721efa8bc2dce391314bc3c909097c41b3d14f7a5f55d7da2fd8b85c16c492db81c9ec554cbcc6c522d3b0a75e0b5363b752991f83e002c7eae1652c9998ec93ce1b7fa8d31e578aa5f75fa7c6e3fdbcdd64f1e217476185e98b649b3296463ff729a68926547a253ac0b06de2a34d4b087b1c9265b7802f435b80473e24440058d3cf76ae5dd3e70f4d88e9946a9f36cfeb888c5398e95d97fd1fcfe023b6386cf102858682f27a6e55d09466b0485e17e6e6f969349f3c6eced6d4a48d196ae3b46ca0ce0c69a1a893adff4baa39b31e1623496988598b2ead6493f9c54f57abbd1f1936651331e4d3bbb9385a10e6aff86b7b1335f9872426e673d35bed461102dc62689657e3c934e622f33a4c74e88186ab7c0436ae3becd7a15746364c8e5d38ca767d137743499ff85aa740f60c39af664b553e2135e0dbf29f2cef9d1048953d4646206031f0d11cdfa8ad9da5ce088f92bd8046855e46adefa610d6f1386dc937d1c5f80970c1d9058de1850f7c3fb17caf057bfeaf0ddd46d0e32e8de9658827875c19c71b473214d3cde1caea61dd707a20f36f1e7e945016345641f9165a01c59c647560e9b03c730c99592db373297fea329e6c5dea64d93aa07c5cc86335502f7c58317bc88c4355e1304bcc82e68f50f52953354a223f34b6b40da5640c0ec8819f4463534141ec2e099f1a6c8f805da874227173b0f90c45c2133043b56ca1f35c6205eb037b42c75611debfbebd805978c55475a2ff8123251a1abe2d8527c9fb714b940c022b2717129b704bca47b51fd4475c63a89b6fac61219f809fb95d2ef403db401002222b6fdba189eb182a1ba79f16412126710253a49ccdb6b124eeff9beb38b20b0df3ca6be69fe465ee5280c5c3ea29871b9a5538e428668125746bb69abfd0884d0916275d96d9a8108b841d5811d0d2342ab7e8f538f20cfaf9a4b9ec6ce7401ff744ea467a9dc82f50d9ccff888208a4d84f4de79deed56efde6c04a731fd6e1e58033a02604bd5efc4d8e9dca88a2af0b5fa3de5cd94c639fd0db6787cab142fef2b6d389acc5d317e9800074e1beebec427dd4553ffa3c4d819139bccc568faa70bf4b04ec67d7a576b6001b616ee366f2c2b109a58bf357329b391901306387637e40f62d93f65b887d4959a5930f500c688847697f5341f1da83c6e537140af7b742c16de04308e6462be5ca5c1d1030417a2896a3cd571f0e590c69918a9d8684936f4c0bb3da1ea699565aa51c4eff657647bb29fbfa9fdc5675daf411fdfbdf4c5b856e3a3fb2cebc6d749d9a9cf2ee76e82e81968574c77a406794bcf0dea831881cf9bfd7ef0ccf8ffb9cbf89eca124a160cb5713f040f5cffde52e1908da40f2c5e22b273cf343b2ded7ee2d210b342a6b438a0b08b39c3e4a295eed92451441f15be72d6ca82bcfe887ad69314a67a0958ea29502cf6eab0f6fddf71e04db1254e27fc917b5ec9f6090f10f234ccd62c8b67808a29b4a5e28b64842ab5f19dd4d0c0f25a85f75d88810cc6ffbceca5ee165fe3df08abfdd085b67f5b8e45054689afda4e756f826bf61935c58b57d30bd4beb5f94e2138eb981b653a56bde20f79f8100300854da0b9e7a6a30bed68fbcbabf70d8e2cbc116a102598620fb8aac07e8906a84b4ce2d382cb6c9a4767bd450ebc53a74ee685f5c7ce2c851ae218270dd5158d8a8220cbb99a41d21cda8d3aaf22c9f89420b1fbad07550ab024c326064a9ab5dd45144b5445bc201f369d7d2ec59db412de8ff19a42a0f4ab8593ede4671804450f28fd3a3f71268d754b7917d153590598c2687bad3e65a50479ee01ee6c85ae1eeb9a737b4e5a62f51b234f254109ece427af7eff8cc9e8262c7c4129abfeb6ad65803ac32aadb4c29e0330316b02be4c128814b2656ce9e39bb18dee32690a8bc60124ff99611063d0b3ebbba81db0d156f8f4bb576baa49090b4302179a5a58be97c56c165d9c436da54287b566f99c57336ae46245eb8de6c3461c064e50f7a67f46c28bed71fc2005a88fd8a393389cd15ca6d84450ebd0906ad930f11dac47145b69677a508d305a19b0c323b267e269e4b6d831af89ee1bdce4418edfc01cd5ee3b3e61a45857cf10ae1690f4a4f8260797a4b72766ff24ab5bdfe5660b4d84adab778a1778902ae1f9ab40b65ce0e3e9475c2418cba660af9a4cb41b3f316bbe16b6032b104d4d669c5cdca1ec374c96fa7d664c7a247311afd22454d7bab51af9042c94bc8c1b3095a8192626bf78b174bee1113832560f9e5bc1848cd496c05249ff66b54e6dd03b3b3e498f1aa27eee256ccc4d798c98900042f419f2030afb4bfd7896e8a751f4dc328822889633574121e126c62b560c8cc8575e57d2a6b22c72ce20e6c44c4a3b14cff872ae03eef392a95fde6386a81e1da19b147f55db6173947465dce94e904a4cd0c0087b0d80ee1b77fc38be080d9d39371a88965d17d6c134df8e7371cbc8aada34aadcb7ea67104aa717fd4d1bf4ce66f5488e0afbcfa06529974f725f1107db3864f9ef46082a3cf98d5b9fcee61eba7f190f3b0014e4aaa97510d055555e4f76ca73c593c33c4160d32cb5a68c9124eaf04bec77be89f8080637cee0fe3ad66094c32eee83e9aee227dfcfc7bc07f295679a9003b5028b3047c31f673003925334b1bfa056ba07ba2754a13b220e003e02a53fa87d611bb5f4117522d886f3fa3ed6d12cc14545e5594b87ce279be994bfb62702a15e14fbca56df84ba683595736a9977f04af4bfc3d322a8480ec42c82f2a4816630babd582f76dc317ed577ffc124a9b3b91c6bdd5984265a968d98a7d04ea041ec97e576b248f93793ae220b4770667c026d4e6f68cfe81c81bcb1c3a967c76056e066b26ea340486c820085a46a21f17f4d2faec7a254781231fe2a1b1f2434b6069723348736901648888361a569c2c7161e76102f3b2555aea69a5419d4199c47c96c40eae4bcfc3844bdde7427d9f2716a8ae63596563e7c3d97fc030b75bc4cedb0064e2b7bcb4f9ab483a7fe92acfeb4065ef3075171d9fd85253acddc2272c1ee1526cd6e4cd2cf27a5c172e0e5a00ce9cf9c27426c485dc6607e5b135c0c0cef886ca7f75c1946fb0de1b9a4c80682c493ec640854e3431c7b41c0aaa7f695ff765be412b32e3fcb70a1ef6d38ed4da9d448c6131bea2febb57c0e14f86e8b44c04eb6068a3a50e7e5114f39f89ebb35aa9d701ee75260fc5315ddaba88b3e35bf82c3f0fb7185b5c0657dd9ad4184ce3e5a40d3de979d82ad54155c7b57f171d9b5294d318c6a3cfce5b6e613af8ada46f2951ef1432edc1119f1a7c4cbc7e30363b86ee2b88e802f0c8d2befa726a7ec70f08fd745dedc09b24d4e31f32d57dece861c397913e7b2171214130485c2f249dc8039c9d0ef285d3d286f5ca37d0d07882d4392a9fa15ba5d228d9dd778c52bf612340978c62881767ec112bbe57430e81e3eabe747ad4f714ebfa8342652a258ae26a3be635fff4ec88f0e0e28c14e150e658dca318c4098d5ccbeb5f05a78fb1dc3c9182c20c51b6cfad33b74a143238601fb60e94c0d0238db6a6ebd6347ba0190f5f0b366da34f08f45fdc10e374a1ee26ba5a39536d7cb0b797ad46ad8dc327acb7fa5e60ac86646e19e29f8357deb145d3229ba7f34b4f9a7b8f0a94ee14b8f63e137ffd9b164536fd6c8ddc63b7aacf138da76242bde4890809675b83ade47b5abbe0f1ea574059295ba852e0d3f60cdd47082f81e90f1779e543169c7190a99f242aecd393a16853b19cd663279202814fc4acda1edfb6e9b06d2a58091fd4e8a682806f73211b5c80b3892be47248127b22717e2e335853e671d0f2f14e5b9a8a1c23a2c091dc0027cc7261345cba5d59ebb5f61aac0863f29c948d0ac1b7c3824ae75b7dac85614d278f2ebc873c2ce42b461b6411c76e6c0be2e7eaf65bfe69988cea6e53622d27e2c55239306fc7eb819a03b9cecfe8b73c61ed75a8b109e5e60227edbfca6b05874e39547d8e04b6e9f3b23dc9d8522f575f395a6ec3971a9c55a004f7624118c1d278c6e6fc25a0d7baeadc287340cba6003f42b9341885485dc663cb7c2736a630be48cab5cd1a17f756b2445cbfdb6477a7ff7ec2e694f2fb4bdb5b9c707edd0699672a82892788f2d95c9f175b55b8a2715aad2a1595058b45f12f1ce14ef147185e7e8ae698613bc4bc1ab0020c7d8b6b7ec8177ee6e90921aa4076b7c941809dbdc4e8598ccfdb63299f3a2aaff5de851d6178077018ceee8cbf7299bcd6246b353b16fe46f6dcf740c6bdcf8beb8a755ac02ff567a28170fda0c9a4021cf178b1e24971c3fea6f0cde88aab86da5f08e6d0eebc8bc187fac5c1d8ee3a469b6957e8c44949f204a76af972e5b329de8e377b7f4ac7f0f5fc1cb0f745e89f48b37f9b2443add6e2357bf462b5c30cf05364305a57e1ea1347a26d82b5e9e1f127450542aca0ffe72cac683ae846d4b4d0ef1ea9f8e5a5cbca2e6e8c394c74d6e8084ac18a8f3361d9237f0ccb2e07a14b10628aad0ee4b6419040961dad09f889e0e9306e2e8a7857c2e0bf01a1bb2871f3abb5867d43b14df082f363437ca6d98052d2cfbe133da75eda19c314ae73c32bbff62104eedf5fdc62a8c9c015c82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
