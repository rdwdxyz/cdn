<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bab4d001f664b0b70a30c978c953a87633bbead233bb0183525f9c68deadf6fee5130c887e0289212f8d6bae3f57dff06dcd012f8bf0fbf27c3fceb95c8b195f5f6618f0f86ed36342720e6b3eed105446ce11dd48668d842651acbd791576ee189760c3df5f959f59c89bd5249f905377586b8f9122ba30f9c959cb7b1560305339aab12651e16bf61efaa4e84381ef482175cf5214d4dc5172b8fbca042e0f244135b8b609e174611a1b5165fb16172c9f3c856f645c84cb6f298a87fad2be51bafc5ae591070997544d4e018d7cf52a47421da71ec1a7951d699f5c356e812b47208c836adeeec2be6930f65df48541afb666a1fc513b3c03d0ef681fa276c3a7eb71f8059e67e5602dc7954c2c0e3b75d944e8a4f1494ec7956a6f62c90554ef574d007141ec74d3315207981e177ee1870e04a3bc4a15c2674002fb96a3d3699146eb4573b5b20b1350d850821a309b556ec71e013d33a33b3cd42791baba1b3d0283328b6478bcafe9ed95db5059f53e18a47cbb12bfee6fbc9c303044b519e1f7ecb66376990720ae41436dab3a5e454076f22628b5a7f8f7c6f7fe391e7454d3950e02899a9a9eef4617e1a8dc7c87c208f8a7da67604182fa691f0955cde7a428ae246e9114d800e0af188b817b2565ba30be1fcab2bc7b86122198943149deed3cdea6fe25e679d40c162020d65d16b8857eb072ceba6a349fcc2e621417b843ec526fcff2e88af703394de941299086188b445617ab6169d004ccff535e06b381a0f482adcb074efbca5cbeefea9bdf24789ae6aca9d896ccda74e2595bdb4503f67b8a3c68975fe3af85a32c59f497716309e4db5ec71f105145a0f3bd6a7eedf8ee3b1082c9aec4b2ac6e131b5b2e8fab45a078770862e0b7f6c7552b1f32eff476229db4e41b938eab3da57dab61716a74b1fd08abb47b5de1c07e738907d16ef5e07e30ec239935a04aeb43a288bf6c1b23c174bb275b3723fa4bdc40f58d430079cf60eb8d0e405475fb73cb00f888d0eb705a29bc5c478924855cf0d67a1649fabbcc3b80e088650a2154d9065ab8b3b2ac9242623a706e125699f923801f6f3ec8802e32336298ecc7be35d209389c1a8770c9126846307397a88fcfc124276bf3b78ce1b81002124a26f331457ae77c93adf9f71da88f84a41208b8bf9906d5c1f6969730d217df1bde01cf87a714b8da2cab727a3e33a2d28ad4222d2451664284db9c21a2e9a2e0bff8fd2a90795bd71eb073f1f72f82abab6e5c0da29877fe50868f625ec417e4a3378e5a9c81b950f8ed9b73947ace178fd32e1734297a7333e1b9cb47c9815606dcded72ba3b554833c9b39b15f1d12dcc29a9b458a1e4564a7dd387a4827b90fb7282a61d0f00e9d0bac8122154de4d53ef51519a39efd8184ab6ca2896f93bacae9e5d923b948eb7bafcce9947d801489547437ab88087aa636277e0c7fa1e184666b9f5741cfc7aefdcd76612f980b7e4297c781e3775bfdea8af1bbb065fe1118929fe6d333af4ecb94c3c9c8a42b22abf5252af8a5a137f6f4eea496383b690891852b183a153460a16eeaa7c64aa083f71152319bd0132b43712c6207e5d57f5fb7e284273679a49c3b9e7c86a8aeb5919395fcee106b24ac361542c0755e21d0fcd7f395dc88efd83bd822a422c2d9480f8af4c525d2a3eea1fb9034143bbc9e3cd3c5660197bbb6bc8da64dc61be06548ee873221ad6ded3141cce4e2cca44f90e0cde1f2be1c37e251eb1f7ae413595ea17c8f08a300b9ea6aa6bb1d36dc5e3f0d4a3048028c40e751d4531d278b11ad73637800bdda1383cf6d87687c1f2fae9ec0c10ee861b2b5e8f55d0e75987b2ee1c7182a51a18ccf2ab279ff3c65e33902f782da209e51c939e20516a125b53d58a5f97c8ed27abdc37f246bd9597ba9361a992b2db40c4bcbf3b817ede73a4dc43bcee6078d147a9473f63e446f8b625730c3c520afca59ea7bf356c4e29ebde8454062b083ab98ada8e6b1747c28aac6a10005a4861ceae6fdbd82e2e86249edeb54885adfcdd901fdd553057152e81071c70383c5efa02ec00b0fc353a18e7c52cfbfd3e765d5117134ddf1f8377145f10fee5b7b62649d875afc603d30e9944b96e3d02a6d438f3b76ca4e42ca930fe2563b50b86f704ee9c735474ed6b6d33a8bbe7e9c71185636e5e121c7bd45294690589e1434e332942dd941c055b1e0d8b1569fd48405cf3bd01ce1abe65d0102aa9f7fa3dfc3e8f1d3b12a5b938cc105e612bcdc9fed83e8944b9c0ae3ab2760db7380149e9608223eeecd64a8dc5e5cf2e2e5850c60b077262d73f160db878feb1fd124c4700275701c3ef729fe020f3216ee040c8874957d32b8d5d4b8521ea9186f54953be0d2f10d6630239c501c8b5cd04d8e064002779b69ff0ac6b2dc69535d2b62ce58da0523a31790d2840ba15f2871684fc0e2fa03f305821912c438b1b117b2212cfd0d61286cfdd1c2c7c5ad56a40365935677aa379b9bb5a81803e2051a8af257caa8cd1d8f1cccfe7081936da6023870fa9deaf365a80f83d62705c28f6ac49a3a6821f628f9a65964cab322488aab58a70c939f40dd77d207c649f2581f7b14b593767d4834d1489458c9b6ed554799b8b23ee99813ff558392fe79bab5ec870b149c95edc4fd53b891f728ae7b5f022de21224573f57e8b9529d3e2ae63dea3f9538970bc5b3e3e64b6cf331337a178c0546769f14e355805c63efe6dc0c8c10a140bc98ed0b60641881e62609b83100e870df947d7324719c90a18929287017ab9cca3a8ee288f4f07c0ce2ebfda07d4f9ef4ae442d2ee0f871d32847689dcdcdea858c90a4697a15e7696a1f0ed9299487ea90c15ac4042ccf5ae9ded2c5e6042bcc632ce4e2e303183ec53d0e6efb86f261da896dbb57f785e0536fad108ed86a2976eda92d904f72a0a730ccf6a8f285a57d778458949f3d8b6f868496fd79a6bb5b3c9cc90a39b3974781da1c89a0110fe08cc2f355aebe4492efe3c0a4c1ebe4be34464c72409b7b3f5be9cf6851a204ca34b3587e0fff08bc56d220e91f87d7a687b6f840e35fcc8444d8e38e1e2466b90b475bb18312036a0a1a6c439913d6aa5633981c73400ffb336d14607ef96ce5291ce09e228ec0ad7680679e34778697c3ec8612be51b360786a52a2dff59741a969da0e5c18a8454c4a60ff8dca819712dfd8483396b4cd4bf9c5f705e00e6e0e9cc69733b3ef4929c2ee493d3b574c4e9e8a89af026f5521cc5f4ee1dd1b88a4c88445f23293cb90b7de6f3624e94a844ef4087028754c70c55fe2fb49bdf1e5b39e9d19bc98fc4152eb37615efdac912ab780961a9d1e16a84a60a16977598c3f72f0d2fbb5b8d34416e98db4f76d901df885c94ba5a11b2c70b830d42dd62f4300f48a3fd0006a9b41fa9c16383d884065cf1405b141bbb74ff42c94b8dd89cf3cba85f8b04c51c020567e504a1e8cb610a12bf4220ba5256e097be602681034a85837653622a4e02c043504f95e17fad6d84b6c39d9142558622fd41ff98fff41ef7085e301e6694a310a812d1a8a1337a781bb928d87b4dfc0c467e9e166c8285d318d58bc0b86322d13f1110c99881026dd9880d62f46662e814e00f315a70d14c16f838fb87172fc791e2009385a299b6eaae212e51977b7cb17eb015cd8999b895cebc3ee23816d1af255a3ebfb559abb2d51f8eb25b9ebb019ca09181bf5e2c740bc99f651baa6c847ed3759f446d1e987c48b52ccb5da4f343ca927ec0ab554bd0a6771c0ceb1eb427d397d412575d89326a40ba6e08fce92495b46be137226b07793ad30687b1e0e12676ea8dfa73ade9032231934be97feb44764a701bd272bc8ad5302cabc9ad635e33c04ce4eb60c38d55cab3cf1fb4e275934e7683d3cca897520851556a3c39d58217f7ec9375bbb0403588d92b276480ce4225c4707f0a47e0fda52bf96a90d1d049e5ac27e87b65a06316b5908aa2eb936ffab71d98c39f7900c21e9f08c6191efda1637abf4fc78c6d6590f847a00f2974af40318aad01c633028bede9d275fa3b2d87ae484c5f86b97333ce91d43f9cc47e02fe48836efab73e37555b7e20a1bbfe5a7049290d39952dfa5498ed09215be6e9b7f20301f9513784ac51d8ef250b7ad387d2d9ea4fed74b78ddfddff3b5a201643926a6b9b0b0cdae41f6ab5b441d9b90ecd82fe058b407bead57aa0c14224d873fb07bf8f69161a325cda7b9ccdce0b18393b987c9f1392c6483f634fd706807ee539e9db68b49614dceaab6f2d5f125db3be7b046fec1a2dada966f3d2556aaf83c16572d82e6197f394d81d765add3ae4c0ffcd313671d8630d68a1e6bdce49be00ff87aa0c062a4171d6d4f6b5b80d8d1ac4516c694a47b141ef3da50ece55f82542e6763feb5b8495a5ab3747f6ea2d68fa7963e0672775f6ccfea00c036e8d8b854a52270c666040b2fbfc88809abed3c64d8d207e8c3a9a988741dcb81dae3981c4de211b61a577c034cabe11b3f53cdf95dcedd89940c90f207e7800e949cb79b602673714f6da63270c591327cd484795efcbd85d3d492ae031e1fb1ac65d9c2a3dc9de22a48518c56834022617bf0e451a6ba25fed1f41ee89e41f98e296b2d23d2af1869ac0d4412c9aa7bd7b049a4842dbdaaf2991f40226651124fbeef02644bff33414851f32eabe4b6614be1437d22b58d776f151b12d2a23a5d6d78b3d06c68a953857ce63da4d5740bace9b485aa3af8588bd19f4529c74086daff398ca42ce22de143290e3acfdcbc949bce0215537c2e92b2f518422fa222ba78825d970facc8174fc7eb597b75a37000c46877465cab68431c970246387a7a44d63fe2b1fd481dda83d69c858aaced3140266739c733caec84928cf83cd05eb438667c480cc7849d94ef00e99d432115d9f99241d10573d84daad9db86c4c406531877256f8fe48c9e34e37b24275c7d9718074e768084346ca3f5d56af4c9ec5a85691951b2a4d560ca30a5b101d1a0e8d4e02d7990f8127fcb8c38b5d17e5e4e1b70f84fee20149185a5b1b06c38e2773b942c581bdc6717e43b97660ecc9dfafb2d503c4664f27a10784dcbf26a97c9681a48335fe15d9fa059118f7a461c53d0a2d6f6d66ae798ee7b89621ecce1672483b0996999ffe4150be81e3e91b4d202d4ddfe7f20573c36d16d14d62899ba40e2400dd2cb724461f5aba747bb16c35822cbe4868420d82235320d39982c4d1a38dc3560e97d2c2d1034cc7d81e8476e0af2206a638d30e668f778051d0b55d47bd829949c982a3412a098e09b0ca418e4b9116ca3364b9dccd8a6b68ad22e4baffb8953bd0e1375f410407b76c4ad28a4ab5a49c3ea296465d99eb36161ee9b6f9994edbcd40df49798482aff7acccc3b737c3de60e7011cd10241213397495d08e2e98a2e50f49a70cda3e3685d3f74a4db6b472046f23f9691aafb297a94be04a63e1ef946050fb54947b7183480a59e97b848059c7fef127983a8941777e7147199317ab39462ee314a82e7571c5e5e22ea579809af6da6c2af9081015f260d0fa0d02862ffbe0718c11d3dfe25b7304d5b8aad8e417fd4a837bea05b6b1413c409e209ef239867a93d0cffd76c1c1abcf32a10b72d1e9179aaec992f436be5df01e19fc0722fb5da5f14723132b33e74254463bf19b4778ce66940abe63f56bc7f77ec48447396b3a5d7f92872416eddaa414ffc579b2e6c0717778bef9675a3ac30841e764872c0f83dec7abf6c70895f815f949746714420025c780866c1f1c2df99b2bcf9b41cb3ec60c4ac355e3b3e244d9f49c6b8241311378490fb12bd486b5d8c9744c6daca5f067d973a7491ed600e6bac0424f0d4ba7fe0e0dd31d72b08c28f40b7420ccc667b68c60f43edb3468d1188c095185607374ed03670296a77a785b18d914111c799c5faaf53037975e3895e4f94e5bd65b5e2165fd47ff6dd4a971469ee721c3865ff421d63bc3b550895d181baef8b4f5a81bb27df9e9075b8e52ec85d308c23331f2b21a1385f917b23bac7235dd15ef3b048e1b896c0cd47938ae9ae96fc8f4bba150c2c7c6210b23205e8c6c3af1a98c01cbba7cf6920f57ae486c0cd0157119fcdb76e48243a96af855f54400b84bdfe2f35b09bc15ec0db18052cbd17674b586b200fe81cd6487e2398985a6670ae538f2820a90844015204b6aa6b2654ec1d97e1650f74a9711ef0a23d5306f7966b1b7fdfdc674f0fbc820084d320223df7094675cf5bd5cd803774edf40551df9b411e444919679e77b8419515a061ae425d985dce9e74a3fec4be3d83d5e328ea72aa9de1e89d737700ca79282869b78740e71001bb81966e5af94606ece1632f1435387cbd3d9e88d7035bd9bb8b402900f66b742ade620fa26bdde36b4e37babb5cdea25d374d4a55e2d8160286b90e68baa6b00a2ad276a2d71c6bf7dc81a02d6d597d7044d561561eb0a0647192afdad1aa5d17d84ce455aa1360cbee1d1e519046c03a34a7ea8e2a6b0d1a48e8f54c82958ba67f1e8538718de9404cb1c6f9bc9d5c3a7e9c9c5e258856c339d4adb82cab1593daf900281319a61f7218977db82a9f0db6432c41a44b3251cb6de7a3ad82bfa3a32c93818f76d71f0cd445868442ea686225745f0b01468b0e07645a5d48c74a3de1451658b60a8085076f8be21b42885255e4cf920a68d6c18ec39dfccd3757bfc0f4607e1bf1d0852c9d5d95227a6445eb618e615827e2adb9f2f798912098a6c6bf489f788b995578f7ca7d1e8609947b00421389462b074c91b1e5f7cc3439ff00f15f6d37f8454901f719029d614374c13fb182cfa16aa3f75a4108c80524f8ee93d312221b7a6bf149acaa6a4377240bc2e90dbbbe0451b036d13913338e538e81e6ba1aa5e6ec022ded49b28b66379142211c3d5f8c0ae49b670257a4d37758512e1f597bd54e07c39975432963ce66be76582010b9b8019afb7de1b9778ceca90fd33b19fb1a84a3307e4496d113d6ed1c5faec20404478542c025d57c51322781eb8a028ddbeae720d39322daff9ba65d422a56fb6ad8e1dae7ecdd086e6ae91149f9eb6163154584be63c5ca5b80b8091dbf04ccdbcb38f33f6f26b5d222202ac3cc0e2a1dde10919fbcd66410a91091999184adf5503e5790f5682938b020cea9af1664f6fc04b0b8c92642c52cff5cbc908d80ec0735548aa1eed516844e9aa7180830f655aa5ed23bad7177a95b4225b04b11a19642b7a4d4b1ed501c97fe8ad191beabcf0ebeb13d84c04335764bafaa918006fabc6f27f046b710686455eb514fa681b7a252e08f7dd48861ecff6fbd0c132a5136f55c2dc48dc7eb577f707e663c23ecc5cb5f328e176784c5558bc97ed68efd184307e2c1d812deff91479becd6518b9ca38e10dfc2c485904828b0713cfaedd5ef430506dfe7ce78af389bf12fb573cd9a0698c1f979bcb18acaf2c7a016b5eae96129b29412741239b7c9ee2592c3665b46e02a9b12b318a146af810ea768406851f64d7c5efcfa58a23c3f7bc982c2c868d58841bafc5e47f66164a0fb632d7e6c939cc6842b695764dac8f289521bea51a5b6cb3a2190fc1ab8f9d2c3bda7df16904df97a95f1015098ce466c812bd321a62a98a542e51cdb54e08f7684df60d5d93f18555510526154244198f67ee51741e8740bbbe726cca4337502368b45f5ddf9861d55fa11b1961bd6461ba8d3ed3156d2a957f6bc97c2b31bbddf1179a8a8dda650e39d6d5adb5354a8d4f108326a162166158dc217a22a95cf116b558cf477d59275ebc4726b33c38e548e441ef262cb97a1e29ff9580ff3f23552a4175568847ce4748cce7fd68e69e2c3ed2176d11f867be18a06b7731b72777ac979a72daff27889ed8ba88570fd36d4e51e81011512ec8eb83ec439f1d9c3e431a54758adb57330e77df8d8738422b7bdbb63c2d37bc8e3edc21dac17dd5af498f2ddf52b7c45465308a7815b4bf6f86c328003d8b9cbf00662751969dbf5708df01f6655d969ee2bb37dcb6d2a999baa400c2052ccfc1e969c59b4e8ea7288f82fbbfcd205db9b8dd95d6304f9a56aa98e9da58b81c86a768b7c7534fa2dfd4320ec075a2fe2b7525ff04fb697c1cc4b3b51844c51b56b91287819beac8aad5a4015046a21ebd0697e1dfd61b00bdd2849f20c51f6e7810a7c65d9919cdeaf0aaa3906dee3139e9ec2b34ee894813c65fc3ee3cb82bf8e01802ec2097aea9e5a0703a05f3c5e31c88b9afb05857ea9ebddb0de3afd063dfbc75657bc718b5074c66ab71c0a1e0f833d915b717c6b30a26d157c29f7500437e07e291ec5a5815a0e37076387fe8813525672be00cf0856a51af08fc5577b5ffae0234e6f5ae972296aebcdc02984e560693e29ce2259f1c5a7dea8b4da754571b0f84904ee356189e0ec6ecb460e03bb56fc9baa44bae62e2d58c3aba39915f8040d5ae8b7aeeeddd5e00cbc8579b19f38a3f159f19b81fd34521de403a6aaed9f74ddb9f241b598f2ce410e7bd56f29536ecdbe66aeeebcc5180978712bf4729822bd5af7465ee9ffea012648c07d7f524aafd5a9adfa77750abc8639e6ce0e55b0003c03d9b45379da6f186f339476cd120ddcee084ce76af413f24baa2ee50528f479f45f404ca2ad69d957d594f5a8b5fe8f64525ebe0e53f002bfd2a0a0682b3a015ba986297ed5f8e006176887e92c287cef0dfff9254801c6a7a2bab1123d17b5c45dc01b4b9f1d68def25e48f62a837a61b1f2dbb4c71bb5bf925514dcd77f8873bedef523320b91ac5bc08fbfacb573d0c5135a5e89bb32e7ea98225a64aa19beb2281bad70ff53e4ed9c70dabc4dfbc502fb9ca9e541d0646ca67a20f2f630c380afa24a8f9107ab8a1b6eec7c608be4f4f72648239366b6a572fb6cd9a511bfd50f72e87b1ee1526c2f8fcd1c680b203aaad2d751f5151928e2b7c885f915bf55765872ff859e210e79ac4c6628aca6ff521754a5b480d223d7e9f1da698883863adcbfa0dfac5ab0d7ec8e1bcb30ee91ae0696a1529a3d1ebe794179de7c003dd6e663f12b95d36c9b2f1050e036568f0a9c1a1f96deeb77da8321ae5c5f3979676940f23aa3313c06e4addfed91b7afb9d6dbf32a66f829255031e192873326ad61e05ac9f79d3fbd2381be5a37e72302c1250ead0362bacccf6a1064ffcd85d2d6d8b31d1a35a77006548d4e28487373fdde7fb10dbc2f8e6ca8fedcb6348937a8d8ded7994c561fc2a7ad37ea063da4d7aca99509cebd86f1bfb58ead801adffcaa0fb381f3e91a0e8e6465b6ebd7ebda1d8118f8ded9e3a2a7fdf75b6eccee577a1728b7b709e3f333db973e21a272cd44972d0a08b67c6ba6f8e514444741c8fd68d99049503fb052b22fe2d609fce570e597c6956bd438457f2543aac581da1ebac425218596bbd186cb21801e7dbd6f428548926f4def53f468ab9350db458d6d83f205eb5885f4c4c67602b6c71c106369e8a807f930a8188296e62d8f0262c12fdc97c067ac5d67a924212b774ed2c4e32c86b24d50cb84f86b8d80adc021e9e63767de22876d7d7ef54d144bdf24c3117aca0217a4084dee6449d9b087dc718831cbd1940749fab2997476594d80479c4070bf9f345540ee0b6ee50ab42143373aed5e5cd0b7e97b2f428b39e90bf6afcb5e6e67beb033711fe483d157299e56f91d57490b6ccc7544d82f3143fb8c406d54b76f4f5a896d5e0c1d0c4b9ff1678a97ef5cbeb992c308d61a62a621ed6024a8600a66a0729b8f3313f404a88d9b9c3a4d9373b9e48fec9f96b7235add544f7588bdcd26fe55eaea4695df2959e9b2195eef3db41687635d926ea18728d851c68bd4a52aeee130f4eea7247cc44d82b56e5198b00e9d46be23c9fd9c936d207a7a144c9cf8d5426669ca26d496d040355aea6c53cdc0d21e39611497d8d7afef426bc44cc69b2ef1637151d136e3961675cecb1072d0a87a39ba810d95cc2c9229ba12256df7b813ce86364334339adacaa40ec168abb958f82129024468586941ef49c1a25253fc16b04ba1a5867ffcaa51fed9cc1f8a812711cd986caaac5a4fde115c6f4de2a3c03335943b770600a0d66ea07dc4eeb104efa2a56eb009071d85d8e0ffd4142cc59d9f6f4f8247998724103852cd94f2df6f79b77e8d591d6d8c263ad3efb91387009f0fb11650ae4812e65640bd68838b9d09c2c2ee4a79f8aa8278b36e6c762782ffb4941f2902f1fdc9361834f3a90fdf7678ba2f4994cd4a4385298cde0c8e195399e4e1716b65c42296bda56147d512b24b325e3dea48945ce7f976703b054e6addd3355e43b93fa9885271b3750820e4fc4b4dfe18c67a98780074f9d9bd034e5ca10e0da096f7d0dd7ff74bd82729da5e9434205dd46532db67fb3ee4ef4b9b96d2a16102ff7c28a6f617a3169282f28ffcc2634004fa4dd2351d1e5924b64628666e14f0ea5b072c300987530474d2325f53dba7e61ac686a59d97043d0e39a078337a0953e7a891f3f69558a0c47d7d2d4dfaf0a19d1843e6534bf08280bce834e9191a7b5a2c20c88d1b8c6905e2d033715fdc871170737cd409a79ca419c896953396a75b5dc1cf4fd0abf9547dcaf38826ef4c5ad45a59769a47017eca0a89b4202aa7843d571db6e7aa612d2e1ec5cc2df2f51e1d2b210b2a338364c8bfaf544ff77260959b0a34492d597c7629ef69c61bbf664e895393fc8bcfbce0b2566d0b6808f370b86d004f31fbfea8da949fea5872502330ae276d775fc4c8ab1ffa7ef03c17d725d3deae968edaeb6b099c918916bbce16ef7dae7669648d419a745b65d17dd4dec1477bfb84157fbd83f9779df3d00003d9796d1cbc498d540fd0c05432bd25cc664e1bf793e2c9f37ac85bfebe654826b4482751c0a8e8f76c89ed424c255b42ef1c1acad20937e65d968fc417da726c36b9827c50342e7d6cbf1c181b81770525e1e3a1d7a521f7d32ead727946fc8adc3a007bb2c0cb96b772fbb83e977846afa5a048e04c46a1b50a8e3330c4d5d17a94985960bf07f12bdc3b217508942433db2e08da925a9f3982e3c97029fd9cad180dcc697de08750d27d62817507c7d5b3e09fafc5d6e7b84500ef82962cf1534f0dfa706b204c77756d4adacf43169710351bbfe4fdd3e0258e616a99d1e43ab9234e12447bded397d2bd714eca9da9bb861dd87f8ec1bbc583797c4cb118c888df7559f82c69adee48c50c165eb37b93823fb14fece1ed715ffdae56cc55bfd1a0bb6680ea567061e4d54b7e817205aefc8dac77812090ba28889904703c2f9b7d2d5281f6664899337a559865948a5804f0cbd9b864e89b8ee58c72dcf189075fc9d9f6cad15b9722318ababc281d9ac61adcbbb35a621c260692a905a446a11a865b3782b937d8f5485e0aeb026fb1e2e41511ae7981b751d7baf7a6387d24a2201049e05fe06899416d4be001de74f52ef3d4d3ba70daccdd13d5f2f791f152147c26de3c9040cd078619d90508944597f07b1c612f8e81ac68bb46173eee1f388e6e687043fccb33bb5a9919b30343cebfed518afbdf129602f1d7ece9271c79d505dc1b88b9055e5abb7b1b56a82562bd0c92586f2f5803e0f312efd3684ad47c9e14bfb2db59540ba5b923eccaf2abaf0f321c37c397bbc4205be5ef704a90e84248a64ec3985046bda70b32fabad71acd109139e4f257eff620c6930c132fb03bd4dba8472667597ac5f2af99dca946dd497615925ea8c3e4ebbb293b599f42e4c85f9b59b72ad9bd20b03889dbaa1551dcaa42453c93c5c9aaf6498b6a07e14c11dff0068319f40bdd351c67ddb828d5bffc412213f9681d2ba27731c5bf7a10451a3b7e6acf9520e0d7fd0dbdaad69e1c460dcc439754cc1ef46731e505c80a621ccef302f0845c3e26e03d390caec2b1b24fc7ed91d401cf6e95c197bc3b646128fed396a16e04dd41fdb72c4399b30eab7bcfc61abbcc3989dd734ae484576b05486807ee900167d46196735e011b12e29e94a7dbb6b54fc3f5513fb33c32912519f830e9f0c37e3284b7e3a379a9a0b34bfc04fc5bfba7b29bf974faef205eb2c93d04e27353c9f7c3602bb5655518618f7200cbe93f520710a8389c70e02ec30acb696876d2a6c3266a20d28f928264414e9f90623b0bff3e8d80f19f8c3e5c186cac2c34477587e2d4fa18633e98876a94718ede069fb68d3f0f9fc399069acd5ceb2ec786fe04089e0a7a2977d0b814644e8fc551d30c4ecec8175037e61d07df630382a33545d258369bd16267030536e5f4cd7e7a91f9edbe15060c2fd9658bcb2e18d6ad6dcd6a2f06c4ac9e33bacc10d342d96cfa78f035093e78acf1b39c8a9571793cd7b457b5e5e28ca85d1906260afa44d561a66af0914f3c02f9d6397a23903010d1ea3b683b0fe3ac4c80d6e25374d2a2d991e5e19848dd8322ac7c45ca8e9b0cdc24abc43d196e34358c55fae2c09dab177208d5fca2ffd5b69074e37a273d73ba55c43814a72c58900421c451a1c02bac42595423231e0928a2406e0012fb9e3974ee91e57087b50c60226e3bd9312845a684f28d83f4b3a18a4480b0e8916eea8eabbf67f15747a0645393ceb081f98ba1b6ec2cc7004466cee5b9370f4badd831c2ca265f30627c6c21cd7d859177c50914407d1a95102b923a6040d8492eec6392f917d6e0c63afca6ae2150e5aee20ecedbacf1752bf133ed3d43b3927fee5197428c564b9ef4b1d4144e18216d0f62afcb01b9db84a4cf4cd538b06639d3768168cf3e8db72516352b201f6904fc806997329b3dbc128271b79ec13c13a654fcb3b65978e9054cf0bc7ae8ad5486e810c5e9699b4aa7aa77ce3033aa332df16f3760444c5f59a06a4ce1f2fafe189cd88b3bd3ede8a2933bfd61de3649ddaa5087fe00a0c36f6627eaac46e26a861b560770fc9b562c4bf677d0e373130eeb8bd551f9a0f9eea4a35f7599727963a79885815c6d8bfc2fe0e6b28e2dd8f03e439bc4fec70ef73c89df017211f351241ba8fe40f1dd89e93b8984111c0d4ea3fa3b13c219e520e308e55d4dbf0428acadbb9cd95518ec3193e6dfa232fec1c2e14fe5d535d34058fc3f04c45a5e2910f940eb82d5e54f086d0a8dea9bf87728fdfaf6c80a91f1c822a930ef18224e1691bb3f569c31f03552c26b211c530e300ce48a8aac601b556399bff746c872a7378fee5ea88fc74e5a8749c50cf57b660cd748a4759ac4e5944680cda6e59b83dcf446806f89100d15d2f5883be4b2ec2689e352f37b0fda075ff7d236f1547b20d511b0af6cb79c18b2629ef98de19aaba0b9c0fc7a8def0952445f64dd919060e76214e7559c130f18b6caac23f7b54048497d9565bf4f1934ddd265216f0ff6854ba9045599ce4264a6198622c417de21338f5cba0bacf28f049c9bb6e2b578410e1d4d5a6d3895e6083b34e381b7b5b4d011968a017c6b9502af9ed3c45d7cedb26bbb3b7e16fb6fcc6141422db935caf590330724bd82c84e50fc212a43ba2e4b640c3d873e057856b9b4f531fb791eb023a29afbffa48a052c1e553d2c5e2b51256ee9cad6bec1ab7714cedf4721292cf304fa00cb7808d2aace6145d516fc0e50a39886aa494b5db766ff15f0ae2ce1a80dec2e08a80b55010632a3c259c3b73941df150820e988ee321c5d6157b02ecc49609f881b5431e50808307ddba6cf3099e1eb93d8912daf6f7c8611b5e4c973438a3e43b69b0be838b1e55d5fb73abe1292ae46df0188428a908c5deadbd5d25bf02801f3668ae958796209590b74d57d64c2a19468bfd30602cb269e89a7f18a508f57b672d12caa9c105052e5321b42372c1f23c72394b7f915b1cd3fe2ad19432f7134e8c6fe7b8d792309ea94c9bac1b4637037a27ba40c9b243a82a31acdac3a3fc83767f21de06cacfa08af9afbeaf764c789b78e156ce838ffb864c31f846fd5f91813690321ed939e81768e9562deba3170b98358688c99d02be2e07e3d909e98f9a76a4b12c2eb660069aecd1cd8aed524557092c2a79809789a25ef97b9058d54cf1b0ce3df79925b16e1f335e29b436cf22fb7854475ddbb5e4ae234115fb53eb5067f88056799340e27036989252d714937b197509724e8478255b6c53d89f915ffb238abcfdefc62b41519b264b26a77fff8904a640be16db13fc1320d6da04131be3ce8cc46b1afb7ba27fc97879a955bfc90b07034e21495cb2c1a9bccf4627a8c7f8818d4929329e6717a18ac7e8f66383af632fa815e044b60e53105c068e7c9604e16331856d5bff66a1d6939d2a0751f15a0bb52524d215f4efa193493b98e1d575331a25b8803d1e6216a1eeb3172dd13ae7a09c31a8b951d1e86d97182861fcc066e513fa4dc8650dadf909c275c0ff0cfb1b5e96db16a411bf00751c6ec82dd240ea4330dad8be888bc0c69bebe51c6ee694b6815236b2dfc5ef50d0b308ebba2ab23efbec4ce245ef5fd50d02a8c8649d67b049630c4df39f88f240475d2cafd9c3aca7ac2e89edbab03c550167d50c9b7182aaaee251dc9ede434b14bad4e606ae4e4c264ca7b8e83769c806432dcda0d8a9313b15dd8400bf0aeed49965c3f31e412afdc0d6755c9d51ee3dc2680eb0759775a50386df0c8626d541eade7c3c693af00c35fdf71e3c5559105c6fc140d6949ccd5a3c46d1ee1a27fd65c39755774dac9d96b0c74971a58679c7e446b444c4a026e0d5e1f3d64a0d53021fc94035a35237d354ad53dd9d42fc5ace9ce353b17bbfa61df7516ddfe7d645aa77784c67233c0ec9ec6c26507ef08b610ea6c01dea804368529ef6a84dcf658fe9bf3400b0fdab23f7255c5080c20e3842d96d43f7508789432f98cb349eb355f30cdaa2c66eff15b01d438350b784aac534539321af33fda95995d7b40529e13fdcdd7b2c10b15ebb3561e18e3dd11c5cbe96a2357e0b64b7d3cfd1a6180cd5f2e87c109771743432b82395b873f5f24985d8638257550ee32561818a8c849e900a784a323aa4f9ce5922fbcaa7a14cf2222d040d914ee954ec87bc97a7ae8adc2a173f02e74b18129f0b615923964b3141b2a9dba8bc3487b4bf321d994047fd5cee8a46d153c60d2ca0bb45e9bece6785114961b11c63dd1fd3bf1ec07a898ec61f4f40fdb4542246d89d5fcafe6498aca407cd6574fbe8d8efb1c566a34c7f6959d3496b1ec7ed4ae85846b525ff257336e386208c5b5a0fd627130a8f76a206316c8569d260ff6b4167e9fb7f8e95830efb5c3c4e08c16c7f3de05704e998c2495d0f3fb16c2fb92e106b13ef8c793f07cb1a505a37c0964d6a34ba8b0f2e0f5b4fdc81329a7b5866e35e103a276834bb63202e04cb6d7f2cebfb995659c8c8c2075003b3e16a7cefb982ba8a6337dba30c67a01d16a4266a863ffc31d271836ef15b6405bd8d3fea57628ad147224f56477584924334d7e981ceb845cfe2fa42ab6200c9b9579ea20fcf01f1e5581ffc67ef7e37b811a431f5ef036d112afeb770ebd9f7d8799011f06dbfbf794e7f282d81c423b4bd1808f154514db8c6b27f173ff669e7a473d58132afc1397426d798b6bb4181bf1f58ab43635fa50cf84b00a91e690107dd29adc7efd846bdcaca9c25dc990418e7ecdb9f4027bf887c74d00d4ad2eaa297599f9168cb11487a7ad18fbe24ef9e162ecac64015b971e90c673ac4f119fda4b783c7ecda00838d4d175729c9ccacc9694148119bc6f2c0a6867ef7a561f9dfce13eb70ff5f7280ceb29a4ae39d31be7330fcb265d546e605cbb218e17a5c6a5342d5f2f2e5abb552c0c0076ceed8e9a1ea90b8d50eec197e19d7dd7f418f4b4d716740d5ed73aa0c4350deb5243895f83bac1e3d91698eeb81eb8d85986f4f05e1f3ab571da877ccc1501489241b7abab62341cbd7ab9edc246339d67caaca9ca4f9fc6e8fa690002bd967c9ac9eda6c9f329952cff1e231eddf620ad9951340d6351c8680f3159b341f2bbe4c57ff0aa3981b6687ad72dea2acf1f3d5f9da8f98be900700671d20b9bd8f7f16264b09774936b6df3bb6073b597fbde0374e8bcd1c8bdd4996ad8ee7663c7e49ca953f5091658a0a12c349e55e7d4cbaf03ad975dcb7b7eeb252569eb2bf7ea260c95ac3b8ffb93476a3057c7bcec09222ad8ba729883fa3c601c6e0ad32a8db6dfa08829ca40054579d9a56a1e66a4b3eb5dbdb3321ffdf627bc4e54be453ed454b4e888bc2f04b8a223417c8b38dcd908177110f0ec189534a9f60a07bf10c6deefdc9ecc75d69006e14c401beaeaa2d881d623045a865527ba8c7072b20ed3f20d656a82a08241549e280dd1d03d926dd87df7054f4f4c423a4d6e5791558ed733b05fcdec8c01fb04323bb398d9e09badbade270bca4465ba3a7a30ea312f2e9760658deef92bc45f260a0408ed99a61542a86430caa214a58df063d22bbf8cfcb1bd6a3a7afbe3efefb3332abedf356a19dc305e08956a2b1247c27819267c45fb50174f03a6ac6c5883763e35b003a4edb445d0438f0614812b844f2f1b8fe3b13732df01d3b1e636341294615d2a4914d9feef3fcebd9f14b03eb3320134472df0f5e1051cbd74989a6be81ddbaa72465107c560efa2db165e02b15639c00c6f423d6f542997e255e633d0d2d35ba00308b513add5b488f50194701ce13ac91901eaa165be0f3f9fde8cdfe2d22db80c0bfce4325f02f7c243d50dff5de185c9bafb0ce5a0b543671169a42d567d1138ad3abaab9f31336e67fbf508026d215909be56b9eb3985043f87050994bba02f1c5e73ff3b9d127db11b8e04c255f364386db715b2ba1ae2e125939a593a360784d2f32ac47bd744a22db69f414f0c5c4d22811bcef065ea463967140c514a982fa145f818d9ba4f6c97aa03559f65c32ddb0cf5c74f57f91197ca2b6e7cfd582e7b7373eadf01bdcdda29994517104d6762ea6072a47116f17048ea5bcbef23c90bf69bf9fe84405fe0bf413f41617ca52c3018b115bd03d16ac1c6e45ecaff5555948247b9f74bcaa183b995d9dbb878bcb9a49b431699dc47abea76dc733390355cbf97c0ca18fe1830edcfb638690ef8a8496556d8b57131a5bb73e634cc97b082d47c71e192e155af3ffc3ef35e2d03b0507279f18359240aab252d46fdd575b02079e769ec3959b8db60b232f112ff0d61a5aab90cb011607c12310f301cf5948a2a377295eabea67ec7aa95a6b7a77d78717bedf4b42142ca0726d78b301890b22766c7e81f4091ee1482cf2431724ca22d392fbe8d9a1c1df5d10fc9fd7e467c4cd1a3dae63f3ddd4af15b8a9ff73c8c7140ae45f20f493b37d909ddf34b275d3f96c9e994833ff10595a35c51968910ca1da8842e34a22737c37e39c76ee499012af66973f5c7590596869f8f6bd679fa89d0bdb4ec9cd2f2b8305f3c621e34ca5bcdb156919f1c312f12876aa80f9a8f76aabc96e46f369e34f4f95d54e9f1038b1b6733c90077c7c08939ccc4b8e8c11231046609d278cfa99eab867618bbde0bf9e23b2b5c892ee6cc73f014dd66c4c08543fd2a22cd9d699be75a4c1319afa2be22de9e2797954ebaf3f68c368ad898e3da002a02dd5217840747d7150e009acf6989003352f72fac5062aac19fea9a480776488d75708c400dfbf9a47277ff6d2863046d873ebdcaa26c154e2eda7057167bd282cc551ca6bf681a12cf173ab28e8ad190e055ed206af9551968f9dfcb6f7b5f92c21799a0f3ccaea8f0649a0f8a966a036d2629e7a598d51c8425c032e5400f458671d95b802f4b47ed08d08f5b30edc003d92a4f1592216ea7477768046536663ea924bc6edfc7fb7aefdd0391c2ffdc2e279c80693e18efc3151da14c7c9662f938430914d64780de1f433c1ac4411f89b3beb328010645cc7b9c24546afac545a09f43c91420d8fedfd621b8e363c839b711189d49cf0725d8b1e80e850caeab5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
