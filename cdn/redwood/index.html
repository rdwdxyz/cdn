<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47490a410a4411ca03ecbfbb085ac3d3ebbee240dcb9a942d421471220f66fe2f32622389fe36faab347ae5c2d98411cce52df725f5148b7f2dd2c77443b76bffe045f3b3bfb817dee4d2741cb2648328dd00775da62865031bd27a13046e08a18dcee52fe6f0f3adca9405315ebb7467cbf2310a1a37c5e3002a92d57e402c3206c14f4295e07c7c4fcd7661b881be0fc691b5345cc16b15fe2fc5b582e8ebc84fb06976b43b9eca0e6f6ec5ad49cbe6c74323384163629126a33d0b4f3b13e8c266c76b8f4f1e2a96dd46d0ad6164ab6a35cc5e51d25b12de55e33377e73db8de42f38bdd5f726a14d1f9b8677c1fc7a05e6b4441bb436b7168efefc7bda05dc43d69579809691e2b04643375b9686aa50c9e18f1b9e6c3c3d05d8bf86b4d4c8c596fcb0d938e859e8588efeccca2c3f05dd12672affc5308478e37da9eb0443c4b01b237e3443ab315317052e35793fe41a7d73394b40819f5295493ef835c64bf045edc22fdc1d536f838fe45ed628e49beb4d4b2dab326991e803fa9555ec0d213b8ee20b8fe98171818bd29474bfc9324b1a623d5c152f1284136b71b555b03e8f2280879becf30fb6d79ff9a126d48346616ea36b8e0c124b849882a36fa281129ff6799879c8a1f3eb466c384ca3019bbe32894f74ad353e574ea1e4c604bdfb256824c08015e3e33924c58b220f24a12bc5e5e5f36bb359948bf30c4ca21c28c9a2d5b1f12cde1a33e2c396a54660258f227f5c9f6ec97351bb224c274b40d555859ab144e92cc4ef11398f512954ebd1d20481f48d2e2119407c6975244965acb0d8fca0770d89ee7e443a2af41ce83018a2cc8c7fc30e004d7c8516c159fb038e5af393e5c39be41c339386a950787eddf01af47d3473b94c8c9ef366c4fb5afd7d65f7e11b9fda4b38d0fd7fbe96c77ed09eca2bd15a0fb04f4bc4aa0e039fc942c806d1221b63a00872f7955a635b4f6c8c798360c1b60e3d282538b5d215780d8a762bbb247614df8730e20a9f310343cc703cd31f0546bd6330100b8bd4da58e3d8158d558b61391f7b4a79a58155c4d4f60640d52c3812ecf7bef3089eb57cca50ca857ff2ff9e9316081e60585c0e2b6bebd32335c347c6ff3a8394b35a81d60a91e6dcbd5d6604f4ffd307d16fde4e5d556d1e13c712f2dfef0e842a9bc9710ba3bfb3cd5c27e4313b31a0413b2c472a8250bc79f3b8b65be4ee1f7cdf86182c5798b6dd5c94d489b66cf4591ad74d962d1fef6b89e0c0a0be4c0f035ead0db9d420cd143a4a058aa79c886f61277e6472f26007f050a995ecfee1272bc90ec172f6f0106377b731f2540e7a410743d89d89b192b9b070b8388ec761d5b9b7e88677d543197c3ac1e253320d1d7d34b7914d053ea4d8d65b45c285113601867108d8892203c1f26a29ba17e7156a00eaecd5243806e72915465f98444fee627486b8eb5abc0201c92e13bbeb1681f015d957f22d2d0a548e8568a58ef9390d4d50388b10398d3575413af745eae88ec9a89c576c282e5e1af280e5fd71c9336ed775e8113114f5ba9bbfd97f6f88e66cd5d0e86b24ae55255918980e6e890c6170facbb0c1b595a47bbd1804b55eb68aaeaf84a32003765f917d3043831e4d14a6967a202c61d32f5d999951f0a0e8dc0f3cfba1377e9a3a2b06f55efb5237ddc412d3953d609a8bb49f9e7e98c967c478e33253b8ae4695033fb032047e1169ef795944a971889738fb38c36f6ede4831a8a819f853c3c7d210364045163b29a070afa8d5d598d391020db737e01308f9279d2f7e48e69f4781f59f88a2a60f41e60cbc92a19a7c67bf26c437c9f7b51b953b3dd7ba62a149ebad26af65219331f0d924be0e97b43b33c67363ce27d61dddf52398fb60dd614eebb2a33ed0015896ba54d8e0f6c89468ce26c06f3753a877cfbbc1a25bac90a88f9da5de7ea58f77ddde3c9e0dc24316b7df0438efab5ab4aa80da879037beba9a24369774ea47cb5773e2265d0ccab4b9a94a882d1451ebb93178676ab57902abc8c997ebf5a4460b5686c3c7ea720dc3f006310fd8c9ca22dc95b59a6c8f601f04075eee53bc148f52e2f72e36b257295b27a9af5bc3131c7ccc6e54ef6492a1c1aadf03b6a78d9a351a5c3e4ef13a605fb5f87f0daadae3c171a1120c9cb23ff7e21c38a91006fec86078e82afeb3afe52b7c8a29f565656ee58208c98e6706ca28b9e7cdb840f9a0fb8612141a9bc3acacf0a6b75c64d4dd6fb659af23ba8732c049022a43a0e918680c325b84e4388cab64198e4230dedd7fd0f4d97959e4b8c6c250531936c8aca6866ec38a43361ab46bd9be7332b38cdd2d78504854bc9018559707060bcac8c431ebfddde0ad6fadb9872ef0d72f80dd90454a5329e45e3346330082aae0a42903aaeb6c047c541929fedaf6e0a7ee186e7f80572a342e74343f22a9775e8304e80eea7980d6adfe4394856ba93dcfef74c78453a5bfecb8b4b0f99468bede70c572deb8f7b4424bacd60b1b560566b0ce02b2199eec195f719e8bbb3c565cdc1a4cc59cace37de656432f8d3a9699dddcfe64c93d68b86dcdbee936c68947ea271d7c5d25f3158c6a4d4d3f5e266db6ad043d632a8a82c5ec3dd3635d542d1c5aefa720ac9b545dd04e76b5eb23fbf1ff0e03d2b555a3e651c1a2871fdfb813bfcf9fa91e31f8010ea7989049a4269f463371f6f7be5d7b3232f1b0a43865570a062e289045d349945fe1a4979dd1349bc0c8e91323734bfc457cf3c5f4b49e135ccfdf6a2991949607d3cf08099afc38a78177d02df2484ea0d4692f74d19fd855b161f376fc067d3d2805d9121414cea761e7da709f305b6e8c772dfe2cec6a01d8cb04ad1f29fc8982209cc6faabbc8676c511622a14ed56badc3d543b168408d5c568a4449aabbe2b4ec8ab22162d0f837390ef25393520dc32988cba9d78d0a73c6b2b624293cd1810748efd7c69a63fea2b0dc15f02f3ac3cba030dbe407c039a77f5e652e3738ecb286ed68d0ae7d55c0b58787b45e4014758b5260d5caa8c2d2a0ee83fb50c31c8fab6d188f2dc0678e07dca99cb2d0ddfcb76ffa1046844fd32d789657d55f84fc5ccc05e288a68644bce24c41edba7a8a1cc2fd961195b1c732475bea83a590d0fef7aec7d5453c791a90bb1aa112d245d39e0b0422c0cc65d19401cf4bd0e61d6698e24c554814e4e5decb95eedada6f8c1070ca72fdd76e0995d6dd716638eeefa402f2313096ca18d1047b01850e57bd616ad4d82e1acb37dfff5ab0c8981ea4cf43b3b174090c461a0b0e3d2fede30eb3b79e62b1d513a32c98fc96cc57c5f9d1a6ffc906521164c319b54796466b8742fd79a3827b414183a63d56410f45c234f0a56668d945065f12f5e29ed6d0283e04e0d3faa75852f85f72a37481a2025901a2e6febe5dde416cc23b3f4d657d1db0cbd72ee9ef9f10a87bc1a29ea8e2fc743a88cfa067dc18c9e42f53b3bdda5858bde1306b569e03d4bff76e9429c7ab26ee2b36c271998236fc5efa1ccc4fdde96a40a827e5fa578575eafad854e575e12490190c766f820c277dd73835eb06f025940b2e9a26efe756afa0c41b51259180c92a141accd6f981cb9f3e5e5ecb3558d0ab98272ba723304ea5a566802666d98e7ce46969513732476684b3102820e20585eca1e004062dfd9f7c96fedbf018e24c328027e8b8d0cb5323baf94967bf691d6f64a92a47db46d2a68c2537a9383a0478cdd32bb265bdb00876de11ac8aa7854f5aa6001c74cafdb0afdbb58a4dd4e4ca112a539044b90ae65401e0777f4cccb2cdceeead87aafe397cc6605963fb4758599364da3a94c524785cee7d48686388b3d8f78d6e7416086de44c485c99773d0a235d73254736398f7bad50aa65d7a7af9553d2a6dcdd4a0496ee20ff19c335a77a9021e5c9fbbb91a554f4ee00422ec3e71eb1cf20e2561812ef4f8a95da9bfc3d179e8cfe8e0bc5b4fce9785d766f0a42c0a51a51e73c965c98e55561bf42e2dd1fcdbeb5e6f507cd75e515fdf02ad46ce53e026ffed8a7c80e357e1002b8d00cc2a8cf1105f16bd4190cb9d29b9c37a28da2e8f8024f8c6706f20af9d8b39c729ad70b3cdf273657ce13b0ebdd96cf501ba9d33f2ac90e2a5dd734aef1f7c314e463c9c15eb26f3f12a74baa2350d6473f3234c3f78e99ca3d3537a85cc5d08007b422d35f2c8931901a9ba2e1a2243f6e28e0c60ddf7c38bb3ab7f2b6b31f4e0ac46c35884304d8a9e7754f649808fcba01d972e820227df5d08dec4177b9c6f9b071f1616819a79816b105d6beae90f2e24370b5ce2dd155772a96a8bba71a50b555b184dae777444e5e7230ad19df9d1d42f33bbaf4e2e7e3e1c835524e718632816cf74a9bd5fc46a08b6753ea6c4d7535537e7b1abc0d680794ce641f7c3315298cf257ca2eb1c9b19003721cc4725a6fd4cdfc151e9ca2d0c70b124019e385fde0ced5ff697fd1afd42c5ab2395aabbfa81df526c69e3ce9823b31a5fbe0abde372bfd6f5adf1f445e47aa5b041c56e026049b3308971e7194359e6d0f82ec455ea4334860665959bc0affb51fbab3075192b8a64105b7ba0a09608ce0ccf6ca2303973e4ca38d00b3fb17903d50e4f2c7823cc3454fa688df31bf24bd2dc0b1c0144e651052080056ec47eb583ed26e2b74b63b94b3baed6b2fe2efe73c3379c89f304410d29fb7316460acb2d96fe272d83ffa1bcd1381a23e8e517508242ceb76d93b95352121df31d3beaa640e9e5e469d72cee7dd5f380d124f129b7deeca8db958ff483a77b393f5817865222cc77bea3abad6271add3cecc6ec174bd1b3f98b88c7cf41fd9030979dc9b1c4b5536303fc37e22746caff5cef517d840b8217560b2cab81b65e9e7dd1cf2423ef838a43ac1ddff69ea65b36b4b7028329a00489c5bde7c5e5a633990a63b659462bdfc1c402ce5b5501d9990b8fe513be9ad90deb2f9fc8d25e46af37291aef53052793e2cf5d44e3f6e5dd680cab81d77a02c065777d58f9e1adc59541b94120389aa366fa3756cafce13ec6bf7970ea3e5686dd1c6658613b5b5e11f9871dc073e2d8509423325001fd76bb77544033d20487c6f3559bb981d7403fd271b32735d78967cef004356e1d36a407a651585818f21dd9e7741beae9e732f1e30a9d38b47da88d4656a859c8e3103d1b4b3cb2b0a1fa8be2e491d34ed798b5fd15791667e0a0531fe06ba102461668942795fbff976cdd40313731e8e8911251d03c1791b181aac4eb5f082db2eb0dad79b42ffc7f9852038b859e466b77c87fc574da525267555c282615b44330ff03d7ed7daaef734609c41de67b7749f812cd8e66ef3f197ca9c1bd5e89f685fcaef7b762aaa21b1d25fcef57c270938514d2c751586a6d48fb8c6ad007f742ef12a1aec02ad5b353e85ce7d82de288ed2b0af77a5943dd0493973a34236fa3efbc83d30932c22b6d439d835e6433ca702205c3699fe1205d5e96940e23be2521032e2d6c2281b232234affd754bc7bd09fb0e11bdee2f5d3b83443b3134741e42be2a12645cb6da5d302c8c0f0036081e1766e6561b77f289a8a38fab41804c3b85fe7afc79a10924006b0278aa84c78e3433c8590d4b9709439ea6a6ca0d24097a7d4bda52b4477522ee3d453f98b1baeb196518d3026f92aec58f49e695bf563cc28cfb8752c5d0085f577911b503a4762e8e396a374c8ba95512b4e4048dbac40886f5bcad96f8d2e56a3e2a3c8c1ec482a6a808572a7040ab14098f7b847e3fd17b5dc98bea3d9baecae506730e0ec3ecfa415cf5dcff70d18c63974dc4e7e82277636c56eafccdc2772fccca3f24da1732a4c23c9b101731ff07fee0b794a057fa37b42767ad63e4bd5520690285de3cc6e9392d45bcafc711e5c46f6cb2341fd2109e19c1fe7e55bf4f52fbcab273012194ce990f84588baef963c6220426c76561f96dd40ba54324c292373f71734523bf3cd32935f0d717c81bec7960ee3bb5d70b6b97f5ba66c885e65ab5641166d41dbfcb4a81203638ef037bf2807d001342f068b2cdd80089a74b2d7cabaadc374de1974fbb0f107b9f27487a717458223e10431e5f4f189672b4daaed05a1ecf9188c4d65b92a31dc5c10309dd8e99705f3c71ff3b89607bf484b157b6824b94ed16bed723d930c4a5738de445bc3d7cc218b430034de75c7822597ed29717fd22894c55b7957301b3a51dc489e6558d9a212856638f1e56e804aff42eea8b7f082bac856c46f4e3be99cd2cb5f2c0178cf6a9e8b4c250f31286d1ff6e7fc991c76ae73f1880a3cd1a87c3e12abe0ec82b29ad474aced82647c2b5c3dad5619c0dfaab447c5f24c4b766ecc9b93429af327909703263e0a1e5069246c09593607e7ea0f9b0cc9f0bff4bd4ec15759a8dec56e92a8900481a2a7f54e42014534f2768611a1f7f07570ad18f1c73acc77aa106f30caaa9d9fb72b52f0b8a7fd376fc8c4693abc5e2ee481db43fa51877f37cd2ee14313d1d379d1cb5f2406d1338dd40e597898b02c35e49bf6ce562f6d00b4101250c756b7c4db75accb10e1dd0212a8fa7050983ef32da5ade62bf2170e88a5e3a1e44589c1a1057c6808a481aecd6e93b3db35e7edd2696da59b4c0e06404e6f4c83d8d3742e7d1ae606ff3ea0add9609977417d55c3ee9f771e5b4df997ddc36db6ac4d95d08412ccacc90f428e1b015e4862b8dbbef7f7079e00bc41eb9815ab0403291338e540524846952073b784b99445a6b5e8eca9b4bbf987afcd007ab8a9ee8bb4a2cad9f4076342794852a941b8910e8ff467347ee52905f90d564d7d78aa4a8f59b70f81fe1b9ccf6ed76a659e4e8668983197ec8c8a54e1e957b0829ac707c257e3dfa00cd93c37f2aafa69f89419647a5ae728b895d4f490866cc88e8c802736d02984d3a024654546e75f53f519badefc4ff2d238ee79c55f27051e2f64e478e5d3b9d77188feb2cd2669d840ef894eb47073d6e71aa32a38c6eeadd369eb68dae150dedbf745ef4a573f0f1535c5e96131c2faab7802cc2794f7c4ecfce06350a55ef3c14e8815b6a39dcf1b84bf78c1bba788f635a99094d34d066c36a6cdbb1ff0b9854c5d67a62e992013880425561d3b11004ec026ceb4e428d23f68cae3ec652e629dae512d8d939f8b219f569673e92f451b6bfdc8e0a0e53b5a454a8325c1db2e32d7ad3cbf42f3d90a05d4bb243165876bd2fcfd7a749904c240582fce9bc00ce988fe47cab63a595e44da7c814dec79cea4a116e12d4f460226aeabbe7fb26c7296c1bf2283018bff57c6c42dc3108ae18242015c30287ae9615eea6a72c53585933918bb533dbc29205cc3490e8d890ad31fb2f9774b679bd5608bf0a3a414de5f2c61bc9ef1cd2f95a3a07428db4cd89f0a39da82a15c4834b70f680731eac29a91d5d1a5d15db4b10327b9582aee5d0b4651e3a0acf4bf43cfa2c7becbc20801c50ac61739b02835d6e94ef0b8b7e47294f4f21267dc1793dc67ed64453a0335282b74e64754e89ea1eee92cebde5a6fe8718e42f293b2b2dfdbcdc2879515cf7e8cf1b3da7d5fc4a55ca6ced1ad4dfc18642f551b91dc348a2346ae007abbfdd3a1f395ddfe5699de9b698658a740b2777de57ad46c800081a37a5216cd30a74a33ff8da82368f35a3dc7845d2edfa13c15ff748a1684e558b72aacd7268c6a476b3e8c76fb015493a56828bb47c4f0f65ecb169d7872aad118b5a32ebc51709abbbf231dc863cfa5e0b1d4a57850981d3680bc235c0ccd724cfa9eb1c5fa7dd23d633c42b38a84ff07c6d96b0af4ea87e5278e2ce72aa545e82df9314c749743d9e3500dcc1976ac0da38d72dd127aa0608299a8d567e5728afd6f8cda48d33edfd328b2104133e5abbd14ca3ec58a95a0ec74b64e1146baf265e200c3d50c75a03b123851c340c31854464853475c4c50c5238b618da816115cd6314a96b0ddebcd2dfdcf98bbfb81c134492dc116fed7edaa3cd3c62a5b90cec46c7b51cb5dcebfc93211859ebc4371b54b30048c946e78efc62c86291339c3d09a06f7f725186fd09eb4927487828bfe69928a8294049653829015530dc247c8decc191a276e4b0ab9ee207a6ed0766959a12f5661426d8beab3057e995ac908fd8d8a6342ff709aeb213ab36a15b8a72fb1b547306ffceccc7caaff55cfaf12bc968a10299169e6b8c76b2be2e85d22329c887ccbc46a463f088b5fc84e4aa10d153d4c4d1b86aa9894e0d5bcfd424d2ed6c6df42355321b69bca3859766ce9539a6231d397f25c9ce8cb5c7903e29bb8cee08f848639882a5483dc31276bffab623d07bcb264f7f29714b0f72a39b893e7a8f65b07f7d4af34070b209d34408fc9cfc6543614174c244f9aa11cdad2e519fceb7bba9fe14d2b4c9a3e4b83e08b215e761a6d94faa11e4d473b761cdd95e5430de18c26a747f17d5ce6924098a5e8189907cc37e296bd9749407f9aeba7815db0242b729d7a29306479f0ac84b2da72a48ac237d7007da36389ad4daa7b057d6a7dabc1e6cade2e85ace640b72a428c7b9a05dd5465b9d3c669f1d61e83a1bf9601a0898ecd39fcae0765686675f57f8fe7b76408bbe5262cab0a2e9137d7713e785bbd74963a31d13bb096b74d4b3c6b51b72ce15e756dff52764edd6977d2a63dc4b30d0fe70c9b5ffa011202d05214d36d8bbedf1f7bb5f6899db298ae5159d1c7ade0b485759496dba2c720e03b5e9c2e087615063259048e8c59a9cebcb238d4295d7f39da25fd661bcc82cefeb46634c6234a4119da9e86fa3714b4308b7cac5d868b769f26e440b9247092cea3a8fb11728d194220609ee9e4c6f62309b42acc19af13f05bec2b09660635da7ce86d2274aff8c48d08f0b053c8fbff834e2ec82e735ae362b4dc8135cf7d27fa947aefd6f33a0366fd85fd37bbe1d764bc2976849b3e191f569c133fa2c537a261cfc45ec8f9ed95ce8e0f6b6776fcbfbd59be417c67afe10dfe55c86b6dcabe4c384f2c0947a6e869ee02752de52eaba74d4d7dc9c8e7acfcbe6a55ee1658afb8782186390525e519759bdccbb7f5edaabf861e5c23752517efadacba3df597647ba6577a84b646fbc1b3d0433e970713fdff47fad6f156ced7c2b293d50ddc8d9ab962bb593b01f853837af2c7f63f093e3bc5f6570a8cf19160adcd127c7ccdf51d06c58fb31adef11a50a0fdf8b506797e604c1cd737131bfac669cfaa66a5ad4fc6dc73947ed63df73122a11f1f22726628c54ecb582ffce83182445d6a567c950f167648e4e546bdac5289ffb03a23a68f75a1802b114c3c4e9fc62755fea0978905042fb4f3be7410e1d7d90336901b29ea3bdc73473ccb90463582e2eaad36d4be961fb69e33a00daa1bdec74562d9c543fa2616c64732cb6f9cdde8560e4c47a3906bd831bfdcc17bc232d911700ce735cf39ff7af75af5cc1dfa55e65780c89f9a09236d7d5f97f59713c533e5f7f07b7616f2d286bece8979deb94828bad516743734144d808e91f4cc634f23462d41fbbcd59baeb3dbd0258fb07f16a1d993d51a7a5fa5a456851aff092653a056b5aae52c4d0d0fa49d632fbef963d977e793d2b6cf3166997a5e0a3eeb867bb7e71bae531c7dbdcc00f81c6b6b773ecbbc1f5290af4938e545318cf2d0bd8ba56ffe3a0f72edf47be9c03a533b77dfe891dfc18abd3bccad671b8c60eb9b08b4aca4588c55e56ec5878d5822523e6909f369d09585e4ca8d7442e655913cb2aa14399bdc690be56354b72080c041f5c86c894b2eeed58940bb13832960626067c3c7acc26921e5b2c5a7d6e78d3f063db5dab84f5b98455615a174f484bdbf375d9fe32986f4bcfbd85d7261f81f47bfe5601ab5107e208959f59483fd6bfa3ea498402f677254940abbd15469156fd3a2a1ea583d25597c6123574426eea41bc8702374c6d6313ddb94b9e57352cd6df11a75d3ccf88ba50c3f57d36846accba5f3b69546710880185e5b8f3336e993b6a926aa5cf6856bd63bd1829dad9e2ee50555f060e3f8acbc5635aaa9739be877a6d13f88e4ff80a4b9f3683539792a60f13f65410fcfa5c4e9215c53c5beca4f81f77b3b6f5a1f7b76ed90c6d6a1218112b166dad03e9ba787e9415c7eec19e646fface0db10f1bf9c862fe7144dd62cbb4e8ee1ce8aa24ba31c37044afd4fccd133a9037a6f9c189851dccf1bc0ddac8a955946403ae685d260dfb8310022f33672d5febb8e0c4e8c06972099c55ad4ec2673e458ea07dc026f5bd66303ead62e83dcc5db889ceb137b34da8db94f40ad04ab6ae6b1bed0a327b21f17fe8fb271ed46e82205876b8559b2dea01d0d976fb600f8cbb6d130dbeefff78276a9acf99a4984b68a5f5f768237e637e8d7695440648673553651204813be06283edcedce8358e6d57d500f6f7eca214828bb1ca420fd025c612384de1a24392469afea4c3f4c2b229405553383156b2cd2da63098a9c29e08bef4bc5c22d0bfca893bb062b7ec824f75ba17db0144b99148a5d724a7ab9f3acaf826a29a459af0613fe7ab3dae1fc5f716d1d4c63d97d0ed6567379402455e95f42bd527a423fabea846facde5ad4c48a79da3924aab6dd23aa9f909122960039cc21c1a4830148bdab6d40fd5dd55d569c4ea23008098a27bd2b9af01de7871e3f82df73189168ac335d305a3d9ccc80f993fae320d904c768de320b1b59486cb5e34e9a3b9e89a8d65738d1b8cb5d0cc451f9d6108f35d9122bbc0ebe55e45b02be78a59735f931c298ebfbd44c5d3741574895d9ef0a9245cebe4d1a8aa0c24e5e9e5412f2b78cae986711069eeb73be1e3d7b23bbd33ee1716f30f42cf1d709d56d2e237bf766966f3976d3439a2a40a5566b02b3a879fbabf3871dae1db93290c64a22038951ba0d5999ac5296fe16bd5bafb8ec4d439b14705a238de7aa2dce250a44efda9393dd9c0cc93eaac00bb615a3468f2c2736e81693ff13814099c676f540566ac28323ab6e1c468ecd67e7701111bb6b888f15cd60a5050765d5ea86fd8d125cca02b8a29e77d7f71c6ace1ceb5c96453ba0e3c2e78d221b9a14748e671b379a9255b5a788c3fa63a2ea288ed61e05949a1e85556f2bb9b13edb443938c92edd6f66d9553148a1fe95c71d28af371991102ec2d5f229ed1081185b99027e0b986c34e2833eb128810232754a8dd144a86f7c499023b199cf28c498fa95c36524085209a4afc7bfb8c939c88b3b89d0891c04a30ee4e3ad46f47341181fca2d1bf85ab60ba9f2aca40cd99978e7fd72bce1e2a4e342ce7e05e0839033a0745632057d493f3d82c784afee438840570aee92be9d6d24fe57088066caf6600ed41132c97ca3aea13db0834912fd3a0f668b6a5024fbf3fd624076b149ef534a82ea96160ed103f9f1fe9bb09c304e8ed513bf6db95ca58579df2caddac2392509778950afa55c916d10ecf882f54f50517bd4f635def467da4284a9b1788aa0d7ce4db149f7da169df9ccaf123047568ce7e2f8d08b8b36b5418cab87950313fc20e6c1feb92c2dc862995b5ee92fd5cd3314f0986369ecc88ee3046e145e7a32a5ea8c3ecab8061564d9f57dc614e17cf30d70cfadd7e5bbd0251588633c334c24e04865921398bf2dad394a92ca54ad86b9ce4ef21536411db89821537a5f5e2ae1a4f5f0adb3f0ab988bc7f421bad4d50962314e7e79638b0f973839f75d02693cdbaa3682c9aa9be67ce7fee9fab566d8e5e4b16522f661bad4adb3cc9914419a08d6fde2f0112e61484a7df8bf5305b16ac1e2c3de4b4e15986745dfe792252673955516f8861fa4e4d47c1b339da6161796d32e10c44e5d909172fd30004cfe18c106a412cdd1cfdff5e911752599fbb6aac6006db857e5bb348573bcecddb67b61d40acc615bddf7a4f45ab8db31841ed2103ce7ec9cb432b91c94166a024ad569f883453c3a95b9b8dfde98a744f05975b657dc43a51b679d24d1404fa42798528c09264574065819f8206fe3d413470a84db43b41e45069d4d60760c5d4f8d44213ca12b22e5780d94cf108803782cfe1bac5e889a6f45726c79625f6d68f83f233c449569bb1bce655fd69b5dd112d41633e340c30bb692ac9263a84076bc4b490a242c734df64b42ee66547b8b8975302f723a3364133ca07c5e4ee63850edf9526de5ebb482e2dd2f1e3774c3022ec46d9d1d5e43f54127b0796315a2f743ed63871fdf311a31682c492691b938c21f908ae47753c5dba145b61562d596b8f58148380df5bbb01a0be107da9ea26c4403df8d23a488433095ed10fb82749228928fb810af4bc2b8a01b1c95bab0b7c1a8d5fb22afb905a9bb12e7a9432de49ce5b9779b3a00a03d576b2af91c9d429de50182498c16f96070d4cdd8caac897f6367675eff8ea692a4ab26b2e454d630437183afa24309e7ba39cdadbc33f8feda64a5315a738321982554e847e79b0e84ab4edc0e62ae7f44b0b27a549ed8a93e4232a3c8239d25851d0fdde8ba8198d283898fb6eb8bd652bbab2efb8dfd35716dcc28c2906b68bbf6d5ac23ef0bb3cdfb6c578ef016913e29247b26c14950010be565846ba2a875a0d1aa7edbd9500a84061f9918a88bcf0a3a57242a40733a8e607e5874cf3644235ef8e03df151bf500c717c49a2205d631e321ad9f4ba6a2c9eed4055662cdf4a47cb7c7111462037e6a506d7ee1dc7818e6a107002d383e4c773760c894a31538868587176d9e4d72194cd7434e97ca868c7ef37fe87c5b4dfe0dfed2ba95ace0ae24872474f025e88884fc4c9a6d3233ac4b07ff36bb88f84d73a2c79b4b4291f2d9537494bc118ff4c8fdc1b056ecdaec28778be8679520ed38aa94982373dbd1b07a5315902ff2d67164bf3c4d5386915404d9f785a1270e7f561823409fbdf5947fb99153efed52b1bbf12d91c7bda842362cce025a49f5c7c485c0d07087175dae2faa05860f767032f896986cdbeb59b2ade721242283c2c8fa1528037b795d02ddb1af81be5f83bc285b1b92ec764f2a270e9d2c92dd410623679cd799acc2a1ff958f790c79c776b1455b2d70931c6c6265a52755b4ba9e45b4a0c98749f2a9931a5d5e670cbbbd7a0ee34f2238203ec84735522fd993de0e15faa055caa36b11f1b7b8dfdd1b4186b89f454a72dd596c3d1b082c93a535b5c7a7f84674961b6ea83e52058dcefc12bf2db5fb85c841dbecec35dd81a883fdf587be694de2adcfc1dd2009ebd8f7c4d48a8530a6c05443f65e68014a8fed1ee0a97e73d58299693174ef122622ac7c636959136edbf85182741d20122d271c2fd8fd609a27f0798448dd1f0ace4ab660d5124afb96b52700d1383cccfee300d4b48d4ac09ad9511b965572e4e3ea05aca75d9606e167653c85b235607421a3f448b88a0a3230111ec2e29286b4932bab877fa3abef62ab79126d88d26ca65c850ca01ccb0fb44a9a016c64a5b90bda3b558b7452905a40c3cc7d49cc02d5fec0f2fa69f29098705d23f3fbaeda7459bae39d822f131973a43f85a8b9eb4d5a7f4e30dbf4c565b27930ea58b7d973d148660f6161a5631e752cbafb3bd5200276bd771352978135068e6503c27ebc55be1445034351d115f8d8607f0e232e4b55e5154393f8a68ed8fd98a8d056f2bff58f2bd7fa45bd3bf9845156b1a2f7be54904689174811b5b14a35a76fa7aa41eff3a4b230f74ce2496aff3707aca0d5b474db6878c4296a61df22fc8a7fa23322e79c778b89243d4d6d7d8f9d1312aa3a4ce4c99d8f0900aefe541cb15d28e32ed8b9eb557c95966fb70eb9a30aa91ada3b53fc0c00ac95e7c646315a4f5e0335b28d1166c44706a5c72ebae34a94970f300a34a97b700b4143864dd0c23b79c17ceb29a8db012d29c124f8bb700e11fab8ef3ab41c317f10d962f5d36f61c7a0d9b291d681f58b7c6c35d274aaabdd279fa87aca6805018c6fdf1a779b4e3a8d9f5b59fa6e5113a6447466de01cbc04a979e8c54ad3b2af5365469984a0168156a6136dd5abc3052ac9043f34ae3d20de859da2284db0714be5929cc2ef9ee0416171583a856aed3f21d23390e81078ddb95f8ad232c2a47686f44b109ba9c66580bef7612b361765f26fba093fef93dd5507d3980d4df2e83706e086e4795991a0e722218b9024f454758111dee834754f2cc4aa6fc956a16f211cad6886bb501b6c1494a642657dc0c0c0f15aaf81f55e7dd6af3e411bfb77b35d1ce5b12628ed74b39ab5d14d98490074d89b040acab008c0bb9129ee77937304d447cd316f058f8e96f8e1097d0a0bd68ea0d34fd37eaa616a4d574e8e1cef3b875ed81bfeab0c6e19ef952ed5e669229cfd8cda6f7aafd64f87179ca28136157de58f86b7728d48d4ad5f91994a334397f75776cde733c51c72bae507c02fcb7878771f15557ef6ab836fd1e3fa3c233df4b3a7556613efe2cc8256f6c0fb66e4f0ca4c1b8494376ef142f001e39f6c9b3abced4a9306323db7d187664d070ee7de010ccc2a37ca9e3eda0e0a55ccfd196b31cb196f33bebbc67499178e8f79a68590ee19a37ec90522c8d264dac433f5af1866f39433286649ac11daed0fa2f4ed5e663d2c4122b910a1e4c150ad1374e25efa9ac12e85ff599ee723d2158de3600cdbf636908f9d3d236563e350fbb487096c9edb94d7d82a1c6e4e369db384377af7b2811796b1451a634204dbaa06db6014c4cb0dde38585a3735761b275fc984be2e4ede8e96151457c15fc8b0d35e1f9eec36d53a3381425186816c940bf1995990d18658391697ea23e9430637718c8bd5f6379ecb0a10137ab4cca24e17e48fadba477ba5e54858a7c0464a2388c6f3e2784ea7a4232e449dcb1d189087ab1a297911b317839a0fbe582296eea942061d695be352473427964f892fc7fdc6f8e79a366edc9a0f1f8cdbd9073dbe99b7ac01eac6932e63acf4936002f4141dbd513f9ef027a195a9132f3db9ec08b021e28540fe1dfdbb240655e1f024909dcb48f7642224e6a747b6b55aace45aa54bd17dbbe13dc01610e1d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
