<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cbac254471869e3a3c735daa01c01d7306e20d29e99799f77d68eeafd57fdc787da13ba0125a896913991d28c62e8fca7113acf636b356017c46a78a55bb9d2b6e77fe691c4d985c4feae00011740c390f7f1b44e74bec75b59c72b8d5fec1b45f1f3c1e934e536375a40c47ad97f8652e0a46eb5f7a2327eef5032bee96f97a070ad43f088575a36fc848a097063d56b77db10c8c7158f69eb067199fcdf681481105a85849f387e84748c522829afc40b0647c35f50e166841c1c69adacbae8d343e2edb56a0d4362f2557bc2915b2a3194a8cd85e384e81c81fb32530b44a95993cad262c1f568569d72c95076c14c2ba09e81b553c437f3b8cdffb13e4a66282a9d35defaa4575a083cda2062b49df234f1c57e0ce4550ec9171d33beff66d1cb957210db0531bc243ed3fae346459f66e426bf3dca91a6fb67a304d0c06b0f95e5298c52e4ed34da224bb33273bfda39b730bd9e6ba7279ffdc98c6aef855ef5cab4646d2bcbd59962877905cda841733ec2f3f47ac09fd57a3a3c27f46a26b72876349856d57579a02c6edc840bda3b0aa7aa8436ca103c8b1a3f7559edcb1645808ffd62071214ee5458fecdbef58c8b23c7eeed322432dfcfbfb848ce9c16ff3c094cbb2463543aedffc722b93a7c38ebd1d5bff234ab552f6495d34355455acc51430708564e7aa82f1dc911df09d748431687b476340fee9ab7895813ec8f7d63256140fd3d4a8f3022ef6d8059b0b470b332b58cdde828f579eee7a7face3d24be1370a2a0b3053de88b0e779f6b71966c507c5f2bd45fc74fe41b3ef71241703ae93142f78c25d773f4bebad028d9c0719970e34a02146fc2b9ed07b6a9674c79d6d15dc6db37ec3980fd1f9fb8b9ff60073b919ff2be5110c4aca0e8a60a8ab12b2e52779bf86fe2f22b5213d778e1c2eac56fc499018da626bed058776f4ceac72089695e9df035ff9b560c2f37689f33b0a009e1a58f9fb8d06ec80d333d8d6aee437fcae5f2412ed8057585246f52ad0907fc6b82ecf27585cff6848417bcfff95a57ef6b128f5184dc894bdda37969f017ef463fb72f18413e2bb6e779ae50dfae710db69f151043347fc46e8706cd16d5b5e89c184faafea51f3ad6afd1cda981eec5791059ed37058b8f9902435d1b877e37532d8eee89057c691a058d5834a4a64750557d40a89f1f02cd93578558e3b03a2a84c08d111501c1332beb0961d1bd6c288efc3ca99e440c43de7af760c5e7c44a3fe21036896919242bde4e60a95a82f7d33e44d41a17b5f1a09bf67d05dbd3a6e1859d31c3fe247e740d107b1ca25ba3fb4c07cbdaa2b84c3cde869c1de7cd56b4dd89dfc48e4564ab1990ff2abf5049c8ee69fd03ac0c349b2ba1f68dae66f62ba1147141d5c94803b27e13ed60149f47c5c6e699301c210f4d1abd0449458124217b8aeb19665bead3449494825676a0b165e9d8601d132cf581e7d477a74bcec1044c064315e92721ce8165baed3c9900e53d07749b778e1db5b3fc40b22825ce573416fbd1d04534b79ae6e619c4f6cb8803bf4708c477aea5e8f5b7c9ea76bffbfd8a9f9cb1da51695c2df58dc5174158af3dbf4d451260b2f9bf197006456df20cacd780f0dd5473dce94649802a769c13079ba97599c7b440c24cf19a573c396c4098d741b58091644c2f813bf12f991d85757f793008e3326a590a60147591b9f5721bce647699c69870c399c2a004d767266dd10346373d9d5ea46bf9c9b0bad9d8df557670ecaae2c53907acd99b294d79a5f5071ad8ff33b492b274c86f62303b88bb1f97fac55943ed76ce6b770b8f7049f36bcbbc0eae1be998119266d20e8cb52eb3e12333e1fcaf4b2477a60b60217976ebc7c552331b001efa968a300126ecfa45002073412c17a94eae5e20ebe227dc31e022e2909ed21809a3e914eae1dfdec4f2a7e4da30f983349b202cbf7412d1a1e3f86046bea72f14bb70a905fbca78006fc35098fee47b712117af8eec119039359babfad52ee504ff9d5620935c61ad683ba9d3653db43873cfc60787c7f4123b3011665025efcfdbc14edeacf39acab1e8dd31da1537e1154ea43a463efcac93480fbfa9e06e7397a52108d014c60caffc115ab5e702ac96c21af5e66d71a4d55783fdafa46891d190048ff08621039dd858b516f313ab0c55d358c81d98c942a3e0ceaa83c40bd2bb2d74b259a1ab6eb829f1e90cc88e91b4a80b7ae7d1424f2a7f1f5db29beae5da32530e216836b922835013ff078f76ec4c6bb51d0df44383287f939d749f772090b12a04f397d5d04a9058adaee1a9f40f2a8ef068bccfa283fe10bdcc409ea26d3cc490ccc0d8597714fd5b56cc49d1b55806feb7a03feb6e3ebdaac416cfe1d948824e077c8e25ca16392f2fd0f5f91efa4de882df45d198c3b01dd1a246df88170d409cc7210035a542758f56ed599289631ad694efa747691e4551518de5c8e0823b7f8a16efc14ee6de0e8cd049dc65945362bfacc83fcad814f4ad4718d844e1fc5951fdc1f7fb5ee22ed562b294144cf5ac757e99d3cf16518fa80e1377845102baa5c5cf619a9d752af4e7e6003468ae15673fa70e73e07afe2cdbd6fc540d45829c158b514eb72a1736ad141e9c0ea2abd613366f59804b6b05357be1c925e39ea31d58b0ed9ea73ee5390efe43c7130168adccae623707c3c97ea6a38dfecf269b0fb627c7c1277d32542c35c0f2431e1d2c3d84e312ae1f2232610c581f904fe7c4d8f234d0b8517b97a5d3f8e5e9289f26f0f6bf85df42253e3e19aaecfa10c725c290f9aa10a12b33d1ab0bae549f83f788dbf230b9bd097643863a56345bd4c6b0f6c6f093d8a3b2f559d43f5359495e1928951ed6089e046eccc743eb0bd1a2703c816c6d27b9e638c0139dad3e4b5f76888b73b5849dd174282b0090cc2fc6416f0c171fcf204ef98ecd0c84c417a02a3214e0aaf6ed136bb01fb01322f73b3efcb86c983c524e4e47e398496fda0585d0828a6931104e9e4493791996908e418417352eb05cbffd9ddd7bb2d7dfb0c3578bfa42ac7b116f3fbed337cfe198a6b9bf7c27881c134ff926d3526a4a2087369ecafab1498687136adcd9fc60ec0ea95a2c06fc11bf137f1813091365fea2caef06f3a4d6c693d78145bc0ce6bd7e1a8abfc9af7c8e9c004b6a947fef0f627d77c43e67cf3c4bc783c58f8b458b8c6e61a1fca1b3723158a72740d7e9b365e875eb4e2a6e75f4c48155b5680cabeffcdc87ae20e8f10d5a2afc4b10c2cf67646cca1c3136ce9b30814d8e66f5a7982c7b27936b688118247090f0f13763eedb11ff35ffc6be3f5b62970007bf59bc1c355c482fd17360386b0d1e2cd404998ef6853b77267bba3c80567262713b503ac6292fc9665563bc180b06f0035f41c030f73bdfa3e71c29f5c8cca91a8d96b921b1bfb6111a568d71368da027f76d9b3de7d7793c8bb3458318b5e7696f7894162ad21b529c5bcf39b7e0ee3ce1c4916b5a823c181e90d3741ff4ec0706d224bf34aaf47e353bdb4d4a060bed86958a05978fc0ac5ea3721c66871714daeb5546b7b8eee638e9319c75db21c21a4db2e7b2cd35f019bf3fa2c37c9ebdcadda6a92b3542361ab7db5a7c496194b3b2357f949169c6fa1289653811ef10d5d7a0cfc8331572bf16244d0ea1d5eec28a6ca9ea934016377572d5fb8004b7940ab1fb1b612422c7ab8c2606ab1ce7bb2b87197b52ec24a86bb9f5b841bf289722e0564e27fdcaeff54162d95272a8e7ab2cf01fb21a93bfbb48f3297bd00787297162bad46976673833eed7491d85d9717c88db562b80f90818b63226f2373ac6a3de803ada25a130b9ca7a166525a1a400827ff0dcc98e64862af356f1264e52ec5d7e17039a17838fa4f4250958d6562ca3928f3e116da645bdeb192e38a55efc6eedc3596095b0878541abf92d65e37fe12fea28d38833c441947bef8393c22760d643396238e7d0a69bfe911088ae47fdcb32d0fbf47c8ab7a92ada8d9060437a1a0e4292ec00289e3e98c15d49c43235c695cc7ebfbdc402a79d3d7d4a50167b2e030060c46f4421d5d4f28faf772f1b9f690b9e3b322df1954f1aee7cae540ef5e21ee1f7528e15d4a73d92f514ff1cfa91494cf14c261a25a543ca5cb10d211d5bc356c367d914876255799e07877c8915418f7c1aab5cf33731f0dbc4b6dbba04039332aed3c948f3e4bd96ed1615cb39e44e3fd9cd64f85bd8c6fbfca49fc5dfd3a1eab58e2be1c792cadcc21323d5fc74cbb7995b5a484ba13468913a597c7d995b8520138d56513e40c720928124ad9d4d11d50d0194d719455bcd3c833e99ae0221ed90efff01464d387a0098f5c3fb02f861ab4bc4e0c1f3af44f19ae40e4e88851ad1d6e95e25acceb6e578d3a4be0362d70e2d4761b48b43f1eb7f0125fc9a0d55eea62f9763f1f910473c72e18bb195985ee9120183a2e431caa61f97f14613e6c12b06fa36359b5f8490b89f13603d313e67c1f6f5853cc9dbd743a254e240d3b671e9df3bf0c5c8d712d4ff810aef794898bf7a4c49028a2ff7fc9a81053eebed7678f729be29ae8f507c5f3233fa444fa87601f963f2bd184829fccddcd7ab6983ecd55ae3795a3fba3e1f387ec54caec6392bbd7ee9211bcaf4093015409c3e3fdaf6511924fe19d2db0e56627f021e7292e98af7e9039694dca2aeec8029dbac5e8f13ad59987a35176f9de985e382f1af53dfd0d19963e63acbd5e68ad454d72a16001f5a43ef073eb9d422b8f3d9c0ed78bbcb295d88536b3f5559023d9ec067f38754476e7a5ec17997210a08517fa2da76dfb48d81c2725d3ca608b0e0117d85041db47caa4e077e65e15bbeb6d647f7df0e8d8a9b9cc0f34897ad33db399a868099bd47063cb96938070d0cfb72098cc79fe52490df45ca9cc74e4185902ed305d2fb32e357fb185e732e4ca0f67a2d53018f77ab3e338666c7feb6c0089ff1013d673a8b7b7095ca358c0a7c454d76b81e56666c993faf50e1ebe0eac046d565d7fef397fd12ff42a455616367185e1c4377315ebc05d1ecd790bf5f01add21b79644e902ed642f49be35c0810e060b4e4779b4a2995f97926cdcfc60632568450af8bf91781c135ca61d1c03e7ab3e3178914320c36a959d1c8a238cbc66935735ca70f4d36234bee43caac9417cfafb9a7d939c8eb2640a8373e1688f17119568be04d750314252462179cb14b5dbae98c72cc60c34c9070fe261f93a25eb30206402b671dcc75da6733ff718710a1a0eeb3b9cc765fe5044b2778f08d14dbac7cbdc1338af1edf1f7791fba2525fbb10708c82fed72c9ff201055c7939f522bd7ac094f1cad3be399d9758fcca034ce376d72e957b009a119930e9b08883b3e6c052983211066fb19e960e3ece1d5796c1bd690b9ce71de8a9d3558fa28460110451f567806005b13e96d26c1844c2adc45c4594218ce381adb79c0b2994be5417ab24e693e5ebf5499856968ee0ce84101079adf006e84be61368e1076d6613efb01d9b3403c0388de4b4dcfbb316673238fa175aa281662dd7014ddf881796239942c9e9d7acf18e416af8a7f13939cdff897d8b4611cd279fc005e33806fd8e398d45322cdd0893539d75d86fafabcfaead42d39e52cccccc37063128234c2f85cf26c23cbeaf70f727d4fe004eb28ad4a99724d08b2dca89101e901d63b3f1e17f53afc8dd3a03b1cf60ef919b0819216d2d30495218a65c4e8a6b8e833bed164723664c46b6fb2321dc8b9b40358262d93be162fcd5d1ae7367beb97d382fa16757724fd4dcf5090222d35ae78967fcdcf9e500d575cfe94df7bbee8a43014ae92b4c8e3ffb634a1b1c40c29ba64de274710e6248de168594830ec01c02503598db992d132da38308eea6e4be3f1fbeeb1618f4e2e5ce763ec421d7da983e71489fb8286cd562e7d8f3193e2e6160ca5da297281845bd58adecaf01497edabbc3c971e481c0f5dbc34e4231dce613ea1a2630d1ef7e307d98738bcfbbdbe0a2be018cfdc448f3e1e7b57285cc7627f9a9e2781fa98d4afe1067f8539e64d83d84a620e1c759980fc7668c3d855dca0440a21cbc79b677ffb2d1361cdb06939272f28b97db8e55145be6fd9abb74ca149f66f5eeff68ca8dc6e2ed7ce06f2c6ad932dafa811cbc0974ca7e09118fd454d4b7a0d6e0e34a205f07c34cfb7aeb58275e0f86bb30b2e73891b50982762e0fa5424596f0efb74417557dee2bf283686d5539b0e34ac76cccb306c6f13d8d7f07cf1cfb58ff6170c13fe9d1ab2fe230a1369ac97ff7a39eecdd8b7b89ffb5b7b9e9f7434e9954007ac6940b6b64c3c41bcf79601b1978538ba6067c41512a8b8ee5b437cb26aa87180ff7eb6a9f494564b8afed2c9c482ce95239a73eacabc1cb962aafbc4e24caa5443d57004b8aa2b1652aef7ab455462a1210c3325b57b9d7cd2fee5641dde93b34e26644b58b289d5eca587e866ce5e690890b93956cba0e0de424ed56fc4e9d4673d402f8388b4d31918446f4a8af809486cbe5b3fee833d80450a786527708b9cf293b2618d121edb5e119c47521a4c8da90e2b441d63bc5c73db6ad9d9fd38dd81e8c57fc2ccc5525fa6b73ede3bacd6997b7a9b4a5af1496709bf713586e0fe2273d5a3a5c27324fd5c5355ffac3f8414d8350d6cc144eb22143f6c9d44c472e698b555fa5a32b8c31b9af27f3cb25d21325207fdc6ffd2b4b89c6cc47653c6f7d775f43dea572e0efacb133af3b7aa0b482c0751f51a9a0a275757b554bd02a05f1d83f6267e4fb74f74e2dff77b43722e59364afce481e2f850a17fcab53788abbf11bbfca71ef92f282da9625aca05fcc69692a2cd2e7d095b727eea1189910065066cb6c05a10e52b35e3c28f373045a1e1cfafcd3f824196a3c24de5c40a511d46af773baa5f29dc9f1aa55d4dd831043dea2e3ad788a06dd9ef23578518385eb24cb23f14f1aa539c9f746ae66eddae8c006148a8d6ab3238bacb931ea41484c1c15def495f474ec6fbf676827fcda839c708a6d2130e7a7c10b8da4ef7770119f70feca878212b348badc72b78e1d8c950b7e302ffe299d2ff6291c94d1626fdc395f06d0d01835b1c6334c17a6707f7d2e08da816b167037f928d1e3189ca573093f1ba4d0d722339cdc475e9c933370052162aa4eb4de927a3209e57c7e5b3c351d38bc4aae138b94284108bbd0ee150497c3016947eb8ac9415975c524c7a0a13344540700f569904c92009d4c0587e1fc27f859eae6f46b8b696c7e4540e7633f12b7973587760a67b7ff215655e340d574874f312b20f26abe4e207ad24e179299eb5d4b436fef10723874f738428b8ea4a3f50ae7f753e3f673a85710dfc47f6799ea083050c140df5389107f4a9c984e93d111d46694275101d446deeb17ad13342cceff3f6411217ee765f97f1cd0ae7421ba73dc0c2183cc94b12bdb9445772b937a9393fc12a9da507d7379ce827a18298b749be853e0519b529f4e39092b5e1708636726963814fb7279687bdc9a5ba592167cb7af132277952cb0713aee763462a437a866c4f851e530717dc9db3eec9e0db83794dd6cc0eede3b4843995e132fac7f364ff806989f3143ea1bfd99499eec359250b63976da9dec99aef6a5fcabf76873d3d61fa831669e724edc2a6bca183b851b78956b7c166a5747e8d7aaa9df066c3ad180580a04ecaecd63da051d975f806d5846324793eba746909f2e0914ff277d798dc5baee1755ea56c9563149e0e91f4e64342f34e8efd3289d4e1cfad2a595984561704a7c93605149980fa488be926df4ae82cfce9508890af101a16da19ffc96fca88e22ea723020a98b5a773ebac45c557d5a918dc09a23376014f7127afd7a84ada4f83dcd62677519733b3afc793b30234bfae9babbce1caa07ed19652a0e9d191459c9091d9f79e9d9f316c5e445d45b0ff7e960982e3e05e9a39f875f6cf1269e7cd8b189aa5460c86964d092831c3298e8f04cb9e0df2efd66f5d1067d6285a95ec42c2e4f9c934d282e62fa1339c063fec81270a87b72589a16337ce0af434deafae33cdb474ef1221bd77a8fc8e2d35945d006d673c8dacdcb0e3a0c052eccb8a691ec449f7b40d27160fa5765e6b6884f2218b6139fed5ea33b62cfccc5d2eb9480138b416a05e58bce6031d27e493723d204a4ae52c90ce8e8ef40b05b7b9da719c268d7757213dfc62f49f41910497dd2a89d019538ed4a2125a5b6f09b034914271310c8446b3a337e25a561b73b1e7b74484ebac6a70e92f6bd5272aecb5bc96571b227ae4fc9fdecdc1835ddb9033dfdbeb83cf2148f6e1be39112b4a69c54263a49c3201a2a3f1070d7c7693692caa82a488600676eb1fcca0eb8c6ce396fe962631e18513a93f326d1f4f030996c4279ea765717ede6a94e19ac15f647c946d6e1a700d035a60ff5293cd6eb194c4f04f839ce3de470bd079a63d47bdb6ba2bc47e79201c2d86ec65d9b035d87cc3bc06ceb3273ec7106ff80ffd69a84655da43a7876a3f71722cfac43c1c3f3a3196b1b6c7613f5776f69f2de4e2581392d7a119d654df971054b9c257d584e2ef0e9c00368d23c78881aa37f616cab8df9208578f2d7b7f498992b5424a75564b67833cf96ffac8e209a5866464244a23478b07cfd40c8fb9b7ce3788612a710861da11d413f2968d81056a12a8ceea6c55fbc89d0291ab6dad6fe3c4f59aed4307ff2400630c6f907f6c44bc3d4b06d1f0d5d425d3a681886dd8443428afd711d46bf48cd5d1c261c8c0ec4f5644b49d14eb4c30d52e9bfe57333212e4aea239838cc11f4559b3a20a343b317a6e49b6e44d03e2c04f7e11c2ed21deecdd682a64cc77c16680b94479851d3d61bfdb0a4de7dcb202abe366eddb626af8f25c4c519c4c997a6bf4ff4d7b588ffea89e51dc14f079062593c544289182a5a6eb007b485f7c6fb772b2db5a8f53cbaf0074373c7fcffc534d44db35a087c61154bdfce7ae422c90409316787c89f5d30123a2ad4003bd6329bc3105f5aa52253b353d9fda2c8a9dc8f1ef80ebffbb301696a34229f437bb5558dd8f4d21762b98e05c7db2d15b40f2e5edefdacf5f8d7bdfb1869c9604eaab23e86849ec41732217692afeb4fb7811b99150aa43d0c9755cb5501a4adcfabbba70ffc35f435997dcbcddb4fad4d6656e87d875542046d50a77d997a062b6d2e8f140b645c251b66df0342731c7306ec1fa5df9edd7882da1058f6b26000ae802648cb36b3c4af5f8b51970e56b294f6e80e63d45e7491bad5844e6b5b0a395545b7b51e2be77a8daf4af811c5562c1b68d52ca4cd5c3b50f6977e5562a16c134dd2b0fee21e0cf1f4eb9294ba664067f668057718af70541dc289d3b130aad3fe90556915ac50219ee534feb89a4ee71bde852c9587c1e8c24c91c81d48d310e389212961f813ac044e300c8a53c7516181ebd6a8fad54ca3cce12f09e8f77a476a3e7e454bca825dd185f519ba792a9378de20185f79a364814e5d09120dc7064c438bd0f07b14e81d981c19118266314758e9afd87babb56516a8da14a78f871295826b6c4806c7a205b062a96a758b9a6ddcbf0a21fc06231a274ae3952483a43a7da1a52ef1c6f56280c3b53da5cd725f60db364b0c0adcef1d0a020a4bbfd87ba49ca4693bdd0da2a7ee497acdb181db0dce9cce72ffbde8830b3f82eadac0156a0dc78d8e1f618d6f471415816f0209fe2b7cddcda95b9cb99b10adf6dca20199254cf8a34cfdb4575608914b09c96e8c1fcd6d5d4f91063181e493a442658665ead8427d9b589b67616bca810aaf7b5276587b6187208b0205efb74f8751eca0daeececb8aa90d90c2ae8c426b939142b073a6ee6acb58ede8448c178311ae9f425308b83e3603d288e2af4ed536e439c111d5bf4899acdf5dbda994f77b0f2bfac6226a2410473a0f1f3be973b0581b22abd93b0fa252951fb2891dc6abf00ae0cf8a0b6205d4f8083faac01ebd1ce895a54db3977f2b5b04f2b7022b7e8853d0bf356e8c7c6dbe018eaa83bcece4bdd60be5d4a2f72ecbcbf5b2e4c3e43db3dc4a7fc02d01fa0c0d1c894be62f222a967ba77a0b0bb9724114c9f35b7bb06d23a4eb0563c7b919d094b43a59ba43a51e539a0fe3b7bef9295bcbbd85246f50958c5fa0a62d79e74ca8feffb1f9dd170d7aef437669698cec66294d769f7a28fc01876c7c7949ad9d95ba3a72fefe0ba2c2695c4762a714b8e16cb00f275c73dbbf9d42c7c4edab1646876af5f9fc75baff044a5a1aa42c44cfaa626a76829db27fa3d2ae9e93abd4c3bcfcdccf499315d4645392330763b673376e1756ee839b375076c2eabc39a01e3d1cab7d1188dd631afdbb63ee52974800810aaaefd2c3c020357478c8c255a381b56ac4c9722375e71b8085390760d7d5804d156fefaf5b925ab4115810f8b5ba82a6e1f22e340691ca5cf25f69d8645762cae0c7a6ab48ec0a58b4631061115cedb613e8b8d091f58c61ebe82edd9be49f1cbc36643f4479d444f4460e049c707ff159b408d119ca6ba13a18182156e1a2ec7d9cf35dc0dc57e9a7df759d8306397a1dc4ed505f986e6cbb829bae1ec8199dfe59d54f59d73befa1058cb93bad7e4d7a4b1c229ab59cfd281c1e93d7c90597fd73072d7d6322f2019e7ac94ab1ce305f8175c3eb2f11a24cab9e0924b9b01910be7cc4af56880b110aab0633cbac13dfbf445f9578a56d82db8d8a6b745657a25fb28c77bfa5ba53d5cfcb4ba4e322b9d0d74b96c945a9fe4f645da4899e7c4057a087bc47e04325f6ea02f8734736cc12e14042f6a7f9b536992cfbc4bf60b71138ac64cd8acc2f5d908ce30d24f05922096af84eeb77a20c8fb93b7ae383d775db3000c722d2440a11eaf4b43e3821bc7c5f362dad2e71300fd86f13910c8c804c2470caa1f17198bafffa99523e2dac85d2d71f0d4dff803f6f93af993bc2f3ca10cc4ef06b4d30de1f42cb08357bf4fc12ae282365974915eea9bbe8f88967baa7a575cb87c6ac8479a12fe88729c83dac5c770e8e1fd633b7ce857adde98e38593d5a1cde2786bdda27f77e9d711366003d10ded925ecb4a9d07de17bc0c05eb4b12f755888c78c415b44245c2f3cd2d01241e590c3e2b05ab43e0618a43418c9f7c6e6dd563a3656e4f93c008974b15992f4c386f0f3dcc85fb91979c22cde5042c1b3d7c0e71e8b4b1e68854c0e00f916117403949b2c4d8f4ef599da0fc5cdb2ee695d66ad83ae780aa69f9ade17484288747bcd5d35d9423fb11aefca0b3fe1e361710b7bdc17a763e2371fac7015529ba7c1a15092544be2733e8514523a897c4b597008d83ec28f2a7f90666b15597097d4df1cbaf15e26a14c41a671add41ba9b5e0a01285bb413ac7049f3c20b333794f4bb258ee429a7e886b193a56eaecb883bfbead7323c8df3fdade9437be5f07077a1b80358e01a2b7627acb95c90701ca2d4d19f4703181171d9a764c7090f52869f327c22f61116119b1c6a61c568cdba6b53f1380bc0ec292ce739fb480b1a58ed1f80bfe11111f2c1e1c39d2df4b79ab07dd4fdd2ea3d7037e31b66c010868c1a383281bdcaf414bbd99280c253b956bd1401872cec028d70f934f0fd0491affe7b79d6ce7022f76ef0570922fb3f5a31f0ccfcca598587d95f6deb5028fdb3cd94198dc99964112cbebd0fcfce9a5f316b2dc44d93d1aa2fbbf462e1f3772ecae20e044007983477482fabf3419dda3e1fe33e913b9ee4b0e3baa9b2d3b61b7978f61153a646112fe86076a0e1ff05335c5ba04aa991c25b04a0e37ee7a3c2a97808efcfb56f02c639b834ccdb4aff606d1cd900ebb14964341f7bd28e5dafe7d76cd43bab75bfbc3b2246301bc1e86fc26179f10465e15f82fbbe19c3ecf584878501ef771c3c9ae7a9899d7d1d18953b62200de1372fff1d30d3102fcd8eb92b89fca0e8d923bcf27376ec20c495be42ea1ac37d162c523fdfa1697d33c9135c5c41f5d3173f933674e700ed1dd8fb8fc5a9aac22da88fa81ab952ee34efd07acaed54b9a555f9b21082d359116f2a364b4a85800ee317832545aea33b4c5ae842fd64f70d14ab7830d7b74193697376056d9e9077ebfe0279f35d55f5592fc982bddbc12e37a0554db3cb7cc834922be39ec48644e695ba6cc9b412dded7b891030f58ff526be30d506fb0ee4a7a89cd8360f86b97d69d7daa9ab0affaff24b9ea0867f4cac1d7e2db652211f0359b2424aa1d894bde951086631982dee9b0c2e465b58271e23cbb9b926cc19daebe65ca67778f41271aa1bf15a8fc09684d95e74e3b112b7f3898a19f79023f65480d8f14ff2e4b931a91014c1223e341930e55b71c0db3fc9892d7f200b6be11bcd5ea327aa20714efe588fe3e0ad31aec5e6c512824e3e86cb95f502f79d8955c8b9751804ddd7c53f5f032c639da4aaef2c08dad37aee9b3263f39f25ca7b41cbfc00ff2c111b1377c8d254a8e19231ec152bea205b636e861904917cc4b91a3426a4c03a5e78b39966f984a8f4abff9f9d1343112e42dd09bc65344ddd9eae9f7b033808a966c25e0ca44b0f1dfd01dd85b00f828afac458181ead7166aa6b2223caacaddce3632523823cd4686e87f8eebd73a9ea3b661305d5948b60e55398e012adfffa8e7db9810bcda27fba3a704774e1c2809bd3baf81149aa79b5b36ccb97392bb3662999c71cf556cddfde2aec19b98a833546440896cb2ccb5320467eafd71fd65b1662ee241e747ab4e02b42aa8ab9f6c5c859821cb1562bc8101c6a2cec4fcf0fb146a4f48587ac7d0e6f65af7fe7f2be92aa04cbac415d6d895f304b01cd164d0294b637e3b31e7875f3129f52b85bf350b2608857a2edb82e320ab056c6febf00853e4fca79178d5a152c483cf4c753cb8815b096b76eaffe57cc364dab221854d5944de54e154c519f435fb3f4389d83830f9a2d034e3fab78f9234cae0e39b85909024bb43e5845469c69dab1bc0b4ebe3cb3b39ba7e13e6bcce301922465a8f1fa7d82b2bf84ece978d3788850e9179eb4e510f5a51f7e37cd89f0467245348065678783dd49325b649e844df98960209fc21bc89829d3f5d02177cb3d8dadc2c24833f2d8cdc010b9883d48208af95932269e8c8748df870187c87bc6d46acfde13848053ab7e82b859157e5069ed976755aeba6ec5ab0dc05a72082384a44afcfd6cf1589d067c4e845ddd720c767c10bafdcade7cf24e6d1270bcfc35ada965a4352bfab13ee4011d7604ce40d76563f1ea9e2de21fbab06c26744d882a72f33cd326dc3ecc665e771400978a66ef7573df05d509e44245e2c4c6c8a8160e328ee92a92f6aed76cae7dc4edcc402fbbd9154798fbad2e136b37f7d0c471e046a140b39247e33f0eec28aadd01edb04c88163998c6af3a6300bd8b6180155b136e4424c1740d48f2dfed83e768d12a5d57c11b66538f9fe5ff84841da2a45f024dd06e29925466695090471cc880dec4c43c8e9b3b2f5bdf8ece6c230b2be2c3ce9dd200e2bd7dc939c79add7038749d138a3c8042b744f161d1f701daf447c0d691c4219c285ea1e91069dfb8fd544357292e0c03fcc50cbcb47e841ca7ae32b85788ac614955c502f20f10c965259b2f806a3e8baea6e4e09ab14ed65c4769b44079762ef39dfa6c9ac10afe2ef50b09e3235d32680e0563dc582d44c1e960edbf437d5716d156a41e76054fc9e4b8a4fefd621190507585cf9bb7c14d463ec2f9646d9f4fed1ea9322b7d0903ea5748a8524fff35bd352127c244441a6603c02fb579bf7828d6038f49d60fe202202d62427d6eedef2b51c6f830539112348b651d1d3193c2ba1257767318cb87089a7ede7700ec6080015c8e988b3f56703a858bddfcf3358f9aeb9a166336431e5433839149521edbc894e2ed9f3f3a33e8cb0e6a6d03622e81dcd0482904b48248ef0d564b98a4c76c98a7d3a04ff7273f2235fd3b6682994dc2ce2bb2a3f83a53347979acf7a388ed470194a940bcfef60f078e285514072d3812f071179fffba907b8dd00b002ec44aa0e073077c82935031db2b77cdf50bb70504100f5836cf1f57ddf5cb857b3cc3ef7c650c39994d02a1fa9210370f47622d7bcb1a1d04164c9f6a62d14010b6991f42155bf692df12faa1d02e0beeabd34943b99475aac746ea266be3fda27ff469c07545f9af8b32521e4028d1e583b82019ee6f309c8be5f229c619ed3531fd26d73adafc0cae3673e19408e364e24b9e02789aa4d3f3f158a13be9b92214e3c335358b146f68e44d7da2d8e12dcd3feb34f5b7f63ccb68068332dcfdce8e43f15fc570ef3c966a8cb2e32f392a161bac63c5a6d9c0b407147bdfec3c4e51c9348e4d80c49452fabb310f97320720bc5632d9e49ccda64058a8e8767babf9aa6bcd69d56819540d39586a08061eeb40120e4bd0210f22d185ea0bbbf8c31d23addcc8a78d8a5aa288c7b88090e79b672ef05f7608caf4829af7a7b15f94bde0421b5e628f0bdac932abcc27f0c8683317080ec41e8dd0699cb696c35b367ee6d8a856445652f82ec6e60eb01ccfc814ce013d00c61f63c31c8124127eb954c6a7a993160421d249cd9a7dfe2fcfa7d0702d5d833271cacbb9a2589cfbaf243b7f23f6e1eb52e8ad42cd57b7c6d212092563a17c0a92038b28b8c455b9f654c82d9d4a56714fb1c031cb7e5309c74a4fae499b7d35b2a9f3b5308f5f53611a40839d3a408b75d08d3120757b092486ca33df3b6633eab3e026bbaa7d3f53a15309bd1dc6b41f20091cf668481f0f4619d5725eae3c9dc3990b182470164beb065de2a7ba2a7f300286420f16a97598265d20bd0833c382b213ed64ee48e6710dfd08115f259d320dffbb759fce9f6bb9e4b9419324aea6905473dd856818db0e4d8fbedff2e7a6c69e9eeadb452f1533cf7c037e54920cadcf5195144f5cc721b456414cee46382c986e63144effd41b70705bf6109c159e6eaf3881cbeda3928d857e057050578b6a58ba527dfcd009","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
