<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e81a193c4d0d49a09740e899b307cada5a1640e1110609883d4ad75508c254b4ca4460f039993b3dcabdd85537c2699c84673d545b3520b1f995f991a50a2529b1911f7cb01199a706b7fd5db6612d8d8ce58bdaab04795d39fdf3588fca787559fa1647d81f5d8c27eb4c964c1c82a8fe5e089ab0a1dfd5018e8fa2c5f4ce96d3acc61fb650ab1dadfc162c61c9ee40cf45b91dfbf01c7eda5071a08db87adc3f0e15ebafe057729d249a7ff25a5ac6f84fc703085a5231f7ac6006a1bb56ab9a7a5e61faeff8a7d2a0c55803828a1d71b6a7120e3604d5aff1c5ef365bde7cb363ff8ecdc36990b9e80140192b1f4cf2254c98dce721fa087a1296b07d87a0017868cda12f751a017ff5bc8a0468decf6b1aacfe31000f80ab1c7f2d93a74d592c6703dc68098c9ca93fab83880f1b45648c2f188b0c7fcf96ad959d3e0e5943c68b68076b851bd71b78e8bb4272681fdaf123b53f57523da0835d0bf0bcf75e1278cadf65e630fba1ad8a05b9d43af956edf53831329eb6551191a8c8a2990e0edd7645f316f04c8a5614e0da3d6debae145412146917558122151cc7454e11df53505d3fa490cdc0278e8c396346305b67e0cca611ff2497b8497bbd5a52919f4af999bb6c226533bbd06d435d6c40aef2179db35ada0d2b84b66d3cdd2ef65c0500d0bf566f646a68f5ade81d27c10bd732e5dcf540f4aa353fdd9768871ec4887fa15d79539ae30276613c407d0f67d6228e38df88a21202ac199e9f67a73d7cf8ea029b1f972eac213723136c0c78acc80400d4c395ca6ad0c73a13a94c8021299243032152777b4ee70a95650993613d851fc48cfa871f3902239095abaf01dc3bc94db955fc816e3166b9a13bdc4418c02a7daefec8a817e23af14bb8acc80ad66dab6dd23f92f93c9b6e35f9df015b1716cab3b90ef7933da413b24afd6186e2dce71fb42a76859573df8b1b28f29c9d17b1b2b3b1304172111f19e489cecea5bc2c80e331c1b16e76d0e99992c36f5b71a7bac945ffb1591b8230289bdda6c268189e4246a0bf3adfe432f1bd61b772076211539166565ff24310e7fc36262294847b28d9020d8c6678273f3d378a7e54b9e6ea8dbfd65a4b9b8cb47862584da0b52e2c90e0a92178593bc9c05d1d60131b162a8f2680876427456578350ff9988d0c9b3d179a38e81610b0d8ac20076c63118a51f6c00e687b06151fd6fff2d63094a11b8acd9f725dc3596e08f85b58145d3aad1ea86f96dd2167e719bd76326eac933efb7b052733c25db694fa94fd74bef9138c8417b0a30747be0690e5ed14742c1f369628918d53cda99725e2ddcc5b41552e0d3176789fcdb18b903041b2ee553e10b0b6c03c54c5202c167b4e8f6a4055333ba83d83b70ade0892a1e54a44e12ac0e32950c439de5d66261a478e7e3a832fde871c638462630391553b6a7aeeb7689fabeb9e8dec17790467be7411376344a287b13f0e7b59f3c7ad8a704b463a880074a6e4cc8c31f7a6bb9897388c3db5f9a1dd950fe59e8690e1d2a6c848e18a0fd100ad085edd80bf70cd52d59512e4b2c432d9c9ba773e31f7b449b729e1bce6fccc155a871f484db0961ff0377df2b8ebdda49860e6fb38d768a0bf8256684893c97c9892a53dcc1e92bda6107926294f0e6a409beaf74c287921eeae04ee60355266e303adede076b59e43595c91144f9ec4de6ed22fde80586c1e789e45b977b787cd2156b05a2308f20aff753db1d82a10de59b5f8a0b87af325e224044a42eb8838de0816a83224c955cdd351263f17b75aebc0b95dbcd4e864f8ba244e0281089aeec6495c371b124397e48d7016447fede321ac076519facd54470cb182acfac5d14035f7acddf0a37746f1837c1b6bd661115ddfb784c91090f04b9adbbb7123216178fe87ac17f8a7f39db6f065615d9cdeeba93e5b3ebe529bd5c66fba8945d73c50df7e9e0beb39e6b70adb73b5f9b3fca0aa5b0ba498e4ecb6a5ec0cae6f633b853e67ac058197dfcdf7afc4fdfc92039c64f1e1c19d6255daa466152d7bbd7e5570bf14bd41d094e1c833adb9ea305b65a52424a93ddd0774b454ba638d5d1e728e554fd0fc3f03928bd2cfadca39e7bc8131d8da2a3cf0342f6deba743c819679f5826b2b93937768e2112bdb1b8b083a7bdfa46a0ea80aee8e828e6e6903d38c99274af227bf93b6be07592a7e2a3ce52ec094a38b80db0f6ad068cdf2295ea0316b7e3e50377a7f3af01a1eb55e6098b8c245e5ed8b53c6f9958db6748729354dfa52ed2c483da108e683f4168e0cca7526545f0c08ca3118f8b661c573359985e792c98929f9e53a67e52b157d49ac2491008cf67899cc55686d636ba3a54fc805cfc136753677829c686bf3c430f41cfd2e8dccd84331dc94b4f82cf103ff88e7d75663d7be7938899f86b647d5c82032dbafd2eadf168bfc6270f05d0a627925a958cd28d6120eb61816a1c55cd9aa1e0ac9097073921505c8e7aacefa7731eca31c681008fa9a10bc62b16aa19551b2849fc3d1703e639dd98a5e14a819b7939abb4ea412a1dd1f97cb05e45c155fb000a5b4934137b58bec7610160e3330505ddc5e7f73d371cbb29c14f81adc998722430e7a708140bbb4e559e9781b28317838430e279388724a1a7bf08bc752bd726b3ba3fd173f5f2aeff0cdc11f65b62ddb3bcfd776cd69a5108d0951d933098e00e090df1f8efa12d653a3d9d53a4846d43c1f3d2fe2186db16545d841576f6115c29a4880304fffe80f82377295167ff607ed480dbc7341f273560b5364cdda623f0d44d0d6f23f56722457ae78f2e340d252d7092f3cf7df085029409a34aa3844dca36ec3114edc64df369b7b96517f7a70c4b3c32ab61238466a57b25c01772d57c6fa4ec91191f2deba3bf92fd45360526f4c281949cf96bc8f7e7fcfb2be323fb3a63db6a480ba597b3a433a6eb8cb1b9efd23c8b72ae53182f3fc53b3021b7066599b8fd4ab08481652c1067c849e0d1b31bf956e6120ff643ca791c60eb2c6c5fc104b1d4ae4117ca6ff5dad68821a5edee4a00b96daab985fccb1b189f58feac98659d7aee8ca5d6c9d853e0cf11552cac2ce365e0276ed13e2888300ff95a4e6c8db7cb06c64c23dec8c4029e2e17661c4d5c9a5a50fceedf8ad8acc073530ed90a5d355e3b747bb6548fde30312bbcd14a2ea49e81325ea542eb283b602b5219deaacea890e8ebe096e08cc1cc20cd5559ada1fc25e98574dcb2561a9638df1e681477296a4005b17a123e4bfec43c84749d103dcaca1758da2da30ddc93825ceacf8366df48c8faaf931a3fd90d384f59b4ba50ef884904b419ca219f4e2ce701461c1d221c75aba6bb20293fe12ad75cbf64a90f1eba218ca16feef8d0080fdc14f7f1fd2491048641c361b15fb57b0ff9a70b49aa6d4ef7a3f628542899bf440bd53e5111c2c5211f6d3dd314145ea54674424ad8ac6bffb90e827f70dbe821913c7e619b69092d9f9c21c6e919528840bef64ff279efc6a951d64c21f419ca6ef93e4e232e474c931b4f4ecf23c158399a4ac8296146fa72336140fa2e8a92a5ea291584432b9f8e4a9ec94bb35687e3d4fe711a2a062dd14eadc53033dea2b69116e2a914ec2be3a247fe8e3368cbe6af404b6fda64729865eea32fd84f4817ab96210b0a7a37cd3566b8afc2e13457030434c0a2122f02a1d0a605876145eb0ecf88fe17444fc1fb5ee56ecff75c38a20017c2b2895119da71450d1882049d556b57fad33a45631d9574dbfeaf3b224cf9e00598350e6d57d62615346089830c705d6b4b8b9d2666028c0a4db23bf9bac87c1293c5d6b5ecded84e3db400ef8e7831a6948b52028b3b419c4b5dd2a498e0de4b4c8761c20ed209b1c43d52e89bccebae1c1d60aa8beeb40a5279ba1a5f6d54fa16a0d8f7641afd3cd4762431cf65c6aaac320c7af8052fd315bc61965311875460cdfde1d602faef305143e63485ee0dc76913f304d89213ee8c69960782662f13a0235874a3214a04364d548a78d18fd4c299208f103a54057ae36f03cbcd94d490537f84d29a51519eb63c1f92f5f94768504ee915bd7f7cd039ff915dc2105b1ae55321a080d85ea09ba7292e22f5dde931c0cfdcdbfa3b015deb4c3740bc75e04600a7d6dcf2c99ed0870c90fe4093c8d449ad0475f1e0485d1d9f8193b98300048812e601507d36e229ceff53392f7793332046ddc391d18038b23ff3d10d6c396be8f01d53be239333855ea34aa96fa6773983ad03458a7c2cef2307f9dcd55e7b8ce24128eb7e18d4d330635fbcd5feac0b1fd596a224626c7b907b033b314d05237490f1c9ad44f614007ebdb5ce3f7008ad6b25a474df48c5b154f8a0ced07757c29c537fe72206f213d01559a7342ace95ae2ba8da037afe8525e0e0ff37b11dc2e1c19667fbfb05937ce6ef21444ac6e1c44c6568c477958746e842ce101f921d50ef27ddf2085cf55bc9d94e6e91ab4d0c3aa120dccd1032bc86dfdc9a6f2ef2c7f075a3c003c42dd8072108adcea4863456b1542c1a671ac14a3426fb3dd063cab6a6e95cf0ddb9bbb0ce979ef7623577586020aa7ad6a86accfafd38fb5df01902d94fce5795161ae8d3b2d2efc09d5bd160486d4a1a71835eb6f1b7bd6643623f653917ce838552ae7d79a872171cdd68aec9b294387296095e0756420c8f2aed08789f69688a7283c2915eb65d460500e5848bda570c409685fdb9b827eff2b33375a6c1b64d844ecc80772d6d494d4ffb201c8f03675f0d976d4bc6c6c664025a6f8a3c491308a1a027b472fc1fe8e1a10212a2b6342d364c9b73f593d3946fc00ab94f95646640b6e066101e7b89cc85303356d4f4345ade9ac2b0b8bb5a93a04d28ca7bad98d4ebd8fbc5de27f173b38a56ce4b2ca5c2fcda1893d74f92850cd8167ea5cac24cfc4ba5ff76435ecd368a21e9a38c277e83ea74d2e93fd7a23f1c9dc70047e1c575bc232c01c8b975edc860925bb84d5f995eff57c617b372f290691a90d5cb819da84e3d7cd5dc56fcfc802b20d5fc189464ac699a20a22e1f45d103a6c9d5af812c8e9d24765b2b5191dbfc1e548ae26af0762ecb20dc25aff5d64e679708a34b88e9410d21335a68c2a8162d0c31834986e5b8b9dc3bc0bed514b3ed1cb7da1473bc48545eea8f5e602cca71adca91362874aea42cceb25f70c2ea3eafad9d6f8a02868a2a52c386eca8d742846bde55be7f6a7167d6e56e4cc29baf7a022a2c8171e1b0f903e8ba2925f764d40a4c16bb9146b55e56db613e6df3c4143777c90a2d05b271c47aa177f823d429e2a9d6054cac4de86561ae863cc9332158927d7a4ec4d669766c28ad1fb45d6973c6e6b6811493a31c0d6799c64c0d243cea88e4e2193f2fd489ef9ed8cca42f0ff3492613ff8e9bc5d9c76d6cd8f8a1b7629f5f734f8faaa3427640880f17beb5689fb559a2ae77338d7caf3e1521fb967a8356275c06405f61b7f4ceba50825129ee6b8e37860db43bd2902831fd48f39daa0f70e444c0886f871e7c04a3e99e476a31796b83b0c08283248c0c30e0010265393ae9b469c643e3ed0a17ed26677cac11239f4b9d86256d8cf3d4371995dec7e2ead3c42c823da61a4efe2ad0ebe3f5aa0c241d431c58c3d2109928a3f02ee52d764b49e9a7d9ccc59e79079c718832269444b3a697a83090a7348c97f5bead4c783eb2c8f9ef73204553ff55f91cb4114fa813defc618ab11f4e0d94b8811fca6fbd543a53dc1940c67f221ec8cd1ce4a8a00f9075d2f950a18ace8b1175dd960dfea290f835f5a30bda439b113e97e96aa2047f95e09347ca1c4d8f92accbc2764c66dfbf8c46283544329b664737f133763578247075b322613157ed931ced190e3ad4f29fb165dbf2ea996d3036d8c0c28f07e1c875d1672c60c33e91ab5eb55959195e8fbe658a5621864cca8f328054e0cbb2d1b83b4fe708b2be01ea8a9122e48f1e995c9128cc6a5b9f4d4e3fe9b7c5fc6da4a7647170be9be8bf58c33fdecbe58e6fa97ec25602725d8d16b7799b407eef44828863c7491d13537a183ce57afbdee2626600a9c4d658c18c5119de84c1b517785fe68698202e66141971d0b0de6de9053a3dee8eead1383c116d3b01f866a21cd6addfffaaa2137cb046fce057ba1ba5f374545c8db329353b3c6c6f8b56f6f0db059331c5c988cdf82c818602011fe85f6be48bd3553135ea349101d16272a05455d65e8b84358ac33ada6e9be377b111033cce667d0eb95bac1ea4211cd8d42f887eac0a1ac5c37f2af321f6eaf7701f4ddad31808ca0a6c2de577a076ca2db32e957b0e4f7f5ac16c19f429f27a7ce0593a6c99e9de328cffa4987f455a4c8bd2c8c59eca5b825c8f69997f271359b0f80a477286bf374701104d2ef4d898778d8401a7074adc5d5598cc23d4760f8b7d2532f3de9f15efcfccd62bea31e11155926b8c82dcfd22a4894d36283a79a3bbf2385e193d0fad766deba378f7c40260868272f41f0c6bdbb5e3bfdeb4b22afdb67ef00916bcf1d3bc91191b36fc952ac8e2fb3d035ee7511df78f04b1c98ab9bad6d47c046f724eae4df2dca2cf734121a32b08b994f7bf815e00dd45dd553c15a3be2b431fab78d1cc7971e3ad52833e99498021541545e8fdc6585bdca864b78c281bec8baf4d354b5e0dd8ea1d06d7adc93514d0212b48ad6088839e979026a55c9e99efb5220c8319856727a05a5030dfc5bf72d6b22766e44e3feb4388907cd1bdcbf962372bb5578e376ae0cfb17dc55c76c6a9534af94e7c8c0ac72e3699ec91b42bc1eef50de8524cd98a28671b4cf05f8edcc27c615bbccbb42d96e77ff5456466b66dc2dc3cafe45820ef9c1c2a1c88f55e1949870cb70e4affb46cc55044b46cb70a5e77925aa4dfae9b98cf57e58407c37307ab0f8c0c127611ec1cedfac55cce25313c70839196bc36ae4585f5aa0bbb6357a13ca1954360548fca2c42395387797f7d2bc4efbe33cb4a933695a0ec2a8a8ca3762474b93a2efd291fc21077ea7557d8102d2b2c20c299f3a38868cdbc1af370a53010eaa66852410880c595c35d6c7d5c2afcf2b925755147c4a82f7f7e86e740381630f078a75125f4cdb923d7e4ea50bcf5b0ccbf1a6a7ed257a9cd8c5a31098a4606016e931c2362e1051441b3a4e289fc023f1155afa05635d25c820677bfeddf4bdd23005a6ff37a2f4c29f5706f36b7e5c51b6b4a0711bff3084897217030c1836bd6e61463ac91d6969b05ad0c6bf1c8879600a2613a383c1e0d5c2ab32fa76081e97a0b0ac8c80d7b36ca50780940b6f627795b9af719a3e074044ef5a2dbc661bdd43d195207c50e1021c4682961f8ba80ca3058eb48d67ce41d6d103d3ba3275c3f3795453fb11320da4665ea80540f6a0f02fa8122fd85253fde08ec86cdd8a1ea5d8665702fe63fc5863d5629c1ed0ba5d1e2e05ca4af16cc345fab4ca4caf204a3d3539a404fcf5a276a4e7e65bbf10def3cf31a0e9ecef8899609741f75265718d5b4951a3250eb50a1c5dff8d9a83f4fd56fb349785abd14b6eb38279a1a3cb140a791aa2c325ec0cbe8abcf7a2139b9161e5935f2bf387c259404ccc8dc4a507a0431399683fa32aa91231242e6da39f0a6baeb1f6bd4be3279c7501cfd9c6eeec7823bb12db8bc9c3575069dfe8c8343a6801c2f463267455401503ca7ee4bbbb6251a3fbc20f10290d01aad24915c61bc896927babd4edcca6f2a28ef75daf4ddff13e07e39feee8ecdc37585bb12c51fc9637947ee8e3404c85d911aa797d1b0e3c3a0195e55549d2e6b49a8da3b95ddd1b895ffd4f332461c20ab7647ef246fcd577194aaddbe30721fd9a34f39ab7b2ca0a2db3a00e90f1f81345940d2b4621a6a097f1b7a8fe631586c7bc2fd16840dbe7c0d7e2735954c5fbbe08c8049e44ab0955677db22fe747c9ddc4e44cc529444455f80f1bd0d25c915a0641327cfd976f80e27ab1b11f8cd3ccb768b53f75f65c483562c8a17cbd405e0399778fdd245414e8d096179792eaaa6fe313e1935442e37d840d39dc591ea0189977263752a988d8214229f10c94d7b0ecc69e10e8a9da2d852c90a135880b1f67a8a4034ec78194c83f133d3c0bfc5938ab9d5f04b2219964e6ca346a68a0be45b555088ba381427529b4b1aab0ea960ec392cb73a1dc8ab33f0d1e04102645104accb0e037cf61b6a8ca25fe338cf79687dd5c27b0d3718557db2f243f65870f6bfc6cbb29f39597034d591832b6023946c0d19490914faab501e512fa1ec0da052286362115e8de58ac90af9833780ca34493e31f6d31349ab376246280cd8167ed06c6ef9a723ff3f5719be9dbbdfcd190d5e7903550874c4600748dcedd7ce24e2ddc08beb5a1abd25a8916a515cc19fa1a60ce9827010a3ceb0f598f8d1a2c0b0f3dd17aa76d84cbcfc0950e08c51096bbe58ae0e2890acb8bb1deb02b87a328608d92fa30917412174fedb5e9fa90426a44c3c339aa91e0e15b723ab3848d017827285599d52761f3e1ac37fb38b43f157077c6ea1d035af11abd0371efb3585045e9949656f6d624af4f0ab72dcb20e77c8d04b78fe1976ba55c67131dbf100f86ef9f630bea6b37becf3b2abffe8ec0985472e6ba813a109614d7137bbd6b16c50810de56b0afa39ee7d72286f61abe42e66a9359b1ccca6ec14074e99cb12659d83f3dc065cd640a8ca0cf33df74b66d3b662a666e8b89db6c6e470da3391053e7c425bd54f51b8dc93bbe172ce152252bf4e8c68036afb1ebdf24b3d3a5cd58c664a2acdfe461bd9220b6f18b55ffbaa05791c045e9927ffb2273a3a7bf5aa5424f6659ce3e17683ea7be1c97b173b5fcec0c90dc211b48d22251fe9ccf16eca1b921fe1722c8fc4ad1febffe40a54474fed19ebca8301cf1536995d47be81d9860311204df4f1c5390f0f3e6fdee8a9cbe1006fce11ec96c62fcaf07d79ea9a78b3ab648096f451835cd72ef7b6f2ffa8fffd261f849299090bfdb69f234175f144c2e82c1e801d6c89bcd888773ea8877bc7569268c77bbecee0a87092ee9cd0c8692280f53e84d0ce3086c1bad0188379428330c8d59d4e92d57ea9eec0e0c3d10a26f7dd44a0dac3fcd426b48001d6521a35c7ba252607b069a45d4f04ba6156cbee6af28683b3bc50f854e283fe5e568cc6d3968c91bb8dbda980fc97203212e50214d6066ed4864645eb851266dd6e0d5b4068cafe42ecb2fe8b1e7f0b0647c00e5e23d3de5bc44d63602463b5e646cf1456e2ebb0164f5f2cc50ca00ac4ce26b2f3d803e9c5f2f72983110ad66f57740c35d03b07482c94cfc32c74e9627581a1e5016893e0a112652b5384f4c90b993cff0cc3463fe805e6aad4419aeb998f868bd8721ad95adb9c8240188c8a58a2212cc13b47bcb4472214d425acecf78fd8e67aa167be5ef2ce0259a9aef54da5ae55492e1c5f57fcc33952c7c3f54f9cebd57be5f4319fb427d381a6564b11da9d5377d7001dd19f23b4758436af75f067fb6778fa8c4ebf0975c3f57dddb656487be135168b018e8a3d228b2d0ad19d0f7a6abf6f2afefd718f0adea4d6037fa42333fcadfe3852c4d448904a89441a3d6fa7710b76bdcdf2febf234920b144617f72de8072c9527c5b71ad0523232ce448cca7f91ee284f0aa2d09bde23dcfeb2d0b9b721ad0d2f0ca37c33f7c9484251d6c38d95c21843f1ed1fd5f20ee0c88f786267de656290cf843f914d8e2963dad6680f22b3506cfc1da510427065e4dd63f7d4ecb85b54b04c2a51901155b5168abb196f5767d2424defca1419b2358e47b6878bb0426c7348cbd46378e582fca36c10f872d6cdecd0eb7e89acb27cbf9da257126edd937185944056baea585dd1dcf2224a2f0110c6b7a5e0940972137746e3d7bde67c765049d7b26c9a31eda43f78624c8088b239ae25194928191771303fb164ce94b6ac244d8e4477ad2b60dc10c88c05c583a79863280a7ea2d096e3329097af3fb665e20bdb1e149e9c34ab1805413cb9599129ff2be9cc453968f0ef43299bb37b2163d55f5f1ee9424cbfb0b94b3d5e21070d654fb1178237f79d94d92b8c012766e86f754b19d5e1ee7938976d8ee6286351305137d04f5c9cadcecbc54c3f3e297a9deb0ae36664be87fa71041b396ce5eae82e8992c2a532e30f5c994444119e108dc094486dab2b932798077a2531c7b1c0e72244e3a54928623faf47d37333eb5b53bb25d69e47490f785b80999f330b38d0715d79e324ce5e351cebb57278dd5a28c5b9b7503206971b32933901790f912cce57952f9f8fb655dd60fe88899ea85f44ac8d14bdeff006ff69ea369acdf2e300595b08bac38b76e9e02f6c02d5ba4d7d28763ab1e63c7a2ca2b871a037c9f364f01659f299fd7fe1d115560c7d5c1b49cd28c8c4bafaa3df25d5c66aca93c00d4ca6c7972e1b3199334f10b0e97e25c7969122a9a06b2ef7214529bea91872e132ecc65abe40fe9eb31c5b65c58b9a5343765f522d9ef582e1cb7384953bb91eb3713b0b2ea86dc2d2ec22e66effea8e63925ec132494b855a53c78309b31554e614c807539694cc9574e5b6dcb3da687b7e8d9784ffe115cc9c6ac381ac98955302622dbc3677899aee4b7368afea44ae9520f39497417060ba9ae26efec23d600bce481f762a567b2438bdeb9690c575e0c78976475e5be7cbedf711895cf044644bb4259f14c6c9b886808c4718af9f74198d6bc9f5cb2b6a97723becd13bb0ad141974c0512212f9f7205df353a9a48b7163b6bff59c5ca5da073a08cb9ae90123a5ede60f028ed96674bc028c8dfa58651ed354da82bf770952fb8cf8246eb6f225a8c880a7b9ce2ca851aa9c33093d15649925ad08c9a8e2c7cdfcc7107bd6c58c138807a0ea06d85632eeb1efea1000f73c3e7102b29a9b633b0eb47e87c0173c10c62ac717e4802151b82bceeec3eb5e6840246fd5e8138b0ceb39f58da1f718b3bd4ba586c293e64d66f4dad484b1da8ea35f3f4a20d636fa497915452d66390d2efc803f85c3939ebc594cd9ce6824771a80521e01ad3797356a8bfb7c9464fdbb559b3f90ae26603eb03dfbd132b5381675b9ec3a511825d0c817027adb9c70b2e1c8350dbf7c27dd421c3b248459fae4ff8be7cd2a1abac249c735e0f0fa2363c9dc572a2ec6b9715d575465b3b5198e0055ed7c2f50721ac64aef929b80a512180b29060a8e2719088e7e4f9953f824151f0b7994bab1014fd38e6dfe06ed558afa09ae32d01040d184f5781d1aa473188b1dec8e104b0dc5e61b9cd0420c5ef98187dd4efcd0dfb40506a667bae050991f492f530bd4bd164e6d44d9ea711bf022aec4b3323fa4e04937b85accac59b7e03114619367047d773f152dd45896964999eae6569457045bec9c184f58326f853832c01c0e9e0a567b1ce8d264e532dc5fb82f980cc4e65d94028c6cab3af93a7dc25bba23c0c452b44222cb18d76bbb0e82e120b14ba0ce4be23a7f5bef25e9becdd7c0a0929abb0c68a852369c59ac43b1208bec9b2ee99e16ed26cabd26fb7e403e18711d3d9b0cc50ac25cbbb31e34f51316f1abc50bbe30f772520422369b34b4ccb11dc333a8d926c80b5bd697fd5d04d921df543b04068a12c203bcc9d9cce975f209047803d0ca90458aff71e82df1db5cbb98dc7903faefeff916aa1174f2620ae10949806c5edc9dd2d7908a2aa020df80b92072679c1055764d6d26e68652a5aec4d1da38458c4c42a42a98b87f0a0e8a88c9570a4a908d10ddae3dedd135539dca1e8fbafea07c1e5bdee43cc9cd34d38d7c23858d0b8f277ddf8f66ba7362705e33e6a60d604bea4e655c7af913d8d11215b238ac6b6cb962f60092d5c5ea68ee7e46450f4d0ed978ab102c779a2b891f6044cba08e17ab8badfd51c2d6d24b3d7a60263a6e005ba815a866497de1bd0b6873e95c6fd34f628be4a80e55f655b0f51c5ac60e99ffec58b0599cbb86976cf5e87f92b4f648564734fa8641d926c0e3d2ee0a06aa315b73c3fc38a058e3ad41b195dd6223961d88f6dc98231648da0f97106255f817caff65277a79a57affe743cc6aaea26064f9040f6b1baf0b1a706d31533e0e9c2ccb0ece48f74e8a605ff9a3132e553df6ef57a62a981cb00f25c7fdb306de0e4b9a58fcca9de5b7ecc3e394a61bf54f30c30da9e3bd549a6b03890cc7839a4bfd9c9d3ba919be4de797edded8a59718c36bc64563ade7e53cc176564a0409a10f65beb21427b089aee614d8bd0a5c1338034cef578041b190b40204fdeee8885bfa5b4154376e385f527fa24626e8c4b21a86271177462b8d8ad57a6ccd58f36b741434c73d3b913c6f7514429216053eaeae33a8d5c0c8397addffb93606775890dac48953adedd2cc73302e266e9b7df339c910ac93953cb563c108dd34e5807e48eab85d8eb73bd3b424620ca5e1cc9669fc1bda729091936992d4dde5cf04950a1626db37d5a4669386b814b8b7b9a8d82fec6a98ef41b73868b52cae5ed9d29c244f04ad07166069892cf83496c82d6f8fa6cf54174f9f7c0da58c5ebb26803f6301815083398e43dd04ad2706fbbb9eb452030bbb7bdfcfcfda66761c6e8f0e4343f3a5e9b4a6de75b035154a70b5efa425fae2695843ad85fab0d915dfad15890078b70da1a02542d0391bdf36cc0344baa4e8a88ef06b3c0ab88b0ba6ccfe316dc72242ec66d5ee5e79d03feb0f6e71bbefa8237bb644c8bab53f023ccc7abd43dbbdbeb022b96e6d01cdadb3478a84c7b3d0a271809914fc38407b00fd80a63e48632dce644b2fc3ee3288000b743850cd7fc7ba0f6eca15cbfe8a9f26f86844438b75a2acc93377d732db4c13f766e4ac9bbdd4cb782d0147e171abd1f3b4aa6ebb81b5a94f0ef322150b2f9f43f593dedfed4a221c22e819bb02fcae01dde1335b3dec020c3b93261287019ad03a23aaa7ccf3ca8773362abca8b6c6409334bf108c60d2c1cfdcc187a8bc1b09a04610e947ca964d779434b382342a395e455363f5ca024d4e9940fca575674921b5081d878707dcf89c03d7205d3f65d24ec2edf352ff2a9833611f98fef14a1b507c0e18cec068243a1e3c177bf378a9b4393fcc6817097fb531e7a5cf201e8ede55bf82f8bd17b50a73f2675f916c75c5708e68cf82b923a443e64535e3164db430c17fbad0fc65d336bdf993dd361c5460e32e9ee0950980d51545a7da154ef131d8b8733edf2ff3aeb09363e81ce2721e3d1c7b5ca77457917704c9c6f46e39dbb24b33aec1d786b4a0a7b0880e793f932c4e16b66313fe50a8e6b99ddaf7d43560d6899025c778dc1c3461d71c37362aaece30a5795f80cd12226f4499f2c1155465312866b848b5a91a9e0795aff24a8822c994b29cf52a553e61d631c308b29db240c11e14f7c9d27665abba5d1e6e377d5d9f827402d550aa3a36b220a8e1f7787d77b23998fe04b7f191715b44aefa3e0182f82d92afaa4414ef322cc6b92c9083d5ff02be675fbd81c7d981f7af7e566937f00ab158889f794a2f5323642dd8f43c0c944cca550326603434a73aea08871dd2545708a36302bc27f594246c012b429980e9e8018b681fe1ea49390a5456dbbce1cb127b8b271f082d2ff3ee18e7a8c2712bebc6cca38a2283713cb18065a9aa21363f94b4af260ed4532a9aaf6c6924e932cd911ae07fd46dbdaf260c6588e86be3259da115d42339de919a1fcf929b923990c008c5dc996a205ebf0d4598d76d9d452d27c5cdb806afb0f2ccaab0058e6168f4ea4c164d7a99e74bd316b383fdfe9135e1e846b1ab42909353b2e91ecabe51384f6573bc3443aa7e68f5e3cb6c485ef0948017ed0c4709dc0b073e46c0515d02d8cfde066eca982016ed174a4e758d8186c89a1b6719d3e87a4ef317f62da8d723d5d83aff55ab0e344768230ed867e2c73294f5e6f037b065b6c1d62a872036c687a18e5c3e1aa10055897fc8fdfe29b07cee83d1215ac3b8a7baa0c43fed0a3a4637fb5291041e9c6e3a509a44aeb01c14c35d6150085cf60b1aa44991087861d4c46c9109217760aab158e9118d981c9b10036325d68cd38cf41c5f13d93da4a922451ae18b55bc2fbc165c62aad5039aa90bdc59602039fa33aa70d5c04fb323e76c5bb1ae2b2e73472cb155a30c23571ba8675b5906fa4140c47d062ab9f1419c4ae10a76846e8f2c76b019f8d5795d19a079274794902db1eabe6b3badbdc9c129e3de9266f28acd67a04ee7d4cc8a82bc0775e08321daa5c302f2515fcbcbf7a442e06d7569263f506556bfef4db544e986d4a878b08558168278f8f5a15a213cbf3ea597143778a98449fc717e9b596baca8d0fa11bcc9e9371e887174d1613e98a2d7373c5a2cc27a12183fad7a1ea4077d8ae53f42bc004c0e36aff21d7a7d1027a2b3d4b75a2febb347080f6dc990827a866f7ad163f3fcfef0a2f838b2d37b4932b76f68fed97d522bbac631322461f5756146e718c8170267f6448c65fe76c72b606b5dfe1c70dafb32955746bf26bad2d3667da1861c9f7802e6d3c08646aafc9d1aceaace4567cb1af999f40799d19be97ea666c58e8d13d8e7fe253068afa28dd3bc4ac0a814cde40f222d1487105cab2f1b21ecaadfcfa556b7f4beb3edc52f977ff314cae129d4964e1d540dd40b3328a0c1c78a9c8c28f15eafabe3795e462ec343ffeaa3414c227071c65403a8d57f668ddceb7c9786b9657f4df78ab2aa0dbf2d245dd8e3d6e709a729168868c353c42f8d6ab2b47d3dcd7a4509c4dd2c556417ece89c99b58961f8091daf3d57c6e1c69cb4b8a2fc161e29a9455a5f39f8257b1dee8b86b7792b43537303363a3714c9ab73a59e040fc5573953f3f24c086d6a076d8d59e4b200a7aeb66f67a4b9e56a5874a76d7688f1f79c9444775eb173ecadc251f7f04b4f9af490a43eae3f3ea3c71aba438f0c3339890643858dfeb49826f2c7fc5525ddf327297980bf92f1ef7eca68cbc938e2561c5f6b6e275fc9c5a7d499762bf5fd2c96a20458075aa5d2c00677088a01df27cd9556ff416c6a52e0567e46faae091a77bf594cbfb45aa89cd06c50d15b539c6237db07df2e6e2cc8a0e8455ca0cd05b606a4f1032e34233b0232373c981e29992acd389a2e716713302405afa81d8f1e433372a5c433184b7246f421942b514ed9738215d3bb78e93777d844318a1a9865f866a58cc36b07da3f63f646531558560ec6f6779c9bdd640907204c5faea2b30727060510cc972f7a6d141959e9e7c51213f27d0e562ac9488c00cad2095de49284cb5122b15d68464a687e0a0570c6251a51a473ec14a328d751a2a102041eecb69d4b188e56aaddde32f1726d19d262841d5d53a2ca1608e89e9e83e314aecee4e13facc2ed643d760973c172b169aa38d8116f29df0773ce85effd5e34fcf75ee41be25acaffee22956e7d70e49d0a93d2b1b20b34e01914943a41098b557e4a330e6b17e7f8c0c327cfc35bc704f975ee650597559b2d644e0d508e5a40c65858bbf9642741f9404f3d7510de37fde2e1a6328bd22c0f40cb74c1888a05a9b368f551f1afabb4692099724b8c7765989755a77c84750820089f898b18ca882ca77348c011f9a26b231d8ddecc3fa00cd02f699d620e80d6ab47a72d7c7c5e7dba7e8e82968cbeb051be1f0fb567ca4ceeff1cc9763c2b0f1ed703f2b886a70e6af694b084431eece0bb565fe602fd8ff8572ac9ca988a399868a56cfa88355eaac67ce4e4974c186e47abbbee16a1a960cd7741ec0b169ed8985a7988849075054a34c43c2973a9ab539edc9f690568a92bac73df41eb116e49f0ed60d66a65a3532ffbde46cc80c2a361a54cbf54640dfd4fb8cab6b871a88c006b306217468c80bdb680fa84ac1ec79a5526ac6f15270655f00683fabb19b2e61ea89c6206661d58ec49d8cfed17f369150486c44473259833d889d7cf73ad4d10f10d5af83e23bc47e132c687a93ba30647e9cdbd5c0e086121bcd6fb014e79174e9f1d8a468d827abefd85171c5f91a6a6543d624fa9422cc2e998bb50146726fa068bd49cdfb4b9fa5a497b047083162d62337edc78330e3a36b3556a0d7dcbfd5b84cd1df4ae934e8889a2ebe549cb2d1a2b25e8407d0aa38024fbee8f72ba9f67efa22d3ac4452e689bd54ae220422e79dd6ea1ab3cba13ad099ccbe82f80d2675d3b9f0d87da4c27f91d5d49a115cd233872428071fb0dbe93ce26efef82eaffd0ea6e24a17369780f7271982b64ca4228e0cec5026cfb1024921bb764467d429b5dd776f220e3db627fb77595f8624902c2693462a271e225ca2ba94cd9f032dd61343602bdec6d9d3e11e39e922b219918733d0e1ff826bc3fd2dedce859b7890f9addc142e172ef026e96f5f56cd85dd0ed39f1e273c4d1f75ce6b68bc37796b82e0097671328d397422734ab1c7a9ae355b12c4846ee0dd4c0e38d49db083d498db5e59f0fa752d84e1a18a5cbbadcbab97b67485c9d4c13aeb80c6f1e8830866aa5ffbfb4ec201189945201d6fb10b1c72aa2110aa0836f81d95711bb0d1ce07c0fc56d2d08088ffe01c2d995128d29235f890e39ce9083d3700e58fb5fa946a9987ade0deac264b0d36f69124177706c65c5a8998be95cdb100cdc2dfbe689b310561f99fb5c73648b3d3af54156533089230ef946a815a5867b7a8d353ca77d6c166b0451cbd730b97a4b061d19859dc20294db3cb91a96a572bb1541774d5cf7949d06d7a98b00ce792b539e049bd90e0dbc7750115d4fe653bb1ec0fd776a0565baa23c4328af697e848eb20a65e62aad5a3976dbfd5947a42f4713f24d3976deabe302ce77047ce9e47c9ac17b3757bd7bb220d35e1d44ef75068d1e894202141dc569cd997f080bce1aeb0f840d3c7a549bbe766362c34c5df732e4e5d5c888864d1b4b0e116521bf50ace593235ca4535bcf7cd10cc3befdb6964498b5d0bb7bdc6ee016bfabc632ccd48d9accdd0bffdabdc56932e5ca8f6e193dfa1910ed74544c93d710163cb08a0ed5d5c3f31d7a6dfc72b0077d15a0b8bd77e173f5e5f22fe91f0b59a02b7fd3b395072d503ef3f0e693c0a9256d3c1568d25bdd5096ae7d4272dd13def3295dc228498d597a82c2d7c4188943b49bbd7c80d412cd914a6a78ccfb7914f05c22476d0620a41a45f3bf449510fef5a81c614d289d0e673d219cdda4425584f513eeb0139cb0849a9b554e397ce9fb600eab3cdc88fec46351486a3aca9996c6a4abb33379ecf6922472953ecae47c53704b99bbb49699187fffe52205d0eed9709fdacf654ad74c6a435e5795adb1f305f6357b534232a6e74598d67e7103c4e3680ec6b12695f97d5fb7d534cd54a9c157f4581048475ec3cfeb84117deaa5ef313298b388b2d77e3acb2f766c80eebc5941edbe7a70b92b0f31504a7b40b304ceff2b2ab86c63a3b6be952225c0f5cbc13b074e82a06085e12bdd88b5fb5d7fc508be7b5721ccd2ff508702913e3331eee33e5b019d11dad66907731e83e3d5b321b42944c16c06b584c1aa2805716e23ae96f80530192cd3b5b07dcf8e933114c09ea7df928d2201cc7ee5794dbc56a5a1fbe81c86843e40de5d9aa603cf68ac8e40eabe65ccdb191148944387a441daa6936fe12e8dfdd80799ce31f4c20cb18f373a8b85e1e0087653c1e1439a675d8fbe1e6ae6d2fc2a6357fe5e04559061a9d199e141d603661b0583a56850aaf3f5ec9b3898062c551f1e6da13559c3ee887a9f4a3ab6380488413df17c061ea4939922678b9dc1a11c0449af1fa257505d8fba061fa490b035de37a4688feed64d226c3175add1e078d2ecb4f9c90dd1a7a7f5385efc08c71dc5d1b0eb1847b66d2bfa6ec381e5b98a1cda8cc99944d7e6b15825d126019c0c3f0e50c4f1d75b35c2d227083507a7777b06edcd2e8278f6e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
