<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b84d52cfc4b6d0a9af5fc0d20f56853711964a5a9d6abbcbea1e668a1d789232bd7f40fd3f1aafcd8d4e846ad603d00b0fe2c43b2c1dc567fa0fb4c226d2fd253bd09207225b6797902adf51e5fe476a358815582009f50687d9616745e129d2fac6833a7ab21750e04ed9e2e23b170d2e9c30bdb7445a9a51c1765b4ebef3514a9d2916cf1c4a59abf82c2e8163cfe8b92928ff835c1d20c379a4f82a6cbcbbfca6a251b9ec69a11e296b29d7fa0ed69fad9b4c751e0337fd85a99caa4b4fd5c2aedb39341ca88295cd1c2a3f9b4a317bf1b9d2501411906fdd70cedc6f3362a574d25b563aad2fc2f4142304d62560871c5cdfaae24e98574e7329166ee3d311ff19836b32d73b67d7dee9a488e2dd93bd751302364d4db951c45d901a5d5a52591be578a302d5bc4ea85a77e0044d33b0f2504b8cec1459812e6771bbd417289c51cb7348a8b2167833a53c7d9896bb4470e0a2ff27398eaac3be2d3ed7ab389b4ab4d705692d93dd96c94154593a3a6e070a9d252d41fd2ef02d827a0b98791c4a0a34b2ba802570b39015e3fc2eb3460dd5b03f48751f1ccbb8f639c76c1820be4e75587a7e008b59715099ca0ad506a87c0eaa8fff857999ee72b271d911da208120a9c52114dec65f8f8e5dfb767d14e80d42553bec92a921684242b6694855fadc6488cd3f502c418b1dfa924f19be74606163c35a216f76d7bbb8a6495c9d6ae794e39503c3b3e2c2b184694fefa5877b4cc27d83069abe4026f2e3569925a73d4eb15f333a3ffccd327adbe402a1e1e8f24ef6e61cd31af3b7a895379d14dfa6a4fed7fa48e8a2ce180b9ec1669944415e11884dee4566fb2994b42ba7cce074d1de19da025ba0a53c247266b871a1462bcc3254e4a869a3623f625f0796c82db90950d5bda4312216c94f43c27d3b5e44b43a3159ecd553d6707321e4835ad61acf6241ceef12fb1a8f80cc44b1d581e5b4329068f69c03164687e9469afcb3e7f44bb391fb0d34548108296f9a5da3824ee2cde97d74a3c0a5faf4f5aa1d0d667e23d0ae96222b82952367b09a6de1c37c5829be4f513bcfccd4524ad62a47156989fa2d331f9730e97a6c1f0e7e773b42f70ba3b288ac8642fba5cc06cb6d6c8ee1b3fd675f36f42b14992b21f43e9ece0b4b6a559d500a612ce638378df81d4bc8380cec1b167e8b1c02c6ebbfbf00fee29d9393ac8f5f844c178d96ae72d84e45da74b62a961e88ab3ac5abe9701c74a7832d1fe5078fa46ba92def5ef21775fcc07829f211cb6b7dca6b5cecae5e0d46deed1614ee7587cda6ab024d6272c4a1e898f1944ed001f7a64f722987471b57894ee29297e2af98e3d44c505c99d960e1cd52ba2cf502e08ac146118b1de1181cd1917f5523bd9843ee310936ba6680be0f241f1a1eacccf6b99267eaa97766b8b222906d72c3f856c6c8abda173dd18de4d43b32465c02b860d0bc5c1b3df809ffc78c0e8b84ba0d0bdb7da000f4c9fce4bcaf95bbe0596217d58b384a86d05e187e3c587ca65366f8f835158281e34172973653c3897a2bcf80416064e3750b5926108799d1ac9f55e6bf2240a0ca45e421898a69c9a3ef0cdf3ee585d43601a8cb50a0c121352c194cc4db9921276d65e87da74921c1b9681aed4452a0803b8c30f83a3e9f4fbd1525003a5daa0038c3d1fdbf67b515e2afc3c6fcd8a624a1af0f30a6e6501606ea711bf5b352de9fbe2e1e528987a364e48f5b1c29e340e8517a0c5a67eaac3d953048dc879b7c3ce1bbbc2403684018b47a7f4369155e53d14d7f491f60ee072dbb9cea43641dcd29e6a3af68413255a815a4402b0ee52f930d399cc546769da84ddf9fb3ae07d05cf9ee84573eec54a258a81f6a2bdde7ffa1d2170f659b5cf245348c4c35bae1e1543564ee8ee114e21f779f0a73bedc166395e6818cc64086de160b3be209eeaf6d1c133106ccddd1db728deeddbd2c8a5d4c5706d01e30ca32e91b3f9d906fae6f32ae60e3b6a99c0f343133677139b9cbec7f5ee6574efdc42aa98cd6c1fe374d74324ac32a833fcbd1676d669ae909061bab705766e299fc9b2179fbcff2b69c7c85ef1eaa4b8069a43d0af5ab187aef148510e1e8ea0a05317615297e15e0f1253dd4b10994fddb89216bc16611de742d617260ee23aca5208d2205056ed344f5c12c56c4f66194357422e021fb7222a65f5f7a0c294f995ee9372d0a721259ae9ed39cb45c30f079550cfe81c2925eb390893d55047b3003312dcc5748e6ed43783c5d750b2d807b7543357dbd0fec9237c802b80277a3cb65cf1afc564aef02731735990cb230b6cb2f61643bed048d0baf38dd16aef7e587c23925353e14b1cc884701cc014d7e663dde2876f28e9dabaf6d038e2901e30a0b2c4f1177994c089cbff2cd26a74190525bb8117b578cceacd201269809aaa3e4763aeddf5afa1c2d9fb0d6c418a2e64ee698f1d52a2a068f74a301efa6e7fa4d9e4a87a83e7a8c6e0736788a22e18f22d1f490f2a797c904baf00fa459195257a6f2c90698b5036a698bf9506f4c668d324b0c5b3e250a695822e1b60cb8bc0964a68cbdda40d150c7b1ddb58b01fa1dc1f492cfa14d4e226b1a73716aedd8d891488648935c786dc37087479e1831ebc31098daf2fb40440e0bdbb0ed3acab66ebe7ae87f1760e03c02f66aa5092863aa1f14b4495d3657a122d2e2068c3fffff7984251d90e66b717b7f72a2278e6a6fee0b2794e19121bd4b55bd265a4d8d164d72da2c6f42d2f5494beb2623b505c4b12616a86c45f324e9b52e954447ee2d7755237e16667041b3d227c05d7f60047f7a1aaad0dcc4b4525955e603ea6da7a1c4a9453c2b0bf34383209a05e407d978561d4af027bacab2b83713d34bbbbd7e29b349c54b444a69ed4b40b3653e0c5eda3bb0a077dd94da43ad812481f9b59d1a8bdd17e64f3cbb81644f44d5d07e5b57b0c7772e0f8a0127929ef2829d68a6eabe19b6a536bb89b72c0508ba72064b00f9acd455b1b638d0836283d9d20ff7ac73983f865201b3e656af95f03e340c14a9584bae338975009df18d2b651bb7daba7f7265b7095907c2ab3ffebe5ae870ca49cd23d95f31b81f620cf27db170ef996cd2140121f49fdc2260f472839c09b8d172df81a5d0f7bb29e0c7f03ac998eceef0e6c4003b1870965365c331512ec27b4af60be6776a0d258332ffa602bbc1fbf7ca46bdcc70c2aff902a4bd7cb8caa271c5b6110458b416814f9e1ea7afb3c9e50f47b98f5ac672c7e84849d6b19326bf7923fe3c1941370766b717bf745e104ac28c6c8fff035ceb47ccba0855fc5a8a3ca19a155b0512007723f36b403e70cdacfa365898e1c04192f595dd5a16b4fa471fba03b2e272856f1b21bcf395be38327f15ec335d5064db82398939679d64174e2e0c8379e773de2a611333c2818edc18321698e926d7be90736ac7ecd73090f8611b1cb3b4b6d03f67a3558588a9fc2aaeb06c279c699bd69bb906c12fa23994de3595a29dcdcdc6cc6d51a0302c8477b63477b36508c460c221c1ee33cf20ae2b109395a133587ddc15d1a827ced08f71b070358649284421bc9d3de9f11cb21006f6f37e0059081909a635f0e777b1386432374e4610bfeff699ebfb576547fdba73f0d992e60f4024ce0a406fe4bb0f4eb2864fbe8d5951a0d29aacd626337ada0a84e08102e0ff87e4fb04dfbbcd8a8044c95106484345703a1d69d815af0dbb8b06bb6b4cb2ebd7316e0478472d6c28179ffb33360a76b3f82b17739bcb471c7246631e0ef090affa7f399906c00ea0be95c786a74366b44361b8830699cc3a9e38f262b84ad9752623547984f4938492d38bee07648b12c577de516b5ae737c7f016b231b5d5dad9dcbe5014af6223919cca0dda92191bef43298063778d3adf673f7f14e8f59214d1523f8ac767818e413f3dba8a6b7f77141242083cbeddcb8927d4c14126074308dc12dd9dbe390ed0a4059adb447d6b79ea58397352523de95b9baca19149243b67a9e649c1a4504496bdafa7c53fe5de7bed0d08316b07677cfd79599726c25ebfe8ab6c1552a4e67d7caa744491d31ec805527b7627e4f879013427ace5ab06d4b03f1e64a0249db3733242167501c853c452776dabc72e87e24a18c3e75a8ae4752df1210f22f30fbca750c44e58852b6ca2c8321e0727c9e8adadd710c028415760edd3a8ed20494ca37fcbc43ed9ca1ba7c5f8c9e516fcfa177bfeaa940cda8c612c1970483997e1da54eb07377ea31c3ace8d7e38b29e0b36621c1372cb60d177b01a213328183128e4758f43226ec225fd176df0ea9361ad4c0516d83e223e40ba5194c575c35ad28b82c81052222f26eea30974de1dddca6f208bb9e21a8f3193c67e8f5fa20d3d1acc66a46ed8b1c0a1a8ae38ff18a982f6bc4b255ad3c16592bd0e326e4dfc10a482b836304bf094ce16c57997a291406b89aff6afe08a7ac3a176d3fcc8facad3ad1237f9ff42c25ce82a15026460de1f2d22b319d4baeb9f959afeecaa74f51cb9210499500a0d534b4711f9898722c2d3ecc484e5528f55d079dee8e1599dbc8fe7615621a20e6f2d9a4685be2a2462d7401e3c0b923386f9e36737eb72bbae66b1dca6ab056a182eb5fe271affb89c6f26018face02c7e14c3d03792b94d6215cf7adfdd1277b36775682382003ade9e18c77417f716e48b5bdf8d3484a43b456b8fb74038bf94ee157bec6d8a889778fc4be82750e0c6ca70e4c478fd7746beda828ae870af82641c6f60edf5208f95066927983e8906e52fb341da54b01ef7facee2448a52a99ba0bbf7fd369d4224d88904aaa47af7826e89648f77ef1e2912b4bfd9d80b9417ee2afe53e4a73447e057327a60cc9e897f2434bfc9ccb3a4e26b7bc2d00f6c17743de46b4309faf54852f08b073297776905bfd46b6198d3abd3473e0f142e8d4e60ecba203eb38a0ffac1d50c96222624d5ef05a22564020831aa6675615d6740463cee85f067a9b6d2f944c8b968fa3c6df12bb5b3ba5dfd08b07f1450903571c86ca5b123cc779013aef36654ccfa0299a217644d34e3f99862617ff32d27d4cb88adf5e8670e589481e8e2643a9853edd6f56a3ab0888f4fa50001aed38d10cbc7d012862347fc4cc58d9bb876b02ea9cbd40be986cdec28670cea643ff711454d13f2fa3082c39ef1b4d9e9073f5369d509772b21a5dc7664a5f7015229146d5b11753ee84a46abf8725cd6e0a86f63ee4940fd8731a5c4b28f84bb8638849a2533dc091c6e5fba97ebdd41877b3ff76010550a02049779f211fc082f1a86f4f3f5031f252b6a16fcbbdd05316b3a95c82fafca3fe379c456ad8a37b8218af8183dcbbf3cd6e13d3de07076a264c9d105fd9eb39fc4fff59deac022a4c53d55579113452c94d3532069e9516b9d9a02c0af932dd29caf26fad43e4bc6bbe746dd6d092f903abf14835574e7bee0b44394dfeb907a252f1e0f010bf27db13a49a96a2b6a3de3e044f22c4883a787d9e31f11c384546285d83d540dd4e5eb6cd4fb2403e5ef568007bce6c30cdca6d73019c72acbfdcf732d94e155c1a7e08cbe99d1d1b09ab7dc115c4d4af1febf599015c0ffbe9d9471292f9d55456ffeca65d5f109e0bf83c37aee684c8fa6688a80b38bbd8ab9ccb6dabff64dfb10b45bf27295c0e3ed26946b3fc314e9f7289442e1ae600feaded5ce30931d929c30fbbd5dfd1b4092cf62b11d3856b762daa5987431e7f0c25bb2f6e9bf31a01e6596e8d3197b46df65bf51d796920ecb3b1d0c8c0482f24bd8073b0a1044cf6004ac49fb4cdf0acae384addc8eec04bd371788456512b24af5cc2ba7a2aed1b248109b2db0d656950514c2e336859333e0036aa438f349260786f44f1cb3b5d222f7026b2f2e15c80c8b6cc3929872771df883f4217227c58310d40eaa82d085cd2e4ea86474f159d11b1e116eec1950cf5cf62952955ff313a1d8f11349844561e10514d70a01a8c3ff5542d373e0e3f9631f1cd153b42f3bd5381859af5459e019a1ebd90614b697ab6fecd02b4d0caacd5a76eef77d462941ce390bc3b4e69f3a3aca913f120d0a5f0518d03683cc100b386ed931492ac0e11a67e83fbcd6315f23b868b9466373dd1f52c09f2afd65f441a9ffd5ba1acfeb14b24ce48335da474debffd8de2a5b19934f91f952439b03a1449b13ace31182d875ec0325a2ecc83f94b9239e514cd1244dda8d53d709e4b922425caf767619e925dedb00b23426e2718206ffa478383ecac22a65eedf225fb2f2ba1b41d73c63407ac854f5f98a5fcea4ea3fb16bc73e3640278ae5ddedd18fe80c1e312510adc649e5d6e6006e7638c57f4d5a1312fbfe20e32dfe740236eed3f0cba2cdac2ee7f265cb3ca48d44518bc0e80b6d56570d6561f4ebbe0e784d410a42e0a532337ce8499c9148ffd3d9f889fd1bfa112ec699030f370c6598865eea5476944749ce72fdabb09a74ffa9984440a85aa4b34e985ffe25ff52cc0f7ac1ba53c4dfaf832ed115a3b27ff1e6678baa5c02ff5d0974f72e220bf5c9f8efc2e47ff44942950de850c0a7d936de8e5bc841fa31f3788b941cde9c635bcd0fd07cad40375cd4266895554e29f95374af618a84bab6ae351eb1c41227407f169ec18da2dbb8b6793ea685bce861f68bf119d2db29d0a4edac6561573eb5c9349dbfafb2f002b9b1e9794ddfccc47af37dea4bf4bea6affc1fe78410e9236f72e9b2748e6b15fc2483770167386d64003724ef7500ddb4161321e61b3ba1822024545d8ccd649c73bf5e39de527570f026ef4252e69bdd25051b011f44c260bbc402d922ea233df9424787d91c364000e2d47102cdf5965f5304aee64a0c75f35cdb9e66f846b415523ca8ae2fccf9db34efb2920679c081772abb731a3892ad5926ae647c1cf5ebcc5ee51b5a3efbb39869557a1495fdeb9a2a32de0a50d6186c0fb48b2c6e9342b12dae045d751c25d8d8a98e379bc0beda2b611858d398624d5bd3450391ffb082c4af6605879ff6b13da520bd64e853fe77e79a2d7e410cb13c55282db52a26113e300790e3031d65394c567a48fb353c4425d2839030d221a4947d433f40980e8109b47ce17da94cc6e688452ff9b4fef7d90f67f05a8c094ee4a61205080f7ca3eaa71ca982ae311d0ac56e2a1a9b682597030cbc2d8fd018c521ba58cc2dec1d1accc697deb6aa8de710221f97866832bb07b57f7d63ada9e0636bd2376c52bdd6f22d1c924970bd7cf29ca864869e88cfff7cc37279dbf775bfe069bf1d939f312e4b342e8e78f962ad1fcaafb0fb40c0e8113eeb87348f790364dca0399e94560e73d614dd09473182d8777ada162e1a5c9db1aebc7d0a90f1b21e58f27029167a979a25b0b444d22ab2ffbc996a4a172191b53c0874ef0708fed7e66cadba8debf52c14c4f993f38c76e57430ff8d02519ca7bea0ee82fe8d6c29c4f3954540a682ba3bedd99e05afada3f7284271fc688398dbb4f016ee0211ae37be3e23251942202948f39a422b4dee1ac8e04735d70b0d0931119e1ca937d542d271cc285b125837b41319c50398e038ce0ff04506d400e9045cc5aca3b41807cc3caa7ba3470a8b329291e63f74893ce566085671c0b530249468c9a7fa8d92bc15f867668ceb6ec5fb80509a750edea70303d6d0dcbc181e1cba999ca0c20ddb3e67be877cc7ae053fcd4df401f204d2312b9e7d4835324c73c6d7359b746a6b79c4f5a455a98191ef5a2cfa5814a054292f018f8cffa8a4f2a00c15994ec230766e15de6bc9b397e1bdbfc84513c7be605bb00cf7d43a601af38bb6b15ef88e100ffe3efaa217f2f95131e40902f58040c51560981316d0821d3a0d4cadc677184c938bd26c4ac03a85060146616ba32680baeccc1188f0828d8c39f2e9c66c947bd47a74dfe3240d2350d71129d325b480738f10494611e09b9404ef6818160cbbbb779a26f5c43743bd833fa6d76bb1339eae8f1f4c6877308278bf94b1034aff17f5795edbb2817cfb3a55ddbe53f19fa2dfc5308f5420e79677078d812f322d5bc93747c25c8832fe26dcd6b043764e50ca55abf68956f8952e6401ecb6c543ee84d0589c08ba7a4bbba1048a1349166407829673a61c4cd12630a05ba127ba1fa5c12b20332d51ee1a1513ccf6d8b27feea6975a95596fc4afe83f5483bcc04eaeaba60fd5577a0d6136a773c0356e2eef2328daaa3664696ffda06716324ddd1d6f6d3ec8c8eb4d49d13eff19175b37397a9a45fdbad5d7cffb47e2ff9f166db15b69e8b2aa3c66d4086d063832b9f4e0e7b5ee2c31d622e4eab640acf391f01fbf4931a0eae963942ed5e4591395efea42e081e225ae5941efe7834d5e89a16917bfed19bc043286c19d2ae0b3b97d7d770c19447b7e974e49fc3645adf45b1584ce5d86818be6e0a7d962fc5dc4249beddcf9afc8eb1289a8e9901b8c1a5f571f4f5f5b572a73ddc413db985165111373e09f00381432a8581f9ec4a0d2b0ee4cd6ff50360b15f1004be44ad49536cf8fc22646d19a7d725519e1f083b7195e82eed7c9a419db8d9d795716bb49e36efdc7136b18c4b986e9a0a6587e24b69ecfa96649e69af3665e0aee040f4e8ed6e69eb98d6c7d34928e41b00d248993785bd4d52543eccd3fbb2a4d50d42dc15bdb0805963ec1c229bb354f9e00823af97abfaed61cb4702245b4c1ba0da2e02601919d011993bc21bf0283c7e499c1a30a5bef61276abb81b3b566e24b49743e773bdffbd1c40e7e4a803367a46249a2793b91e9140c267e5b8d1d542a6ea005133cb9fc813dc367b67adf46839f8cf60794c14356aee41a521cd0d3a511dd80d19f80dacd0eecfdceb03d45a3416996c591badc837726bf25d5ee7726267b492e4f2643aaa176fbd97a6293865382a0df8012d219335e6134fa0c66d682fede5e011b86b297e29cd9c29940fefcedbbb57138e84c2411a89d22da9a53a3d70b01cc139b1273294dabef412442f4169636a25feb9f00966a79e6140bea5394dbff91845d4ad907e75dd6d6663aaf54da5be7fdcd7de404ce49374539789f31d50b76995851331568fe6630b7c0a0275d4613ef90db3465908f7e67a5a44e9ea268e3eca58bfbc2139996a5bce6f39b2dc30f457f62e080b34e44f0136837aa0c1453438f987f7649d79cc7cc2db0e6aeeb7fc763b78c9c0c29a66523b779a86894dfd315204373e6cd233ffed5f020ddfa37025d37fd9599b88554adce5427747c1e358ba904b7b42b42e0c81ee37456ee514ceaf755487bcf4adc1047bdb36c39500ff782b4befc3eba30a592717d95c0ef739915b2282806e222bb20302469b123ad4a1a47f157b4818764899d5935a2ae6358a8322b2032c99440e7b272e7f7db0c24fae84b0645ba455771a1ac615bd1b5f77dc9a61ad4223463727915dbb657bbd03ab6ab297ae1875d882e7313b30dfd24e5416044fb9e655fa4bf439e88bb0c1f3f0bd4bce2f4bb8f6a09b133f29f973568ba095b81027f521bcf7d731a4de39bd2a1c01a08d66357f658e460431d1a2a7095f939cc30382411b5f7a1deeb010585c96fa3ae7abecb4553eee65d4a345200efb115ba634817d3dfebd4efb27b24f220bfdea1f7325496ed048c2229e714f7c303c909ec76651960ff189b12f74483d73b8f954633729889d715ba22d5e2a9f7250e34e5a824735270a92112781eb2460583121efc109cccf4f0222e63fa56f67576da17047bc9ef3cd5ad91359b7fc952144473131082a0581894e4d94a2a3eeb43b68578ca8155161b03ed4ee109eef89f7b2f754851d5f06aa6e4ab4c2a2b695d11cb130f7c6e887e30bf665af39682015d80b95f07eea11333c65d44dbd86c7a789a575325cc05b141bf1087133b73da5c34fa7959c63ffba265a7b5b7e082cdf3e16a6b64adb133162998d4d8e29013052ab0f7bf4b26a59b52a225f509d11a8960401b55db8c0ee45d026779a1759b71bf04b9a605974ba9fbef011bf80f6e6a551da3d0afe90a81e17410a91c812115ad5c7fc6e743f85601535e737a72b9578cb4a8909ec42386b3fbb6276ff813a8fc79246c881c9273c91a10bff9b7322b3ab7b8d81a182d12fbae48b92e679e9989b21f1e4f9d352d0abfaf2d2ba99794abe1650979b8e98ec1a0230907be9b77f1de95a95a5095b252400b208b0e5567425808c90a9af1e520d2934ca83f9b8f2d57954548257d4985b49979bc1ff44438cf0f842d9b296b720f136576d759c0b591d0b136b784f9628852e080bef66b5524c6848f0b73689237f7081ad33c55ad265cb6d7761ad4845632ac2275f178b5d73f3a9dbdfa28d4da69ca728d2132e81e943c61294089ef1801bf4103770e464a03dd78584059d587ee14355b7690963d80ca51ad32c1abb18cfa91233ff438c789ddf2e07ea4db713f652335b2488dbaceded0b1a17a8d2887312646b85bed44ffe9586e6d810c7ed70cfee7604fdef25261e6c8909f8114c03e2ad71551cc3b9c3a50d4162abb6c5b477211ca6f85919334ef3d200c8e7a073a4d810d03d7846b810e0bfdaf1a563bb41ab449f35321988f07fae3c4b6100bc63a4af07f74d7550233aa91e237de8d9a9b08f743d1b7e5b19630130cd23e04b2d76070d0e1cdb86fa955f026cb24860a8188b6ffe6725cfaa4ea1d4527da92ef527c94103174f3f572168cd938a406fc746e39caf06b9a00414841ccc82f3617037c0b263e7ff5e3c1949577c6b6a593f3da5ce659ececedf8f6a6b22535456512b4962108e31eb39584a709039a7e7347682a5325a08b0e1a1dace7daf515e21b9f9a533e81e7ee2887ed47c56ff85227b0fa721b8f3764606d7e87b278281d3274b11e08a62ebb004e473dc1cbc98710619b7a1aeec818a7850ecdcf5e15c77287a1e6967a854fef3e56b358ade25be48dac38d67ff77f6fbe85267e995e575a185d5a6f43381f47ffb03bc78ec499d0ff0cfe40c3ac6d6eacb1fe8e1664ffaf50e6730116924995c6c9c775e1808d6a61a4b08f42a6017bf4f30eb7387e4593e120e1bce58b277d2161458139669e53ffa6bc0c976e97b5e775d0bc24b9baf399e57c9978fa5408e295d696db14300e1dc4efe151fbb89309f1d122dc1be7cbeba90eccaf95c54627cd97e3dc3d64e416c342b6769cf31f97c993fc0ca645b28f14398d9cc1809cfcb8b1729d0199266f94a7b3b2f930b3aab73e328056dce87698ccafd28388571c17db5540c8f13b67e92d6b704f5b1088cfa8fae2953e66af8992a300c6555df82809de2cdf8d6c4de3f57f7b7132056b86207281786e8989c1d86ffe9767abb0c27dcf30d62b93b64d1ef8509b4302e432e6389b6cd78b6afb8ed8169ede3e6158ff3053b2091539c896b7cd20d8166f96e9c2b070962532d35ad8073e212fbeef7089411778f80ac39308c4bb8bea04fc84df51d51a0fbf2c0f64ccd0e5430f3bb5be0ceabce2b1db4343ba11f7474f3bc4ecf71fd3137a35a0ef09d979f807b91bb179622d9ed9f413dc3c3fc3e6ceb044f8f36efd7ea90f77fe84ec9bdbff8f55c0adabdf912993a339c679541d2fafdaf585e5e90471502aebca876803cb081ee13d79c350d2c875cf5e1fff2665dec2d83585961aed13f038b0dbac61d5cbedaeef3ebdebf729366b37c21e787b6ae229490ca0655a2a383b90e1a5566b9cab0e82a12037f8e12afb80e3b5adc44bc61e7cf46878b6d1702491a122e477e8da9535a935ed8e928ccd500d9bc2ae4f45dcfb84819d11b3143a60b0779086656cc9ece231cfb7992d37d1f2c543bed70ed247cc48ed029a8fc10a20e1fd16ade3016347d6441c501ae702da87dd944f1965f8f4554ae61abeb3ddfcfb031fe7d0b86880e8fa2cde4989ff0aebdec3b087fbce8949d55018b860d4ed8a2a238e2eb62033a88e987b128aecc088ffefa20448540d20bcaf07c1fd4c237f99c36c4c3c0f8f949aae4fee8edfae93ebe6b89525f3d173ee897ca61cd71d2d192019a9f7499e63263c63a62924f1d378e62f1b9505d6824f42ac87c05d5d006f04c57430a7e44e423c6942fc3c5a4bd755a43fc045f233ad69bf80c0398511e9558546d9e4c53b952bac972327b0d1f07903b78c252adc3d5a6f1c31b53a54aa98be07df7ef201b290b651a657df92930d89389d4aeed490293db41e7bb294fc51a98973a46daf5056b93df4d40ebefdd71cb540ad213d0b16ff681760883f8f968779b9c5f8c342bd4ba2cef69c18be5da311702b3e5a29dd206f158ec34f714c62c0a81bc383b1f43329466d8169757422866eaf38cede21c11a47ae383bf71eeba25410f97eccfa882b751ce7b357355fa225cbce6e39975b4d2fa4fbf59a82b8995567d4eb7c86a493dca8a14b165bb4859f071590af8e489b4747f577bce990baebf1b88bd42b1b61b33247b0570525dc6020baf43e749b19c618c343ca69ce55ababab3695ea3d6d188842d539b21feb84df6c7cc21df363f06905005435c92527dfe712d47ffa2edceb7b34f453fdba3bf4196a78d858ba5ef078044429fc11aea95ac374b7b12ee162ea450cb9eb861d48d12b8264d10d279df87299c9f1b188bf598fd0e020e9fe71ef42b10089df41d9774e7908223dcf41374181d5bad59aa437429550f5b1881a0ec81498987103cc13cb018dd7fa1c08723c9c94609f06854580c94d2aeb0f2bf0fb74574fa039d092b99534023f5c5f26a3b4f72deda8685335877d37350a3f430b1c412515f32feb901bdb4bd98fbce06cbb0e77cad314d99336264ca1887a678e71afd969d52a5d9ed00f3288f09b3f6908d9de04f7e67ff300fc77fc949e5686f692ce9fb4ee3caae5fa2b54fd360b1c5e89185ba4145fd56a10211a11163cf2df9a448b32bf89ace95dfadcb0038307118fcb7115d73145b971845d43270f48be4b6f80c4e3b872dc6ba292d41000ff0296e5ae7d6648b997519d916164727cb444a4f4e307c268306d5aa5d8b17de8f70806471540a8212e8785074b19beed065e333d6370f7d5fb4fb1876233420570bb2622b5b39579032540c34e07f3bb762760a70681d094c3a16e96ce92905ea5a863c313b2be2c76950288d41f0e50f5d9dbd36a9877ee9b09a3f4fce5f3d6e6e237906c06542fa4fe35eb75270163b07069073cb69b0469e40b60b905fea8dd939f16084e6e2aed0e27d9b3d6b52aab207bc8baf775cd6c4c8791dc4ba4aefa3b2db08ec45cc846afbd7d6d194c3c4eba8b6e472ee36b5296b9b97601fcaad583245432cc427d09437910a1473e01ca8645d3790b4b5129e3bc6c8792a6d3fbe14c16144c41d54111cedea9a698cf9e1388ba4bcbca57f1ddcf491142ab8e78d51cdf61af7d5fb9a62224ee4c29595dac52e48940cc9583396a358162a6e91712f7bf3d3ecc0767e8db8706a9ac10ff8fed1b4fe41668ff78df6b53dab49fa73cc43e26b5a8bfe5bcc623e5dcd592f64e2354f6ab41f78da76e5fac1f25870cb991cf230a83ad29361ebed125ce325d545e8901a8b76d02652ecdce02f820208071817ede19d0562875354319cdf5915049389f603addfac46c2bf33007c329d19b136df3e5350dc8e99651014dfe531c8f99448f42902d67da6ba8c07a0b4c74d3bbcda1964acb332fdc3c08006aa4eb7251aa5ab4d3ade98c6513a63bd30d4e587b1392506e076ac73c0581f7e2289f1bfefd4ea74bcf96f30fae9c6e03cb588da95e2684a1f279d4ad2840f2941b835104f9f2040f0c819330aae84e486080b597f7142a79ba431ef4801a93f652786e88f10ee50e6c5065e8b8628bdc73b23411802dfb9178dcc38a0ca7e061bc7318c11013e7bf3e83b52085aa1772088e1074aa0c2c29738ddf4d8dc3e4bddbe3308b9f562422fdda3dca247387836d82549c67a63fafac15fb2788e2e686a0ba933005d2eed747d991d76b1f708d8112451724abfeb75e63449913d7c216bceeed199494a184c00c0d77f22a7279936af23b5ac86a3c09561d97292b549395bc2246caeed7bcee76f26869bb97c811b58acf1ef78ad35c27754602883bee2fba8cc3550bbe5ff8951437f00506be41ea1dbcb02caa4c37ef713353bb55a730c73eddd02ab84320bbba3e28ba0b62bf8c2834bcde264ff59fa2cc2f07b1d0027ca5a7b9c0091eb1a89483feacb53e307b3c7c7feb95f49a911dcba26f973b26e05463102537d728f9bdcd29f5e9ce463157e8df4eaa03fcdc2d318d1d3f76769faf16fe2ef16e6a632825793e76b702ad46cc69032d827193014f465b1159195588e4167dd69f242e6692abd09eb63474d6808e115e24df25e85e193ac8cd5b887a982f314296e847290a7b0732d72466ced2c68c6a17ffbeaf715ab3a8d74092004c2e7e666a3c069ac7035f3b610bf920398c57d072b405dd91b8ed0ebf15bc8bd5cd2fd02499c4ed1913cc08084d408e76c03ff3d713ff9f8acad523d6ffbbb894d32586588d37365b65e88ddcb8f770394851ccd341c811d48612696fadcf35b7dee030c6535084b09db33b32d85c293250c0069dbc01a505b92aa9d16aaf8cdac464fe3095166c3289404338018acb4819e872c7e794fba21e0826dde3049697c5fd1db04af092d766045068cf0fb30fe33eedab1c8cfb7b8bcf797afa617283a596aed8a32e1a4afbbff3bc0724aec53435d76f0a829c13207f981243f8db7787cb172d0d2f9d5c25e5b80025f6fa234fef10e2c3291a7fde2897fd381343336a021d9c9a85384a18206e3f7138d9ff37c509eb375862728cbb1bd12c0071d90a982ab86edb1e9ad7945462dd5007e500a0bdb62394ecb2ccef64eb50b6c18e855bc971767b74bd2b2ed16896b89d2d8a642df9fb513dbca19043cfda4ce95eccb22308dc77899976d547b66afbb3cda76520016b0c3b082903414559be80e874f59705e4e0644f116902d195ef5df986e3aac3e1043cc4abf9f9457d128a513f9e19fe8a56b3fdd86c3cb8eb8af51b756818368c25787c465f3343b44fb6ff8e7b16b9657b480f44c9a3e06342a332b5efec8e5605e37f3baf3319469923cdf7f53161e13d18da12c5d48e01861dc9249b620ff63ea9a69bac23be187937b6ae574a1b74ba0657bbe229195acdf2558d924081471998659b554770f1da44978afca23cd8ed22f617b8ed619da01b0f3fdaab5bbef0df155f3410e82b7d42342573a962a477f865d01332306cd6b5116d6e8e853b732793be704dab406a0788ab1e01aace0523a3a319c1f72171de672063cf7853fb38f2d80ded7ad152749712b0d4a836ab1afb11285736ec2b1fb2615d6fa2c84334380c58f7050bb37e8dd2d9665562136a99d923160ac8a3f7766a68ab67265bb8fe759f4355f9adc14100419705ba2e2a0238a1f931c8cb4a38c1bcc405c3f125cfbd93244beb1dfcdd6305ef082d36fc5fc479b4097856347f7b7ebd3f9f1a80102cfea1510bba7863432ea5d5e3ab32d16185e1bacaa8dc02ea416e7dea825cf5d78d391b7f745b86e84f74c0a25e5fbc68442ea4f65fa9963791ff0f0dfe350ad0126bc5a5ff9b12a5c4baee618e23ffd8072880eb749f807b68444cda01a6eb9b8f6ee545698ea840b65e55aaa2c10a0755eb400a14126cc9276f30682e8e4647d2db6a2ede352d7330e43195e53ac8cb692998208152526d7d1b77c095c6388a3086e22727f393680554829504ed027e48bb5c9a8fa64ec5c4761bfda1d5b4c5d35c4d176c2d25799bbc81c5d975dd16c7517406e50139d3bf7fccf0ed6535e10096be600e1e9a6eb7e4a4dca5dd789053b5f90980a82faebcf38e8e340447604580be7bbb1b6c618ac27e737fd9d89a9a0afcbcc2121b358c5bd35108c99ff8b03491a23d74a252b1b71ead568c5443aba8a29751805f924ee82072d93f2bba236cecabbfec9181100076719e31c4fb5a87e7e6d328a7170714d5b2640a81e1ad738f09c36f5032c4c4d80da5083fe404bfce2fe207fdf3ef1c6d811f4c61d7601e7908e52e2b46ebe5629a65403213f8fe7a641ee3984e2dcbd376be18dcbb5fe60a88675276c782c6cbe8d10bac7ff6a87e6755b658db65ab6066fec11095bab8e4ec814dcb1e2515f7fb030061ee52dd0807e5f32df1c9e9978402b93c46e7909f0eb3589f33ae37b1fbe0987e2bbdd0ac01e5b127d66c4dd722a022314115a13bb675abf64fb8251ed67605de154d75ed6543c6e0baadbefdc73f38de45d1b6a737676c3701b0f831effcf24e2c69458d72e6d060982650d50725ea378839b68b38a8f1eec4b0257f082b9f673e2c4752462a5db923d3a64c1422cd7a402398d63c94366fb0d5b5474b78feda0569b7d33bb32511075f6fcd9a8502c6bd515259aac4c647908bfbbc8c9e6867f2d1f401e0f3ead82e78480ba16680be3de8093e9335d3dbf8e9156c1f786cdbe2e9ad37708d2431fc153aecd75ad97f93bb0684409f8d69a0eaab6155e274374801ec5a0bcc3e5c4181ec64d5c9df69aaa9c0245602fdb4cca87712995be4a670abc58a2b781e9a009901e4022afed4e03809eb6a2a7b861a16770105c239933d606ef1eadbebe68ee67af16f6da99cefed962024e96fa823b36cdab635f1452e39d749d63ff696908460169c988637a0ddd8c56e7872d9fa6e29219cb8391d763b6fb43841f8ffa0b43ef13eefb776ef708c55475d3578bece45680157bec7faf52aabdec916b0bd7c6423e981777c9715838b37d0906e2fca2f6c819d18c69c77a68343b0f7eae11e2ee422c0cc0acfac5536fa394cb670c308aa85e99fbc5623c1141a9bfbfdd7e8c06d188102cf32d7c5f7509aa3f2c6c9611336bf8a6244c1189d95baa984c42ab5950cc39d95179ea5fc0d49d6317d01c7d586c969bd1b5b26f941516340479a883e9543d8b000730d1c3c2ea318244a82eeb948d91eefcbc2faeb64fb2c4b645d7a32d3fe6b46feaac8fcb15e0ce8735ac66442e7c02053c3ee23dc4be6ed2ea2b9332b3301bad0c7d3d227b6d2b089fd16b35eb597996100e972cbed4dcf3c62c1a3c011bdda4cf30c2eb4dca0ad63d00237acb20e0d188cabd5bbcabf5134385189bbddb30bea97be37e35a7babadb80a0088ec2d00c769931b9657b886093858cbff57663f15e92dccce2aa76ac87b874f846f0a91d4b24161c2dcabe6cbe6e48f43afeff1958efbfa113297e0deccb8948712e0ec638c8c332119d7a0b8808bdf566933d7031ea7b43cefc9592a78c1fb014e4ebed4af2089796e2139183acecc5f5721a23d09838527fc1b739d697ce182b95f18191691d9a3141f8d523311c0bb5a2a6126717029e72de2d44a27129eddab8dffde9c2b5d2b583e964ea349fc71037135a8f74590543c16ca0a03ef66ab13cbb4ff8b8930ef4367e2dead54f8d06dfb8f8a92237a8dd74b2dc6cbaf77e9e5b46c11bca721ce0ac187a90c1cec05bf701187aa0d6b55d3a97ec7024a32bde052ff6ec79da77660994ce0c6c753eab6e5eed8e8c916589e8ae4bbf37eb28854f1e92369333a45064a50dba0d78f550c3d9f2e4ffd50d6ff475297f30d1ee0220d45bb0f62a5af196805bbb92868d97beb6bc44da74a585ad51973fc559a0510a5532d48bb48dfe78ea45b764d58c92226cb47f7077143969dd3027d64268ed330de9451239f9c33c7acde1e1d024879771205f4190edca22d272cb74dee915fc23154cec0a82d271bebb42311873555e85a3fdc67cc154007862288b41bc3ede1de1827a0db172eab21324712ddafbb2aad6277e5bf4fa3adac2381f2a4a4c1092fff07932a9e7c8ec785d6ac4e8e0787583953c75fa7e358fa026869c258916069d6a86309cfde9d86c3a3c34e195f7c671e2b253cee367d6cd0c8c80d2d86fabfe049c5acb028e0e125c1397fe1639b16be996078105a5b986987579f059dca9da8b3a9b0e4ee8911d497e701f7a3ef90b3678ac896f27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
