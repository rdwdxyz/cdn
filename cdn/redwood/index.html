<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"92c1bb06da06b9b4cab31c6bec40dc000129ef6e65837450ea2c7cb1e49a2d72576834529779e5f2de5870ae8ab8861884eeca74ff1c89929ed803e1b5c448d8306b83e13374736434a3dfda1e622490019e9a1b89c43ba9d6dc52afcb98cfc508c750613957c1caef6e51bfd5b2abc41c38970391198fe4b24f340bd6f7a49d51d4086cd2085b52471a5e4c1335df657107df6cbf90303c24de4f9cda5b028992f0d443bb66c876fc9d08cb45b9541b3834dabf0ed16b05c624876cf236d9c4aad2ed46950a407d410bc2504bd1c507d7d3e03294d46b0677049d195ac0f324f517d161b66d22ba773f5456f8f72139f757b96b58a94e94c360fde8856dd6cb7fe6d4138df10031634539b5cd35d438a664aacfc5da1903e3644fe79dca79dc250ff5ed4de1acb8cea67bd2aa1b97dd1867cf18d9987fecf9c215db68b0ae730d9274b426a4df939248946380efe29d22bb68fb34527fb80f0814cc28c9c5a481829eea3db144e39268db38317ee319d32e6bc8d4ee0f43090a78d759a3f8be3c6dcaff1399db3b95ddbe1e57820ece20454aa9c105fc9f4d7bba2b2993e78f2a4a488c7175aa5c34c155d21cba6de47f29bbc48fb35a6fe88b646541f27a2030d1950754ac69e0d800549935e10cde7bb539e9be978c2615fa7868187876c81d6c1a5dcf100a965d549e9df12bde88ed2ece2b091739ccf3f72967c2aed99f8d8221958a78f54431b1524d27b26188b303ec48219d9fdaebf1e440046abd51a24b572f28d7b5c6e4ee35b9c7a89a94c3646c2e5e1c4c9d523dad3885189450777a580fa024e22dd0372c56405c967ff6ae3354c247004951ee8d5d92bec71afdf90f4015914d4359681780ebcb5ab2cb131fc7b9580f12c361d3895def2452220026d7fa93632967a182d3066851448e75e5c73f07fade57d14888db14872b3747a9515e845fcf07649a9a51e6d652c592f000fe3de0bc4b93c364408db72339daced3c544ddf875f9b018e1f1d7f47ccd6eb0ff3536bcd257afb3b909159e5af2cb315d58a6af89e0d09245703fd4ba70f46214acb596075c3f7d57da1ad0a72d1508abc4c06bd9953835fe4df268d35ea3c48da4d2ded232200ea410ac5e9e4593f62a77a63e563499746dfabc4a565ae7a01dd6b384a47bf95529a87b8dc88fc7b9716738df497cb02241584dee751a7292bd57d11e4cc714a355ce5c9d3618cc3948ddaa1a4c1fda1dc95acb1981575e23d4c32c185d4a4717980fd3a5b6adfbd64032b5550c0fd5a1c5e1ab036f06967d7819da75829bf41fbb36395b4f2d3010f0a46fe0cb9b05cc8afbf73f622fa3c2f9f6f3fba6fa67bbf537ceb66561e29347527c1a71aded0aba9753e026b5ea7dec81ce3e529a8ab6498b6b2bbff8f9e7dcfb9db45a6c873ae5be7795e6428e9bda9f2e5d36722cb35d831a37e05cf3ebf277642a66dbcb4beecb9487de4eb58a974e6c7e6db4083076d3a059f22a60e398a33b915b9314a70a98b98e24e7ada454754fbebd73eefe07742ad014259ee6d77f827bf5d6d2df2c7b481e5862a436c1b37e0cb2e064365a6ad755d0b9b116890cabe68edd71d3173717888bbf525d61111f5d3619c24f02bf949a5ece4c0757674b2b74982b788e45640fe098d4a4998267b1214b80a918efa95ea83841dfa98fa3b38d80487619e3f0d58d33b4d4c9cc4e6fdb30d794d1efa1ff5d02a7ec61a766d4fb0b59c844aa00b2f69e43235d5d05654caf1937f0a5db3698d814dc7234bb9b4439489958c761b6eff2e01e28ca8fa67a69651026deaa6d04950ad25cd99a9467206c57db63c92270fddaddf4b6487e0e9d1f8b58c3b73794647675006cc3e906ea2f475e9c392799a1b3e729add3b32f897149d12edd01651cc3f2b893ba874ea90df69fe502a7f0376cbdd8accd5fd6ee5db2facb8822a14e5d4c16c41cdcf4fabeab27b87720ef8121b293eab0ada435a05eaf31ef1a99d48f678a45a36d2efc58c731fed33ff7b587d9974f6b835c32937aab8da538f9efe581868a8037b93e368e7f35f3826133dafea54a05a60fa43128113dd316806dce6aed7102bdba75bca324b401aa50f3e87cd9dbaa6def20cbb64e6a50114f07bd5f4280209b49dd7ccefbf89d451b387a5022bdd6a8c9242bebc9c545bbee9b74ac75248004368922cf79ebe2f91d9b75ed739a795d123fd9e54894650219206c76a00642ad51bb79d6050cb8139bfc8477b9ee65a10dff80d5a32bb71bdc112d6028dd6a010b622a0d51b8a20eabb81c08d41613e42eb83d0b5501b2928bc1230f696615dff6a1102a7a6143354c6b49cedc528db06ce5cf8731d0dfb939fad8430435bb140736fdac35d00911055778c603c90e80333d9cd6ab165f9e56a4556cc57619823aead9d49f81c003e59913fa2d42c8f9957c3ee3377fa87ede1f4a3741a3a13762cd9e35ee5fe5f6045ce54690635ea0aa6d02998342793dbe92ada57ce388919c78e4993d84f79dbe8ec10b5bd0d9a4a2130556de7700dca0c3e5850e4b55617a51cdabe1bbcbf1aa0709edf5f8b4f24dadbb1eb0aba6ae197abf64d1a45b72c2d58d2451687efbafd3572ed7b17e7d6aabdb1a736a7a5b5d155dc02f0615f669dc8a18dfb84933a4df1301f02ecfa6d2def84e4133c181c782faa649e31dbb1ffeebe64a61e739bf529177f074deff78183807df4de44e550f045303600af2574585d22bf8fa30eeab93490058feb2d6707b1e820ec5aaa76135cc5e43379e75216d008ffa9daee50809817dc79128285f33423b7725a75b2c17e59d85f72bfb5f4c5e18c27736eecc694cb0b2cc05bb7ce2bf8214556620822cacaef84772a27614857a36a3da567f9c5cb29d2c99cb2fdb0b228adcdcb38a7d6c9c92ca8474f31108d84bd5211ba9f3980ab3b33dca5aa45bd7910d17aa1654cf163983bf756520f6e465f6cca31cb0ec11b932777e11c2de548d5e341c2d45c6729bbe6dedb955f2b604fb6e05c10df4870970c41cfab885504190e395a10322c4e7aacb4e6b495c90e606c311604ada4f4d946e17ab637e598c6ca4cf940e6778dffbb3ce267219c6f8d0e7d7f0a038b90390e0b7835b71c30acd4aa281a70e37cbb659127bf86ed16057fe8342e758798c599d1311384ba97fc8162601cde7f120df263731b25b7ea29b3a54c56d693a1b8b60c58a7dc0b462eefcead25abfea1f47d26d1a88c31b15885df017e83700c16e23f05633ab10818ceb4637a270f8ece3f81f1e739891051516d5060cafd36b6499484bafcb84110ee5f67dceedd8239ebea8c34978d86791d2fd875d436389bcb09fbb0f515cd172848d6354dfa18dcdbedfd8a8c68090c1d510696e5f2f76b93122d8a1c955f6eee4f216c1f456ca235876312b86ec8cb5a21bf8e25a40b4a8387797dffbabf6a13e888ff351804d5728a0365c3d9303e0ef4a7b74d40801e0c666302811798f691c44a619f5a4cae13fd796fbf9519b2a4756a345100325f13921977bfe36ffee46576d820f0c898e27179adbfa7a1f541323237785a2ee92eda836c0a9c1caeb714b0cb042cef9f3b71cb1fbf6a9db9b300925f019c9326597a6363f69527e9ac137a923879cf8b5d2a94a2b255832cba1b41e0859160ac52566b00765d04241ece90d1867f42aa5813d92d3049a572ef059d3a72a3c2c1ad22a931884fc9bc07d9ced0fc6c0e9ddc6dc85984da811db970f6d2f0b4ab12cd0ebe6f8b19c7a8efb87f48f987f72aa1c011a5c1e3df746327c649836878f0e4af2cae5b4d082e5ca3ae765b76e7899c84d56d810fc6800f4c42fa1a619c33d98ec8c18e1935b1ea27b8aa19ff8dd85e0e70a132aea3d55180651d4d5bfa06d7e0a5fd81b1e40cd09de168394cfa68d71fb6bdc6630db663e09f70f3480469c2e69bf0f4f6c94a6506eb0ff0043218a3644a8b7ede016046f459a7b3376718c9e4267f23009f083db80a7981a76dd6a7c5dc88a4fa4be648bab496a8a9520dae261d1e01378710743a8283a8bafee6727d0830f98f295bbd7e5495d2d858cfd23fa52c9e1f863826a7c9a5045e20f9ad71a626c83faa802a54053ae41c595938668e37afe7ca85cb3c9509c2f11c3686d79c9a24d47655f2360788489ae9f7307d08a58948274cc51b4d3e545a93fc4d768c87a2f7788580398890997c4f522492df748f92775ee9bbe6380b08aec6422392171836a2cf1bdff48a8d040d24c6a30bacd2442b145d671705f0ac8e83d22818df54a8a276e6dec912c85588041a0c65128aecd7113d9978c62cf4cbcd9d511b5813c40fcdb386068bc6ffb1298f8551458738bc7427e632631b433fe8119edcf3a412b506619e0072d2d94cdc3d9b6d8f1f3f40d2147f71e283071bba6fc8eadbb2f2bb99a13c1e19ea13bb884d9e1f11ef9546f5acb881f1b0aecb574df6bebb4c34e71326fdf218391c38669f5c4723818ff1f0e2c524f804698ff12f47511816d523d6eb00bfd2d8ef76df997faf62fb7b3cf3a8754adba00ed202a7c6e21a7c0b49afdfd73a4154eda98be57353b3667713ba02176bb8b3e2017dee1596f3d11ee29da2d39e192b8d106f588b349971a4f5498ce0e236908e25be36ae6c484c9df7506561a96ff339c6249cd1f937220fcff2676172f1a424176f2090cff8c6edd4944712085ecfd717a130fc2ffc0f419801e0cee604396ee44edd1d361276e8e84a2c37751bbcd408927cd5ca14979ef24e293f1d04b019980200e88e8a32a90bb5c6cc60ca54f734bc7496886e5c1f44e53a1481b49534c186d519f1490027a4c378cc9ce7a246cbb54321f03cc294eb96494e26f7fa63f6188ad28159eaf3cfcdb0fe1685310e2bec0bebaaad37fdccaea2d278e0494711d72e3043b49797c274696152b136483ebe013fc0d9440d2c1dc81c9288b49900826800f988adc8d63f27e25790f893c61fa4d9859c986c1a533173593b8828bac3f914a0e0e2152a1511fa6e398b42563eafd823bf9877e76d46293679e6052b945d5a9bfee169f31204f7ec071606ad87bd605ff289eceff132c723756afbd94b3d3dce8dfb85f7bb06432b76da7c3df5611763acbe8a5a9c0f43ee9200362bb4f834711f857ba9b96f9483152ab18f709e85030da1aa7a80c33f3b132cbabcde54ecbbd8094741bcbadaa52b9e80bff146e3c299adfd0eddbd543163143a2f9b56e15dbcb36aa419c2bb66757e88897494d74b9195d14a04c8aa06969d1ca98e4d72e3ab88deaa69ac09f101d9b969ba7d5c1607fd6a8c87709e25667cd0b8f3517fdee3ca2ef3a34039dd96a84f776373d7e22d3d1baedaa066d65e8dee8b74f140a18924a4fd69c449c8a7daad3d1ba213bdf80d2105ed2ae549a81aea8b384f726079091dce4db78440fffa7d1cd011ea63f1703763efca381f57391f1ff8475300302de5da4c64198b0633017673133f2dd558de1725311d3cf5e6e62853ca8bc94ef4d7938b035cffa2b5d6acb777b142275de0d4928118256dfdafdb792235c26ee97e829c521585d0b89b55e11c1a644cdfb45901a0563a35dcb4fdf6bba76ca4772463c6c6d75b4bde3147671c5b87d1d8e0cdd22f3323756649687d969dad21d3cdf2d3a29504d89dba0571f55ee40746f5ed57cbf33b8ca31f1769b0bff6256779ed04ae243c3c3d2528d914a8ee2dce796a46e5fcbc097bd2d8630c90caa143ca72ba00e5e3c84e568c0a38577e85a9f6293db9dd7cabf3a0faeb27b1f9b0b44a99b118d8e8518aaaad6d4c0b1e53927296096aba9234feb273a81fbf5ccc7477ec596c4ce1a4147e7b2d2e7e34465e89f8fb078aab3715274bbfbeb02bf99c461f877388777daa7a57a5cd10666ca1ae05daacc8355850a6aff0fe27d2677d6d33a5caef4835592a3f856fb5167fc6ea1beb421833cbea6bdc1d1024bfd1c788e9d6260e20658a75016b6616893f4ad481f454e57fdc71775ef9881cbca8cf7cbe03f179dbd9f1ec2ca2aba140e2fcfb1dead3d65e9f00ea6da31d3cc83e8d9d6cbf54073b98383a515446dfbf5cead777fb2669cbc326df5027e332fe6bc073a289c4d6d667a3b9ac48f14194f0ea1e7655d83244548236642413b371a4cb5b30308655ae964cd38382775d47b623f1ccbe41a5a651af6e8b23e6c0d6fc1b7655e6e120e22b29d317fa79088b5c5f70fdfb30c7040b1e661854f7ff2e821312d711fd38acba9db4576a5d2c6a0affe9b969c47960daa7fb331ac5828a9662f1235a6eab85075c3552a0064409ff6867863760078f16b242e2a79e654c08eadaee2b286537e7837420074ae15eb61141e6b7171291cb2ab34061f33e6a4b7e340aa25fc21a8770af8a58abf51a7e6cfdede14a76926535ec7a74d9cbdbb5bf0d74e02f10e7b883a88b85d7b1f1a6bda1541dd25bb047689c245c44797094b2f9777a8ccd76fdb9373d6ebcc83d8c708f7a89b0ff5aa71359d16198c09b243fe7cccf9044fea3c5e59d0db46b22245a8c5eaa43292b63aa4ac75dafd9e31f443ca46df56e2e41cabdcb424066c55317670d8c40a80b652a00a532c02cda163e593f5f62ab844ad904880ddc4aac8480dcf892826c994505ac0eed36c1b3a3edca9d5af0f522a73b0a8186780a5c037085d0cc9564444cf280d859a39a4e1234c007911c7bff249763ea1bacecfb7709012f0854f1f8bb82fc65b62a1c736ba360ec8435df9937900025f3fd82291c4599d0968b187ef1d9d6d6eff722e5f9feb39df9e1b7b4de9eb968f06cfd84f8f307afad02c28c1918012f1d41e6978db78169f889b9499c79d93422c5752841897fec51b432e23487a2f2b18d6e8dd7c96ca8ac2e12b5bd5486ae295c8affd38fbd95b6fcadf96c773fbbe64f312408a09b4453511e8212eaf32f8d919cf5f98a5d5dba92624b8346143658939e386977596b7c8ac0d5c7810ed62a4d2462708359524561bf2889151b714c3650b18561786821e7c9b76145fcc06ff129b1a24c91548287b5ec2e19ab386d0b9ea87f12b2b06cbcab258e564059108ba1a8aa1977e6c10b98d1b325a903a02e7527499d5b63d617c34cc37dcfdbadb1ce1aff1e3788b074f20f17000d440fcb1b26c35daa18491ec8eabf3ea09f27bf44c067c6781e53896ff1616424f6c4faf45ad94ad76b056033aa2d8fb886afc2ede61b806af0bd0e13e33ce1fa079b008fc5a5bb88f863e2b2d287028184d0295c6a1b366a48b1894c78589d7ebf05268643811c10a096edbff00d8df343f97c127ca99356468b8f2d343bcfeeb1468f969334c46d51732b6c3fe32ef7a3ca07150ab8ac12c8f3529154c5e6ac43ba6830d66f0421b12ecdbcbb16b85e356c292e5bbc8e59461b78748808c2134903ba2b3324d63cb34d2824967ecc372976364a7560a3f9d912ff4f2a5a8a8b820aeee7e94e3155a91a00d8ad03de59ea90c9ace5843e5a978f52d03c220ddc011546a7a2675a61089df836f7574c42fbce245a82c585e624e8854d45004d978564d7d1c336e149495aa977d7294d1bc7592c9771dd74b3339c0febb609462070e2fe999da69e059419754de4d7d914efc3b007cbb106b7889c63ff354f46f7d559f61e03ebbaa41f694476d0b13adf80f454fd1a2c54f3adc881935107b165e671dbce83fe3e4d4cd5a364e7ee0b18454e4f77e6994a54ba8f4e13e399050128becb0350c2b1a8d91762b605887e1f44c250fa8fcd6ebc141ee06cace399bf8aca6018319efed0d4e2852b4ff73ab2fe204b66edd1668d13c6206d7119d15d38ecab1b906d46b28f7e15e89344f51d15dd3b16e562de995311eee6d27db3d4c7699a1d7e09340781aedb0d8d7ff1513621d89476f3976625cf8c00f5528744d1bbcb58dcbfc87fd996f8a583af90e0027a82de23d8f5189e8e86f7140b9eef3dd116157fb6863e18b04d990a878401ce611d33259d7cc2417ae76e623920cd5861b86e8bcb9cc2156dda4f41ea0cba523a053a31083381863f11e919ec877f1b7c9f74d8609a024ccd8ef8ea3e9ce65073d4b902ecbe9fa66cc554e865aadb2090f47dc25958919bfc45edd44c63330f22e327da0d22d3ee794acb44be707bda986e32ab41804c517907d3068ec06fecb4be4c0adf6d8c9bdde5b4d9d1747ddf8aa3fabbb829a998730820a0a8d2b1057df1bdc028554ae44131576c6d8e9808ae8b4fec9a51316b6b46f82abd062a0a71f534baeec0eeeed546ca1630ff5f857354ca45013c1b88e20764fdd53b65b5cccd03191157ca98b71d3f21d1da0f903ab47ca4334ca332133f3c857297860c17e3de055e824e81dee87f6e755df0c501117d83aa33af50f2ec01bba123067da4bfa70c2d128da622af2dcdc31a90d682bf5cae399bc80af40724aa99c29a1dccc4a7486d01a01c03167f9ca556193d2078b9670a29de6065b8f28418354c8f14cd7d49f0b85729acb1b5442be6c6fd2e1ba0f39cd4272929e958f0c2d8647ee2333a1fa526af23a324e21ce99e3b7c3f2b50e7ed80d923be8a43912084160153d31f9401345223c8630b6f8d5fb8c52e26901be6244b8014eff8cd53fd8033491465be3fc9da99855c6255876ad41dc1403514e136d1977107496707ed871989bdcbae221914aac4567fbfde638d926aa2cc81d9936e0677b71c308d1f7426a24cb955acfb955a4523cd56036a7bb35db8e8a362c29adf491b0d7b82dba41842df21695c8dce0968e2b1b35c3a0f24be50dc936ce74adfcd0720b83a956c8595032f2db04ab79c35992ccfb19232c4245252bc56a177986848ecdcf9183e171f32134fa51aa48599ca7600a9ab662bf9e41c423bc1085ba72d3f06a873d9d004a71ab47b0ebe61fef263a694b57915628cf948357e846a38f0493abd6a4cc2d56e7464b8ff7d64e08e97dd4c7d14979fb105d80846fb7af0648a0acca225085e0447dd6d4855629ed36c4d6d6925d8862d43e23e56f7e848f34ccf660c4bf57e89fcc7e9c6213bf117ef3b1559e6a77fef97f80a9d53d6a1244a61e2d0610398c7d55a390c276f3e69494fe998fa7d0be8de5ab0f364002dfb37205355f63796fa4f2029201db7aea452dcba679265b925491c4406d66417b167c3e154f8697cc205e66daaaa82d60c9f3df8f43a16ec50663ee0ce67abd797a41013fbe204635886f74ddd41afe6a11e04b262ce0bd20247463cd90ef9a40d4a8613894913ffeb0376748f8478ecfa459f14445daa5b7c43bbe57501e12e6ef959fd53b5014d6bdb8463370110edd81d2dd1d82d9fa4b7feb07265bcdc93906e60d838a5ca2c00604aaf25fb2297d88d5717f9ac7815a06a548061a5a4a04c45eb36a2401f892b73ad15551a96fd6773510514452a1e8f66a65fb3413db5fbcf703854082381a783a09cc1d17de577fa8c6e602ebd4915ee7b5f07f3acbd515c8a87f8cb7c92867f09a3bc988edaad5dd0e317812ee5f6b4952f8f7f532021b2aa11d97a642ce274b9dc1d46db32f17b52c4563a33347bc397ade0cab60455fcdb6ef5b032643b5017609de6c738db0d4813b0dce0ba052f51d7cc48de3c35229392525a9e2543e55566f5b3625fce24a6bd93e52d9db93d28ed6a76aa2f0b4fec6979f23552f3ae45c4a3a4151d267c512da90b4a00444a09c50a9a889dcfedafe66495f0972cccef7b73028b11cb40c998d76adf416923216c00b34de12f1b6281c61669f9e212a823e446d0eebde9e0ec51dc3565c72d31185257755533ac82fdf3ee97dc3977a4c3a1ed1156efe19f45b47aecbb0bc2e9790f66405ff80a5cffa5c8323a7ba930a3b8dc2c6f267e0c71938f9c63659e7e47c6b28526fbad7cd083cdb68831a895144c09748c36a94ab9cff4f7fe4266cdf27b828be6a8a8f7be43703946de2addf0b0e535487813796aff684d90083c42627959fab56f4b82f99acac701df6f0e83120f2c93c36dbecd9e767cb45ee0245a1d0055bda4e75f24c228e84327d321b711311944557ce8dfa3975c827e09132056771da35d4cae7ff315b2e545402fb8fae461d17f7d7fd0140b864032d14e9c6c3dee4574befe17f1f2b01e04b339f6530ad1551529cc381b10d2c14174e8f8bf499a5ca11d125388129146a58d075ad26408dc07337142bf7d60c1a4e48ccc45f689834e335105679b7e71b0dd7cec645de74eaa05caeef863da53b745eaaf531965eb6bcce0b25241898883abfbcaa483c3e36b98198e471184bc56e8255444de563abaad4454b9792a7b76c82efc05da4f0f52fe36086b01e59fc8008d707b42d3970bda3059290fe2d68fcf57aad28b6bbf5cd1e6bacd8fae26774e6385def2034bf8417986e859c0dec0840342d6cb17da2f3ae39d14d3cf1775cf0acad166c511495ef70c9acb733d890dc1744a5bcd053fe8e6ec58a014bf0364338fb90f4750cde97020db7ec520dae92f6847550f1532a3698dd9abf117ae949567909f7488de781be8e3a9c33f09f7f0835bccb41c3bf41393b23561c889ae9dc3e34d9ffa5bd849840c4dc6bf7b9d320128130867576ad9adfe7e8221871f1484449d561e187da31abf7a625a083a93120ec45807412eb77fa61ff784329b115bb7db0b9e624a7d4acc9a0ea5e651599cb3081f0c98a35cc4bab0a25c876ba6e9ec67b8b80dfa378e5b498cb351188e7540c639f193c7c9fb5290fdbb3f7c1879cd75ab1d537b417eb10df6291529a05a64b176a68cd28c03e5201106dd850930df6b8cf5054a4bc58114a58f09c96ad047dca40944817bfbbb292211ae7cf10641fd44ba7b45d1bc034c80d160589d074676b6bec8796fc73f25451d4b7a41545b86c5d9ace37be7d8a90718d55380e6161f29512c55df5878bf206bf2edcade53b8f2e3b61406425a92ee0629c1f3fc3b9f8bc5697a856c941fcdbd030a5e5925a82c3c861b4b0f979fe74deddd122a5926b78ebba5290d7e38b7b04c1b138fa12d26e9d3a9090281bb5839e7636a0a94c5763ee8a2172f5a5a0d9686692847b068333a85f1500ce56caeef4236a2b68f55912cd7ca5c2b4c36995a0687eeda2f2f9b73b917f1f8a5d8d84644e68b693c724628c71d124a3765f36ebd125996b3090ce86424ec0b991efae3a9c7a675e432d3728ccc9fd44e25805887b57da02b1931becaf21839e89c2150efacdc4990219f4bad5dfb14fa777e1e059523791f6acde32df4392b58d8ed83e2e18142256215a10bfc08cc51b1bffee009c021d0718f45b140108bdf5fc9532a6c30c3fd169ef7bfb86454cc7a5e7991104c2a8b66509fe1e36cb444882023f3123ec21ce65c78d00320ca1c4403d3682e6f6f2ac976efcd75e38ccd218a041e89f2de1fa9837bb3ba43c6c175db0c4fff2dc8e41efd8ab90c4cb3872ed8058d1d8e54d2d027323b13c1dce8932451ac30033ba4731ca33ff67ff16b506709f428fb6d89de30c1995eff83fece75274c56f776e668583ae910cc9f6f872712ac7e349bd8e28f17dbbea4fa57d5aa52adaf9ebf0a1aec3d1d4aa670d81e6b39ecda7006b7abb6057aa36e5190780b50e771c87f1c5a6703b6e8006102d3c540a1b97dc0d8041814cfc786756555269b9ad5d641298e81bb390a0b69472fcd121fb14992a0bdfd3f24e4ef6c2b788b91331908341e057a4e88ded2e42d2b30be3af3125c8a306ab488f18f2a138a2232ebe1804dcc9f20bf10822bbde08b0570f14dcf4e342e347969d7656a3218678239cce798caf4335f102b81986eb16f530525d55e8c6e3a91c1d04fc3657a25c7dc5260d911eac17af3858c0b0aa62089abf42a1e2d0feae365536ed64edcd1d86f1788c305eeb0577e0bbb22fe200fc6adfb09e506b7ee178977329e975c818036e43d76acd695e12a198bb2e1ef3a36f2de87330f05db86696e70c96f940fbdb3bac3fb599ad526bf6df8ce6bc1c554ca08d1a4474a48e891c1e27d095b06be6b257d9691c86b925b1ab4e72b7f3b196076810bfbe26bead08a9f95ed9b9d5fa5804a530862fd8f108c2efb77de32d10739c1595c8136108aeb0dcc6903258c1567178eb036e70e15a4c0d9b34fc4116c3853612eb6bfaba036f8ddadbb0e74f52376a668341b0aa9015959858bf368cf229712be51e296f644a5fa001d36a7a496a56c4b751f7d52776f54e9826d71770a0246f822ec070efe8b135dfcabbbd321c0561d3887ca2cc8e754bc3e73fcde605d5668b03ba1dba3af24db9a80c8fce3d985bd55bc2491ca0ab3a3b89e48777b227a1e3d4ad86802cfede002bc42aaca18e4d673807d7cd51d95e2af25e1ef30779f17454fb865e7dc71009fbe2d9783bc5525baa92fce564116d06022be8b2179ad68a84f55a1d43b6deefa27915d1902a75f176c1032988d44d485f1d03b427bce86f76f019ddc1b1300a83a0c17f995ee01de8c5b5a44809df29a6d955c8881372cc1cf118e9a7460077738a8dffdaf4e6531064fa8951c7ee5af224ee9d38520b4e71f0e57fd64d70a6d09e81031b00b3a79c1f328ca4226675d313e8705a37cac8cbfc963303f46408a25ced37de3ad06bdbcc686b7eebc1b2ec5f80f97d2335fdaf3192efbd8bec67c50452112330b3a7ffaf51813dbf5c8deba8ff2bce359bb4a4cccb2041c12b9e2ca66ee679c26b81eb94c0f57166f73824672141cdab9bbddbc0182efa8f0eb273d59ff44464e0f1f7c068625fcc4de1eee936ebc9f4f75020a3c5cc7f5f847a1d583e03faf975f8893ba728270b649721283e6e1340c7f1d17e13333edaee9d80a16b168800119e772fb220d1e66ad8f69fd01afd703432d075c13c57cb8323c8fd22fb90c4badb5e36e3b4a6b0633d32debee1b7866c63a9ccf577c454cd774e3b19dc80a1c6465679bbf1ba990302ee2097cd5ffbb9ea62f30c0f4ae9356e4fe427557cac86c7f2eeb1c65884ae060e9433b8af9929737835daa86e2cd10e1824c3ac99396a9c0398db85cdf84b4ab8b33e4989f46d35816aa7e34d62d03926f6ba7b8746cce77aa75e99dff8bb6f82bc77b9b8fd5ca650ca636a43b054a64d9ff534cba8c2a72d2862f7a88fc52aae8fef970baef30466890cf0d3f68cd1d5f7e81cdfcbfbc797e9fa86bf1b6c7c9991cfacc02766cd05326ebbfde3635a28096113035c122f8b1320e68ad3b06146381f07edec04200ed8a7a8b52ba8b1b887a9f70f9cc0e5c25e080b40d7f7a7a496a3a584932ee6ce8f53d53b50a74a0fe276ebd98de2a4c97139d1e3b3444926e147449b9a85ecb915bbd9940e3836b17797eaf3644640a2ec5e54ceced35a67f12c0ed201e5279a8a7e2ce4e3d3e20a46bf7ace6540c03ee3a3b5b5071976113603cf14fb76d5efe6a46e932863f49b4e5d0217c5c8e877da7d550382eeba8c06f2fbb57f13550cb406c513c8df5d5c22909f97c9e995b78efc617095e72777c156530fde6b379ca802a0a0246ba82ae2f4dfc8c9612b81eb7b4f3e3ac8578b54793f3e100918e1dd96253e96a3e5c65b275d51ac6b292cc0f73d10c94d88caf093b4669797dfb081fcce6d16d9c6e27f6fe92ab62e923858a7554d2739d96b8a77954f3fcef53a6f960f1450dc3d33cd38b6932efb9ac5e4ed55aa7e4606413d02f97fd8bca7aa71526fba26b27b0a815472439601e8559f6017942a7bec1fe76f6b4c510b0cb0142b797b17aca927866864aaf2b0bd9edd280cc47f1e922fb0ef9f33922412149de5e4c42659ba29a270499116cc65f2d45443ec94cd6a8beb3f1f1f084fc7ccb406edcfca5c38939b62b69b12c41499c32350fd193f9615b1c6039d82589516add452c63a641f67c149740c0592eb16201639a79cdac6e9a155b7318861dac8d5eb4ddbe97937a1263ff187f28ba19ca167b2044f875a9754b80b068128e60e308ee4dc5a3c88915ee32de5566c7b0bcd68ec5c4466e43b9183a00ab866c5228b6b546db5a2ef1388691e08d3be7e048912f1b63c4bb2d3b4ebb9a1b2c2f1cc30316605cc91e74e29163a5901313128e785c5009c5c1b53441c6b57d0a9197c5bf125517450fb3f2d15278d205ad0c48fbe07a1a6792913033ab7fb3b363f4b8767f8b6ae9cdb9ea2cd2e73cfc291bf5ca12dc1ef97b337c731c0ba9372ad6601380bb74de243deaeb9ec981142394550b0e410a20a7a836c9950997da101a50cb490992217536ce078f8189c14343e6e00b3df3fb429a1ba6dc3213a2f61b78c7f8106116a222ae1f736a6df9dede1f4d2464c27625d25ca7dff21c47e9f971a94a06cd87af3eaa3727508df9a447e0592482f46ffd378642a484fa89155b5129e9bf235a302b2671d901ed2e46d84e3ed2aee5ec6d6f500d930b020050a8f1ce687e18ba47bf24883c90a659bd90dc7e68156252b008f0d24cdd2bc051a52e850c37ecf6ca6b70084f59a07e50280be3649b2e85966f4048e170aaf55b408aff7ed0b44206b5f8d396dc745c5f1b95b4595aa1be9d83ffcb5543b2704ca2779f970ae49ff735df7d0c6fd9d9e7adc3bdd29760de747b0fc2fb5c87ddc099d55eb0dac041027350dc0f923ee88df4c131e285fa3d877e069ebec036fa740796d55aab84673b49bb09509a1fd6cef1557940820fc0ec5f82667a8952dd002d1cb69b133a56ccdaf3664ce0001695ba0f8c495874cfa64fed57bb6952564324e8332d214c0f5b2583931839081f31d823e148ef2b4217e0c373131d9f6a3a0f07a1e1301cbfd1bbd713301a722887ddbc20ba1a4a23c160576bcbeb36d33bc79f96736f99be95c95567bc0c05ce597b9059c91b6db4bf7cd669af284fab11a8ec2c33ad056acb96809116ef1415dd8841c4d4331473b3fa592a0951e32e83f33d821cc14fa76da1d0f8c5986142f9abe0b38677cea9439f1b16a511e4886323a1113ec95b795966e81be3c363989fcfa9137a9b474aaf4f9cd9c158d6f253688a1685e23776c773daaf1ef54d8de4ed4cd8d92dd5d629a3cc9f2a177aac86baeff7f45f01e01e7457e67331f9a617bee68dd8daab30a788813632c164adfb1fd0097a04ed72ad53acf0d5402a24641e981839699ea08fb0d20ef3b993c6973b1905ad0d7aa1d614314fdc9876462d9db2d230b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
