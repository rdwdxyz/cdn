<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"faf8dac216d565af89543395c6c24b4c991a487e8f4df01e6e08ffb63a1b7da5b020d9438525fb2260f9fb5c6e721d33d14b7654f7ea76abd493fb691a6fc6dfc286c27943ecda67da30ae57170d71610c21c519c663f789027fb887d660af225f12029e7a72d4a1cd9e49d1ddb0f89d255fce734cf1c67a25003ab04f42f315481d55c989c57993c864b079fa6aab6482ca91681da811916aa2e1ccb6fd35a22e88a1196a5fda0a0f01e7986b5d5d37bc5df89c25c65739c68bfeab9cb24f7a104d4080cf827135727d6ec936c64640ff48af51d88acce44610edd3e87a8da5a47f2927a96431c3e9df7d721773336fbafa516305031e8478a145459a2ef1577b34b43407136d2b5015a4ee6152b217d5f4cc27dddd7170ddb3e8d10313fbc60bc2d12c5f577f25e5230757d03e6c824ffa0c48b8beeab05d3affbf9b6ad72a3e3437bee87ad66201bbca9cd82b2550e27c565b5dc6c30e3a9505a0ca3d26db9c40e4c4ac0c17ddd2860a7244aa6757fd6ac3f9f24aee9897ab2041eb28f9bc43e2ab1671ea877f857dc74faab4bf0eda500199731599b905c4bfff9aeeb9fcbec17d03f83da99234a405a9a6f8eb4da295169841ada4f2ebeedce174c2ac6b5e2a2d52aa5a4d08f7dd7fa6578f27fb2ab019a5e9564758eabdfd59aa55c730b610bf522e652af3d807de16aa65826c8492ad118ad3feb6134ee14aa31efa198ceb6dc838307f6e148934d8ed954385987052d3bc3a243e46d5ff77e7ddea4286fc2d109e4159981c255023051c1ae6ed935dc716336dfb989584e331a85e80c07f13336d17e7707f9d7576431b9de0d2bcdea76e76f51ed7ac8fa635619fdde7157bc8115cabf6ccb13a78e83243feb828681112a003682471bf9ee62fc58dad426cf5066ae2267417f2dc7dba7e502ff5029bfcba8e5163e99421fbe5bb038aec19eaf6ec3def0e39ef328b9ec910f6dd9f73a38cdb4387bd821f9d4e8303d39fd0092f63f304ba20947b14b71dace9ba59fc1b085a750ec89d124dc61a6860e56ef2bf62c4dc0571f9d9f323f166c36169dc09c42181a26e36dd51fb35a23918370e589c383a68cc5e3244ba99522074f8c37f49f18ccb640d6822229beb50f50d1430abafb5b2469bba8d032760bf3b1959bb3b065a7e4df6a07525279c4976d0239510f6afb2cb79f8fd7f9f019b2f35d5aee510c1f9956947dfeecb0dd5905fdbf4b203c8ad4717c198eeee3254dac139e4f2128b2f195e884a8443632596eda6c26eaf747e4850c5f70ecd93cb5533906bf81236fc5cfc551f6044f3b63df64af1ad0c71399e97873243cbbb025cb9b0209b7c5121243e7bdad58617c20c295e91a9fef91f9b252d95849eb2fdc16008d15007413afbdf2cf8e1fc797560742b153b886ea6e73f201be50ecacfc9cff9b2f14222d207c1852675c9929452faffcf063d0d642a0d45996e34ad895c4fc43ad630c0a212c4793c178f68b86b7eb4fd123b20ad3ceeb330b765c22e43302cbbdb5a5dfd1885e0324db83cab29c1842183cf5981df00562daa6ae9a977d34538657100d59cb4ba01a9634346c9a4bd3f81fdb9a62b9749c2013f51c1f18d75060be04c921a0bb7d089eeeb7299316b8f80035787f0254f0eef3008033e0b81baf108c05ad8b83cbdf833d75c1e137ce83774713f150edea12035cfa08f545c2bb79698526f88742ce348886c008904470b651608e4744d70e2ac2c177e1ec6000f2a5d9418cef69694475f366327f948dd50c49f229e742c449ca1666930c94c4f4a1f70ee0e147b9e89dfcd05c6ce552a8a7e4cf8f5182d90ff728e4a94ce57b39cdab9edc5905a1fec4143b2e1fc919c84eb288ddc49ad5a993ea2a1fd429a842ee7d9113fad9c98af833bebec8596910174849809567e8ead7e191ccfa33336970de9a5488ced82fc2c8860d68f706b6e7fc4e3c735cb7a8a0e47043b9d8991c83ba7ad5d03a1eecdb114c21e8d3f1e3b30669a860307153f1ae9d6d32b4ef7ca1cbe423ebebf7a7c3886677bb47df177ae13e2d54c3d0c99fb63daddc90fbc1140a71ec61d44529f4e1e7c2379e8e27723a1d6da8397142b6da6c6e52c39bc3c703d195defb37982af141587bd4a354d598977c51d162a60edb39a4d79567a2c49b3610596bd35bec19af74420fc6372594eca5b2fb37ed38a9e843ef68117922c1a2fe4e4e9fadbe5ebcc46a75142f49fc6e77f7cb87e0bdc3522449ffac7194af19fe34169e97504668e1ff04a1a8012be90fe287e9e7f7e92512e48fe42dbe639f2f3196484f1fc14331b8d393bd709b8a88237e2d4031d2f2b96def34bcc048dc4ad795236ede65611fa57c211cb96a43e229a8f5ad84207e6dffc125486db6cad6db5d45bacc7e63ee7d809f87d967d6846bc182f6a0e3924e826fab0337c8f540ba0e47648f31187d5c20ba90ce49eae466e44243a35a1e0d6c46c7272e1e5cc7d1abc7a4e79168549a5a6069c80d7a133a58259d1f38ddc4b0cc95fdba944fa62a9b860952a6f91aca64dd5abfd47ce9a20e39dd3231fbacd8854b5f390c7d8256a9c733612c64bfc460e858eedda9d6be52e5a769efd87f68c0d4bf5b02d3a74136be5f648376499e0d882eef4eeb52556ed69b922e099b9a698302470311e0d77ba25620c671be71adcf42248c93e058ce20c46ed70a6bfb334ea7dda017ea22313cc851c99d494d31f1508361c0dac8a7ae50070d54bb3dbbc3c6ea9d7b809bc30a64ac70214d05c93558cdb93824a8309911def22e1c2f7273b31050d2193274c094145e7926b0d1b47db11c39bd8ca33d78ba02a388e2aed80cd8af0ca3a62fba6c81ee212128a3a1efc120f860efb474a3dd2a4e6709b2ee0c05d362fa243eeda3627eb195aafdf2be0978feffe457b4d6413d0ed4473faaa65fab98b331f7a4988a69ccf03e8b91b4f224a54a9bc53ce77eb04cf839f76ab0c854a6d6cc1685522c65c17d321a9f96a42a470af8658f2306a5960f3c823ab4c8fb3706807d781a9398fc658e82789a8aa3166938b25d1fd20962a6748192bbcb58f12c719d18a9b6ff0c1a5f98cecb0d0c8dcb414d7ce9042db66b1a5efd11e46f10a15c1d2800ebfc9e8c9af15c1e720c5713894f7338a4d4a71f905b10c6e9320335ecc539a7cad997de4e57ffa78b3c0811005de82fbb3b01f080ee5441f38f05afc7881b2245b76901a463b3b9fc225d18f903e5a186f7506cbb51f0dc4d3974c1a77e9c9e7693dc3df6a442570f5e0a2d769f323036c042e0d109beaa2ed6450d2b31d4ec4c203b15926b80b859bc98b16d72bfe0bfd64143a03e062e6ac14d1544c8340d402f93de9181fa9f8c67b6f1d39d50012d4c3a2b25d1389c6112a4f9d911dc0152970eb735608ee1537b60f3eb832a20edc0c6bac719f9ea8d280c5ab7110c74d9d420ada7d22e734cba16d1a8a04ea0571bd6f3e7cc41726cbdc5b77429275744217a88ae3a73122a301fb264e160bdd2d353d59e743b2c4c9f5c4e6d756826943dbc86d905dab6c0d3f46899800c274284e59542d620a80420b00f1605e42f5b308cdfcc92d5a84ddadd67395d32d45ecb65f0c47efca0df60b52c39b34716e2282886e792f35000286e4d9a4668bd2255298fdf2b3650e6e89fc0b5446da83949eb04147c2ac28ddad405368cbf0ff752ae2190899fcd1991df9b2787978fe5565acba5a3f021972de39eae150b9325d898bab681f7f36a0e97f43c3ab980d96360bc00a8b7aea5d4326095f1d8c2fa61cdb78442c10173f73bae244f4547e3191a46ec437c57d405be96cc5dcfc23762f3461e58f06426b1481efdbcfabba5681881d8262481bee4a07bf19550cff4d515cca7823b3286518f56abf06ff095bb164732e6c0ec4f280fcd36dca1a8f6d9f41c19f5f69a4cdf3b2f3bbae65299680640d73325881ed82cad3d2b128f66b72e1dcf0a9b756d3f870c7b87bf3d0002ac2ce86dc06d8e67a8deba31af17e911f624fe1c32ab5eaa2f8d53acf5127679d8973b67cd5683784bf6058b2b882400c09d6cbe05f932704d850f84505a532514db28ff52bda1c534f98fb4f765f95acfcfbddc454f164e5c138cc48471d53b4649561c20033a07bbf543cad7a74053c506acc65b23117ff61417afacfdcc2c38c19036d8b01cc55fe4a9e7670c19e3346bc588c9062d07cb19d7317dd86dd72e494c4eadca00e443ac24a6012caa40f4fd723430ca20e570de0373ade61d72a6db97f8cfedcba6ae023708d98e8ea0af718712df53025672471fa7eb4a7ed771643c2c94b2e31ae4b6c7e2e79c259f387bb1d9578fe5b91a592b79cb8119fd09bc225df2671dec43e077c80f24f2cf0717d9eebbbddd9e6053064b1a166adeb35a259fe317601e090074d8db401d2addddfc11664b9aa99f71fbb511995c359e76dcd193691e45c5c0ac5abf83bc6c89640735f04fe69018fd974e6550dc1eaa58f089073c7f13d2efc78169c75d166caede8a716f6c2b95b05c75a4d0ee7118dbe79d4242f215326cced57945dc3e9b1f7ca1a6a0436955f2a213c69153aa0892ae9690ce258a5c88e5dcfc7ab95d09c8e84c2c83acdf692dc47ddffb749608264c783c938fd8490060ffd29dca310483296d6cb81ac30f76a7051d7ac9348c413a7c0202caabf0e127fca5e74e580345ba4bc82f3febb5f2679ceeb0812f4d5338e4fd9f3c54b798e48c8d58b8a7fa871461c80219a021f3e41c5a46eb5231975f275137a02ed35b3932cbe292ff0a6ce26fd586b42aebfcd5e1a6714c6cd2bc1d001079ac3fddf5ac8dc0a322949eb1c88aae55d0971e40b95bd961911e8b88a983eb99112210c6db55f6fa026717d831d5c8c5a64610acbd2e286c665d7f7e5a80019fd2b15b177e45bb80ec2488c7cbad6ce3c42b77b1faee3c4ce146ee2c5fcf83855380bd29340e3d53e4b4e0e5a9ebb4960e1fca6fc57c0553d4c2078068beeb1365c1f99c800758b54ddb3931e2e8b38f0cb0b211281a53ab556a2edaf5e24748f07e21dbcad1ca4b5561b6bda1f28b9b1d5c81586585a148902569010c3bfa39d42ffd6518c292097d0f334a3560ada29c1a802cb42e1325d051989c30ba88a0900b0ecec2485fdfe61f97f92a532155a2049239190d3e79c0c49e230ec4d941b4f01efb95f1948c690717645753311b2347c4a7db22b8ff48130cfac76e6c70476dec1f7486bbb08712e3d185edb7c269ef3f6fffbefbcc8bd85ebe979a70c94bf15239ef0d5dd64ff6b3d876ee422fbedd450e1d77a76b0d635a0da55c01f0fb3b1ad035a45183c49b1f497fa50326947d6e0bb39dc30e0e156fe0cec5737e7d298c1c0a9b01abd1d6de756cc8d9bbb6899ea3647b73368f7cb9d3ee8a0a2f31dccd6b11c7be1ca0ffae8ad7dfdefdc97a3689da5189ff8b3e595fb5a27c6a5352352472a9432cd7e1a253d88a371684e75aa4332d32f50cbb2d076b8bc4646bcf167b6e425c14bcddea56a8cff3e60995f0b902b0d9ee3899651b10aebfccd7c3ac4ef04a20f12db2b1195e3a1ce548b846905ca3332c5af840c2c172bd7970fdff7c3b01eb45d14a3461f437e5defede8e8a801361619b63e5f57c6d01bc27504e3a55e97a5d5184dfae7a47a646e3ad07ee5a8b623360bbb2a7fe82865dd7eeea5253b20f41763687f2ab09c930fe871c66d6091714e62f8366927d010f996666741db3e94f5e81d627744392bc11b15807ec5dbc3c2c308cac36fae4948cdcadcef58835aff49c1bb7974102da810a646ba239171eb228c477f33aa80a085af5b789b0e2bcb2a34c3ca3d73dcf987fbf7fd70ceca5179a1dc8344c1b2773966c2fc9ebe3c4a4055b955d09299f23ac9865261acc8db561a20975f39a88d48ad00a9e08e67f8dcd4e24d3bbf4eec311328e2792633de138589875e5d7e3a968b9de3d272731a98b222b0407c1df94773282de2998938db8f00d65891e226e5b8e416b16d08cac5ca926e33120a0967e81b7de0666051659179352e0e5041de63cefc5815114fe595c2c8518ae05368c724b7703a0589a19f862dcc11531e666043002478ff5022bed913d06bc7fedb1ad5f266adf77a2d122707d0a87c0f0ba4b6363c72f791939f8f3aea1de9252a335c04cedd1618ffb5679bf69f1bbe0e9507f47df92531718178d3cb9f134124f28d01d13c39ff86e80cc33baa11c6ae7b41e8488956770728b21b089de3fd299d148c0d979ec4e12b7c1b64fe421e9cc1caf4c7897d27860554230c58d9e1beae677cee181e78d7129e20c884d49c3d7794c89e0bd724b797ebdfbbaa1b4f2f22e98aeeaa84f031397248d2a7caf2ded8206978c9a9bfe0f94102f4df8fef5dd867af2c5563f056be27b767d4ab82de2439da7cfa7419de8cd916c1f752620e50063a25a975ab227c64d8a5dddaafb46c114c3418ddb430624430c3503e160174b1a69f00b22f142b28bf16633a9b771b272ec8ccd331ac35158954625be6ccf41c9da6346ac615c1dffb1e061e1199136e9949b61b519e3b20be728751b785c7a548a767e89101226475b6ab235fd2ad44346bbeaa589281a9293b8c4b93d7210b737de21c5f138486e34666de33c90d754f844326f6754c26003fc1e15431f2aa61d624b31d81a33598b2ef73bb3f3f4303c044eb9d5f4446f0a76918eb56781e420a37cc5278f4d47558de5da0315391e45f42ebfae8878a735bb2a9a62487191133ffd02551ab55331e235d5a333eebc0dba9963337c3e9c720eab8212f5444cc7e239ebd0e99daf7db712017092acfaeb186334e54f256bb1535d433eca890f9c2ce2da7de039c946dfbe4d8754d946dcf61c4c978dc758fa2775d71bfbad7b1b3f1b1e54789106bb1ea38e258a34386af831f94fab01b7aef15225f3f4854d8abd06b5ec71bd8b6aa9b3cce10c79746123cbd31ab670fe30006bff21f2e9bc4995d6a056d5ccd2e0d9e4aae7e9ddd1ac9220f8c60061f90145b13a7c9f1f2e60b43368eaf8d83b934c185ce67a631679b4402a21adbc30e3f1f1c41f94422920ad47c68ff2e4501f4cefec0faaefe1efff9117b15557869dba1e5fd4193114b978f096395ec8b0c443e819aff3b89af74cd98e5c43111e962be714ba54782b1c1413e1278988e1add7f1daeb6c30554ca24de8a2fe2efe9c3b45a4cd50dffd50d6056055d0f1c8436b314d30a3967aa81e0ffb03d831a4dc57ce0dc1377d6e842595c1450671c1c6285b37369ac07315467104961e0ca6bb3163f71a90a77712137a4faa49ab092c3f7ee77fcc29bdb6397c40c89756eca057e8641827e6c588c78ad4436369ec94a52e05f592e872715289e71324d92d436ae754a68bbb2afd15683c7ee5f7e1f3e17f83671a0fcb13e0c42ac311f206193d7cfc3ef0c70087b8a5acb51b15638f0026bda6156cd0a7bfffa898022b0a951f330ab6a4a7ffa9d84d7393e4fdf59d3dea525a41c091ecf500f4a7e904d980bb9cc65a60c789e81e95029683e7040ae8e643e5c8a0cc3805f12a12efd9675eb57bf83b9e5a67325ce7ed9827a16719fb301c162ddde28ca4ebd9e1ef2d48b20232826718b3a5124ff08ba1791a6f3edbf81c7f9c7c60e687e35b13608eecfebc15738be858cbeff06eada2971d8beebed04050cc27c87faf15a37f7e537a6f16337d9993fbdefff82bb44bac2f75eaedaedda23313caffae03a187eb3e3e4a8efb2e9f78a6afddc7b5352f80f94347a2719cad828c5dc2a6ca010e09ae09e52a924649291de12a100a5c962aeac3134a3995b52ed48ed02d7c2b19ba0fc1ca7a978c3b09efb5e95642da6f7cafaf8bfdd5a29d5770306c504a096543b586e4f6a1a813fa462b282b676db6ccd2393a24339b3307244074b3420dd20a174776c3293987a9cc6552a08ce611ede01254463051b581f0574bdc4378d8deb256fe87008508b1ccdc2b78af1a65284776fa3177bfd3a876f5067362103b94f78a4cd9262ded51af0e9ad76e5b15d83ba23fd6177003865562d636c703dd49cd8969197da5b1f47ab4a40df1ac7dc819c8234f953e2ee37f20bdcad84481cb7837836c1e563531aab627dd10663377e35e06e4498d509eaf992fca895284c8a76339acb8a0758a76b11795efe861a3ce77f0be9d6167efe5427de6c35025510adfbdf39328d38d1a12f2797735a45dff4aae361f0cbe3bf0d2ac8d129ae6f43c026055a2a3f624b551dbb55fe67c6e53fb897060b976d5544a2aa24532609992bd1631c5ccdfcb064053c8f9c28d6c9bc7e827ce3f2ac83a25e01bf9d9cab7f1dd8ff80ab39de01e5c3fae2925bdbbaa3d3b0788dbda73ccc4ef66a43b69535424489ed8c0fa9f34e5543c1cdbfdd7a254902bf4710885a467600fefd21b14a11699a74b857e81b8163fac4d475b8688e1b8e0bedfa6debb3786d5ad27db3e0dfcc100e345c056b1419be3968ae20d7036510a63e52d040556ab4f6fdb121a00fae207ac7e900343882d52dc4ee3cfc43264755435ee6869f4e668ba2bd88f4ad740d7061f2af24ad0dcc92eb7fe069f957e3560cd4dc95ce72014817a54d03e85c2c6473f87401f1872ee3db721493308d913efee6feda0f7f61883a5fb0b643ec05889e44d30db5845184221c89f7976460b5e3e2e54e9e3be8afc8170a29f874e9502bf0402aed1eb12668573773aa211ec9ae68f5f0abd680a35ae7544abc00641ba242d90d5b60112995986d14e0f26d4a0dbdd6abba9745c53dc767f29c0d69acbd0f4e5219ac87875dcfb82cdd283abc75b6983dffb878ebedcc2e5b0e5050fcc03e2503f9cfd0e6fa78da3216febe81936c9ee9231900e23d5b84b03276a4e3c26afd3c3ba8e75fef540fe58244fa4d9bd4182cc24a9f04cd78f100195ef4d0d950fab93bb3c5eea75f30fa4546ee42c260283f282d797f1b23a16093c2da3214ac581e7583356464465ad4b39514f2e764dc08ccb43ff2cf85f8b5dc0f1cedb8c2cee56e5e3bdbc266530aeb5ff37144394234b46958439a098abe6c59c7cd41f059c1840f2469b5b2129bc5e08248ceb9fa636de0e153a6b0d37e577bfe6e5d5ad9ff4c0373b2619f39a42494828cae64a39f0c4c226ba942a624e1d9a3aadd3f29df0815d3fe4b073e3b5ab2ffe1c2e16b814946ed35556b253f79770e9ca86e68a67327394a1e438557404c1eff94e64552d98dedc5a2f6d6a283dc944e255642836cea08d76f8ab03f199bd49c047bd8b2963e44523937a131e91a31fc2eae9c822a293f4967813764583333461a2f917a51fb09a5025646915b58f51969510838c808f41d7353c473ae0e2be4d1313af0bb0bdf4464273a28ecc2537c59e520fb269b69039d91ab1c40df6cfef1341029c4086117209dc6783a0ac6f9034a70d4665572c3f36353353dad5e4a706ac0ae6ac0fafae8a757381554172ba278b498673c97504adecf006c4bc0f1c112ac78e787c131e3f710973fe4b7d76f756641c399959ca278b6e80135a8d392d81f907c525199a18af170c94478ff19a3ddac11cdb015a337b9bd80d8ae980590a951f752e1b6458b1bb3c318c04a77cebafd4bd1a4b754bb8b8b8008446c91b0edbf64570191441c40ef35461cd51868b6e6762165ac109793daf534f228a59cc861ef2149a3177372bc3bb20688ee40c4364fca6eaae3e3d52e8b1e6bc0ff2b2fdedfed91e44ea9b0bd884a22b3682699ccc6b83f6afb2a745efb873b61bd4d0736284f666f8f88869f0f1282ebd75a3c999e37dad39e8830ce5d39c049d9d0e7f9372cfee09ee2a2e86f0ef48def36529deb1bb7e32da04a6a6f5a372fd063e5749816c112062b1de62c8eea2f8b01d802aef9efdf6af5638c7ce522261dd7305f85e3a2937b7bf7769ab3a0681e5aa2922dd1b6a67c33d3e18722d7aa786f9d79b52130865bda139ef45d3103bc2f77c3b5ed219c338acd72afde8b8f99509aff72a823caf2c2f3ea6e22fdc74b3f07836262fe964b9847663d1428f791dc933236267f62768d5a46b506ace8bdb2e071ca3f7f4505d6f4cf6a333e0bf9205a0a2317090c9b55a959ed0bbdf777b47583a1da5c650fa4da38bbcde9c0299f976e4a2c3392b16bb4eda5eccc55c94fc9696b66410a92aa9eebf64478291fbff60fba5992c5a0da2b6497a8db80d6d929b7ec92376c3cd26780bd3cc07866b2a3fa3477dd6ff7c49e6396e02f924b1d31df0ef8a8afc9b30e6a3c5df96358d46e3eabec51d8748e31ec386912afcced16a25bc290df76afd99d64298f129bec4a58074a2b2114e81832021df0ebcf5ac0f8e5cb93c25437aac20c8a604d89ae1926eac277f7091d561b239439d5d352dc10ab64d3b2ad03cb513503406f5467890d3a4944ba3028ca797eba72610f6568423b3bd3a74aa048babdb24423875dedc73003fcc2885a951a039c573d2dcf7950f1a810a1915ce1c4f19424b36833b2fb50be53b5124712f6ac58e7e475f5442232f5606bc87fcbac4874005f76eb5318e268170dab42bd673d1ec1428ecd450ac0b545afc64551dc48488057ce7d546ac2fe7ac37eb6b9ec95cf3f6168651299a15b2c231b8fd2a09a2fe1509e6e44c866beaebb86bb26fafe722a94f844a55d69a0663bcc3f25209786d3161e127a1aa0195c57fb113af83e24b0ca72806e5675596b34893716a192bd0474e84b9d58fd3ae6b72f12b8f995c1f5b70b18995a108cce14c587ac70b4d5a8826625e102d7c8d0bbabfb2c789413e3df4ab706aeb05f1e85d13efaf7797c26ae888e0bf60f57f23ba683aafcfc73c953fa96278b3fdc5838c29311a2451cd9e339e3e86d8d1c9344e34d9886dcbfd6d9fecbb9e8b85f1714e1647188ab891fc9f06aba93368e750b5a8b73091e2f0b20ecf9644fbc58390aceb5b0f9601c6d152ea3a8f353ba3a8a1c42ec39a58f07de4c6028a6aed96d63a4a4dfeb684c6ae0e4f0428a52c65876b39a059622abe6713f80af34452bc2eb9a167f344ebc3d5e720187fb37152caa5165cca380c7b4048886fbd8d811183e2c1a979fd460d229052a25b5458d4d69a501f7505fd3a7f85b2ed581f93f8041297592a4c6f81098560a29a6d1ffd8c17abe974f017b245a38531d5c42fc807474c82c25de005e99fd8ff7f7130f2157d53dbb34eeb898c6b4a5986a51958357d82f765e8ed425a1c836eae186335d50da300b622911a7dd6dc435fe894f928b839910dd81b5bfdccefaa2da270942ae844e0a4c9cf5061e032e6aaf15d66f46442ae7e80371a56f1c0aaf1ed654786dc9511fae04ac8f1c26bbb4ca76ed12cacf6ae715d06444eea164d4be2c90723bc254f2528f2889df26046468b044469ec6790c1c2102689ce04b9e5ffd54e91567b260a0455ba0b21ac9d8f22bd50f5786836fd4acbe512bf8564c1b68327fc1094abefffceef1f7a29a28dcd97abced25f8bde1ea19543dbbe73c4c1445b5e69ecfa66144107403f3ed537a54ca290f07f330fa49162ef1fc262008b4d5000c37c13a192146da4b176f7fe82e7655fa13b6d71d199484d5d76dad0339065516b55701b69095f9ff8301ccd5c795070fb142f456835000026e0da11461bae241c6178208d9668c78080a254946832f22757144e7feb846d2a2b8a5193c1419b1ab7401f7302fc0932f10025446204c6f029a08d595eff47d8ea00a94fa6d6a382a770bc036570a223d4790dd5e1d8d781f2da35cb4849ec62808d344a39a565931d5cfea972a3c8594a353f32f6d4fd6416fe6063bc2469ad7a3345d5517e3bf057309d5a731a9f8bd48094c62611b91686b9e628292566e673bc26ebfaa09b1fedc09f8278991b5929af90196e9973d473a88cd8fa4c2cb7625d542fc01a9c0e5f521f2f24cce11d56998925c02d57c8515dd84d7f1b74920b49afc2678cd28bcc3a803ba222b7b4704dccf3db5ab3976c2bf43064a44847147abb45c119f2469840a9060f47e29d36d90dd8629c27f4b16e10e036e427c1e2f51a8f26c6eb55737a39c27e4b53e4fee2d42fb0c8053e55f38c8012342c85517935aa88f5cdea5c4d2ce7433c6a39970f1202fe7614f776a2462196da3224d17eed89092f3d9aa3c5070f94815e0b59b4f3ded8727e25716f7e3ea9bcc82f3f5b8086b006fe12d03f41511229eb70833f907267f05998829c2d6f551973c1f41b3750a693e87b1df2014bd4b115ba037f76f5a0a5d0e3ab1ae7d88ded51121cc0aeedbd05259a7fcf3c4dba8b10f39cb607f78ec78d2d39a5775a996c1391f6a4979b8e542099bb4815ccb0e810f730ff93bd9846218d2d43a6859c78843fa3da0ccf0eaf3eebf3bf44aff0cc1730a824848db09b83a6e6462e85a59c3fc8aed05ad8701b3de24ace78a8e5e27d3d97d84da9bf3af5810fd2309748676fd12efc84f77c460317663867b5b08c79d2977c954b4654556966da221617c7f89b4548167c4d5a3a0b190a7b4fe4e1e9bdcb3aad2d3fca073990fc6a8c7e46264fbb7521037b5869e47c7d52e4a74597ef0f6d5335d77d3444e89c82ccc0add9463d23b1008fc95ff1116d06251e80ef6872f610e4d35b00043e783f24bcf6eca2953acdadd780515d6da59a217e34815bc93eabb69ac0b95e1111dc0e5282c078a873bc73e180fba2bd838efdbaece23f0d809e88297f7c5d5f0b49b8502ca61f95dd82dd59cf26ef0bbe37b8b9f523e0ef8583caf1be1ffa02d0053869895ea34213127ac5d5ebd6feb3d4ff80bf202bcab2a9bbfd79b000c4742332e73acf2f1451dd20e7781508649ec9f1660e0fd3ec2660698f5f35b6b236f16d9965062cb68a9a370b59690b0c1b9ec229ef19517e9c069e55a8a41252be3d823968ca89793823bb3a898083a9b2440c5a27ab0c89e75fcbcad40230e19979bf5f97c3c5e47ef15d05b4faf7a6f3e491f14253ab2037a226613fff9cb0b8a181c7b75dd51492141bae6efb0db203f0d181cfbc1fa7f5f5e58b5c78ece88539bd09a44f9042457035e96dbb0cfc76232268145b9633ba747c3ca1e8e5d4f2edf2092904059c5d328d9837a702afc722447e85ffd5ed8c15db8a70a0b707be42f7c3b6f13dd8b02bd80ea3d86e277bfa58d0bd152b4af09d52ff3acc8a4d790974e22422a64f882c9c7c1f5eb733cc0cdedeeb9782caaff8437fcff153d986e5877dc8485604ce8b603976664123b20b646c36ef153ba2caa791ccab1d34a6c00bcd0a35a9e0417a24a89fc3d313b8d1b41b3dcd3a61e6b55934ec2143c771fe9d73342287ed61ae11b5b800e99cb6020471886661684b810ad5753e277833f66b33c9581ab5caa2fba6a214136c208329597ca8c7c4aa1d1615b6b9b085da8405d90f8c54be06707b065bb08a099ba6bdca2b3bc2daa39926ed6c00e0a39b156d7d193f2ea76687cacace8061afb2ad8d612931c44538e7256caf4c023ba6a72373b5e6f3b8ccf8afd54277d69f38c3bd577e2df0d48db01595d769597a9830794108cf860e05b118638f37a461283d16e95678888e625943e1aa461794b88753f49c782d99e57fcaa24b4c0cdaeba1b9da4c21e8ffa4ae50319c90e7682f6aad78cd38c289582a8b59045adca7765382f53ea920c072c5951da296cc66e7e3a04ca9bd285d29bb985cee26bb3ce485c4f74a44aedba1c08b9dac409b48d1de436a66ad540e04097bb81d2bc9c00c70a9acbd1312360dc2fcc0468f1f915d51063b4ea0b433fe22cbb50844b2958c9e53cdd749da26b7286f36a49f5d084b782b77fdaaf9c9e793f5d1d9a0de7f62413de13a77daaffa7b8a1236dfb7afc8e7b37e8c6d7f9095218236ca10b3b384484dfd74ba72495e8262d5366f2e7ce66689ee392939bd31c342559578d766461ace88c56ffae9a406fd3b1722237d1048ea792143e69f7fe289d5f3224e1ae389a49a02bc41c9474cd29fd2591609c54c6f839e39ffff22f13c80e0f5e34464c5d6f6bc2bf815f9e4af51b60d32cd7da958b350cfe3c452defdc6f1a648e243bd99d4b7a85ae573b324b506870f4fb396f1b5b6ff72f1926aecc3473d1b30b36a9da9fa242960a9fc154dd150d4e9ca12b5d49a61c911ddca58e6d92503dca1543c8716bc4571122833c5f02f0ed85c191264bde1b532d77d3087271a35f02ff74ab5df32086c2a9cdffde16b3f8ae62de6bcb9f1a17f8136560ec75831c02ae4a6985370f495f141b7062b9547dc86f52873b3ab08ac1375953502ddddd4cbf3b9c774d347042358728a2da4fcc0fb4730350d90542849a0e77397167848ce91b1b493d91ef63f5a523a2ef41f0ad171808506b594e25f2246948f34ef6f61c98cd1c45fea9feb6af502eabf7cf059911646bf57233a87f6deb9374cc7a040d27e363af66e9414ffcb688c43b4c082d58ffa9380dcd526c8d17bc978e1eb69c9720b6edf9dffdb890993e405144bacedcabca7848d9f99128c986d10f9e533f93d2c98cd99c4255b7d1c06cc5e18b88a7ff1b76c151c2a84177f6e340fda8c7a9b10993cb7d8c288c049ba26346322bdc4b7d1ddf7be26b0a240eaa2cb0c33c61ac5fe70a7dd20184dcd5bd59a416fe5f36f3b0b83981642d4607352516692135f2698faa2f8748eb86deef540bfe5963a4850e5a3187dbd75e4c36e831f2befac208c64c7e88aec61a06cbf6f7d50bd1ce740d8c1d679f0ad16f0adcd00ee328f6b491fd5acbb786db31acbec8b8e8d53e5727982e5955e99459e08466d1ddff4eee0a1863cb1e4b41200a46e7ce0eb56bee02844d935df16e1deed5829a50b8de13d0dc4e89c2f4eb660495674aefced145681fb8f516b527b978f18cfd2129a7f2af1bea817ed8b74aa5c3ed1fb21bc96d6f5ee997e28e2947efde8e1e8d90e53a3a975736da4378f8dd7bc319805e5e44f85442303be7b45e785040a7d638679b1063adeb0de6d4327d4af2c228b9e7d3ef7827e12ebc9d595e99719f10f70b6126bad923b0c9d8726fa491fb025bb4a86291240800cc41ff84e2fba69c3fbfacfb14f135bf2422c42866892bf9bea199e7f4e1b357798f688f34d6c273b6c5fd752cbdf843e08a64d7879ffdc08f0060d594a7410f96e41637228af5a168ff89007cfca74f80397642337d27e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
