<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19e23b047d41386f3c585aa5a4b0eaab044e9c2994f497c44a5bd3b1f698e4b596abe294caa4c95046985d79cb9073b363b3597b78e4d6d0dc049d49a9c120d26cfb73f43255b184101438a28dfd999f3453fa07bf55ad8529524bc62167a603b2583cf1279c45c2332e8825df4bc4df5260898627a4cf2edf8fdafd6d1532e94cec415966ada7c14d138850d17219d591bc8ba5774a8541bbc21d7bc85625b3160292b42b535b2b1a76fdb8695b2944c7ce62fe5c729782a77a235bc7aa7ded881c553f70d1b1e9d74fe48815c136d198c0874d5628af218bc0da10a1dd4898a6a2ff1a0ee4046e0fa7819011c2b23c31865e4188f5d02c6809b54236839a315c5db4b1c52d2586bbbb34d74ed556dd006545c44b277694587b0f8f6ef63ec70d0eb6dff6f207f7d89b6248110bad0eb9d96d054e65eec8ea4585f9cfa2e6239fcfa685a2cad4dae656e920f7737b5bb9ad86e5adf0c94870b533a4f8176f773fce9440f9be646620a04c1f8db76c2958e3d87fcfd9d200dbee1f1d5473defa3a6fe1bee41090154028edafe69bdb702a795c2bf43cdabeca6cbb363517afab3e560d92d06a8b033803dff5c6e4f54c0d47aa11e91a505014b60f18798ed16218d3debe931cbad9f214be2f6ee222c1721a56642ebfcb4a14a6a46b9013563c56ac0c8374c3f68448cf288f850ed0190804d05ce71a651782a8e1d696a4e0cb5820013d510665ca3ee227365faa21899a2899d7921c7f98eaf47482a4b90dc7e033c8015f28c8be4f62d0c2bf55c3ac50e442c59fca88c5bf37d7ba1615857cb0cdeaf65ba2ffc43e41713a198e81531d6adc8ac4e155728e40d1f0cc8f42f045cd01cce4bbfe3e21ccbeb343101e31af7068a9649bc3728ab498e095d8b5545d628b614be54f6406df3f3565f00abc0c2d15791a6083db799f100cdff2614ca332c89d0b907fbb114a0241779d5f671f6f53c441cca921269d6fcf69fdbc2be8578f9bad4c220475938002887941527a787991cacedeb68c8e9fbb00651ac5fef3017b53b727e59c0e4affd1f428a83e2fe57b823e83f0f665c0782e302a00961f56510af801e846cd94fd17b8749b67bbf1ac7a9c13f78b3a2d91085d9448e6aecac6dc2de32171c84d85c0be8b1a674d5b93511cae0ba41fdcbd63dc9714057e473e6560c21a0fb3d97237ef3f6f89fd6d7751b8cf855d9a95d0ac89a507dfa3e41370635914b2d5b6b914624fda41ae8f228a6b7977480db24d907d9f5aa7f0c294d8ae80b5ba908bf05fcbc793366aa9a15818ba1aeea66971024625a8c18c2998f9357e8e867b8ef4ed345605b862be919ba89e0cfa39a372edb0e89457ad74824a3056b1b78b7d43cb580b67315957a5289bb343fc9d745d8954bd21f3256e39b43ec49e0f2c2c7ed066258c45fe189137615f52ed24609f35e880c2f124005ac5f7059b7a265a439aa984677a271013253a27a2a21964e4c80a7a2dae495f1cfb15a99a29c342f03f9a919ede2794b8b1bc8e6768ea64e46fa3b50ab819d059665bbf8197142eee422841a25581ebb4b92ceea0a99f88222d5a0e31e445e75e1905e5e123f668d71b4cf944d88f131bbee2a439aa3bf1e5004f8845301fdc81ca07f67748c14a973b32d5b276d3786eac30815368e699b5cb76b34516f59be97ddcccfb741023f41a45f6395755fd06eca14ab63552705f7f785c9608a55ef7cb4efc801750372fb9f201f2775044a6e45eb67fe875c15420e1c076f6e56dcb223de7bfb27b838a8582fb48c8d50febd35172c38453bace56071f35371346b5a5e381df1f2b8e58b872b371dc1000535c981c689e0f34214c0ce65f6312e013b0994968a327d5f4cd0146877cf68a2a5392bbaa41f4ffee8c08c50bfbe0ff370683b912743f71c5525d2af2898d4ff84b8eff9f483420768c0d917181c8b90c96a90240f9a357ba319da348f2c4dc3c0a493677d5e82da6384e0d7c5a970e4904dc6381de69198b0c001c23ed3d24892b40489ce8df8d5d819d2cad0bbcef34fc6263aa0895a746c76fbc2849450ef2ecfce9217667a1116c9db6ad358c3432dc7ff713ac477ac7458d45644fee73c29c2e27110bc755e4ea5081650c29e31acda5429829128663afca3156c10457f2e5c0c7b30da4811cd7980934fba8cd28a12021f0b4bd79f0f3777a3e31fe67f56dbb4a680fc1d8ad0465d65a75185e7b465be61a244bf9e824fbcb9b50fa1ac7fb779bf4b30907ee20041162f6c0ec8bb08adb2e8893280e30acf5e93c9e9a72cb1d1e9f0ac0434a3ea87d481197ca3c0ba175faf0d6001e3bd644e45dbb2dd8318523f7d2ae28f78f46f4104f05072e965c7f6d9e3bc576a04243090ed382b287c27f3f1220c389fa7deb31cc451b107fa58f93fc1d099485771706103c5dc4a66635c950751022cc1ceae920b019bbb566e84e0b2923f4c5c719a92cc3fcc024e528808fd73df03d2bd00c18f330e14fbc208b1175281b28d5738d04587e5a1fe7090ee6487aa4c4df4769659a23e31031263e63ea5e85f8c9955d1293b152afe18eef5c83bbd257f86e223591c67ea10ba97ef36a8856337a35321a4f8ab364a9ba614adedfca085fc60124f19f6a8768a4ae49345155ea4238caed7896f7d6257138381e817be22c0c03de8122105ec2ddae24086453288bd6cf81e12811184b88687fb57d2a744927c75076ae8ed67c5cc91d903d1cc6b38b345c660761a816e58449649d6099e7865f68112e794316fdf6e90604cf11b8905e6c651e9f4c4cb130b51619f70eb23e8efdf1b62b95b481a3dcb5b7777373a5faf908110874c2e7970b539626417a4f0277d432ac43f2d4be3e7306ee23bca079e0260fb376eaea5848a700f37bd0cf98205f5a14344ece2c887d63af1cc79c63adc848862e986e8c2b1a603df57e4b931669c2244f247f5a5e2155f22306fbcf7793a5c34830bb03e825c096985a08e53f79a5c66cf8e3e35f4213b6fd4b7f86fcc696f6e3ae814e26fedbc2726b4c9a475c83ceff8fc4bd0bc71e78878a04b3f0bcb14a916d2575cacab139d14634a9e6b22f352175f140401a5f08580884b5db6632c4b6eabdc67e01e90a95813eada3bf8501a2fcf221adcb959bf38e49b2598cb0f4c8fce2122a1e97f89e970a27647c418114e7b259e8bb808f82c48edbad23ca0bfbe9e2a319b996817710018f170091926774850d5a2996caab4589e7a431c72241fe157af3350be0724e103827fe198ba147c3dc68b944f0df74029083bf60981e97d973b0bd6339abff682bf67651c0c80fcd7ddaff26af4bc5fe0a4a1ca6cc50a8bfa4e88a4885155aff72d4cda270590a3c99319a3ac78f514d223936f75aec707fdc86feef2458cecab4252fe09321ce1c9b2c923412ceaf7838e17855e71b91f227376d0622196fa9bc56ee35de6c1584b2af72bc0de9b6e3a6302a31c0d5c52dfac94911430a904645fd94417de0f29e19b447fd3875a22badefcf21da85fcdebb825920b08f47a92a16d08d2e20f4854f6104bc89ab93483ac24ef84a41827b7b471a320e5503745160eabae9a7a51867d8b6db9cafba348c4eca1a4b7b542c39f612ca3626ed70db9219d21027d703fc1389a5c9a68b77f82f48c481114f5462d4d5ce0170efc98823123c0216439b41e51759ba0ba41df1a801ae966552138591e107418158b37e1e114b65e480735e28265c22d3591e45bd0bdeab8cde8429482e74eba0a4635fbe000e31f785209a68f556995d4059fd69017a3ee50c28935eb912655e9722adaffe0bb32541a787599cda925eb92aed01cfe932dcf2df7cb66bd1d6e6d1f51a2dfa0dec799d62c75a0b64394de4762783e2cdc8d95c82caae6e61d66d61c85c01d4fd8e2fad196efe0713d3f185d9d99941cb9b786708f03678d7cb85d6d3c384d83fa001dde7ec62eeb83030e12b777f19b49bdc8aae685270978c80f74c96edb046342ce39917b257748c46c2614e04c41215725a580f2a30ef1fcc4fb167739b3d5ece94112c5ca943ef439b2c490d2250f47ac11f065678d4fa2af758f1cfb58b4805fa9741257bd35966d5f128156326d2d1d3a71c925df5262e8c471d0c4c56a63d942136e2966032c3df78b97eb2bb32dd9aba30cb1ec920721355f7826c75764f641bbb65e19951ed7ff8a8c431098e4efcea83921edf1ea9e3ef10054cbc41fb8e598210c7ccf5615c04bc0dfa6254cf4df0fa15981c4d767ebaa63e2829f4b753bdbec1a43920ec3348990daba8304bc2b8ba3706000127a93163ab7f5844cae2eb3d8e19ad98e4ef224eb44de0024686ff8ef4dbc7ee5879c6333692f0ff5b1ec0977808e6760d64dc2e615e513516be5fcfb31303ed77b3ecf4433c00ee0e94e7b05f083a941fafefaf9006799ffc2af402788baa49743832eb544c1e5501d69b9f902f1f36db35ba8c72e3eb082bbc2a3ad2856709a5a73955cbe4dee85c377fdfca2046b00b562c29be17e9f20d52d8ab69120ba302e7c489f68e2d84b37bdbfae4504e9105eba7bbcecb8b71725bfd9a21bf223432b5d89e5b4412d81cc83078f408c9f6fd623cd521ad129ead6e77cf505aa01e3b2bc20fb1ec87a81cf5165c38924cb18b4b2fd0c4b5197d1c04cd1f555ad83bfd054b31a329596cf9d1520163ec5d913250418f2097f91834aee1e42c57ff087ec5c54d75a30a7546ae699af150322686a22349e2c68dbaa0435e195b9785ea77db0b7e061d1fb90cb7074e524a751c2db87433c7b5cdb6ac93ee38bfcc375fcdbbf206215b2edbc7b3cbd1c1da8134dafe1c338c07f861de3017bf8683f5689f8e967332c0917ac460455d6ed913e3645e842796a19bb365907a985b6e62ac09ae4e031eba72f78af35219465759b6c5732e80ff1198a1b32b172633f72aa23653b31f186cfb5193ac3fa6cdaf9a5375c495fa0787aee8617a8452850e0e8de89865ce5c2e9ea17ab2d182746bed6f708c97dbfa993853f5f2be12f6f792201bbf97507991a3060f3af9b846f2904219bfbb32f81e417ce858ed2b3f3560642cf1bd897673bec0de4572fb83e80657808da2beaf4ac65690fd69c8fc4ebff109b2360beb3c5435c0a0e19e3787571fd8365a957709d892bacb5070e53e0d98e62a6c73c72d66883859e497d8a558643405b6a236dd310d7778cd64da4b3290f43dd9fc5bd518e7f0122188ed54e844d46a8265fb8ba9e5708fbc066eaeae5633716f6e3aced5a43dd0cf02294ff476e0a38f39459d9b73bb67da2f52acc93a13cec2d5f2fa35841509f080ad1037e47ce218b1c734acce4e90b097f8594ae40310d4aa6e74f12bd0e9e1abe4012fd7afe30472a1d806f7985345e93f35443a9ca8ece922dff66ef4ac9b2aa276141e3bc4187bd0cfe09cf45faa8e91663957f29c6b559c9236120537617a8b872ddb62ad2730f97b57dbc0bec07770218b68d09535fcd418b367603162d2184c8b742c82747c7ff7c52ea8e19f728063f4dd451171d2fcafe3d062f1061e232b2e887bef74adca807c26f9dcfe84221899928e25370e76bc1304b0506b93eebb3fb2c6d555bfb489bc5687d94eaea212e848da78d90ee3023e015d3580df4b36b109653f5aa35f9959833e8e05cb51b797987a140799127ef1d15a9311f166341b5674efcc9bb01ae5c618795311f682f409bf70868abcb68a31bbb0db48e3ca14fc20d2cfb49e71cf728631629ec07e7feb3f9fcb37d753960e0dea9b46e0bc484fa4d21cfccd931078e81563a94cf95828860fbdbb61893fdda571c15e69000d61ff0a0b7f971d8cb8d6d6a07e7ab677f5f839b6dad57026cb71a28431ee1555e2ae4c4788b17fcb2ea24b961fbe186df4da09558746c7052951519d5cc06f5c248f4988de488d7bc8afcf89b6ef23890bfa106b2d9f9da283f57a4c04fab7083cba5d70d188d4271e61cdf5f013e299400ae59c7b2d290b795e2a00c7e3cdd4217469996a15918f7be4fe88b208b29c4dcb1694d3208322b72477fb9a31d4a08b6411164c6ada617cfb84e366cbddb340788b36938449f526319d570294f14de535b067a93c38852b8e1ce1bb7da4e8cd0a5218da8bc9466f801e55513647823afd5574e061a5a0ae38b108ac113664379e7d7fdfa410b8d1c196727b86c79704485628d3fb2e20839f7106c124c7e02cf4222333e12d342d9bd97fc62f53405b9a5175a13804cb33fc9c12348b19b03b1f8d25a691c955728291ac28350481bbe86189ac63b39b89fee7f532549b60b292ae4291bea4b2ea154607c9de7f5ad6e9cf7115c43c7ed890afe0d67d63ea1a29adb42db8f8384eccdfaecac8508632604556bed467f8071771dac0650fc5686001cde4d0122f54be4ed895ca774bbfe5b0af5bc7f5bb67a3b35e1c683e72b610aaaf675e80c5aaaf927be4c89a3a66dd779e331455562a46ec62acc1ca4f4eeee6210a0c56341f8a4ee30155c8777f025662a7ec1357f149329c12b4df3324746db07b204550c866395fe186196c2044b088aad7474a56b0515aa3161a9dd52337c1f3cf484cb3bb2f01dd59763b9fd79227fc42a4302b10e2f8947f3c8f21ebfa6349333395e8b8d7e18c034ea46338d2c7e2dee87bad217a39e3a5f404a41732aa69ff2d5fd097a2d417b0e16a977e2487a99d203a9984f8a81922bb05029ebc0174a21927ee06841462078557f2643f92a69f6ffa7bcec5f135acfeaad9aa1841cd79873ed40eb07e8eb483ffb42a10bc5818e65af21cb352747fe55c93aabc821d8232fb6aff049c10c75c5f408f824678966ba69f019b36177eacfa96d3e1499ab6f22ee1b1d0878458594e39752996582728b0e2f29ad2ee05eabda75ccbaadb14f41cffede18efa77e1ca04d0f21539b4da4d04847fe570a9c995476e05b5f5c9423fba72b801e6d4f00a004907bc34cef4589d42018e003c07ed425acad2453b0082291e80162af09d3c1fc34859a6ad750670a52f89f72e9e4ec1e6cb6fc7072eff6176a1d9223a3fac498b9f16affa16e06e687666af6538aa837113f55248ed409a72ce9bd1d67acb6b6593af845bdb6ee923f8e2cdff3d7aca22227fe5577b267cc1ccc60dc1ac563483cccfc17d568ddae19f955c407de87ff6e6b69e6f83dc42f9ed71f6170bfff13cab0e94af3dcc0a52f77197690379a9ca3b1e2e23347d3be901021e82fdccef03a4eb94781a53e7a0bfd288d31ba058826ccfb0b8ce6f4b66a68d4da562920eae946991d4a1b937c800886c4473936c12141194433d875b0c7969d2256ecf33c135b9238ad5039d72627db8cd153786e0dbc16d26e1764cc823397178719c16cfa019f3969ad74c34c6e8466e8607d753f048e8cc124f399af3b2bd88e83df919a44b268d766658f7606d4fe004a84915b8aee2cef938aeabe3ffb8f11ce6b153f965290b552bdb2b4e92c2032e1381928053598b218976594fc8c0fbca2baa87a96d57abd236c366a061e13a57a6fc62434fbd963e33cb735511ec37402abbcfdd67dc04e91761cbc0545ee79237e127ff869b407f986b64d2e749607bfbee2f1b653e771f8e998411afcd911cf6aa2173c71e04a1e69b1eaafaedafdbe58426d83a4488287cbba2108a5ee0cf4fb8ff614e65cafd28c292797297249f4c6b83f774dbfb6c553dd49c53fd95376571110f6eaab9605d554d137e1a01b0c9210027eb6d084e30264e43bc67220f7018974b55de00ca2866570bc558cee598cb34420b2e52bde6821813c6469371ea2634089be507a7da8e0835bcf4e9af3592edb6bcedf69207d60d7361d7d9c320cfd4335f042af5153a44a3058962ce9f4368721b507c05b1e953e79f77ddc87cb19c536a20cba5311ff91fdb920bf651adaa32db68dc75b30ae96c548b9b0f51d2904f0f3cab76569295eba8edce97f133ac280977ab1c352784425c2f242f955300456e81309b060477f1a20d837b0761fca95b4396f6834ba2d7e204838f09e13d0963613f6338e06e73803e955670b205d42af90c5cbbb6b9c4c5d384639d6950b3c08c291af5abffb7b65cd54c2ed9d85e0460aafeb70eb62318b62d3a28b812471064742a9f8ff53666f37f7b2b1569adeaa5c494d6d2c1433de9ddafabe03cc7c9c0d79a8113f62a29c5ff09332ab1fd51d204f04a69bea435ec8158561f941cf025d36710d685423db818e1a2ab5b0342ace37ca1f662a3473a8c62943ac735c9b10d51a9fec5307c1f768208a7091e0eda40ef2242aa5365d03a8e65ed3d6bc04e2b0cd1e0a0862c6ee82e575727397f13ecee94ed49dcb5494c9e54df74a12a84ed85fd07b532c1d9fd0e31546c591775d5de942963ed4cbbe27534e945511b8661d968b3f050e13a6523d0e9fc3b7ddb091009cbb538c95ebe3e22ed03fdd0dee9f0b55a79c86195178c5a25cf94d72ff295641b7832c53824d522f1e9d235ad6c5403a25ea6ca34d9457da4fb5e30fbee86a6b54b1dc9473d0a4632a7caaebe8a7cb0a4e55944d9e4991cd3b77b6ffb674e4be4abd43695e08440e4b9ab1f05cca1235b257f03d17d6b005af1babb0e8c24b61929209a8d1859e09a71617596485902c889bef8f7c87897606a3e796f98f75733621a25b2485924281ca2a504858c25c6ab944ae8463ece066ba746e46af0948b1ea3e5fefaa22bf100051e627f073639010d3d12db9d6e95fcde1349d915b39a40c82d395d129658a721da3d4dac42e1c266edf2d79fb8a50f868a5d90abce6bcfec8f6dc80fa7ad4bec719ec6c11f1d1f08189c9804d2685b8736565760fda296f106671c8d17ae82d34acdb348eb8bf559799eeda98c0fa86034b492d2de4124795133ae78fdf69bfc4bf82ac6ec1e8dccffe3b125e1bdb8ed941bd14e513be5b740d5909da192ff5e3cd2c8fcbee83c46685409279b09369c16c7ad99c8c2e1cca9bac3ec79dd108667ce40ea402419df4c036a8d7afbdf68d8940bf05702f408ef3afa8d13486898e4b3ef7d00781aebd4f9f5fe64ed6fd714dfc04533edf91f81ee7ae4c5a6cae58d2658703a34543980f834f2a47ea9b01c3358876c4b95172c35bccb27646fe541bd149c424220204ec1d7b45baec16d9b46caed536e603ffdae8cd1840a84a52062073f8d465b5ba818e0b16bdbf09f3bb6f49bb5a526347d795426d1c8c8c5a3e290afeacd3824e897ba22121f76899068afc474adae15fc48e1721c47d53529716d0fa78b85bef3ab980f4b4c54573eacc224a5194705fff2eae30ad151ab11bc955a38c779633e391f2e830fe217d12c44130d8aa7f622e12ba896d491418e1adf5b68b833605728317228f5146893945ea66241a73cf04793c78bfeebda50318022e2cfa13dd29803b68c0b0a942912fb76cbae724a24db9e46e84ced4cba2ea445877d7428ebd1ecd1993a33a6e921086b8651afec1aee7da3dfdf9edf6b85ec1a56d5e2eef39d9dbb8a8284d66d5d2ab9080be79b8a216491618b6a4f8e637a59978174fb107f0c20725aee4ee2408d6ffe1c50ec1b6c9a677c44d06c1d25bb2f2c4656f760832c384fdaff6cc3d99358c08602be78ff1f0b864a6d1ed7cf9be1525d920b0c8f3e61f59fd99d826109b4e07c8d65f61069f68df957bc1851530867ac43401e9db476b3e8a27c1a4c8569a0144ae3b0eee836c7ce153767711ea8a9d5e57a5358eb38531321ba63780a7b4a1ae48579093488b46027a1d8894575031cff4037317a79f276961ace4816c337b597df7c8d6d88a2b1fc568c207898f04a0a7599bacd6dc36187bc923d3b0e46713e89ec777b2d8a559c64219df978d80608eb9a5b0645f3281b7e0f0c479edf37e45b01aa436fea1f045e758d0cacb1e298479f894b42cf2c977a49cd06d4a695d3369e762aeaafdd856612a68398d75f89b09bb87663e03bee28efe2c13254649fc446da5358087d60149b2b1656f24a99c695a5e0c5fcd6d86986a95da66a88e233c0d7b0027a3861b740208fbf7c618dfde8a97ed4d5b4519c5198817f6bddac4e1097b60f1fc9e06ef3cd2b3c1a4b0f1de04816ecac6e8074ef924dadf7c193c73be75ab1546f790111732cc887c5a22d200dc993e1dfbb57039161db290196b4a324f676a392972a9b4bfb2a31b88218226f1a64ce48b6ad8e04d918eaa9312da627fe7d4bf1242af72b8c3bf95918710448bf37d48661b61d535f9623a61fdc199351443c6820682a65d8020c6d0f31925d4de6a9300eb74ba82b02e32ce2dfeec89410b4f1d19e6084ebd7c98930b5f5e071ec2e25ed6f46cc7dcf875b44fbf3f749e1e5d4518bcc94692afce2ce6a3a7dcbfb68688897a98132a03b04066b091e18d7f86e3169d4df63eb4b60b4a76782c21f88844a86168a4707522d738ffdc72896679351904af3d5428ed79c67e8db374370c43780bf0657d81fe1633c0cf861f30e4e70351183be368159061a5e738ba03b1ada9f45df0ae1a7489da313afa8e91c1db51567c645162ab48d3ec5661a76175ed55defa3b95e3923153ea0c10c19145328993b8d9165223c78fcc22bf4874359a6bb66715f06783710acd40ec2ee7a1a8f9795f9317c8993a0bb3285f4776b5844bfb19ef6bcdae3c28d249f742323a9ef9c3e2d0fe24e7a3e2307ff309e6b28051c7cee9a120671bb5dee61f5789a79e536f80265b2801350d01db7c71821b1be5db36c4c0008875395f385a5af872328ad65d8d498d14186b62fd7d6ca2255478faa949601f8074624a0ef37a90fc1f8913a4359b845c2ba8aa1451b90c665ebb2bb846dbf0954addd5a0ff5c7c9533baa423b7c4613de08a18f994d100349c3f40f0d2184fb0a3398f7d78e73b41d23e1c3e8a257df076d18c6d2dfa13e36693e1d266b91671c43bba2ce1ff8a8d1a9029b16a4bb1d94bc00124c1fd8def05a326be00493f97f1bae225eb2a33020e19c7274b40b541f27d14e1e7bb54cf02744921e0d181844763340ba9d3428918a979df6a0cd709cb13c2b07f34e1b57a1a87202ab361cff5f3e1e2b065d99e9bf200ed0c5a509c409d72da0278bb569cd1904f057ff0f952e530c35fa94e0cdb4ee70687006e3e71f359e9117bc891d2eece1a4bad4f04d68b5a44e52c2cc78d24c6435dede735eae8d973db420e9bb1169a330020b6ee84dec8b991719b1c5a99bc9acaa81ecef7031aa00840c069ade2e42a566eb31e5dea1497071d06ce101e746b4fc820b98d5ff17ee5b738822a152ea56ae3ee61b26e569ea539f8e1be0270dc56f9e0def36fd26cb8dac16479513111516de7f4611fb7615cf305fe7fa38d1f1e7bf8494baa811bfd8799d198b328d5569b5ddaf197b080c846dbed0dc761ab78f1cf4e37199fa622f79d4aa2d41995a6df1c312213e5d9dc5d8d68e872dee93622e26beb4cfefc72448cee4e07c3f8af834d59990261e09f35f028cf2645dbc3eb420c15a3c5378d58a40cf542ab8f3411f6919925e3856cb6f6cbfbe644b69bb2b75144fe2eda2aad5a512a86038e84975dbcb42d5b01f7ac4f5e17b3005ef39919547de43a616d87057a45a4e9ede46378270c343aa8f0030d2b63a124f52cf866df86f9718d36e9e37f0e967cad792c4e11ed1e3111716dea7c9392635261122f0b6d0526b83c92165d5862b5c61c62d5a0e6768f376fa651c322106274574b1d8b10db9c59e0f5b294dcdb9ed185dec4bf7e2871382a742d9dd8da28fd500c04f4b997597ab6c84c9e49d062dc226e579b744bd3be5c61d6fd1fee70f8c54a84c9ab1feef6a9a748c7a382fe4a628928daefce6a80fe0c9494d106bf82a83df936d6aa9d776f80d90ef07f90ab628f5025e9d81ba5cbf76c9d9812046b8aa19c185ff3cbbc134dc32f76b3f416f5cf1b0f0a2a3e6f373cd00baabd73eafc8cdeb2b275ecf5c9e555fa0817dd1510c82827f51cbd2f850013a7825fd9c4a59abd926732d2d84b38f9cba71713768b288ee5f6b792616ebc4514524fd842255f5811b1aa1719e2c1a1ea572b165531b2f144fb8b3a56ce8ae112b2d67025bb317835d85690e5baff6ef41bd9654587fd785a8da9aeec0d07395514456ba89a683e90285e22fb6b6b3f63b321cddafad784fe88a9617cdc713a0e59931b2c30bd49a2edb20db573bc04628c25048ae9419c61ed2d030ea865ed82047e66d42348a1c82034f54c358545f9e30aec2e1dbae4107bca162d7d9eef24361d653e2b0ec55a9fcd5800fa456aba5ca2716b502340b956404da5feed90e8d03c35b329850d1d7fa16fda12a99d73c2ce4cf35d5f295797b581312a7fd0d9e269a1504dd1b415a6bb92e8bfaec4cd686d79de5c53e997d43aaeb159f6b90726fd90e15e5e47142b1b68a536e6a7115f471a002e62bbe01ebff0ce77f0a69c59999b9c19d5dbef01c2bd19d037672ffc2506745bff618a9e95ae3387f217d6e32d4a3efc88a475d3468b686b25399faa98e710d4e8f05c239a26401d7eb6db829a18a30d3b1dab12079931c0e556fb3824e882997053587a84b2d92c6d6f2b8544d30bbb684f8d3d7840b1fe7b72be785c0d646c3e75e91b60a2680af6f39171c76c63502917ff8b181f183b5c9d75fd720e29c9ec4119235b03233e63a9e8f9c546b5befecf7849a63b59a362062ab4f3fc3acc42055dbb33565f8d6b99741b733b05e4c8b99d24f4b8bfda6cb1e61821a58dc9206132deee1ce3f25e65a6df2b6263dec89fc1ecdfe7d08121386071d9cd613ae70dbf448615396e58d0d577752658e7df5c3def057c353e6a7c1911969148c69245bbc0d12f21619bbb243fb94bc1f90bc65154174630982f7910375a36420372b59e9feda5c3ec0ec1067825498f45a80c602893bcfb349c931e98517c89b28470c96def0cf7f353063bb277cac9d6d157e6ec68ffee1eded35bc3a5e869e35794c58a6388ae18c11a060df28e0404cef337247ee19b3fed5320422851d8cad496c97b5a438133b98c81366325121978cc682dcbb84a015945e656d73b0af79d51cb7e3d318aa923c23f2903a07568a76292b24893767d114c98d49e288e56c9a991988ccfcef3419b53476fffa1a3daffbd88e6137677e10128c207bbcdff3af01dea1af581363c4514c006cf10166fb6a633134aed16ecfbed6cda4c14757fc277a076fa71041ddff151ee36d9cc6565eee56eb65fdb893c0f640a21ad057b197110007381e627d359b8762fedbb8b18aee10868cc45a414aae73d723cd95705933bc791c613705fcbaf7be88a051b57364cda02c84721546398e5ee223b7b09ff3eb019b1d81bf19412d65b7f5b95b2f09163bef5c26dfc27141874e9a049db0897db19a3ce3dc4f86b4a994ab32796937acf518d7ebbfe8b069dd49991dda6a5b8fccb749fc99c0b79ea60a654cbb3735d857f82d539abb9ecf310b311a472ef8cf36da675b027a54dfe286d8e5194b3c8ab9b51074da8865720ba2d1450bdf382e7447a0fd30e4ac0f0a7b548b37aa7dab6a69a9626845e8d96db642ab2b58056939c82ba8feebc424137ec75d79748a11f16e49a7f6c579b7f639ec762c58b56b16d03dc101fae921b9bdf1522ca3e7e122eeea7bdd660d0539dbd9c54a838f7501209089d23003c0da898c20251993032d19811810cb526f0f6abe05ec02a12ab4125f0b2e23a3a2fbcd8c3c79cb7fc0d565140bc207f114f49a8f4b909c6031681ce0c04be9fcb21210668d05a9e9bfe77e9c097bc9513d2a8b2fa51bfefee5181cd90aed8f360ed33fdeb93bd48044cb0283494f4c601d218f9ebb6fa21e00afc02100ab50cce9b6faa75614cc8de5f47c6ad8cfb6d880dad7c4e98c68c86c5761657c554d74a81b56b7c8e119cfafac71516f1a664715425e3e821cb10ce4a6e973d2e6d8ebc50269e1b3b7ea86d6dd8c98e84f11847c910a81fab9583fbbc77fc71e4604aa1bf3f60115ca4bb35df1107bd26d0c1d31230a0da8c3aa29401f4911d6b43213dca70c487b56f0de4117720b024a12c0a767bc533507acefce3a047cec7349c0fbb1d8d23b085e0fe3ff92351bc3fb0e8d1c3b8c9e158ba6f553c2fe4de12c8617924e0acd53b4f5d33e1e99e9233844c3c87e198f1e0ef06a40ebc6d88a83e99bef48cc204fe2b1a2dfd3be8316922a9aae2a48db05c2321a3716f454b2c13843172d9e4b1d38a076f7c9901231b9607afd0add86cda05c141c3781474ba9ebbdf5364e3b0d33d60460c6b4eb35a44338fdb502d38e7fb75aae21b70d88a6cd1a04d4e8dedc1d8e7bd676e7dbb5a67c845d6ef00e4e846184b8656e7f9a1a70b47c98956e66d40eb64ec46c9f471dc3475f899ce46ae1903ed449c9bef4d76a261534dc42bc7fa48552aa092505362e04f4fe6ccef29816e95a6d13b2b71d0bc138e3cbf4916e9311427e7e2804a38f484d724efb951a2a7eab07d77a4683074724d923fd64e89507361a3889741586b4683bf490a6aff992235140c71eef351df92bde73af95a22ca220cb58dc4005882be5b1c8613e8e446f53216014e26eca4b18745d32f4743ea715e292dc91a3b947d6e40456a1755a3397bb80dd8d2c7ecfa416bafd6f3b3488907d2cbbb3f5547d979013debb073d068bfdb336e86ff843dc6008d620c5e76b822e3a9a6562f1ab331b6aa7b50435f4952a39400717bbb2444abe420039056da3dd07b0310c26f3fb6932aa2bf408d94714c658fb57b1096ad43853b5771e75f92c8b555ba001a858a2bb12ab98a7546eb80689a53912f98139a0486745f16733c22a10084ce974be4b7c509f200f822ba2ec446249dfdd0ac08bd5d2521492d8cc3aa8cebd76b4d079df0a3d5448c09ddd105422ce373bba971d67b48b15b432125a738c4be530ec2c5a9e94214046b2387bd59c130029358877798a070f4f5ad13d9c2a85bb9cef3d6b7356097da182ab07e63660957c84402dd3ad46de5e8d785aa933e09fa31749b4dd010e88606fd684b8a80f196539e2ebede82c71c7c7ea50114300013eb55aea946a56ae4d6b8da7d7880bdc11b10a51c503e0fbdea2df19d8c23f041f15500f3d3b15e8b9c7bd9c737702a5ff1878cb84991831cdba501a41140c14c161b751eb30ecc7edb00584930cb2d6e3a431bfb52ea83938cb298a10c2122b72084d24d775c71bbfec7e92c7a70662c7d08b0411bf18b5df312af2e225c1447165c19f00e1c8b8a0073a9f9217da5070adefa89a5e257291c01ac8802d4fab39d243005390ccadfbf91ad79f3bc9681090c4f59a89aedf45a77825f95e2c889e86fa11ddc6778b5bd41bd093fe807d5c2355ef7bd8635550d94c284d08897b31d3d944540b3e97477925324276edff0db097304738cada4c3f7643c608315ca1a2827a7d076e89fd82ae0418c56b1843d7c8780a47f0ef7082b3a98d157d2c612d5008d1694e3a01f21d0e8df40b64831fe8a7355501226b8dd887e847994d86ee09484fa7ec00ef70a46d52fa22551a7f90a950f289721cb8c16b13c25f963690af937094be137d99fd4ee74478c38eb9c5bd5d0fe4f8a986500ca225faf76e2eca688eebd6eb10481ec5d56faa17064c2f6a3c3da65337862f6c1b22849b164ec522eb150c0cd7d2f3aff07144cdc2441932addb7b93d62d6edf33b28279f0311ffcb6e44888255098374b697d6c099359aecc21bc4a0eac781f498d11146f226e553fb046e8b1be95732a26a6a4e5c169f54040d44a32645b8cc4aa4138bbb1a17e234d788330faad7e8a9da6867ad02f38df44e18177384c2dabf3d1e47365c3d4ee4afb62bb5936be01b752aa2dda29ae2e79e2570812892bd3574503c064f98ff4370f0e7e21c7b11743d76d5702ee7277059767d739b7a2c60c689040187257ee4ffee43c70b96af0525d59cab9eae52a9bc45770b9014ff1abf0947639324fd862172258a253b26698aa57d0992e4dae7a3d9bd1118c9db797993b4213adc4fb9169fbc860b5422bf0edc841c147696a2129dd23a19f2b6e5f56c4253b9515aa219c8ff8879b8f1cdb5bfee2635b0d664585d8905902fd0f531e57c0bd7f6f6c6cb2ee5b00ca9f2a50cf4a0c0b3adcd6c98846575637f428fe1a89787ae9efb2fd1e00d2e9f325626ce94dd5181b99a975d25b2316c7803dbb57f1497b208d730d51fe6e71e5988a9e3772b7bc24191e8e573d7d3aacf97c04fb10e86e12aa1d0804a7f450ee56e6bafd2f4bc8270566280a3e698d84823da0f8b32ac790710c2a4e4f73d0e5529da2986f3610148404c98a3bb1c3375f51f0919cb21a02357532e8b70b99c035b29ee951388280195c3647f2f05ce08a55a3b97e79581f6971ee38dc5416eaf59002d0093be1a5593ecd97fa295d46ca6837613bae16210a6d725d74acfd68cb75854fe84736fd7383a31d78c4cdb9591cb228a993c6f214b20c99c5e0c41960f8c16617c3f57f527f62c3094b2355c6258f0eda0ac26907801d4e3932cb334aba85bbef7d146f40783cfbc59f3536137ad0243c5ea5de38d92157e73cad657867fd4c68d0cd6255bc50165523de2b566a40e526c36276b7eaf2e7d498ab97c7be99ab8466abfbb0b1e9afeff839d15fe28cf04c67487c11af72276d39bef8321252e2006b1bc7347d4171382cf404548af19f57007bae7fee10e64f20d571ae89c79fb79e22ea83214824b4c97bcaec2b79e3bc733088378f4da6231b7e9b20c4189e6ba221a6825cead5e09eb73d7709b2cc335a8437c764d8b24c62a3e51f0356163695f2ba2794b26a2e80afeb8840f05341a19130e595bb0fa0e2f30761e8c6a801109d276d0f0a8c2023f90b34f525b2a87205123c017cda427d5eaf1f0daa930bec6acaa9d0861b644497076302f7287b5edfbde6c1b142f08e1b18db0da18cc4934d20e5d1419be1ef937e289d20aead5f37d077248df7f232e692227f3d1c40d4797ed79e022f96ab972c0ef2552650e56b36604ec6fc86eb562bbdf078b25147447c3cff17b0d0feee82abe85b1b76a683d33ffc88d2017acea98d21ea2ae0e56fb1a815ad26557cf8540362dc6a31f91ddc0d8ac84f25da1a91df8ddd8603a9725a9bb72554f815a60af20d7217e3b1108170482f02fba9b54c110fb2b279c39401754f8cf2ef4158d6ec5576ae2061274a9b82ef7b6f7b6be1883c56a1f6acb278a5a05b5d6ff9f321b9ad1c4f9345a8cd00552b96609cbf66b38662eb7a2cd9002a17279ee4610c68d5ecb1688981fee94933ed590c5eabbe32faadecbdf4b4af223e239fddb4f6b65c45d0b147be1074e680186b2dddfad5f871012d0bc6c95bc32901bf007f97ea98254df74e8aeaaaf9fcc099ffe737c390618fb4178eea3294aa3ce620a7f44b45421cb26f75594e276a64286ae402848952c4c7e32eef986333a91499740569f176f6fc2670c55f7c027a87709f580dfcc4c57bd3670ee524987ea09882194ee4b6fe21547fd3f6cf2e8d159060d62478507bd2139220add71d57b2b5b8f6c0b49373e8b5a57b056cf6a53f6a5fd7983c5c8c97ef7ca4479b787c447ddcc026faf66f8fdb8dac8bc833f6c226e8cf3189e850827612e897b271775eec098375da7b9dc04caed230d19b57ab72451ee43e19e66ed35f70eecaaec023db70387e427a7cf57b90bb039d0549b0c12b997afa24522d4e05665ce53be9ca964d45cef0e385ae4c2444cf7f4391d94695de6da67a8b3143ed293fb41d8f05faf7f6ea453156fe406671736c734be7c0ffee1159ad131063ec551df22e534df1a7723d4634ca9f41946988649015c51d42a2b92035e9dd379ed4e758f858d72adbc1fd3361d74ca81d47f4a11327d64f23dffa784517b4e12a0389b7bde0fb322a5be801f8009fc0b134a8a3bb52a9b29ed2cc768742c5d6ece6abe227c31a8c98e30e5c681d4ed25d7ac833d710a8fb98318ba2260d94cb75b0d59966a7e800ccf41b1ead82db8f2ed8d0ae03964b2f62d834ad37548be82587c78baa988747c8b0155719cdc85d236250bf047897611148f95978eb474dce176e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
