<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"adb66a959a71e0b5f3a0e01aba12b046232674ae0a46f73d5b172a93f1fd304f83dfbdce40d492f120f63987ed64e46f39c8d4cc7f8c3b6f61fa4c1a629d4732db2b7c7e5f40946d1f705fa8ca114e5462303ff4b82876a07c18fc369af7f546d628440878021e4243c993069eb492d0e4d67bd37172a4a14383d9ef7b28b348656d9b1f0a34d1f380515deac2a308b6d25dbace0ba72804e4225797f80c992e38c0727a7a1e94e714f3e77a507f526441ecd9e0bf436ed827553845f0a6176cbd89a06ea7dcda5d094322ec97795d9c50171c288ac8e94c6b228de524bb588e9500224d78434f487bc7b0085bc92186415fcd562653ca03bb2c11edbe991d9961ec8580f7f82b4ceff2bf1fd0170fd30310e7a1910a0ab5c0444a5950718381a6f44f63e4000814bd600012ad9af6861986cb036689b7bd700636943373e62709e6112d51b701c8b617c140692a98271647868d23f3bdd7a3fd160663e3d94260e9653072009fd4bdbf9117a2841363081e96d034c5e60725b53886897242fdef7f6b1d3af08f33abd39978680ca9c228b7a9c37dd1e969d49657dd4c1f99ea46acd89b270197aa4aca4ae5ec9cd868766469894cc001639941d25e05d96274436fa2b66bacfe458cbb99f68c7fe4eda6c15d012c53f40d314fa85520edebcb8dd2432c402a7cd83764f851e20d5c185b0ea8a3ff2ee0b1fbdd1f31c4006ae2ba001b5771a9c809cd3af4df2952e200c68a9f14b195a9a96cd7de2123dbd6c6b6e2c73e73127a72bac7882a4d7f53c84b412d1aa1d3391e2361cbb9e4072bc0964ba47059bea0057761815538f4e0e1c71adabbfa01e6fe1ef185531c74d61698c997c93d7720f8bbe029c4073af20040144ecb1326d36c9cf238bd34a045bdf7b2fa95b5daf233cf7f1baff95d4f41fcebea70e25b7acd780d5df728be023bdd2a4aacb76e1e02fd84ada97e1f3090bffe97964c364f978a1ede2702478bcd1933482743906a9b55f5cf2a0796b6788527c7fff447cece5695a0c79751178e85c8d16daa3a1c5033383140c67248ec225f07595c53f7f33780b12944d05939a52cc28822e3f6ff0c66fa45692a7fdf778ca12ae8bf5f8059ca019004ec2bf30c81eeef6e8fac83d13b0d1990de5d6bf45102ad53c2cafc6096a45d3452af45456b12f66d4a0e00e04d3d1d2e090bc168b9d862f52beddae463b3da269bf36d173b827a2e418e903996503ddf48a96d8e3ea2165bdda19089ef8c4d6652effb41902cccaccf3a7babd241a7a3b4ad69185aa2d322eae5cbf42f34c7e64d0101a1a5dfc136637e192fa5ff4b8c0d28d76a35520d4f1743100725a42502b24545066e6045bce55c4c9ee39b3c71979c5c3525dadd551fb62d01b5ea60f91bb289c68bb26e5996d00cd9b38ecfe9ee407aca6d304294eda06bbb685429f5d8c57f541b1607dc0518bf6266a88a69d25c4d3effad249620c76e23aa167018ddd6c272ed88456f2b7030b7bc01f4ab77ec301b02be25fafdaaead47f4dad7c3f516d337b86e3d95d076c4fe63e40b854cc47caf552b64b5ce967bc65f06daa5c0f0886cf0dc8b393b1a2c52c7fb355d110b97c99b59c517f98528d59404f3d24a61226bf917b20bb619165cd6453e6a9598ace0af00199c5dce6702475e49d502cb6e17fe8026ddd6d730f823bad83630db2b1ac253acf063a55e31b42c7541d275f32cf13b338cb9eef7bb0df77d2795427b27b7e582a307c5525f676bdeb966f3f5d1b994eb1187d645c00502f963a2043b2672b24dd114a45b6dc5f196825dc1b5f6b23c2818006453c34cc0c2db07a68cce4dfa5cb430d8297189e2edf49aa278b7aefd86064eddde9f7bf7d0d588ab0d7ac8eed52511702726f7e10cca5dcf85d915e6f20c7af1f6524d5f42e0790111ed0ad8f924e7b50ee887bc7ee63d5204d273acb36950bbe9e6fef1eca6c778b7339b55694f444658d8c17f4e5923e908d03a06f7d2b2e645fd7f400f7ee7f3d4e9b255ac017bc613471e48785afe90264bd559f434c34881e87cce481b153aaf272f82c53287e660a4b1a513c09ac79f545d7b12196635a131cb9cf1950d02043c5634bdbebc26171fd7ed5ec637f31bf0ed665c89fafc03b568001706bfe555cc436b03fb95165c5b9ede8f60b7a2c8fd37dd3b6c702fda4cfad7e58aaf8a68e934d4832d2f90a3ea8b47d207c158ed862f37cea72d93fb55d23549ecf87dc1a92958f0b57572c10c29041c541d1f11295016420cb369efa1d1ca0479a0a2f7a90602f5f2318a473ec67a6840b270a4234e33c229d3894ff8e4066793e4514cd241b15156f09b24f41ff30c0b1d79fdb621deeac01e37719836ddf6cbef8d642136615d732d1f77fd5e771f1ed49c31c0ca3b1cc80720b1c152c79a8cf4d1689d54d5a6103bebd3ea0f9ba911c1143a13f925f61d73fe5bc82bb193a61803f97649d2c6f084f2d84467fdf5d41c9b1cec0dd784bf54e3d3bd5597ab62714a1a0e0f5a7d78cb0268e63cef200c728eac496e67922e38ad0808ad865362ef7379c010c5cc93e961b7c44a79ebb153a112c858abfe16e0755491592c55e04a9548ec6eb139d4914f6e8beec92d5ed57be428d7ea0db12ccb9f8068adbbfcc2ab054ef7534b06ff49296a639c84f15b98b06b301e7bcb355e837b383f66ea0985dd303fe409c68ba7316043768885c72fec3975414eba32b40e8b112f3f8e8b8a96c21d247e351ed46f0c9c2d1d79d69d911686b8d4de7631d2d6df30ae0c25b4425bd7b3db33b3f7de38b35f15a6c689e834c8b986c32671f23441099d15c2dab9d09e9708bce797263823ebf1cf3828860c5e4579399b6106821370da51397d98c851b70b84a567063ace9ef511320f775583054c41280a0fe921d320ef1807843e890d059ea886ffce8a4416fa8c61030b9a8369dd235b4b2ab52e75cef0a9082f936362f9fed434087f052b7857f392ee7df7e2fe8128b8bc36bd0351ecac3dd6cc9c62800ab8c7a6dbbfd37a0b786edd707797a39138d73dd1e83b5ad3aff1b6e0456a51b354ed46913f552432174455cec64885212619f2c8d076364b0facfc4df21a821d98d28cf616121132166aad5c07f07b6e493d9914fab3a9aeaaf31056b2dbae522a44d3916882a25d6e88223a9b74d36e7935f030f9bbf4c0b156b2ee15ab305e128597b0d6d70ac87cf34eeff7e46c9121aa775e29193750cacfd3484b640ccdb13093b6fb310c84dd71c1296bcf5cfb4c9b2b378d0150f2c33a6ad4efd1b4ae2982473cd6e4297ff03b8b3e366e8e1abab7283cf8ee1fe35602edf2c946be0e8eef94b48d29fdf595f0290daf5bec3fb69269842a5cde789630288c9b9353b0998616caba4be1ef92bc86f17102b6f46e864738e7d96d33e3f52b4466866267130bf09f3a620c966dd8c766841c26dd20285ed880d5bae6903543a231e40d2bc9b4324b9c800e762628031ff5a0df188397b7608a839da7d1a6befa20c7a2179a9c00eb129670a7f787cf0aa3a39096fce9cff41e3723d956a94e63866f03d86c8213bdb458cb3329a1aa9e2d5bf7d33324ed615d4dcd3f1050d26686ee7db7b030c632154131358db0e453bc972b5114d25e42690c268ffe07835f21b47771a4ff910d56f975a4c3ca51c3925716b26b19a4f456c8ca6fa748e49f8e11b420645003953582fb4f1d7507bdd72e70bb00d3d35c4457d701a8394614e68d1ea8484ba5d1f5123ec64e479fd7c615fb7842fdd4ccc4910d3aa84eeb3456f2739b9062246e9dc0a98419ab18724ff6be07e786633de60ce734c7fbcdb948b47264d0c7042d95aeb7f58955904a007254cfe8fdfb150ab2fb0e6c47f2c9ef5a1816e593c3992f94585b12e6d0d7dc3f80a29d95e3b1a84748286046a60670ee404b0396befe042e7aa576af8dfa95a4ac1dc0e31105273cb6d9434702daad8c63f183d9d6e0f9b98342ec122aa489552466cbff9f4c43ae26eefeb52ea3dd235fe846f69091773ccc1bf4cb1c13a2b8fcc4794821597f1902e4eb840d1e26eb7f26784294946700a5ab50ec9887221ed0954a2d0886a8d916149f3e5c49c00aeb7b7425b34d022e9a5a6758ed3d3c320fcf3783640df2ae5276cda865bc48bf131648523a1658ebd6402bb757a7f2af9525bf8ab607e4b6f6a6919e2b4a29ddfe92880c59d41c60d341623399ac9e943ff89eba5464ab2358c34ba66e4bd93bcedaa7249f81d7ae3673fb2568be31d5fbeb2ccc2b69d0a10027a2dc14c1639748548de75b3f9e8253ffce2e01e88a14f4f1c405bda7f9078302ae20bdeeec7cdd538a6b559d99e81c7f8a9ce529e491c131c42bcc2e1e6890ee50ca38ed31a7620e855e6146d9f2df9b7aa894aaa94445b10746fb11533ab5deb3dfc4eb5170dec0ec008be3d9672e22c088991b29521f73268de4643d6ec2470417934f10d9856c955a6c89453f22e61c86aa2d8e2b33948cebe7117d2db54a774a9dbb742c0edcc68f98dbb9987a16fb35970506b4f636b200a39de3f40a81607b20ce9de5f38f10f223370ad6b2dec76d694588192d7e3df2826e7da63c10ad865c4d5b9b05d480e4c23abf7f13c5166d5fce8c0cc2e0e61a3c7a0fb4fac36ea12c236024c20b6e29f55d6c3007fa830392a267378f4871545f55238976f070182356874c6ce408a0a45b79470fd69d7a1a25bf9dfb548e33d8e253b170df8940f38d69549ef75a7aaf12cbbd9bd3e6ccf8d9c82f315813fcdf659d2391712dbdd6615485e8d630c9dc2854b96507b7d0d5b221c377e6f693656027d77e981e8d147777419d0d6a417e9d64dd7d011f367ce92f179c35fca1765591061bfd9db93cbbc3b3afc9be25cc144f4fd1386db37bdee76b9dc31e7aacdf1538c520fe5428be3c00a1f90cff92f9271b989f26da2a61b18ac822cde282bbd5e15a178e504de110f9b782dabe429965c6ae16057de1680eddd5a5d3a3b95cbac2bfdc1710664f65f4a5fa447e7b9e081fa053cd38f8894068797b69b7300f3a00865fd6d92907a409ce25ec6bb70f85e86377aebae3d780b455c013d8edb8ac6a5095be38c2e0686078d8ec7d2f6f22a167745a2dfa8f22c5ba799d3c5443215683795cc98f65004e9f1d87500140ec0498875443346a51f2be18546bc0193e5c3acb0dc948f93de66ddf17437a43e2fa1b9372a599eb2b199d7c3490b6d5689450713021a552be33a0bfee14cea37dfd8253f8720c5e4ad37d7da8660689f0dfe35c58a478645961b251a0a3d8f2adb617248809a9f35a0fdbf906b229a6730a37ce207d75f3537f174968fc10e316b3063da6aac3a9f14ca2a94baa75fd08b2f8dc1ea25a78e4a293f4505953ce8cfae887979b7d00d16abe46de5a7f3b7291efa4b4e56d08e0d299cfb2a49796bc45ef6411566fba0147ef40d06194ea1997cd603f2ba7816b20796317ccf657fd9fbbc16895ef58982bb7ad1a21bf902a7dbfa2d05b5947d8f085ea581e5098298047b6a4ee045fc56c27761797124d109bb5a91fea735bd4688b308eecf70c44903d0d289751da6ab39582dc3462a2a899edc6ced552a45b262d33e4d91e043e344d7a180af99ecb66c80d08eb59e6d1364de1700da83fdcb356861752468a52b0cc7c4c07dae7b9571d5900cde622a9cf8edf1054d097d63716e26cc74a2932560f7c209308afb2fc27bdcceea06e3f8e80f5e971472810544478694887904d9113f0a65b1ecd43a6dd461782842ce622dc28a8bcd3e2321c6bf88d2cee07cdaa9521ee713cba611e740938c04c93ea33fc212312fff411c3ca3d3921a7dbdcfc58c536a4a7ef0d41f7d0b4e80af8714939d3aeb6d230376b3a8af14bafe6a503552b09103b0a4420fee87de332b5b4804b356457f5b3574c7bf834d64fe398d8103b527338b8b2e6919611b6e712a1241eef2764246f54b1fa8c17f3a07864dff4c3c17f721adef6ccf2fa32eebe22717e276174abcd229fea38d39b721767a7c0df9b8a7de6da70b165cc1b3f445c7a56c1eff6ec85364929e4941529664538ca3cd86fa9651e399c5b30fd069adaa484bf5ee8935d4f6a20c780919a3b7e241757cccf34d30c14fc2ac9b6a25b5a24cb221500e017fce8081addb8c3f5451c2723ebf6ab153ac399894ac4141d1b44a5c57194a05a1e284398fee3ce14b3ccee199902bc4c0c0160f791f08d6044bed8c5b7e1307b05309c5512d8ecb3f6eaefa1347c604b2a24f638bfd8150e06d2086fc32189a575943e40db2d32bb5eca09c254d50bdb25272b4fbcb505e504200d17ce67762e2378d07fd08c3efcb1d9d86397b3120fad19a1b0a0dcd32cd4db67013aea2764a27085117887dc1ee67710dd23f4ede2e7459ee44171e8422061cd572b18737399087a8761516321665a41e6bc13a3e2e0458659df020bcc5ab647358391b8ddc0a381da3ec1a993ab45e0b11f4200a36992e730e3334ed9a5b59f52fe01b85d5756463c5d987da292f38d1e0e1e61803c223511a7d660137304930f665e5185c8feb8f1c3fa07a8b1d4fa320e1be7ddf699908e4bcb986edaec7d193976c48fa2f54eeebce8075cb059212ea2a3aec246fb2c128eb3b1e047a4ce7e856dc98a1c1bb78ba6e176d3aaf6623e6e194745dfa6ae587339ff45a704ca89ab862f36beb4f8c41692f3ba3640084daa33b86e8a530915491c5d38393c66427098a549ca2486a727899af7811efc159a76d9490e11244c88f17c6ce1204236e66c4d04c444f56393ade12cc7095a20e24df722fb04e417ccd9a8c1328562e10bf320f1a28fca3be02011305a51c9b25afcb70825cf0c106ffb1e85109839f8ff480127fb415c730e54ec09778c1852456169e79c444820bdd579964c20f17236664f3413cdaacaed1baa84682ba523d1b6eb200209ca9697e5d41ba09ebb92963e080bb489939fb9a6b4572b68a9c98dac9aea70bd63cb6d3e3ce8df4b3ab7450cf72c0b34c596db6108be8facd293445056283bd59c563557b85cc70988d5ef69b23e23306b30a4e9e54fcf4e75dca4365e3f9011fc9bca3f208c8a0da6c6149398df2a39371987ccf615f81f32ccc320ce20ac267c0eb76b04e639805960925f4c8c7f41ae6c41a883138a202f82a1a65b3b220799f7fd81bca3636ccb2f3a178f94403e94232b1495d180add726c1280a8cac1c37c5ea126547dd6751c30e31debbeb5a951367f79451a098b9d29e627fd25137253604c984c7c68deceabc594fcde2b1d250d22ce14e5ad471b59f04048c66ee1018e791200aa59abd075081f30a0d9773cd33f355b4a529d1f7d849f3a010154b1fb680dd79a2af4e8e318b648b8d648854ead078d16b19ea4cde7de6a5734b1845cc0804acadf6e65b153ca533fbc75738de791e7bc7e028bece6a13561f7dc5051fe49ad95a133d6731befe041bdc467c140857b9abc484956b0e5ad8c7ea5cbef2db47a6932593681211aa40dd0b07af010176ead3975d48aa250ec9f7519bcdd51243107eb06562966210a6cae413df77e7a3f1712bc71bdf7feabc481cf00526d3f5cdf97f26ba090902e258e6c601427bb9859b54a489928eb04c24b19c3a899cc6ceb0d41b729bf54ca7139d9ccd8f723f24015ad4eb15b069b883f0de07a7152822130829fd6021dfa2c67eaca1e69250b571dea3ceb9f0c725933180742c84f107e072aac10b2ea92283811365acb9c00ba4480ee6e457c773f0c717ce9c8f2d76771f8ad47522a530d5f3e0d133d20b62ff4b035191cc99d3f9e491cfc8ad067a96526fec790daeb98f725190d50db6b75d202c42549341b6cf73994e27ebbcccfdde63ff4ad2ea43facc173ac97eb7ec7e184ba5e0a2f9dc55a1c51b4ebb14c4b65822fda1faf8448900f486b5a391bffd85b99323d8ce3f84015cb0bdb6db7d0aa8304662866b2349fa6373e309c53733d1b5cc815429c3ea0a990093605ff2cf87f48e50f1ad2301a4944a4f2ff2a871a3de6ab5aa79d342a80ec8334e3fb9be104e63dfcb3f5c7e7634d8b40a3bffb7f6c7bc369934aa128c30357ff1753229abd54d7ee9bc1c5d8774ecdabfcfbba6c619d78a0e0011125b83fb298d066971911e36c4f19439fc179380c9d4d4ef4f9f2f9278611c1cfb62ad2e85199a1314c820b0b1e1ed2814064904afab242c9a1b6e607cacc843b21459c6445c0f7e7b03159fd56a5970d51f9360b5d7c01c7757105ba1e49a0b353e1e26b95034b4664b50f531337a81982443ff45548d8ed2e4730406a342c15266b5321a0d45da5dc1dae81fcb8c99a16df6768ed1f6105e857edf7faf70074194e5610fd461d7cca20ba98583d61de97f58a718c7999f5f20d1b72cb1ec21c6bbc1e0a072171fc950a2d28894b3952ab381080a5ab61d815954a59c90b3cdcef664e022af4d83285e8d0de23d5681203af2df0dfe69b690264d9d791511dfc4e6ff3d0ec530e9bb02ae290473adb18936614536c292078d85fbad8a90e5c570c6b08098986726d5579b2d37b16d80756c2bf94a19820f13a2328b89d604e083f6defc3776eca835394d15da29e5944582d8076abeb268d72801106bb9141302ce8dee7b9b9ebc8e1a1b5d0ff8a848b7a7451ba5a1d23abd491e366dd077c52a2777f2f714cf51113aaec28575d4a7b1b2df6038bf2b047270dd3180ed67ffdf9671704eb197fedbfd59ef3337ac5f5355ca834a6b155025053d19cd6fbdea03548b7db467b065ca59c31a4c5fe27fad0ab0f73d8d4475c8347ef0bd4418e8df10ed57d302d7efdfefe44781bfea5864524ba98687242460edae7c57d80403c7e8246643f1097d63dac7eb86dc1126fe8237363ddec02b98ab511b68a358e57651f8474a2623a47829a26727fda0d83b630fb6d25c86446c6040a0c321b083fdda282a08349d048ef0f9096a5b52621a2e29d1149ad616c8f753828a97cb940bdf7d85407ae1b2ff32e40c653b6a5eb05288c867cfb6d04dc3177ad223d0c7a90bc23d88423b8bd52730e847f4b422aa32929e72a26c7cf93874462074442104eac7c1c3b6e0e136320bf33138173d20cb98e5c24ec855e0ae14bc24c4aa89663a73d0279f76e847ac79188e4124b2622a7ad8b6296b420c613231f13bb0c1162c30adcd08e66c18040b96af7bfb7f60b34ffddd9ffbb37dd53f0cb22c45deb2a5f95f8d1cc7edd700691b07154446a00901f4fab3e6967dfc0370fcd2c4d510d2d4dbb2562b992fcff1a093cc9dd61b7a0c79689051fb304d80e21281bc52e4a68411f23cacefd7608287d5e5167d7f87fb249a4a8e2022e95481845fd0416a29d081e98c10c74609d6e8b046b250de8190acb9f08664b83edc44f60d33f1360b327d8e09ad40290d44a63a2405626cd2c4993c86c6782d69151397a11883bba1582c1fe045a0ca4a224d6738468818608d1199195186699ae1f123a059d48d909b4de45ea4bf112c041a135e648490cde4e752d030877c4e0309279c6747a9168a06f11e9c0d58f3ea890265dc1fd03b298df9115ab80294568d2dcddfa6979ffa591ddae0bc00821e3a09338ffd3656e139217dc2674d511edfe988cd8b5fbed31875d6d8c3c65c78b935d13eabf82ede5b906d8a94510e3012b34e7790961a53b8b7a5ffa71da49b176b11c78f58ef243ce90fe065323b5cda2990b33fce1cbcbe4823614a0aab6e9ade7eaa7762b61ecac75faf4a59cdd66fe500c33e8b66995d43dc1aef6a934b09faceb0cb59a6091f52b6361bf4ba9f8632e54fcd6c556951bb6390eb8db425293a752713f6d40f0c20fe155249a6f3c0e6e51c9da421a8e8d7440e67c283d2046e9f05e15464f33ad36323a8d92c91b0fa27007e6a02c101ae0086976dcffeef3c4078f0da7ea1c54cca617fda6f1bb783ad04e151d84665ea345d47bf54b14e6bbfbd5f1a07c1cf0a3f167fcbcd5712675ccb681eb03d1c8b728600a141639bd00de64e0372fb702e750f0f4489d1ee00376316ac438ef0e9a1a905073dc8b072cce392153c17cdc7e2819e432539bd7437b7fcdd17fc74e6de2f51c94e175abcccdb153e0112b740aa90da557d4b2f9c0f2df0eb962d7d6c8f15a300613b1f29c101a9f67ada3b2c9e3db37f862c4fd8550b714545c380459c57af040763329442963dff1fcaab9c22de39c8b0b9e50c10428bf9e0767bdb7fb379767760704d9fdace86ea0300304947d09b51ff5e36077e04e433ff211f33173b9b81652395012198a10acbd6b4836482c51efe70bdfe9986bb1ad3a0e3c16612c139861d1b340279854cd8d676261edd4aebd1ce761f3c806b0bb3cc135fbda55e244bda25e096269ff98f994d8af5f112ef592d081718164231bd949878ce0b948c99901703f0ae3ef47ad3bbf82e8ab29f2960cc3f816ad69715f0aa35dceda3c2f49669b4e0959b2f0029c201e25c53c331fd14779398956162be7d9e6ba12a1c78af1207fade42ed36b5b469093569caef2a6e7c8c21f2690a2940a3aae3ee37abd79fea021bcdf9ba4dced448f4e2c9887f573efe33febd20cb7d7230d481366621b5828bf0dbdd790b97a1a9de534167961cf2bbd2f5dd3aa5369f6ab5df0f28edc89860235750ca8665e9cc36ad89374358ffa8d38cbb84f4940d9e30254054f670697faf3dd4c61f3e265e41406154c451689974419a30c2e0777db1c09d0eeb2c4d32b1430d426c759666663ff10551aed3a19506c62f97ad0d398cd3f1f9ae06441e4ba24e85d141ebfe9b2903f9dac4562197993e419a924f51b37ba0a10e373ec1b28068e111a7c420d3e768d48987ee8f9378ffedd1de855c60dddf1d93cbc03c04da5771c587d33b175f453db92b9ce279c7db3ab5d631d4eeed33860116685c0a71167cd6c67fec888c1f3c6af35cbf5513d136992b4323f2a49c256cc2892d4041e2ca1f07f5f812c732f35d41ba9612401915750e6b4695cd1316e8a1953ecde2b786b29f7c898a5a6d40b066d334760e098b3d4f9585f6b52ab9b4f9ef692ec91ddfe30f47d306b68549e0ce3abf44a79dd1d64cf1f55fc307fc85a227671af2d264161d6ae07fc8bb0710b4588826f1a2c23f0cc1e4d1c334a4bb13b088e273c8ec47fccd46006efb88cdde99dc1a15768a221d95e57b9ac694d4cf84211c5ac8ddf6f789628c9f926075bcee0d6453e04b485bea1730428d66219e06c799daf23848c9ace77c6a8da4061d611467d6c5e67c623a2b099d49f7d63865304edb6b2954b1669cd8acf30ef38b2d6b44806c9824f426dfd1bd2af1ebd958555b55d44d98d222e2fad66640b84017059393e4b45c00a235ebba4a9fb23cc83e722ede784f5af0cdefe54e4e551019ba51eb22486d5900cf7c79a2dc5d50134a3e14a0c4c4b07722a2934e93e57b5b110f223d717df4282042e73a9c3679793da12db43aebfab615ef45f1f4bdfa84d955f3fd2df6d45abebbcde1a065e19e7c9cc9b2c3437660ae977533c74399be7a2b9c272428b6baf18c0fe46ebe85259959ad725e583f35b27cf98e9acbd30af5e4fca6da9aa00505544688718d79d8f1d90f32d78e4ffaa89091dfa986d82b70e38e927e60ff9fbef4ab5f6ca1dda39ce1708688ed2ee5712d5de8231f229a6a843d7ae9511e2b0b2b9c714183a41e1884a5429069bd2207d352671aabce3d0f7a35e4a878f64eec1486130367141b5bc031158b16859a213c4e11493b62fc73e6a6cc48aa71f1d641ae483012e0951c2ce233809c0ec778ce0a870d2fed9b042c90265bf2d8a5aaf46ad095564cc0de4339659edc5731165d109a7d7b6c3af389feaee1deeea2f8d100329195d2265f2b255fbdc591c113ee3d7e70a26c7eda435af1516924801b2aee41789093631408c7c30c0275005a932e48394a6049077e378c4687ef98db5a3697a233458442f7fe361924d14c0a95eb917f0ef1e410c2ebdc7373e916c8f25a601a1dd83f5369f167f906f93a5027278233c1599dd7552e320361717b9cdb0794d0830cbd16c80239f8c18eec9720f9b6050ded9666c518daaf23dc0736da85cd674c05e01cba1325ed48873fed0e66596a95a101da88b7aea63e7656165c492914ace244443b358ca7bae99c713daf2a989cdef3e504194bf38afda885be55c50e23c2345c778f1705ce612b3bc07d106811d64c3529f1ccd27ed937bb05bd6e84291a86fc474dba7566617ae8c8899b8b2ea44eab41f35f5c561732730f0d6df3b0091474ff3270ae69ca1026ac436f5fbd673c7ef41e6363a7a12e342ec5bd1bdcc10082602d1c331105565a85df96b611fca34e91ad88639492f5cd945fe7cbe00312f4b7b2cfd6b0cbf8c69fdd6830b874a1ed919fc5ca80c3baa3e2294789f889ce0056b71bdcc3ff96011560e720fcf7056889e0412a03054b75e856c2bd750c4d9bb4ee14c194f29add5fb7215c933353bba953df67d8c591f7610446d9f296b09aa1384547d79330b3d5614883028357eeb95c67c6630af415b03ef6bffc93e341fd00253dd673db8560faa2372b3ed1ae4cbd4ecf78902b5f1af4269de9e69352284744580c5ee8bcb19e604a467dce1fe50672e575a2531a643f3b2c261c54419f2f33d3ee022df3459e85eb68e46e36170c3b2d38d735d658259758dd4d867d257eba7483f57a1f0b269d7f0cc7bc2be0af249dbb784d299384cab5c8d6686b3b9337a9f3d0ed7827fe4f38513046676bcd080d240d986a14feefd95940995ca09253b23ac41ede2148b16dea1803ab7d704ba83b3ef3ed152b403c3779e54f6802ecc5ae2dcfb2a566a96f07177748a1192a74344e1d38d895168e7f40fc1d1ab9538ef6b22f4f03642c5d97f9d382243c05495c61ade47f0fe8872975cd5b87039b2b7e57da1f360e63e5f05608906c3f6a4e7a50fb9eb081afe96ac61af0ff3dd2310ed2471fb7f13261ba072d8c93bf617c0c8c9e0adcc6c93c5503790bd82a36c2a3c2cc0ce73f07a08ab388bd4e753ffcb248f8274c364926407e2b0e8155bd60e74d4f0737ece6bf1f6342cc69cc870ecbd09e587b1f3cb3f413610bdefe08b8ab28146ce551a9327b47c7cc9b0a8150ff1e60130d5769f2ba4785d74c1cb34bc188739733219b1ea06c01b3d3c0ee0a443dc2bb2fe431e36e52afdcdc0a7117b696252679fb6abb4a20415359dfa955f6f992c8960b7c381bd594fdeb1660949b681c4892ec044b01f209b42a0ec0f4ffada4c02e83cbd02330d4f8685812c0b819c9183acb66642cf688b8707c09accb47b74cda671e02e75826456778e701352266047fbe47416daede6c2ff46968cf24b8b096d383dd57f38db0010d1cb1d5b16c5faddda63d8156ef33373d3af07d22e4654e76dc51344459f806e1f05ac6afc9bcd2c66d10490df986912ba2ace22aa933d4a66b5911cd831028035634147d19c0d36de18a93fe0d0c0f2b1013024f274aa44b8020173d6b0ecbe9af47aa217df70c9561384960e829d19a378d5c5bda74746cf8ccb07feafe2ca50527c457ea546016ea6261077b90ca20fe88101d0ba83a84df415be0f9c22b20206bd0d605c2f0d793df4b6fb18e388f604861d6d09ff145886792e2ea40db47f0e9ab498dee36451f5c930f34a0acf972ea516bf89e6842bf231fc0c4570cdd34be8bdf75c41244c95411386433260661c5c97686fc52802abbf8a5c7ae2053b29dce6c3a52ea62dab60977a5ac8167cb97f728cdb8fa07942fc4159c519787e923f0f08e95f4de66e048347639c8e5ac028def4b35e847c1c7194897e7aaae656e72806acf38a840dae7651753e8f470d3dbabad66fd6ee679e3bb8251a732461f424691ab54d39494316eef518ce1a74f57fdac78bc9782fd8046e46d50c8f3258f6f84d0e6e06402ea8f83830ecb47cd049ec5a55d5122c8c4f814a901280d525b0f7046a117ea9f4221fcf0194032f3dd3ef50c6c0092a4b7301bfc16784b504f4121818362e047a88f10e55d9d3291970116e3fb323beb861b65b6d363499cb89fe97391e6530cdba40e24bbd9fac79344fff96a80d126894bfc2ceb3c91dec4ec83652f149da82879140cb08427970c363b48bad35dfd831540193d95387d761943600aa2df3f47140311d0eea36a78ee9832d35e5ba6d2f7f849c112b42d512c59176cb65b1a5445f7f2d2b40066614dfa3f30c66ce1ae13c96f69129fc7bc679d05b160f7d82ae9f9149c1be3cb2a72effc33531830173d8a9bb762b7f8bb3b15afc43b884c7bf2ed7d4c9696b82c6483d2d34ddd34b8aa684650e1b79e796714b4fddaf13946b6abd9cdb4a2d1e22ad0dce32ab664c4b2fbe4d93ef3f349fe940f91a11da6627d0e85c5ded9a5f47dbf14d0ea9a78a8be94446959e0b4e490e5e71aeb20f70e2daeb6797db305252b5fec96d0f738f0b5b68b26926d1d09c29611b7dc30a845b3cfedcfadd8dcea2f19194c10185b2e3320dec9cce35de727bae5c4bb90a0b73e58ce4c826007c8afd6057de85af29b562794d35d70f114cf5e41eac120ba68b0a27c0c6db2e5f4827f35156c7afdb1033b30032f12e380d759471f4a2df1f8309bfa5bbfa888e03346868d396f4638e84d2d1d3bc429af8d41d0c46313ca9e9f8667e21444e9f6720211fffda35635759b605da222100cae374ad5f52855a7ac526da453797168e8d7116eaf672e427f89cc19e7cd1d1473ffede8d63406824d71f10ad2f8bb08679395fdbcc432a6f1bce069cabf3d9d38721fbe16ad4fbdfba90b446fe8849d955cc5ce97037552991e0bdf9fdcdbe1557c24b3953d1f9c8653413654ff2e6599944609018ad36f694b626200aafa1bc6c024a38ff94341ff781f7df1133bfb0dcead25a8855df78af810549bac3a87a04689f3a0bbf726a96c0fcb14f0c5c9ac269ffe423159fc183b1eb2334d66c1679f68044679496856bb57d9db634f230d61251483b6ddf9b71bfbbd219d683b67cc249302faf0f046a9b7fff70cdba78e8ef68cb9fcb9c1792c61da5dbdbc4476ef6a027d3e42f60826d7ee9f2d5ff731ec86411994e958b3b7fc07171f2c4873bb8583479a288c28931c6bf661fa269fbe819d3afd8e63ca0a2e38f62ea3d7228dc0e596915fcc2580cd9e7469bdd15338b5a8e9a56b430183c7c0718e822d45cd610eb22805c2578e886ca284c64c19fc61b5315d8d26c66dcb4433112600aa960fbb6cf1b515c9b560fe054b60f6e6ef7c4c60277ba75c76ae865a7cc204ede7b0dfebd9bd5e831a078d257247f88607722c7d758f87774b41448d1c514f56675be9ceffd44fca03bfb818903f9ce566641ccea6c9d8b832200778e7dde84d0261004cfe1e26efa2dfe75c9f598607fb12b2b8cedffb7596e7b746e79cf613be7f6b6cfcbfb7c01af6d98d1e6bafda2dbf80eeb5701ed44efff3369399928cd395154dc19bfa7421714f3f64248f15736e757ee1f0785f2df20b748c17dbc83dd4726beadda73554cae3ec51b3041417924766e5042cf3b88e467f0228cd20d6ca991be886986ff3ad42794fa4b7f3ea50f8a83ccbced89a668450ca20c8d7ce6cadb2eb6e8c44664dac7ab6d51dba6aecc61eec46aefff26bbeeef0b53e13dc29216b4e3d7f83a1c939f9641fe6d0954f5616980453c7cf7219f5f26af74b5d8690a2f9fd211e0945499af9447736e407bd6e8b4870f6b68c364e43d1146719b7e2357a11d9536a7d0fc264ba03ca67bd39347d8027680afa75ed455398a44ab9735bec58f0b7fd9b994387c0c559563b08e99b370de213ee301e54b3b0cbc46506464c3a6ca8adea8518e364bf1abefe7255bfeba4036b5230a77ed201abfb8e63639f78c1193c84e30a3bb8ca77c632d7be5e61d73a70e3bc3d6c7474ecdbf155c1b9468eb00abe59d29953c4d5eb221e9b2421133ec70256753ebb5f464a9db5018be9b7260c36bf5ae75214dad618f3ca087c37fa21952860e481d430bc53add9b055ed0ba88fb2f54104b04e29b20aaf34fa2aba8c37f026fe0833235832f28cdaea616d1faf59b5d8552c98a9fe0eb519b128324cf99a4354472ca9ed53f0fc8379e917662f7b398ecb63d15a98b1f176f0b9aefe613f809a62d905c3c7604b71282558a15c2f9463a1551d9f7dbbf4234a0dafd8d3fc87bc8f468d949fa2f190a5273748e28efe8bb2aa9fa60d05373fc0466f0692b9fb1f7a2730765ceaa8868e5fdd58f96c0e89634907fa043b7b08d69c120c9d382e33f339cff732647f3807654b8cd1cddc6a5a7d3150d90fe614b4b939ea0b9db088d37174fe2cc2e5ba08c7aeb48cfc7f97c4ddc83ca2d78dba443992e9c6b63b6784a9b2f7f4fd6748457ef449580eeaeeffcb3d28e8b6df64b10c32027a857c3d503090b80678252bd1a8867ef2e53ad4d5a08d37610f1ae44688de4d4e8c02a63a43746ac5548722ec1af284723064cc6ae797ba926044cc43ada44e745932a773d721030973d99732ae4afa1273bc6bcd485ba2974afb015acec5d83153796944f1dad5f1b6df81fc049135116db344b1e180fa68f1159ae69dd99c1fca3168fcdc500228da3777f6912e9944d5ce52d4e4854aceeb1de8d9de047750de9788228e6ea4b13d478e9cb4db59f3b7bf75838741b4bb0198baa2be1dc140f1db5b302782cbb7b0993a71969afab06e2f29b2485bc7f49d3cc1bb593c3349c214e5bbab6de8cba96e456ac71cf9f3d098049caf76fc49b5c9cbed957620aa4aabcdaab16acf7edcb9374d38e1a4af2c9159958fca663009c6042d29ad58b83f7cda9edcbe371c7f4787fb4386c33be17ecff038cf5056b5d46f5e2d848a81dab5ebf1c05edffa56564ef03f2847334c72cc139d640a6372b76503a3bbeded5f5a36b57a83065c29372921e825257e532833f098a9925190abe2b50e4d12f60a3082ef56a9ca8b449b63c01d6281b6e4b900979e6969134b91025640285f3fb6598f26035268d9819d619c89120466db4c15eb3aee16d6e14ba8fea817087552a4c4c0604b1372dd8333cb05dcb543bc620e1c8a667d53333365793b404646183bc03e31b65dba9771ded1b6411c5e1079be97d6c4631b0469b57427855c7ceb669c08e394fb5cc23127157d0d25ca42cb3f0fd506eaa24abe445406f608eaf0b5e370dd9077a0686e0c4cc849630408fa5283ecc63b6aaacb6b45c2343acf9bef887430e2f46abee126c950661e773b8d199d5b1eb37583e0da84a8d0d0b1cb7fbc00ef9aa835ec693a2eb1ad1b91bd41705f19927c5693d399f02f3f8f225b1face35b58d22ab8faea66600b75d0d4e66310f857b01e68748ccb94410d303a7f0e436313c50e44aed623a39796714994431b29f02f3ce127a97358edfe815361331a8c183a558ca6afdfc29b7d99ccdc31f2067fe8cfd7bcbb3f8ef78d19576042c3ff8c06fc265a8a6356bce67fd774729ae95ea23582fdd2c1d0da0f6f90cdefe3873a1b1226a9a0d38e7383a3a0da06f6aaed011a397c91f9f3760612c5090276ff99d544a416a868edb69633cb16158855d1fd970427237e19d3a1411a35eee08593eb66c254a40dbeab27dbb62170967303aa8b6b45efa00e97ac1cc1137e372d036c41a368cf6434c218a117fa535f5ef9d0c09f67a73224a0aeeb71a3ef2cbac0b096a9a0105e55f01dba5aa1e17f49c3392b3dffc300986566bd59e39c56beeda161cc9f31fe04c080d1b3ef25b24d042e8888ec46953c41f0df38066a2bf12735401a5b2d251abaf589e74c8b8f95a473e897451dd1b4f4c4e1898e37f968d7348085899e17960649425f5a4dc9f3a5554159e6654f23085414c6ad94b83f7141537aa2682e7736a84190b37ad39c5195f50995d6449710751b228ad5eb7563b9e832e0f6ca7e466ada64f4d262f3d6502a38fa755e33a07a9440906593bb999260244bd7298da255fddb08db88151ea4ddeb82dcf99a3633a9b42a7fb0b6e19e5f9c32f7c35e5c4fe0aa3023679eb6d1be382357b7d4ba85300f15acc138c31380fe22fc59ee542","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
