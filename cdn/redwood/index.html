<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9de27b55275b61b6d5fb999561714ebb4cf42a87fc42851fcd45e44177f39c520d758fbdadca25e90dccebad00af211d2d238e25077893646d3a4d1c566e86d88124607af0b45f0984e3d04777082cb369c048e9f29beaa1f93fdc01274a4aff6b6821a5824bc18048e0449a8d864cbb1bf166ee90579d9962f58a839cc7c836731e5852f152ba3c7199f1e940ab123003ace09571b11a373e5cc18f3dedab0a995ebbb3adccdcba3247f387d66d92d35d072ecc7bac2306f98d748b6a14bc9155e5b5173c08ef0b0eb420a486ba01b7bee48b164bc74df457e978b7b6da3c58c37abe98206f39f1e3f0c19fc1321760c2b476971e17758d4fd2bc5354e2234bbb5efb8becb498a638017e00e11ce8365fe2c1fbf3bac078cfa613e8e579a54e7b9b8351ac41b4c524f3e33eaa482a4e8e4b88aafd35e46d919a7277a8db5f612f2850174c851cf8cdd79db7123c3f2870a4aa57ee88d09b4477b39a3610294595cdd46e47908b29ed2d77f6e52902650f01f75b4aa4647fe5610182b8af62c5905093ac7d5fd4892ba1a12390bf6f77bee9ea508de55b12901c2796aa8aa242446a2a863f0cf39091ba8ed0529f4004bb86064bde1fe13de79e03eec6a2a4349316f0411400743deb4bcf67d86cbae25b65ae361c1042f29ff2e157f2fc0982ed4516441d4551a99efe6975aea870053e9bd172debba143e69d6ae744a8e3eabb5959edf1bbdbce25cc167daabf2084ddb4b1ccd01dc4854f9f31dca23f60b1367f644859c07c15b266ef3d282b51f38c43bc59ba304e26596849a36bdb583fc6e78655d66eb2034c8d33655ea88e91fcbf388b87aeebbcd0e48f375645acc6afd912b450c953fed617d28cc701968856e5d641b27757e3fabcb3f0bd503300cb61602ae578094387c34b5127e52fd574ba99caf724b2f0dd12a937f9044d517e62f87afdf57f124aca106028631c0713c15559657cac75b84517db19745283d2243465fdf4ada6e73e2fe216b3789a9c23c39263978ec23fc49470fef9f9d1bf3b1ea3b616ef3f1769262f40863e6994462b96f259c047e08bc39b3468008c67fd92097e11039f0ec77cb836a30f9d94293f366e1aef43e78c8303a44b4b04c942ec6789f46b4b7c135ec7a43f6376e726b78b3017ee831b243ca11d7440dcbbf462be0c24b280b78181de699543b408554838baeb73a0c42837d9101c0892737e4f167f3e5d264da2190ad8fb4910b25a11b6e10efdba3aba5cf579c47087f954f5ec45cc7e1eacadec3d2c6ee814b6ca13204e7fb9ec50391d1e14332b265cea07f27bd24317cb61636342048dcc78fe286ee99882c5984a9d9c0f827c0486e86a16cdcb165ef2178b0ffa11d24405d71fecb1d6ae4000989a6544542576d7f17c377237015559ea2c0332bde72ffc2e4976ed12fc10272c18fab7626e414418f8ec7c391db8282531c155db33e903647d8609412d22bfbad97af34efcc683ea554a513fc3777045c428cec72a2e177ed2fe29509fcdbeaa2a183d264f5eefe68f07d69f49e30401f47307ceab4e761d6ee88271c1163bd5ed0d248c57049b67db981ef07b1c5ffa4070e685d01395e81dfa07e33f18e6329ab1f8f3151e25bb774264339da7e77edb6ef43e03691c02a16cb026329d8d4542ece262cf756393324c6d3d793ac116de82313f3505c1c50caf7b7d129fe4f729a108807b9016bf6262cc0cedbf8c02ba9019f31423b3cb5bc7d0e987191dff45ed42bc1cb51f0c6a01a2c6514154f0f6b1feb48e958633e71eed22f564093d506eaedb0174d48d5e51cd6c76eb23975c3aa7df8c2a5d34a55570cb53570ddaee149fd412e563a471907188388bf3a6c96f67d1ddd22a0cf02c77ada8fae091917be413e648775cd28c33e17eda5fad072ce2f88b8c44f04ab93bb8e28fa5c9cdbf3d94f6c2b0e4fe355c02bd39c22bfde58e4cea1b88ee91773da91744dc184e24c630142d143bd82dea45b9ea8159fead008307cb1379d410b946cb4c154c7a17fbd0a6d27db17588008b3ff6ef0e187ad714496f1007b9e0c73a93196ed6568399635719402ed0288fef883acb5b12805c939e3fadfeb4b3cbafc1171f1c65eb285c02665088a7f5d324f570a7591dc3433fda136ca45229bfa3fbc625612377d5194953d51ff312c971056b424a63989536b3f8bb08e286a0ec922733a0aa8e1e46a55e4520c8720dbe1bb4dc438ed09e3acef61370150a5260ae134617356406c63e6493b99d76990d709424997b6e62d1ea046f37819bdd0fa1e6f6f3a7d31792a33edcd6cd60484145c9fb19495f2a39469c42e0bb3f105bde03982a2669ad7dc353d55a722326a0b0b8d5594859ba65c4c6af50c40e66a10269afb8a6cca2dab91ac3d417738360432b7bd2c9dd3458c36148c02e61835d34f793ddf9ff351b4fa210c02f582b43fee91681cfb044e0a0ec877fa2169a75a24f5cce1d05fd15842422ae6c302599698325c651b14ef31cc08ecd71f36d7ea0878e2f89dfb854161f69b898bc7274b9a13dfa878f44e650f9d9a507f055e71c3dc01db01e1b4a6684157dedf6d26085a960d4a0176669ed6212dc56707d2b7f280106cfee116e65bbf2e301cec6392df4437559df617a51739f039423367b03a64530595636ba45eb406a252a9104d38dd4cdb0dd85148581784e2c959a52d02fbfbf653358556973c0e1b082926cbe53043ce8680cb6ff6ab8973e137c26d2e104f1e498d2137375abc27cee3b83acc2870d0c3de57798327780d4966954d4f26bb2b24bd3fd892bed83501fa8fe3b6234a11dce9a1949615ddeadba338e84c18791da9daa3a332255bd1c5715dd702dedf18a9512742b6f74324344db1100f5b85823b2586e3af6c6126e7bdf63dfdd2bdd52c16f3286678392d8124a665d542e0d93d5977a0731c679c3c7619fa6e0cfb932e7c2bb7b67c24aacb98ef604e2c12b8e287e8540b539a039891b7e4708266866e35765e20c81fd4931b1b596d530a9929f06d155e17195947c3b5493160857bffccc80279d29c5a2e2213455cd5b5e7984874ce1668c3c6a68cb777f7f99a7619ca1f496aaab36c5d9fe2c95810ee38a02aeac829253dc6ffa4712075c686e72e7a474e43b9a2a3fdc65b8eed80cfe0e6ab7fbccebda8cd830762c44a99924d1f9bd6b80c3d3227f006e25aeee7b269752b80fc8d7cff507a79760b5ac23e316ab05fb6d9ebcf7bd3da857f2510276f4585e8d23fa5eeb66f4f6354875e0419ff957501e49bd03d2d4ed508c6ec255d06d16cc3577bf80ac8e9e05d7ec879457e11dc568ce78b6ca1334062941dcbddf1ce8296128c854c880f4c5ab19c77c5c72e14ce88a9ae559b745bb11865a5abc49971afdf6a0a737a2faac8ceae576445458a1b2ca1176bdb754992a7cc6eaf989dce28c6ca82f13f2b176b0bf9ecb524b81123f07d65cbd179b35ffa628a1f7696b568ab7b36b692c3b4b19f4f109d6df43710e8a7976adde5fdc747a5d1a75bc05e2224c799e6c9d95196c11a7fd56537fd8228351cb65745ba35fee490150d271bdf6833ef45388bcb645ae57622980a17ee01d49a3c640933c9a57c46184960ca5ee9eb626515641aba6c505cbe921c2a0a7c4315c7685157a0b2018ee2f81da60d203d9840b0ebed3ea3837335665c92a6985089ee1a878b9e8c67c667a14a8fdac3b8dd5379e7b6cc591d643ff15f8263c285e08d084c70943e28a1a08d1e73bc61d9a3e6c9a2332ad8dd060c49b61734369047d49ebb041610f42dc68f8eb2043641ac03888260d32ed035e1c910729ef398e9a10e5ce16508b157a828cca833772ec0807511c929868b0085eae9cfa954632e8b66e5243c6028c93d9ed46666e42c2dfd8a520f82599cf225db337272f6ddddc9e4eb14c2e1a4019b8a6992051169d3e1698e54c051fb297f151eadc5e379719c9adedcfa105fe0311ccb72a2f7609de598ec4e27a4a19db56ca1f5add438eead2e30f37bc42df930a783e12b977446879bc6950927214d7111f5e5cc95c7db9ad2b2459d16ddb99e497093424f596a4dbfd07b5d28148a266a02455a8329a0656ceaad453b032f4b5a5ec98e5d2cf8fc908dc7174d48e358fd67a579dfbe71b2d9e1a8db262743cb6725ec178b97f208be489a99f4fbacc32c9db74ba192c88d0c907b52eed4f1308e98bcc418b12c3beb3b439c20385219d3003266e3ad4a142cb9d91a68847fa0d9214b163184d704de11e3346bc48b1d6e19070a4433e752b0d512a53ac48d98956979dd1291ae029618d42a7949cbd898352805f7968ac476fd7e7750b7228bb8255a5d323a679e2f338c31d104f6818bb170acf9635ea478a816cb76d77d396b281add74dbd117645a40d15eb49469722e86f8cbb63e0e79584c6314c5666f626f084abc13491b98b42054a3c23847b94e6fb145ac27533d6a878100e6c99e0b7f33915339170e1beee7f007323b3148840aa4ec257bbb68fb35264c2a8b4f4319ee5a2ff05a2427533af1f42b543bb9ab01b36c8e69714b8bf1c11d09057106b75a255dd50fe88bd63fb2bbba443c64e36f0213330163e21a5781df60a1e94590825c2a21b4693e22eea1cedcb886194b3897dedf2930c3232cc85dda3d2c84294abc8fafd8ac80355481d5d26abfd01f53f1b0579d27917edb05c2f6fb6e55a92c009c73d42f72511860a7a2d79be44183c43a40c3d5cc4ca76908af6dba1e26df969ec3c501cf044d61fe717f48f7cd68e10bc74746feefea43407704d00662c4a8c23a6224f8175018ea9bcc55539a75995c161ce152f2676275a4d0eb5a7f3ea6d361e40bdfd63fc1e4a1d62e3e6d209ee9f8bef780324ebfa41468f52998966c65776fa8761e87ffa02968868174ac3570c6de2c548e49b209e4ab3bdcb5ce67652a235c90db4db6ac0735187d6a983a4f77eb2f8643e491f8c5ea90309f185e5d2c067049ff7bde0dc7fd5c78eef6370e685476c4569bddbe52b80e1818450011cd4ea247644fd89a519798ffb478255f6a948a02fe020b158be0cccfaf73a8fcaae52847039a2c718ac287f9ac4da180e7d98c99f946787af1ab63782b80911e39a02bafbec08ee229570d4158812e428f18608d406b32746cc15eb6d921222a5322b8e3a7169fcdd33c6a8b68ccbe72d7cf8814a47d6c721e163d7141ade9c61dd358f1819d958237b7a6bc09511c0db01ff2c596473995e95d3b65defe9742f87e798cc424eb9bca8dab0a2a6a7d62fdda84014421a2203cd75cc033b631592ccd0c6adfb393425e40cd7a63de5e65262a230924f2b4ac1685d683920972e396878e94aad9dec401fb39044e2bfcf5647156247c503cc747ddf09d4bb3c6768d2773941959b0493efda611009ba9de4f73bc14d0c880f4eb4fe4090c95af0daa8299c38311fd8c971684f3df961f5b0e75fbf78217a1927d939bbbb69259b23a054e6803809ae08742b1c510ebd436c69f2179fefa42cd9f09027ead26afd667174ffa520ec1f7bc4e0140b2d743ac80b933fabda160ff3b3a1e51661748fac3a4da998c6f2b846f48cccf3a9981e6a6da3da4e0264c499dbfbae3bacfa97bceb3c96afb7c276b4becf47b49afefbfd91ea700b689555634a0b973d49c4bd330fe85ac32e26d6222cf1c4ec7187496ab4aae295ce9f6dfa99f497686526e2f3fa82ddd1861aaf7a7b839f99c50d19bf7b6d81e6292c29eb408f516141599042643e354fe5ade38c934e1108658d4fba603e240d4212372b36edc904a2f037e623084712492b50992c8bd7d9de77163be422e79e8b3086a57a571ac37f6ff0cdf5fa833312cd1b72e216fca11fb00d0ef85e2af069d695070e8078ddd34a8b03068bd61dcea92c5783118902c751bd1d3d0cf1532169034280f8a20c55be2b61baad9e2d4136782408ac564c796c498dc81aec40fe264d7ed12d3bf7cd413ed786385a84d17f46c0798244c2a8ad57cf518ac902f0653d68cdf74f2077747f4263b222b86cafb71e7bdc5fdcf7808fe1924bfa620f15902b5cea9cc4605a3cb11e2ad0298643c7d6d15ca0b4471c8a16e9b54763dddc799dee40cdff46b2a73f4b3efe2cbf165f4c5984b129c3b7ffeff89962f8f1561e26ba6b94035718ac1cdd8e6ac5a014fdb936fed2ec2a324a32dabb4e6bec8c2d2d0dd0aa0bc0b0b3a1cefd8b9984430ec0bfcc0ecbc6b9cf191a42e26ae5addfcc6b29fb678840b6634b007a082e5030d8b33a666df4a83ec819cc051f1ff2b980943c30a85d985a591af9ad35d328c2e461ce7dfc50a8d7b5d9a2ff268c59015a31d80194e66b248347feb20003eb44d960e0e08f878a8c776812185cf496e8350bc136b36fce8ff2e0446cf19291c4825bc635b9d2fb2ddf69d8e47df7d43a631dffc3070b4f596909aaaea9026ecd8016987c7ac6df671c854e57494d0513295ef441017436ef8840f9b3fdf8e7eda10f2ef098fe90e5330281c67140f19cb22ad00cedd2e78088ee0f960012fc9a83f76d025ae8b42e34787e86358be3391921cdbdad20a0ef643197f6540600509894273e04b27fd2f87908bca16eba319478ca9f033e9c0a240f612bdc5176aa29b78f241c56abd5b73d8ded31de21ee3e6a0b9778814f07b749f5aa9b1577faa16b7ebb0c3ff3dc7df4982179f5d84917379cef5a05ec432b7a0eacc2a58277ddc25c2c3c20d6c5b1f4722d7c938de6e8311bde3e45700f2035d08789ee13d53d85769e8d1524c5651d912655e34d5e324952ba04bc83417ae52a402d1ded8fd36918812ef491cbeef0b18b9b91299f92f9792f3d79b56c704aade7ef7342c8b084205ecf814be62526a58a4dc97e1a8e7174125fe06741226d9ca581fc0d082f32f94bddf7453ba9d70b915b69b0dda74142ce23be044531b70b80b8bff43a895e8f94838ef515a417739cc50778aabf4ceaa038c3c81d727cdab74a5bce97f86c7553a75d0b45038478f354e9775242a811ce6934127b0ea7a216a458f045442b2d5d7d195d7500af428271ed72f52cd531da26dff1a22777645d2fa263dd671a61a2d83bef011c0361d20a0775d7830a2f39bf151b9ea021d442d738f704190043fa7661fcc0a56b60b2736b4cee2ef8a58f87ef71629eb5d93bb8d46dcfdcea288a6d81f341bfedac4961f1f187528b91973b1a744b2e551f2f1add11c33ce90896a78da904c7ae53351a3f1db44464c94e428ff362307cc7109750d25236242cfc8ac918df4dbe88f9a77f9bd5e49bbb31e35de3dec792d024df91c5fc0a27ef9b49e3e1fcb5046ba56591ec95aa9fd48cc5e8a9ea42857b72bb43402fe98692a32188717eeca9bf2f2c1e2809da5f015b024bb217ce1774c497ca1de485ceab7e75842694b2825deef5ab9e6d4b4ff758e90a125184cf45031ea9d44993eb438f4d79c5d5034a1598e805410291458b452e4c7e12c39a4f1eb906cd03f06b5b5c8a9663709466490a0069d9851869c2bc8aaf2b480703d406b0f03444046d7044d3877a20243757e38126b79ef6db2c744a8fb580e99e1ec2acb8696ec1fdd32ec1b60b254cb36f42f25c09e7c659e7b9a3f53d9bbc15ce6acd235d27b3e73531beee26e3a4cf120e7db8f84614bf47353e32ee8b05006d757de5c8e1d85779e045d54c935eeb76a5267201bfe983e747a0470e612db005cc2b43aed450f2fc6f28f008264a539990b34c3cd493b035c1e160d7a4049cea58cd083b11fe4b91a5575d7018ddc5efff0336ade68fb31c7ccda5379f3cba9cc17517ee9642bdc5e2cc51c31b805241ade41fcd07a83b1764fef75be9971e44d4e9640b0a73e580a010b6b876c6f43fee2559b3d217446482b817852e5426ff5b69ed260ae388aaa153b10ca472d7e5710f46faffee7e19e37431687ce5cb0924f6f8602cac496d8d843c9d3495f74c9d675e16c549a1abda4646cfb67e5d50910370dd87457244efc27659ccaf117aba5e45705df2776100c427acfaac9629921f03da03ed4b3174c5fd40203171b8bdd6a38d9be596476302e261e98cd57559fb70d42d936c520df8dbcae96cb065777ce5fdc1946e5528e2b104041d06565bac79998100863ace4337fa13f37b1a0e95413244746f12978366e454a6808ea4bff3382c870e6aabc5f2f4f3078b1fadf26a60b1178fb737c8ccbfe2a392c4cee7ad55b773bddb721657bf3e3362947614ef34cb631fd54ffb6852f5d33d14feb828c228825dbb99ad94080af308e3e469eebd8f024eda07bc93a50241487b5f447751c36e2d7dca6cc514ffe807c4f83e9fe9c5461636bbc8022993eedb0764c9161e77cbd31931c339014862f44197514cb9b7c11a89f2ec5ffd6ea05845fb5b4c205d1b05fe68a406d6e9befefbe907140a1561d1a9cf7abeb6cd94cbc76c5ac8ef4d4ac9daae281620b1d4f29d625e0f88db2fa920ee529f3a631c0bc101fe41076b5705d71f4b24fcbd6b818a387ea4864efa901ec2b5416d9bc799277be5d2392be74b550ffcb6ff24a7b9b9fb140358f28b6060301f8e219659dbfa6881b695885ced0ac961e02b9c1adb0476a13e742f8b5b57bc68f3e8783222da45f11e6f26dafb08130b7e890374c7ff945c99a31406910774d90f33cdb882f8617778e85c6748f8cab6a2d59c0e444802f22016aa1b4583a714b3f9007103c0ab8dba93b2f07e7876cb0878cd69669e1a5d0d3174aeeb6202276923cd6c221464bad723328a6ef80f4f4951c886edc4caee745e47d2a1c33b8428aa80ef5258bb3398fc8c445d0c3b5c65731d03a948fa6afabf08458f6953b47952907ed849b58190ad19143e7c2a2c147f32bd35ac5b18f741aaddec7a64147a3a5166fa4b5deb839bd56f649ce2ba80c0bd0254b47f4fe4175c17c38430692da8f7cacbd2f988101336d8c304154b1b0f969b38ecceee5f41861a819700efe2ddffbfe6b27368806a739a573a3311d933fc464524e30c426c8e35585e7a253e45ec94274ec772ba79864d99bd7b75066901f11d197285bb9d3ccde17a4b5003621b8d45523231b5595a1b37656ff603be793871007924ab38a8192c7d48a7a686984c028faa60acd5b87305cb51bad7d943a25fa66a31e5770658bb3449c21e2a5705fd9649eeb213a97f866a9abc5a92207920c475f9a13201175efc1648d28f09edce5e0166343124aaa584aae67f6dd20b17f1e5a293a304862a1eea7e5a1512a6ad1b5e841d40da4da790fbdf56647ac1523167792aff356d6909a4ae97e46ce6bf1836a3ca33940db9215fa031c3402b188512ca0ca7ac416e6ec98802a9af73eecf2e2143e578fdd2f99ece4be4a2c642ded7e6d52c5440f94f3900071794ffc9bcf9a5e940695da0dc784b88c394e1a448f7fe604321cc679ab0e4b2b925b709632be9ca27b3fa0d9343277c51106dcae44b42aa0462270229b455e1faa505ec458b47be254a291476c727467827cb114c2614353e26c58c64f50ec8fc0d89860c607a7e8bfa96e29628ee4259ce113e868c57c6f926eb06931834f938b9d4caa5510314fef03f68939db4b8f6f566e3b80850297cf8afc3c46d91df1e715974078dc2c39e08b1cf59bbbf3455bde8a0d53247a0cd7c0473ce45ad258fbc6ab5220a1d1b50b1d2bd6fc6a7b84c12c17407f5d64ec4506e766c5e557947a5ed5e840cd2bd08c38ea8a88caee8cac1b7ce2125062c11d02ae229a9488b3394e670b4052ea9bcfccd98a63d9ea9931fe5a7b581353c82cb245cdddc1641d8c0c01b76130a2e1a98f9c7abba1a29ae647cf94ad53485276620219ba6dd6c16b7b2afaae9c9ae7671a069d02a531290bab291d3705bfea8ac1fc592b36a54cb674ed4e1b2a9a8b7a2c34257ed4c81bcdb10cd1847a5fac02a9ba04d5a43e2df883ee43a9c3f274aeb8802da9151baa4fa03900989fda7065fe202c53bacc7ad5986d5f3abf532b50d29ee7aa7a2a5f38b0d27113b808b41d525fbc3ea3f3722c9cfea4421cce8b51fc3379961e0586bab818bde534fcd5fef91a584d4d6241463d28d26bf2ca0381cc60a127a2bfc041b9200db673b9881cd6dcecc26c96560ba2fc7aaf313eb357514eea9feef9a65467f19b71bed3879151291736ae100ca0e1b626515ef6fe4d2b823e6fc13c2783c8993f8e57da7981f19d8a7badb72e740eae074f104f5f9cb208655b33c4bd58daa146e8fbf43ac612f09a2de34045538bcfa43edabe0470b7127e2f3ffa1b3a6713905c27dd9df860a2c3d5c3cb401c1b693cb412365ea28e0625567fd50b31e4ad705dd5ec3dd0d4ea193f815705f2c120d4e9bedc659da59d39ff77236342f9555ebd4b0e57c3d78bd60c88a585b68a0b918a1f932b9a4ebb8c0ed600db2417ad8eee215c2bd520acaeefe01d26beb01e69193a57ca79d5686509623f040ed53e794790040a2f55eace56eaa64bce05171c3415fa7efdc1b71508e0c5d9a3bfdcf31ae75c379c449fab9b256540b51db682a704ad217a9484a24fef55a2c37d97e44832a4dea8703a48199c8aa322352fd960b2bf38ef3562c9af912c6731106d54c18bfc1534a41776d97d19fc27d856f27753d4ce291470ea64252d72554c6b9b7294aba6ce5880f40cadc983ec65c3a8c7cfffdd8ebb4ba59170fc5edc4e5edc6cd126b6b815a8fe8e46db41977f250888601e647d4a249e9a600e4b181f2e0b54e1e89fa66fa59f1f9b796f81cb4f6066f62136b1e106d3a00bc01cdbfafd37fe11a6291ee5fca9c81550423b78495d85c266ec7df1984f6f868a5b4d0f6adda8e8da44c55f1b7932c7e8f55f6e6dc1ba75294857f64c84ff83d454fcdc85b575294a5c3372bacff0c45e10160bf2d8f7dd5903169de5845e5fe9f6f5aa3552ebef1713c06bbfaed9eae20e9d837392bc0eebbd67c70e15c6e67a0f474699b4941f527c63dd85025fbac82ff8f0a5ae46895906e3562ec9fc8c4108621df0a0cc6c265564d2477437eb10715950921f2b0135d9428199a846a4e16f6a139d2cdc4d8e339ab86ef6446da96b3d10cbce00ec864bfc315063928fc888d668f56cf7ab109512340d308d8d3aaa30869937319ce1fbeeec64c6035e324129da6ff85228786839de7a99d363f590e83b2918ef76c48f837d4b543958609d35ca7869137c062bb25784aef2cb29a7f00167e79d62d1cf98d1b319d1411203d497c11851a2366b1650ba5e89e7570f192560f2cb04b4eb90effd9c29778639bf2915802451191de921e5ee1875bec5ab806afb16bf968595121a49bf4a6e39c35abebbe6a82f580d48f1e75d77cc0808be33794644e8d7011f2fdc5e56bd6b32560eb78152722a2126a6ed49bc74808fd3567147df7349ea0b4f00b6b1762efe23952e8dfc166d717e29fd7b33fc223a2717e20a570fbc4bbb50538080ab3522d5e6c185366bb1fe108279951ea79696042ea6c2fda140a01bb2607d90692368b573cb4ada4acf0a88e209939d4377330bf1fee01ca794d74eb60c06aced41746481f4451b7333a6959cca6c9f1ca8245fc5d006b5d486dcbb80824d419b126a5ef3f8c11fd6ab0331fddb63a4cf2b5b50e47002724b3f4bcb19029d418d569d61cedd330b5fd37ee23d650833a1dec3b0b06313b9a42b08282320f5e075ea023db6cbc153f217f59325487b5dea882d43505a0f5ff1120a6a82642ca01512b9d1fd24aaa3af3f00dfa359f5fd0dc19645999543ce9b674fbb2c6d9bddddaf7153b381bf0228b25eae50b330bf333045f065db641e6b37bb1dfe01fa923f637fa4f47e54032c1b783c25ae283bcaa15a365156d381cd43d43f61b7529e6ac963c38216143b4da20b2316560cd86ad64ada0c758b2ba1e3811c569d2430d2a224982267c179405e8690cffb95ea98a09587cea2587a7e45b57a8e4907f8f9601f4655c7e31d5d77698cb385c025debcc21ae4148695d81b11cc367ab186ea7d765ae7548417dfac259775e44a95ef589759b7b2c31e22671dbce6870697d84fd3ada97cf199bc7d7b1655a41bea174d6268b5ea81cb113c824d53faafc204097b046f2b8e724dadfa512b1f766963eecb8689a6258c8db8c9f32fbc6f2f70c61bc47214f654316a55482c76b4683542e450e309daab7dfe0531da71207057440499e95834c2281a8d1d44b98adb08e47b2228a41567e0414b11382bc27c8b8678a6b2455060ee0a81849726190e0980c735d1a6b97d1bf2eaa23a653cce40b23f66ba8c570e7aa4adc6a3517875f789877927d2bd4a57c649eeaecf7bff308fd157d85d8eba4ec2c4d909817bf0c6f3ea8ee3d99c121e3192afe2efc0edea5a9888b3a876a45caef17d0c34def59a4636999c8d298179c0dd6de4a7d3d9c2e4a302a26544e6f4511d3f7e78c805f024c98eb3fd68e15cbbc7f23b3496d80c200a66eb82b6744f294e45da2d1de7bb4134de4528e17ce631049fa0e699b61222c51bd814dbb29de5ab282f442384ac65e5ac49e73e414a175fa174ca257c7643bbe82c1a47d09fa92482d44dc2db2db86cac6a166fd06b2dd21a0434bd5077540e7bc772d7b7c061d1af12aec325e8a036f14f8bf0968c4cd6297d07019c7c06f25854eb167ce66560250ca367df4c61714e69f10cad28a58cebf856e0c031940b57f61189af84083059f044f6b00fe4329c00754d127f2b9b72808bb683dc760dbfd4206a7f9b42ccebf67addff3c6cd62831842f8593024b46cf1797ca8c43f70c0b2c2d4df6d37847d2a6a4ec3f9a97a3ff8f89d0972214af6c0987116e3e4db63b57c70c20cc688aa285eca4206321a341a79766d2dd5367b59a1b5940b8499a2e0a53a86fcbc358f0d7f6dd2b068e72039e0dd19a6adb64bc04b1efbae5c3f059fca3dc4dfcd93c15a80b190abc70ab67d76fc57a3ddf580b9a701faac99faa66f90696b0e7b98c5a25cafbf4120c24c4fd9c9a894ad0bb34846d1a7490d085c088d32cffb15d4de73676e7d59985efe5c5601ebb40d3bd2a873b43d0cc6b9606a3296e96e8399b1b1e0fb89356f3cb7e28f39547020f354e1b293d070705ccd5dca9544ff8b848671285a29174687bf614b90ebe0980936b0a5073ff8212abba69bf627b1c6088d467f1affc9fdb0ff29e355b7d09e289da2a64f4cecc0a2f1588264222624ff18520519b77abc4a8c10c1567af58fdb3b7cea326c9b61e93a3dc973ab78c8ba8204390d04f61931f37207f1ce6984223f3d854456344411b0d925cac37c37679dc954ce4835f9bd30bbe75698c7e72057443e6a9f7857e454355c43133d3012216bb6faf8da10827a3194dc74ceba469a880fc3f8bb4e1d3e10c453854539f41421d6b905508606484e2eb7f6b62bca04eb5b8f6649655e4cb8b4ebefd5e89f25cde21d802f22bb3680dcf06cd9f60e4cbfa5d1184d3b1db6519e550041a9449971db674ef6f470ebdcfc2ab8c01411f5b565652fac27e4fcc1b2758702a18818210cafe99694e3fd6b61c1d2d33c38b32f1a35d3009168bfca54fab3e1b6354eb7cc5276e5294e7a5cbdd3bf0d57dff3de724f68405c6545c412578f0f3d95e0f37aacd778e88d94bcbe9fe56d80c6e3069a8ebaa0752ca1c3ccf98fe8abb8130b844a81a2b16716b664af01a2ca0eef95b908260c5d0a58a08b1198b6816f254bc05bca3930214b0f4efebb6040257a9f43d36d4e5ef9ecbf7b2b894f775d300c297dcf3f67093b2f2b1225f61303eec5a2210143a7738a126da7e06bb86adfb696ef526d91d86ed4eff644b08900d3e57bd8d0b13a41c72ab800c78908db7f184ec2a98e8ed3297d10f7886e1e59fd29e263920fed3cf84c5845edbf741f00c19e20d05cf604d11360b5751525bb1f2399de43e095800858ceae5bb3eb475b459a2488dfe21ba311f53d864727a55267ad55215df8fb2cd2b3504ba49a462f65bfd4becdbc3ece296e9bb7aa463f7b00fa486f4c1f97f2a37c81fc5b4d85ffb38f4447239562e68d1cd9be3e411dcdc0873bc8eb68dc27e948bc0965e618b19b81c1e2841091349e46a26fd0aab284877034491fdf781475960d21824c0d05185768bd3713b861f2df79a54c3efa8c9ae41a3d30000d5f7fe6ac43058aa77d5d852b5e1f91fc8fd6a806e272b19f06b1872644d31280e4428f3d51078186ee85040f1fd91325f4e4a06d7ec71975e21a66850717a9187e69e968e2965702a06acee4d106600ae46bd5d74a959eb6bb01df7ff4dcc34c50f930ca25ce789d1490a7c244da113fe551b95a97589a2ccb19ef05761098f305becdec1d5da853b5389afe82751675707aff542c1d5002a9a4ab616e7d4ffa9236e7ac20e05e5faed0377838b48de49c0244f8dd32068b44bfd3b3d8c8f6d1275616a291c20ca027791c242a834afe4a66df51118df1bb10d22318752e473c48b22f9db0c68d1108f6d4122353ab8f82f02828d68f5b1a5988929849254ffb1fe88ac8f71606ff0ebc2bfd229b4869a5cd7b38aa70f565d0d7722bd4e4e45d622b016149048ccf6d9efa6219398f42e0ed3f33e5a1ba9d2ca517e8e3b47ca1eaaa9e299d9b435cb3f02c183fc7fc1a7da54e97123713de489152992954fa9e1bf464ad66dd2a8c9cb7dc6ca637cf235667a295dc3400c0e60914b6e4b5e6bde2c45db05454345d9b7ef128db18cbfe1a719ec08013b5551e657e2479a96d6649766587b392df50c0d8c554728a070fa4895bd291e4aa4f51e2276a6cb6fb07722c73439454f313ec00575686e2ead68b878e5031eb6e3bf8bb04dd2e1eb52f32102412a531a152572cd03b54bab8969699f8bafbf0d53dffa8bc8ee7886a8b930313cdccc96a278f378cbfaa766ab9948bbb8b87c78037be9e1b54297e0312cbe763e1ab093d965c91f70d447dd7638b251820987aacfdb9f3ad9e8e518557ea7f476a43c3a0761cc215f715d1f85f8c5fc9b8ecfa1e078a9323e18c214044d9f0a8d50bfa9b84b631901eaf04289ee44e14f27455635df1ef62bbe70a0c3922ca7af5fb3c8f53d84b5e7a43b762ac3447c0f7382b5471594043e30f0c84101f395e972ebc3323b939199bfe5f040623283ac620386546faefb4af9209363fa9707e0d0f9c0b257305a166a855de8dd530291ec8e67fab7366584622afe6d4be09d937832c088e848be3f709ce562ca9f35a7a9d153ef9058ac8e8e506a9a89f24c7056d87a610852143bfe05a4ccabbcc324629d727b4b209475ce42516efee24791f363dd6406af866feb325ec64716a1fb50c0d6d4754a500ad9c1465a1e5172d70ed9dfe5580be55c6f50639484eea0e886dc5619eb74f3afe96bf0f80ae83cc1939c19b5965b8c56323fea7831142728c2c4ddb62247454b5d2a7c794500414c26001f99e543ef171cabe4345b5ac5be192ef575abde0aa5df57c6ca050a99e203a5f73336bd86d21ce0ce960cb2c9968c314d288b0f4ca7b31d602975b04a9113bb4ecd0eae933753228176bfeab90667606a356509a22bb5bd692a6cbfe479c1cc7ad7025a6d4620b0331cfa9cb65b3fea39f232769f80de26488691d0a8ac7910e3d5bd6e905105bd5d3153ef513ff36f793b52fd9618a73e3a5bb65eeb417aab8b3e3277d6550a07d6566953a6c6181d4098601c8f91b75ac7d0bafbb90a5c9d396eba7bfd9f5d813d47133bd3373cb8d3836e1f8043ff60978f663ab50ba49e850e28b7357df254ed16e5769a0df8330b8856459cc9b449544133d222da968f11db5c07f03dc6c08750835f7b395e56970bb0231bfafbb66b54f15bb4e8e401e82fa40abead6082fa578251774592f4d47403950d3222f8b3e37bf0b0d22c7d19b615c1ebeaa5bec0ae03647d727a64006335c6eb339cdfa79e20cd513088bae46ed328fba7a42194345b85f4eda562f99e19752276b5fe085558773c82873ced04609ef9fef19245dcdf55a135cdf78cf56ab489246802fc63d7a03475121bfe4aadaecbc3c78ca662031c2c12d7673ee43de308bb02eefd79bd5f744d96d76c5678819d77022fd9f78f0dd4ca796b5013dcfb3e33ea29cd4b9e14e627fbe34227c16bd3ad70dbd5d8454103807a0b549cda79a065d3b04ceebf4755b01c4b6613eb1129c20f12988561ae90c43722677fe21dbf3a0b89beef02b1c7ecb3edc0ef575ce311fbcfd45cd0e1d2264cd94896bfe37161f8e73868dd000a724b606c449f733d01acf37296ddcdbc2562feb7efc9279cfbb235efa14bd4d93188504fcfd45aded99a36dc8fe291cbad102c0da0b8b3c79895571ad0c6222363a646d3ec724af272e18dcc5180c8d1ae18af4349dd24d990eeff3248fffd22a57a06b3e684870bd1af219f8c57264e192e0199860876d5b89138fb9aea4db1551d7d22f0ec52f70eb93c510245a498b7c5e43e97375b956bc13d5a294faf7093abd21ea76ab2d3de6695536634dd7bb364aef244d8fc4086cf1e6121546821a81bb95c7f5f399878612c5ee6bc781fab626b33a26d25ce8620e60d5ca39b90b264ac79743b2dc547406c0d08b6320f757202d5792bb561c2c2ca93d04b2f3ac482a7716e54994a07f8df7beb69ac0a2cbee27dc5afa3a4667f3abf1b041a41dfa0be52dd281b0484fa79097af8642a56ba77707402168f965737b77a48ed6d6d33f581364cdb8bc1bc48e6a0d2e2978275b5e989980fed58afcbc7782f1377a3c725c7dc3c4784d63b3deffa8506dad43e49fc456100cf8a79dd0d74793ca641632d88b03f9a4d8c5e733c9f716c798549af2db9c0d71984966ed606d40c148813457fec54fa0b37d81f2d68421c5a05c10d10909377baa489c254289244f3dec6f3f77d2e1ad9584f8bc293229935c93949a811188b70c86ef68429c1c259741776a385515207f5c89e0832ad01178190d2ca26dc75d3735689e44f05ae98360479b4655caa55470c5fed87e10325655977d66148f05bb17278ad8a6477a2d20223627ce8f1fd4e9a380593972b9ce954cd8ed1da41e6fac900d19dda25a4934f44f877e3cc2a2b8008e84888c689e12eb1ad0db325636ce044ddc640638a6234cc06b58267a345909edecbeb50af601023c0710727f286502f8816a7897f0d35b2a8e0b6aaa8cd5879c971bc4fcb3ff95e377922ec86145315952bd2d406b2ab32dc3408e19eddfe441b7cabe2fabf928ea3f009736e984ea4d14fee31045e074387bdd1be805161f7c70e0ffbdd85e0886f6a4bb8ae5f29133f057854adac5f71d44d900d1228d285b67d692389910467f2675eeac78c3cc335605af6b27275ddb071ad0e3effee26d2609dead3ce9fdcb4ece667422cb19349331a1575da5643766adbbd83af85a7905d16612303aee6af3ad11536850e93a7831aae8ea0f58ac29f458eb849b3b3c72284ff4c344c2ee87890478712e1876e1611d2e23642390b2a31c1f24b70315eb208307e8ee5f4a796434135ad452d3ddc87d82dc8dd408edfdd5fd7618a3475ee989a12b257d05bfad22e91dccaa2dd302540631450112bc7dfb8a06e704a6e3058af531a2fd45273cebc046ef296549e02d2b379bbb743b2fca26620785c16d65cd7112694b5ef6510aa060a0048c4d20863467d06f154e6ed6033cea3e750de38a0dce421e66616d5c5c1d65c33df0303f12ec87104fdd38d95e57eb8a80e0fa324433ea988df7c24d6861c986bb14fec4e9a90f17d47dc8e6e42a16c05cf9f568e8bb3037a3e51bfdaa5aadaa1ce27d63b794627d96d649dd59e1d0b25c56ae6f3aa8493917cfda48e153fb580967a26ab0d76584fcd92c823be5c36ad65ff38b50de886c78e90021d16ddcca2b47f9c1135a27be8fec9761aa3a3e50acfd041a1a1347e8f0c7cdc9cf14cfd7933d9615fa7a5fa3e3e389f1d971c2be8890f3e48e9cec6fb429629f7ea2b1768c5285ea0d72747ab2bf8024503129a6cf2ff692227ce1d31a9a46e250fb542964977fde2317ca8d8004764c6d2fb8605228292d97f90354590eaea4f1a077461a491b802a2a08898f37ce01069d9b70300516a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
