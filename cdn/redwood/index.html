<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"600aa12b24014fbb77c87f9b85f7c35c5b8ce43c3cbd3746314bb53109b92de21f42f208bb662b136fe7791918f2feea35daac8b02d19c3cdc036a5e383562a0ee0d5025505d91b21d752a7e7802015651e15cd99ebfcf38d038f77402480d63a2ea2f1d1d30b15ab64016f8f9c884f0bf247ccf43f44622e14c5c5289604061be2cb39e40cc81dfb0564096b641ddd00dac70a1c3e0283e95aa0deea7aefd81a73737cd50375d115a58236b8bb6e0287d781a418644141c12d1e8af7d207aae257b10350ff893da538248f19049b1aa728a8d72c92b99036177d74308f6b7e47f17d0f70f02e18d1892eb3258a428141662c035688bd12dcba2c413f1227b99b453bcf633489f83e75082b53e6de24dfc8ee80a34cb70c52a3b2b4cc8a8b75c0b77e77d771fb692a279ab7be314223ef6f558cf0265adf6692742a680b155cb545fb7919f1ad13f903ff100acdb47246a9968bd644bbcf5a36ec4ba95056ae3c78bca3a96c7bb20fa7247883e5f1da8492bd19b9c644262f298ebc7c61a8e92bcace33218f9e4d65c09adc10d475a47b87dc3afb7a277a6520e86789d82e19a6a49249659bb912738df78358239e3bb3e711ebb0a02f71f302527ead32dc7279c14644d78cd3af28f022780d3ea08036d02b476aaf19a59a12ed4d6864ec9477adb4623055737d20b201fc7b54fdece97896464256574865d06e39dd521ae5c284a4cbc5bff92cdb62a75df4626c1b8187acecfa6ab13ba7e0d64befd18e7a6180887677febce8b3087b2a08d6d4179c8e784c9e37ff013d86b06436fc2f58882ca4a85c0e016b9508ce8b1dc4b1c02d6300340ecbb8f92f8bf84a5a534db41005a643f3a93aceb12f7c3e71076ea4878c9afba9131d3a804a7cd650c69b4694f9c3da4f7d633b6c2b95bf531e721f4f1f2e7c76299666b7da54ca9cdf5d0eb110e9d5c6c41ab12260b8f92a3f8f8b4a7dba867726cc249c3b9d0bead92934150e3d2b672348b9880e904cb9d973cb225fa72362de1bfd639880116f09b48b81831f185e582a8a341ba4f15d1b9a34082f5e519fcf6d34ab7434b72cbbc4988658ee324b17ca50b7f6c1b6ca4475ddca7c85cf8eacabb5d7a0e194adc4c5993d6c436344cbd9be3a34eb0aa6b9466b8e4b46708d6ab976be6b7dbac9b569a08c01e362f4fa4e4a805d49d2e3cfb277289915582474d5848ccdb12a54464cf617428196b4f96ee441efe9dd7a45521822b1293ca695bb0383ccc7a61bd31c028152d1df52e3d1b2e0664272dbd49b15f63304c95a4b2310ab7a0d2b68c854687f48b716b1e549fdc5dcc8b830284f479942557d1d0354b6269a34b8fff73c5cf2a752bb49999999823cb50b0bb0fb94fcd82a3834e2cfa635034ca67c55284c396557657946a6ff737cde16e1e50587e64ca6b764b471c73a5600dcb50c3619449f8eaa7f7945a2959b4d37e3fac03ddbaf1b4f4c3086e90e96874fc937f00c98711520bd8a1fb1aa933df360ab72010f93dbbf134fdbdc6fd6b5c57311c4efcfd89372dc7ce0a14e9c0f659489427f75cfdb4c0fcf2fb5f3230bfe2100c70ae9417576beff7eb8012e9fd714ee58386977973e1b0d2d8bce230268c18aa62f42d933478525ab7d7086efdec2e46fda395c7c293dadcf70fd4ec576ffcb4ec78500966d43e5c1e34a5b031477bccb2338fb598381226820dddee34d33c0d1c9f0808001a715103379e8d5dafa4d81a08b20bbaa06d064f2c69527af98375edc79cc925ab77fb75f205900a9919f9f028b3e9e339f4e423a9f50596262d6656facb342c806be98211151837a68f111d67756a90478bc95508ae0c90d8d4b025c2e41bd8c76681eb99f922e10b75f33394a732717c8978ed5f1202900df88f6619eb5c18ae6dd593345b07e5b930457797e14ccf4df2b5d5c5694505c8f7578573d8d198ee18c956b504f91435bc98cba2370d45490f974699387ce0fd5bb7f7b972f8a2a4bab1ede5d4965a8ed608ac5421fffc61199b301f1bb38e99e2526d130cb168c42968609d6c1e7c5b90832a95bd064294f0ed2f78398ed73661c21d7c6504237e9f05e31ed511aad23615c405f4d53b62d17e2ecd05322c23f16a9b4ba28a610cc818b83c2cc42e1ccc9da0b4ea70236355568c0c79f31f92f0783fe78f086b74777f2e6a1b6af6b9b99cfdefe1f86a0b015a22b2675ee823adfcc80fdde5745f10ef53fd7efac98763a2a9df6aa144a3d83b0672fd0b207cfb19b2343d718b335e990655fc8c13e65fb7cc3eea7a79157380c7734f04dab01e02283a96bdb43bab3b8adec393ffa8797c23ec25d095b099f183a6dd327f26567123b054dfddeff60162b05006437a3f0cb26523ca3d465bdcffe9b7d9b1cc790354228da3874b545720ee436621ff43d982ea74fb70f91b847d683916ee4faf823b4f23a1422debb3403b328d7da90d4b9e62def24491408a8526919aaf48c2357eee02bb2b77b469cb4f27f99500c23df542b1a2172d6e713251a6c2b3a352a63632f32738d39551db4bb2fb38f872fe06b0698f01a9999aeffc694bb41a1a767fcc1dcfa0ce74f3723e43790a60f3e96d89be37bef452d584c5b7a056595b1840d699e2ed27584009f485bbd09119c9d00b9ce8bada82c90caaa2beb8cd905661d13a85569ff69b3e9ed2bc0577c53eb492d221c16a5ac29521e684b3a033fc3e7edb6d0418810bf0df7581dcc6da4946bdff2b7f758563fc65ed606bf3bc9dd24d917ee3626c01a5f94b2916f05f356eb42f68ced425a2884d3ed750cd09956ec419a50925299d1daa42508806834f3ba2719d881ea6c35ff8d23f7370257a14d210cf25a633433fb909f3822fcd4e5d8744cc020355eb55799af0ebf41e076ae8102ea3facdf534e169b154e9c794cd5c0ec9b4a9c1937ed79ecdf2af154713ed1e8dae6877824d841f24519d1a05fc761d44b350cab6283c95758584c46ad03e2c7ff7fc59bb01e18543904155619fa74444fb1aa6bb78302b6088bfe3a8c5ae9690ad5a9a2476b2ab4336977f4dac7d26bc322044335b99bd4dcae123b62b9450105d96e72a3b29274bccc16dd2ac1d75a1cffe2f142ac943b52296d34d418b7b6c0e875bd78fae6f5a152dd0ee29612798cb5b9e70ec69337f8e83eb16331e38c68809c0c26b4554ffa2cd387e3557812bc558d7d15376cbb727eb1511d26e20ef2f9a77d417c2b36b00ca4a0bb5a6bfc1ef685f0ad1f16900cb1cac1dc97e8d3bb8b53026e0f84baff67257eba8c2464a9ff4700242e4ee52c5f540c5c9f03065e52f46ad37d46f9ee4d511697ea47d5932267f1e2dbc6d725ca528cf5d76daacd46d177e3e141713a5254b872f4171d116e5d6e62c1d1ab8e2961ef414fb09ffd82a13e15d47bb8ad4a74666e3dd9983719c2e6ca1fa6e6278a98bfc6bc8c833b60b5860aea57664ba1dab869e57f77c889155c4eec9aae461232e19522255a635d365ec181244a0017b170250a060a2a80a07ddbb18ce6b2679c66afb686124a299a01793487a566f704577536b7278b8fc43f9fc0b008441035cf629e429deae8e6bda6a3b8bda3eda2698431c1a9ec39fcbeb2896687fc976cb73f3c9af4b56c2f49920ed17a190094d59033757192df6db064e327166e45f8bebffc761a8d77d55481c8ae956fc88c64d13000abcd712b070a53aa27caa0dd03f60243c0726d8b04613dfc14f287cb613453a7e809f0477155430915876d2eb2e4d9e71959be13841c45a80a43673cae2120ef301125a925694a126cb30e9cc434f43f198c9f042b3c7b9c6e825b78491fba7b053df529d8aa96a39f7a1b4fd06f376ec1e9b0a4dd6ea4ed675557c9295dbb46be2663cef37bf12b19d40555ac9f974003e33c0e02f662b6aadff9bb2deb48fa1cd5a9b59f1cc126b8d5bc95c0b46dbec92ee35091cf27c8a0937a9ac9ee1d59aef040f763b840620027acdbe9fd93d93745abeec767dbcdf54be97fff79f6fa7edcf9fd6d1671f78c8e1ae1e20d1620370091ce690eef0387d40fca1d2d30ec3e67ae2916abe9056b500ca2b13ab30a201353d3936a5666635b3ca5336c6832d204c25e72c7442f6c9664a932720697111342bec183c510f1b4844aefd87a92f9771b73c3048a853ee8ca404ceba289f9e1e862795d97ffb2f4f77f96c416c5d93f26e5edb2e0f699eb42a6b0d069c9ee1b69754eb65c4f0f00870cdf8c80835e8b654cb123afe8aac0e36cb76fa5401b41fd1b83d109be47252eff2e067c33aa7c518b58e27b4d68cad2be86813eb1efab4bb7ecc2dd71fb67ba732cc11adb823448c7365742b3abb5ae452b64e93b4c095124eb0d826338bd27ef490c148d9432dbb2a385d273fc7195c54bfdd7d830233301d6ac240e3250dbd17d0a2f5d68b30b8a8640d6863b0b91412a4285245de3dfdd5672558327df102385b1887fd1040504e9064cd6ce28bbe7440456a7a161a21bd5ab0e9d74b035c09a6600efc0db141f5e772d2ac352d5217723b3b7e64d74314c02bb0beefb0a2028dafaba01e1bacf6ff907bcf92f6558950ba8811dfae6efcdf14f791586207e553f6c3df1de33821a8fbe74ebb1b2ed42c1d692984d69a10d5b40835bf44a75e2ad653e25998ee9a598e92186838f1a538fe0c0804fe10c38caf1346f9de46fb2a8cc853a74bb53fe6607be61da03aaba2fee52bd842fbe908c3d7c5ead1930a601dbe36278f0c030f5d4bd4b272b6a809c99649c8d7d4f4deb1e6ff898d74f81bb629173cacefa80fe1abb954365689f6450f586871e90e532e157336343f16f71a08030113af86234814aa695bf214f21c7d1e4f69c2cf24570c91e6638f886550b78b86893cc1a69cdbbacf96755988719f22548a03cd8621b60d8077d91b2fc1e4913bb3202a55aa8b5d60adc2c3ff6de7c12d62bb79e3f669405ba2fbafde95149f4680508b9099e2bf16c55ad1af6a473f74487ac5dd3f00f644b72c9d52e7e3dd12572865f83fa33ed9c2078d081e10d7d889d7d774ffba65d9197d426453ad46b1f40de3060cc69a1f0e0b274fba9b767f8c3c6a58b4eebf9209fa6c72195a9bb2d47319ed8a6d10912cbd265a071d99419ab74bfbbb39b9aaccad8c780f6235624c2dbd33dad8385f7d3b59d60198ea8418e00dda55e45926f4a8b981823965c198c84fb0d3e8838a3d7f96f055164207db65d0907c03f1ca24e14e0d5228419c0d465c66bd6a86b14d560d948153f711b7e523516dfb6320ece043302cfe5544cb9d697563446567086fa4fcd5d86bdba49d95a99f134b403cdc7e58267f5041f5a305ffc1985f40760a81d7f5a86f9f8fb895b1bdd9a787000fba71503a49474b2874d68fe63179edd758ceb76511250b58093ce5f7d067ed10b41588dff57315e4acc94cbe8caccafd0af80a61172cf7af2433a8cfc9912350998c3d080ce2083705bb7232ae4443b2f002cf45c0fa448c5748c2e658c147365ed7b0ae4f531cb6940410d8e448bd787d943878d5f4b1ac47ab054b7327d4d395acad4a32beb018a55df321e62fae394d7599d6f9d65cd68cf81be2eb7edae6a34af5943a04403ef30d690f71bd44284724dbe45b8249a9c42bb982f8d7e3b9a8030be0e1d6404b4c862dd3951f253eae77e6a118405293f5d492b7b50ad038d8d8ef6b2054dea787d80a5f6a879c85d5c08e4d9fdc23e13db155668e5c56bc74c52196e58555fbda47920da76660603462b46c8fdc7a5e221b4fdfd690423f5da21adec4cb3b38f34294afdffe643dce219d20b61bb9d0ea7f0d95da3690c5724507543713279b6caf5fb7e929cd871f523384486e2643e82da1f59b458d71c7da833d6f41802c2170bffbfd7e716b816909064ff1636bde6307ea7ac39eade052416ef08d572124945e6408c287218f5c42a1f4e438a53609169e4a0263bef3abf643903bee50f55b54596aa24a323ba32710bc5af6e18d1e68b8b31651d186e445af9a95e54c0bd4632cc996a00b95565405d564c3ffc7a2086eeed5451f9bebdb47d4bcfa40f7d61f0c1894e37543f48c434851ed08d3a7ff2e76e4a05969f050b482df156d8c8486013aecaa6b75f454206701e4cd3f487e2683070659531253ecbbebfee58abb15b5b600ebacb54f16c35fff5fffd941d2ea203e039381f8b0cbd6f5d415794314060ca15010e22d725c362eb26ed9f686126167221450afcf05b605c9b756f723b119c2be6530a9f603013ceee17823d143fc96d03e06a714b734dcc997e7475ab2fb966bef3079b03dda2a60fc8b3be43d4490dc3657272ba6ce5b07d0860693bb689adcd778d2495af8aebf4887d101bad13120d2aa19788a9477276a031a6451ed515b61aa6e38a4ed4ba8d0a8e61fa451744c36091aeef9aa538797c7888677c965ac94c850cd37c18d29ec785470d0f52b59d2607d78267a293ea14e61a73985875aca0ec8eba8ad148a55df288cb0d6f52b0013f83d5b6b00bbc4d1288c67d6f8f3d7b98e7e99df738cb71794af2f9fd851a8ebcdd672986d5b937835956571e13e4fa93938e7c27c3acfedf906631422c600e212a9b7d2a7d58f57cd46b683cecf989da8fc683a13e2ed3586ed938f7fe60c2bbdcc061fabe843369c2fe584d085b87b8cca67fa7dd4edaf1fcfd534493cb304b8cac2ba5f6bb86b5e4b937809c0907e55031b82e867ba1442427c929b3a76b3a05f7df416fa9740030cdff7b91adcb51abfc179dde0fa3dbfe49414117fd7ce3f1494cfa50a06ce3822d3c0f16dd3ab88ad479f399be3b31852f7ab3a6b35fb1d413fa4e7b4677e799bfc65a10cd91d4d40f0db159480590f7a9e6066c19c00c813a3ec0fae7fb61c885d2eeeb5433bfd4bd7eefad634f36e36e2e69740dfa78917fb14cf3c2e156f8f02724fc12573a222dab886a4a075c1b401f3402a87c13d5e0fc8d9ada2fcd2c27d93f8a104213312eb25c198968ba3dd36752dde95b9aab0b7e20a403b4b78daa7b5ca0bf117757987a1a62674ea13034060ea08174c49b971c14b70773f5cbc877c57594bf23cb685c3e8631172f0952ac0d3a18b4573217a702c2ff91224cc076b3fabb686fa387a5e09daf4df15ac3694eb729a8b38ab974a10a03233b51f106e7e1ce81f67dc2535bfeea0767bc81cbf9a54c100a38c62c56bdb60bba4c906b92f2689ea85b1c0f4ea0724eaa7026b51ef40b4ad1f30e26c4efdf5076088a1c99dc6231039135f0e2689d5eab8e0d45a28e18f8907e732fb5fab07293e308beec1dd01d397c7ba508bed20c86ca6bb1b89ebb8a28710f3ea9c812cf4854a02ca0ba752f7dcfb95971ecc8742be04fea2a4e8832e879f3813674256eddd63d483852ada3593e6f76e5ff9bd8389adc5decf7f822d2c2622ed0825747f2994d541ebef20650d8c3f3415337e29781f79a58f349f24592b53df92ca14921890bf712dee094a57801070fe66ba1c73072dce86337cc4a7f9010e887b1f5a38d5f2acec27734c2278e55ed289d92d2c0e48efcf02171137e1de02a548dbbad227fe0761d7fec7ffb6c7f134f4813ebbea5d34982d5a17bfe47e9e541b54c9ab6085d1ff5abf5b874ace8f66105faaa48519fa4527d741fc9070a1d16de5c0b73d47919e136cfde82d9fd7d2a293bed619deb977cd768e67d79ccce28d83573755d5ab2cc3afdab479e11f95f4dbde7e1c43e35b227a630e2cc80f35dc8d4102cb41b19cfc11dd3a0e9d660c0282a1ace07c9dfe45ac414085ddd8126716c5303ae87190b24bd6fcf9cbcbb6cbc17933cc04342ea3690e6172f64491c2145fe8f4f3b81a15e1793bc3a0910877b4e74df0131e8a5a73b0ec4ac20ffa13b318d1bf8e8509451f1639c9a5f73d483e688dc7b3952972233c7ae5c63f36e8f002390414b8f22366e3aaf956f2ef49df3d3527541293594f619e93b63c717c6cd8b588748e54b7175ebd96b1d6c8e26035d7dd3bfe88137df774b9ccc78bf03f6fbc69044494755af815d44b8a5b301fb9d71d89dcfd1e7e169641470ae833c8ba306e8b0a8f8df0d2e7344fa8eba63816f2c5714325381cc774664d8846bc0991c4c68e75818a15f9bb678cf9a8dfffcdabf605d27bf150b48eaee976707842c7edc4fe0845fba4e8399b8c293bdfabb3b0f11e5064b1ef920f6b73da5547b86b81fde2f0976bc87e38376d9d4761a6c85795aa1e130ad64f1c4fa7e31167dcb5565dd5d577a9664a4b29f3dff0289df4cb234ba74121113cb08a4d479cf2de3237d48e8e40eec514c2158aad4f2c15dbffaf91b692b9dd6948f1b9c2c5dd225666bf20dfa9ae4f2ab90c6b32dbacf33a3d66615df7f6685143b6d51a84f5dc472a709b136115916ded4a88b7d465e15820a5dce00fb4c2aaaf484ee9cc6dcab9b722a0d21c6bf14cf3dc673cc2168176dc7447be1cf9299db54800acd98e844fddfddbc70e89d28e84d59515f0571d64a79a98c151f1cfab7b4ae9a344465c254066befed098b99382375afeb6c7bc68b819f1d3a8aae8576c2f96a7a0a6078c4a51f38d3842879cd8949c8e47d96d22f3115a39eec3049d0d6b60a4977ad8318e7b6a2744464f0897832be0dc01acffe9925c4fc2533130ffce1e819ac9b467f3e279c3e11cbbed65c8f77243f17e69dca8c78076ccfa56d4f986e7de6ee3813f787961299cea757d67277af3c8fb57095feae943b58ac38a1bebe5024149c2314ce34aec3a0109feae3fa20b07914bd3590f436848ec37d7cd017ceddfa375098eeef81b3753d573d6ba81be854f3f3b631536eeb582668876990d1dee6ac538878f91b2bf916e62771d321e8f11638fb3062a4603536e07fbb3e2ab1dbbc012f0af74146935307a3a20218fc74f2c134139d02db6a6b782611951daab6f770f804c35d4817b0b309453c098a5cdf203bc2530a0ed376ce74d35f4880dbaed3b0fb408e93231715612f9354522fcadfdb47b4c83c3c3179e246b156bf389a8362b544b8fd0df2e4e4759a4423e83724c80240ca33d6a313de15fbce57e13db19d157e4c136eb7b36dce3fcec3673aa6774c770fc4f37edbe12a7581c89df17e68cc26e1f0c9e8a8e39188281badab49d5cd24197df4f0d7512c51e78c04e31a1f5e4628c7bd4cc6bcf441678ec109f3d8b1c76010e842ddad6a8726d36b988c31be78ec838f3485bd8c6399507e2f7e6fcc3cdedd2c1e2f27ccd0f9121a0742dd95bdae1b7a5f9ae24c9945b446b537ebd9078d03abb02bfbb7319f37f0174b5ccb7e6fc6ad00b64374ddbbadefed8f632925a5c939a4e73d17ab8be54233facad3970ac8b65f76564a2ff6f0e4a765bf992dc9d9ae8a3b34ce9e98cfb53a962c67d0766de4bce1a6daf33cb1c3c16739914d1db302ca04b592fb92c843aa044c2604f0d2f9a4fbdc5270cfc851afe1a9b9d8f499e7fd31c20568673a20354e389a53f02ddd83ae56258c40f94fc9363e8c5547093f8aae2f1db78cc802488be70053579124f214c6fb5934205fe9240369e769f594e2868a86e5ecf080c8358025662e6fc2842ad117348cf255b10a27638a236f0c6a0cd7d7775c39481af2c94ee6e0c598b963949e51112b87ecd669a97402bea1784da81b58fdbe8be7001e016e516e38d9a2dbe99434db606ccd0fc81fad3739b13bfa516dabb4ca4cd403f15acc1c5aad70168e91b5a2be1f2d1bd07c7ef29374903a6b626a54b6e059a4d69c9a105c3c323474e3d31b02d631a32e0cad76d392f1193bc35a5bb10e8a6077c16f2daa65ea6f6ec8dc4c8a6a0f3f41e14f117e10d359f46a1de792bffa2eb6b2ddaeae6726151b9d978b7d195703198be1d5d4d116031b84624c9f21dc5e48b06c4aabd196766b26adaef762356db19f6901f9d2e94255536ca39facf8eb17d57f3a374ec0f9609ff044a282a5372fdc54b5ac1d36f12c1fd30f3d8f8d17a9b9ff00d47c0c07da840a777ff7f5410a24e6e136355fc2751fb231d728f5aa240186d27c1cd8d81e9e5a0750947e8af99c2774fcec9d2860323fdb5625e43c3f110ad71ec452750dafeb782bf0760ff730e8465c4029c0f34d5709c01aa9696dec0ec32e2bb03e8d4b902c46484d8ee3a650c7b60c3d8b7f777f6eb4916bf90d851506e007de0e8ee4f41b7ee57ec7d4520e0ba008ab96b9e5bc826ea0e3ed28328f3b1c9ef99f8c5b2f808f594de5a335608550fc90c3746e0459980f3beb7738250581a344ff61c44b37de816d66092df3c4d729f23064916cff1a129ac6a4c18e789c9fafa8ebcf46e6a4d2b0940c873d504441fce96f71b8efaf24818034e98e91be079b578cadc372e7df2b0e4b259cdbea919dd1847c56de69058774ae3c659cdb6d415cedc255d2155e27dc9af7c62f33b68525078170d92fbf20bd0c365c971cd91192b33e4a8f87016b916b6146b2e8ad58d34ed4e90f3753b176dfcb7131ce3c95fdbac054f7f6ffbdf69097a00e2f2f181d00b0858f7d1b1414e71dee55f224860761ac11b2ef62187fc8660c9c60784cd8b8336e4000288286638bb3c1e8b2b38c973039fd366b005a9659027d3a96fb3ae8fb0dcd923db21fbbefc001e8d0d398fc91e2c85f5b80c14d8f076a47a3b13471cc6ef2298d483d84606733a0586ffe0bf2fdd43529fb2ec263b6aafdb980779a7d81d69eceba2c63c5355476948da4adec2cd3fac0ef924882ed7f64b141ab74e4f18db5e066be8ceac6915bca4f5d36a844ad92fbed53a46e4e62112dceb8749216d2015b8409fc0b1530ca3c438f40f60c15bbb9bfba93b894d73f09475a0e494c9a8708f11f598c8ef740bfff109099c175dfd9c24ff1837eaf0066530c8b15f0e856177d39090b28c592c8d2cd0519b594615225ac8e47826e8351242d753d66f1552412bec11575f2eb31b511efc06f14ce38fd57e8e6b5341963eac404841f7feade6ede0e9ac95a2dbcb4c03f3fd0bd198d2b414ee3836f62fe43a2039477a8b12db9b210f9e67ed5c6cf304f00d5ea2cbe0decdcff92f84be23a583d15f50ecff5a7c4b243e5c12155720c55a5fbcf96f0f04171581e649a2458141cd847b719b63c0fe1303f9393944e9c6dd90866821e312dff7ccc3e4e35b0c1261c3c8d6088fe7a62c88aaa31ccb5d0cdc14eb6c330a18ee627b3415d524284c0fc70f2372200a7c529d9a02894d6ab5f187246204a786d50ea8810c1d4c4f3b1f7914e4217954e5798dffa6baa0c6278a1576e61983e0226fc36c2ad65e59b52a3e5c66b058c1544ad38a2dacb955085932b44b0ced2682c315d04a4cdee2c9bdd13fc64252e06b186f6f1529b6a5b280cb773b2376280b9485e787ad3b754ddfaa41c3091717fa526cc1ac69254f781f508a6f0d3e93241b3d137fa7ddecb1981daa6d666583d9b7ee3e961925431a458078f63a9951a5a11e54d2772d7853608f86fc8cf72c13fbc0bc9c121513a1d96144dc11874a3284f7a5e3bb3766ba9240342efb923c17f5fe91613ca023e9c433e8204be2bc7af0b24bba3f3f07e2e95d6dd611b69804b01b8b8ed328982497238d75437140225a4d17b9173b2454edc45b33aface7d9033c6e5158724a7d1c86a214d55ca2c563618a70a700e969a054a4e15b850c0f6d8d901855757db1f2f220f7cdabb887581dc4595f476227984a60f9fe89de75e353e276e7557b1da377bea768f0955fa169e11c5e217901afb56986fe665f1fea8f3043e29eb175b9ccaa52cf8de1b0128952d8d431ed6b9ea4388cf7e0129e0e3b8faafed637e6e42f2cd8dec89f82f5901761da25de3817b9aea8876759ab29ac1511f6feed5a146aa4af56715e4e9813b4789a299548f54389847ce317ba46e2536acb7ed23420d6d56d5ff10820aeb681715fcd3ff76ac89111f4720013dc6ff213289243f6224c87328cfaea81c7867a8bcdf21174080241a09adcbc51108686a51bef0a2481ea59c9d8e6543d1551f7e062b337023fb7dd93e96710182599d9880f34fa01ca3d18ebe131c2d5ffc2877f7a59e2fcb1b06cff8a249e47c0d91b41f16115e084068c77cfe03374450410c7b2af2f9d506a3311e25d5c1b04ae58d790344f22a1945e8802f04e49298c7a34655c4bb0db6b938de80484de98f48f3e6ae90bf60f994a8fdcf84706b267d6ed282d5c096013b01031e6ce2559353a248178988e61784d92c40f58d9ad804722485ebac4529c7b6091a73d58fd730ce2a3bdd365b1bcd87cda4fdf5b8a8fb3ccbdbaca808447f27b19753b3f022a95d2c7063fe57d00f1e59855a1fa8b96bfbb2818168e4d8ae32857d9c98446ca2b87b08e54b1f6b6d4e0fc6bdeb07eeaa7171ef884ca382b7571ae9b5450634c695e7caeb5725501140f3d8d6b7e3b76fbcf269088d6e9e42c3734b79f4b929b77d5b714573ec444e386828d70030f68964eeca96c84b064c2f748609604ae058da43c7054413e0b8c83b8c339dd413122db082fbcca73bd291262be025a22410e4f9863f2e74519fdc829510a3b7d1e2ca065166e67bce7b77b4be3cbe5875588784b5b920f8c306df627a8ee5ef57b17e9f4881de5747d4c180754963ad2a02b9a7c22cbb5e00c56023ef7ea07a97e26381fb30c53626d34ce8f87abe0507af48359c40fb5ef919868d84b889d919c0cee497bf96eac4b192c840b3b8ab775f7bae2b46f1472a4d289d576c1e85989b863fdba64e68ba162529aa282cc51885183e6a61b9824b50b4503b2b75ea6f67178d01d79f40b9b948fbf6a110b1623beba9865efe0c9b3be7992252f3e845e62095ebdd65c11911dc06045b3f2ece287ed6b851f4fe5b7117f6ca4c34dda2ba51d0695d838d5e423f9dea5ea7d917107732ca3929849891948f4abc96c7add73de98c834bb2c745296655524005da5071db2dfe347f5ea181755dcc764a5d708f110a9fd03e9b4eaa7964df3b0786466fec88da37360dac7d2b26a7b19ad9807afbfc5f9dbdcf488139a40a5f64eb4c819ae2a75a6ccc08043e0570feb8c488b4eaeb35ad487a5418917d23cf63cb9287b2762c4fbd42de097349bcb3e96d456a4c4fbd35c7686c84f30a82c13266ab0785883246324ebf35de8cef6162ab324e54ba3391768ea4af615676fd4756a810b0f65f5a5df792165feb92a043bd53a1724591d5a1a0ed3257498192660e3dcd67a6f8d20aacd632286e99a46b5b42169d850d734c8807e7bebcf5cc8036c5f8f17efea49b67742190b41ce1f8e95f90644f78d9dbbfc0d9a39a3e1eba26f562054e853b6ec8cc94f8f046558f8da14157332d2fd2940b38ed41f5f075424a8e89f45a6482c82c3e96b2213aab95829d9b492a0e547977026654eeef713a9865113b1debdc08ae915ed55605825fa71bcf1ffc20eb9e449257f582d5b780f6cf9e589b1d5d51d24606a579cf23803a20cf0d3bef099c6c9d4e87f7e3f0b7de1d566393a9804add475fd3b43a33bfab5d44413e9c7a033138c597a2d9fca36255e79f78de3bfaff969b996688d2f8914f0d0334d602852e8e68c3a0f1f66b771ae1c0b8d6fd9b5d190621ebdae0ae22fef10c77c3da17eee24c63d1e92b3cd35bbaa111dad5dd5899a48f708fd89e1fd905451627a00c8ea85b0a86d83c3c8b22a0ee6012f74bf5685993a9a0d831f0bccb6c68ed82c4373283c1a45b412f2b774efd42a3754bdca4c51aaa84b8d9757a754f7b821dfd91c52e7c2eab12ed9f5746e1902bbccdae91f668444389552f3d815ea3f672f3477d147e4e51063f5db412cf7390054f2099dd6d6242108f60f40afdcef5153587ef23e93a2afddb13ac82680356d57cffea3bfa8b2e9fb1eea0e9753ef6940ae5473c270022b221fb9fe26468dcf2a14bc562080c1f2611421bda8d7bd045758b8bbcd5178a713ddc9122836862278ea12f2835e2f421b0c673ff33a98775164f7bddc5dae3658f19d67e03588e2359339979d0c1f81c78d8428a00b462513454f72c02c521638f523e1380e17b614c5d76c4e98efb5132f9e2cffdb349e0c4158137557fd66a1df593adcd41574c0251709315eff5503709c08ca6b3958fe2e977533236a590bd23da74682978f621e1d185c519c99a937559ca39d835239d14da5eb17ccc0831c6211fea945dccf3e2874b14fa154b688f30d1aee749382d352614d11418fcb72f196ca6d8aff82a0d3634af0122e7d1a940a5e4ad5e8b16ad2ef972d2056fdd9b580edf02fb1f892e50b169a1e23382ae667830113523fda24f190ec7b1f380ae764184e506f1613ca65465b2f49a6a67e43b1cc3fe14ad389010da2a33229ed8aded8ec70b685d1953709daaae815cb388a92637a345cfe088156c50bf6c8192fe1da04aeedc7df40f86b6c99a8876725042741316121f55d088e7fd5fc3bf70a8044d612dc41fd12ea6afb2e2fba09c979efebaeb730594763711bad1eebd97b25fe906ef66fe7a2ba81d931c8ea7feee8f648a0728305e2baccf02d87b45553759d198af9f61fe35135a08f52829b055be5baa81e3adef49e71f5651bb40a8b95c9d2dbde12cda4b524c192003196c8ccde8ea2b56500707588c2023c2353de583498de4f9e52c9a5bdf49d7a399de559ba8261f6881f94b174518e3378ef2d793fc7828de8aa2b6430ec76d7a9abaac9518fba33c527a2371c9ba30d181f8182ae3940fe7e72c325e684ce3572eb102c602ebba641924a29800eb963faff7b2cad5dcdbaa89158d9699c70db3a7f69fd08dbf640f42d22683494c6a2d5ae63a03b3b5a4166b1b790f4d469f9e07685427e64f8ac0e289dac866f1d2b173ece08dc182675baa761e78ead84a71261c3365ecca71672a9462746a054ce84cc964209db417e6a673d256fc6b01dbc637a3bd0fd9764d33e8733d118e590939c4bf4e597298f81b349c4afc9122b1a0c8d4096645d2fbd7a3d5f1d27db79ea4e647ac462ab60c71d8a5708d9a44b9d8ce1c986a74ff0b2729dd69eaf1010e1b83f7fa2fdad0f49342cfe1b0afcb5a6f7d7a3b0198078e633256f8dcc89a63a6c4e2bc12a6efe6acfd7b6da2fa0052960220e1d3fbacb04978581474abb14afe85bbc58e22ad106683f1194e254b4fa26f788750755b00f2535b13664f3497c4eb9af5588bc62badaaa18a34338979ea7397c28b31c169eb97165046067e962a02ee8cd02aaf6ec2c677846e4bfe22788596382d5ab18df9acbf8494d6c39057c761f8fcd6290c0b98a13107aebea6db309aa144a3bf3226fc05a2dd3c1933e827cb6f4b466fa5982c5b0b6b9da7a14fcff9b10ad97042a4370d137e037deeb9827780d0cbec74d38cf71a9e86dfc5a06d050431f525b23a83235751cce739b5b06afc7ef8abb08ecad256d567e4eed069b1240b3b628fdad7e878c3aba45ca849f435a2086d36871b98f612d7eb50a49437ba0c6032fee0715062a34f411830004f4a091839aa5b04cd31b9bb6dd2f8bf493cc3219442b833439bde67d558f21784f4ae149661d04ea4684f4ee1dd5c3f75d0fb3033b5229ed463a8c50b7eeb944b1307eba5a341f789752e72e06fa8ecc9f085c844ff777d72d06ad5eb1583b634a5ac09764dc8acd144ed80d8c3ca8e08f81de63b57f37085bd369bd3ec55b68405423908a6401365a698250695c4088b0ec6bf376132c3db14a65613c577bf511b68e4375e90425ed97f3716a5118ddcf431f91d9119f6115774a8a7ce9b90bc14353090a1297489d3c0c91f545e9682c25d930564794ec5ed0af7070c39bebdad35b1efcf0b089d2701cee63091304d9ba9d04158e985641a2ada1e2ced773324aca0c54a356028e5fc6c2960ec412734c0f32cc1ff86bfb18706eba31e34cdaf2b2d78c2e1e41ad37ae92e4cd978509be790fcd7053e0f9965f696acc41d86fc30847e5793661f5bfdd055b0c845151665523c85c839d45c2ac6e322cde04598e367cddacb8cc3f43736d0c51ea67a1f2d617ac1b7809f58acf9918e64f8895396962201d88b5f4739338d93996ca44387c35c6c9dc0b9a66b235a1ecb957556af45b7b876f10d7e39e30250a51ab25b978c96277934e2f2fb1e6f0aa71acef407f0f2dbb7af809cdb7a23e8653401090968dfaec8e4cb4935e979d48148769342a0e9cd74eb13b0026549b7a1aa6c76b4bc4fb9a75a9000c28012b0ae61836da280b2c38b11f3b2a5ddee3123cbaaeb5acc2f5899ec09600816b59ec8cdc9db33eba13690507fa6c30af4b7f380c81e5d1ada0a5b2bc10379076811ab3ceebb71176e2d402048be221e800ae41eefe7afd1a023be63d03032297ade32ba80779cfc98742c548be5284b099e1a45cbe04c21c095cddb797f2fb57858caa442351dd7784e1e4779437498ec4e74ea5387e2dd149385c84a22af8b05fb0b36aa24beebcd9b485f852525faf4481eca6a94e2ef62a1fd17c0b885e73cfae208f9dc67f3464767b3cfe08a8b6072a68055b6ab2a23bd75b0b88f86964f599632ca643407e14e44abdd391fb9ae15139827b956794316617df35511db07e37b55fe18fe5ad321666d401abb4af6d4c9113daf84eb0addfd2fdf0af40bb9311a6772f0181451684efddfb44c695a6a9a309d6423ef7c4f72aacf5fff1fa337af516d48072c8c66508637e4da8bd45b432321874aff14b1028f2f5c811779f3d2325507b6f66685ea6d267422586b17ed3a37a528118390800ad7ea226033237816db0041e269bf1b0a9f58daba22962e0c45c3b6e0ac2d9019d10009f1aac59e24e6b939fc2ad9dfa5bd4388d77289a5e4abe6005e74490de89aa85f34fb2e8f9e83081b9e4b02b545ecbc17881ba1c139a2b0c1f8e82be05d5bfa2ee041050ba8490a551a4ed7974301269965004cb65ccfee6b21f16ff1d00cf855ca279b81be1c2d36da6c4cf1074c71fc81b40e8b941c6b00aa831a0f7096c5fea05e4a9a66ddd04f1c2921bebe95c3920e7fd0d2101f7d7855766ee4fb3bb561d544bc07f5c63892ea8e276a09f676b8fc0b63084e7bb5f35cdb85aedb7c50fb179c684a5230593d4090ac1c8227711df798e95d1cdcf0d8586a22563ba0e9e4e6d56953c8a4f42af339a28fedf3f98a7930535fea5c618e9d23127040ed819b890b7d26bbbcef035c93a8481fff4fc3dfd4f24570c41612682767df21b88c0192c8938180497d0cba566f5d860e0e5c4f2afbdeca7f3cab5d5e410976d17c24225512c8e469fbb7d12b5509aaec129421fda8aa76d0356bd83ba68724006787a33d74867a9119d14cea8b904a5d835fab8a7e96b2925c4707108c4781aaf9a2f628bc479bdaac986beef4e824b5a65b0fa49b8faccf7a3f7f4d817403a7bc1cc4f6092938dfd883a7624657f8175fc62d94046c989658642da24fa64741c1ddd9e6590e6f47ed8780979ec6cce57ac46a154662c743269883707161adab0f995d795df6e71bfe1a8208c064c7d444f4fb301e966cb0c8c6eb7f7e9bbc4895baf1fad9fa6a55ae7e68c126aa62c28acf4cf1f64790e6d885962372cfe632e0734d4f89cccc4583139733e02852b89d87f4b7bf627b0254874629261c90728a4d378a7630e87c463847e18a20853ee8d5433334c26d4aaa8e2e0e703d578d9c0316b37a31bc413cb680733e683f869b81f6a05830c1f075c38e3a289cdb16f179bf02906cb8b127f0a429baa5bfdf3e575a269f83d7bfd5980dcfd9e83e399a31b67cb3163c911cbf3a05d8dc4e93626a8f14c5877738a6f17fa17b44e545c6f20976f9767b020917c4f8f6a40ab927e248c32585e303755a3fecb3d73578edf52271381ee2290b3ca63afb31c0be240f8a1bbb934c5127d17a9e275b66ae40313f910196de5b25334642e188091a5c4b91d70035e2196e9e2b689f59f2ede030c011cb42ebf895c7c0da0b224a92ff4a8085eedf881cf9d2bb4fa0dfffb6580dfe43bfbd12a7aac9213b55519b441fa67fd4676fafad04423a1ce210484fb7105f014c0290e6459770063376421b5536a79538592e312934fffcf493f7ac2ceadfd0ab9c50f69258f67838f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
