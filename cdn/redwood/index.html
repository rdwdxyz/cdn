<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc5ff54121afdce73551a9e466011fd1b3e20b723ee9075323735a57907028ba273d9b243f286c068fdf4f4484af832cf7a6cbe45c6ae5b25736df163a3368dc6112992ae1ce1daa334c14ccaeaa7f950b4bbd508bc1fc99e963ff8195a798e639adb7d98cd7567c889fde905b5493f098f2ef46164336a9cbd45b8b600a09c902d4c81a9198fd587728d1d5bfe2fa045e03c28b8019a2f64811d881136b83e70a3ca9e62446560a69a962f4bca31ec7baaf68af85ebf146f65d3725822838a6482e371e7a50b72484a47475d1ba02c9a22b1cb2d30ecadef14ae3cd7dd0de307317548b962df4646590685e57852e83561774997bc6db6b0c15eaf1a68ddb5be28529f2cc99c6d784175d239398aee99485e7908ab800964bcaaa454a37a3135726a0cfc386161cc41f1e9834befb9aeb6897fce182403b1cb936acb2dc4dfd2e2889d8b69825c10513041718f0624b0b0d8707df59016fb7556fdb428d2621f212d00d9918b9f8aeae21135119aac8727a5dc58ebe1f5c85733b30567d753fa5598d6c42d2fdc6146cda3aa09736bf5137f405398df19b86b09013a98effdf7f5d32869fed0ef9841be064aca5e540fffb288b571aa1e70c3a6e35af07cae0f1645a993fc6c2156bda5a5a2b118d7f59acfcf3be2546fdeb0c3953ce15e5a07926132ed09763624d8d4bfe1436979cd7ddea24bd159df7308ae0cdc1ec0cfd08e3c4a0353a82b54c1fc450a2f0b88caf5eac0a2220640e34d04251a6519f907baed2677fba437608265548adc834f6358058d0c546eb785ac13992e0b6fd1cbaf6f2cd4c565a7be9b9bf9e1692f4b93c53e66607674b11d3f6b479202a2080863151b0055caa4ca83643d5e1ab016f5adc624da3c5299a65b246f2179f45910780ee0ef1b59285e2dc09df547b4f2ec19577e42fff6225bf1a2926468b2efa9fc81572039df058e408facfd2cf5574f02202da94615af08b32dd2db22041ebf9074306c9d73130ee9ac9a96d96ae934385581a69c4bc962aeac85ec8d007bf941600604959b3861138ed7aecf8ba8a0929888943a0c91795349a993f5632754313627594402a572a2107abc45e9242a5eba4f3f6538bb4819e1e0c641a3abd3451bb1ef495052474d9b4eb3b0d9972123ee5a035fdbc66908ccca787fce5c17c9fd8d7ad246e79aeac3e1e64a65bbeedb5cacd9a04e5c1a8ebe01cb992c88a5ee9f65924265eb202848c6919a9d12fca7ebc1e11aa691938f2d9a16343b096e1fbfbae8370c3e7d541e0d051fae041912b48dc96a188ae0b589fd809f00cad02844aaaa249f4d0a0f20bb5cc69675ada32d6cb121497b4a08a22c3b4d5577af2f514c2324b92607f8d828ed6e072b80d9539386abb6b338aa2d57ba8feceb76736dc71acd2be4de0eabd027b49e6de0c175cc9d102560d7d96e9f7268e39458d9879707d74e40fbb26b7af3500920eed2f6aec9dcec6e1a979be048eac8902faf5ae1b74ef9af92ad8522514acffb495d001abbc7665e75604a9d40c0431770eace0aa11c5f78c0bdac0de6533a0e361eebbedaea04036e5cd26c200fac741d7d5e8ade4edba155b187953c62acc9e31d1206f5cd1aaec6ccd8097406861bf8001209df9204d6fd70fbe7ddd49de73d5b5f4b0e3f933fc823f7c810b686ded3b20f73780dd5f2649d268b3dde8f43aad19110b76275b0de7a9f50d04735e8513915572f45e3d8de141a2cd4d96ff6029e239ae08557b4f5a5a8c60f857d9e5b8750d89be51b032fcfa6f8be193fed9d20c0aae7cce025a7b3fcba75d151d1c336f0fa039ff1943572b3b51baea97769592a34597fbc337c28b08ee8d74af5e075afcbc5062c2f338789aa84384336afd2bb7ba7184d78f5e08a6a17c8dc9b8ed6fc675288e2eb9b53df4f40aabec39bc3defd379caf485f861296b7390c2ada09663d33cb73883fb4fc3a89c526b3f43c4a1763e2fcc452d43e54bf33fc95586030af39b249fdc279962286297f8ce001ecadf2955e7fe41471e2af6c57456e17d7e93b59539af851eac4025629464d4e7cf62924334362aa317c5ab581f6fac7af8eb49d4c92c38d81eb5c2fc9c12d38087e91eac9f6768142167c1ee2ccb38ed36a9545c7d7a6fe71a87a1370facd1b771e03b5f563d5bea5ffa38fa102481cc0db06b0d34719f01f5aa49c0416bc6ec07110dfd1efae2dbb2c78486e2c10a1660bf3da69bad4546ce58259a30ab80bc61e15b3613e08948bbccdcccf123932f9630d317ba57cf5c99535c4f523e16123cc8d86e301fa63e72e30bd0de69ad94c167666da9e74ef750717db1aaded09da6cc75dda88188496400de33e5d799d3ea862d4b91047b302b4e822d9d6c7ff3f5894a796725663bb996ff622836ee64ef65e7cda4671ee76d2f29cdc1e38b4b375d84ec038e70ebbfab5bd4bc0e4fd0b6a9519461f7f3516b6f862b4f4b9f70d00aaf47e17b6ad63df8590367b6cfd47f1c1c2c8cf814d114f682ad4bd2b1133874080a21e66e07c45abaf0665fbcb83ebf9c8477409c78e28ec0ad244a3aa71e76d37795c136fe0225ffe6b01a06c907abb13f0abf103fbe32354118cdc144f7da9b2f301108e1ab4dd40163371c833887e34faebf1b9a9ef0265ead17c99e941f681394574cde7a631e4d7dbf84e4d3df7ad3bc1d41eae268cca5cba11594a98219da796224f1c22ff1da0fa8eaea29faaac75d03ea9a99007ffe806c8e0d1cda8ed27874f9d20aecdd3d6e9ff998644087691a452926f4ff7990b469eac68f5e2e7b63ef43f86b1cc1525d521192849f48b7c9c200ab417a2dde5b0a7c493b1776274c383c2f34a9c1bc2ef8f18ce44bb3e6acddc0602589d42bd083fa872f1daad5ab25a49ffa08e9c167c4672de6fd7fc49ae2d4e1e6cba8efdf7366034cd8fde4a3ce639ce32aaadb499a2c321103806d650d193f84fd63c935d4de400814c85c2ac92e32166cb7a78328dcf17b140ad1141cbd0537cf7d9edcedd3af2a9285af49671a93ac9d73988f3e0659b7f41fd4ac944d3037a99b678c496d6c06578f174736c3cc11eef23b47a851054b191cc6b472a424241dc2cecb010a6254fd87f5b59fd13755f49e6e814af14feb7d048cddddae79eda64bad9a7638e1f532a2a0e7692f2cbe8b4a22a131d97762850cce2dea8a55dfcc97ecd94fb5169777ecc2c277612d309c4215f0373d14c852a46d5d3cd17d0a12ba1aedebd4a783b764644a2fc47168abbc6f5edd25de18720cb172ff398dc30a3987a41cbd09e03a6afe9ff377d744e1c33de5c8c7977734f5bd7a0c7219973aac2edaf128f7e612d7ba873a2d0ebf9cd95c8e9aeedb85be14ba3ce657b8c1f23ba4eb07e7b48a153ca17705896472cf1e555cc3b67aa561432d4ad8bfa0519c8faa36bed310916216f3b2b0aaa22273a909f0f9c8fee7ca3a6082e00eded3c369d83cf9688187591edbf52f61e194eead88dc876e8d9369375b66bc8446f81167b4b6f68c9dcf1a76685cdc3ea6e8bc6ab1c38e8bfd8140ec7ef09abf3990454cee62270d307f1d7bb6fc31adb79f484b9695a0a157ce3a382a292601f5ba10e30753a4fefa52a10699af982b375fcb4b459fb781771c452f88c17ed7ba638b3823392358576b011f95998082e468b7126a2631df9aaca4a3f8a003be6d8ff36e6402bea9c25c141b95326530bd09a92c1ed810db3e215b9d0d6c296738a544e6cfe38d5448aa81263d4762cec91c2586e993b854e9f0e1831d6b3a45605b9bf49f201d93aff4a975841c4998521be8d885900600b1d63f9aba129ec3b5ee6ce53398b8104b8ad16b7eee03e2363d4d61b6d6812900138f8c75fafa73b423da1664f107a89ab93a5cec37eb520d63ec9059a6e4de268f430c8b1c4cab96222e0546eed61eb4e49dabf29cddb6c319ca8dcd9458f22f6e7fd628c15a77f3f397e34db2c34fadd885c422e18db9d2826681d763ef77ea2609098cb884e71af997b2c65d8ce58218fcb41049c2deca78ede62d434dbb8e289b31919c9e99df64eaa44463b19349cba803e3545107322429a75d8a8c8f12dbfb792e6d642daee4cd4d07ddea05a347263c6d2803838da829d70f9b684c927a1c3b203e23a4bd27c5eccbb08d5380a13c1beb7d94ba0ef9ad5b3272e2fda32b3cffad484ef563e2cfac78041db778d3ba6ce81bebce7025090b35d554b0487b9e4a1437c546be02d5a5db143958b4e1595d5b43f2fec8e8cd19a3bd15262887cc374a8eff7e35e0e03edd0028abcf4f0b9f762840e091ef9d61186d3a166ec74f86fbe02e571c5548c17bb8b75bcb7a08ec2d548c2382445ad6b2d916c12fa22e0f094593b19945f5bb6968b3fcc4089c364f59e5b034cdc81434c045d351d92aff5f6f7bc9d811611eb1eec0f2dea5cd83bb4ef5bd6c8d2601f49747476a04493bb6d6a90f16ff03c592eac9c8750b65f4336f473ef976f8d8e44dad2db9d71348b0f50e54fe7b33c54065c12b4f94dad87ed157fc3abc1706c02bdfed3f1ea63b500e56c1f202657ed6dc1cfbeea63c2f2ebba7e55ce2ddaf4716c5c87fe939c872d5b86f1b44e16dcb8cc3fe9f256194e1fa7425ff32f113a3aaf3dd1275c282b8feb52c7853f2319201e5c84566f11c2d49ab62964369de3c69e5bfdae7c33b7048642c584aeb95489464a11ea4d691669217aa0fe610c1126be76b4c928d6f6efff505ca9cc2ef192fe8f2eacbde229f9ef97c84932e2f490c8ca9b6b9ab7ed2280b09fbb648cf306c6abb222c650d213e30469c25c11968504d7483d92a8de818b7271dfce3e5e8026d7b5a5e93d45d29a2d5958779d1d1cbb49ba3238a47cdbcc696147670ab306e1d621d6aa345102b9e7a8845b64c1ec3b6c888c74e2ae4de2bf89bd6d8251ed576ab47146335326fb36e9b9284da6aae63f0a5c9f7a3e1230b6a32fd0aaada1d9484bdb5f65b1ee8c3f89b9eeb76e536a4d0f52e133c9528212996743f3b5d2d5b83628156604f0986bec999890650ec5ac472898e4ec476abb062ef9556e8b9c22d3f3dd405876b1c29cc4121718cf9c9d6059a8cb8034907da08314ef12adaa36846263687c8a347ceed0a0715f1d0bccbd8fd0cf089fc9f441e6c8a630fdb22e0a3c036daafd89757b9a707a8eb1c968a0a0bc35c7f7e7bd44b4ab99e196fd459cb233a8cee06d689bf8b057ca7b4f19b79cb85266dd353bb587f4a19278335c802db38f673dd8c0e1889c3da06883100e5b99e64eb73e2f9d2a6bc7379104b596d8e80388c4490a66d62c675dfd578ccd439631a16e803bf4d2165744a6671ee37aa1ff7c498e1b4a7bfd24363dbbd274828ac157e4fc5ab1dd0cd25890a915b51cecaac79a04d16259257c68de4dfe3c4dbb3107ad8e1decc6667c42cff62aebca47bee160eb96ef1209ff0c01e4c1b1bc2e77ce2a7197558974e3dc4dea5b65ea5bfb62d4bdf5f2eaf822528e3a0c0699056ef941ac0808e82696912a8b2b8a3269fe857c4c19c506636837db270c205d9ffeab66a1d1f3bf5bed790cf6b09efff0b32aed0e3836730515edc304126ed5f460066b23e50ce7bb876ee5c18de133e4216bab82408444f9654912cc938ce2941e69c95edf18b4b4a5818ec98f1c1880f3413d02557477eed60c1a193a5389068ecb7154cdac114c7e3936c29c1e2e2e7c8bcccfb73b7adfa335bfc3b9fcae0f556953f3f2861ff92446ca3c9dc63251f5118199b407f44e1226683ba95b7471eaa5e02a39ad90ff2cfc42029e84319fe83b3b525578300f82cda5dbe691e6b2d72835785bd725e99a17568bd2d2569f935466f667351dc9b8d051c4608e410e2b065682c253147bc7fb1583ed1fb46fff55727b53acf688624548d0d884587d5913926db97793d2db51b4ee11f54f31f5ffd4cf7f9b1545f0de05cfafbbe4b2b5edbc404e192fecc78e92dcaeff3387970b8b43e3b5daee24df75e2ef5dc530be695f1094023d68556f8a7f83e7f014940df71e0806bd1624d3da565316ab1c96b7cc777fe49dc54cd8d965542e9f786fc5ee6c4e8e889127ee06107d8a84ae3a69dba5995e02c5fe7172bfe6c3ed96ddf9fed62c600b15f5dfa0d72be426e9fcac31d59c2dc09ce127e81ae6a3783250b1a41ba88da226d83c2e3a2a22d0ec3e978c83b3f440773469fd6cf3041f34276ead575213d9d7777fbbd85b0f1cac966b7ddbbe219626288cf66186236286955dde76441b40213bcdb99e14685c29c6906d7bc35d8fa69b6ecd5faadd906130c6857c5674acf6ecf6c73ca560992dd212fcc3c4925d14f8bf8da0295752165beb8da493f305681ee2180f0feabcb0962608e5ae42b0cac29ef26f80438c5ff32df8de29eb3eaa3f339d9c14d96f0c5cd35a9b78daa1b93a4fc67bc8729ac66b32051005b9efed73d784398ab03ea28a9da59312098acf907784adc72da970014d90ac87ca091a6124f0e466636c253eeddd870a706c6f60880074d645bce287500e15203f4ecdb599762f32cfe2724e6356a99504b9756abb5fd1448c09629b138bafbae9945713fb8318caa931c5eddfc84957ceb6f7b61e77decce18831005dee35359bf1bff618552e1445e527eb6bf1ade8b1d67bb7dc11195cc2c896bfafb7239d5d25c72caeca1f6b886253fc772aeb56d3f0f0252e356cd07e08fb1a7a486f7a079c23687372d66521b577fd2a347b4e873baf1c87ed3bb4754175f4dcf1845956c282778ce21a99e9ed0e858edf5f275e5d3d2100944c150a980c815a5079bee5610d0b592034e0f630f8efe2f47dd36fe93b4552c65f4422bd1fefde8fe1e49bd1a7fe88d4804ec51ad8529e0f1c5ddea37401a9a438756b644e7cf5033620d2e5e59fdcf228aad9ff1feb9e77d73b10c25f8339aa3d6c2dde1c07da659900468d5c18475daa01478fa7b4b4024851c53878f075e63229ceaf8183f89e700dfb9a03348ce728a331e13bae3d943fbbe924bb5e82c91bc74bd0353fd987c42fe16620e6af1310a4b65563c6fcbde3a727068aea92ca537782138660e9df2f23852c3b7434da4953dd79d9290e63a36026beb7d6b3f14fb19bda8aa3484d0d1767b7ef9ffd6d0c0a37e6b7817d85002b980ac9ee1738e454fa0db271d107dc8c84b06fd2baf944f3a9b33974f4369bbe9928c54736ca50866a1d7f0e0f85f3ba9854df58fa204761a4ffd3bbeff87543051589327d8faad53b7106b591269e706ff1d73da880ddd71e719f75be245ba47c1fcac03d89a92e57743810c12683bba84a249c6b767d632cccf43d5dc3a83e3e7349f3ba76d56bdcbed253e08f7b09736100f43bccd1acdf2d6063415d77db84482feb5800d480c5954879fb9cd8db38fd97f3888e3abc3850de209d8433ddac773d6dfe0052702f281863e9a1e3942b568611a9b024289628367ae97f92ef7355d0b851f0ab2868341f3f24009df98633a8786a37903f83edef84bc18300ecc0784c587cab7ebcb7c43b12d549ecf91d1ad6603b18500d801c63e00f114c90d3630e8f1858c9dc0905af1644175c6603c1f616eaf0a1173706b0e76f89b88cc45ca3628a1f380069e71d94fab299a7f351d7ce6ca0416cf3db241b39e2276b3af6152e8167bc007ca25dfaa0ec9d78c72bd9d4a70c0592500f1036a049f363ae5b9708a96d6f7a5f447f69c5dc7b70cf6c0bbc7d36d009095f62b26c6a6b99062575595ea987cdc602a1571f3729422d3978fde76873f3b376d06426b3939d4bb5fc5de998bc3f56eb8a21d466d4707518ef6acad6270ad6929452cceaec411b5d0ac2ecc6f05121bb971526ab397c0c948d64cb1e560b4b38244fadb367367f2c9499932d33c1530b17ab7c7cfedcf491192b76f4fbfdead097d3780782666c73829386357b668bcda2c5f8b91d5d0dabd3ba0a552bcfe71ac20d49c1d1b93c8719657a61ebcbdacdd48d746ecf727f09f2b83b07937444f7c434de829c3f31036a0c0da87221e51131afbcd80de8948fb9e6165ff4a6d97e155c48618529055c3d70ce4017bcded4abb2e92b587bd2659895d9aa81b1fc8a1e2f6f15ec2e2be9b6b521293a2c71914b2ad2752610ae3a26a1bf98527ff91fc94f3440c0cbe5cdc597119a98fdaf14138a9984784bc2c211c756a073d61fcb083369fca8f560571f88d769c48d606224736ead2baa639b031023c08ec4a0e2e00e42854e835b3e3afba3607e3ee9bd81081e5bcfcb7767746bc44c86b6bc2d40725d1259c5a46440139b7bd1c0f0e97916ca0832882d267ac42d158916edf927fe3a284d2cbc0e25345a421089a004af63232920c136d52053c87c59352e9c644a0312ac32ce3481d610457ef679caeef318c0543657e82623a3e78f18b269f60e92de4ec86ea3c2b9321ab84d977cb5d59b902461f1216285991b7b13d358654245698930d2db1044029284ae771db8d19a53df6b92bccee35bb35d382ac690785265d2f7950e045446d4a4a0b987c1f6e63479e00dea0f04e027232d1ad02be4ebbae791c4ffa4bf862cc79e68d9e212c2457ca10493e819e1c4c62dc66d780c49cae70e55f48db6285669af1f91bd41d179e9688a267b29225ec423305cabf16a9e82f80fc474877429272947bd8518b35ee410372903d561c912dcee58fc43eafab357be193bbb1cf9470b8de7f75507c334be4f783823b145ac815f1b65fc12ad94d9115395bb06bbb28278087ab93bd48f3d3f33e8e41ed3e0e35a04379e234fa1ddd3f63e6f18bf52625f6263ce5a9db1dc58452049d6ad3bcd2e51be09b662cf4a97384ab189a8c6118ec2f19e767e6448ee02391444950ccac53b7e8a7bfdca3e436b35536c1456c83cbfde3f7ebc722b52b93f341520ac4c8a05979d3ddd437ec720e759f7282493616318f73ae7e20f037b7b410525646d59288359573aa133b7e63bf7ff3f2d0f1dbfc52bccd719f84f056913c1ec13534c14fb49ade10929003b855abbdfdd7cb10df9cee8efa393b6f66c62abcdfea8fd50f528e1fa04524231345ef76ebaabc550697c4ccbe62b205c12bdcb67f37d50749939713d65c3b22d1121be1f168408d69e6e4902084c3b67563eccc2260d8ba378aff9cbd6f2cc9fc911517ca580980c8f01e494334a117ced23a2a19bdbc51409113e8c1f23a51a094d8799908d5b00412fa9d85732a790eb9c083d2a480e2e301323ad4c6e2fa99fdcbe04ffb117be9fc2557c241c417ba966624584bafedf27c076d64f349c4199c11358c63ed0eb102432e03833ecf61a19fbe0f5b21838829b4a91a80208749def8a43be4e401a91d987ad187cf0b14d181d81108c9ee4ff2e18d59c52006dd37d9468f9214a704212da315a2049bee119bfb4d1ae454b98dc6243a455999d782e606f0ffdc5a712ea78043e76c271ca78331c334fd6c74b67e8b0a2caee186499991d5a4dd2dd0689f6d46f38de378638d837c56ee4a9888486e83c04377b2ff5a6594a5902df53f4b6a4687a37f6d4be9d9496e0d8fe9412decb547995736d2e7e9808b602e57a8fe2c99444cad93b368c7b8a2f173587dd2e64ad421256f5ae44aef3890613210a310b83f544f8bbf00e63835c406efdefc8a5d4773cce507f7462d3695ccf67de6e08b70e2250ad59dd1061f705daae537421aa19a153e0e5de50370eb2a430ca945a7e1da987956d6f2e90a124e44b9110f41b66fb44a3090f0a18c77749f9484ec98f487d4638517d93c42a3d3d9c29c2bfc70619b854cfdbf3609e5fef03cb9b61701bd93702d1cfc4c977d3700e355db9230cae3bf3b9c24ec17990e58c12a451182c5cb013260711e20ba29ade033cceb0ba2d992e58f74e71151de79e6d69e8505626268148b35f1f6b0f10a77f23d565201cb583bae1dcd4b9f2334f4fd8ed1bc11b7a4822c2923fb299561ae9ed6b5187a753e47decdc995f5d3ed0098d13ce2e310a19c10a2b011df0fbabff3253cd02c4a1ac6ad0a84b7f7543fa7de222846bbc15dc205f51ecb0fce35a9a9c651d71188695755aac58cc33aa0e30fd54061248aae548a0e87babf120f84dd31b124bc2e3590f26e9de60db2cb3a4dfea951ddd0d1e92d4c4c105062c95ba6d52d7567866268225fbfe0e631bc206edfa831b4e687abead534fb9085085e70a6dd3af7a6ec9cbea053d70db285a8f5e2215559696a9a0ddb0857100aad77f2d4be2cb026812321a13df36c0ee78bf87d8234849d6070679301bb7c72985184f43cfa20d7b85e2e7a84c586d685ff340a12105a7e30a04dc30ead1296dc2a917cd4ed6dc0730dcb2c01595ff38bf399f4e1c6f67c555d5caf860e52898485070af9d48ba0f6230866e23bcf67c1f53d7e39f5aefd514342c3b199c6dd17b79cf02613d1cb6ea23b48ff5d9d8d58cf22790437b552e1edfd812f2bcba056f68a8ddfe51ca99eb4d4e05ecc8c786a9ef55a5ec1a46641ab257004f8c2d304e6447c75c9839ee81f69947991b2058f6f1e4617f6a91c2fb7a11e3681d2fbc14becc2381cfe6ecb502a52b508539212fa96a9368184cb49b78f3b55c92daf3fdc192cc3a173ebf925c9c8185ea4015718534e8d548fa36160c9be31cd7a317b08f5581425bfbc1ce5013336d115da21bf60f1d7808b4ea3c493ded435acd0bd6ffa07b013ee85facd30d4461feed9f06dd9d2197aa4427a02db9249ed2061b69a71a7b5558661e4f511c571a903f1b8c4f713e7d9cba4acbc979b6857bb649def9661b02a5cb8fab3a62b3a4c47b05c54f888c3ed09f68be5f1fb6e6c5912890ad805239ea0f447460b6d8753765b36223a9e4d14638061c231d3977098aa1e12cafd2dc53df8a3b3b697de44023e74580733a36d390b9162d61afd6aeba4d2606636ae539ae59be596f0944feb832d487a3bd5e77fee267f7a501351cbced3878982b84d0966b6ed1be08fd2c8ce5e96b30f06fd6ab022385193c76c02061950b23de2946221a3b1648aa332bced90b553a5597220104dca9c0ca28066c2c83dabb010d1727a2054b50e60191c341cbeb31c14f00449c31376eadc60d2e53ec1a2e3f3dc71167d100ff5ec8cd74a9032dc1ac81febdb17c2ab9a4f125f021a1f895266ea487282810d6cb2bd6541d1e7dd01e281fa19a3c56f459ee7d3aecce27c910f5052a3a616539130076e5e71a072d197550278faff71769f4eaa2edc9b84b0bb360c48f0a4e6fbc0f3ed454eff6342d9933fda338c6ad29af1e8ac61e09ff015faf047cfe1b5df40d3b3598b3e96efe1daf18c164ce9d12070c44514b6dd6a11357ecd4ed95b21a91109073222392d45f634e1d119b3b950e23a354300e4b613b1a324c500ec7438d680f0afb859276566e0a0d59a2638201800f3befb12429125fff1e4aafba399ce01cf38e99aea6034cf7268cc937ebbfeb5c037ee2ebe0e28b7df9d95590f681877f4cfead3272e9af3ece8e9799b7071f0e87f1b36382b7297ba4c27222ea38af2afec0bcba0890c68359062d9deab3f0f21ee58f10274c4eafb59c380bab7fc05332074bd41b430c363a7aa21abd02a8651ee4e0d26aaaf5338eda7c547428940209a899defa0fef7c7d9b9cabb9c326bb6b790e69512e5a64c42b302e7ee216066393544d8401ba07ecb765ac80298110b0c658f3024f0f564a3d7d5340770d9a503a113b34b471d820573098f7381b0aa8335114b46ddf96fa21755c4996287848db8dfc65ef459fe0399e753e64dfa63191afc529031d6a70c81b2ebd7efe8ffbc9011e4b4f3a2a23d1299db4a9e97386a2aafa6f215e1137c18ea135071b0791a710ef880b76e41dc897f3675a1fbac06b28024e95293606fea35ca8b899c98d29c3f927b4c95b60cb3b404812b21f925ebb31444e24348e4feaa073923f3860d615a3f3a5d4f61846406bb6e109f9de1a87f20902adaec9ca7aff2be8dbfc575d675b7a8c72d1e51368f766ed35f31f83fcab5267d72b0387eb830f0f32d51d53e34587c21c755224ff476483a0c594faad4f488064af06d5f604d37162d4c08b45ad77f5f4b2b38fea2eedf6feb33b06f82780d167146394fd7ddd79bcf0e85f39bc6e5d6e45d278d8d1edbb5eacd6e18b43ecf180c6c95a2bc8a225bb4089823f098f45afc1a14a7878b7c86312699878221c118cc620b48422ba4bd8e7ff8eb3d740592356b1e2d32bb1e23a6da1538669db357f96b61541aca35d9e8be1a2152a48ba26e5bb53484bc33ad91348ab7378b318a88dd328673ee5767e5902007e4680f7ad62f06ed04434a9ef25a55aa9ad875a0305df289cdb44862ebc8fe9e7e2e712ac0a6bc314501e8a9072ae54b509ebc03872b78e3dc4f1c1301f4372f7606796c447d8e5fa36b20b3d49d8458752812ba670f228cdccd5e6e099d43dc73434c4070d2f613478d78f576a6f84dbff66449ddf1b1ff5f8fdf74128050de12ed00c7d5e33126153dd851501fa376605128540bfe5c860911ea3125b6dc4e85179d72d2551fbac25993107a2692f7bccea06685b256e089f0eb112b1ad2bb87102215e0edafcc641d55ce7439377720413c584806fcb1dd9e570b3113bc34003bd2fd090ee0b82851fa8f635267c84ccf47562c0437b9e51c630e051ca232d49ea5201f82b840b9f4ffea1d6f6211676440bfd875e54033efc9b889311a27810eb076e7c01a82c5da0b969d274c445aa6343812dee1ef16c68166e0ccbf4a8283567c66eb5a9621462860e8339c15634d268962fc9fa9f11ff4fd958dd51a6b7ea9abf9f243f292d48a0cc14bcb48037c814c7eb27b5932cfd91dd6bf2ffb9585edfb54124ecc14a9b57cc61500c2e33d99d4cd5978c27143c57403e4a92d7829891b9ee92febe136f4c37d4d7de6a80be9364363f88267895a3b5c267378f47274bfa40a232294abd6d0c3d378858bf573d446ba8790a158e74ec18411bffb8ca01626f1e39957b5d76b59cf5a270ef83656c3f5edbaa8769bef8b0213450df401cd337c50f26e44166f9ecf53a939aea7fb6094ce94a2170bf13a991a6a41126b23337d96bb13619578bc3e62530519104c56667237f34a27f54ddc862adaf51b5aecff5f8c66e179fb501468289ec2a9897cf2a97864943d0468aa873fef51e953ccff0fbca5b560ae8415da9354514a7c1da108d58f15a4ec40b423ba8700fdff0de86ed93a803fe86ae584df4a0df7df5d47a93dc857ecd805eebda5e66058e38a2c78458331378af8d06ced11fa06bc02b53d4bde9da6079d585893a8054747653128faf37ee97a15e5281411b576e830f99aa9ccea17edcf1237cd7c8baf261b585d73f46d5f44d94eeb6464031966b8ce5bf717390b40130b3846325ea3629d2e4d25ebdbbe03711c4a3d63ee2b1ca8858843818ec3c7f840da25721ce4f36acf0fa9a62b2ab879c36a29bb17912de2e17daf60aeeff46af519d2747b94ca694e38c52b1d3ddc814fe2fd57d4ce1ba46628a4d384b4f612cce4e427f7ace3be1c9b16ef11cc150374d1fd774b1df1d7cf7ab503297ee28638ddb0d870fe08c3a1f29e4ff300b07f34de61948d3d173284c9dc68f0d48076ca747f20ab938abb364f29600206b7ee576eda647cb309f32067abfc39d7257a636477db3445e5fc8bdcaff178cf8fe7819566605955352ae8fdd1db9ed1f9e7d7d832f3a7d6de950fecdd7e6f7982c724dd9d618e2a949a78850e7105942321c7687367e4c538f826c1b379b15503ef12e2f0948f42104f5fb6c99d4706a2ff91bb92a771b172aa857e7f565d7d4bb948d00197a7d0afd563ac6073b083b5dffeb2e41980b1ecb4817adcde1a07f88cd7afdb4ad5aa836e5b621db2f252ee60f75b4327be77f3efc8a1b430898b066d0857392593f2374cc134abdc14f7f0e65103546a5302493562edf748638ccf43ca768d9a5360e89d2cf76af42cd7ea5782cf5ab853f4c77f7d9b44ad5c1a5267dcc4440a0e0271604359e0b56b713062c8d3ed4341ae019dfc0d0525c33ca1714cde0dfba9aac9111a6c6cec24631ea1c4be0eb8f9b61f0b00a2aa6ecccfdeb1ea2fd67a0415fd7e3653ca41c957a694bb746965b71aca5f01e876ddda0795bbcb334d9d4eca4488745e6e8c0d7b18e03cba37c79929022551a6f71d8c4795f494352c09c5291a35228495938dd3eb7e84960d999469e57d9765065b4f4cf1c675c61a7eea50d803121d4e8fe7c7eab5c59f1c7e2bf4f893fad1fa59c9565b952fb51bb78e55ed9686c66658b6cd5885e791fb4644daa9cd35687f23f165e1c62b75996527c153cc5f3b9d35544a2eddeaa1a73318110d5f6e28c9149b1712b9e1272cc0b9c4b83eb101fc96f672f45bdd26ed9aafa44faf6d716eda71cfbb32c45722abf9e3e559cdbdd344e47927260b5c56950e2457ab76077f9030cbf3b840b0c29f25416a23f4b715637715df8a070579400432c2e03ebc65c5be4fb9f5e273b7df9faaa6647d7b456de920a306ac15c126be81ca4aa1669713b43c84349813b52215ae16d54604af2979eb887596e44bc842c75ab1bf55f3f71c9a9777276027b2949a5041d3d4779bc25c0a61be38c74cfeb6d7351fa0a4511c49e97ee0346314ffaabef84d67723a69b414049761771c817b3d6192df59768c2f0a41ecb668774bb56ceffbd41baceef0a48f6679ccec7d0f419b0154cc8df342dedb56f47e2b9ce6e6efc909403ea12c3109b32cc35331e87a23c74fdbbdfd49bb590f1373b608ab4c073221a579185cbd2cced2928e3122ab10011fd3eedbabd110362921bfda7e7b0e14438dbbb0336284f32dc4b6cb031f46df457ad856ed043fa665ee90c683e90926ce4ce56a7859c63b6e89a67a79a59a5a80402910bff81a412e0d2a58ba9554486cde2a87a5fa644749ba4bbc452d2996de2418d37aa9c3109e6c7a346c15c8902065778decaee7b645e91cbbca588d0a72b237413e6883a6fa960a21d888f1381a4d4941babfd02dab382d877f60a8d796aa2599b2a4373d4598f1c788db282816895bf4112c8b4c54912d035acd3993fd6f44412d1e74321a29b9865f66edf392b7d2cd9cf36e206b84d79599bf9faf11252e27f1150bc250abcf0800f325326e977752b165d9e7e28de4a36b725b6ba7e72dae8c3aa2fe6b6ff7266cbd9ae48dc0c2fd1e6f05cc68b17c4e1864510b620c94fa5619e90d7bbc47773d8021dab3a3227dd0e77e9567d52a83ab87f3f82b2a5e8dfd9a60089be71ad64815504f842f631bd7411e1d4c958e202c4789bbad7dd185133b01d4941ed17198947acb393a62299c56c1df97865bedf84e3b3c18c96b97a8394317dceb0407c779dd0891db422fff34341df1a3edd8540889f738f7b3ded7bf47d65d5abf52228896b5088f031263078cfd64df557c1d48c1321e56c5ba0312590000e7fcba21439658f2f1656c20c64366c06e183f50537260300aef6bc9487a90cf14b033d3c0572e82d3c466563f63d834eb2c09ca72eefad27a67b720661898676cbea6078a7345c220560e73ae65f72400d952acf7e14af3a18590dc817d25dd96dbe34f37716c8b2982f8e40ca37c706a349a58ade7ed581ac14bf7ffbe0b583d6e73505fff56231102f734dab2ca0eb545fdb88877c5934268ff62d0465f675386b331fb2ac8a0cb3be28bb7603edecb377f1e43e5520270fef25a84d57553bc2e0d4ef9910a80e415f9405fbeeb9543aa6313a488ffaf5935bbccac999915433e1a34d82d0c756211d8e5578ab253f15a22704857cd7048c1b814b3e859667ead71dd7ceea815ea8b25485f07e4a80cc0392884b412b5995208cacd35ba230f0b0dbcfdac44ca13e7777a7a7f250c5efdab2c954cd10ab25eb7aa7d38091a7ecc8ca707261190ca0e7fbad4c02d9a6b9d6d558b60820cc6826db3f9aa280989b24dc619364c82d8bf797031fc256756b99db94e10c2a7c951a8d001cf520f866abde1804ad563effb6cdfa48b64d04ef0ec8f2a65adbef65b2052051fd580c88cb61c3ed4538e0d65060e99253a2f7e8950a78438ca2352fb2530402f4b936b70dc128f2540c20c6e097b203f284d73e840631ae47914f10592087255ce594f8f875cb32583ad997528c8a299c6479fcce4aa5d38638880908543ac6a0e1fdac07265375e81d5a4c4da778004c60fcfe816d64121c759376da56f675d89efdbe84417f9abd73c07be0b364c4e48a4a8a8e14aea9714dde3a00e40eb53c949ef241331293335ce9ee196a7755ba262addfd49f66908a09c071e4ce8e6189c614d45909730283114303c5fdd1180adf4dedb7a910c847b963ec18494e00551f104135d4175ede65dba67c63b3efa8309aee3a7992b610734816babc2fe40c0012ba2547c83c4bfb9e2327201e07e552bdba15c5e215b3ebe9c4a617c860249845d9746b57b0a738f3342134db8b3c56a84ab03d19680c2364b80ed7409ae51409cc10824582b3a245fa7757b4b5f0d734d1537596c347c18a6ccd72ee5c670ded83cd3a357aa8b66f21b1c3984e9ecb1fd4002467182b619a82dd2405bd886afe89066a17c77969083e1db507c72ca2edc2cbbffcdb339340f232cbda7a3e134f3b8c4974dca155c8f26e826a7a35863462541595781f7eeadd5925944686f3d06387953e0690075a38e173c0b5a32fa09cd1e9143a9d63ac159b7fd498a99ca13aaea276d9f8e6247084249180f52411e5794b8131342bc393a3a1649ba2dee961dab2add4e412d1dd4594bbe5e14a8c04c720e4498292c3d746f51d920618adc0de2dd982f66ca86b75fc96502a25d6381ec53298030bf790f0d9c1dd84205992af87b9c8fa449b827c86ef9e269a0be559d69bdad7683ecfbb634468826c2fb9fd822cd43128f58243a543d9163a9ba2a1bb12e5d0735918c9016973037607b0cb07d828c1738edc311f91c1850ac98092538e401774d2f78afb6faaa8f89cf5ea0fa0df64d1297450f282038905d4d07f58458f1ad52333de68b2597923509bdc66c712d278eff63256e1321b67373cfdc17049bd375e20b976e6383c4efc6341a47c66cb96f121693558e48787d8809a5034a5ab8b4c3257503fb17dbe37c4f4ffa50e18494240ab2fda8213d8c85614d0a3e95b7a7f68218c91e7daabece5e2210a81c53ce6c1a37247e6d643cc131f908fc45a4a72e03f15b3cb8ddef2a75ab3bde181f7f73b720c6caba8683eaca0ff2bcdb71053c23a185827dc34b28293a6128615c046883e93e1b60ea38d38022f779064366777f72cb62e4f9cecbd67c17ea65491a6d3646ddd47551fdd9ab2f2ad9be5a1edb7fcab050268dae07a43ed1dc0eda600fe0846900f9a0ebf3684630e5babfb5fc11be6608ff802a3b0c4656b7284ee5f4513c7fe62c17c96aa6ab517af671289ab76d09b086ae37bbb066dad83556fb59e20de510d77b719bc8a6f8fab0b96dcb0f172d6d47e106e6449ec0406aa00292504beee8650f9ceb68f79838fcc8a1b2be5c8285d761e64edf90bfaef393a96ecbcbbab552f1db7d584cd718b051936076b33aa74d2147db8b1ed6af3635201868b130135e0c8554d492e0e9af2a2e954bff86721b0db1f8b469ef427cdb3b660951f6580526f9dfeeec72706090c9e7a50bcfbb9acdd20d523478a49e13be64f902f2a9a432693aec7d12fb29780dea9f5a8661471db0acf60d45ce95f17f3be2b06ed09365a0e99bbc0ed32c81e44e75518d2a8c00a3274ba04f5374547de7d7bf685c1dd01d3d4a90630cad20ee4d90fd5e8f6392d200f1b7c1a9b0cdc8a8594f3589ffb4a73e16f845b9d7bf8017754b17b761c1a433747ae8eea6a5ea6465886b9089892c3d34eca7582036c4388a1613c731a19faeb07778eae1991581a9cdb5be849de3c1b08a13dfef57142bfa68b8d914a79e2e5ce1f2a7ec15dd46c09826c4f7aeb492b48d80a9cfd2d3337330e5466d4685921050d1f312aa7486148545725bf4a67ad86109276cc62def47c667ca92deac2b5afd6ad845a56ddaf3b253c1a0db9cf21257c45f98a7a801339349","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
