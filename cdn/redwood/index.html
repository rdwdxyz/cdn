<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4569cdc43165148deeb8fd237daf1c5e75664f2e9695d9858ea373dc1b11b99857293af3f83099560efea3067ab41c31ed3a00d6828b1ad5ee8736f8603fa6dfe546934c43487a98985339a790762071f2874c0e0d7522527c360585c0d0da6c5142ae8856ad155688062f3a8a9007f649848bc152d8c7361a2192152d678f1583810fe249973733939b766b581f429956b8a258b934b02930ace0e4873d75a347ca67fb9be2f43a7a862036205a47a603f69702b45c7688825d0fab3c9e9d0f6515dd95a03b3c906a00180a38bed4edcb4a007c037065b90c167e3e69206d96eb47bb4d17558ac0a8a6bf855da7e98b971acd2753312ef33caccfa4d2dbbde3e340e8895abebc50191be433ee9aba537b04c33d8c1b9b3da56a48542343bbb0ef61f73e6e24620383086d64da6e4b6723e53428a15be790c3586f28724c4ffa12cd9380600a2f89f04f51df31b85494029a957ee90bcd85d262566f6d4cf1250af77058603ba434631479280fe472ac33fbb9abc81e3352dcc28fb3d2e57d1cea01e949910625c55ba0c77b352594c1b6ec6104913112abff3d87669eb8643eb71bac290a8b769323a196925343f50052a64fc07c6107c3d684510a6e3fbbabd743babce1826042d4c38fc565547bde7c33d5e51f0fdd773d6bc10c32018dfea90f5c93d227adf8906a0243bd6220a15647d4f313cd635200c56cd7314a81b3cbc95301790fe55133c79e7608a6918d84d446a231f0211cadfe3e6c3add629d87a1f895b209116581f2bd414dcf9bc4d02799028ad2bde0c9a0cbe07c52110001ffabe72503d9b7aa0eab954ae0401c68be104a59b46ec0cc7c5e6df9bd26b6162e22c503233c1aac95b169b978bf940281de9aa1c7c1fbc62a6b2c2be0e58e03f99243c8bebfb348c099b8f9cb127cb5d91e498ad14393d0621dc3f05ff5e5702b54d1b67ab9b6070e4ac97d09115350e1b5033071dec210dacafd3b4c4c5fa06f7f4875a1564e2e27435408699dbd2dbfd9f79cfa8ff962515732df926cff81b0acea4d1478ad0e9c02e09fcfcc6b9439992af8e2c3d14c48954b099286a2801cab30ea792cabedb01e9a964614fe5f681b9c6ac0d02a1bbe7dec0fdfbe3d4153f31eb6a5cb891df5e4f8f94dfcdd42f6c0c37b45c89ad5f65c57333da02371b65031c5d70a53785fb9099684cae03a39f5967b927c58fee93db3db9df224eeb47f593926aca569895b272bdfb035cbe173e40ea65c6022b15a4a64dc28c25b1f8b528f7d28c424d10c654e0cc4a0a3e250d68eab145e788f5fca5073cc9fd1fa69dd4a40f601c3826b4fe2e6485d2997997de6b27d72fbd2812d5ac76e3749d81447f71d540eebce83d169748213d90a968c9e308785ca02e6fd424d87e901683e2bdb0d7653bdbe1f02b38d5927235f3fa968aa2fe484a43ad088bf3424c370cc0e746b32b603ffeb54841643da24f376f5b9c279a86d2c2ee46e6d7a0947e17cbb87735ef4c8bb0a1d69f7fc6cedede00233745a46b5180a8bef32b0fa46f1b30447284bc7aa8d8fe7393f7e336a97e4552faa0dea283005ba71d9b5aa2957c67502f2ea65f8abbac687b9fe9167f62582f5b210d55f4165855389d504d002c675e30c5f95837e88c344e48a333ffac92df8b458be36306b661011eab0a51250ce70f1ad022b0bcbe895646fe518c18025572dd9defac53bad5be2e3d337c256cd274654a4d2995eeb47a7acff8b65d250ef9a69cf149b77384d8ac6ddef51bd417ea7115317da18d83a7e78daf9a863b6355f84b2b901fc1259968f488f711eb0648855acc97fced06b3ef7dc4ecbcac3d93354981a5c43b70f46fdec1f06a7b7f66261b005a6d7dd02f3e9c9c47f3f609eeeddeee8147f35edd37c32196d2023d8124cafd3a5c953313140aa188ccc13601df56c16c57a45854af9d43b8ba320ff1eaa4bf3273e2b5ffefa83c669d6888f3f44553b0f33eb9b1f4542235aba240b80bb3e6144e24a31acdb63c75793d62bd9963e522db8cbeac5d777ddc8b4fc33ae83cf9230307589ad0d9ddf0e79f2aea04fb9cbd85539e63d419e48bfbf43fd6f377a8c1b42a33459e8c9eecb82e3d7db8a026e066afa35425c11e0bf0ef5e7d8ce0b1cef8fbcc295223b3298ed7ecff4bb0f2bb37080f06087f643148fbf1f4f773c16e7359f3d4dc1703cd806a353229be417b1968e3b457880785c381bec1424c35ab277288baa54f1754b41397dade86afcfb232fd8a8b53c0d61818ae2ae47955e509d3aea674c752db5700e79e8c4ec9ee3692d60f34756b4cf0f5ba7db97fa4830d9b40e93f8b1ba93758cd106d65d73ac7422420d584bfd2552bbef1b552599c385c7517578d9a8523abf2082407ba25d425eb03e7bfc43f1a99d23e96a1537daecb6b9468ddae09749a662b300fdbe3f37b944533b9cc921f843d14554398f0555a0be2510f2408fafbc9122a52ca17b96a72675e81d4368afafc95e8c4c19a69eb79328d0919bac0775649ddd653f1675a3e41ea2262721ec05bdaa7b69cf619093921530205e52ac391f1317600a32ec85b5c75122f352075fd7ff3262d3ddf6f4dc8eead342c7b7c2e58b5dba9fa817599101dac700bad463c6b515d9ece01e03c219e98f576dc42b445fc6108ac4c2d7f8f3bfa37aeafcd24f31b8708f7f8fee177996caeb4e127e0d04a1cfdb94ce2dd465da6c187ff923af12c139b5300cf9fa9f4ae8a8e9257cf6d2866c877cf3da2495412ef8fad37207b6d4618ca1605ab708746dd4edccafae14e67deebdeee436cdd5762adc513d21380b29c8535fff383f0e003db984d06e8dac9ab69e008990b807f7950ae15ab48dc9bf5878d7aaa134c2165fe27b5d3edc68c5090fcd1c1f302c9f37889ce7fec2157361b12932f6fe0c86e20fec2b652eb9285c2345883e53ce31539165b6ea34ed06f757d7b0df14545df8b66d032abc251460e72202c195daee0e6f58494839e60d4acff814d92a7d9dcfa85b828cacff717eb9343d5945cf8745a4d00f0266d66e4d8aca0c7bee5991d71e5dda900af346e36a76a1edc702bbe56cead1b1ce1f251fb0da1c7c8a26fb724513cf12f516d7d935ef49334165a58e2223013b6f77f692f05f2fd285ff3dc56eed270adcc6e8c9e5911923211cb334e73fe98ce9c0f8a3d22a88c77321a2b8141236e9793376833b1e7d8804c20280d6fcf5b1cce4c96fdfb17b877926502f7e985f38a83bed5443f17eb9074bc5ced5b6ed3ad7ba899d8b5d5c1c09f66068ec351b3b0d62ac2379aab04201c85b029702913a434f3880f872a308cb75a2593a73f65c69164be5f96b0edff6d2f9843970315c07a5d23ef3486fd5e31745109e88916ec762649bc6af8ff4dd9b4e72dd1924cd70a0ae6a13edf27924552ff5c452d592ef9cf8a1a15d7cb41e8271861897664257404d2acef3fd5229dc4fc855a58e07c72ee7b39a9d5be4618125139d9b2594f238bccd7ef39e729ed7c6e84060d0e0dcd4b395e978ad8cfa2a2b3ab45804f8379d0eaf1842517d71a62d1e371dac1e97ab8c5ce1e37a0603621fc3892f55a62da51fe964d0a91289fc017b2a7e4d5f0f586e01af3cb3f178c276cd6caae989020cba0184d83b23dc5ad193e6f892d1603afe6a112a4986dd115c122d6f4063faab42a478d36ae53e44c4f1701375ee3d22c5582d43ddb1df5f40aab9619c0e7c0bdd55bc58493e2fe701935b1e6510300d35837b7d83c7021667b4206f0ed86b71e3334e0209c4a25c8b0e170fa14068a4efce10a2b08a7d836e547be2d780ee791a3c2ad6a20ad3f43a735c999ecaf0736e81270258a7348dc2ab0ab1cc5ed544f59f036eeebbd6907713255d907d616c25d8c48646c2c66f849ddcf494fc3e911a4dd838053954b1fedae087f14d8e0d24a5b20b8fc3e35237aa12dee398f5bc7d13c4210d00f3e69fc955249d8929ca5b79de7b8d01fed6bb6530d0891d29824c2dc5d3f0f9edfa61c6bb459ee01e5427257827ae65fb051fe6e4a8b452388ddf2955086ee81129291f2aa444666542dcfbdd0afb353839ed6eea19d25a31b35ed53c7c0e43f475c0fc475b83818297b9aff60772b61192252f0bec5ead28c0a3d8e513757a2edc199d5f26e7112d1706350c6e634c4ea4ce69bd336ffd7723b0d25504a006d95946fb73d961ab32864d28e3c52d572d459180231109c918464eba02a59098832f048430cf6f6f57799b5f1a9a0da87ed2eeebb650c4d5b6167ccdfdf7491a9bbceb9fb03007edeb0cb7685218b6c58dac642c446f3c8d143148a5c7ac75aa4e169b336b922d9b08f974777b16815d77bbf0c7535c0fae45d1fc12d7f4402e23653d3d55dd5c7ab1d4146eee879463de944086d6bc6599b4d9a20b4d7d88fb415961e7795215a85869d8f83a634b46d3eacffcacb087133789fdb285747f0a994c129554ed67b65afcaf59384b36968ed49743037ef0253f462f453087bab88d47612fd1e2fc960e9230a5c2cd557fd3e61ed8a0029997fec7feadb2048fbf56b607dc298bfca7dd975730455698b190e9dabd9fe0bd42a71c4dc34d14c052f836b5db4b650f89174d017ca058a999452de0235258a4e0416fe6129acde12203f2a7436a680b925168a0d1d89ba88dd58ec62449728d13cb7e22b66d6c3362bc9e12a7bf6983b889cc9220542b1925d72141cae30960afee4a9dac12bbebfec85c9c16a4f59da76df87602854b586a2418accb34fa5b155803393b1869a7c168b0d6383aba2ef9ce3bdf4dd54ecb2fd8cdfe305b014ee060ce11ee797d321e59a8d455ed1e5810495242df442b5273bc14785278f1bb8d4c463378a94428ac5a26b3c7c9cd78ab6cd3bee2748901ca1febbef547fdc98d844abc7ca3010cd8b5cb1dba015d091cf6de7e86b7cdee6be934b03aa7a09730b0fd2afda0e35b56041a388c582d7a5b8d63fb47498b8ab6fb447a99f27caa9051f139431f4aac3696d7b59fd35ebe051ba296197b10b7a634a4eeece3050631d3faeefeda36fabe433b165a160c1606937f2d7d35873fe8bb2c1543c3d87ad612828b19b5cc5853f6e8b679106c1b30813ceaddc8ec15ab6f597b6be75dd01d0921bf149fe4549810756589cc7982f1f70bed2ea2b2259607a59e4de27d82f8e2fd5e103d9b972a3be964ecfc693fd3f805f8a441ad39630a0ad4df735adc1c674eaf73bbb1798bdd06f9ae6677c97d70b1ad516667968159d8fbcca66a0883f2c1066673779fbf61f896559a4572409e130a0337428bfc7f4293b9750abbf7ca958d6b7a7c202a3abd997388cf5efe7ed40f800664e7f74ce156a5464a68f3e1fcb00047cd3c46b7fa62868e3f1d9efe0267377be77dba794ce91ce0a21ce76acb2a8a4d580a9e8395c574b7cc3dffc551926418636486812b6586a979d22c396f809deddc29e8e450c6f918912634d770dd732b0d25e2194e47e125eac9ffb303feb59d47f100949bb544078d4b63a219cb0014e07af1f0fe2639909a3a035abbcc017531d4e8784ad21afc5393fdd6fb9cc3ba1dd570f3812c79e6646f423a60d1a2d8c9d2ee9a9aaf92ba37d6a06c1a06a4391f8e4cff1ff5c9ad570c915488172a4ce5d8574735f6dfbdfe65e4065d013c8d967a91b38c35ee178a1bf3d1ac22b1faa8b6c9c23da2f0ae5299e8bc0c739ffc2981f1fa00a18117120b787f2dc8fc41a485b761fb0741adfba995891397c93a5b3dca76d4393a859e456817d42be2972ca53d4fa3717f68fd6e2d888d43b6832eaf9dd6577d9eda4d892199df2b4581980f43d242154bd2491c552861e3d97f2d09afa2a61f7f991e9c8c59525a01172a1185730f9985c6fdfbc205f2085a1128692ad5d61820adc9a274f6dea1a26a26282404ebdcb8ea15a3a85563d0219efb64b95bcb90edda6485f8c50f345a813acc484eb6512edf34fe6abf8223d01e6a6b98c7ebd2f9721d62cd9dffbcc7ded1ab43fa505a86ed76f22f8aec3cd57dd6878e753744d9a5a77bd61891bde31ef09b6e54c02f316bf3a851f976d600b59230d498c4d4cb074401318c7b2e35172b4ed05ba0a1077b6ab9b2cea421db50345ff8bb2e15137fab4af2022767006739f7a8f77ed29ffa7e474916d7be3c7549bb861dd19ff68ba5d9c275e64d3cf0d706d6515e637455c146d129a6fabf46dfeb6d95c101ca492c052bcd2651e14cbe1f799ecf5a470a5d6bde65c94af2b40b019efbeee39b01ded274e094583aff44f633d57ddac96319db47173fae469fd6963f6ed06c36580f234cf3dae8364888e857f3c254ce0777a4c3f31ceb7cd8b56b57d29453117e1aded40681a6fbfbfd064fe69150266815d8fca6f834d5c087ce9803f21ecad230fae64f1e986f34d4a1d7297b222c94e443a27bd3e66a80fd860b0d7ef9fd2e16a96c05162d8092d73c6fc1866a4fd37d123d65428a5dccf167864a9e20ef558988989341918a5590af67d2fe8729c4733c80f65799f87e5bdc53deaa3daeb182e9d76c6dbd7e3b4a41a03850b1d3d76244b809f62175e6ce688e0afbd64bec25138399e566b9b81a5cc2a75836542017fdfc75865033a68be9e540767bd43f355792eed336f6cf2f901bb4265efc9047aef5b735af704787000c16bbab8f8c3e5cc5d66fd15e096d5d9359eeab28b20246e6d502ba508a6af836d767256adeb6a9d8c22a0f38cc014db27edc5c002db752c2c198a0b5030a9491b47e06d72b815f9ef27f40a163a568dcf9cc72847218d3a70dc1f99f16141f985807a4594da5da5e0734e5d66b33a9d4ff91af47eeeb7c876946ade6e4739a5309d76ad2e95f2f98b13a2dfcef7dd2fac14577442b7a474386e03477445b23083800caf67bd9d8cb74b863a8886222c7e0ea9fcc9b5a2c84323afa25fc8bb77098abcfa4b0fc77460459d9656a1ae08489b6e300540613bd5e349ac90228a17c5fac940a21d0669e2d3ea3ab353707cf7e1419a9b3cd8de1db1eb70e9465e70df747060fb4e0b10b89c8cf13dba7224db763610778dca499ea654a9bb4db582876fa86aa5ac756c596f4076fa44c8663e6b0d06ca2c9b48d8030817cafbe3eeebba01f7862c86f5e2192bb43423d1eddfa394ff41b7ec2f27e5702749ec66966615389f2236c9603fcbbf5ecd3a144c414d89c7c13e166e0b67bdd55ffc2c5f9f1eadffe25e1245763b3f9b31e4de27cc1135cd6a153e930067b6925b1e230823fbf2f982b250688a18a80ac0bf51ca9f0e294459dadac3ec43e645be8f3911393b69e89e49b75d7218486ffc9f52ca4ce82d7cdd74aa64d6dddd7ca6a6ecc31635d0782f3308d4686677d05d94ac471a257378f5369b53d801f34b55c1773beda324e520276444c04c3a451207337673efd5ed68b120ddfc0e1cda17068d386b83f2eb7f7590d27b6f56bc04e22ea1c240a5cc8fadf3d18fdbad4d769cd63c5f889a0d7a047f00a881920f29cdd95e66b7da347bee3bf37d91d058329ea58cd259cd24c381e820ad4ea1b29b9412172dd7233493b6ac8dcc0613fb0674477b1acc44f1ab850c2a574be1341d5d35772f34753abef5dd295a4a671b43cd72bb4592f26cf758b06b69de38eaa919392a431849ec5a25d6751fdf90ea56129619161165251360f3bff4a18321a1de2582d555eef65f295e66453c4d599e18626cfa8d495e6bf1e78b0c7cb589292790c4de3184373cac2b8b0bd78c45238657e39a70afcde9b396aad44bbc8727d0a6a3ca052c8a97af66e2fef3b7682cbdca0ca6ed9651be2b5f0be6924ab4390b3e44ca03c0efd0ce2a3f68029d5b2352f7762db9fc673f41ae1540d265ff6f31be20928a6e922683b817701b43eea63f7e7e1c0c1155d16ebb908d02876ec0056c752629de711be4ebd212131f571b34bf52ec7106ba73d7292bf9e10fc737b4c646afc91fdc75b059d1225485975fc08692b19b741de619257c6bca6dd209261f42c52e38ec74034bee672129d41fc4b7b8fc44640f6d44d6caba0c8a203ed7767a0e5f3dff99179e55a9e899a7fd72b4ee6ffbc3a1d1126c637c524c7c70b7dc14863e0c315ffafdb5b256d3acae36053e2ba3a760afb20b86c7f7ab2a049315e3a31339e97fb51f0bcfbb8f7bbcf4c190a1839a8db293b894abd5ac66de174c92e4d543fd8086c657a89e7d5993f3233bceaf038c93c7f195fb8d51a8d74405e476f6985705c499e0bac5df1b3dfdf5d1501bbba0f3f43d2d77860fe9a0fae428b4dc6e92877dfc204e1d7e44b05e1c2566dba18ef6d2ccc243d7739be84fee28666160b4a8805148a51751c2d3ff361e9e18cd26bdc494936f951664489db08589097307942d491993db6d5b6b4ed4f82aea9349024ecad970e9260f5d7302b55c0d8bc46c812463990b2fb1dc5c8a962551081aa238feab3e080553913b184bfbccfe301e60b3b6edab4c6fa1617c227f5817193c7dce027d9edaa15f2d05a6926e4430ab6fdae8e600bf3ed921fa6b06b4aa89ede3248f9b461681b5b621189b647541b713b653995d29d44385d0788b0314ee1007762e4ae5e0e660346550cfaa7cc28fbbbc548bdb292526046417d01f867d575b916ec9d5f137dd09b1659cafae3a7f19fe521c32c9af50c722bc4a1c1aebd478e4c15f3c298a37dc401f1ed25fd8aacb765a899765447e5ccfcb2a3bd9bb2f9f50d6f668ab72802f26cf5315995666589a3232ff1163df4e2df713d48c816c1df3a6283dc8664cefac1b3bec376fe584837e047d154a65dad83a8d5f7566148ca63d9b79466452d9f7be55f6b41bd58740790992d0c15b8808a0cf9e668fe6ad82bf2b30304b8125775bc1d498af56da5add32bb52f190983679c2a8b2a9cad4f118c32fd6b36c1f53a4f56358f9690abbf3b102fa2ae66a0124c6c1aec541e8478d5cb20bbc315293238c8dd20e9a579d1611bb21154079728d5ae870e2f3df5ef5eddb7bf154aee2f325e64c048d6aa10547efceebae907d6c1a7e9614567a19ae43962bb65b90a0f160d478e2478c6794b745875760b6e5c7d86b89ffeb6cdcaf14a26a89e1634ad45b028f761215f249ceb9338b8bff8bbfe7e0cfa4dfab2e273b3d2d6882367c502a1c9355a2174606e3e26722e563df9f2f3aba9aba6b93fb41aafa645145d117c97cb5ca6710ce93449c4bf8e20faba857bec9a4addc7b9b6418254ffec569757b9d382167f98059f764c230d1d7f335afc83707b82f138f70c61504a582e94a7c2974244d40de650d3634c4224c016624843e14dbfee85e3ae39be902042390da85beae8a1c026dfffea05e35f53915a0d5577b7639febf64c1df3a6c87b017c4df7d199f966490ef5b294f24f1f12626bb06ae71552665e96dd175b15783ce83b04c7ef2948557f13085acc6b42d8f3ef8d8cf340141aaaa7f1b78a4ba11751cbb80a2c134a29907ebabe79e3a75093ffb5bbd39b63bf3ca77fb871c9ff8a9a9002d5e72f8595b080230cef3eb8452f0ec4ff9732bd2fc05935932e24c3c80e3cfba6887fd6aa5b7e89c13b983eb3e06690e007af71e42c2be4309f6fb61e991f1c10edc92370a10b2b2008903aff99a34b0bc53ee6e39cf2ec17ff3cce02f9aed2db001dc70431559d2796bd8d9d8352b825584b76548d191c4c28de6c511837aad3ea258a7c8244f91ce08e5dc54baa216adcae8497f0d34727e0fec2e1ff288d1ccb9c30c41a6fa80cd4c50812bc714b70230d66b8d1d606043bbd6792be009486fa27016e9d7eec4ce106f12109a8c63755571cf759c25105892ca9bd830dc3dcd3f53c6df975f392174c9c878f967ac7fbbb230223aa82b3c28a2bd3e7a8f8ba5007f0a4807620442141af5a49843f3c25f854ee1dde0fe4aa9bc32e514dcd9f03583a74d29c4a7bfd0e9d47e81ea49bb4e6ff43a74d4b82b21f0c03ff1bd30b184e7c2f13532ef0910d4cbe46ca892825ba2f0caf46c86b7837c03e639a3c8e6f4f36c73008d35ba93af6a532abf440c5be2f039a146b9bc4b08779bcd872c4f8eebaee49fbbb9d5fbfc15c3d3db6fd8f30789c649bfa958a0d39bc1f1968fc93a3878eb491948e99480c36d93e00b6d07f8352736a33998fee99971101874caadc754a7c8ef006e9cc4077421627755dbcdb5b801926cb3dc6e11b36548a065e0b0dfa9af7874af6e94377cce8bce6838b27ce3364c2a948d417d90b9a31547d07b10c4b96ed8a3a1f84613ddefb008cb78c4664b294e12002c532172754e2a834897110cfadf06a815e793c703044af3cb710609b30f95071931af4d2174a0dff80bdb3356eefd7192b250bbb7ab65a182c1dcecd4b410648850d00347abb3912a51564ff78228213bc70091248dec06268ef516fe62a81eb1b40fd7c1e3382f4c4cd191b3d68f8be8a38b3eb53277f1d9cce9d933951e098385631a802e3c5c42784c91368f4cc90de2c893b79069a4c98c6e357e87f710fd389da5f3c3a8bc016ea0db12b725ccb302a437552b6ee413d0ca8c3420c577ff4a40c62d607a15987090df381c877fec3b4f281c2ea95c783cd1e6801fe609eb83a4b69c4d6762e2aab50da8d3f552937c292e44ff8366f9040ff61c1f13ca71b12b4a8461b51fd2e8f0852e0e58bce54b585b5212771a5759dfbd31d5f23dcaccd05006a58c43dda05cdb425098e4ab088c434108051cabbf724b1a9541ca337b15fdc2496929fee8591707bb8483fc918ed5d1c408159790cc025518fd84d9d682c864775e061c2d897d0b9b703b4db0acfbdea93437cb05662fd5ae531d0d5eb9e0521d478834df401ee65d5a54838400236b9f26bc44afd87cdee5e0f70a6a93ed198891b311ea2a98121557780c1cae626fa834a1f155ede9dcb2445827ffc24a22b4df4a0d913dc4e5b23dfade01cd46f63608ab0fa74ac2ac594d0b65a18bef77b2a40707964c57e0a6a2138300a0f8304610e6be2610fd36d8f010f5d13d788153313f12b533a559e625552cdedb60934251a83771d27db35e5bb60e8a8f81e1a02990ead02e78692fa374354c94eee50e54d03bf0a916f4b0ad8c569afccbf960a6eaf788d898206d490b71b1d242168c5b6a383820e11a9c25387e96d45bd34b2901533ff61f971da8b3ca13e3ee67a11e06f116f1e20a9ac2e8f80e907c6da2518148293e0cb1e57c25bde9ee60c5945810c3b9c53056d7b30860949d4e0c50162ec5bb0829291b685d6b417d6179b1e94a1ee41e189c23410d0f6d94312fb61cc37f228122a49521b054116d43dc7b9a400e9f87f23c7f82feaa7582da5717925011a0d474aec282cbd10235ac105b6c1463907207932a03593b0c1ed5f7d84d562b9dbdd36a22872ade23db2524b37b3259a28d251b2f7442d507440dd60d90a0404a7dfe0d8021f5cc93137db6e0fda8f7dac69f8f8034a6cd7e28b70256442c405937968cbab4f9a91cd2e1670f92bb7bae2421fc78b579a7b62f7d16777e25fdb92b5ae1fd5541779086e4eb0220f6776050d7d1417b7ee4b699680f81cf1d138dd3a7e023dd1477ef745e48039b16ed172488869b6c795edba8e93108f36130177d41a43d5132117d256f6548b1d88338fe93b8fc350561ace9d83a42ef94b0d6e505e69dd1345471459f40d88f9f5c4697a99edda5ff8abd19dd658d95ca50c393436119484c14b6223323262b0d1c01cc5dc0d5b0f3d5653b444bdb9e1ce28e1b2ece30f44b53fec32776c90f2b7162f28b5e4a26a110a05ce54a8fe61265ae31300a89505229559ef3a24657983057780b764492172d2db14fb71655d93f96228c85848846fe2b8abac4e01e6fcf9e1b2173c753c3fcb8d2f74eeada03b6e632797cb8e7a541cc2d72ee6da523b2dc30b3fa41c66d7c5ce19e84f9ebfd6958fd1424b5e47c6324d2853c89029622e57b256c9ac63b9814b55f442aefcd33a14ac311a93214c414f3b69dc544d5abdcb73cbbd01fa7e76746fcd8ba48a03fae2546fd1c7b7fd2574d7f7135ac197b21198c5a00a67ff6971c83b7341c13cbcee6e43b9984320565a4a24a3bb57379be9e65dfc22ea6110e3bb9536e63844b9193a64bba7b2a67317c8f96c242e99a891384952f18ab0816091dd38279d5d62bb1757d59013242587453ee5cbf6a52716d49f81e30d853d42e00e2385252e76aa34522edff6040daffa8c165f37f2d7999ae97b696d64a7795cad44b5f67afc55394aedab5e45c3f252dc2c21f454023bb7238ea8475a3f66a4e969cca6d00b187950ad40c0cc8d62c66f9befe55d16ddefa44b643301c74b465ba79db99c9f3eb9f0cd0532af2c6292a4c33f9d5c8299b7ebbd63f604ec2a729de27d7518fc48c0c191b91a1d7e79711b46c4a0541467235e35aad7328c98731476580b88b77098fee1b63bb41b9be8461932261a4f84251f409e07a26f4d34898c270a9d3cfe23bff5d78b44edd662588d9ba5275dd4024d4c7262fcd1be1c8df71bb1397a6964553cc2d18c21309179951fefea76a09435bf493aaf1e37ed4664fd82bb165adb028bb6847cc075d91b0ec636a86f880c15fd3bf5a51afa606b2ce73624aed16634ec89937de5414b82129acb22c29d367e98f855911f3df9eac0436f1a3b5ecd334f640126ca22e8d5893792fcdec5a8c650c9299ea85b68c79488b7cf08abb22784f131b9a8547cae56a0206e1b7e4c97a2268cdd9a2acbbb270cc0365ca7b16f790cd34f5b2a0a4d9b2145d23d458b1451ad10bc736230f10c17a12523fa79c9c2e9493e63801a833b66d7a3ae8111fd1f1223bc04f273a12bd1ae64f1cba9de23b947f7c41c3e3f9be0e4fab2e6972afce9beb5f9ea0fc2f0280e6518baffa34da98145fc70bfcc8cba2b7ea077f82a3c2a9c809d9ff6c88361e57772175be2f06a9eb058b4cfbb2271539c7fd0c24bc1bb0a1af32a7084c1e8dcace1fcc23c19bb99acbcd46588ff9b088ce15aa21f11c760aa54421021476144f7d8d297dc84559a2ec1ef2cf10e298a70144496fb6427897daa82a264d442ec39d1c58b5aa7b50590e7c8c96d19642cc9effee11820b894bdba2965cb61f95f541b3ff51b152847398c352197482e10808e6fed71e539d080c2144c8daca22b4b9acbbc3eaa35c94c20717b25a45b285bd38fd2c7894b21338bf786b8e3b75717c0a082d01db3624e8aa2d44eaf3c1e726c6856124d8118f55e4f313d45df046baca0d80c6634842da2d19fa161b35de6a27236674df3dd287042d18d1f4d6b1249428636a479ff69a26ac0ae7cb5b1610562a1ebae1c4f5241767d4e2c8378d829d38504ae6c4d5450e5cd8f073b2a0fa61c9db9174874676477e80ba5bbc46ae41a16236f0b64bd86763ae60ca5494910bee69e092f25eef5ab8266b05322d63405178b7b2b60582e64cfd6260274231755ac9ff2b292b0372c02a20e3ca95dc07e7e090719cff1745687033d60c740f29b2180646dc297f045f1793464db79824b806e329132bd8d004501ba8809e89e371bad14ec3d12def78777711788607b92915cf5666f1fbd6a135739d9077964ee44ebb03a87f1511b8310495627a10f098a2f120283acc0811d9c247d10d5c7aa92fc20be53bd4abd4fe2f4c64fc0ba59083c2a9bcd693c7238c83170070ec1a97c7d97f8f3d3fb642b943a6115aa5af0fb46da6ced20fc4be743446a604f99968b01beb73770a8cf0c1bdfb38bef32837d007c8b81667cc80fde576bba1f3707114f157eff0dfe715f19af80d9066207b3e21be132a135c54595a4e597de02c5a941fef02f43fa2c36a344b3182db753567a9d16ba4c565f27ca5162dd397ac37661b3f0eea935f240a710f0a476861b1cc73601f61066e2a108932ff69c740498909d9b732cedffdb5109bb622b5db40d85f3b7067c3f40a81f1060fe150cc047c147ab88f5288de24e23296d8f8cc31e6c72b0472877ba018187083df8f86c3d2ddad604e1f5badf6c0c64e0254355c190dbeadbcdacffc0cfd1b647d80cee4c2d986e1f2cd043cd4bd02a9700fed13dc6cc913466094006f96f26b5c39cb54cedf2e96414e9dc6211395e6013943cacc5f3f02a5748d122f326b1596cc00140469c6f07fdbb12a5dc8acc7f0dd36dad5f089757ff9a50466aaf9ebff7a2393df5898f7b877b2d0be01c12cb523a192f10470ec5b49fb79861bd434e6c34858dbbefc83b12371f9caf008464a0e327a80fa3284f73bad74918ed8475cd132625651e80f5eed416fb87e3c4bd7b3e6ec7859d86640e1cc15640063c9770e22705773a3904cdbf3b91a74402051d5ad075340ef871ac5d9e01d26eb49b6e973487b4ab9190225755379d6a50dcbbdd9055950c1599ceb0309f84a5328820d0359a5934c05220392d27454f01790c590c3ab12dfaf93ab963aba00957d397790ee26693e8e67c958e13159b41fdf13936372d3c4348c2bab8d0f5341e608a9e4a0268160300e4d263a3e14c7d8727cb18652bf9cd32f47466e8a441254db969f8b947f3ff487e8a7cdbac8fcfee2ccdb200db7df423f16d5541a00c4306ba3b51ced077c568e716a44c8f2cec97d2e1a4e8196fd70586ba2e10217817ebb7b2b6f16fc62884bc11ead95bd6d35bb7adc549682b7cb11052a77f3f4df6148f9e3a903f08cfa00c4cd48ae01db2eeb6962786dae40b2eafbb0d0919ea899414d50bf3846221c777782076c08b0a416ac64fd2ff488c3fd160325833c1645c1c0e35935ccf59ededa4b6b895a143b82424df59148ab46fb8f5c3aaccdd99c0e636a1518c34c641e6f788a50ce138bc1274cc73fc728bc2b8a91064786a7eea63879e10a21b13a6683ccc3ea6220db879a2dc84f75e2773f8185ed164a408655277e6f1f1068ca6df9aa957e0aa89f7e87ee4b3c7ec1916441ed3c18d1760bd252d0b9fee98a0d02c2433364f0b7e349c0a46c02fedbcfb1dc1815f8b1fda019c9647b6074bfe7e948d8056bbd3a8d77c01b1b0e5aaaa18d90dac72a50e2064495c29f476b31296d60dc252341d7e0851fe67de730d4ac8fc410f2a29bd9ef11308ac01670fa5f267fb2f26645507e40098df685745925dc6497424bd75d92c8195f49467e5e075666af91d59ab79d18d5b176060ceb9660ba0b042579ae84331f8142c6ec75703a801a7556641ba4d044c6456442942cd7c2c59ab05e7abd94b07068fff85670717a2197804734dffdac641887a8346a802edd45de0923648ea4da12cba68ef502840b448cad01d0121326ee46b87bd011cc82fdfaa15b49170175ca7257f55aac77f8a0699857973f96934f739896dc8531a73af1e47f28a2777593ed1a9afa6872b66275062548c4097e938564bca894ab7e12f5630f589f197e7531012a7ff4d2b49e2338ed59c003f9261e2569c58af824f681209890de9bdee49650c5693361d731cc425537c00ab6d09992a3cf61c80dcbd41f9d63a1c3519a28b1b85e2230f49e62aaf7d7bf34b0babf7e470d369873220a1f16eac5192f818b650e6dbd9ded12a5215061b64583f4491408694d5d8204504474b0691e5ec99b5efbc2afab769fea92261ec967bf527e6b829c10f69e89a0d3490b8848525424366972fcc37776e54fdd47457afcce24e222455ac9fdb103228a1709324eea6e0fe261f057204f60a544e1e622fcf233b0e346bb81b697b8f092bf77ab78d88a08abbda74a2d718a8c32d849ec940f90a72625d6b8671ff7bc9162f8c9b9aabd2048d7aaac80355d89cf65782fed85b6c81e244a0b615a2e9fb344eb52b843cd77812dc9d807a359ff423a85d072a93f2b86232c3fc0236d1fa164c7f49f473b853bdddd00b996351587e9dd3586799e6e6e1ebf2b7bb9c20cd9ecf72f71e16f2e32e1bdb67f09d174659a93b0e1fda2503ea102c1e9ef611f4c9a3338f671118c3a0bbb8821ae7e80bc55fdfc2319a4340c26443560fc1384067ea9ddb8f838d1ce0ef68518c32d80315f3e791c0e3c9795512ef5339f53f5b32e3207e5d6d96a0e417bd73d8d035c07c456ce60a8e83b3376b4e7e6901c222d63f11d0bdd75186ce4cd5c4a43b3a1b93f6f936e6023ec68ee907be0e8e1d839d8ebacbf7af88496dd1d707a307cfe32f6c761fc2234a411cb4abe4fdc89307c92012ca5ae75a02dd15f239a7f5a36d6cfb6f22ccb25274fc4b57eb98315b19ec775e4f5d7483438aa610f2131732d3c199542572089bfc975c3778497e40c87c223e82914174727d50b2318dacd691e327908ac382afc023d98bd432038b04bd142f3b98285a6f97089e4f3e4c39cb22a0839db45771a8267de9b2463025dd4e402eed025af860e5b27fb43df252ed240f7a59b4daaa73408aa1e3cb48b2197220196705be87ea6c090e792ecb24e816064e7648d98eb8917ddc092d33313711c995609fb0aab242adc44661c6aaa2e61defa85df89f5e5cd7bcce6eba983c30a63e342512a6550f4d2cf4189c09f5c33e3ea5a08d0674a4bdb6e61b72038ed9dc0ccdb431883bb8f82a2b6bdd6949a0eb0d011db8e3eed32354e0ceedf186aed41df995d001b5e7ab85a53435f9373c933f5df1457eb47486f049c3e1933cb55e24465b2669b51707a0ad4957f9d000eedcf230d77d0d8d175ecdb852790beb7bcb613681d8b7dd32ec65257a79342db7909f0b98c8e5f1abf77b03e1f0b3c0e87793400a4bd4ec2f31bacee7401c6b7f04f43b2952d29aed6d9819038a9b1453e44a97b1959e3182e510584c5c08dca04f4a9f7443d3460784a7227e1c831d91f729a067cc5505f4881b46bbf11c3a9ced0b2a87414749a7264950c94e51f5e333bd982bc260f53f970dba0b6c125e9f6bd3f7c50e6c012e7eeca107219d5d9cad4b7c03fbc18a9675de9c69fb44ac2325e117b2e8f05fe81a7071ae8792e0ad91c5627819f62686f198e3c474aefda58576da36fc8a46b20a99c643a65ec4bfe691ada627a86a943b4956c2b0f8cd2ef51b9c8f917ef21bf67c67d5ae741847995f0d8e22d4c30282d5343061575bc647548be38ca40172c7f6eba090140be2f35e457e48a72c7a4a6aa9806290b2672f45a414dba6088447ed60a959755f5de4541f8156afe0e9d0490f9a30838cebfc2af6a14b6b1845ee243661839603549893e4b3795f6b27875a4807f6963e98ee2d5cc4db4c21cdd37cdb19183f90a56dc6436e5d9fb93c776edc56288a7e344c6ca85a1925c88fc0575947f0c38519c7f5cde4e1ff0c91b702409858744908668fdf5cc5eea8934b3c16b58997670979c26b062765764c1c31ad7585479997c531da892ab192285947638bc36a2983a6699580f1949508a1b1a60aaea4e3f939cffdf5d4ea417216929cf6de48dc98725c23e9ef92ef97d753f8089690cd785592c18e37a76687700a60a604fb9bd667142b7c096baa976e93ea21b8cfb127be915d3c63e5ad8d17e3f9736a742e21754e858bf954c9d84f8e08ec1c85dc1ee71a4e7fae793f8d5d29a03e04c243636b451f3bbbfd51ae2ea226fa5a10e42eebeaa0f19c5d2d5879aeb2a01a5136f301cb3ea42bb56cbbf848e061234f51e4abde2d627b64f8606c334ca103b6e147cbe8c93ffb34cda7c5b2980ff3ee70d26242a7ff598472e1f0a9c108ff4ed8bf2fff687041a8bf8391ad6d9556cc71736177e9ff08004bf15cd5457dd2b412ff7e999410d806b5c5d393f223e101cb17d71e89c6cfd770200810be30ae0a33f6f98bc86a0633979cdc77e2f80206c40f6600dc7b74062b67e92d0dab864cfb6a76b9412f165a6970db02b620d8fb032794815c1e14a82a96caf2a20dfc13825d7671e6b847e695a2d76be1ebfa7a90c454823d6810fbbebd35f756a44e8be7de0d6ebda61acd2028c9820117660227507ccb2c8802df64bdff6f042c22365a56cf9b8ea7ac9f2f32b98022bd9fe8164bd255617bcd6a50302d368c88e5e8a2e6d7692cb27fae6ee7f0a82f6688038adeda2c27de10a6da48ffb2dad995f549a94d76345208f28824649a00b2e2f26f1acb952d21c8e662fc8f08d2f1fc4861","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
