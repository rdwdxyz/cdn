<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0457d4694ab8589297bb607ecff168bfa701938822986838ada4bf217ab0a02c159b9a901d7129f2351796ffd90dd84c5a26b0ad3b4f3a57724428ecf53994ba5561a7176dcbb63977b8b9bc5bd46c9d641baee675bc5791bac2f6ed756b52c5dbfa451545a97ca403e0789d4e7ee14a63a5d045522027a3e7cc61466584e0b25f08c52a2046a22e5049f73202b4775b1ce93192c9132d705af8bed5fc3d56a8bd2729ad5cbc69689a929f1570385a286244b93e9597680b7b4e1b04d89a181ebc1adc2cd0663be143f1e7db24aaac7cea6ee7885ccbedc38b92af50b5b9fad96ac126b2144ae745a7dc68602744883c6a9650da2331f07804126520b90d72b01a746816aabea8707ac85e498ba6a334080b8249a2a5d68505252ddfa8a37fb41344fd6d2fc9f0c4250ed6cca45f5e534af003438286c8b3bd75c839b08d825850de8c39e6359e44e1815256166650ed15109625c5279ca318f393df4f8f55c88a48309072eaa0428806e3519e7942da7b6548e5b0002faf1343f26b26da0d439dc318873c1f5203bad66033308cc0d0fec996d141dc1dc4ca5317936cd3cc48d750aa316edf251c531b8e06da1c12398afda924059e0d1e65e7b5a1bdad9e69fe2253b4c4a2360a2600be331f31ec877e4f809160da12efa02dca0f2051d9e038ac08dca141627f185247eec200d83fb73e23f75a2a4ca9c746bb3b4a67495f6a61e905cd31098f58a3d611424951b4244271edd835d4516e44aa8289f893fa3575e15c6150e9eeb96f812e5419ee09e5aad8e773df26217d19e3088e1067d4f0657b6a3f96d8830ffa6c92be47a95a9366b1e3d8a609f0a869c51af841262bbdbaa3bb73414f3812215687300d4b55e2b2f847fd99fad0c644b6cc79b7370491030e22d246ce3df33b74ed39de0cea13ac2b47ea57c2d6d92a4c29bfdd664677f9e61ef6c3eedcf2ae3fdd6cefc09496a396144f12c951a32a2a76eb60e14d809c8c8f8d31af8c9a624f1b3b19fcbd9b2c2f1f4e8656d66282a1f17f5d0747be8d630bbd49d05f65290b03d2f97c0b6cf95d12d9a0a70a97e2684d83760a6dfcd33e8aa0f2aa4876bd8dd4b839bb7ab300954c4afea85361aee780b481a2e59d5bee00fd180d66e3021b7105ed6b217f633f1d618f81acabdb0eb025a5df1534e18eda14c95fee52ded1a18d1e5a09e76a364e39332ed1990a920b390160bd0f084de0573468ea73f035548de8ad860c088e00f8204da4805e4866ac9997cc0981c4cce37935b6c6f4adef1751f0c0bae6fe079afa2866f0c66c841210baa56d2187fedf7c1504f32f84db8d5e7a3520c71cb183f9ae0d463bfe21eb370ed288eca18c794578a2325a80a4a8e7f7fd1f4f2f6e9f8b299b568c15d04b7275afda925c8c9004327cd033819d5d429b8016688a5f9f7690878c5a2da10437931a3cdc8d0308b338770f16cef9a208fedf961a258e02d754ac59977de304a219587387aca6f34e6cb02be25457bc09d208d25353cac1abe200bc4d6d8429de5c4882ef13a64ef56b63a70bf703164e88ce87a96e5e7fe4e46de2a755fa29cd51be7ae2727a673f78ff30c06f45f4feaf2d9c952eb402174de9a306b6ae2425d54dc4868d3cf0d9ac4231fba2f117879a43ad69c5752f73dbc7bd2c2642a2dd33ac367aaec7ee4f53a554366e800f43270acd4fc9e9eea41dc7143c29d53f644e4f47fb994a660c08c9cc84ca6b677a1688c4a27fdbafe013a4f10e4adbc185801259c7a881770985a4dafd07260c825208134d61a0228a053ef1b7721e9112c08cdfc6c0e490612576989bcab768b230e63eaef354b0bb3fc2d9cd25cfc581ff94c979e8eacbbde2915d94aa1e5f3b81502e6b27a21efc30e0379591371edc467acbf8d457772a42db62c614329d238735012bc8515e457f61f31d8c46327c307d377ad59380bbe37184b2e473b0dd5319d93c854d3cf58978e2ad4b96fcf8111ce9c5da440c01f1411bb66bfe4f2f2b2332e2da33b3abf62bcd3af7e021744c082915db283b01197e198cbd259036ef5f10abd3ef0dfd859d75519cc505f222f64b7fdd891f4b50379682536fca15cbab4ed656ab655599d0b130d0500e20626a35af45ea529527ca7b0b79f899f5f5df31cb022d8bec1454f8577fcf7df5cdb3cf9656a7ffa7b325572e988b90a520ba152a08df257f8f8745fcdd999b05b019aa790293d5027eeec1980adb84482d380768ea5fc0a81a265c0aff6959a7b092f76f2f5c31ec53cc33ec632e977868a133874a9cb1ab20c085af61dd836830a1fd99f960e36892da4039d18df714e5cfeabc7697e516346ee2049181a3c0d9061d09a4fa01e06fca689ba318fe2023dc414e19ecc63138293214251592695940f2f797c8b42fea9efc514d6b0a23c037826a07fa6547656b8ea5edb286d7ef320548aca5f3e72981003e77e7015ff21b86795f5d98784aba83d4a42783c960d69da3f978841f2eb7f4e103c4d99e626e993bbfdb47322b86d463a10dac03729734f6c92ee9958c8e2e042cafa9d9135ab3ef5d293bad4c528bf67783ceea570ec4119599748daa25f74d32808b1bd321132cad29244d4018edf1a916ca48553e63bd7acc3448f5e9023cbfb87ad26c4b7098b757b65a6203ccb13de558759c2bd5a109b45831b3ab018e6ebea4ec8b4c90fd53a82707c7da2a0e6a62ba3c8a60fe59a1b63fcd84c9a9a40ee16ec3ea979374681afb49256502b1990e1731940947ea618c958cbd12a7a334a296513c9cd85c4f911ba7a9d94c85e93a460aea8ea5c289c6f1419d6c22b72daced2ff314b7757fd743de689997a1ec22fd6e5720872c4225dae665bc05455fb6d776422ac89a463144e80575ee7c688a98ba51a8011aed7bea749d2d676330ea017eaac18a7ddd218fd92a20e1de197dd388ca62ef3fbdf7ce6fa83741294f27e4f4237a3a2cde571ab0c26d382809f98f49affa81058597e7b4dd72d5598716e7ec3f80740c2d946cf64ede200558c14a60227289b1339094e6c442b375e25513e91a0c0638293bda1aa51272f6465d8382797709a382144474fc7f50e165fb737d7b89280869a500b8f7991dce4873952719ee3ab912655e06c784d7596b576010c05a2cfbe68774c7e4a902d7205f2b10374a68efafac5e54fde23cab6abf24b0578e4bfe9aa5922a495633e9c51524198adf50ae311788d653ef85a4313ab84485879bc11b2c68c45deb6287ff52fc97c8cd0b6ea7dba870449206468a0ebe0892233ac92bd12ae9075222428abb0f64d7ef1d284308c134ffde6358cf7aa1a70a0040426ae4337c8ff0dfb231fb123236741c20ded02f88f18e68ebf38ba9f125e3cc959ec6e4bb9b441f2450884cc3e36dee7de6e88cc323d06514af6af8effb4f3e1fbe8e6a447eb2b7c5a9fa6d9622a884f80cdfe4b5e1b355fab93ccf400d538dbaa5804cf6a6f8520d453214feccaee041fda6acab7b9da56b71ff412383390f50f0d9be0d0a52cb7510f5ed2726921cddf2c2b79fda21e9d27e19764ef1d91fb9b4440b2e674f3fa72c00f4153ded355e9e1c0373ad1adfb0332f74bce240e8f6d15240aa31084a21cffdbe2a84c0539adc0a08db137eaa07dd9b05db26db7243be37f2efa88134c7fa452196dbc867643e8bb360d660f442edf6de3a026f3629874b9fb97da2af60126d935105c101a242906545d829ebad86e4ba3c549f4ffc3346f0417bd71a5564de791fea2a7adae51351b74dad55ba4bec19f238afffa171154910e5a36b23caf2cad8a4bd27a437f8e80177fe1e9b9b5e595c7e0792a9ae9d35d869f8ccc5f08d4636ed858a204b6100406df5c38fc9cd5639019212a3b8592fc25c4494d832428a02a8420d1b97b834e5fb862d38a36a8c0005c8feb7a6b48a0ee31a5f0a555ce5f77face89b17213538fd42f6c5067855854fff15128673d81b72d6da94287c580b9a5edb3e62b050c43fa2022f42198ac84536215026114f24df1521215f277a1b3cf32e628298fa7107eda48c39b36585d9c1871da378435d99ac53de964ad1f28ade4d1a30c0853a600a40ffa51db7aaa7221d5e3675b05099035143d7aeaf14019b3e348c4627acd8ac73255a2117feda310245cf73d881b1140601c54a17d6d8be933e18d27ef78da5c76dfc0b0e93b6c5364707337148eebd4d6bc48c2703de97e39528719bee18d1294addb83b699215de6cee1af509113ea12e3514783e39ff4d9af22ea155b13d3abd8a7955839b07d9c0ae6e3a582713f1939839e877de1f6867367bc3872ba6a64f784e5d3be59a51882548be30892394caa55f98a37926ed3f86f445fb20d3678f9955d017d4459bbfded93c941d6d7b153b393ad27dce3671ad11f2dc86ff45f60669a70c7a6d02975a91387845795874921479ca3a51cac891081a7599e51034805dc83e57ffd1cfef20f0d3b4a8ff459608c35ddb877be61c367e8159d25f7c5aff60f2abd0a2cae576d6d911c233ce99adb9a30f75e5274060aa1e474c35ea8750039c70b951ca6331fd03cf527d165fbd61d6c6fa43682d70816c45c66feb9c35a432bfc0b1bac018f4db02c0ffe6d35d40e485dcd1b6fd45b7ac9b31bb2034a2d7d73b5f7bbef005a11e43770b167d3621a2e569d11ca7869abcd7de7bb8fb2f04b9cae325c71d4c34ec14ccebe3ce17a1923322987e5b7ce1c7cb2790659349a32984f284d3ff20911906cc61d8b77bb475ab535cf1049b07b78a5028928b7c479cd23eb8d43e65dc88552998a232df06ef22ec25dbd6b5f1a89f924327c1d981fa993ad2a6f469f3435ad289d61ec515d6df29714262f3dea2ba8506e88cfc648178ca26afb017a1f5a9cccd7ba7a095fa7ed11b173981b9ceaece9a4cd39396494089fc86f48d85ef3a60806fa0eb237e31f6d6a359ede4b6104c80f3177357eece72767dd08ce594f8e8ef25dd021de94cab43ef7d7a3395c88795b4b77da9c11d53e49773471bf4f490f507378bb97dbd0618509249a0bd7100851609b5982f2803480ed1c6a4207d4b3604f6f147520abd7bcbd6f09d95e451d7c783fdcae450face0407d57b4e11fb31a1540b94701a19cfa97c710002a1e8d18fca5b498363d7ad137b76539ae57894078667971d1c514de9d034e5b9705b7a1aad7529cd0d79c68c2d531e017aa88bb55dc39a19b483c900f6df5a0b3153b0816fee385b09a93c6085dcc2cb98ae03034a393ace71f9ba069dcdceba955c170cdbfc95260de8f3a7b38912178cd78bb57f7edd08a6b5f27bd4f9d69d3dc62a117173a99b46e60371d174a0bbf4cd6734175590beaabb6c2929adcb53019c7348cc2ab3336ddcab2229af60d4dcf7a1337173b465920db234c1411054704e7cde01a3534df3526ebf40e5e5e3f2ae35c27755ca95776f4bcc32b3f39e0f60084248b6cd5e7de54e30881ef6af6be1d1d48f2e7203945a53afb8672d2f962e341471417d7782fdf045a4e880fef07cf73d5d890f4826eb1043174e3294f4db17b8956f0dfee112bccb27e439501bec3238fdcf1e44d5392dfb98335571bfc06c317541d2a2851e7a6b3c99b8d466a4f07e689fff380f94b904a85b7fc4ada5ea040168a6125c630207d75bd08ce76a9ab202775d435c56128df019fc1ab07c69cf4fbf408ab69b40a250f70245bedd51d35fb34c332bce54c627675153f1e5d76fbc090d81b8cf3370364392c6276cc113bd35379cec48bc64c4a10d0ffd391a477482aab44850580e85e13299d183b299c93c4c43c4a6efbcfa8a2ee0a5b7a47b7b2445ffcc123d5066c5d22b4bdee88397e1b9c473b1bd368a58d30fa0fc073c5de0020ba06daff25fbf7c1c65e0bcb33782147288a86b2b2e195c338bd18c78c251b1bdbfb5d74841a1c96a222bb8309411454ad6ae12a770ce5ee91d81cdb4fb5de606a323b469557475a1cd0323f7d44320b10deec41bbeaf81012d6b221853d88b07c98b5ea717dfb06ab20e7c2a6c0619904547c7f898dc1c9462e5e853554bda25cbb2023b9f8ff937aaa94e1f4a6b08bd20687eaf929197d22107429bc7deed67d2238b703574f89fbf3ceade6ae2e7bcbecffa0e624759faaa988d1947c3abe5248be9cbb9b99a27589846fd4bfb3b77daeb93e48700a977c6780099874176853ffadbd564461b39c8957420346d51189b5e8d5743dfe6350d1828bd92a748417eb8204bbb229b235fd8482d96e8bc7b839124a6751239c09d398b6d3b18ea40bb6e6cf8a4dd467d4fc9d17c951538b1e8e80cd00f9f2a19421def8078de3eeef4bd089d928037e245e744eb654d31d9619f6eeb84313c4116e0f465adee5def253ab164c831d1dcb3be8c6fe008d67da28be8149ba71085db907a47fab81fd253e3ef81cfd622e00c089753d1d4099ad3ec7e4ee780b9f0dd5d0bf4aac4fa20450d3b9cc84fbae6f08d8e9715b208b63c4e281f6e60585dabcc54783b8026e08a581c5244d81dc9169dad4d4d8f87891db21e12a419cbd6d3c9489a84e28b25586f0687229d6e97dea78420bfdebae7db069239b2c62f2f895924e5a992cf3ba915e83fef559821eb7a5a4752def5ddda48d2ca5520acb8561dffb2a1e130308cc26a9d32eb069bff7745c22c6e4d3f983da32b9dacb91bdf9d9b5a4d3d9f3c2754ee59d2bf0a20b33c192c27a00ab03dd58d4b49e91d9650a3a2a7c632f2a54d856a8fdbe458e1edcdebc9ce2b8ed2854fd3ce2e2434d3cc5c72c5a9295e6eb2d324c7f2eb0a1b79ee5d53363fd3bd475d46dde56187e31f386c053dc0cd9a0e52a261ad4d4092c5c9e81aaf061eb67debb8d6e35217f9621ba885879ae8f7777e16bd62c66e7341f7c0f912727e108c64cc22644e219cf6ff7ddf005eedc94374298c4ad0306716a200dda2385ad5ef236e099d83135bef2ddbd39295703c8cbce9e51d623ec8e5fa91238423f955d77bb27da0d6870522f0af408abb9f5a51318a34828573e7a6ccb22d4c538be69be32fccc08f4b83dfc2ac75b5e1fcf5c932ac3c8e078638377433e817f8ae08c33a6564b30850fcce1204859be3c33ee6c067a0c334ec203d1fdaadfacd0150a7c125739f35990ca33bfcdc03840e627ee76dc9446d754b7465e6e34e50e3ef54c1b20c5703c56d75530ff8e958150553956b0c6278cbc622f60791e8f737bc84feca6731b20eeb841523b2c8f3411a6632bd6ff410cc70de82f741351e56ff5117f627b52a7329ccaebba76d67fae1f10681240b48a96da842294a80c476343d1653adfed9c1d8a3508b9b09417c3bbaa9142f039802483e413cc551f3be9a9775d30a0c2d3592a67cd58fa398d3d104cfcfa1d3daa642961179891eecdbcecdea261c38f11b9a0f998eff389899cec0a58b33f8a43426d5880ef5654ede3bb0ad1133e5552d364835fbe997fbdd23bf6ab495caadd1d29b9df3369132b728e0d4f3aed9d37edbe65f87736fbe8568324b1af95c6a371a86227ca35e57a2d901e2320ba6cbe63bb265ec516aa3fd66f2b2be1124853cab8d23c1f7483deb74d5e203c79bf77e6716f169b31a20cda9e9ee2efcf749777116944925e7993bd9926869f349fd1fd9ebe5ce40a4e58fdc8aee5c8bc1311c2f6d106b09356b3023f3bf4bdfec6abe5d9a592358923bb81689561ada83da6291d00891c675351dfd0666423c5986b01ff26299f401ff5bafe792e89f203a724fcdf0f19340be249e13f156d79224faba4265113b22e9c49023d5fe38c613910cb632b1f778deb296c225f37790071a6a632782fcc61a1fa941bd665fb1564dafc431a8e0988004c2581a09bef1757093c4e94f4b8b05907928aac1f5cda3a7cd306fd4f6ba1519469d9804e510212320bc26539ff023e23a43e7c09fe75292b9434d8a0ab1248e8732e564d685a4eb814d7115fc3908e9cb904987acce6774ed97feecf926f9fe943382cb4d442c9cd93337f415f8454b22a5ac3f6fd8634b9ed643a640b901f42771d605da4d2bee1efcb5c914df2e647d1052c773258f495c577738195fa38fafb964467f7693893fdc427d603523acaf398369e52009a6aa4bd51af3340911b65bdd34b682a31a0065ad8b0fa9672d2e1102d788fd46adba1f16e30720bc39dee455148e075d41d9b2cfd60fff34cbc66ac1e4244e9da0129a2b6c29a59b992702d8767e5d6362ca91b6f04de63c38719b38aabaec86ee8277641feef1650fd0a3e6def27d4d0b6718053aead4c317c1bdfe077766efd80362f61c0d2b2dc8c96b6a15bcff9be9349791d337f35522047b6ed8ab603daf1200562696cdc1ec5ea8761dda9ea8bbd2f050770873e3beb4ce417d59814f0568114a6ba163f1c153e3bea757122c6cbcf16835791fcb4fc181ca48881b4f794f6afc881804e203059160d20349a9990d87c21823a99c7a92eb174f8eb487d1f34b2d4ec13021de76ff5c0b9684a6257a6544115a2d5fc7ca4a11f7ba7756868554ba24ccf0faa80a20e836af3ee695f65e03b723dfbd7521463ab979f71db09deda1b992869787c308fd214ffc425eb74fecb7dec3c85f7bc3014ccf9a9a704f3c600418ba47906651fb2118186e60155a7838e8dac84142e00ba28eb3d08c86ffc55b4ddc041adc752b9ed7c8298cb2603949fb76e1aa29f1273b51a6d525bfe188f8db9edcecadd708947c8210d584f661fc93b30e8b89724167af10bc353a6fbd359b1842084532439110bce8eefdf367473af8abb5ce7ae33875ed376aab7a7f8bf164eeb34ce29b49a7550151c73054f081429b17e05e1675075cf51d4e30753d4bef4dec4ea7e5a5ab22b86833f411b48f508ae4e0e6b489d523877553e0fca11f583520b35edd05c0d0cb38b14b980bd47623dd9f0147c3bebda8aa0a9e4fb5cbf3ded306769976cd7a6ec3cd39d98d6e105023fb83c1eff9f3d0b36e71141925153cc2b0dcb84e5876a3e1e1af1daf1b6878675a4500dd2fdcf2e2e7926430e6a6a08bf2bd14111f0f3d3ba53b457444df16085c0204b05ccf15066a374d5f68366f4084f089897d5078accf5275f0073a937db232b861fd8b95515c944b5748a3d05dfb3b86750113df6ec793d68c75e23de6fc390c1dd31e2bcb4a05d469d30f477c11a39651b0f333d173a31187201eea90df5fa14278d0dc96881510a37431c503aae82a5448a2c938df1cdc01e0f67f5fb3bd91d688035bfe25b047c4d9bffddc1eec1a0d2fd0b751c5d60adcc822299392e1ec4ba878848c57b304c479904d15a243df73882db06e2a31b2036cd4cfc8957e9852470994bbfd95279c411125ff9462b4a07206ddc1c688052bfb9bb783d55e7efdd9fdabbd4ab652ff977f1a6b0b7f27c7b2520caf62d9de4fa7833560f10f5380acd443fa85df81075d137650a8ca293e9dd820d16c116bb3a196f6135968615785f4ebc5dfc03397ec47bbceefc0106fab1fca9569a47e3ee7248cc608c6adf6d378fcd8b288354fd633f9c4f3aa8b07846fde80e7a1f46dc3c12d4d6bfc10cb72bdf761b9b481b27b2c0a4d64a139ddbcf451e3ddebc806df013e10fca9ee674d244083cfdfd833a231fe50eda4ac21b2e3161e5b4eac482a1c1ccc2327b5a3149fb4192d480d8085820c3222b20c4d217b338245e394b22f918b8874b6e429f50be0e92108620079dac3d9bac729be44e3617c9fe6a362a644b71805ca7a2fe0a14bc023d91c261aa69c670b3d04edabaa8bfb034550ca07923bad73701f3f8c230ad3f8c6225af836eaa584d6cea7fcc77712341959ca3298d5919ef36bb36f6f362fb62611a2f7546818da8217475a6b7aefea4f95759958ebcc8ed53406d82d88f8efa4eb1b13eb22a469a3aa1741bc2d901d66b56c03be95c896718d4d74f5d21d47a491b85d61403e9d839a9e62a05ad872287cf74914502efa131d5c3a24c98904cd1f7bd4a3b5fa075ae1b6457e7fa0224ee72fa0cf5dcc7455ec31b435de5357bb436cf5723d732fc92e0abaac8bf8f1e9c61d23007fd0464357aa3590487e3642b3fb5b2badeb62e073f92d60a94cafc0919ed2c6f416beddecca9c101e9704875255d625ab3b4dbe374389ec2f614d0f01080117286be34f14942621d96d7c27b02f09615b684ee7146b550e91e4a3b9c844cd75e8a463dd48cf635856d9b635bb682b601ab84a0a3bde6361fbe073d962ca51ab89411a625007c72daff80313ac681bf273f72f36eb6e3aed33857597448d3f48d20db89269d2ec44de7122b0bda136301acae7f429186d95d5f0ba6b21685e2f79cc7f97be38db50aaba77fb142b080670e1c336914d5d984f37ac9aabc0e6b19355e5bb0982982027c2b897ed096defc753ceb3864c4153c8a8c44d7be20d25c9a34d73cb33e8d8250ab0611e61633337d72621c175bc6d65b03d12b03ad12b282da99183a0db3bf0d4c3ca90f728b8a72ad4090570fbf303e48635d8eee9c8739f0ab6b6ff1e7e0309f96d0bbb953964ecaa31abb9f261a44a0a16741e99b2050365beb93861bfe45f211d453683c5088f99a3cd9644170acadec51d25d9c8bea832fe6f2d5ac84685e8bb369c2e87e3a29367fc5b4c9dc446375c3c65c9b60b70bb56915c78daa228d3360e73b4351dfb00efd1b1daa8fa99cb505aa6819d681a56861d2d7ade6cc00350a29ac20fbcd63d1f43e9a439c9aed1abd89c143e859a20231f0cd12c1c9cb4ef9e86fe53041a4e906a332febe1c5260ee66092c23924b866d84792807f6ee8789ba8704ef492b830e2b5953b61133c23b4d8643b6f6fe6656d5ca74c45c9eb1564a4f63fc71f5fe455a69e50c520c0d0bb9e3df40be3dee214835aee960f3d43388dcc7260e7fe0ed917a8410c6808f415918b25365c2007214872462cd64ce3817d4d12c1c8d31bdf60ea1fc3426373f0ad907d9103fe29928b2af15dafdc75ce8465e0b9af9252b7435187a77a2b1b4714c2e843996b8530a077f35a6d0e65a4a0efbffa246a75e277cc5f4c662319b1df43eed39734a27fca2a2d8b4f5046ad9dc6879d4f15da1bc61c9293c18bad68f8830f4c618eb7a5392370cced7f9b62292bdfed272927cae314c84f130952f738859f5de947ad5ce8f8d41bd991c65e805c13bd17a2eef2b515be04768c293693ea5106df4d44fd70a86f78bb2d341bb54a2f107647691acd5beecb406f2dc0c2e04122e4deb03383a488c7d85f82509530074bf04db6ef3ac44d53711d8f8c4153633d8b0d955f4f84db485230b85e8292ea42d7e4d2931ef6e771e6e9dac51eb2121f629abeae814788ca2ffa30a5d386392fa5678c07ade0b3ba18b0a780a95f8f271de641a9ac9823fd15bd6fa113b5d7cba2ecd1c84865bc6caa990145ea29190ac57a00e0d68b83362a70b425c1f2226de337d53e010b5c901d0a0d0c2f42579582d21b803a81beaa17ac8f859b962f6f619abcf5a1dc251c4820db7b98021d3e23a599d7fdb53bc99e7920a3684dd25eb2fc6f35fea6e8ec8930c15ddc56a83dd88e1c7f8d55af416d05ed4ef81fc4c2c4ef0c9ce212ff9bebdf9514a87c09cfb8938f859c66ab0ce293da4ed600f053ed64e17552e9a196c84a95c44eaf02a1dab2f248652e651d23393d463cff1acbb871ba96a227d0bcb71258f5a5c93ceda96e84bccaa2d781f80393f1da7879c5b45ec613c5db514878396f816df573b025181181635b530abbba39187d8e9b3479a0026afccd754cf0ca979efa140f9f5aed00cb9710c7cfcfadb1f0b4adcbf9131ce18450f1f8212cbab3b9c8997699bb288cdf9d92bf60ec9f90040c9bf6952103c070575b69d8f49794efeb1f1abc936f1223553a4f048580ad78b9a4e613bee544210d3e81857a344354e4627d9791a3ac865f2666c5d802de1c46587a53a7477bb63c0ab2a5a19b759a92d65feaf65707cb20132b7b9ac3d3627a5012f20a039bac20e2e7a68eb65e91d51899c4024e47ad41bf4302743e6660471bdbccec3bea7591cd5384865a9148a11b0611dfad48c430c51d0277ff0e91fd0c95efd78aa5cefc027bf5ff21956d3e2f692a1ee133d9a64831d703d541d13568c7229247bab574b46548650ca25c7de54dd1a01f4e769445169ec41a4eaefdccde61fbef2f03384fe1dffcafb9fbd85c55a98a16e5306499245c6b2cbf080ddf5fdd7faaba3d88dd8deabbe3a579fafd6dacb7f6d4ce88e79559828ec57a6c86ac9a013656f3338d2bfffb90554faa29d747f53784f440d8a68a9ef64eec85ff6c8b24ea662a08752a4a3c94b6eab3ab6685aca8812d9395d3fba7d2e15ae06ec363c99023f2fb71ac7cd78d0b1b8d43556f570bbcf39a2d64bfab3d1237337e72f29756ab10e0ad6b655e625fdc48c9080bf0dce8b90732242ec70974f657bbd3356b19198bc5993147a0ed67ec926b0fd2c020b21cb6528f51315ad17ce44ea073b10ebbafb5edf8180ee308cd1a01713068608d42f43f4891c96277754d6a52d8d6a484ac4833d25d55a6d7c680c63d6fbbc7aec0711d8a66eb369d38dc3d386785f84b8940b4a60b208f3d8b25b865d503711f4975634e9534aa8dfad208a08bc50cbd6247727dd692facef2783c02b5512f67e01c6582313c236a95d24143ab394867df272b0eeeeedc147da1d7e93bd6f1dbe0af4fda5f039dc6859f43a4f4c581238513c87b583c9735cfab8b6a8dcc8d8afcc2a6a0244e21e6d125ddcba58f396d57d526c779b698e58b27aa6749712e99779663de0e46c994298bfded2356a7ca51e6600ea8bde2c1273c09adacad241ec4d1f8cc8517a81e250ef5939da26b6e1eb2c6ce61845387b0af41d3e3e6db4f80b14ec75fa24c7fb4fe2003d7f39be7507fe71b2b73a60ddb03caa7b220ecd38876cf7ca3e1fcac3c5722ac77be70694ab4e81e7a6bf2ac8971c35d415bbaa0afa9c9020bcc30025b0c980cb8a73ea19a98f25199f0917e77b044606e63aafcea4bc616ccde4c526ba4bce6141627b78654c75aae15d384580a74a18f4d3d0e3ea4ea389aed3b42c09ed02d991a79eda50d9bc45f5eeafc51c2cb400806d1178f711038ddff407f2a0ddae9f519ed02a89a9f09e5ef477cd1f879b7ab92523878268e2631fec47a2b86c63ed4152fd5d10721e76dfa834194cb181f503bfeb1d51a64296709ff03618b5768d3490f14355ffb21de24b4cbc439771ffbeafe71b4e187602d4394b9ca8ef58b094fd9fd4b6c980c6bceb4e083baa52bb217714c204262820c3a0067ddba65b5ce609233bafc85dea913428cc295ec47de728f839ef1fe52c65d0ddeb1f5e2da9e57834e52be001854eedfaf1f9142409247c8637a68f0fbd763ecb7ed4dfac73b6d670c4785318d6b0b016603c58b9e73b68894e9133b7fa6dcb106bfcbbe28d102c0fbb8febb6f31184a07087e2ab258c144c7f94bd3a31e1ded8c8b9af15eda8d43d96a3b3c3dc2ce7f0adb7b65653865c4d897d5c7faf2b52f60954df5e5064fc8447049ce98ce9176b28a7bc2f8181f80019fcd77d2ac24ee986bb779c061e3864b8846e20ded764d9a576561d16dd99c189f4af3e43842c46e5de00d324a7dce8a585e74e0bd89886d46cbdab3cbebfcb7b11031d390959c9d13d17b8afc7d884abe8e35d70b1e216c05bdf5d47c6a9d3cec3649a06047881a0434aab2e9e8a163b0a7ba3d5b7b37eefcbdb1095d32d6223fa4cc797d6cef35759b0c2c207b35912b50867494792c9498837f4c8da1f409daccd7c1f756f070426a6c58d5cda1be345f62df07868d23f70f83610ca4aa947a61bb8c8019773727409335b2183c9c72191840c0c77c14fd8a0d1385a825b1b5b26db2da0443e6efc46f07854abb2699f875b1e5ea3aed1ea4c000e52c8a6bc6be2d99fb8f15b86b1ee8811084dd6e24f0dbcd3d4bdbb6461be8266b6a29ed342de859a9473dfd1eef8ae9243aa354d2978c8a82055556f22233519c7ea6992a74b7acba4c1c09daf1090e851bbf5b7902b6c382f06537b4097e3be8420007660fe368869544b5b9ceb4cafe83771732492dcfd5f34cad2d512cad6499362fd263e6509ba6322e64bef33a9072b57c18bb1ab9e2a599697ab2317f843dc63027aa99fabe03abca90fa916fc959a6326c2207acff2f0eb6fa17465262e0cbd6225e43209eb1d970c0b78dbbdd28e1a47510f638232ec92a6b5049322df8e22463367c37337070728c93d256dc68465bcff75a7f6a766c5e6dae272887663d73a1409e2a2692ee9803654ce07f19158ac9861ad4568e3aa24831fc199124574fba11f0e52b524ae6ea223527f9327645922682e176697c1e0c7e3c5d07e7b361f76c69d3fcd9c08b15ae07839a496b4a11d52adf712573671c6e903ad857eb44eea02c721c5100931b318391374b617ad96d158efd56ad004c639073b9da1b2613513c4d72ee7e3ac204f493b80409d3c28bf8f997b4a911fc501846f96eb6cc3fbce6bace2ce0b1a69e3844b2e73a81fe041bc4263a56216d019dd54f2cae71c0474eb240deb285b94d18b2ea5225de5d03a3d2e7977c33117df908f2390bd972c997332d12fb48c62c7b5f2ee8cb9c2eda07d240726fee9b40e6a741395fe20f497a7f066924d3186c6310dfd8d2d808c4218dbdea3d4e732c0a7ec19f19a92c5c90e7d18d2cba4e477913e055afbc455b8d75b7942c97b8f8a38239031a4c7c137068aa0bb9929e99e89f9afb5c9e2a6ca26b2261835c19f4b2296fea87ca8e97d7bf4045b6cf731f83185ffc1307b1ccb22443a3801c880623c14434da73075ea53a1d852cdb5f4991a0505d53d84cd35f652cfbcc23e7b0778ccb457bc8f6129b189c2657504aee069441317da51d50cf57855856502d9dcf7f5469dc03809ed9535dcb6a42bcde6e19fd1eb7b6bf3fa4ca7a1693bab26bc6c4016ae4bf275e4ed66c4bc68b17171a7149f8dbdf202e66c74b26ffd01417077e2e7376df5bf0deffba8fedf651333a2cc549dee789a1892fe24459ae5d49d80f27d38282df8dea3bbb02036232eeab7d054ed6372237789bfcb37a5e5f175e958de9872505363712192e1b583183ca53ffa8ceff7f44dcd6021c0f4abfab080f0f16a86119","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
