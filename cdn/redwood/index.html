<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4c7159b22766ae139b89c28d5cd0494306adc5daa017ef7f1c0ff08a21883eb23b51170536c3325aa9b59e93c175ee7bacbd22209cae0530b6c99f3f1c418641c9a0a6b565a7059032dea8c1212e2f320771e2abda8d1c7a50ffbf937e2b79cf35328e74d71f7c35f7cc7c86ef76740efa06375c51a7d2166ef1738b4b9999af413838522e0a6c2b24cf1f6016648dbd0a37df8be18a15ee256853a8fe4acfe24f8e6107f88e9e9f96885c1c15c0666ec8939a5a99be2f7c14ca7dc0fca6fbfde7862ced7f681032f9eabd8cb410d5fc3c9d6125e5cde150ec95a9816b0e86b04fb58d33777b6bd0a4b5c1afcb5cec1389b46b5c336c98e6957137891c6032e81ff38699c48789e24fa5a9e68051ef81ad6c6b9eddf3cdaf8c07102d32ae601329fa9bd52c0779ab2e94f7877e15674ff70f6ff5ee617c4a92605febc9ad6e6dcda904d0b9e33b5bfcbd56c251db9f1b80220ea6dcc2aa321130635b63a1b0a58231f62f4430e73a8587587384c17dbac895fa367da308d5a85e82c9126073f656f21fa2f9ef0886f99378f3ef3dbc3a34f0b42a4f9d195346e377aa601a010c3ce3094c8142611fded39a4a30395b105bfafb2a6d0d872dbf5ff2c1063431e58bd9fc2c191a229e76a8acdaef3c1609286043920d4e6957db7ef7d4daa5f1686842119a6ed5e421674010d933a4383b910312a10bb746ef63e82ec0ef322b367584e95a0952f85906445a303eccfd2e62143e543b182b31721d6ffbb2208c8547202e651b4ce2a6d27b905a79ee72f56a321df402a6f18af50bf4af9c5c7643dd25ad5122001261f2d77b1b772b9e4d4ed20933dd5d290faabf480ca6718964242456e272651f29e3d87ec69d0e2eddda8a4d403e06f6b27580067e26e77c3664f84dfdfe2fe882cf00ec38136900376653a17041d6d8e07b1d528e5871a341151d092fca77a48f315ffa6d849c85f7f3e3999e79102ad26661ccc0a45c202c3abdf6814ec7b6bce3b1b81b79fe9fd78e93f3ddff63a61b529aca55d31dee2dc0cafa70320a985e07815ff04bd03cd4ada3564a7c2cec945fb7bfc9c859158b06a8d0589a4d9709fbe1e9470100f9dbed61c0280b4c6111b58aca30e493c6ce0c0123af8329f99641161d2b505e6941782748c1bcd64c1b34e4b684c11e0cfe565d025af385aebf12ed11735eee9a9a8e706282cb88dff2cc5c1d8cad3d1e12eecfee2c32e1a9e9f6f12624f5de149aa42351f94107b8fa9a6cb8cb3a4317767c402fb7e2d17d448a4601ea50f66ab8985344a4493a14662a293c68ee637d8c8779f85eccd2ade43402bb4d7e6e5725cfbd7ed9227b54fb063b8b06c4d6b5851db2d8fae2069ea5d4a95543021977381158dfb5d3a985bebc65bf9642c3f9eea8106d2308a57a330165844830d42831c32b093f8858a0a0630b1d0e538265d88bb8c7df8c334f7a26f7e9213db5ff8fd238b570ab6c82ef348f7ddff41c051985301fd7b2f8167486e9a42605c7d45b96bf881da43ff855af5a9f0ae82b5179208916b1a7e397e251b833a7e37c09666f5dd654216029029c67f1e0057db99f3fef457f9121e7ca0463dfed25c1ce049f1c66577467136541e112d6e25df7436ed8b5646420b8efa41424dc026cb5c2ebdd4e5693445175ee9c9bb80bc0b6016ad14be3c5e37a0600c5f80a7cd0dc9f381c4fa579bfc1d4ad2c726e97f3f3aa0bda29f0346330410a21a199431f9009804deeafac792465650280b17622bda25b5d11db2b839203dc0118b23d32df1c69af3a8036d67ba8206cc28820e0f96a46a748d16b54d3a24a877b41a06fc511fca188dc215b504dbbe118f60dfe60603dfc0187ee9149436aa1fe434ee622225ad6660573961c8ac06192e614aabfcf68978a238099a3c14eefb1b45b15fb3035840ce629493c2579e9dde02b92f5d5dced762a76a8e965ccc7a07e61c7c606d870493237b8cc0388a8bbaf5fb5328be5d51a9719f6e6db8b69f21ba756d2dd3b9c3a1048d02dafd2e751eb7aac8ae2dd44887cec31753b52481a798429e527df3c178dc1a67198ee97c6d86cbd3f2bce35aa198b18e3feb3207b46f46bbcb0846fdc23e67db08b395feef8b68274b37044e87bc6995123cc02d592970891bcd2d0d6992fd4c2c8340c1f05ac047918902d597b8d62a26079279423ccef4044bde48e29bcc46ec9c89b27a078f7dd3298cc14c3d6f4a85244f7e99d998881fddd83972c09467738b9742d4ce76805fa5462ea1d056621cc8391ee37550b29399200879d4c65673dc5262f2f406addf06d2e689cf42f28fef85c7ca4428c7708ce76349fbe53275b235d9a932da11049e381febb7a34ad8eb7433d622bf8ab127c89d13cc91a692d94b545a38a8d3d52156d3d63a96545af558de31906819e3e0dd63b97ba0fba078368c0ffc50888a86921fe24e4bdd102fac6239f507f355eb206b3091d32679e958ebf68317ec0d663a4d6220fbf8d13d51206670893d3600f2e7e5a859345270d4950f7f1f6bddc5a3bfa06f735dc6e6ae940636724929e4d55d80fa49b02a470fbbd8d021b41f4c3d5053bc703ab9b026ded1aa3951b1a8dfafc2e1e3d750f7e010202b1dcc5356aa35406c8fe418e02a25aad35eaa4c527578e26a04b42bd25f103fbceae062c260a612d94566c777a2294b84953cab66829bcbe489042f322d1988e6de3039d451137ad2450e803edf17682e974f4cef788e2a15051ee6f868746fbafd098a9e7c09d885046904a2c75a1f95d3022547925110e9a617329ac4cb3bf0e4dfdfb4f63432ca49fa6aa8be85594a1b86d30edd5dfb6d8d48b0fa6c44707218ab09c0f3c87efa8069b9685b021968aea925aa42ae58b614b90818543d560ba3aeeb6b7923ac5d56ca1db58cf264a225a68e1d867eabb3c86a34ca42c71183a7d476544390e8466c1c3e2e170a8015cc13d2822b252a44008eabc8e6eaaa2897ab0e08d366c7d3af99e67f8c85210414a53d7a893114a11f8b97159d2de807db3732a76c4a8faf5fc6d7a5779a8d23e3643f09a086c911986d23040005184e979d4211cb8850f77c10d1037b0fd2dea42e2ee64c81ad0873fb8e9ce5e62950a7e53b13785a55a234f8d2908af12fcb95fc032d01736e6bfc9d1560d7d0ac08cb90be8794b88226d368279112205f98a52a260d16e342310fdd2f9376bad10c67721b47b3f9575446f5835e984bbb13bd0b56d5da127d23fb93f0623b4aac52fbdb9f6f6bfaa4b1b1e79ac1e7637377719faeca94965928e3f98592e03dd7676f24a06a5d6b1def27b537151169a9d695aee134bca9c51983ec200734a712888db892be1e3783a062ffe6b2e164bc4f57467b80508d61aca45d15f47fe76dd79f7df48335f605ee1220b0f26f92ff754221b12aba518c3e68ed1f434a9face6c40234b51f8ae3b4ce840f35e3876d7eb99016b2a22242d67faa16dd3a6606577bbab8f5b64db737dc4f8bdafde32fd506aff7334b8d8680e08b1754c485f99697437342513d44fdcd34238daed0c527d4387d0f93cf7ec6860d45029734f63cf35621181f482b2c4c619d4b11e7a266c8dee4627617212d40bcd84483d689b2002350ceb312d715f50ac3628cff2a9f32d4edd000ecd1116c9da0edfc72d5b61010fff24c77d054fa2dc2c44b043f29aaa5009edfdaf17f4da498e42099b1b9c191af46227c1ccb7b3d29f96cd1ff8f02899b0614b0876d31b5c61138db6747cc7e7a96137db16febeff93f2b531f88f7a42397da48fe26fdabf50d95997cfe4e3965fe541ccfcd82a8b3805a7d5cc686fc2f7c5f5b7dc7d3a0923c9ba889a2e33aa1aa9c370920d1e36bd36465f4c44f2fa6277185a6dc855e61caff510afdf977af3a87911cfaf51b9268d0d3f38cab6816de44230863a91d8e76072a37b1c7f888e109e92e893c4f11a28d5d5dbe7ddd15d758fc0c9f45ae722645a9a61ca4fab205060158c775b66d0a2109d2a7e44b5a83424bbce46ccb4be511ea09530435870ec5a6064f9fdea5693e3064376c02e9ef73e98fe3909675d3ebfef78105c8e2646728c471fb793263ff548df3270e21ffdc8dc3c570811511b060415ea108868719237e0f60ddf7df0b8ea63ea7e8876d9d62cba638a10f95d3be46d1bc5f7e91e42021f8fa10019634744ea60d145c23f82032c8f5834f0978e9da2e175d89e7ce6a2e0cbcbe3e504d6e275438b74fc4a0cab7ba7727e3042b6a4dd4ce0856edf711f7c1dbc6fbc268bcb541012e8f6d8775374f07e0bf1d35cd67023018470ae886c5bc488d5903849825cdcfb41244c8d1532a62fff081ed0280473b96c1c6ce7ac6192a02385e00ce459bb8cf31eb0d2ffcdeb8132eb80bca93ff733c16a5aaa01c0de7ef21c22bff85594774795833f21b224d1b9dfb1bc708903e7886f5650d43744e256439f0ed0a58b6f24a4ae8baeb15a5beea13337879f909961d50f53e1ed973555385e9494ec9bec409dc70f16e88f17abfd2e8dfefac101539c0a39c23a4d47b05a50d641189f2f7ad0d3f758f716920e6cc503786fbe56145c5e3921833ec6b3c255b3a64cab5cf2a26dca21721617d62d71eb8aa704948ecd77e87ea52990a2d2f5abed67432b08082fa2cd8d83b3b5fd37b68626e086756bfd6b18b0171dd78a4afdf9206d181d48fcb0e83e6a33b006e2b8d270a928a229839974fdb2d872fe1da2da51e1c89d936ca940902e9ded2dbf6125e75b4a2b7e610c09937a02dffa673fed27230781bae5f5358b298b659e11cb4c1d37c5c038f36d7155374e221a47a61dd8f2a481ed454c75e7d2c012c6b5c10d19fbe17c02376c2ae1b5c309ab5cdbc71065a373c5bf9c337f3f4c47e01e1133633347626479d2a41dbcd049bcb8ad54d382781fafd2b054f892d560930f2557e15f8c6b46bd7f1c85fc96fbf34c9ed0a609904ad91e5bebba791373406fc5bf543e6fd165043c1b7045077a81aa1bc386f00efcad5a18b2c6bbfcd13bb576a66e1d0815e223836af97cf8f8bfa41e8af15238f41d91181f1c306846a78a6b75249efcd76fc869387a8bc240b680ccc257c2bcf40e9cc7564d3d9acc1c3d4fdec71c59e4fd03d1a99d930e7167e0d87256eca7f0e09b74be2f3fbe50cd1bb21d0eaf91cd260b07002a8fd391aa20075b6049c129058050d94d95e48e1b4ee7829f0e2ffe50705ee8ccbb47b5f813a809c2f212983d0bb6e4ff494f4b475ede97960066ffdb08ef948d5a73f290bbf9a82e6892fc80f8e0de6222806d90c489486d511a544a32927d95b7c8724020054074308acc312e2f2492618ddf1da9bf227dd8511c8c12c071b9bd042188ca8f0486597ca0fa39d7c15d3ba1fbd0e447f7c66c1909ff906e746b5a655f37f886e0d3ea4557cf928cb1864060066e845dfc0d43d3813d2016d9d85ca8260b7749cc3acbad0254f197e85019e320bc9247a5277370c560f6ef058377343efc43921cf249ae3096331d9a2ee4e46eb976a4e2a712e98265a14cddb4185e40ec12f138864e1c864a3ef838ffc6ef1a13e89dbabe7c4907d40fbfcd47ce921b093879c2bd9bed76edc72032ae778cdc90703fd905327d51470344c7031563759014ef1168b7afde6fbb26bb96080ce67fd47656bf35742e184ab2e5a2f47666b3cb2e5b02097d4392cdba02ac5ea3e17d16c68c6b03cd969c85f318e90c98b5c02d43770c5921dcf2b0f78665ff3851913a21fd3745a6bbbcc35cf2526ad116b4357b60513e1f158de0eea9dacbea2a6f479ef3f9a5af4e2d927d1492feda20a02fbfc8c3fd2c69a6d5f1cb5b3ab08aa1da167a6b6a6fb0cc5049dfb860ddca4a6e32501c1ec6c3a6714275161828b91c7784178a5a356ac765d89a187316af2e85181b6c5d62df1ac70c0bb9894d60f656e06a9ad9b6503a056bd50e78d82af7114fde9140ee47d41c25fd60a418a0b3f415d293c528522b10f486db08f77e59fb6d6490775e19721501545b2e67ada1f0e3a409cc2690a3c88f0fc5f591e38cd1f62a76944242d0930e53c88c54697cbe4cdb0c860158f9914c4f2bbc75f883ec4e04032b1d3a1145c8e714d1ad860d0782a9a858fe6f353a7bc05889608f5fc2116a4ec71253950fb2d845cf8e08eae1ba584af753bae3001ac381484afbaf301550684ef3c08522783235a34abdeb0738a6447f77aa284d6e2e459e3142e0f9ffd25e119861f2f1842e4234e8bb8e1fe6e578a5f6d2c070523194db210f8fe32b8f8fdbcc9b8b4d6d4bc4507190f9766f5721c2427b45070de69cbdff13ff2853d77336490b95da30afc40d025d7a65969e1df62f94c7d16486103d73af000a4de33eea8c81ba3fba3d4168e7577bf5d25114094a307c1c82e5ca6a36495b03b0e7e3f02c9d42f4b6a3011819ee81799e978f649fb950b5977852c53a425c9f64fefd94635236b199a29c3c7a0819dc300508cc53bf82b71f104a591409a9f67d0dae14a057e81e9068f47ed522072ff94dd3a99e72464d68515602f074fcd5bc3a12ab2901107272c872d96604a32e8ff9c631f27d4129887289509ec827ab58854ebab03cea6b89a1663d9aede4ad2413ff821eb414e485e31cabbcb3792dec7478bf3f4d7c30a04beb43651b03a5d46e86ba1ea97ce8253c9711c6e9fbef9d6b627e7a3c39a869d95a10b06bd96f83e6683040fe7df3fd1a5747f1fd388cef21f53462501f90dd572bbb6be8303bdbc0922eef07debc2111dcde2adf03fb7eb1a0b22942092393e835a2697afe6effd9413413f8b06771fa0a8b2d6ea3e6d86a02b6f25212ab57f201d3aea20d1b8f8263a491c2a3a8b1bcd1d8af6ed090e7aeb63689199db1c4fe91a38698427449011080cdbd1c4166bcfc6e7e38d889afdf2a56188f16e897e32ebc3427476767046565de77cb6dc06def5f22eed87d29bb029e68ccd3d572ebee46f1c1260e8601c9f6920e0894340c6648daf912d619d7df9128a18d9bb1f75e2fcad8468f247034b6cfe1849d044cd53f57f52b9e163adb56d7646950a25c76a70596f89458d48754cc80bc582c57e58fa71a52f2d8b741da49478e6d2e632df0b42323663788e5ea71ab0ef80ec9daffb7e67a393bd11281e27efb3b8be9f4b6a1f55ac3140e2eb1958a7b8a57d28a577dbac950d445dcb793a5d3295b35ee3a56b7b5016df4930afcc60340a80b188cc27fed0807bf1000910b973a9ab4b35cc913a1b7b0360abbfb7f9a69762e5ac4082d40e8a9d4ceb3799c489e04e47de186d6467568a983be82f5625a02cf7330815ff011449a4cf40fa49e8a7877ad96934bd6659dce18b851f3ba7fe1a477b1e80616ba1ebc5db3811a4615a9f8dddf62594c4d7468a7132548821d85ad6bcc27c1093b9286a24655235bb5061c22fadaf96b755df24986437077e93164914b4570aa95c555ebcee7636591da512d74d8cac31268cced814b9e70388916116f4cec0f390c08b2af21213b5b75e12872c165753c1d1c67f05c1310fd2939dc9ed3ae05cc55bab2d20df4fdbbd8f21092aa7b151e89782b45d43e1223653e3f6bf193c5bb2dc84aeee4af8ef797e0d48d24e1904e6179585bbdeb990690734cc5686d3876d2d3494dff98d8babd8bd627ab696bfbcda898ca43c9d85db47407c76a497a5ca8d7a608b580582984a28820d4d4d73b703238843ab2ad14a75067a225bab811ac86fbd7d4a581cf2896908a4a0fb0949f8ffe0a3e39a932f44acbc9ba79e19f5e2bde57ac550294e0f4d8378bea41f14bfb852ef82bdd065a8f3c70a81f45661aa11fb61bc064ca36f00aba8be906db27e4974d21e2d4b132fe21890f427e19704ca6cb320e23a192de298cf336a1dcfd9a56f6a20683c14bee2b9439fc07200caf470c47662fe164895e13b4e830e4c3544e9924d0484cb6a1607d2b27e2673f6bb3379293aab738582860ffb11971753999cf82e796463933ee17f0588786948dc21584d237b9b7825ff09ac6b980b3a23afe790909ab0e21a4336481d0e389877183759ec0eb6deb5399b29ae6a65fe211756611fd5bdeaddb72e3356fc51b6ecfc39527c9e31f4827b4df61e44184a1f49ac479c460fd2560ef0d0240bf6c97246f1a525e1a8f7ab0ddf7dc44d3bc5c50a2a270d1a051c67cdb009dd408996964ecd6c9821185776a6f338df16b9c1df7995b2ff41f4abcac277d1c34de853841a81f2ae42c34268c45f538a72d7f2a32328c80eece3573c13ee3a869ddd8e2f49a991db8f9378ae19f63e27d59f4e94ff9a98193b0fed9aa430f9aa1a1cade02d6c3f34ba324331e9b3424bba175eb4f4e3f354023c2798368a8656f1e39aa22b2c20ab5b949357f2d0dda926bfe84f6a52d485ea2880e279e976acfd9c90fe52ad389bb8ba173e8f77d72b323e2da16839b99a79748f41966b8649e744ce91068011f9afeaff6c9a2fc4745bfe031af66d2b0ebee7dac92d57ae17772744af5b7e528fe546308499016ae5ee2c72d10ef916f2c436ac5a5f1514a0514a85a48ecb8328c3d7a1b3f34ad9930ccd944b2a7eed52c83cbde1746c94093b8eed28996118133a880e0b214c08d46524f04e3b3bed2c9a39ddef8ed868df7b3e57bc14b65a48dcd938505108527345fac9a482dd2e0d59be9ab038e29b4fc913f040c96d4c2fe746847e926fefb7c39937f6293e2df0d1b4f31a1eb81da85183a5ea77581b972aa175d38b6f5d9c37004ac0b895470821762864273445fe68f6155c5d47b19af4a44a461ca739d26e81268a02585f3b01551746427dfe5ca5adbdb92850e00809b184408241e5fd1f7fd31ba1bf5c1ccd091cdef658ca0b96abf824c5f1a9866dc336eb287a3f9d37fbc4039c53357fc9629b57cbf33f981b5693aada8e07a64e8619c45452ef22844a464c819cfe6132c45fc9d67f780d843684c728db5208c6255b5a8cb0a508e3ef07d6c27d444bb61087b3aa8840525b26bdc8d78d0d5798691acf9ef6c0e60d77353b8cd4c0fc44e1d173cc398ef7cc35367f149422c4724dbb45a38568322aa124a1fe50c6cdafdcd2600fa269815ef5444573e327cc5f1424671377ac270a09033965bd867e39a0213732f1bc21cf49a7bc59e6e7f82619502ee1c3bd0ed676151989257a50104f9aee63c6b037761b13c6a022db989ecb3f5e1bbb7b22d58aa213d391e49aff698f4c52bee5586352f1137228ee4f3c544b70d428a12211726c20517c00414cd6695fb367c284872eb62f2695aec6770fd93475ed9a7c96a5a2e3a27e70103ba9f3e95463f242c8848a158653b926a96d00e1bb232a94cb36b019a36a0ba91798acf95b9eb1ea4abd5a79ab59452590ec7d8d704daefbc42779137e2c4e9dad384e551070e0cae30e79674d6b90d6104450b2bd9b514015fdeb9b9d26d728a45d8e5a7df0d41b493650830f5e2800110a8de22ec41875d5bb1ab2540e7d37f862553f5617abb57ee07a7a3c24fe6b61cf0685949ce8647e485401c1fab474801f2fadd9dc9eee7332d9a7b51d2e5317a8e281e5d07546440d243def69f8623d7a14bb3d7e96328491d0793add08102ce20107c1811223a05231cfefdcb6b941ef01809f0a2dfb4a42eeffadb0cce61df69566bd94827dd6fa1da871624e44682aed3ead2936bb75f108162e6428bc0457e248bd6f91c9e9dbf8bc8800a20370b333a6eb5265ff11eeb8f7337e279c24b55409e00d6fac6276ad2f20d9340abf5280f15010c085a13977ddae845a7382acf8a0a98e7df518c1d97003cfca0560cf1881bf5214b6167f282714df96b984de8cd36ff9d5479faf2379051d46eecda7f11f216d6ae228542689bf707ee55ca35994d088cacc4878cbdc66d97aa63adfe913fb4897934f8e9081bc59e83188e0fa41175567d1e98a662ae6e724b5ad7b6cbf4ee984e0445a3e1653351b5a823d05087aa5ee40af40d7dfa4df1a0c9a22c90541d2227bd1b24fb2edcd592d89276465c545ed5163aebb79b165fb59021dab21c4f221af3bd97ab418572ddfaa9bf1227525ce307d2e940df3c8b3fc238f699825814711d858a094ad57aa3cca2755fd11dfb46b7b64f32440af8b25d8455df81c7d7c43b031cfb5748620718000acd4b0f0d859858d54d80b59dd020981de1d41922ae8593f095d1d1c23855c16de84040b59af685a028ddee363dd3ce0b0c08ca9fdedaf5de9782ef9035a519af89ba9d3d53e4f6a11f731a9c39496767d3452ca9a273ecb8a9cc113ce5163adfb83ec583cd46ec1675b333c29b7738c256252d4b4316948929fd8298674fd3443a0421e026e8b81c9fee81e3ed88d61b31cf4cad00b517eb5664c6617b3bbcd91ee7da829bf6e2c9b120c52dcb17d151feb9bee2baa48b1b319980162571b691ac9fdeeaa9b800d514a8b740c0502584f4a01b87d833c0dfcc6b056258a3a86df372881f9d628e4571129a7a668b0d692e88d124072da745ba563e2c0751a11cf938efac757743db67d3dd1011849330c6f87dad7766282b1a0cc1868803a43a55b57d013fee329ab7cc41b1fe4b241eb9441ca317c854bdf2c82785e481865244cad98780cef85e0683e917f4db72e5559375f329d3ca6c72738bb8d6c8e82daff3dff75a50f7090f6984f8bd15970ddd3e68364017aa5467f65322c693a9518238b7b92e6ce475f634c81bf0e4962a836a01828a3490dace8513230d129a8d3c73c224328df6d8447e604044864fd46155f7ba6536a872daf98d4ad526adf7f0116a4c82b7012742d6ee2ccfb8998810e35141e7f5c93464aff762c14a0d7d8d406e6773dd169406c6c26d5c35f0025b57f5a42d7de50c2bc3e16b5c185c523ec98fa907d1a07cb9c6d061a4fa9c32552da790dd08d0268c55e22e48be0cca4563de12fda1f4d74e6b688be0c84f5cf626c344499b04604e62f0c2d8f4218ff041eb85e6ba5edb8741bdedb034a9650b1921d90c7815ce96beaba60243f101b807c30ffd38b0cc9c278dcb1a15e75ebc56a00578b2bbc4112948c390cdb28028ed4e62f9a6372b988f3202efe90db5d329d97a9f59435c8573bfeab51cf46204a0dfa755111ae4b2a1f4b85f03af3c05ba10a960c8e52c79be68625f1d0dbf3b53b46d8ed989b15a7225e31c5e4502e41b03418b955e312c5dddc9ed18e2391713d88e87ed731987cb9813f09ab301522a1dd210c9bc62a3dad301d745aaef361d85b9791610cc901028dbaecb01f39b2ce0cbaa37a9e57f8541250104f41b6ee1d551cc4f28ec8d0c7781be5abf9ee835d9731d03c2053ac21f34bfd08f648b7c470479b8c0f861266e6d81891f0903b266b49e08c86e36fb80f51c95e3f1320639161c02df8c3b59049192ce597a6fef997fbc79eb0c78a3d74fd634cdc49600c76462c26bff521bc5779afec603fbdd110997e44a0f428d479277436f834c69892872b62784ff86fb37714c0782f3624c773b1a1d5547b504a8cbe05b79762cc2a2045e2e2a99d25a370a63f14e39745f7abcbf9af2c7725bebe388f2ac09a3ee27c6a39f0d12a08393807a7dc58447da1466fc561055429b94105d31a9becef83b9ac54b18fa2bda8dc37d003d4553d6694df224beccfcc784852b175dc87ce612aed64c2da392aec4a6419853b7a6d2e1fe4efb2d5cc33762156fa15631d3cd55b6ae706fb612751fc85709f2dae324a49b090ee915e8a3dbf0eb496e16f8dacd5d7681e660ae0b34454506005a7994d3b30d81bea7b60a198958780b095293cd26c141b1e92535380a408373f775a433b3aa4beecf4b87103755dea5b53f78775c59bbaeda8fcf3cd45bc9986b1d48ccb00467373cae9e07cb11b55c079b0743f9e84c6df943409d0d671fb333b25c47e50ab190ce28d37acfd4ab5cd8e621104153776b0a35ffcc6cfeca8e331259779de289dfe5e48f529998cce45eaf578871cfc782e8b9c59257d764bed442c9870562111b7c2dc07ff5b184be255f9aa1ca9e483fdf290ac96a6e0b94959c8e69bb307f60ec95160daaa950d2b246cf5e6d17817e4df3abcf4b0ca70f324731cb43ff81341c544ff211a8b5e68555e1e3e4d9100ec75c8b80c843078403517f2cb0d3d223ce9247a815319543f76ed064f291e97e21b8dbf450cf22008c6c13e294004780c606304f4d8bd96f00d4f403221cf7a65c9ba428b5137a6a7d345c16d6b2369d828a91bc49743fd26a62a379eb0641467dbc531de9adbb4b39e1210b3167222c3de86f089d5a76bb95ef6f1edb3d8bcecfa6e1fbfacd239b18befabc80f2fb5a41ceff624772c5ced7c232d8ddc69aa702cddaba3f89d18deb3292e836cc7f9e309c5e06da82aa970cdf281309274674fa2516f69ff2f7e0d57230fc7980f3729d265609c85b1b3bb3a7d0cb1a876ba26f87f201639e41ecddd99a9be94b5062adb35b3834249afaaf74ad4939335e6cd85926eff0b0ac9f2e06234d522289f2dacb3b3cf81e0ed2479666763197bcedffdde1028f538453e61a9f2abb59944de2100965c6ffc8f05f8a507444539b4c614a2b31613a4bb2e3b8fc8304cb3b0f5fc6b0933d655d27f5407caa801648ec2fae87da57ad150a4f73b1f75561204163c35883fac719a303c497ffd2e1a8f5dd0ba9f269bc28924faf434e554f1accd88d9a2d1d888f434eb12d323613914e45ac35a5885809cf07b67c3a89b2cff1e792199d022d3ed2464d3b6ce6fda60131fd805fa1dc57a827015b145433504fbcfb90961d77407c6a4d71e7c7f898f2aa12cabf3102e85ff778d77c76d114663166b102d27773cd6dc36c9a1d7dabaeb44d0b9383b74bb8ec472e5692f0cd9700a54c618fe60589b4263e296c73d79313370fc30aa98cd6d4054e183540e52434ddb18b90dacf623d93fc312714fddc185b5ad4d77fe41d97bf1f87eee276218ed29d5cca2e128cd004de4d32e0da3dd1a1fea507ad34015e6df1687d037bca91effa1dfbcd6256f734678e2c43ef1a7d1a2654750213a83e3dbab57de18b96509b004d30699e11aa6a3fde9509af7c66e16eaf5247f68c53faac53446889573d321032946399ac7baf8e57a28ef27c65df5de51554194043044e11d566184e74376c83cb4070c93a727dd50fefccc86afe95eeae4376c8f92aa03da4ea2461a2e07800f74027bf7aa7398ab76605b63b88fdbddc978d1d220e813aa01fcf918bb45d83917655e501d4ae6bb2e6c0292c9bb52abb8676525c09c32193faa1f79039c0a209b39289c3ab86c70ea51aadb0dc3b69cc018c79c263ad672e41ee2696ac9b44debf55a3ae8d7654dd870519969b9d41e52253c4982229e1315ae5b285d3bdc537749ded2af3d7cf261190fb0d74af7d3e78998c62fe76e18a0d2f09947bb9734a9e4b217d958e361d49abbb9f5ce1d76c53092d699089fe9f11bf8c1a59675781339d8757f761ba9b8ef70acb637d6af8eaa1c6ba51eddb5597beaf6b39360dc8add10267bbad08c5306e31c9a05de6ba346a669c9a43abcecf7a3c3643bc49be1f9606cc247af44c0546492e81cbc433d9f8ed4055e8382731462a18b2acbab7580ba70ef08533ac4dd02a36dbc8dd3d79fff836be73b60f94bfc38cbb95c8e007429cc01a0a12d89bcef801c329b64ade53e8f884b46c709942fe41ffde8bd7319befb4f3763e0dee691faf5ce3fa5a54959662bbd52a9b913acd7a3306ff52ad3ee56d3af383c43f82a965666e53abb815272e112b624746d1309c9865640e0867c9d5a082405a23061482411338d47b184694506ef74cbcd28dd3bf6f49f271479a74c2263f4f7e7cdd584c2947a9bec5ead4a9a534fc9914447e6c4f3168b2c26f81ae36d9608a2990060ea192c4a2443df369532102bf198e9b3cdd76d65954f3025b7dbf4dd7a0481fb389946133d543dd0ad6c7ff829d4d16c59107388f9524bc405d77181be47883c47e871173ad087f3a2e347b539883b2ceae6355bf64397a6226c5a4bd651206d413645194cada2e66906e77bace5fe6b6744d7b9a7001ff2a743f3320bce6a5ff4960c5bb737daa38c338e17859dd65795f0770f3af7596613aba6e1bb18a9c879e2afd7ff477c6d34a325ea28bc0da091e6a511d756bf9c54bad4f8c02381f8a3c14160b7e0560b7d5a85daa5025703476895264b74a84bfc7a70e0a7d5c0b1b427ab4ca0a8985cda6d2638fe9a47bc33f26dd7321bcecb5a4cbfaa67dd4ebe21e5f98bd81b4f12e9426507fdc6ed59e55bd67f5b0abaca77f88a58c8d4f06111d0225c387dc4a9d2958c6801bcd5a3f6df9b5d18fdda3106ebb5f52b1e9e6310c1b01e232f2d6d59a23e1834b934e8ee743be07dd44aa3783a743a847d5c739729aa9e2581acf9fa08dd6236dc878d26847f38e5271674d6c6d85f93f25483c82350a5accf7577995d0ea88b84f08df8cf47daf3957b749e97735a987fe35a5a964d2c1c8a1a240edec2dd92d87686b5592e7c571e8e698d88a5ab53fcedf3049baf1aebbbbe102284cec5280e078bd5448ce2e5382582ae505214fe437410db372c46f7d1ae9d71a1e00940ca192dd4e55da065f140fe461f4eefff368b4a272251bb59c1a5e95f2be53fbb7b4862d9da5982f57fad1b3ba5ff0d103c9537570ce129ce434a21083e046b1d5297914b3373f3f163420af7ddaaba2f2734f941fd05127035f6974af3d49a6d4623d01bb862f53e65e15ac0f4edd08ef1b8f264307ef6586463427ca8c22ca7d7ce4c77a3189fd9bc02b5952c2da1f165f59905929aee85b57e67f1633e65991c0f0691490b8322c20d6a3b600adab8be78d49da3fdbf2064c8b15029cc0229bf1f4a47eaa6d94242ff1added10f5046c645e8285953d96d60b0894fdb203a82ddd6c1cc277736dd5d91f87d56b28b14ae811f2005fd061fa8a1850c118471fe48467f580e051cdf63d267389852d6b9b39cd49690590c82fa5b30cdcaab595c827b74153480d702493b31e80a63dc583b335a6b5dbb073f354f86550bcccbd0127a8c1b6c2d39cc80b6e1375105c59361c942d2b54a6d69454be4772c59955307196d8b40f560369821430c695a344503a35b1bf514c68b4b2a638eca5fd1369176721d7441d57453b58ffbf354a3223b11e693d16797ccbb0c11822f08bf5d88a66856827ed928d02800c84655cf62f219df5a364a876c21195fa8b3eceef5d2d509bc3ca9b6fe375e2c1c51510683a359e4a41f9e444669d4394ab2b9ac519c11cacf1d63a980345d06234b7ed47ea99bc54316ad22dcb3b649105ad0251feb0ef739a2b0e5a750712261a59e6551777ff4f88fc812cc74ba7583c03ce80d77ee6678c99a3a5e8ff4077fb4c9aba16c1c916a96a7f73e19d32f22d7dc4d4ad2601d447a1192297191faaf5251fb648d70c91c438aeb04d612604f837ef7c9fe4f4fc9c00171bee621ec9330440341fd451fe1e4bee1fc4103198f01615d526810b4babc73f19d222ebc0845060f3195a1b44e85dd855b0019948025ec8a5fe80a80eb624a649ff44c65ee81261305657e9632dbe2ea6b6481b338f3dca884183a0fce39609bd52916a79c0f3c626f8c4861c273a1223977b6c50c8b70f545daeeffbe74af165c96da7a8b40f8be291c281c436bfea151f23efcd882edd3e5183aab3744ed952f3b9aa9ec69a2e284e83bce460891fbca7fa327ed7e9c65b31ccd625c1369c2ef3cec8fcada584f7945184bc18a02dcf9aa90223b29e6ac36c2e59ffb97b5b3b527a62cd5eecaa48fc188bcbd62c748d1185f374535f5339fee3cd50525157d6476ced6d5a3a12e810db471df1d0caa02c993996aa362fd4448b706f0bed399fc0e60efb14c40d958a214f034b8e2a11d794ee756676603572d3b15590a3b613cff724dc38f58010f12a2d4d0a11d8d0a444f71afda8122d8ffb1f67c2cd1ca699c34836adc092ca263da19e68a25d89be012809505438c8b1f170c78e18fdaacee4e94b574529e81479853bc9a249e37352ce2ad616545c593ac08c480ccc56a3b971f78ad735889d0d31cfe7a298ff35b03067ec74b900f487c8c7311d01119aa7b9092d56b3ed200e60b9d5338fd28d35afa16c0f90bfa48cc51e63937d0246f2b96b8302b28b023a9775c96934b481e5ad44015bdcf9cc974e82c6d118cf22a034510edf59855046fb9e22b383a18e751be41fd53738f490c978680136242b6ed883016da9470099b16dbf5635f5485a4b75e91d77a3df158ada4d14faa806978eec69373304f062013c29a4eaa47fd7978949ed9752ba81a7b1c642f91c4a10427770713097d770a9102c5a2c3cae655ee51422f6ae629e0f13af962e3040b78892f1309fd02066677127f39d2d23fe42395559d30772f3149afdac094a2d2a3140c5c2b82755bd73b7a7dab4f8d159d866d4d01acf5dc2fa3219d32812e78a2f758d873cc6a391fc9bfee69db45fd44cb2eb407ef2c8788200bb73b884bcc093cd675ce5a1bc16b7d5bf1e199776e61a482177bb8046280a03b1c357731e1a54ad7825e2bfacbc551e7e46a2760ac10ae825360f3c3bf07dceeac5118c0da577adb529c290cda4e49771592a3fbbd3f9e06bbd7ebe3849669687219fe9d29b2dc81f7fd40579f6663503fbff9311a11f47666aafb9b50af95ecf6d1b91797fc4a5cba1b996b091e87e2d304cf2afbcd0bbd3c1334d277f6ada74a9bd90eff61bb548a5b4c0693cacb4dd13dc5e273f3086a048d844be802392f4604dceffa3502d9f0b92b7e9a678e73803ec6071b3bd4459f47ed10423b1ee739e970577de54712448c413dfca5b18c39b714fe938350200315ce528cd389799e97d4149553104f07d1e94038face418d815c47b7e99a85388662d8faa3364432ca8622686f79cbb3cd9a7257b19a0103fcd4a76d66093579e011326e7b625c86c72328c2e573e1b837590b47db41c60c0161b94b93ae0f8d04954f04c9f05e8d8584bd4782ec11e6ca449622d69f4df6b729ca572cd70355f73d10517af8704c999be0922e6a701e5d4cb91c133b89cfce2e8cb8aec7e868e62c8325c0332bed77e0d67338da3a8fa2f45c5b6bb315313b1b130d9292693be3a73fc4c5268ea9aa48b7adcb2c868d50238f0af33fbfce9faee1bc576af183d6ca690f0935475f58d5562b5b90afb4673ecfc102473aef62e0018ea8f1deef2cec91aa5a5cfa022fb73c3383a848dab2a72de76bebbfd9ab1eddb1c0a14fea9038dd246418a124cb11288e27aa0f989e0a354654d0b68f0ab949c91f738c1adf0104769bfabd72ba113f2eef20da21928f15d0245a400d5d3c0858dee60974c63ce8727def35fd39feb06b6a567c1f7fb3299fab2192031b147424b79c9c7afd1dfac1146411399e99840eae27a035c92be8cc0dda294afb19e6b6c0d7076dbf0e17745c9db90106ceed9812db6e8dfb77d1d45144a81da9e7238cbd2f321f0282388ccb92807b3b845f2bc1311024017741289cc1e25b28744fe4b8c1e75ec5be0010b4e36d9b265dfeba5082ec83397102595893fd8e78397e3887674d24dd9e8eaeac699919f0ab74630b264d4332fc92349bbb2e5a3c79595fef4d8f3a999ba8a26e2b750351d7b505cea1338eb01093201961064515c463d1e5ede84a8f5bffee42159fa66e9fa0c4c267e6a00b2b146ba51ebc0b1a44f6162bc2116ccaa25a02d349899ebd28746398082f7673b0662be756e66eef1c51db20a0f030e12392fcd81a58b2f2353363025811b935e46d0fe8ba4f7ab58494ee67c91f3a669544590cae4f8095b82bd097c2943f275f0079df60e2435faa0c20a52c9963af4238903f400cbb01713a3382b57047e23c04453851111c658df3f7492e6fbcf7fef8f73b9745acb7f2dcf0597b10245e0861fa3a02b9b67ea4f615b4142af024eeb27c01eff42ba0d37f20e502756345f198b28d58e8ececae78cdd0730a7ed7301281c0274203f4d09d0d38fd22f792396b837175687a126403e795928e6120586be5a43faca7a6df307b14f2dab3bc2a3d07a97aee465fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
