<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77cc3e61a17b56ec86f13d0dc0fb179a4ebd4cf224da002e6a6fd15168a82bedf8400086fd104321bcbf5f6046172ebd309ed527ce9ee85d4e6944315f2d57d81c8b2f0fe211eff83703cc340d01512a3976254cda659a778a6e7e5e68440163b6e3fc5aeca88497ad28afd82c08fff1a4725e6a55d407462938d8a3cde4807d5273eb9ca00812b3d962074ff4995884758f07cc0acf225b51d268cfff59a7a81cce574e1c58b67b7e97b6be4b3d43468d57aee168c92b655be878863a39bec5a1b38ddd4b3978f82294682db80f86af2369c83318d65b0dfb8435e520f944018e32c1d6d9dee7f1d9fb1a70cb2dd53762c5eccc7ea0a869f7daf4d843b07dd4bdb573f307b1f7337fc15c5ffb1aa70517d5441a949414fe53a68534e8ad9cc0adaa41652740d13daccee0862f7282160fbec6df7de347ee125880f15431712c56c8ef5cf71d8ad844d11569760c6a2ef25a1a267e14ce9346ec5bd98ef15be505443859e21b211a97bdcd1f92758a9ccd3d5fabe465404d3304d1e56f3b4f4b78df0c895522498c6a6f0b1b887042198b100a78b789de6fe28bfaec8b43fe3b195dd9487e57a4166b4f0fe2cd999234e5134b3dc8966d18db3c3b5c5137166f18d3873be7c608c36930add319a5064f1c6bd659a4ca00f89f90601c61aa4ffbcf7c306d7a3b1d05a1f986be40f66f952514fae048e3dc99ef3b9f7881744e8d060be38711e9d0488c1cd2206ae0c0ae386493c6638eafa0433a6a22183a18420c5b0ac1e97926aaaa4d2d56d99c25e2efb6b74974b2b955cb1b46daee8a05aaeb523c9b472d54333f8a16c913cf87ee24b06ef2c1b13dfaff16ad1acc35a5de88dae8959a30f044d71637bfb8bd2bb504e1150dd9d0baf71f5c996beb3c9404db0d84489b993806969ee882ef59cd3c13aac2f5dcdd008fd9e07e1e5618a169cfc9eb9639e1860826b66a9aa0bbe986684caa26e507cd37f1ccda483b9a5a2894241832015333e46e219a58b1a7a1e9f67b09de0acb1751843ea7a2286618f4867bf95b436a467d63ef2552849e76f454b5b9565b57f701cd0485af534eef0b3b18401ecd9e583b640f35e6c4466afae428a66166a707749299976af4dcab0034f259c7a115d86cebeda03e95b9f3ba01d85bf652640bbc299ffca7f32858c9ac463aca3d54accb04b6afd04cd691edd031943c2b1949afd88c27645f911f234f9ca359262052466ead011e0cf304ace076dbc51d7af81c2da566c0bc8b058c951066ec8f13c19744ee042042ef0ed75feee2ef06aef4fbc4ea3ce7fae0226245bf4f495aad6f4b3cb8a33ae2f7fbb539680b47b2773651687525c72a327c74399cc2bb988cb926e7923e3e14e654a15717561b41080c1d97445de5a906932a6783df6295f34f440396575abcea8a248d3ecccdc96c34fe71f578cb7844fc129a20ce5bcbcb4e085ca4d69e12a8fd4d805ca13f0c0bf80993e35b15db4925fa9cabf4f7afaece15a23775d2235f1a792f43e43e7f08092b7708d6de0cbb93413e29cbf74143cab0e70d57cdacde6b9334d61e1d2ecd4743d14f7299238515fee1032933564551b953bdfea45f922156e6fdf5d381af4b6858c9fef6d523795e274121555ca01b192ae206194115271c23839f537d509389912f14636b0d235d2cefeed7f2903a2a20089ad1209b66fde1683476ac5493f991e6e7e1e0b93119839cac1493f1901ac1619ef85bceed27b48e2baee01e3181fe22517f1c4dbd81b2b590c8c7e1c0eaf7066d042d97bba0dffd05a9737beb2be75b2ae3b5f473f9d5bb10291b69e93a87e3e6460a609aa10a70985268ef122591be2256ba43abeb1ba395a174c8cab10380e87107528dcd4f03cdc39fe611e1891f4af35339b8ed80cf82eec5f96294a6f03b676033d90172dce0cd287c45225b0a2dbda0ff600b978887bfe6fbb6194364f0d286e890d7c27b6bf5ffb00bf3ac07d5bfba125c24b26bf1dd68c0d2d1a9be1755fd1d32755a3c63236b4c6aae52ffe6eaf7883507734ac33b55b684f38a04ccf3eb585bee28d640d75889657b367e990ddb66ef6cf2853a44cd7d084bf49686ef9f62dae6f187a34f951c5a7f63076c94b0fe306d50a197a7b2eb4dcf4ca8c5b1e8487c06aa81cf72b75e8861574c1f38d40b791d0e92d9c312a9a675630734e655a530916d7c6316ec7e3a5e4658d02fe4f781e935e528d3fc90265a59f294e870fb0e218607eced5863efbd577d7e706bf443b5ac15d1c56382223ce74de5f242802ca5c34bf7a62b53f8f62093ac783e8ed27a9656f90af66002ad79670394481c9cc1fac8452a7ab47d8bca75d1fcefbafee66e782f73b2793dbec188dc90123325e93b3c455bb71732befeb3c0f05175b4cd2ac464390ce182b47f478b526403f665904c7c316022336d025278e6c69c418d9de58887175d2915a9f132785e13a4116096de701170b1b53d5072330fc2c27faf57e7744e49e95dc5f17aacef7318637514c1669ee054b5b52fb486a87b7b83115762ba52000d204ec54358eafc34be84af4e740c0ef5b92fa0d2f60cc13da116c3802288dc9aff71171865099d4f2fdfc43d6d3faabdc6e2af35e3a2c6bcbf0df8938b9cd401bd6fa5b3e28179c217d6f434d1ba35c98f0630a050d326142b882f9a3e94024a51b25045b6394d53579181094b3f3060666e6d40c561769c0418a2edd7a29d966abf8283fcec3c605166c893293dfefeca95c2e59a01307c9d515d51f03235770ca8984e2774cb730644b4ea030529d3cab2fc530dd89f40ee87dcd24b9b39b9b89e51e2f779b23c3324fd7162413801e135ea047109c2b130277e19fc61549e4983894c7ffbe74be1e4973e5b0e4cde1a7f8037f880f17d1f54eedc51c9a36457502cee1604fb3f2a9f736912fff5a78c6881270232dce8b46e5a0c6300baa06e083d52cf4aadb2f9ce614cc9803d10b93baf80c3b52850af065d63873f64f68c5247d3c6d44af92e24dd03bb4ba7e3837d0da30bfcbc2f33ea941ff1cd1b8ae0f81d8997511773573c327d1987a0c95ce7b54b2e192fb35d509311d652bed864dc9c8433718e1c301598ef098e5d3f090d9dfe0ebebfea6a875475f9c65a2065e3a23495580baa48258ec173cfe4bc1f14c032f91e6c9fa5a49bb9820276a678b448838a83e117deeac8140b063ab38a2aaac8760d949cd79cdba01ac9abdb85090623e4ea59a58218cb9b824fd74ca64a5b5e0452a724c79f78b022e3166c79bd90ab5052b12110afaa30f3747bcdeb453608c6a649dcaffe225d39863c6d55c009c6426f1e477aec3bb96595986f7ccbea227787948553d6dfbda1edd0c7c51e95648389fa3bec6e7305f2b828825e89df7780de9756fed9a9ef5c6bdea74cabb2e6623faa4ff71ee6867bd052d218747c592957d99078b4f1227318ae3161a4d09aaefc24841449f4b80f4f017fa43e4da77f42af1e2b61e6f8155d71928ac56b6adbac975dbe56b0225ee4dd349ecbce171b32b27124d46222f3e9710f21dbf30dd9a479883bd3a7dc215bea91c0b548f2760a15eefe1a628f5bbcab003b3cd938e0c628c6680f981822ef7f235234c6a4516a050a6a1dc0865d0416cbcdcd5c5e79cfa81b992f1308241c3a766e6e5e18e479c9f0072afe26d51709a411197f7d5c39aa500c53441e97d770477574eb710dcffa3b915cd20f6cbf53f8842ced75ac9f4f0ea4e48954ebadf8f68744f8c0b5bc8e12e108c73f9c103e5ee53bf398e6818e39703d79d174cacebc8dba625b08aa96ce56ba2cfd95814d9b0c3cbfd0f12ddd6144b667ed09cbc4d58eef20350f4eb132fb1123957ab9e97e1f304ae4c62ccc71b904ca68e0c2e8720f05b238bfa0d615196db8e1342782ab956789dfd821acd06bb5643de201c186462887169606f81d00dba0e25f2def5765d19c81325bc1e498b182b5e4a3a4e2913bae7fed7197ecbef56d03cb111cdb7795030a70361e25549a32e1f6bf590f3f97b74b34f7ae19f40e5c4e38ad2d39b0b7b4663ee15df6a2883799eb89e81ea57ddb46848d3f4f82fa8ac57214330a97be36e1e9df6328cd9da2c603da830d2f358d4a7f71e5f27d44df5076bc3b553b56df2fc20302c3b22424ff537ba4b5c6aea3170b8c7487aece92aa5c620118c0031ba11e2c8b89fa75da8b93076f09c5ac1905a9db4479ec8c23aaab2fc169cb22e6479eb1ac38796032bdae390435bc0975b606c31588477fc53ff57b5641bc7f9c5d71cc904f08382cc679567a605b0182549ce8935e6c16479efd1f2a03fd7f70cdb86704f370a76712d575950f7980d3a699de62e238734d080093f124f791bdf5a278804ff675278f86abbb26b1e24814b85da580f13dfdd0c05c3f470bf11f04161f96de25b1585fc3798eec23b2dc7a4db8c3cc44a7eaa9a569e25242bcade70b6096ab2db9df18f2fba9acf34c99f2713848dbf19a393ea357f55937ef2f6b2c9b84aa71c0be6640008d0f591a8588be5d4a6be1109e6ca812362830e128908797191370d97cf8832ff48de8aec0a233518914bcc21c2b7328bad2bbe1667b1320c383df8bfedc35994104cb67bd6d96e88808a638a9cdc42e212dacfd764b1623960426d7114e08e9acf3a4846a1318638a2e6cd000732f51fe644d369e049aed2669f89324f272846d449259a87023b66507f2699f714ad4afb6be89b2dfc8c8f6975afc7a94263c047574abd6fc2febbd12fd00d11c6bea3a9bd9bf7f350bfd61691b33d12e81527037c41206c4d4b528b30a4519b801d5c727d7bbed3cfa80bc03be8bef63152141699d3f3543721bdacf794f750c92fa23c8d59a0c441e74918e8366196dcddc3af84f55c404c705fd1525e714465bd43aa999d5a4f98886dde1e48ae4fe387b1781b9da8811af893c7ef8bd1f321dee7fcbf98fd6d0c589b485e122caf905ae578baf398c34e8ef36feb2e153728476e2e791fd93db29b1ca4bbc9841bba4fbe1882ce0a9aa36d9d3d16339a2be06ea216e2069af0d1201f1402c5cc51a6fe160d89d940885db3e326aa97a635bf936537e38c0bc0b2ce341f4b2f73d0e06141a8e8329683c5e30a7a7a8f5c65b0ee91ef364e424e9de41029d53963c3dfa1b36eb7ba04ba8096892e61b026062a805dd1c641dc6347755fd5d1d27786d8e62a679e94cca5428f0ff0b5c37dacd14700c8c92d7301e931598e597a38da848d478f9255270c9a929ee9b63973c4899b3aabc5262d892e972ce43754797fb0f3979c539407c08ead1e9074723ada67d2c2127a9ee9a0f62264038c1f8c82ba6e4ec32a569752b75f076e90aad3b525307a758e780aaa738ae10069a6eb236c013bb18e7c06f3d1f1fc133abcd7a356b7acea6e930c93a68de2d339dc7e3e9df40ef3d756183229f6a35abc89b48c2633296527577ffa1f537af40e8ec58243028020dcb7ddfa9c415d7f22f7e6da21c91e90857ea6369bf3a4b1b1670b095f1839725f2e4f7fbce38aa973d38d8d14d1a1294ff45b0a3950b50a030682244d20875fdec567768916896cf9320b54088d855e72968ed2b08561aea7ee67fe1b5931000c37d3902573968de3b2dedbe6d145c41f2ba36a70a4f7c764ac1abd79f80b166fe4b655927c07cec9c323159f9326be7244786fd0e3dd216786d0e25f262cc73c4e051bd45c5f347e74dd1c11c2a1a4cbee5e9aecc2ddcee56347f01ece916986648ca1a7a5ad463d00527c5fced9fea9cce23a632a0a2a50ac386bc9579cced2af8a186cc1fc6b3e398fba44bedffe0285173437c213d1f542c8a8d87a7f1bc00c5dd062f1b495773c603c7b62f072e3a2ee6c868943b7b37e4ad87c6155105ef6029dbfda0b004edd44c757f24c1e965820a54e9b58fbc64da70596e1ac6203ebe86684306f6b1cb28d2f9f27d96e9606e0df2e454f8a333ad49666983c50b584feeacd29e83d93894e7d7e1f0faee77c22f323203988a7aa12e1ddbfac30e25392f1c8124cbbaa8917b142aa1879baa2a0705ef5fdd7214526ad03621d6613a1ee4847f51ed1f7778b8998fce76d2314f9a79b160cd93d056167823f3267fbf157a33c3eef317e2b138244fb5327a3259bd82cd71949eaab72ca963f34ee75430179bb7df11317e6b13d694a605c9856d610d1adb6b2719ce25a8b5c729ae3ee44b38db677aa5127e80297a56a6f282ece17bd54330f717c88d1c2b84bfaf8b013c9892a67be7501a847635ee92e8b7a9be3b8758ed0cfdf522b51211c1690b8a026068be2f7cf2c98b618f69e8bc01292d38804f81b733d405a69ff3a4f7b10dbebea10638129c58193a3e0404e84f20afca426bd79bf43987a628f5c91482630ad2eae018eda87128bbefa5b76177feba790c65c9d0de77e5b40fddddb76cc27a84d3d70c9239add0f4887c6b051898733c731c0023e1cf510827e31923920ee31167771ba7f9aa188df7f604eb7b8a824f015e502ec3ab62d076a8aeddb0fccdb6903224ba99ccf613af108392d19c03e1a281073f54f13c01f82489b87b45087dbd049b290199c2adbf89f32f6b04b6ec98d06e20451f620b6fac128a72d980138bd29b949581c2869edc162aca8bb106215d15cbd075281acbfe3633b7de677df497969e0aa2da4251590529fdfd106a67587d482738f188396a567be7d084ec14bd3c90269c9f6b3ab7675136a880bde060adbcf981bb32ca45f3dbac9d8482d833fe720f049601c18061f5f8781ac5523a69c4231e8087e9f16211442327cb91e9b0840e13ba94ff9817bbc936d1172ac90c44694c6d868df5f8774b6ba33b92d00c07317bdbf49c9f1228aeaf62a91eaf0eb840edc71d58dffce754f9533e6343ff72941e41be760c2877791f5a389b486843e1883bbf4c6e70cfde4244a87fefc69172d0b8b9995f58ae8ef4135e82eebc7c5bf1b2d5580f9d7b579785b311c3faa4ef1df6e17427a839e95232a75aabc3041abc317870047537d011dfd5bbe8651ea5a341060d37b477ce73558da79adfc20f88e4c765047b91262ca07f47614a0a374cc6144cbe3ae08b3352963b7407b513f7143b3490db8f48ed3a2c4bc753f53fdbc67a4613cf11e97f1f19a0f7b97fd72b19b09229a442ea78eb9d3bdf6e0b9be6e5c3be8cb8dd7451f7975cd85fe305feac29a65474d1e683071313226d603f7b54c1673b2fd216fbdde00833e2cefda5ffd73dcf103c5a81b26820a06f9e5b4ca4001e2eb9d7662c85383a583b73d44ad41ee96547f03be676e76e4b941b38d0de392064cf5fba1a34413de53d9855c8a8f14838fef496f7ab51d2393fecb7530eae8f3423c5a83ff8e7e83c9c9d7c40b72c5f6ac693688b4e7bb6b52944585803518130e4864e444dd6c44b78fdc2435b0a4e4bc49a2493000fa307000549307ccac4185514a9626ea7f879e1404008407637a7691b97f047ed595f60b6634aba8d8654f6deabca28f8f13d9f9d71149aa566911d83aaec13ebdec5747843c482364264ad83751f68c84749a871dc33b7177d3bb1525575174879cc4b61d8d7eb02002aa92e7a1fb843df7892086e6fab4c87112ef760228d3077a7004102504146d697448ba4b39bf15310d7ec5ce4ea25425ac3fc9efdecdc835377a9285564d5c95e9b6a8cebe22627f71781ead6c626dfeee2bcc9ed9c74a692305d4ee4175da2ae39dea648cbbe0f0321c06bf49b416972b90722700cb1a523055738d7347ff51e5a3a7782f6251d6bab2b6b10c61300b1ab06fb43f965e1a53cfbd46fe717abe435ab9343f52548b8553ba197bb750d8bb51a726c92a8d750e4cbe3346401d78c09e280f87deff5ed43cd83910d8e8174b2f14ad3badd62ceec327c079adb6d2449afd357e08e4f59e240508647a21351a31d0cbb947108dae8def662e4ba4c4167b8d0bad5af13741902e7499ac300492e30f8518196d037f183f2f46116628fe2e5e619ad5ec2146b189b2833fae390869ac7caf8976853b3b75b492805225566d586a41d58f0715482e840018c3a49c714b9a1283ec885f0fac40692ba9628959015e665d713dd70beecc2c9079ffc7badee917474007fbd10993aaf4c18fe14b0e7ed5f350bfe24d751bee949f05f33600f605c16ec44189d3296693deb42485b4a1910e561c64658415d283a39f502960f5a89d4b37f1190c858cd4bff81ee035110df04a314ec3175a5e0b45ff5a81d923654c2b2f41dafaa0e4d12a8d3f2f33f92444bf06caee871ca1b4f339784841200ab48495aba27ebca8659d57e44c7d1173b7c2518c38f663dd90a6ba7ba75edb5f54c95b19d602614a0ca8aaa630c44b243d85ce7d9802f0df40a8ff329f43bb46ead69619c3330427ecb56e721db7084a8260d0ddbacae49fb2232e62958d455b6f2743f943d1f016b5d8e2b9578c320b6ffefbfec7909d3a96c9062c0ef746b3fe5dbf7ba94e1a621c222fb7d7e4c24fc73fe33eff5cfd3fe5a6b79711c17eec2866090407a6234a990648c118d4a793f12a0125419640f35788fbc73a197739de761fbed52b4caaa61aff08973f60c45eabe114babfae809007fa755c7a67b285818358addd039636d7565fa0c6036f7d62e166ab7c52a56ea2b8dcf72f870323978bdaaa8ed92cbd1cf3e4dfed32fa8d884064dd80e9e926e50305423b8d7137d0cf153538476578d387669b46fc43fbbb1b89272b4b2ff33c84d8c63be66e1c9524664552fa35ae4553aba72cae5364225f76f8038e309014e44f6f118014751dd86b814a617f34831409c23d94fcd883fef8a4a6d64027b5f58d7d9e1a89f8bd4261f6f489880500d1901ca162e645c659d610050283f3993d8067b52b987ce1ff90680cd03e6f1251fd3215fce65c8fc00f517e2824ba85583ec56127ed647ec1f6818b740da40ff2a03c1b29c5f8c6ec53833bb87763ff927da3e902e74311a592fe6c952c9b2ff650fbcbdbb401516278f35c529a1d3cf4d430738ec3e82217df825c145a19df467cb21612970fc09695e5e6c7d085471bec3a4cbd1256d1b0dce5ed9075ded1729d074beb0fccca21aeed1a8348ce7d288d55d190d44f03c3bcd2e7f16a6c1a1cbb96fa29fb5db4612222c807bac8eb485ff9fb165a828ceb6405a7bc8fe7b9e1706200da06c19f963ecdbf49c5e45e7f75e3053a6921a086ffcfe84b79e7e57b3d56abafc5cee464e3f66d3dadad719b6b489625b9566b1db3dee301d788b171c05de776504731df4db7ab7e5de85092898dda52c7b4353601fa02d43ceb713760273c489a8e9954d5d2ef7bc0f58a702aefad21c7b6eb49f348110dcd6e94fdb82c2cda244f76ab84adbba6925a959ef6cb47fb0341b26c14927f71405c85a9aead58df81fbc4fa9d138aa7dc5c46a7f8b9b541e4aa04f845387a47a6fabe3220dafd4fbd18e6f140ca77093a01436ad4f776b8b5cd89e7c52948565de71e996c6f6aa9a1f8e78e3c0b2512336a8c1db5c980e716649791f9c6f25edeea5850a006cc427981b65493f6be0ec273fb3a76957668cdf71d6b98dca9f15730968d7d414ce7f17aa163ca89f89b9dcd3a2384c522edff040dbe4dbdbec3612eca5c8811c13fe7f16060046a064cb94eea7bc180a2292bd553995e2c11f3e93be2c2837a58540615c98e59f11a989cf14f7dec81debbe2c9f67ab0a3e3f8670043dc3b1bb2d50e2cd39ecadf1acc2546c89fe2f984fd9109f040fda2c810ae379a8fabb34f9be610b8b87fecd273f8205e21722c793ce903af43ec7ca551b81628b4f1e6bd84f2aa4de00f51c9f323ad9daca5b5dc19dbfdc239122e9dc6b7c58f3d70f656f8b9f8c2c2e933ea813d270bd09ca1ab180d22ed1435a3a71a6ea2b8bb270f2b3cd4f19da3748ea93982b6438f9426b6850703c42e40eaedc55c56fff25fc5339a80bb96b12e49c14dfd8a1f54aa5a3655bc69688a7c16d4f37f035beee2e0039715169398a8873a797f904697002723b0a1b68fa8053c35d5fe5a69f7797516845def30c75bf1d9172416075a85b675b510ae4ce6ba16e13104a18b9fb51eaf35eae6a52914a100c5ce708f5b8dc14b5a1a8004cde19a8ed78379c3a83ac8ffcfd2aa193cd13a4207ec482e5648613411bfdeb2edcc721d83f948a332e501f0ec8e43b2dd68a13a75d70969e734e67e75263f7544f6db8b58acba2ca5abed620fe154d59ed34a458b3f9e0811dba043a5b958f98e862fff5299d3870be23755a179d2d00854de25e3b0feb75fa891b9885c081d5b8cd1b8e28c4da9064dc0ab452e0b5144dece645e5a119d958d4bcd1620f5412e2694b36e6200616c1b139260c7fba49d715d5dbe2f7c877f8bb123367f5825a9782ee64d0998289d86e7947e29575cf5aa1aa6b3011ad1bfb50bdbf94a60ab872844e2efcff6e6f59d2c67c170dff67f176f6c37831ed4fb4a51596035e95792198defb5103e920ed4dbdf631ab6424934f40d01f605f699130977ce0617f85ac6f5a9c379f74cec74872c2791dfc375e8554ab4a63693096a491222c90a22d5d46bbdce1f4a21c61696f801d40bd593d7b6171afcbc094c4b7369993ece1631025e25eeac510125077757f5523ddd1b7b627ac9452a0c257a22a9f7b218fbda7470a69dd0978f34c6e284b033526579f08b877e7c670db68c3f4d6a43af53ea3de58d07663062f8d91b67d5b365cb882b624fe346264018e27c38a8d7aa1c6d11fd4df7bc9800526fc9e331f1f7e3b7139f523dee5a12f41cb813a1e5a6e5461b9dcfbae19e18e84a37e5ebaeb2516b1b759ffa29d8f86923c842661e04122a5b37e7ac0127567fc4e99c4cb0c128fd5201f98ae1c37bbf5ac99df32bee4f62903bb1442a7a7a23ae897e8a2deb4803c79d13ba1d5608406c85d8e3bec6b87cfe905622e6ef6cfe9ab7f3e6ad99a0be2e049e4e8f2c8810bac7eacc524869ab8cea0d81c9d64ffeb06e0ae8761a177bd583955a7d8c198a950ea997a5f8e9baeefcd499184ee8bd758472d9523a794aeb26a18cf27b0c80e99a568cb9e7d077eb87a4cb3e5897c27ff20ac18c21be06351ec27113891299b1c210f49f0c74dcf881a202f7e97401deb01b4909b0a8f71ed68164c990089feaa06c61e800a922f032d0194dc6076dffe54c2cb786d6dd775030f03f5e18c0cb96a67004c1eaa4fe0cc3e6ea21bd9e3f40b1f5c3a8765e356eddc31ae23cf472afb6e72c7c17885f0c895cdbd858f131dcb2c305d368615eecd8aaae8513f7f524b9ef8d2dc051de032f5236068cefd942e4e250bb5dffcebd579ccd62c1ed6d1be877f16a810cf4195a8b9a13618297377eb6c146ae97004b81c5c1491f185d205142a8b9515a11c2cff73786e6bbe09ceb4db9b29d3e5ad5a8d15165844733e32e34135ff4d7cdd65d3d79bdc30c007120a761da76f8e1341bc4225ed7172ea08d5f2d46d92d659539f2454014407a06275c4bab64529d29c8d997fb599184efef013c0c00928a78c9f65fcbd7d78fe780edec0f511432246dfdcc921b688aa6be88ad014529a48d93ca2445d3aaa02bb35b77d9f89416abd2d5b65e6de3a04df31207dd7a7dbbe079c52d9a6407e2c82eed2940fdccf86790994e531e7efa7f8299d94bf231b92e9edfc350ce6bf27ea4cfac24842cdd2125aa7452674a67d915788f64babf6816fb28c308e166d558f9dceff758230d2cd97d7c267051897071eb7763828df556a6a9dcdc19bc8bbf891cff6bf12fc27dec562f4971b29363199e294bfbd5070459d6f28bffcfed528481f05e90258c5c142d5f0388b70d4fd8119cb3db3a79ac210134c7ec4db6597911987c5c819cf03b32ee8308b8255e9034be761a48ede0497e667e7038e91216d46d87b19b2cf108e55570922d13ad0b4fcf5ac618cbeec2317b81b4d1ca29c9eb0a9270ddaa48d88699405075a162aa1a51b267a7822d3686385085a084a7abc7663a33bf28f95f36e17704099a1848a9af5512f9ebb32d144d889c03637e4b13769c60ff0f5f74e96d4323176f348ec731be469fb4d66af15431e5ace94208af82164d29069d477db8e3e81bdf6cbd0d99e586f905e639b89fed75759aa3143424d7f61b4357ee95b1ea51a6ea804fcefedc59e8e5ede0b1fd2b705a4f008c31702b4186b3f2769e707249ea0e3e3aa3bdb8757ebcf12142dd0c082e39561912ac03ef3ab61740af5586474d1e76d57407a046c726850171410e4699ec676cd662490db862fcd06923550627caa2d259c1e76f2dda088b24b0564076fea05b7dab0abf3886d939f2358efd28191aa950ec7e503a19e33bfcc01c89f94f0def318b5aed6aab677ebeb587dd79a6950a3631bc39573662e6813c37723129b3e349ca4eba2fd420cb4b5ae25a3f8aa2fbc78c3878c8c031f3c8a1885149dd177d39b1d234e4964e7562cdba07316a30de1e00d7f157c7837a2996d63f05e09d8102a8a36ddaede1dfc17467e8560c1477fff73144c2f3e863b130efb5ab9329b60ecf452e33f69359be00e567e090516e2d96fee4c9650fcd26629e5de4bfdd02aa7fdc4c97c75544cf9f8c64ed3c45faf847753966a0caa1f1aeeacd45eab2d50b29d05febdd8a2eccb9b133d51d53c49a341fbf59ec0ba401fed5e808686a4e5d9a250a18a8101c56cf4dfa507ba2a05be3cd71fa8e247c1eda169f305bc15d08507bfd847c805e33ee39921637315bc4933f39727740b417fda4ed3f8ef81dfd4f5178d5fa4bce7b0e433a771ab375e48febbce53850916a1a741d8129b80ddacca7376c900fc92edf62d6d96ce26f3feb2e75a8cff4eecfd89ef661d71ff1acccf66ebc637f04c678808bdee823737f1746531c63be31833e7789718192849ffdd39019a7d6c927e54e8ac6d16570a266aeff02a37c758ec15c1be27fceef50059e9a57fa41e7f629ec74ecc361e09c4a717eb57ae3a48d3289ed3d97a58ce5f387f302f752d7919cefbcb3ffa8a265272ad626097e2cd547f7a8b878ed62f806008b133b943cf5a30ab224f7b13095cbb623668146de2d4a1c12d94db8d0183327c002452afff6762b50497ae130600a20189e60fa048b39d41157cb9713534d8a0df56c1e78f487ba974c4e52c2639a21292ce5a2c517ca8d1ea42c9e4b1231d3c38781f1bcd9d95db31e6aad090ba39f159391c45cf2c94b85a5136cdef1a01382936834359f4a559460035353fe0b3f06150b62104e64e1f1ad38bc1630bbb3ef1d172ffe23b72c35bed44e4ccf9b55ac42b0ddf09167d97cbd497af5e67cec58a108e09b02438a408b9fb2c8d5cfc8790ef7e98dc9eb39c590860688258a664a95457488b15c43d25a8e2a02e67bcfcc8aa16a5380ca66b19d9511d82fe55630491ea40b7217b3bc2caa363c4b651dd90ec27d0eecbdb02336c1617685eedf01b85decbe591462b1a78dd6ef85b8df6b3abccd70b4cedf918f19cb2c1313182a5cdcb85810fc8a2457ea724e63d83e9067261561f98fe51718c87ad1461231290a0ec9ec31c92feea8714b2ab9c6211b0b9e4d13009447a009d1f08563707364680e01670367eaee948ca0e1af27b48b9a6c1bd51ceb3e8756644efa946bff1397d3e522d87b47350df948182b1df32c097f591345c774d85a747c3c9f7030d0d4f7c49397ba98df7d1565c6d520ebfa62e0df8cf4544fcc0e1035cc190d36c64e123fe1012d4ec10f04e82ac7cd7fc70b5c16ee929b3411c42dc4855313341a025005c3d505ca87512b78aeed79c8dc83d9d63d63a9d40fd7add5471f91ddc003e7dc6089e8172486ced52228712d8389e543cd47ff8b4fa52d08dfccef2980bac39f9a687dd01e5062e01ffda3d52e124f2d1711513cf72b703b0157ba83079e5097924403e2dcbe01a603158c0a6de9d94a55ce80d213de4e86c6c8c277d37c373c51f0f75dc41a6424a155a6e6d349f943a748b39716584496ff1519e210d6380d69bb401688d26e881ff327162d6237a5657e32d69194188a2f1cbba4abff22154f0a97d1685c21c91d9213beae968e38059838f368dd35c4921eedd62ce5d280c20836d2a7a7c9556c72b782b1c8a3e2d7603e1c3066e5978de41d876a652a775c0d5bf6f0583096ea831649a7132814e941eb21efc1b6094035bb961797c3d93b689e35581b097630030e26e1cc46ef61bc9454363bff20dde6d1b16d9e2474ec8831663dbec09121f2d7930cf1d6609acd77dc8f4b5648a1afcc31074e752d7581f2d2d5f8d54eabe751889bb97b767dfb3194875afd10862d4acde4c76eb5bbd326c53f100bca9a85b34ff53093140a9bc8a2be3c835a57fbbaacc66526935b2de0414c8dd6aed257602ea73e1bc9fada27a759f1b55d41314701025c366cdca0063e008abfa963e0e8319b0312e7d7f61e26971f6a88324218aef455a704ff869ed7ee0219580fa59230af75161a704f8f0951c005c56bfc14a4a43bdbc6d48c56e8e19ae952d6c342e3b43cdb6f297302d4d2c4824c156fd7a76bd26293bac03a466079772bdf23f7adfb299ff7a6534839b7b04ebf5bcf28eff47087b5da3457f3eedd0fcd323c799799494a76649df24f492b8117eb76a792cfc9e273ee30a788b882c32edc7345a53d9a350cc04e57f6589f88aa6400ea1b23e51a963a44c66163bcceba92384d3fd96025f3f065e22ef8f430873d300c154ceb5fce79775761acd77765920d427892463c790cedbd9b1ce4840365d6cd3b9240e616795313b8c34d676d90c20b75f9c0ea5296e57a3ae4baeeda99abfba859ca37c633c0a98a79acc8916fb65d9a5cac0d47adfe025ed4cf4844cc8edd73367d175558d4942cbafb7d7bca70395f157c49e86caafe95be4d59607aaa9a10a713b948640a7454263365affcf44bc518e3cdc859062b7395d7137d13adf80a6a2e5ca1d15ccad6aa2ec28d653b242f07292d9cc887a670ff3fc2889d00bc4d384379781b2fb6109273a8a6c5ed98e58e977c86e11aa85a2c62a0abb7aadd1d1adfaf7d413aa485332163be8beefa5b173535103a91f3252fbb0d6c9bba79b8d0cf03cdcf0f10429fa617e9dee888bd701407b7f1dbc8391be633e91cdec3d33d174e2796404876466823f941ca485b10a3c6d07634f72ed221cadfbbfbaf5fc805ff5360f2f97de56d6256526241c1227714b1b36c7ff4a6581bbaa87660c382ae000ec5d381ea3cdc8b22c8b49782af84f987ac288c8ee69c629cb60dd1a614dd3f5004b84e7d8927431e06afa858f3c07a4d8a0d3059f363c3f068957ad8e99d1213c419ec25c5e2543c40425ae8918f14cf6e35ce8e41ae542e7bfe22a3b3bb5cafe85e70f6d55d7142b7daea822ac1aa01d241ca5802f6e6b01efe0915745e48609f266afd847c6939a5456f1fff8ef89682dfa113b0fecf6ba3b5ae4a3e383a319b86450cbdee7831344df18bbe56a74988976bfb3b48e8893b87d0d2b3947a188b308dadcfc0030b0d3cb53a1ef0f8f1bd493b25b9af9f8f58d319b43650ad48292e2dc6ec3a220c829e985e66a12134c7647f21719b47b36ca15215f12bd3b82d26bce41f17a623e94cce4493eb3a4e969553b3e3e8a6991dba7fdf1065ba69cf8295b140d2283e12facd766fd70a616db807c9cb87597f338fabf2cd9e1c367726081da667c0e1ca89596ad8251bdb147c49f5747ed98964cb5bd85a93dcbe2cb4da8b50eff95a9a9719b948160919821330b3452d348fab21de5746a19c41f4a23a40ad41d1a9171fe6a9efb2c900d1482dacfd10983ab046a192d9d8f75be4d49871b76be5f29cee2b1472defa5b1f231aaa12c6b3afaf7d93844845173a9f71692ef2d79caa8f5df98c1fda65a58f1bb1ffd4cf71d10295de3a13ccd4f02dfd64791f0523b56976c8a1cdcb752222ff5aa387125604686b1f72f84adae809599ff0338735ca70ea4ee53379eaa43029d69a4a99cc554af4d842445ebd61bff03e167eea90d421aafa9167308192557f32df5fd64e661e6c575c02139d12a773ce06e24f9cb60d5f3e8ea0f9192e286967a9bb48ec48f965c5a48100096fefd6730e154d6c861d343a11224c983716eb2daa593b59edbf99f10d7661c0d9dcd661e09b588ebfb368f5cbea5ace859c277419f6446289868962706b0b866e9de4d28047f24b618423e374a4636c2887637bfa6b8a95af646f51bdbad4fec9f9b7aec74bd598a2fcc92f70d5c1e1ddc2d0eae27b6e79696b8d4b03d1979cbb33047e2d76f10d18d4a21ecc2c6c54ed61db937ebada383f4c848bf441ff94a578a71d51875af33766628f9fdaad82f6524efd72bfcc4ea0bbf77f4cc677509311d36c0db74ae7c4a14c37992c1c77d2f1b377a2ef9de18313b86317c4a3c2e18cd84d4d0bb18616a6e3c27501630dde7a284500b31b610056fa3b2ae5c9e5c1cbb5d238db0bac28cbf34bc03f0f5c4c32ed1e83d6ea2bcbe8e8d945667fd576bb901d7841f8c54170729d0bc79c2ab908a03d92e4eb82f085bd25f3a282e8881dfe9411b99a92f48c43bedd1b0580be541dad470d231d434597847f7f457abaecd6909e210b5a40d6c8ec14439993ed2387c95e218b83b679b75b6cab5dae20be13d4dd2dc742d5d74e035224298075606b5c94f3b68f6d372400a3fa93cfce4b8e2d020feffc51c394b4a1a2413337974f2c728dd877afc41b19b6b822e91b1b0d3ca617c5bc99bfeb6723bef72e108d428b4cec99113c74c8113180dfe72f51e33956520612ea0c66dfe9036204afa364490c6b69b5635ec0c1eea4254cda46c90561c71fc23968e681bcfb18b686417fdf06e1e3b23591d64a7f0a140d0e7158dec49109cea6a86b19f3ea57a4f769127e494fca44584d615da74e6978a84967bd97b9809d4e5cc60d944ef0b0c7ec8fb0852265ca202a332d190d4d2f9f572a7e76b6ff02de0cfbae45e96fc49158a749582a39118c286b3d103dcb68ade64d4758657e2fae167173115572dbe8bec50c82b69e6ed1f094c59f6b0ced66164736376ab46f10ec9c9bf0f1e5a5094cb1a0b72ea3a7726e333b2f0fe455324e8d5e2f96ec524beed5b3f048660e2a15b3f953b4fee10c6a825efca19e8349e2300ace876a3cbea36bd3cc1694bbefafcb0f45c9fe38b87c1b607996c90a7e58f0340fc29762d63c61440cc968ad85f35d935dcb72831482d9050149407aa3ab110b96d4f271529d3754017e6d575f9731a9535448cf71bdf45da3ee36c3d445c243539517ce3b01835b3c6831078a59f4cac499508942a6768b674e8051f071d09389bc2f7da0eb7cc6c8a0409bd3df2c1be5d5b81a5acc77ca9309847c33c884ea21c212500bac05d87dd897c1f6d4db1ee68b26686d859ad9a9923980f0699975414df8c5514363b036188f1e4e303f62ec62a6ff530ec0bc57f763c4cf324ddc6951c510b19fd399986fe58e49c047d8fed4cb664ee7bdcc4c4b651678d12079bac250b9077d4d9679affec3c61ce9f3e7203cb04417a9eb8e0578b17af55c462dea011de4230fc3d07fec83b629a2871862169f11b170fc420c070b57f208a829fbee1002ae7aca8c4fe7e11a03b6acb51f3a9b92cc0cc0ff9a265a777dae785a6f6e3eb8a11b64796c56490505a1bbabb4657cfa655371237db36b71e4680d63848c12f86ae5e1c361eec571a8316c58d31d36a58fff72b86190857887ffd0b16d345c28109ba86e35f6b2cfc372bc6ac1f2eb8941173bd48ee1e030d04a6902ae967b93a91404a08d7d869778152150d26ee312daf2e9fbf765ff14db35c987f17967d5302b637052a602ec4d1021d0c288c300531297867765c775da930ebfe7597603d2757579d86350176ac249daed182c6e2c5b9e34e637075e3ad53202c18063325efef6011a86324afa0189854279436a28f3451b78bbfa5ed3c7396203dfa8e0cfc8b7888a620e57884f6468ed717467c65ca0ab925f949b81ea963c991ac2514450302bdecfdeca758d87fd3028e96792863658aba99e15568f4c047687a91689cc1643dc974f9856e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
