<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3bb562a07d4769b7cec9c400bfc570564d4318f4650a7d16eea50d59c311b18c497443cf40eb7b7227570c021f95290f37e26b6b3d62bcbe53e2edab2afda2505b6ed08d738350ece190e66cb7981c6641873bd5204d6b915597f7327d3e5116d89e732e12c471642683a6b8e422be0006e6eaa3aee99fcf0d76f4f4802b39022a4bdcecd4bff9b220bef930d371cc92d413c6dc69b18a04b97b50d5b027bf19cbbcfe09c0ab18c8b50fb5df8361513742a0ec2bdd14e0eb8b84c20acc0eb7d91df7b5f868bdb9b07d3e9365ed88056c115a96ecadf57ce9c9d1402e6a29e5ea8a6abff3d766b366bf245f01f9f89fc6becf00bf3c490ef90ec2d5b7cc1c3cd437f9cc3696322ca245f332ef096bc5ddda3a1fb39c067ed3e76924146867304f4738d30496d25bdbb75ee7e2e1db8630ed0cff59bc37bc9eeac0aa9fed39f1af767cd5fb26b1ab02bf21a274b267626316fc946435e7589d77c05426d59bf6c40a899ab2e257f30b2198787dec6c1418071e8b9d95a98fec1d12d7bcbec09d48916014ebff5dde4798b65f7feeac450db18980c7a7b69927363f85785735343e4034eaaac13bf2501b0319b678c0bb23d1b57213417e3b51d5755d532ae3744ba4da5590875149ebf877db0dd7385ec16201ec032642f816e2486f115495beefe812baed20a0960b7d3a3a1cac3b99795341fb35d7882a7cb09ca36ffae782a7558d2f92cf920e0e7f4d4c25a4a0e57c48a4815d406e0d009192258bcf9b5a401734ca4c51d476a15bad0a66d1e3cef1f45eb2116f7b071a05a034dd8667a8d6bf0b56275eaaf347dc2d56fefb16fa87d4d74bf89ec6dc301f376966147f30edae096d2340b4b240af710a7556200e349cfee9fefd77f0cce92f5746cf7607b44cc664f006d640e7c9fd5851ee13954aa7d7409ac783041923c0285b986959ab20366d13e65162e9c8eb461d46983ad6e57bd2f7aae2fb12031d5e9b67fdeb91ffb342770462a1edabaad4f854e873e3a9750c907a2df1b317bbd119d49386b3e2d634c7c2c9d3e76a90aa4b76af34282fba921d3c0561b263eaa56dccbccb408c108c5fc5caec0c84219524a8a27f8de96088533f80d01a59d262922423a97958f1d65eefedca18aa99d7094f036b8b1888959d65843b29145b792abd6d8cdde21ab98fdaf48ec0cebc706f5784e2d87e42f2bb7bb459c7bb23cf766dfc4fbbd48dd0a25adc188d0458484bbcc906929162ec610611bee054a87e713cf9e5fbd089a24cc139254ab0b34bd90ea0240e15fc9f53fd112faeabd2428cae17718050f97f2921ba6386b166bd906939f84e868fd9dade1b3f16dfdb2d64915d3811498518e95b06bce713ff9aec0d7a6af4a0b7431b93acc1f4f324999e25305f27f3cbbcb55dd7f64a1cf8a44606b78746800bd85079ef40b6db908ec5f2bbaab0122df2fe28966f05ea20411fc319a53e5fe979828231ee20cd13e647dcb66c8413e569ce3ffd1529c5e942f693f280426478e8cc2d7e972f01f70ec9c842589d454584580afc9da54929a67661ef12bb0120f380fa738f5707e7a4070be1057e8001cf4d06aec8b00a51232d7192bf513311fd8bfaab6ec2f190c4fc89b458cc90ce64cda180f63e3b53f207af2866a2180fc767ce01db9745b83d447285095472e6e3213a9e14678181b62fa4cc8ef4bae1c23822b5808433ea71713b24ccff9180ddb380f7dd2b7ae108c1a5f3479d55209c8ca7413b65ef86d2c8b068f3334e56c6fca14944d368bdebc4f73eefea997278db025cf63b146abc1b3d5ff7c2254db887bc71dd72197434fd921647831461b0a1016a537b453c239ee6b4612ecd4bb447b61113a1aac0c43449c86e54371ead52d16067b6bd824069792ba7de92a23a348ce951a32015c219c6464f83ecb0a069a5abdb286ad8da74a5da47a439245f5b9f42c44a2ab05e3f98e3e5ffb869ff634d5114e19b38a675ef5959bd2ab0795dd9b2ae0ddaee69a6bd6e19d5135cbba2841ea393f1e04bc26ee07f2d264c56a1ccf9c3a573904da195d563dbb268d70871bdd4708b75c082bc08f7bc13cbdaed0e522d50053a62988a40d627772814223234fb660d01cad2f3aa4d71f94b5b6f178b7f106be8b429dd52852bbf4459647b496d03038a063dc4656c01b74901594784205ed47dd8627df8a95c36a66641020296495ff0c78e623a1a77067b345f6d96c016711bb6116dcebdd18f546b7a1219155c66739e36448b70de31dc59fb862d0b5abfdbce18ca8efab867562c09d800c689b4db534aed12f6600e9ed1074d807c96ae32a93ef38a4246d6c829f7aa4c062dff4dc4bd461fe9da14b1ff55f7bf1c2818e60e6c04a180700e2687565b30928452fe2d5f1912313ec036cbcd2dabbc79a23887a3ce034328ad0e7eabc8c2ab2bd7c9d0974820ceb6a7320c93dd4e92bab5213355ad8243eac7c347a9eb5a58694955d7acad77456e95267003a2216f42eb7d778ece2ada18d32e7ff6ffcbb13d18b88e9a808ff955cd93c13a06a5324d3a202ecb856669fee345fb7603cd12139973eb508e94c0b9fdd4087a40eca3e6608c4c30eb6fe4309ef3424732190103852e47b4f9189f6d562da4c3da48b3b7244fe514b3ad807faf5f8f123485d74b6a81f61fab9b0bf42272f12801d8854a1662ee6c0019402cc9b1be7812b69a0690d7c3e338247cc670122dfe9addba93046aada5f7ed2d27e210ef49c6c3b20156b73d4fcb2ecf4e0796f8bd6876783ff2636b239ad1be311b8d6a861b530e52686167130de182a557cce9d12dd873e5d18817d0b3ef956993adf97cec3ba602d6e4c768747bb4ef1d4e1c3a31d7bc5302b4ec4a499db5088d81ea7cbb09bb8114c547d80f762b7737799298f00dcaed7c024b4161126a0f7d8b2ce75f3bca5fd11ea23f191ee15368903fac3480cffad356adc89174dbb9040913407b83cf32019b774abc0ffb688ef7433bb640d01472d07a0b196714057c916e6993a80184942820e8983c3569bf95b5bee130e0a9381a69e56fc7cab4a82271dac805b645923b007a72c0c2ef7fe87f942d430cf64be193c646c2c2eb30a2ba4841e6b55e889abb92a6eabd5ac109cc4cbc09e057b3bfd9bdb67dc332d4e66dd188ee927fa97e8aef0d003cc02bf6d1435877536ac43879d66944c1c668b3c6d9467ec217dce6ece6ab850320f97a4b0b15b67f3fdd92b2b36682edc05125c7ca5b456e82a54ce98b3988d0c1188380b770d88a7b6988833e8269536cb5006b43d2036ea6c9d2ea381014fed2b894f4d1e7856527a71473bcdcb81fd4fbcf4475e73bbaf346a3d5d141a857432b00ffb56c3c0f054ec7f58cab8cf02998705b020eb03e6fc2a73d4a2e4a2e50c4b7e5daf068f980fa34448495f62153fc25aac8559f2653ad2c7364d4bedffa5eae01434019d51f318134efd20b4aab792eb5c3d7488d3087b5a333d012303007a12634a60531f2efd26bd67cde5792300fbf4a94755eb0d5da1f261d0c4ba86258e359abc283146c599454a57b53437efff2fa78afc34f3100d9830ea89a40010f9ae48f82b43b3aaf527fff1c246eb371f11a770e52271f7f894128a94498bac6a61cb0157c647774f88efde25a64223b3003894512cdf618d42873187f237da25cf2b58fb47b161c3ba1727f6374437dfdd21bef82efae300b6ececbee55dc3d869722530c0f50f77312425c772e414dd461f9c54e57e73cd4a6d86bcde5ad31c5e63277839a1bbf163a0452634e104ded341b0610d9dcb0b5d2864f380f6b0d1826af36f464ee1858f015e0e0588d5eb48dd31eddc287c5ad4c235601fd584a48857342d03a8461e1a44e581be3e8d23b09b13b2d3dfb9c5b052f355ceaecebe1daf3fe4ff0cde6b423c77f1244d9cd5a9c79d3aa92e95ce0c4b6a9e5973472acd1591382fa23206e7804281e4d010ad6c33e22a02af37c1d1c5dcadf736b92dff3b75e2da1d8ccbd73ef13736a9a79d98a6cfa8e5e4f3d038f446b4f98c81ffa2cec8faf7eeb0552551006688b895d38a069f5e165bd47b44924a347378aa26025c1cdbcead0a703198371628b01f53fd80cbde0d9dd09d4eb426e4c7ef486ce516becc72e29c25b593b4a3785fafdf8469d8892e9387b16188cbd4e07d06ec9b923e4087a71deaa80c905e7bf48d24de504e26b8ffbb6902bd43b7a5e3981120c386799c48df9a31f6d8f2148390b932aa21bd2fbb250feabefe5e8d15c3ae5a7f4026a8287c0d77f95e169c0532b319aa8d4079b97084cd8089da0cc773c25e0387ddf43ad25b13b5b744ad1c77c5003654d5a486881affc72b6b39e5a4f2c58d5980d7da04a0e13609d187b384e2a6fcccf12e7a6eaf790bad47f14e45fb2bf04b5885a1249d8e31839018a3e8c5984ec99754afeb626eda39c191ea332a58c90ffcd095981fc8b177476787c46e570a9edf49dcaa85ed0518f68aaed981ac756fea0689f0b324f49a3a89c92688ffa846ce1c328b88d21fd3af47936cc6705c3909efc9829b97e0a964784ac6ba0f318e51baffacf4cb582ded21761566716048aae477075cd47af5bb99ec8266a75d4c20f760ead4ece1dbf22bf5275be648e924feccd92815f5c1b21f2592d5a2db617055e6a4181214f46831a897c2c9b59a3c8ce782a20f959044661780e2760c42c75041171ead0528876351f45787015ae72727fd634604911bfda122e001705a690e613fb9563aa74dbf572fd8562ae9b5d1c6d707d7f731916c453c381a5029020273efdea85a07d360966c28d17df8fa67ef657373c648018394771634ae6087a63ed6c8077a3206f8af86845f34e711b787d99bfb2cc54b41b946d5d80ee0e4dcbb71fe501da8842ee34016fc8ede8e92989191f774b05c79910fc0aac5a0d89daa06c87bc9ed62fb960f1fee4eb3ada824a2f479600a0d37af9be36e37efd02bbdd0befdc5e0b8e56fd0e81383a242163ff6e10e47d338b191415396b99e3ebe43f0757ab2c3892718af80302b2118a7c6aa1ff070a3960973ba680e4f6bd47e4b0a03c494dfb235d00240b4376a2bb60f12e31ea807f4878f20892725d8147b962cd94491db06bfc02ec95b62103709a0d278d18aa974fca0a575427be7cc8820df82a554499cd7963195ce2b286b003de90347ef4d0e1101e65292fc4e3cf8862de6d2a522d087bbce92e029970f5f614d0d66ee31bb69fecd14754efbac8b4bba103ed5ef931e4988359c22724df455d3fdb6db7ab86a1b4a4ec5d2a5a927ade6287cb1ee7af61be5c4a5f09242d90d486d555680fc1854389000260162d4831aba830bb4eec3dd892e03902a7d5d1e33753dc9d2ef4875ea5aea5d2f9730995183e797bb227439e2973bbc0f6bda9abae7f2bd2500c94dc2b6e1efb8b0d1a484d8274aeb031b3f03f6530bb1689709a46cf1725fdae72a3547a9a26f641a0b1a7906b637139e3ded9dc479adef261c0ab621ede985f605d27f2049ea597575de28f4ad1f7311fbafe64a9fbe0654cc24f87065c2429bfffa572fce3e62392ec279c9d41f5c538be134fc4c4352ce0373d8b3474d80d8f73263d536e74ce8515e1121cf9af2e61e661e58c801bb6a526958c3d30dfc93b60dd33764b447c596ec1331d843415ecaf36592c34f6055c4072fca933176d24f65e9e1edeb4ea854437d8522fc6d2fd14584afae7aca6ace115d388c72f14f94b4cdc18a535866ba7a1e492f7f69f9076e468abcb5ef738acbea59747b7c4743f8aab058b136b3ad0095c0e921af8de54a74a252f962a40838e0fc65fd6789d09863c8ced928eab975351c543d4c04d2c674b09184f93c97d427953850abf0077f4875fd93facba282b20c6c17f2e8339c3e121eb4093094b1a2329aca4708730a432f1d34c4677b6afea3faabad1b4fb522c4f83af7a431d2d7f6ba26f7b9183af5b3ba7e0f7ff741ce67bba7c3e033c772a3c076033b33ae5a9bca12910e61ad5848b737e97ed9ecf18f75825ec4c750123c4575e27a8f762d4071e13af7a57cf3bbe6274225e42d963bf18d91c4f937a10cb8a6946ebd0f2a73adfd0ed9467908600de5b6506faaea8bdc30b4e89b88c35c278aa2bcd5c414fd75d78a5973efc9d340fc0b608d3ce256d66bfb3945a643654db799a1cc268d5d8ba943a1383f5048dcddc49cbcff7aa63e89a8c7b32e7a59d1d2eec5b81a889a891f1e155c9d883aaca271a1edd5314a49af81e3edde80d64b094debb5f4654181514f1b24404fa559420a56d61553bfe93a3a16a964c8e9f4b9757b9a2a1de9f4cf0f51d9ca87be2337683a6f91a8a6849d76e3ab4f4899c3364b89dbf1c18e55bb2f7b249aea4d9ce144bfc3c6bcbbbc508850ed88749e17b498486fd8480914e2337ce1aa042a2bff36f2c701ee30c31bb3f93b6a3200f60e53017529d9621d72af5e08c21255eee7ef0c6a7a3c4dfa4ca64506a567541f11a46aeab0b5504977e52e432a391b8024f4a506a42a4a9fc8e304e18e8a08bd3d0a7b525cb2e53265f0f39d4ff2d8600c50d3713768b898e9137dafed8202f686c0a28e56d61729c55a05526a2dba7fb8cba78a48aade9afd0c3229d749ace450d2bf1aa89de62bcf7c0350fb967c6353d40aed0a2c2241ca2b90866b7680238b6f8068479857e69e6b7013073208e7548ae03936f023d6e3468f9e62cf4a160a56ebeca373e4dfb14bd90467975ffadb390600665e47643f8adcb99f7a1ec89f2e41974afb19370b37d4d11227d1e96c28725b931692a49cc5e9eaecceba072cd2b55d889bb6c3c73b62cdf831b83eb9dbcf1049167e112f8fa34087b22f6a8aed2dbdc419ad4b858e1181db4b37e8f2c8a25fbfb3c106e59d1797ae007e43395c7afe346e3316fb43a4d17ce569266795f4f3493f0952b8dc046ed7a2f48ed41a323240dca56bcc06898d64ea3f5fa639856c8f19c1befbf621e6b3b888c59b8f5bb3b39811e66ae95ffbdfe3c6afedf534ab864b277e8533729ec3206fff300521bc8b9c05e98776b5ddab698dfabc28aac411717f5b1ac4fdf339111468652d055581008e2a08866897b6651c4d1fefde38cdd19f3c5a2b9c3bc1c47cf318d176208f29a5c779600f144c2760623dc7ce1eed9a630c07bb4785f62c44f7fdaa08ab5c62941f0cc8cb2c9e4beb10b23bf369b6baa06477bb661799be95c798c4d3e312b5349a7cabce6c1a4049ca887257defe04ad33337e5dfb97177b0f6d387400f3c8b414a005e5258e185e8a5efbdb2b64b5f446cdca5efe091bb7b3a197e5e6bb4b9deb1a0c25c186be84eb5e6ea8273eb469f72d6c09914391eae1dbfec4c7a06d0751b7ed11462bb91907de3b94a4313222410632bbd9554f77cd1fdc5ceb02815a319e19e254cf85cefcbf455966737b4f012c1008ecb75ba6600c427a92566b6e92fe2e432d404f42db6dd7ab90c78b26ce7a820d2b17b63d09106ca38bfffbb8bd8b0576c6f6c50aef4c4ee8f1c5144a57aee4e5a6f58efa9779dc390a44f469b8b9ca180bd8dd63ea53f0e4a856f7d52822cc06aeb0e9b89097b92499e5d930e8746efe455590862a97f3d674f496c6916a2b8e08c6d399d8df18a2b65c9e44aaf6414bf59d7b28267e03fdf696df09ec5f8eb98952fb9d8947a01a8bb3292491c1e8fda53bdd17daec1f06bea8e228a5ca8be1fe53ec8a5672a6aa9b381a8f6b5f207a03f13147ec3cd8a9fd3642303a6432ac80ee4b78dcf32796a2e08848430b615fcc8ff891397211b6bc04547463e58324d2d7c97178a464c4dd5882d8b25fd85af51c6984a04458c75422316fb3901bee9cf30ec676e550ef8b6cb3f1fe31eba49bdaa30eeb70f110f16b6d858092a3a2a3ae6d49a0e9487d59ed90107278e38f0e6b0676a9ad6c561604075dfacbfa1f711d7d1388cca2085dde610e29fb4a0e458b6420cfd5c2ec5867221ad82032b7da6f5d44d5a4ff18b4aae2eb19ca6772c6929b9454ab38623faa85766d39d0c11f1db2e65a6b07ecbe8329a66658b0d366607087b9f9de270a83b3797368c1010e3255d74c66af668ce5abcf405864d06d5185e914edd0acfad3a5ae170452809e7705010588d2023ba218898faedd1fdef7a17c41f3ca93cb0276febc78a2834021c4f0e01b8ef07eaee1c0bbd952fd7ea145799fc83dc54313af8986efd5160409a173989aea360529fdd53f53e26a15dc97baa1b7880b658ac78b120625297b3e5cc51fb524f633156218d216a48000592293aa4c813b48af4315261d7bc8ad2145436bf8a5cac0c096e3c0ad3d119fe87e165f09b7cca5b7864231bacbf178230c216afd2f4090b438e8dee8e4fd3e34d29113ee9e303da8b100f30c40be94cf64d120c2d8e7e238c83dc581615790deeb152b3d6c2510bd4718eac464d74fbdf049bd117f780cfccccb776306d164e022c00d6e5e34ed6d56d0a0fbe84964b9e52bb39d04403f11b1a277f031bf06d118361bd028fa59f932bada1645c97bb6b6345765baade2f744bb73ec239257542260195224e08f21a48cd04fa33ec978b056ff0b9602e964e9059d43c68bce868a7ee10dd58bd5d367663169f9556dd91b958d40cbbfe221d81f81b578c5ab439761d98d5138f19a309aca029c01edbec724aa5a98aa7f675086b017701e34768cb584b2bf0b5e964b7436416d35f27a578ce4817c7ae5b4315c58dfc230b4f033c71db601d52bdae595496c7c8a3b3bad4e91a72031f6fd70d3268a1e01d3f78a7711e39840bd96ae707f46bcb3b5d723b88d5f4f54df85091034c626c5c8b923739710dfd98e297d3d828f563c1938f332c4b562df62aad9115f5fbbfed9aaf9c52334889fbaecc4eb6f16a7a0c16d70a610399d639c9447c447d9fc269d07a17eb13ac73ec117ecbbc05304daca13ae1a0cc66a8a8c6c291be06ec3d086514f945a60ee905ad2a643fd625c0a99fe797338892b3bf55c08047274beb3a0e33d3b5a51c44b4580de13247e356879f1a94ff688387442cd245dd97b441f85e39ac0c182e606b331dd09603a4ee7accb4baeaf6b2115ca08b75156ac3cba1ac7a39e3a06fa9d248a185bdf3f1a4b83f0e8d9115fd3ba97d468a0a866397aaf608b79cfb4ed5552de475c7ddbbc84e7ea01b1352bcce3ad149863f5d38946e70c25b331e20de02ad787995b225a6b25928ccaa64d77b2f2a716075ba5cc4f13012ddbf94161b970e8630c4aaa9e37d55864aa72e651592c37f10f1b20ca60605d88c2fbf2916015291ce62840aeca51d0203adfc6dd8037495d9628af34f7083927958ba32165b3aa2b9113e7208289c16d4ff3d49debdd958a2e9ad33c0745b5aa88a4f780b6cb7f1531c6ae24c0e516deb21b57584e37659967f0b2745793e2508da09fe443574b4a773ae40c5e4877dea922a74f06a70ff2743011579b7b7d9ac9afc585ee25d8c009db64cb24ff8204dd9aaeff01952ac1f96aca9c8207b9d01b81fe0f59d45bef63ea486db06147aa1229a4a162d804b38f8fd4ecf2dea3cf2331b300589257f8c5b32ded0cabf07a07aa863343a7278adbaef254fd0d72dd0c48c89af8208b5c9b9c10814a3dc6ef3f222b95fccd278791d8ae3be6348439be7729127846536f9af290942a4c45d907914d13e92bc1c9d0f1a9d076dbe42d19dfdf4efff2f74a346724ff9c5a924df3e396ffd5a3e6b3442d7e6fd1ee10ea678cecec5e235cd362351b15cb1f9774f2fc5822fa350e43f92169a44931747766e5c5d432016076f365a8fc0fc3a8ff5c019f16c234f7c6f9ab5311764ebfea1b3e1fb23c95f0e744e8175a15288d581a57845a2107579f39fdca86747716efbcb9efa2201490e49fd59dec7fcb23843a2f7a2752f631fbd591277cafd920d48cb96ed89ee5f3e7afdeb3b4af1d14444749c7c52e90aef0a4080199b9cd7b70dc87a03c594d34003f5d1f0754e3c8450da3ff82ab6d81d8088367dcbef9ce648fcb7fc3fe641b0629361a3cb91e884dff66a2f5235aef580c02b35779a5e24a8940cc3174d392be46da74dcd36f29e89bbe51ff707c29d60d5932af5c5ee15f82d46dcb5af804706ff81de7c91f1dd1597ab5d21d4aec4308adce9ff980870cf208a259c0a0e919589c1fafc6c5f9c8cf611b7ef17f707a7aa2fdc2a3abb6f4bd56cc2bdb69d455c3c7584bde6a3a13a2aa59bb0d37ea2649e1396e3110a6c3785e266201500e6b236935a680ccf2b6dfa701026833882a467ffe9db5ccf058c7751a88f010694a2f3bd92f8904c0e3f685f83afa0b04cf48a46b1163eae66465ad9ca482e10f6deb3e55f90f6333cfeaf3904f8c359f7dc1e03bfb88e9e44b07cb63a55d8eaa5dc153bf5e4ab63ae37cd7b53ad87b7569a6f0d6c146b3e4869056c77f1530f1db8e9db3d858938330557741bc03e3b8e27e591e2f300a12cb69b723e55f5a56a338a0bade6fd6f2f4a1adc3f29bc24596e78a7501319c7b86afcac91acd122e986c6785f72df38c36b10f38d1f83d0169ce1876d8f5283154548f449d58df7240d7ac8cfb8b8ad150fff6d345c7e460ebb0f1bda68c40582bbea0b48bf21f42c7e9cf2b074755074edf8be76f223b1ce7be7d37d2fe18546bd1931a41558f78af86bb3d3644425c285c21883e35c800cb01da8b73059ac422925751f44e88510752c7d49e8ef9db6dc2ca1dc564d675cb03d91ad96337ea9e14f5ccd5ff725fad83452038b02e563123348bb417a0a1763c4ff73e485781dce4cbf33644e58e5ea5550251ecb533a834c3cb21a28ff02b27f2b1a61d7c0684b2848d7c57c5ccf51e460c1e6558cb0b0acd7c8d7072d64b7091911821c93a81076c7d0da9ea40e43972fc6d4181b696abae697e6f8398e6a5b59b4ccd76eb24ed481ec6fc8c4be4c6ce48acda6e1c8a9d13cb89f2d00980525a4e8f7a7de57d480e3dd1e6b5e38a8579446e3acfbdef6a85cc9167fd39c11683b8dca5ed31358578cddeea598a81c4c14afcaff737e74d2412b4a2117876a2b33859f0bc1a587e7cb5545800c2c7c3f92f581aada656818bd1a7edbe6bf75a357a95a381684776340f2f655b1a424e4e18e116b3bf5c44c72631a010f09404e01210fb794386872f761fe80bb02b1dca1f70fb285b395fe87b7c506e7c59006e2d3637f9fc00be2a8587c0eb93f3fbcc8304f840640882463032956f893420fbb05522a3ffaf4beed0135a0f41f6c8f1416d1d50ba88f6e3f018ff7ad10fbf34824999cfe7efdb376b2a9db7f21b2036560b3f8b5472ea5a99315fd9e7cad58f5afec1365565c5fb4fd70ad9cc2a4a2ed15c1d4295631b01e435fbc6ac86e3e449e6dde4d34464519bf653d1eff5c1dd8eda95c82b58a75c1fa91a55db6cb96a7a1f98b6e576a0514db2b3a210838e04bae1a2d6aa44c012818dbb26be7aec24eb3afbe2debf7ef6a6b864a5a41a50ee11a14921eaf75fc4d5784a49600add4a64e8ecf8e574733dd4bd1b1c3ffeec70a74945e93cf053f6a4d1049f550186f1ea4f6e80b453d22ef76be48688075cda0016db7871db30c78715c4502137b0b218eef193f44722d8ba9f37eac94830d8005524f591824a7831f20ef5ac6aa73730914443b2eb0a7cc5b8f2ae8d3587abe7c0b02743c4e6403db27ee13074c810784389b37761d64b474da086289a70e1b49d670cfb10e704ae5542a4dab2a91369b6940009fdaeff4e9ea833ac611a89718a4f0212cf5410eb008ea430bacbd970307982a6dcb2bfb4b5a3d02a44ba040f482cdea00df35f614f4f4b988582a91aacbc471983147829d0d79d715bb3448ac36e9dda210c0a369d1d54fecef1b5c2c8acb4f65e0d62e95024fcae5e9184ac8412344e76daecf07187ff11bcf7d25cf4efca979a7e8b57cbe0fa87fab81532594ba37aa57f7ec8a2edd0671e5008dfbe63bc20fde941c04c4db40de8bfa1c0c4b5b2184822b315a59c64409ba5543fc608912b6ff11181c5e9880ec23d2146d29a85cdf3ca22128f345220ebd3c0b3d97aa10fe60b356941b834c94c1bb0668f878cd1ddcd1101b7d38e8280fc9f7f1d561deffdcbc6affe6f8bd97ca7ad37f87a6d058b7c09dab1c083a36fe67c02c4533f2a3e1e8d4c3739e007708cf4853a0ca60d1eb590794ea871f6a83af670a1dd510ad51cdbda7d86db5420590052b3a4e3010ae4467aaf24e789b5e76ebf12fb90c27cc186b691f507cd0081847acd8f1a4a63095360497e597d1b8d947900bb8ee1f31fff144c478929507c8a74a3fb14b72670384ca86b8194e662ef1ebf56db41adce401c2f8d3d49e4d0caa4cbc9e53077b88477082ff2bdd9cdaaefd246495f4fc9e19bb0104eda03e1efb0541c7bf9bc4bc87a20037b438423720a31e7e4d0b1857af6f3de7c29192ac52ff9381fdd8b5d9e62a502640c1575f4bef67e63618ff74faa75e9623e1382b6e976a1277bd5f3ab933485aa19024bc9a11d79d614de0766797bcda9018fd4320afb660e47a51ec064ef8c3f564637d0f1aade3425455d67aaf7b9e45125a09e9bd72b499d4349d279be160ddaea07883ed615625bf7e5b248d0b7144883f74acb83c3dda252ce876128e6400fa331b39ed98617808258048957d3c42b78cf6701cebf20b5d3f21c220b4d01716ce34756255c96507d0c2b64a7309020d74b4950a03375645aeb77ecdbdbd1ce9f7976c71613750376e05d2a270e82e6f884b3fa829ad0fa492ed7d445d04ca4b703edae29824d0c6d30fca69f10259b7baedd00acb2f2252ca307f3def13a32de43a8871923c6902ce9c7e4d37f057148cebb742e2bcd1946e1e43ddb3134721ffc080286477f8a143e632727163a7d2e0c21b3d0057da33197d38baa62885a8f3a9c0c7daa1e34fdb2430bfaef6284e67cb3eff229d2fa781945800d8d93bc0f9687fb7dfa6e7ac327cb87949765bd140daff8b73ea9ab6c99a3669246b813fd779ddc3230196c2a29fd14e04ce2da5eacf532b183e944d13c5dcb512659aba952ba24c63aa1e8e241c4a873a2e9247fd643485bcedf38ce420a2894e9057231dad568d85a4298e3a96e70fb445430d5e4812a647c8fa8cb32479945caf824bafca3b8a2524b0805914a7db56efb71615e09915614ffab473b797a012b05bc7577c5ec55a3b8454d3ee2c674f5f2fc815e07c5744547aebbb0445bbdace36311badf9d3dc7b4cabdbb627ef4534d1f6109af2abd78dcc7d3cea76ce227946b965bdad2564a343b219f378af560e0d393fca72eba05b2cd0da8ab02d14e104a4a0855b516439295c4fbd319678a4b483fa241316e2e97b6d0431833dd07486071d3449e3215954f00fd185ce963dca929776f2c87d5c00f01117c9a3109276c6d0208bb0bfe26df51d5b01dd3eb8a211227d09333fe65c42583632399917cf8071c745a380ef25af4a4b24ce42956294d1fe1f73cdf75705aeaa78b9170a77c83975056ac3f586bd1cf13906656fbee297307d54a3c3b81a8e146b193f30b9e1abbe62b212d560c33e25445c8a7ed214c8200c6b8a4b41c32ad3409d5e3a0de6e8e84334226631117d37ad16d9ff72be1a614c5dec91b648daf6618f7bba4c6ebf76e2eee1b4df39f49247b040f1254429d9525c390b4975dcf7914e0120185bdae0a79d9d2ebc47d0ed0fbba80e7dfe60894c02949b986a91cddbdda8dfb4aa44a8cc9209b7fc7ccf26ce6097fdd55684e613388beb090db22e780d0e611278e454bd531f350bd233ced405db0601d326b96db6e5778ff5deca56e34709c9d7432c1190343ccd18e798aa22eb05a75b857e53ea13c82cd9f8369223c6ff9a08d2556d4491269b9bf8fcb37bc37dd8c66d02635d0e3384eba58301af1f487794f989cb7ac0c888c3cc59c53270ab4168b31314d40302a17186dd95036122892a0ebd8a8a38d20ee2afdb6a493979ba8b2316caf12afa6a98089d0d34ef358b4bcc122cb511202e73fbb97bf97f175cfcdbf9da63aca54b0064806faff1ed8dd5d6ed43cec7d6048efc4bd9d363408c702309e503fa5c5db29e52bf5379942abfbf25b42a8cbc1cdf66e84cb9780e2e0cd06fcc9803d757fc86bce7626fbdba865650867da3b8f90198619bcda9a40ec3119e22a8254b0019bdb903a224ca34fbd10b721657d2b35bbec04b3cee0013fb731b80d3df7636dbf6eff23504c799d8a113e087a49f5da7743d5ba7488f2cb93ca343641bc80af61a6f9b0e3c5215d47f44a264f41ad5a8b473d9526787e198084412c6f7adb8b2efaa036de95ee8bd7133848a9fb1771d88a8038c0bc486631e3e81826c250ccf4e55c2e9c96f82ab24af6e66869736d80c69f84c005141a8f3d22a472848d98e269090ea6362b2950fcf988f059af80ed5d762007eca77272578a319c2220236d7284d4503973c77e57abb81cc8e77bde664bfc33948bc233e26db773cf426d220c7d02817141c8f34cf000d62d07bf7da172f773aaee7fed7858f6dd29553b9f1c26aa99ced42bc49ed8e0608b4acac18c3e49fb4ee08263ec1b8107a02677f97081f22b5595576848fa98fe0de526a73a2cf4f10f10776f7843604435f111c1e2aca244592a8ad9ad9a677428b618a6cb1c3fb57f001bd51d4d00535242b707c08de91853810250e9d4dc85fac69c568eb26e0640e895c7f3aa146ad83b06ed9372a770383dbe403abf9573547625b09110ca2f0a7012fe49c8f54c7c91ccd0d8db52a99a572e31bfdd16d9f9792bf23e3590335b6cf08a76ac7bcba4c41c334a206e614746c8cafc7b9f29957052c95254b34b5cba5711260bcc9124b7c5441872f31775af5a5bccc26dc928a485169bafe69038db3d23a918c75287b0bf4c921fbc6b42742183561c0ee0270eea1e7e090b4f87e17c2cc391fc42b6d18b3912502f0ddfa8e1c7348f23050056c98ba3e6bc0414c929b0b70087916abc63d5eb235a8ca0e9e7af96f738876dcbdd3a34f326ee13a66758e67fdc1aa4750209cff31bf54a081aef69a5cb449e9064455a1fee1e6d2da609a0eb85661d121926e7dde4877f2f1badc28306d760f733b1544a2a3acbabba9bd3b0773b6538b1147d9d75fd23ad6c1e1f31ea70a11818866b3966be28f025c5654cdfbc489120b9417e5732fced3138f0d55fa48e577824fcc893c101e9f51eaf2ee11c1bb4c0b87f8919b2bb70ed796db47cb9d74a8b9c711dcdbebb4f8335b9cdc337391dd8a4bfee2d795389244608f90eaf99f802cae5d6b23be7368a0f80350c3d05db45f7b6b5ca0acf0f51d4af1faa364021c4f1bafa92878e54f6ec95acef2807ce659e9c8dcb12c34ff73cefbe5a16380563ad4ccc4a92da32fb72d5dd356584a631c2210950f622ab47158802a34347690c25401f9f447e8fd7e57935660b455e15181338a0f2fa44b979ac3588d35b571a4be1f2bcf1ba4a0a1a0cd6917ce625e7faced61f7e54d4eec37200b529408a3013fef55ec371c03fbcdcb71cd398e5a7f2c2c87187e8847b88afab0c193291e4213e88da9e0d094ef7410616d4c3e0602ff99402bd6d1b212622bc6b104a6095cff83944bc7abdda6ae34a05c8e6bc7942b1b5ad8c8c27799d4b7b303405c2963daf70d69085bacd193a7f6551f9a86c829aa6b8b45bfd71a34b2d1f845acc82c793d17ca2ad661bc81ed4cf491aa75219302cea8d6ef2979c62dd33f77ff7f8ea9001feef97dadc0bb677e495c49be7cb4994e8ccce16c500a5f18bd3871ddde1ea6212bdd126ccf28fb4646dd9a9f372b3d3485eb91eaf66e034f913520d318d95edb317f526e9085b19ede015d143073f7f4aa4a7a6f00165263145020d3ac51c187422abb50d065e2960c23a3130baf3a853a380a41ce6a3b2ea27e3b527859b72113f38ac46d79e79e6c0698dfc19afb0b44026453e3c0b0f80121bfff3db49fd4bf342825d1a5b692e3151a99377204a6d6cee1814fa08683e2760cc05e7d7bed682135920235f212a625ef58ed46a8034847c3565b1d2c0e5526ca03a22cc9fff7e5a3d563f8440dd933f7376adbc6ddfc8e95219a4ca2abfe972f9ce70211944efd39857edf96a17beb643862ab8ea3d3442f77d082279a9a8540ed81d773ecd6305795b9c9a391cc20dd64e177b2dcfeb498e861b9556128a61f6a27542c046c9b7bf39c5b2d5d7cc5f37bba6694198932dfff5927d7b90bb3a0903a7b173818a78e7f6968ad32aa6416446a7783208445f0bfe107ea61d476b0ed15404340ad267b7e2e3d4cc6804697d9ad5225952e92f0037a99708c6087a314c85d53dbdd4df96817f55bd9c2ba7d80734c1bb76b3a1d12079fa37e50efdfff882ae9f1c1a48c24ac28d55f7ae8836c502916f26dce2dfe0a93544205537e6767fa45d77467ce9e49af4540df79f8f1b44e8a49591bdf4e56d3c87d6ab3ff1f37d27b0b73f88583f5f6139c6994941e0b7fb773818f74edfc25228d962acab5499fd9c3c0b2b1ce49f98020259f46bd3209c855bec6dea3f9667c760d895ebafc280957dc12bbaf2c1e9a432399c3d539194a70052020fad38abf9425d9d6d8d1f365c9caca6cdaf45d45942f7beef701f26caf6cfafbb2205d85249215befb1b62cbd28186fa03c8dc2faff3875e2e3428c3bf47b52b25957bfda4c059dfdfb251134eb0e160ed08555d6e28df6bcbfff538c83ec89a60bc875a059a55228851a1345048f3537a4712d90ad5bcca50ead4920ae845c3f6082c516cb1eae53ecf950cbab6cb3e2fa53d7b4bca3e46ab3b21ba3a1cbfb655c4f70dea5d30693b07139201526cfdb83303409eb93f3c5851197ba12ed872b1234d592298b8ebca094d33e724b6f15eb0b0147f58f41bf8b97a1bc6493478efa77cc01d71e6b1067723d962e61dda98665aea4c117a8f0c179c89c988d6c2a1a507ae9129af14f3de338b480997fdacccdbf0a80c66765f13ae4a30f5e8174afae10d2e48349577ec202c65608227f0c02fd1c18d9a585fa4c6ddf3719836e8cd70227eeb241a25b2260918dba31ff2a1e44a5b017a41c1d85af9f704fd0ed79afc3968182c93620cd78a51279396e26fec3896707b83051972ccaacff601b1758f18120776f72e88493ffaee6816b5788afb71ebe37e77e761a84bd40242037c5a3124d95d40577c6ead8cc7077d1f541aed568385c6e5bb482174b4c37d1ff4bcea107fe3f67ddf56191f9f3433bf74f6be816081e3929e2427eec1ee1a7c010c95bad81784e782832d2d85c4f91df8307d4529141872987307c052b251b52a0752f65e4af50be84313405b5529e878c57221566e29e77a834d1b06008553a6cacbc32a82f52cd88a0be90713da06eb566c40062548f4123ebb7b22999ef9d571db2f7bb37ec0b4dab9ac8e65b6ed14973b21cff2345d0b3ff778a9aeca8cf1e42bfb8a5cea9bb37f387a81a9ea2cab07dc971d63b18797b58f445eb2c12084f16b798c9d1d1fa26047952b3875079752e4d8a68934632978a05b832b5f879ee98d8703d3cb27beea5e9e2511ed040f27e20d4076bc25fb736da6724110564738c1f018dba8090b090bdad88e381b62bbc87d693ead3f4b70f1432504eeb4db424bc057aecf048486e4a5aa55379514c71ea4bd2e771a7374096c63fd51480511f25d7f2dd809d01a5ffe1b0d6af71d02eab3e1f6471f26a267001b5fe4ca58a6851fd8e8799f35cad4435b8d0e2037310d3f8379e6e84dadfd48c91456df621ebf7a0437f43e55bb11d29b2ebabce87006b7f4ee713c700bd6e51c87b345e60fd899143833c3a537ddcf09d5512ef12596e028f369d9719aa000a0d5b4f6d35244c785d9e43c0af3ceb333d30e91ecce298f3f65b3c4478f750c423d1c00f1b034a3065517ef25dff131ede700d5fc82888e102e1ab981f0f0efcb48e0c5db92eef9b2d957cbb0a960a900ebee1d78fe2ad7bcc796a3bb97dbca0ce0f49340a340052b79b56757e37cffbda117b639ea5871124e6d095f88eef0c7e688cef486312820eced8b90f36ea965c7c197dd1e4105aa186","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
