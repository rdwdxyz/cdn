<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"164ad5dcae754b0918e1ae4d020a50f10e7532139b2895876f9c7a107447eebbd00b3b12d81d2d70e28c99b128efeee0327ce4714789d498fbf96f3e745923c83aa3fad5a007d181f4319cb36f757cf3c3fd9167c3184a0dff448e55dd44c3b6545ed14b92d538935c366adcc8b452566850d179fd63fcabe7b1102f159c07aa3c9bd2f67da9249e03483d201528652a6f7ace8ef588317cd3d21463b3025cb919055a3fbd0bdbb0350d6630851eda39229c46d931fd2b848c1d654f95edccc7ee8037d3f4395afbf0061551014defaf3944224d7cc7db1c6e0685775d22dee399fee3ab216436880a5f328d116800bf80f23742764ba0f80cdfcf29f3b0290e7c62d85adc55aec473e11519324a317685334116c59a4fd00e51fe534500771e0c9af544a19c42af695cbc090c8c54be6c75b3269847a29f911d485242e912a959230c3cb1f610b727f2dc373ed7c52ffb576210e3f1cce897859529d2da3af35d36487750787f37cbc70bab9f4149cbb0ce00c78b5b91ea859bf3acc1719daa9af61acd3d7d6e0ccf49c887ab3f5b59e373b07c578a619d33f3029ae81650643e72a9539c20a6e49d5dfa935c756ebc06154b8795fc7a12c583ee06124e1f67a8ae65eae1f63e5a74d2b147417e0684406d882649deab114fb059ea2e09a84a58734e7564ff13be2e04328fa6f22de47c38514804c4c0e63f65d2ba8c4e34af72794df324da1a2c0d658c16884ec0d21c4584f3cbad4b05d2bdea08c7f7763f0127f6db98a8642951b0a7a897204457b22e12eb763b7c2adc0759236bcd3dedb179f8d6ff2e8728f59b496e4875158b581ce18edf7e3e06cc9e9dd695aece97ab0aa23cd63562797fdcf7272f730ed2bb59c3556c99da3e7b12c7ed46e1aaea549ba09fa0a25db63b8973faf72b2f0d0fa35976b8b5766deaaf7dbcbdf290d031a81684fd1f78dacbe287f4ba81f0b6936f3528956c821af1c0569bf333769690fc04101acc04be2bdf2f6da1a48b6f86a790d9f96891e4a60a378f42d6a655a64bae06211773ba310b022a04b825921073d0154aba9154bf11efda1b3ae542e3f125bb8b8e1049f9135725a451495872fc55743071bc441859658bd92084dc5d25beb51bdc167abaedf26fc2558bf9bd6a090e9c1d8f59a1744196461f8b41eccac72f4c19399b2e772e5ea7376a9092c5180dc499814cba2e4d6a64a30018eefb9db740ffaab8d5de5286aee611443874cff81ba570672e32ec400966f86e00955058ddc343c44b1d1480ce5eb3df6ad132ee5b261e680bc06f0d3f797c1fdc2349c17ee94254513602214a13e6e389294726213365aa863d5b7c82c91d75ad6b72ac16ba73721398cd4383933bb4ae5004c3a6ed8b238904bd4ac958a2e9a1871c9e5de9bb0cbc7da877aa8d83f9b1d95496e987b2c6e81b0fc2acb48e6f8e7acee83639a0668cb703a8a023d20698d85154dd3465e626f29311ed6b2cf4e9ff82329fbaae2bf5659b6861e547dbe55696830be92d8faabe3df2ca47fbb6b55af0d62119e03046f9a6c45a1aaeecc34cb3b0fe4ae3a6567cca4936ccd2c65757f00f681dfeb21692f9568274ce0ae848c124f868625ec43d3fa213fab572029f61d9bdb2e37fb4063cd8723b2d6eee26d40dc76143b933d234137210b9bec86db8e12ad7b027a2969ebfd3ada78f0af2d106c874ac8f73232163107c9d41ac708f41e4b92647113d1c54487fec3e1ba7ec1d27124645bd88634385002c331c966e4789a74e7f4c32b251f729f9d1e99f533396e8af31574631a6b8854a51eba9da716a930b47d58cc09a63adec01d577a9af6630cca8ff78e6dcca75992e6a2a4804cd9e4b3e10dbd7958bcc1ad5f1405efe3106c904e5bcfb3fa89f10a4a98354268a9386629a46e818fefcbd1d9babab1d4013f6b766877e150f12c0bcf2360e68a8ea33224ac2fa4ed03e976bf07f80d10ff684d4432b47d1e8c87b4943a9a379d2a9d6a0723147df378a70b779461cdfd6c84b591898c3f82acb54176f4b79b87a5d9a69c44699aaf7750de196a4765bf4ef7fb23fbb83304fa7c8d68bf3ca1eec77b0c725bf46091a4d5e3cbc9c0891d10c18b5fbbcf2affc27e0de201fd863d2cdc7645ebd9a122707222ef26935973216fd0a4bcb68112102915b2b6b3be16dc198757b6c01e80bd66d1e81bd6a0f19860f4867c58f4d71c7ae6f971524c13e79c3d66ea235673331f96d3c943aff1473175173e78d61cafd8887e554a5a8f4a92a18c504ffc064f37ea2e56995f1a0101b66b586ec28c83d438706c1634e75304287381323dd66bfdf846f47039debbbe6684f05184f52bface3043aa4f0f47672b8c4949dfa1b8fb07d2fc51b4850ed81abaa008ef653fd15c6684d299768f7a311bb72b25c70faa93aefa7ebdce9171e340ac3b8fc7ea2b095e1d8d82d2832fd1e0309eb1ff0e622aeb699d21a4338b891d2a740e48967659e19ecc6aaeee6f94263c5dd584b7a5fad792f683ed3996126d00cef68124dd910cb07c25c1a0ef9e4d52417274c1b91999b0a9b7a3fbace4285b929a9d812974023fd12d9e95e6cbf69b1122eb58ba92f70f92c16df702930e1a365baa274e79bfee0127fa0382d03114908d492e9eb181def0866661f97f6b971d48ed9a61a2f1f1cc5d9b7746daa032b8956e01c97323e092ce04209e2159676f5cdb630f09ab6910c4b0cd7ee718c865bd50cd066f55d7dd5e33a229c29cad70cbe34db2850c5d7a39577ac1dea670c972f3aacf182137ce54df259ce55d0295fbcbadb9c09fba6685013bc52720b956e1af4cf81e37f919be247527c2941279dd09e0216b0b9782b24ced6af110847eace7a679d7254fc6062c16a6a1d23665a5b5b91be864b9e4fb4b7c2901e296100e3354b91b1b14f00868111b4a5e79d74adf03babfbeb56a5e8e396484de5ab8bc0c8701fd784a2d1fbe9cf1c71f3b1c47a9b1957094184ec61fe7bf9e196509fa831dcf5f499d8bb730a42c2ee2a8e5f668d82075a9ec55c21657a795760bc38cd6ca486b4008e4f55cdfd3a5393b9093a9e54f9e6a62aaaae9f9a6974ad501dcc72d9b3d12674094b529435d574d79db211c0c1d6087faaf8509c0268a1fa6d6a6df8fdf43b9b77908f1920cfb8b7d72f82fb5691507c92397640aa2f5d241b84d67868380aa70893793734f3f1477ae815b8fd0827e3df5248c0ffdc1f7cb7de5e1b190e5c3ef990a7edda069aefabea764fc83faef9419923b09bcb2d44550c240634ca183fab832cf69c425a9f84aed7afa824d0f3cb229aa92b86d7d03f638b6197230a51d67dfa2a442d66dbc7e36a63d8500a995ffaf238af51b94e85a4ef01e1d48c7481a1af78777856b7ea81ddbb497938bf09798f73680069f928ab8e7deb991345d811cac69fe65ae003a063b67f49826820e9bda861aa7772917cedac452e72049c0e25a3e3849ea93a55412ab057d596d7e0e04eb3716c808ef7aeab3d085ebd3d212c3e60537222e49e0b489cf325924aa3daa88da0c2f16ab2c125bb9a28a8c1366dd74d3ec3e180f75d18221de63965321451ab4ba1001f1d9b8480a9896bae5dacd7f061a553cfeb1514ec3e062e922fa2a71506d8c3156b2007f3316997a46e5d16d2ccd6910a902a17562325b4b6486986836ba55b0c3a13c4f0c274da5402a05c89fe28791fc9db76864e37478fe6f7991de7d8c4cebaac2f58dc67b9c899fbd44c544f43781359c4295be014467667b4f404f1e2e1aff6498d2a1ce56a08d4541770078be25b0e313c177c8a131c70254082239a2b544c26ad4467eb531de7f92e674e8ad2bfd37ec273ae3a480e0607c2fd11b7c078ef8bea71299c2b12e5eaf5d102d9ba7d928f5029ff09c4df2c82310bb43914c5bb9b82fec48c93acf72c4edd5f4747836e1710311ed4263745db5cf2c6a1fd18f4e7b4fad45492d774e304e42f72b5c2eab822b0221ad71c6b400f721157330c09bc14cca1cd642127b8c706a118af1c3922a1fd152386a0bc675a1ac277a57898be325ce78134e519a0ee8121e35d1e2524f479f59e9e316550516f7851190b22ac073d113bfd4ecb9ba8b3a97d4f2a0a771a21798be81ffd8d28931a920b04e5e61c9782ffb0064f8650b6c5b650f2c01ddc61e6675be285e692a29757729a1ed900a07384f8551a842ffd477f90848eecaeba3d72125db9154a574ea6f4129bee67b85886cfd22fc2d761d7186e4835fa4f0be67d3dc5338003eccb1d23f5e8406687dc7f03f13f32be3a26169dd0f699f140e005770ea5f5569ccccebd3d3962dd6346faec1b68895a8a2dc55e8ca107536af0ba28935285217bdd4189f3f6ca7b8d78f83570a24b4d0a6fb999c6b71c03ae61744f01c1a2eaf97bd5f9a67c4cb99df5a1bb803c11cb91a821799c4de7abfa7a24142b1b8c9910077eeee980945af260d8841a0b26a858f442000461a20d07c6b2ab0e56ab9cb8b3aafb07adb913e848829e6b3f8d00c670e45ad8e8f7c67641924160e3c065c791eb346036b696feda6238d6dcc9dff7db1d791182f7dac576c458fc92737b4f231008da702304dc0837531291484f012c107ae1bd00a8f1a5886245bf7be690b2abe254cc9acb8b42bc42dd3b79c23a9430c31b0e70d98f11a7ae6c3cc93deb76019f004a3f693512e3326f97332781be7c86607605f81dbe824499cc894ede5e2e2b4bc210f36f2abae4d19a41c11601a05c35ebb902c59bea86fdd0bf29f9fa71d78c803c476db3f2b018c3f672a2476eb63291ef937c57eac358678969997c278b99447e7e07fbdc2f6af21d5ea51f0cbade600d24cbb53888ac2d1b8565a283d32709653aa10c9e83ed540e4c335e80de99851ecd590f9b9b544c4f3b4cf73daf21a90524d84d38b25648150f37be04de9187f6cddfb622b78c14750161bfa740003a0be0b7d782a79ec045dac90e029958d2c88e2b071b8a0d97263d50de06e0ba24b9651bfbccb64ce78c45a6ec01a101df8602f22f4ebf4a1d5366a7e0a88ae6edb17e9a68a49475ef0fb4ad3593ec0a287d6ed492b0e22172d72e2e7969c8465f73a9590c451ca39f7cac2f568810d7ca0e6d5fc79fb3518ac7fb3347e214482b409f5f384f3cf3a5d7c9fc36852ce4e572c1ff475f2d9df7ccbbb0ea5f80bf19bf6ea8a009de1d3394c32d164fda6bd217797cee5027aa10fc9380e6fc695af5db920aec548b5f76b57078c4ee9012016b98a6d2ee46bb95c567573a13369dfb2acb175041e18053573919ec138c70ebd11e55a13738d58dc8f85c65d25cf5df992da466ba15fdaaef03b516d1e7bef7da86f3377609c7dc3cd1fe04b15c182f399afb01ed073a17dce004345c736a705ce7460a4f68f06b2a0564fa1ab032babdb069134427755b305a960866c23c9ccf0c257a58ac170ae5eec9542f4ac5f9e0bd251d961d009608a6743817b795c0214772a6f0672aa3a01b58b9c29c537175853f15f0ce38979f7df009557c92a8933e227df8ca2d0256a2f9ddde8cf52a186211a2b60e50eb105121c08fea877c79f9dc51fac3b7914a3876f29c6647f0e9d8a7b60a652965796a059220148ab49fe46e724038fedd4e923693df2ad222fc34835f4a04062d79e544d6f133f94aa70847a8963a5fee8fd2af99c21c0f0a461f8478436171dde56d0c771ef644818c9ac5b6ab257f67a0881947e5d3e62083ea8030f795755df8e7d7b6eb1dba7f9a2cd4671701ae17d63dd6381543861ed7897b543eabdea1d94876fe8300e9af0cf90e7ce376bc6ab3ceacda7bc648b7276e5847f933a3cee97b10c2d1dfcf45f4fcc3481921850f02546fa9e89b94565abb95b514b0b932f91d63fc6cfa9634ebc5664544c44a24dcddc84a16cfeaf470449df0d95450e118c69bc7e99bae1deef80882e7e856cfdc296bf98fedfe959293383871aaeb9e8d45fa505d53ec131204dbc556ef981c935e80fd1cb75394e59b1e819b9d1aceead704cca1127822e2b47918180bca5dfb09235864f149ae8963d873db0552fa46f5e8c12cabc14a6e9b425a679411f2dace631d6ad9f97578b05c4d54493932344cef22c624f8d66bbf856c093c343f9ac600f730d32df3ded5cc05990c404470adb260a90bc7ce41241c2b67095dc73594784b03762a8c43fab70c01d477cf18b9bae9f37b02f05a55ba838df9c16f9df9f71ce864006e394bcc7350822096a85c74190c218fb9dc10fad2e1fa7d33f1b0108cd79d79ce2f73f34798fec2023ef139183ce7e2798268a89d7e6dbc4dc4a9071aecb93b85a5a735a44bb754324dec0153c9d72cb14b86735681bc38da21c17804bb78c900775d22b40eaa99e177b222127c621fbb97ec36db191e09fe0c22d031a0777a1ed36fffbecb949efc7334a719fc6944399c7ca3badb6df9199b3b6a2129e731d422fefbb5fdc09b696c55c58627789c6bb31409c50620fd9c009e2f0ec1ee8a00defd2a45128776485756eaae6b071070e516f982bd7212470e511cab953942505a94a3fc90635257ef27486fa99cbcc7dc600463dcbbd0c95a99d81c0041524d3f7629b3bc4db3a34f6f016da7917a9241335ced27793aa44775a86c5b9276b9cf730a3db73132ba40006bf7316081a1b50bac3e743da0703dbf96082ae697b0b27b892db74be18af192a9ba40cad74fd6f4db48d38aeea926615cd99915d7ec1a8cc57a42560ab1e2ab7131aeb914ee0c4a6d36dacf7b9542f263b6c426a9b8616728fc74cafc5826845757900e9c3480c08245bf69f51d230ee9d5d213cc3f8eb9f0513e65879ac02208e8f9f69e3ab3033090347543759281040f625fe29c33d408c58a8140659eabab40671045c74de1af0a4f4c5db98396a30c3f6287170000bb031fe8ed7aa3ec9b4532b1660178a44085cdd3f43d730be93983cef47f89c2d8784fd49929d1c7d5335176d4531de86231dc0d66b23749cca6323922a9bee59ab49a0207b33e669cc0d9192801f4760a6e194b919547c42f5a6f6fc1d5258e151e2181a900fc53780dcd1ed19b35085f626333608d5d4240e11f25e6208736f5a13c1de58a69df6b7b1f072a5ba0b66152ead440f41383413b3fd2a6c6d9c42a5fb67388338126bf4efedc5401cf73db780a986e23e816b524f622aa1ad38eca2a72b28d5246df2914f7a60b2c0378b9b33d31abc4fff8e4a107d8a5d1d8683026fb4371a9f4a4215d0b522fdf8db186925e6345668489256d36adf95dd1aca9239454d1569e311fe660449ed9992e97ff543a4d5efe12996ae142e30faacf733b5ab4f55b00923bc0cfbbefe3043e9fd57a707408a95d79d795de56c7deb8d1a9c50072b1387064cddf3181fb0c73f24c3dd41f34aa1718e0944082a5bb7215efdad397a4331b955cda96f5fffdc4420c57fdbf0e0d213a8fca5dcca92a2cde5cd88a89aebe0af19d3b90ecd83c1701fe537864678f1eec9567a57751aded25631bc4891ff094a125812c61b9cba5c86d4b2dea8dd424f213c4cb7d6decc50787dbe4cf943e7b63571b5865c197be6e1c482fd33558bb50f1a0e70faa2d540122e1dfa5fc29d77f2892159d17c87360c860b6308f6be05359c29c33e8a5d1218b7f2a279ba0f5d7c4f857dec3d9f790f58d1f598e918a52bf9e45ff4302968c8960c97c8ba1e5c2fa7fe9356c8e2fbc2ae678c3b65643aa02ec8d4ce8848336ea7ab9e35a34917a59866e8ac4526e017ba7b786fe6b56ebf45028833d8a89779b08a077410d91788b88c26d3620c7a20bb1d9e314ff56fab6859fcbab6986881a42895cb2c7333733a4226be97183c9c15fa8ea5f10fbb7561e2df22b4afc855fe31b19af6a45cff2030a369b9d78e671cc0b6c048ae8ecd1f12082d46a38f64342d5349f4187a79d3e9bc025e113e13e1dbe1373fb2ad0aae93372ec70a6d9bc0ca9c2fe8e8e87250835800ded0374f1648cfed842e39b023a5ae397de6de374a59f67b962cc5cdf049bedd0ec753791808147dc4e4d346cf7768c1b82b9e9540a01ad3347d9e41400fdefafc99a23b0cc54f85c90a1bbd3fa913cdf15be0a25b8ede29881813ea83edd1a27b563503691c063e87db7ca65547679cf45da56c5832ca4b83b2ee27fb1bd6b250db0408ec0d1155673edfda195a5046e237df459cdfbe2272bfddd89cdc847f20570aef3a7ff54c4cfbc4b28fa5abb08616db9e345de4714f17156955ed1169a03e177b807032abf5b2c6f7dd396e7ef15414bb6318fe4f2bd90ad5d4ca9d2b85073befd96b0eadc050845520fe34783615f924a113b7c6fe206f6ef06b59bf7e75f20ec53fe77688ffe425d141e74f6218c92ef442feeb4b0c0221a524f0caa73e20408edad6ab337fe58d3e9955cfd1835338b74d8405c9f8d6eced7491fb0d206c53b5f6077c63132bf56c1dab855dc7dad764a7ddf48b8a1631fc0394df3c20c729c949ebba5f2b3505cb04125846851233f3ad3a90047ee0fb293e28c9a26a6937cabf253bef8297f1191125bdf0e19c363b541652fd5d352f428e09308b8115a7cff557a4cbbc46b09922f10a21e1888f72896592fd84cf85876087a31c3ebd4962cbb6159dbe35660c206eff93dac06467fe3925e77510113d770f77fbedab5ddc90ec3913608020f2826ef3c5beff33e4c09158636f08612f8c3a5f674fc85db60b1525563e70a198833befd5cae74b73d43552cbf597c750a0cb27409903cfb178dc8d97089db5be0a812741aabe4927d69e2699b2a9b035591b3868dbbf765c1fecd280e542005e981df78ddcaf460f76b9f56f11321e98ff47bde05baa606a21e792f9017a66f28ffdfa0fc906525291bfc6f3c8427272beace78c23df6c539995969bccf65e5d3f31990bba7496c91d389fead64f9f128e4e11c07a38732a2d02933153afe04bc7a06611f3ee87d949b3bff3e6e14cca91daa2b5d2621b262ca2d52f88c8b9e1a569f803c550deecffb50b7fb67076289f6dbd93bb565d62639897799733116ebed9c929341ee76435d04949ab0f08fafaca85b83f8d21cac9342d832b1c55fc296f317cba2d81fd2e2cbbb751837be35ceaedc4a4bd519bf8f373e54cf1e3b3c72db86ed007087e7c93ddbfe6875789172dc2f6cedb8ee99a0cbfe042c1ec3480a5fd2367f45814a12708d59137ca609e98bc7efb2f4ee2ff4ac6b050b84e67e636425e8510ddd45982142cf036df2c124bb82e5d786690c050378a10f1fecee0ab10baf03959ddc82c255a1b66554308b7af813919e9a5c8bd30c343ba58d206ad2f6940f02ac67ee7097982f4f7d14551fa5dab8b88f1a8a6a26ce910519a55665e1aad737afc0d92ca2226f0f0007fe2a5f961a26ebc3cb49f8576854cf2696a208e7eca9f6c4057e0f7c17aeef90497d1eed845f69bd88a507c34ab978df7e8c14db902eec445ed7f4758392e40d03c6fae7cbc774c635823f4cc26f8c97980de8a61a65130827e95cde23e1e68a45287164d3b1662ddeeebfd8a292b91779ee72f50edb18a660fdd2db68f844763be46ecba7369370cf49090f1f3c8d52c4b9eba32c4f8faec848a31e7487807e71f6c8797b7f4b2edfef0e889eca777e5eb06d19566c286b448eda998ce166e6435938391e12b1dce3116e5f125d942fda33caa1c2dea812870fac7e6ec8dc5bdc043fef5d092749fda6d6cb65a4fe186c9b4acd03fcbee179b79d47ecb9291a197751bb84a86e21b200ab8655d350f5111507a17f260c0315fc763ff6fdec48b21bf37aceddcc9a939472d6564167721b7e9d4f681ae70c61c910a7034e30c102e8662251e0d0fef9ff7508533cb0739bba51423e006a69f3505d8b2c6f5fa008d9151e999fb293292880d2c23e9f00445c4066dc79553f9bdc88aaa2da6bd9cb3b6c99332974949fbb167f8f3bb3cb71702b3aa26a64499e173cc44096be98810244f1ef39b0a187756dabfd99b5218b3f618f57d4bcce90665fc1868866d64386b6a551d413d428368b83e78ce5353ffd7cd759e2a5162b2a6d695a47a40ec33cae5bfa48907d1eb1a4b71456262490699e17537745b7bd7a0482aa62c9a46724f584191132055e25484feecbe1e3b9f7aad2bf37ddd8be8ef7990ba4c07b87842f72182706ef725f6df8dcbe6f0bd70ceb9ee20372dfc6b4a0297e25475fb9f73eaf6c7058609cba48a6c988138b6d6978adbf2f8cf3d543724166f01dfc516f4fde47c56dc6be7accd9c84b6d04103c98bdde43ff9a2dd3743446b1c1e63fcce82c9ce000af4b7835bb104f045838c8c3cd4181ee92c999f13e0a1ff434e3d9260e5662764963097dc2dc92bbd88933a14cc6316c48a111bc4c69de00203dea1018c3572e9c5bf21eeb9c3da5cd5baed7946ba0b280f441448faa8c5e3430c7f24c6da1f581cc45ff04db58107c65c0561a392dfe96eece21d8fef1ff921c00d87f510409f4b5e4d5c43342da416ba0f444d957310dbb9edbc5dec284d524e199742eac505dc50de71d677f4951ff49e4a607729875bfd30494b9e7a8d57c619613c073750e7f2c29ca2020041494f287477e8d1da375008cad38416d14b041166f330b8356f50f5091ce0b1d93aa7e8fbc7d50f0f85dd6ac2f6e0372c68fcf2bfe62f7c693b086d7b6c00d84612e05f3d981d49d6b3ba1ac8b9ef9f6d77d986c6235975c15bf9b1a0ce11cf60de68613e5dded14642a4e746d7f836adfa429c67c65233a815b245317b3d37449d619cc42a4870b969602ea8b8f7a59c49bb58c4ed597cb51e32992b12aa9c438194b01ab819adb6d167d066899faded7f145c728f714dc87fea16b2567fd3c8691c373afbc4382c8ae540c5355e62c6969a9fa3c1a0f157754251445ed4e0bdb1b3d58402da438346217a143a8794fa803eef0a01c87a6703dd701a19a0a31733d2e05d67792c9ea98e7764833d862cd524d131fc9d6216121c8a198da91afdcbe3abb41cab615c4b67787035c0d2037049d0d5217c32cbc97cec08591451c178e0b11161dc7812ab28a3115b3f76843c9439f7c53a4b7ec22873370ff87178963947d118defe40529617846e06c3e38f19c3452c82ad4c53f84c8878ae0667100501bf8d57411ea40d31323edbceebec205b5994ec679c9b33cbaebf639c5f5ee5f4a9f8219033bbe94d3fe5d25f3fb60856ff75a1e963ac5451a5677415878ff306106e549612fe2105a3f8519bedcc1a154c95d1c71c2d5dc589a07ec65268e59b1e107452337f9398babca0e4d6050ce4bbe6dcd13e2b12f1b88efaad98cc5b8aa4ba2d5bf47201369691f4ee340e581a687f3c28cbf9e1463e77d70c286d30b506b6cb70c1d576c5681e2f5da2c7732b2827c0664029b22ab904fa8ebb05f5ebda0010d69977e58fec9e16df0775014bd9ce52639e1aedd88a0245a2ab42187b1195f208dd2c940cea3835c690d74c99d1a0fda5cf5d2d6f99d87ae83309a07f44a6e64f428d3025390284ce03b3bbeda8bfc8b0c83229e7b8f81f543486e1df24097abea00dbb1d9ec9a76315b8708868ff83eed34ef0f7b506d555455848e4aed5adc97ead8abd3dbbe7f5a09ca7eeeae3c5db15a283565e17b378c348c49ff2a5d5e87535388aa89feefcc8bed7aefc08ed3eb754634be1d4feb8c5b5167ccfc8d8dff2d82caffa15c59eef4122c94aec6e46d886a4ec38eec69b1239960c3d5a901e181884f88041e8f2265370d723a8ee6cf9cf4bf79b36acd606386571563e901481be37f5df19a206e4130349e58ff4885295dd01a2b2079a52f0ed17424867ac1d57a423722ee472df085f0df99d003dc9ed9ce58123c640148ed487289c022b0ef65f299f79222748ff13b02cdf314023c04a25f188898b8d1a5159e008ad99d5e7a13888e85382b000b652b751019a5177a91926750ae027f58b254d87063600ac3adbd4ec0a2f1802467ac0f8023bdf4b010036e107807d0254db1b70c96544c1a3ee7452ae1684f7c76494bd04c20e3b62474e5b46170dbd62578953494d74c5c386d28965c9ad4a20b4c24ed6d2ec1905a11016ba34134ac19d0d8dff339a3a7b372756d110926a6bd8c5a965d20b30ba8a31c8bd123e786a633684c0a706f4aa61ebd0eaa99bef0125cf7965112bbcaf0bea0a6fb74706f0998f3714c8f9d1c003866458781df9b852792d92f82afd4dddd822df53b56cccb777a25088edc5382bbce99680830b68938e7940466ad51f49523f54c6570d0c3c353ae46385f3a7d0c67d6dad461907409d3baedd009e09236acaf16e6df74087c56b5236c8f0a2ab35499ded273f4c0a8a7fa0547dbbd73d4468d713e8d44c683e9e6225a6d75280245e63b27f8b2e8fe1791d224405101894d6b9de17625d1e598db1254f77fda67b1bf9d18a0f3a33168499724b7f09c86adf035dcd09190e90f541cc74a93975e6e05e547d7f159171e121530008a23e95c7c6689b17e79aedb4c5422d94c81addbd2a83c57fe1740a220269f72b33faa71bf5f675aaae80efbe3f2bc5e428cfeeb2fa8780f0f0d065cde866a8cd95421071e7a83faafe3204c2c0fb79e69fd0c43defaae6dcab2e11b791b8b7c36f2dbd1fac73f2ff6ce3d668123424dc188c9e86beae59a1f66634bc5b53d38e98ef9d07ae1447d822c1216cd5070cb0c7d26a52d740cd3ae4773946c08482722b6fe882a5d77d581e2bfac4006d22b74f23f73612a76bb733aaba41d7b2accc4f7f62eac505e4076ceed3f3c5059d50a44b0dbc9b3315bcfd6501cd49be6f52f0be1882a02d5aea3af15569b59a4f3cae80c73c00e485634fe0e3ef66fcaba2f18157cbc7d278a690241f83f109c14080a686c6ec0ec7106bf2579034547b927f93ac2bef757069112e778bdc88a085e8264af3731e337544ce08d0193cc0e6d9d9194715502854081429d69244d61064b600edb43929759c08d4829be8d81364c60942db876b9f7d1aafe9c4889e5b756d0d8abeee1069b08115f7b834732ffdaab8b8e5de9b76f78032fa015c39dc8728e31b909627c3536b044d8a717449cf2e1027947130f8ee5600d2bc8701f52a54d8c945cf966b6bffe2b4ffecc6eacc7681e6f9b3a8e5931789d14c5d82a276caa8fcc0c27ba5ac1835715bedb856578a6f0def1ef1df88a86d062bcd7d0c3ffe56ddbcbdc86e24f3f736842702e9c5972f1a2d63df640bb2753ff3a30f8dcbe3e9e1bad8895ecf4686c740be71586ba32f5df856cabf576313bbe8ab344079f6db4f22c035038ab645f8979864596254d57b7d4ec6b738114b7fb13442b8081880b32c3b1f6f6965b3c06cc47a7a6afacbdc8d67f7bb67f81ab7ee456550e5164fc2cc2339e7a466dc5dd4e1b8af46623fbb0c854f25fe3df10a21442009c3191c3ba40d0c9fd096b0ad175e9f258775be4472bee7ef4f23bc405d90f01f451c9d32dd6b82a7b244baa52882cccb6357b069d0c2deae91e01337b7c1f24957283e8005dfbff395fcff8de1d3fd6f2e5cd1650b760cdcf19512604cddb1106f20ec7e5ae01301985f37aed61fdc1591b210d3b31469292c98a255cca212acb8089373c2f603f09380ff2b10f633aa45e4a1a7cb538cf224cf3ec732b24561c6daae89eca91f0e58a0956e551d436dc65c1ca2d81ef6c9e13b1bb7ff1893d5b66ce49f0d339dc5446f51623f113bf2f2ed832bc9c5bc7a43e616ac52160fa366cdd11a00c148ae5364fd817b7e97fcae654d72c34fbd438caa12dbd1103cb748f26c610bb4758bd0cba075321594e098d7a1f3758905ec44b808750607fc2708c51bc38647ce5cac856527632f4097568f191c75269e052354c1450062025924fcefdfe290734b119648644cafc2e79749c736a9545bd660e2ffd1fca8a0ca271d8a9ed017f1ad1a55d044b5d36bff136bafbb437f8877b8eb098817f3fd7fd0f31e723a05af9bce12d86dedb4967dc395a1341fdcbadb456924c242157a442549219990b4b342c4182678e682f493ae8e378b64993968ed70758b87f1c0b964c5ff91531d7f754d91c23a09287ceddfba66b0bdb412b434159c5892df66dc560512101f483fdd93e671de5ce06ccade3ffc5fe967d62583cc89503efecc09fb07a2f78ce0a23aaf9c59ff881524aa3e4ef3fdea866daf7b34a1e54b1f871fbd61cf27e3507cae422c1bcbfc439e7a8177d132375eb7ba3a6552752c441274d5e29c27c7983ae59a93f953e54b641325bba7b71b1ceaf2934a7a416a987ddf0c8824851a579c4a6152a40b76554f7d8ca490e548ee25fbfb818b90322798aac5e67c57c7b50e7a4e84de42b6a5d17ba3fd91f71ea8124b9bad993d6e59bf43fef8cd96575f1534beaf41d88ad8c89a650b9a2dc3ba6a6ae669c35fa00e2cec41e875069c11033edac6300bb02bcb6def0fa74dd1d900af919dd586783c869d97d02b406e33cd1f1fd9459cb9a0312f5a20b1476dc093a916e817b321159dcf950df910d3c47b1dac4b1ae6f691c052a65eb08fbb76a88357c08b20557338baf67d76dcb327701688a2ff038cb64fd5a76fed5d2746f69284b66772ffce3b4fdd6d75bfe0276f9a958df20c830504dccb93f9e63101f6e79d259e8bedeb87eb1a9df887763ff6c17f8fdde0e8ce8e5bd60fe21f4d465fd2f008ef52dae4cdbd2998e403bc4597f65965cb01b38436b052e48ea9ed51be055fbdd7b4acba47d4c9179992402062568a5860422c731e38abec3fcc9092bf1ede6c6d5a00a65fe19be455348370e3e5eca729e129f6f44b869e317a85e87f6733c1d7b98f01e2069f827b41a314dcceb671163e2943260d8e5e65fcc5afd1b93ed48cb3bb4e479dc158f720db5cd08525e3c30691a7a7f43ea1f112e53f9079c79d302da9676fd746f9ee71cdee8235ea54f7f017a96659dc3eacd5b9ae7f8128e6a5afb97c2ace63c7f6e4b2fa49d16e930e1ccba49c56ca4bb5bf7c0dc873fa76be6ce66910db6588aa5bccad5d941042f1eeac2a71cef2606e70158e1a8d8ddd51f23e025a88f275c296d0165ceba9029b7d1bfeb9caf288a795b2a249e99f9031175d20e36835659e5b6157b10d9c67d841887abff5c30c59f73574052fb9419380f62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
