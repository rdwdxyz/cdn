<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8782a8781ee6fd8371f356152d3f7506844528a17427766691899880b76aa7ac8002c48ea44f3555c1420484c1a6f0671080c16b7aed601af6572af5dfc1fe4ce20a05d077bd8bd22d0bf2764d16a66543f3e65c867b4745fe698a57aa9aca4a262753fd2b417604ed2d71c2cdf3943d25f93b39404996b35f6904844dbdcb888d990e7ca7fe3a4daf4038fe7af648060cddd35fc31c363fa78f89f0625fdd8b48b55316f312780a73cdb3978667ac4cc1625275585f7dc72307621422a8533d9c60e0204995b3782f4a8da44016a8d7acaee0efc00cd5c90eb12990b5fe5fcbd5fd8f5c40e51217b0b031850e4102a4f18d18b0b6f6dce348b545f074283847aa35f1c11beb737cf447145afdddc8e9253edc5b8b27c4cf366a2f4676420e05fb0a83a309d98f6d22c174145bb4b101c6fbb41f185ad6bef68d9ebb229d7b23a7367013df2b0c35bc3b570486442b890f8d6d2b3dfa8d3f816d8a226fe529d531280b5779cd9c26a40919a5951bcdc632939534fbb10da101a70933b50fbaf320a76759b04200e0827e3b16830404f73188909e9d2b119be46dfd45c869d8acda22b441fcf71b89f3b6b6a63d69454b6c0cedd9decafa786e19705ed87fb46af7b587f53855a8722a488c91177f182c3e6afe9275e8abc733685719104f71ea70b9c302c9c469bbf25284e8754590222926ef31fa191d92afa5f5e624b0894975c94d87889678249a610f7e58ca420d98d592f1994a6db169563048856dd069c49d3b53c2d23a1116f9b882507c6d391fea93571572a6efeaff590456b8b0c30ee125845c52c70b2b96f7e8de47df691d9674f6b57a3a3633f64420f48996e54cf7fc150628653c17f164883c11a611e9bcb1a844c677e983b2668c703d751512d2f1ca04d9a73d7836bb8d9158d999a9c880d52a836a2b99c6643df92e9ef0b8191529d4f2d0067e72a23d4965c2344dec69788e6490e6c3c92f6abb72092f6cd9ac714f0ccebdee45b1183f276f679d3b7bd0fc5bf992944d2972f6f53418f1f9454dfd4de329c13a68d4bf28d33ee3a5d547335cecd51e71b6081e5f2b304ed3e2cef3d01cf9a14f9cba7cc5608750f7ad009a9c4bedb59008ba6205565a0f87d57ed65c8636d89376a9a11bdf5392cd9fddf681c3270e40ba69fb249d7371ce84ad0f0527e21420b3137f16a11fbe6502dabd24cfdf97214dfa2153616a8776faddb8de9bb0b8fac0915980a29c08b3d11753564e032b566e4ad55983045846e6e732dc57da4a9f52daa6b1d23a9be74aea5f919c2d190666a9825bb81f87e5c8fe523d2234a1c86857032ac1ea2c4746b437435eba65f59940fcb0cd1e1b83835bf6e59999cb6c422efe59fcc89ec5989da16390aaeb5e4c129338979883ea77ea69337b77047290ed177fae8e1099ed1e180d602798fca078e3a944e3f2d26083cd96d429a8856ea6c05711e20bea2cadc26a1b7533b41007829ef3a65aee254deb45f54e4657590c5b48bedaeb04e536bf765bdd32f58971237d955300bfde08d3108735958e4f1e8face1939e825e15623c4a282e1fc7cda18b5a6377fbaf5439e6c587e4cd3005455e641fdd51933d3a18dad04553ad55d6011363cef6d5a0d36ef7326aa3819c3c9ca80d0dd2e4f0577cfe162cdfa3ad489366658273c6fd92662c2c5f25a6a430740cafca282747a4b93f5a46be4d1e24973b71013c41657684d9745dfe4d10c82f22f1416756483944f363091da83d759b2055593a7cd8a074e81569836c649963469a4ad1ec3ee8cf4ec5aec35442261b18e4bb7ec633e451409f5d21b1775b1e2fbe6543aa0f9db12957b7c3987087b89e0a4b3b1f01c8e0beeac300c515a4f12b557dada9c2fccc7c8cb00a8c82447f2f5659f6a9b6d35be03c862a4a7f6756be1442716007c7bd8eb685445d6d69effe587e94179f51e46550a493165468d58a6f787bd50ec1308d68a21acbd3925cb018acac329a7def553d103ac5f52f5ab44ccbe068c76badbb61db49d2f8d8241e59d97deffcfd258fe497bea238936c1de0e3713e17e4f178f5e626ac35f9043c6e3534e4313ab8b64c34297928b4ebaf7225c3eea08d034672d6bc901c82dcb87e27560c6132538735f94755dff3d7d99980d22c6e468b30242977d979415784de8448d96c6d380b05bdcf91d7cb5eb85a5d980e97aa60f168ac079b0c0201e5964316fe2dc08c03ecb5ed88e602462c2c67f17a5db7a934e26798765465fed59ce66493e7eeab1229b14732adc35eeb8275f5d0367f8083eed41b6ae2e171c9fba03b7424090a9b0b72fffcc358e104b4a546015a65c49d7b6d9432a09be5448c7f2ad0a11e64cd96091022d2eb9b6a7c8b291646451805e708c3316b286ad7618f825eee3f4c0a61770d5aafde0880b4e6665c2b3d7c7462f8675442744521825b2f764d50dd31d9341f979907a9243f6a1e77168e90a550a5dd197f0e4dc4b6820b85cc5652e25279d65c88b18c24ddfd4b5521cf4f5b5c445293e2ba9c8b8dd2b840bdeb9aeb51d6578d9b9427f1e70f8aaacae0fe8d1fcecce17d310a4408ede4d7efe4062198a93e2587d625a47f2de77be7f14a934a42cea17f69307591c8d8f9f63d683119f774e8fb72aa9e6843f7788737da64bb686861cd8e0a2dd01acf13eb05b69a4e60f929c1b2fcc60f73b608b3043cfbb9c6a7d2f4f2f41475d074b0706858a0c2ec9797b677d4b3baf9f154f9627b29a5245104305ad0dd5e11714a239ee4f9e5fda7f0078b17d210cdd4654208b897abd6b8dd36a7af5008a6feb03cfbfa90fbd94e9332d464d7278f86869a988d979b30e90a636b87e13c4d8bbae99c81085ed4e737ea2941f755a405a6f714f98eaad6110953666db7beec955e9b3a2726acac44b0f87a7e583eed973ef891b5f10d733bf940dfe83479e94774e7348409a7bc78406db58f5acce135483d54363ea9c02c01e9a7a8f862bcebbef9483722b7f2c1188825cb6a2eda6e08a483c54ccae2a683c3f251d84e78e9648b88814ac0c4dd8873800ebe5d4035de69ea146760f0f519062a25d713fefef5c70a8c70e3dc28f7dbe7b40ca9236eae189eee84020d1b49ed2288d16e71b1c53729c617b33efaae8337d8a0008fa551b6bd5f45876b9261a312734c6cc8e2f4d57c15a649b21a283b464acba10af187d3a5549d782ce62a0d7ea40d40fac1440562797391a2f51421bfc0271d78680750db05f9d7a91cfb03219baffcbbef084596bda78fcab9a67477075b666f907cce2c7bd8fd43762bd97c329038fe37b037670bd11a6b3f67f24d25e7eeb04f654378c1290eba2c45c3f3da33a266e7b4dfeb7134da3342151839c6df67fe14751781d6f5d3f8b5ea3b652b6f3d7bc13e478c6307a53d9d556799fcbeee027c4fd1af05e539bf50923dc1602a24eed4cbffe3b1ccff6482abb2f267f88efeed78ca2011ce46bc1fcff658088b75e6713334f29b1d8c4de6a099fdfdf78087569357f3ebdc6309183954718ed589cec183b3239596222ec8c09b7e3bd6eea1636d6acebf477cb3f8f180a2916bc463bc2f5bbedb7e82698441df722dcd6eea622177edd8abcdb5a5a0fd4f7662a8386a0ca4fdde0307b3c58b6933505743cebb86b13db82ae28d55f194618bc8ae019cd1a5cbb72fb6ce75056ad6580a58a690a3f4b271b37b5bde4d538a8352ca4c1ea1f32334f46ff2f2d34c66c9c423e410db95c1cf986163bc272cddc831a0b5a090fae400b8b3b52a3a0f408d8c59bf5de854e17274867d298a5414bc98aa97cbe7ac99d327b243085b8372e0169ce82c9bb34dcc3bf7c649ea961001a2208ad9e5615b585715f687eaebbf8c67ee00d46df2b9e90d33ac0b942c5a8b41ca5a94568dade9c56c5887d9cdbe83999e765226f944cb7fd98962339759d6ebaf154f644968c4e7e84cbee16a28fe8c5faf27b24a224c5e1a6ecad49e4d9ff7b5d0b50cbc4dda2043e10c9c1d2499b0d78d836fa71f141fcd1077a3f1ec695b3735069bc824681160a3bfdc254854314594d07e71bc474f1723a32d3acc5a69b2f4abe45e44095a21d81e2a4d8e8f304bf683cd06dd2e635beb0590ec6dd9d3b840baf415a80ce1df8759e4a2959f9eff5b85c82aa1dac6934bce25a412c9e8e560b06518ff8ac50f746aa61b77d73dcc7fbaa4d25c9faa85e144069b59cb07b5a4a672c940e0768d526744b827794e2c163a262f425c5ed78e53cf96a5d8d9ac7f63b2551878e4ce1e86fb98a6d8e8723366bbce0c53d412f166c7ae87af97050a5998d9bbf26a19ab3927aa387867b8d07a0666538304d65b4fa7432c286a1981515d1b23f263fc02ef401ee901b51cdf009b68a8125684ad2202625605cd47ec0cf9525d5a5c2e2b2bb987a1e02ec25b5ed97201bf3ff37c77045121b256d7ac7f7de26f6258505e11aab42f01cdb3f001aef945e6b2033b21e2fc4a9818947ccecd3c73017b1c4f95ce54695f931e88c85a2e7857f4aa09550ab2f7cd8ecad4df3b56fccad4bb919ff969304eae6dec3cb81d334f4c4c3f3ad5c8687cd3f612688bae48b1de8d8b9899a17b35fa9e238a20a315d2a9193cfadd3c4c47608600bd35187039ceddb4ef7c9813cc6dea07288cc666c351fe7edf4cb21dfdfdc60869e724225af7f83020cbcd902f798529b50a202822c4b1f2e2c6d74ce626e215bdcaa499f92977d6340415d48450a7598747dbc870af56c48fc426d6a87408c7933e573227d823235ca5a633c18d3f45d24422de256f541eb8eff30ae0c4d13485144b7418aad12fd6aa13c0cdec1f4875d8e32e7050035208b2df5d46637238fa482925dd94cd6a9b66cfc193c288c91935a709dbfdab975e84c30e00a4bf626114e3df6a56372efdd34c160ebdc78bea04df591f4873d00fdff81ed7ea62a3bb6874dbc63e23079638f246e851e98170723c42940f34e69034c4306f4d016833991d9c977a5fcc584fa6ca20df968538d0769c001869995e9c03177cd30f3fc1e553056c860d81b485940c10c2292f065979f8fb9f23e1e232de86ccd2ec45e9fea7966d10d974bd154a6b67d888349e5647db70fb270e32869c3755eb3dd7aac7956504317dde441b2639bf86f5bf5917dfd929107065f5d4481afc5899e93a4140e580ef65e938591a74d4cbbdbc47c89b7bc27f34b6e70d3897168037c5a5d596988099b940d06d4a65b73d019edfb4051d7696d4219af3d10ec8c1a7b289ea4ef8ba117f2a07ecc9fcdb5821040a07fb1664173f43bc2bfc16f192240134672db4079b9e2d974d0be093b452049b2f5de8105165e934c88cf3493377d43fe65cecc526574fe63356d5450605bdc2839fd449723180ab2680b3802410ce38a23c5ec2d2535e309bed1def1adcdb1720a734e1ea5369a97cb4108b7dab10f492e7160c681979d307891587f85cea10be0c5f3d4fb4bed0882baef987ab976263815c40d47bf659aac5707f5a11f122daef6421470109b84591968de0daa9705bb48a0969e7f86f2fe63a8d43a9dd466dfb040bfb0dff829a5b1f0c85e631bbb3b4f6cfaa3a6c763df4c8348e481a6df4d65c86e369f1010fe2dece137d2c85d670a3142e82e70447fb8e724bf9b5776fc6713953c663f0a67f668827e9db2fca24cf092bb7ae2fcb98fb5d551af53524926bacc97b7deb020e99a04c124ae904d0cb10b35816c5f03a8f15b1afb36b0213b2e02825ecbfda83c07bad99e7ee295f207647e20a3e0cc83eb65243104c5f728f7fe192a08025c49a42d8b5c6a9518e5e2715b1e14be866aa4ac1d9a96dbf033516da5164bab557f7cd3b3214d0030addfde525612f095033f50e0930eddc1bee793ba8ec258881c3713e147cda4c3033e3222cc6e7721d95b0db91563168f40f516fdbd4b5617991d733bd09690c95e099106f5d54973e6187653cbb4a17917ee1caca8bcfc8e917c83a1df62868e262fcd3cdb137ef3d0857b79511100448dd3b9ad1cf8a6dd65b877d53f7262d0b658f37c99fc49f22e72fc382fea829926f7585ff41cfbdf04e39d2a5bc4a2ccfab6c0f72065cf11bbcf7b7e87d444623811081523fa039d76a066db826209b75c592af2dac3520c05297116d0709281b552f84588b3a01a3068ec30d8b91b434b71311352374315de765c30767713b890adae80f9e08f606a1b1fad568718fc2ffdc6f5504328871eba0430383e73991a57eeceae2447fa93be07c70718e6f051d4707a18e5ee920894e4b4ea1407a06fcc82c8590618090f616ef609dc6eb96cfc4be4eb3db28382ff1882d61c6d83e8e77dae8471b9a50e9dbb07dc49cee038a1faedd6aac34547b7af674c3a288cc3cdc6e182e072f784049c20abbd87284867fcb12248cc43c69b1f989f0e7fcde3d3ccc61ef14b9c9aefb5cb947a92b511d33328ff862396f791ce5104c5f7fc06c3a7259663eaf281a5599d2d5badf4006310e98f8e490cdd9f89fbd2bf1d82fd1b716ffe5c56871ec4d6b7166c8789d53dfb7326648378fb4f945adb29d6d949dd4f1f51682054e4df9f6ad148f058b9d3604b477c3edfb11a7fd9c283b2577373a1ca7505188a8cc7bbd8b72863b3bf862021598c69afd143c75e5f2b5c71cb11c9dd91699ed7938633bb0b3b631547b03ce8ecdb79c08f67233a8bcc3029dc9f081410f1bb9dad8b28e865dc8e84c1bd7c19b1b4030a668ff3752f02980d22fb48347aad6e021c124074c990b355c49ce087ceed8b781ef090199daf480cc449f712aace591ec2572922ca6c559f9b1dbb849d8223e40d6df548df52f0a4439724881d31ca761e1ed21ad3c099ac7e7690a87652d23884394a16e3a228092628b4e18b287189831822931f6247c2f5268f2208ac20eac39f3e9b7b71aa365eb0bad68830b24ee4a84ebab3c9fe256575114972cd9614a9200b4e5879833d7c2564b04c9ad0ce2fde7dd43cf8ecd7b22274026f04d9234cf638ca9f1adf0056069ca56a6850a0ea7aa6da44cd1b2cd880975f4d852534bd80d351f7a95aea93c206413ee25bccbb6ac0c2a30aed435210fb2e617e5024317c68066c0bfc4fe580f3ba3f61abc399f1f8d2dde19dc53625b081600e695d7225793e70f8703fa17cd6112e844716807905578416bfbd322d32b77bbffc446d096361038314273e2ea8c94292635b33a6c0730af8f730bd899aa3f472dee5be8094f474ade5c7187097cc537b6343359d67a9cad5683b4cdf3a0da8ff1fef5dce4c4d73147f4bc5ca77c2e0ddbc1120c9f3b1fd0faed67a90dfa8174cb80ff4398cf3190b54d2ba5e4b52e2b67a9ee49d9e7db743896cad5c628fffc31928ffbf5ade35a7ec39b157d0c061a4cfe62ebf9376d199c9793fc20dd0efcf6a7f24d42715947f15853de16a3e5aa1bbc734f41a26269b35acf3516691f3694d48d66799571f6a91bde658e4ed263bd5461d25393771c7c94c8ea7e318d14fb9ead09383025c83ece88d163c27f65a63c31acca9a01ab06e6338985b7ffb31aaabbb9aef05524d0bf4465b224367c69de7a40cc8f2f99d684c57f704ee46c4de538255df108e8bc9e53f2b79e0fc6a1ab62d3e52d7b7de211098bbee5e8f9f6a1078e67ab7af7b0103904f8f390aa7e3afb01e256b6a6dba9cefe92d935a813b1a30b7d4f146bd58815fc19eaa7b7465ef9c5b36d1210926171f71b8963e42598cfd0124f38c9894b34cdd4c44fa7cc4cd23f7f5aeb77509f9625d025b171661101ea9e6b83ebab255858ad01393d57c8e9c60f256317333b4bce043cf4a4f822193fe02c32dbecf6f61ef6d59af8c0ec6d32e0c9473b800ad0a5dd2fde60ffde59725c702962781c20a36e221a299131c060155ae0cb7d2035d55ae738e63875d40d13dc1c6b17a4845248f6d91e4b9a1e3a3564fba105a2a0796a20ba685c43c983c14dc628de310fcc7f0102c31cb9df061fa09c5d8c44c9a6f856378a0921ea05a2a5a561ca74d6d52aac92bbb39304f60537ffead8401594182a23432f540930d6c2e9087f6830d89059616f6364e0ff1ee4a53f93dbbb6455b4b310247349f0512a552039250ede1ab661834f8d1179c5c2c5a4b255ad1003d279647e00e487f3410f2b2368f5c0512f6da63249d2cf958be2682fa3f0f1ade323455418236acfa13a0bac761fd5cd5a5919cbdc234d0bac2f96ca05f8b72c3928239426919c8de500af6b87ce8bc5ac60e66e235e9b7b751ed877df141ae786d879f0fae27bcab272bddcf928f5cbc8b72709ff7010254584d33dc68b0c1a1f873d8cf8cdfd42dc6976e3c0902c660dbde503021058425482df9e0db2fa5caef0fc4659273876c184ed215470fbdd0ba8e734b90647dc7288e5f23a2647ad8c85c68663e9e757f516b2b9de28d7400b7cbb836b83c40b8e48fa3f84c835e8cbbef7217757aad7ea025f4b66330223e840caedd602abb62658b60323ad8c01c92d84d183130eb215f3560427a70a46ff0941b05171a067253c84e7dd5629e34329255bafe34541ae6a9e47dd442e24dc310e54d2c022c8aab1a879e1cf631bb349a22f80237107ed5a92c55db647859b2207400a57bea62abd358c572b94c0f95b40f2519f44319001e00f6baad36eb811a150dffb2272b19186edd5dd16e80a5099f255f294cfad68b6a790d1ae5af8b90e75b5dcb770dc8425f0dccef0f8bdeaf390d9ebd4e400274515f1dbefac4c238e99c4d5e0ba43c4eeff0d857945ddd4b80fa10674f0e7977e29ad1506208a5267b898500c0c3a400b08605c32a27796350f77d8a9f41c872d7a6fe71a91fdca1ddae9df16b1bce06690bf07037762187f7061ecaaa7cd6ad2087a9144b0b22175e43183e327b04054377a2cfa541f75b8b96eec13b78e07e2ac028c7f38922ed41308ac35317996e0059141c7f135d3d0a8c7b1de32b9c572d738df741b5fe9fe2be69dad82f711b885d5efd950644f4a2b85b4e1b4388ed4c370eb2867637f5b45669bc847871d046215698daf365df41e0d1a5afe7091fd728b920b38b762e47ecba57cc0fcccc7b51490e9f69d448d4829927958907ad7064c3f460bce3beaa42c6587420b6ddb1f736bd9c2424752d6fc1da72a7471596ec32b777f261d06ca8494fc51ce1274b125b2c0ce375d019afd007c4c8d82ad78be3b3ce51c37c1523cf47d391da7f2930d52d6cd5bf36fc62b5a06be1cb428af4d3473d69c816950a01ada3506b7014719da79130306150b381c45661c1d65e2da8cb3577579d7c68b51cefd5fca9251407a59741dfe7f98861e9aed2e74fc5ac4307770f24e517413cde21947de41fd832b49f898e46a80d0b7d83891fae1dc3c50530fac0d644f59c71165e46706fa4e463406f09a336b1e5928e7ef7ea2b030cb81e882ed95e1cf8351fc517414cc7b8d37856a836e9ddbbf77a66e299d05b93dde16f9f387d4662ab02b8056a83d39502d3d384bd0787dce575f0667c9cde1c83997323479e55017552c9418527a8a642c49b2a84c1c72c1fcc3f6faf082d46612bf27ae555afd386b821a67cecebf392fe579899b769e6673b574e4bc5a5ad2cb4e2bba6eb4f2e83df2a086c06ae4d400e7139d86c31e7e663eb366bac5f33c7ff3fdf94e287993e8b6ec2c86059714b33108543d93c78951bc264c87614c7579121df20cdda5c5e6651c7c462ba33f02662decf80e163a65a04eafd7048f3976a3db2d03128696eeeb7025b6136110819fa83a0df5f8edfb8f179ac148fda66607aa224023837662a10f3cc8a53d74e98b0432d8330e0fcadd2d289a7567a7d6848a435602b3aeecdb12131f4386ec050bc24884bfd84e871b4f337f065a8f2df0b5f0feecced1b5847a2fa166c1f24fb13c3dcd79a8721cc094b1f5f4840e1760ef6178ce797a009b9a200581bbcf7ebff691cab090b34eb6904f4dde3ed860388d1acc052f53fca860f4f6722754550a99f6919f7f7a8b9f862a35879fe96e9bb49761539cddffdf49d2df8b1cfc9d38385363e1947cbdfe7a4ae8382705660b28a1f254af0a216f1222ab7c680594cd8f17a010539ce44476329fbe131b84c50b58ed904a29ae802ad9b2f307e2317c76532619aa338055a20b878015208a7e6a1fe4e7378b932dfc09152933bc9627812dd62bd110b187c12db7b9adccc5144d8b673d1a141e8cca308dafa49e109742ee6653ecac8fd9717be923ce2c2f4af81ef31f70fa7a36e4be9b459c5df12d7e9c02b7e3e9291194c00a001d4def965f354369367467d691d97a44eb29c026abac1c76345384a8859f828fba856a747e3280356a437da9f9214dc0d0696dd0b4d7b2b636960c869703ec64b3be59c5c8b1abda49baf8468b85ce1b3d251ca50ce498a9104ade00eeb54fc05aff8e7e55b1d06ffc6c280031a7ec239f5281aff845b50e9feb50156086235628eb343550eb2bd8b0a5522ae0377ccd47d7cd8216aae7e107008f9e0ff295468ce96b829c5344dc5a28fceed783794a03345665fc7134ca582a3086979738865dea5b4b8bf1ce6eb3adbdfc5e0e2441a90eef02d0f1c9d788ee7d81e4e75f6021dc6f3fda79f946fb983254c64e06ab7e8842a496fff38bd075dab2812e67aa5c542f5e8b111693d75e8737d12aa4d7b3900ed786721215db415595eb49feba05c289272a99c7d708355d99270cd65fad643f5808d9f76abc6194c448378180c8fe4770bf5ce851224dcc904f1b93660eaf1e94e893d8017ce5a872940598f18fe4dbdf713395d6e3cb58123bd24ba5cb97a098db3b416287714187beb771c657f8b1bbf82c7d8ff2e1289183d35e135e65616bb1f0c3d9b43bd2eb47428671b85637f7e7c8a756b4a0d8952d40134201b20de4f9b7c0808a89e09c5ed7653ad71654f98bdde0d51110e992ae0e51520ec8b33e12d1acb7d9dc906a60d23289378275b3e6169fa2eeb53b9712e3bc7096cc4723b76bbf51d45cffbd6a4aa36808ba159a395765bd8834c163cbbbb7664b78f72feae732fecda86441639183dfeee35b047c8c38c5b6f5a11b2ae0aa585f1710ac0a854e79e4efd39eb68ef8c22a220ca82ec28534ecf2336a88c9b2bef5adb64efb90af80f9e14418c7161b1f1f2a116850489e48f7a55bae6238551d9447ae8fed437cc591d6f90395a99ecb25e41ff03aa908534752abfaf8aa23deac80045437e431b72c6862652508b16ba5d848d00668d4db13d833e85233801a97bbcddafe6e75b78c618bf26e12b52f7118dac56ace50249e1a859ef8507cb5329f0f504341c85f8a9f22d9f818a034f7ce1aa657f364318c553a1d4b7e1875f73f82f7f408e0f129b8b10fbf82737b0e1d4b1921cac619a227ce04bffef4906ed5ac029ca5bb7826b8f58a0a1192f0af11e8c768bc5209ddcd99ec3eab96d46c32201f03e182e54d1cad973d34b91ec27ff7eda3da62e61635d3e22d13c74c19cdc1f8c39d09b6a4b640cb2b512a6d232a34843598adb66d34f78d09b40551728baec56244cd592d00afce2cd3d88c051c8162af2b17f92be45b3e5f8e07a886f7b4f9724f2461e90f5e16c37447c1e49c7c2849e4f05879b2ec4a8b4bf3ac9c37cb15f0794318297c53b65130c97ab0be1bc1fa23e05e652f4a7c61ecb13d0d95c07ac195e52cfde4c6130c228bec3b24fd9cb5532cb65013ff6c710537ab908affe257753e4ea3dec0c0391aab99d719cd3b35438c9f8dadd480fd86cbecbd746b7602f5096febb0c5ba9e7f32b0ce72538e6f3df75893ae7fb22cf2f846a2b5a9c720a739e3b4998beb9f6977bc12a7f0cd82f71559e1275a539db4bd1d6aeaacbaa56b6dd04c249bf9e43132c6a01aeeed0df34fe11c00065cc0b23b494e6a8981375e427168c51fd6baac0fe44e8c111b84989195d1576d341930a8a4e864252f03772c1542a9225245b4a6a073a6d4e5a9a70479c302733fdae4cb6ac8a7335ae4b63fc7b7f6d6000e8f25310d7f7d5a72d7ac571d0af3e2f40e631454269ef2ace80799d41239c9df6c402d0136ec14b5a0e0332575dffa69a0bd2d8031fda99f943be985d447b3c4911b89660fcc7f4f6d152ae830b05f119aeb7a7c1e3c34e25ad86f7dddad4b9b895cf7c9e37b5624d33edf31bd43c677f53c112b0a82e2bd95a50d56990e7211a63ffeeba4f2569958d2928c3b6be32e5f5df1d412be33a11f0cf050b9bc8434d04b4f24a2022598b68231f8ea0a5890cf1e97fb56f3d5ef089a0be47172d3ef56934945b1a27558f19e77c8babad1fdb3a583982f6bc0ce505f3e717e3c725add33fe0fede6bdaaaa47f4887ba7babe1738d605dd5f26f88c1427bff5c8c956895841236370b09b236d929778cbf84b6b347ee1123eb0595b973ba004b67384ae7536594ba764dcd4a6c4ee88ccc94ff31bab905c7753018a935176a03c2564afb6a00c9d54ba7d77d7c78da05fdba64c230b3fe5b50146a610eebc62262ab27959e7dc682731f9b7e43df366831afbb45fc4f7d83d0bc30aba257e6209c7f94a23e4696930a7a12c3974e19581846576e3ab71ab00726c882b4d3cee20fe27f2b2a73d92ad0e685f04e2f6e7e4197c80a013961040c57cba38dc00725155634859d8e8a13595b85217eeed235c3875fce862d2fd2d822c8f502404957dbac955c9dda127a00a8af3814de7751026fedbdd805fd0fae8c594feb04e16a7c4d7f5a73e5f1b8c4c7a38fd35ac136bc51b2b6b9a4ae6905c6dba68c642468a082b7917ec71c35dd5a026822c0d2e77033744eaadb7c8d73b3f83b50aa034370b00355949b7a10359d15e4c92acdbb3489ff39b47460fe970124a403ae179af51c6123e09dceba748b5ce21dd6555c15e52733f1650af002f912af0821e7790bc3e3bc67863fe5fa525cb4448d562fec687785d055e65033ec3fe3b8f8da4e87a79092778fa7b4855e5fd95fd71665353deb92041bff8005509b7b524d99f8f73f73a30200d4c81ab52cee5dad7f731a3213cff80a95c4eecf1773354d08d29cc9bb527199786d44778ab43c054a5af23099d40c9c1f46efdf3bb2deb0a939f04e3db86a79b49058336c410a92e478434a6115c5fa9aa5096e57d71520e95495097a937f6d39fc099e0dda4cfab601e8d170022bbca90cd4549f5005e4e4c5bf1da409feff6f44e50599ee707b8ed7f42e9e89d419e3c3b43944b280ceac33a06329bb8cfd1788e0354cf4c8dcc55e09218dd6bd24dc3ae162e921b2d97a5c33f73584ec76f48a785a5f4484ef89b6bd5cca858a238d769f92ec853cb24177feec035096c173038977010c3ebf4cc8dd2d279b13ab1e540d1f83290e15b53a31330f03da2f32f46c95ba205f6c39f77d5d335beba3d775d97d07a737954b54984b1684221e96b8582e2374a2ce40219758e560c8f629e88521c729ababbf368dbdd04817dae636d0884f4217f291acee5b4b8425eeaa5f068d6f28872b3015538c674949d6845b979673d3fd4458f32325738333e71f432d7eed558e9a97f64c750d18746784c7ff4fc43858e82b3fa3c22de5b96472cc8617ce353d2ee90f2d560df1e9fbd813f62d6ce2d157651f8f013f4e2dac27ef26de4f6c88c605a3e35e30c230f4e43edef28d7194778e6e441c09cb56287803dd6178ff23e8c6dec13c0802b7068e1268a33c6ef7accf4425fdd14ee010ee94cf7bf4e522c40c528826b26b30e583e6dd75d75ccc3a514181b916e994778529fc891e50ffd4cd790c3ea6ad0e0da72b9044596fdf55b8b85ff17c9a057b515ed6b2fb221a5c86493b4ac5e007b731fd68bb0529612f33500da3701d38129af6e4d8fb8d3bd99b01737b0d9ba6abfcc734cd0f3d92d5db07bc7708d158a397abc4eb1fbae2716218aa4dfe4049da8ba2c120e9cb3678feea6047a2090ce6708f7bf6bb63211d0ad368d4da5e7ab9873e148ed9f4465b275b58496ea7c255877613f159455c7b9b66905537a51c337ff11c0319e3e3e12305db5e23b8ae5193eea2b6a5c5ee0240aef8156fa213408e358aedd2cc1acc70a114f857269b80d07150e2a4a3cdf5b7f71182d484afb32cfce5ac6d0d8c45104cb5c11cc3ef94963697d0eb452aace87eea643cd14d3af0176bf1fdf1e2a5f233e7ad470a265ea23d8e859153bcfb4520e2b03616b3995b46dfde035b734206fb773135f4ef9bfab2ffca39af7e7a907c947226bdb289b6dbd719c0401fe988151dc74a6433eb791e2ea8981c6ad975626a91de42577b7a2653c9b4e8f5e4e2e034fd3581a5a680209f58638699d6cdce5d5abe450893ef5ee05f310530388b49262c6dec4e5528e079caad5bbf5cca29021c9f5f188a995d4238dfeedad38f993b2f71b4744ddf6f73e5b5529b3f24a51768e20bc8c6754ae1b7336459a8e40f30ecf4b6f9e7c64ac09fe82f6ab86916af4fbdc9a7f13cef54e7605af13b1449be5b429653bd96d987c3f6012bb226483d2b5fff1f003164a6a6459e7d5b563b002f922fa6049393726d9b9d4c83156b2583748f8ba8a9d2d28eb671aa1c0ae85c5297b14e6b5590d892f18476c8364050bc13dd4497a381d134754156cfa8782abb72354d21a4b42639d816c49978af320280c16a68ac2d1fc7508f34a6029f1dca558d1f82d416af8357656a75e1b5d28a155d23fecfd2f4d0a0f639e9b442e2c533d193dec11eeaddc0237271b02fd6da2ed1c15dff958459916b4cd9664f6e3184a7c76a2ee3ba4a0bea341e75f352b33a4c125791399d46da0c7fb81e2fa30be933fc04c3ce9a81295c4b2105fa44239e70f0dec2b7fe2be922b4070a37b942235436f0fdf79d9da9cc1af42d3ec1a133d90dd4f4c89e815198ecc0fe9c85086614c3682e3d1cc11477360bad403fbe3adbfda39742fdcb93827f0532bee61ac817ca0f041dcd54cd4496acbaffe9789153e3540a954476cf19a60e62f312b5bb66b59a3c9835e2f45f69081de6d85329b00422291cc8247c2956f618cd73ef2159d93cd342b25cc904480d2a4e143485e0a55501fd2e3cff038a37cb2097a151f7cc34c47651c76053f36d3ef73ff7fba83e2b643fe6b41f032da404ab95b09d2d7e93a2f9c59ec73efa7dd8665d0d4e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
