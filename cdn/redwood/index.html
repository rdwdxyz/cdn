<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4c4b3f5d10f60553c284dd80fa546682db51188c3bca27a59257b3fadf804907814fcd8134d487d017c567f578272e402b9c47aa879e0e7817eb3ba8bb50d024e6ad994b9cec023ecb6e2c580c1a86d8b0d61da88ff89476191d4e28ad0b4c1300f0dca5d7b93faa0a1ae4d20a7e5f7debaf05d12330417dff6d3d324aec2e3ddfd0cbd5f3bc8de9e42420eded83f8a404e5dce5299986f5a5a77301fd4e4a9c031187de477d57b6c76b1f22c877e6f961fa1484ff957e7cb04735c58db555f6ae3031c442901ca621ece620236d09b565af5dbcc0d716831d55d666e23026e17016804a11f30f180a3c9a9d7a19093a9a6c3c71e03c8a2231c222e4495b0debbbf2c1582f930d41b90b380096f550b3e979ef716226fcda7e51819a9254d7b66dd8bce469a2df00f0bb3faa57dcc40a237ec09ef6ea5331ad9debc4ae319e9136d25ff5acc09f6e353f630241c489b30a4f1cc5102b830f7850cf4444fa0c61e68402aafb384cc53f7578067efdab8af297292bebac01066a7aab9728c5097f7b51e8b7bd7c6f2ff9179da558d1454b3401f3550406281192676715b39244ec64b03a29fe708ac93fcdcecd6b267ca802a599bcc3f5fdf0d830f471070ec219b22eab1c6a475b504b0f87e069175ee14a78aeb37baa6266b1811a6faebc739f79f88cc2001b8291b5df38449ff3008c2fb9cd1e90fe6ebf03c7309fef2e15575b89342af97550931400c9b664ac490fc6b87a4fd3f05b8e06e126b56f55e6b05ccee749a557fedfccac2264eef82e33f6470572962ba2bbe04240e83ace5edfe277bdcae97dae4f72ba40993765eb7be4c178abf7dd23e9e8852b55e2ad6c218a26fbf22b1b93b0694fb5debaec81ddeeeff31b51dc03d8e9906e6c971904bcf5a9dc7ff50627dd69426a460404453be74629a26052dbc9c46e47d5b42c13b74d539ab32ce67882a45cfe0362cae0f77c596dcf49cd16d159859a6a1982836a24c7c460f35633d46dcf8e535f40895282c0666cadc7457c10de9a1c14a0b8d23fd3761508acf1dcc6a35ce58c756d126568e6646b8cfa3482f827d1829196828e1bf9de7f0145bf472f9cd842a9db39df10a6ebffbc255918f4b0e0e4d59959ac5babd0736f02f05784a77b839ee3ac6f7b77da4217a78aa8a16605c9ebe53e722482a71248e346a4d5ad0c6a3b20c9f81f69398207411cc5c7671276b6c592ff1f7b39a3fb38db8da5792be34cedcd22aa6b220a33b34f7c7b65532883b2d8fe983d0f72d8c833a669ccad936a15f42dd578255214fa0f9dbd4460542621efdc9ad45845e387f2ca15ed0a307cc410d4887c893a151cab3caffdf0fb083f4cc98693e651d0b8399a854b4a8b64f7685d9fb69aa6da5e82183e6e9a01f80a223103ce63f7ec9f895582ef68f0910c523849c77e17f263bd96801d8820146f699669f004338a98f55ca02de341421d4c2016ac2137f231616e1746be4ac137f569d461ccc2f9e38b8a4ce14113192cade61e55dbb937edf10995626dc6428ffa673b631e80d9d691c09de263fb2640a4e367083bad37f5563568a77e55d5914d6d6e78e0572c02ae97e2e9e30ac0b054a56eef1f0ab9815d5abae7b0bd4e2076dd51c6413125e21274092567441e1bffda90f42d8f440ca18e953003d9a4d60739cbf68ac5aca0fedf3ae9304ef83d6e277aa9f40d91e7d1a06e10f2c7474747b451db683071cf3b155ef965926c4773ecb39f84d612d585bc141cf366b55184a642eeb6b7181d9c790d16ca6c7f526750e889bc3e9951cd7aecd1cb78d3db384351d2cf9e8995c250e628184f4d21e56e30103929be3923244986cc673a2dd0af20e223d9d4c6e3b1552ecf53c7f4ff1c60e5060e4f89d8fb7c9184643b8b0ba83c1ed63d50fe96265ae14551033d67e458ee2267ede9952ca03ffff75646206f76ddda52b394ac183aa3ccb4dd16d33e1867fd2badd0d475c0a91bc69e033c4a9549626c3c9a3ddcf86be22ad12d2f799192f36a843b5097ca29fdfd7cea74a54459010c0aa364f79871c413e7fb44fd92c41e2dc73451017253f1c57e57085e51a0c1f674f41c4392fbf53b94cabe4e7782965069f9e9cd5e02217e42a45aabc394b457c1da9b274a52334ef2e0cd3ace6de49ff124ca993efa1aa75ce0dff059e146db453e9b2324a27f69eb9c7e11905f5a9ea975ec9cd209ba89d3417428bf03fc55a9958294be93a8b5289d583f0ae1e562616c267a079a168c4c63871d38b137a24b7a8fe57e65e2356bc3b76769a173dbe7a43d5846e227b8cca9257ebbe08680a93cd210a11fd2d5c974e6118581d09e345ff692d6b9c002ee46ba564ad2ac35ee0a7136ded3c513d531fea1837ffb13658ab1fa5147470587e2df9184d7aab305f86089f9cae235e2ddad3aeabb7fb82933d9675d69b21c682a0f3df62fcaf2fbf020301a9c93c0b1ad63680b4de1f7fd52eca4a9f9c9067d5640b2658597de3ac7c0a97cef8ce10bd5f6382acdda0aa6ca06eb4d5654630be7209092a425a4935431e4c7a0ba9feccac73e5690cfccce755a636a2fff0af1afe90f067c67b8b935f4e553172e276085531658fef5f06ce3e6cb280a263c3364a139904a5b9c71cbcf1405c5b2049dd3bac71a02a6bdac829e29b5c872774feff6963ec276ac2c6b15100cbb4c0c164f6339aae909b53827ef23e8e5d8686fd9c48af63ebdf00d34fe359c2a9764b13590d67a90c836f4da3bc0ab48b0203e68bd3c655e5b304f6044e199a901c911b74ae322f7f349e6cc2810b294115a914c519c4b568505021bcadb2531a7ac9a1726cf0a34eb4e32c6684ffd12f5a854926d02973a40a621aa7abb01c521be42ab9c0ec78610d83f6b6e3874bcca38ba413c33923da5efbc941f2faf431eebc5ca1e57853b6191dd735719bfcea8e2e1d3627dc616731883c91bbe5a3dc83ee9a76fd0d7c21eea17314a5b51d62d2f69fdb275a9c0350acd31f6daa880bf326f3ceffc7507be1f678303ba58275dbf9c415f302851677110b281cd1843aee318890efe75ff00f7d2570399ca2f7d8f9a5314ed8581d4f2d6742ff58a023111883fb16db380ef085c02036af33a7c9a65b05ce490ccd26ef7cad14b18ffe065a6fb9b6d9d38a9786c1b5c4189d72cea788fa23fd777c82fdcb99369c9ad023283dbd6ba40573d650f14693e1a723e18c7c425ae93ba0e0281060a51264dcb7af4954a27d6ac8e24fcc3e36619fd16a07c661d1c584c821c383c45acbb588d27eb40636ad3cb35fbd278fea4fd2c47808116926ebbbefcd79c66e3352341c68c45c2749bc90a17732401303b9fd126ace05d18db3a829e7aa6a135e60a574fbab86aecf08dfeac6c1de7836c36f495f376cb6a201a3ab6a6fd241a59cc0c87659ce3139729e2ba2e70e8040f4887755b59107422fd8ab9c8f8c58df5bdb036fdd1ad37fbe9e4ca82d92dfe989c1ed3f053c3dea8e707733443744ebb4243478301d20f6bf678c4960b023764f131221ffccb1afbdc0eeb88683eb453ff036eb59ed972845a23a3e295233dc7c8291811a1b0e589856abc21c5f6f4eb3fc5ccae41d20a615000e0db47e973e2da3c89c98bbee3c9d44b70f869d82b1d7834a2f28782199dca806c46f6c320c39c02567544a35c8845878d9ecffd7003fa9e9b31bb8299e2925a71be35bbd6161ed5d175f58ab7c70534bdd61d5e14cdc7891afc657a941231ddb86babcf0458bd9cb87d9458b70f3124a82d1e94983d5d1a3236f17932c9b0744ffccb501d4762c163df5cbfeaef9bb38ac520941407e67416462697347668e7502829fd04b17a600986d4e62aca545d5fa7b08aff87fa86ee443f4075f0d6dde51f4e23ce016cbed0a1e4b9975caad139c5956ec2640af718aac2c5a5703bc66b0e60a76a3be36983494b46ef6f74acebe031f88f24d8fe3f74101cad7254dab51cad0a15a01399f1d6e22267f436669847a831a8413a52cb92c80cde7ddb79005953ec7e3d2e6ce6ebcb4b4a262790ee3aca22fb17425141d8a7533230769ad35b3b411bb5d7b36d347225cdb0eba6e4e54f4b56b43bb7d752136c775b5ba77790f6ea4deeadecfe53111ac59a1926f9a1696c346a864dfc83228e2d5cccf588812a29974586d290de6bb3f480cb93f73c5b0a725c44e0f1a63ef18aea546c26e1e312447d32e9ebe56a60e655cfb54b36f8bdd8a0bc727e1c034bbcef5c5ef6f28eebfee486389af0e7bbef55adf6a0e80dbf7586880d2791a4b63a20431ea5028cbad2365a8ad53ddaffe74cfab15a32955b129e1d19545b8867f8baada20efda66d2ce01e8566a8d1796195514fa07dbe2d837af66fc71429a5f428f8169d11dc4fa132f4e363756664047be5631cd0f0c28368343ffc01168f4c46a954fb242e5d77e71ceba6decf09e4745d55f02b0e97e149e7bd2e697bd6ff587e0fcf8b2871802012744a2e6a074b6b76791181e0c99c4441c2a4c606eea82135e96bbe9d39d9136185d839c93b5c65f101e7e2cecbdc519e25acef4f1a83514bc50fa588401b342fbd644056781e5aaa927d47f664118c0f87cf9219b41853b4801f5b82fd9220c7383c601c6546f79ce6d4ea27915f55182664b6be3fc4846c973db83d8975046e1342adff26d7cdf21b8f2495803e47c41ca6fee9102675f6c5532d7691575def7964ce46e68230791a77b0847384be74ceb2e04f2af3146d127084fff146e57711647e409c44e4a40ad693688039ddd2bfafbffcb23a98088c609f96af1b1ced2fcb9f065468d909aba3ddf062bd49a0d32ca9c90ea99a9274343b391c9981d5ead1518bcddfed0af9acaef3048932ab7fd5ea0bd15ffe56a867b59b15c77f0b6ec4585b46c8261a92ada0a3c61cf99402a1fc3cf92857d5198eaab13002ccd4e54286e6d7f148a190c765f40a368613a29c8fbffab74ed7d2ece8034c7644cede15b3416c08c4617862acbe305859b386864cc0bfd9ccc9b0b519da3f76768e682715e1882cefd29841c544b5317b8ae987a21a3ac0032c1bf8be3950e52b4d0f9dc45bfd63d44896957b73c1a49626b5b893fa5d2fa265edb0f4784f015a81033e67b926908873b5696d374974343300eadbabdf81e85be23ab0a6cf849a126b0755de4935ec2369bed2b84addf25ae1f75b221ca15d761f4d3bd91824dc9e58c871fcf438cdd8eaadf4b9c6d130d2f9edc1fca585579e9e5c9eacdd284d69847ce475a002471118136373aae8b821a60391493755f937c8f8bf873825f3b5d307279844e35964b01540c36cffda3c23ba80f248ce3afad22549468b4ace6ad675d8e325a6d02ab0288524a60da85df6290f0336912e0e074c25a6625b91c5d9d7b12015dd5a3a56a8a931d4e26ad7a172b62e49cc722fa67b359aade2997a3808974c6359b77fe25044dd79ecb14bf486a5218df59d1a10f177f370fc510836c3af962ace5b379b9b5383bd1df11c92940d72c6d349dfdb57e5df86a2adbdb32a69c05f463f35fe077cc22df4ff27affa16f104320d30ef4f8792bbf123adac9d02680a8c916b244600664e2eab497a07118114294f4c9dc8a3ac4178d4226e428daccefa095a79117cffbb30ceb30cdf5c8d79fb1fbd5164ffec4c8993abd3c81a1829b005455a88762179910d2d3a18e040f8cd98632c12c159aa30bbe3d511aa5f6709b32bd31184b2a54a4806f787b1b23457a956e7fd162f95d89731808d2f4be0f8aa9530917765b1bdae55ae5e9a0e5fef746a543903faec5044d3fc5f9224d9ae4aac45365fd47df5cd7ac7b1c7cf397641ff6b504578c10bef65ba45017b8dd68eac8da66467d6d590eba1e30b38ccfbcfbc89574027e317a1bde366a644f096dd448425bc0b303778cd9f4a2e8829bdcaa365d27a1b2ad3c4fa95439575d87a3c1e242d55de1c6067d5eabc8145af14932469e1226400c13e4533dc437cf7d4002cfde192d8e28b2277037d2fd692e152ddca11739c897d4773b99e84da07ebb2727d9258e2d5d184ee9f63c1d73cfb7e1f9400ea8753a57f01c1c71d1dfdefa158a5a65e69a4bf4cb0f2e040cf2aaa8284aa3202422509a504422c046e230018ae6bf23d314ce5cb439ea4373575a91169862e70a343e310f8e6d5ebf56d25f5e9077e430fde0d9bc06b5f40e1792ebc520cc738acf0a66d668e704e2d914e4f65702661360cb88f30728394f64865720fa9772b67b0502814bef7415506005e7431dd24d26c4fd529752467f9c381e114c7a404e7df85bf043ca1028f17dc7f130291878aeda81cf15e70c4f921ab00ac1611d0ac9d34a8f65eae82c76d0a2f6bc1b2365247025b7a40633a2adaf27034c984163819c32c5f9eb269a62e9ced92c4a8339dfbf9a8fac4d17161cae2d9c6863478d1cd18a0bf464e8781668e97be25ed015d2a6b52a4b1340b974e5959137955834e8107ac7229f6f07123c6e79d8415531759aa12b5f432b05940ddc58e16817813a99bb87a16d0bf9d9453a38403f29b7042a83f201e85bef00de1e5406500478e65663b360e454222f8c706230165624276042bb3f14e51fafb884b4a301275cd807552c1d948f64179f31e8c0c01d21f1557b9ad862a805f8f9f6863628de23212cbf8dec10c0abae69ad64992ced0a3c62935a07092f8ded76ea4a0dfc5140feee63983adc77feac214fd1a5dd30dcf357d7d38edd037ac2708c25aef4a325ec6c1f08857e45234a5c0de77256bbe87944c7036b628c0f6b36439d1c6598c22b2dafa780332c13ca664af1ae88d82307cdf205bede63de60ee3e059a4b127ff83d35c4f78601a9788a29b73679fcc37084e053ff66cb9ee6c2888c1792a1a9eda195c4cbe3887e20ec32fac623a9b8cfb851c101100e22f689412c696e59499c8b06513e52e2cc41e6f452eac3e5c2eeea8dfbb9361ff65d8ef576543d344a82724d91786a4cd9ecfff951aa0514de0b00dfadee22eddce1ab8545de170a3b4d01a1dc2569a0cfd088474abc18775f762f6a657c18fe9aa06d8a3813763b5fb029eb00076c5b218a886b2781d8c6e0d9f4f61145fe39573e614c8d7e9ece41b012cba0c51547464c37a7befed5817b4d18487a76c115183d73b3b225e63f86c0c4aa3637a894341270ee079c9f9885dacd253804edbc44e9fa3bd68a57c309ab132f2a6083bee20a7e492dedcf923b9d0d8d8e71ecb31f653c2b68cf5c13deab4814fbe4155698e2174c3916b07de523f562b8ff3f1f9eda1538f934dae27dffeb9c7d055bfe9a69e2ac98263b9c4635e1cf215ec0664b487adcbf31b6b2c4b02c6a0c854e91e5cd1aebfa5710a54ad96303d6d992b7a0a26617295f8dab6743e58a41e2b936c72ad307b9e29b7ba8f110b07df6a385fafd967fa8bce49a636ed3ef887a8999165349b6f96ebf3a1acaa34c7c6b287b5ce11785dfec654640b2ba9f4aaa5a6170024082f754f8ec871bbd6c87dd4e46b3b4ebdc637c116d5d1d78c748c6d63b35ac18d49865c2d20a8e089706bf397bf42f217ebd18374e606b04a6d2d43eecd1c06f6ad74528e853fed7e8b9d87dbed3c4faf6e2e1a3a7c6437a3dbfc3b22cdcd4c145872a96286e3d8839b7bdf53c7b144f25b056f36296db705ebfe2c41aac2d59c22baa5e0b51ca104db26dd77cea1271d1ea51c25fbbfb3e001bd7a6e059b0d5765dd2bafc5383e45fd45e4046ad9f4be2342a3f18d1a6226e2259185ffbe18d00b56b955d4b9ef4eacf222f0f7889038148dc89644329a467e2f848dd6de968362ca605e36e53f58d2521610e8c851dc9c3a324ec3a5b15faaedb23369758d0f12e8336bd9da111b4f7e7807f727bbf340961bad7ac5acefb1fc81f44491829191ddc5a4f34644a46784f66f00dbf4b57d98726dfa3c1f8a9c43e37205d16336e26cab89f3d32639c488de1cd2e81c283c842b69d6e40805df562499ef2cdfb2e57476093e19b27a64f71e7ecc61c250693dd67364ed65c2879f64e48bf99aab566c5ef45584dd5a18dcf9b67b945385ceb25b9ff088a01df20d41724bf5b35393ecb3479fad7f7376ba1dbcd40e90606ce5f5a35a9cde6fa786632210e6054a3ac55205942f62069933f6c6950adda6d4c4a6623d86dce87fd259b19fd20e902414914d10f3900408bc49ecbd1e44b8d2769bee26a618a13b6e3c98a0bafd2ff9324ad82b507964746264b1a91883b2b5a524f3c6fd745ed53444e089b590086522154b9a635a16d6acae767a93ba55b129cdd34a97b8905c2f5709c48e12efa200578048d505f465f24b658e28d23cde23270916ab05ffebcde594f7b545638b72d7ee2701b477dade8a49e37d4b421cc69e2bbda60da08c2a67e19808912ccbb7078e0cb7a7b1bed7a77efa33e713f547ed04859892ee933b9b45f2815c8a92e77cc01fbf923622ae0015767549a51272766f5d723853fcc96afe955144d0ffd3489215a3c56586ad34d7aa3402278a18abe6fee3852c4c42945b2536dbdeace84d75b873f7a71f4b353beab8f571f2b837280f6626215e804e9e8344da4af851c64a849a1968457265225117cdca156ace78b1f5fa1532647dc4d1d34b8edeac3763ca39ed46f25fd321393710c956a06ef8f14d64d674e2976fed4f7b585e98919fa26f78c6c5bb2263c592ecce332a45596dbffd94b140c5b9feafa42ed1d437a93461d2c417599bafd1f657e58b6076996403f4e949e9605e3618157db0f30e19deca3c36769ae202c36ade5e4e6ff76794759b21f2e7a8ee60ab4fe73e8f1cd10af4f2d5a5eaf3eeb808fd1ab8e5b1c024bf724f55832a6d7d3306cbdd53822998c33ff2741a7a2b51db9bb373516e62b9e2b12ff8fea714724fa9da6c35deae1efe416963cc556d037510bff39f49dc4e6ee311c598ffcc626d1e12c0ab20c07ea61c558e28f64e1a028b4ffe0b01ef18b275cb34a864e99bb2e2c89cff3c324f429af1b2b1dd7ed7961521ac4de31653e05d96b92cedf99b59067b51641ffdf28c79eede0bf7a53c275889a3f90c4dd8cc3d913209648de262e2c189d94a8a19bafc83e4ba5bece1a015000b45f65354cda00a3f8911ec1813aa10b9a9077a6ea2dffb8af7223bf9e405a6053c861767d3b8f65b49b51bae9739a12bf108a7d596c032266e780ea58e770477f819c39ea67a0c77ec4dd0decfcbf465256f3de79ea2b7f5d235a5c19268e85b368b438b48dc0138421733fb3716e897b7b49a3712c6460899a3c67eab5515cf662ddda5b5baad60f711bd1de233dcb81c15edd8c6d81aa7d80931033f720b26eab0d7f6e1655a53005f6dc01d8b39d778b51c88057ee17516767f6a06ee764e5bd8ac6c159f4af3f63f71316fa8bcb040825e4fe5456bfffc653fd40a053989654a2eb211f331aeaaffd34724b0c277b2492f7cb900ac79a3e48245b36c6051eba49767d87e140f34e8068e3cd65ab22b3682147575731a7a11b473bf8513df892037965e241312fed99396ec74eb06be2069b9715d6889f8c505399523c2b7eb9577d7cbc0f662c2f21b3ae821b3e74b104924cd64fff1f1f0faad08c52aff141754e0c6be09783bbdb323b19dc87418384d3721847d051e5f5b1d7039893cbbf3df34720cc994779c08ee9b7c2261638c9d2d10d3f0ba00d1722061bc2780403ce46d4b6ff966e646b72de2591b23095b702201d20033798a12cd327a9ff1b50bd229d78296ea2ec84c1862e6049ddde4d168912c1c2daba7cb48acf50724b1a306ad7fbbc67bdab7e51d2d1df25390d6b884ac48d2575474f0b90e1680700025f758ae760f858c4713c6bf9743a1ace8c925cc61da36059824d7275808340e918ecb31383ef329e019155bee98e8be7015b0a9c984057b4438c0baf5f8bc60ef81a1ec7eda5cc6c3da2ac71410fd0ca2dc39cd9e8dd81f488ef3007cd9bc656a95deda38eecd21f632067f12acb9c0fdbc415e7cd3a0a2a5528523f925d77515c62a208b66911c70578a66118460f581ac0fdb564edf6b0edb0931076b5e19377f6c7c5160c552ccdf1565e405633823ebc0a0b8b3dd0e13ffad6035b70f3319f0a0a85b76eb629d5ee5b312424cec27eee68165aecf8489ed7f1aa595ffecb4e2aa79185282f68ab88fbd37cbea47fa1f70a9888554fe902052403c975ca1f59b0c7f9cb7548096dd109976a47c920318891d35065687669ff46c6e2a8361cefd1ea725a50e30521af3a37838bd5d797bc78a727305874baddf1173523dfb4e07c9678597876f4f3c9e65a3353452d23e6f13968e735b53a1ece52bd1ea05548dec28e87f708b6176f4a0aeebc8711b6239e3830e9d304f96a27a1b619d73b8a413bcd36880164ac4ec41b33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
