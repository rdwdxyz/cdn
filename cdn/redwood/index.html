<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c3d897b1c290a1732f852640509edc775ff0167d69e8a3eea3d01efc1a71a9a7800b9f08d70f5dca9607f38ae4db90df789ab6fd5fae2ecccfb38809002bc2dcfdebdf8220628b8d69818fad0f1f808044b58c64a24ae2888383bf2c98c107f9f5133294f98882fc1bad087a020605233f8075569603b020e44fabbe601bcd1a43f5b8e4fde83eb8581107bb63a43eaeba4614447dfd0bea14d4c2097c5fc9a9388ef107f0e61e487b9b3ce53588ba245d85bfdd26d1977efad9e3d5d4c900ab86d2b77c6b9681d1d81de6600fa3efae991a11b3bbcdab66b2e10edbeaee45fa5d214ca88db705469a5f789ee5b7f574393c324f67a565b9285c34aba0d3202d308b0c13b6051142940a54d7277138d82595f249b08e15738b0834b4861c620aebaefa342ea5585868197f7c9f21439f43f42f874f44c57a3a542afa407aee7fb66c1bae608e8bc0e3ed24a7e9812296d65a75d693699dd7eed14b46d135352cb6ea4c74db9b8d78f05b4bdfc7db9e662ccd9dfd7c15160b7f49eca9ab2c3c19857b270a0fbb2482103d8860b9888f659711459602757bc804b7239a7adbaacb34d495db3ab1f9535aa15014f9bba2fa336c81b6c122fa0e1685093e9b2149fbf94326cd3935df95f8447823b88303f7153d527c8bde0c48cf928ce91ac14db80412a795309106a29cea2195c7ea332ae14d39690a1ad6c196bd74db2015c2db387677fb9aba578b254064c06017ea5578f41def153f61cfcad691029143ba1b20eae85b5230f14dc584aa87aa1409284ee44112050c44c1444480f6eda9796dd880b26e40feb77a8154b1310c6a89135a33bfd3ab1675992bcd21d067c770f587113c103a0d1e5d52c13344163fa46a829d11c91fc6e3125ed3848d8974bed5a168fd7266ac09601725b4e3d4f0e6104d2d6febf4676211f0b5380e117bcde0401b2d95025e52d7caa28bf838ef3c36437f3796903bdfd4285a4412fd0cc3e0d854e401205d53a4582bf145cbbbb7608c6dd0a6d07d2d885a8801dce8077df088e0965d531b07d6ccc725c1f41fba8262668301799b84c9a5e01e8d77198fceb17200802b8549d748a62cd10e90f5582e524b1acab06f0f7639bc59b235e1d04079f1d0e3a60e5d7e3e9c5855d97d3c78d8747ddb71067e25cb74e8af30fa5a3f6142bb0d8780b0f6edae1defbb904ea073c27ebb91286f1736434bc950836a9cf97593ed7575f7aa6aa4d34b68cbc9148a34dbc8f30d099643ce9813a5817284625ebf5b2bdf342a7feac1058186a04c17d2764aadc90bae6be7e8860910516189158b9f411d9d0549ebfd5db0aab3b0e8ed0a435d6ceeb0a221049e2a2060998c316d1607c74278cfef08e60895b92ad0e954165e9af4d518f3b7e23f889de733e79fee5db40d0ece378a10501a4e842de78cd60cbd50956e72cc65cfc772677bec88d251c97c330b3c5432a6a0072e71238b5142dc68340675c06a7f58de47b0ca8509a119db550cd52ab9160ff30b29ab310648c2fd2f051a8aafbdc4855088a28c563d2e4776759e8102be6232d1dd7d71e04268f95f192bbe1849a814d02f4ad866a827adf1c8471a9fce8042052b3205dd2189a2e3737d866ad887c2d0865f9553acd867876051b3ad2517ebb5f1d33677e9ab9a1758f0104dac2879530fba3d7847c998cdef8e32ca8949fd1a4768f35920725b42299de5580e285244a354f08ad6f11b821e3f23e3fbfd422aa4342b5a1271faca41ba6b9a62f58a422c4769781f0dc83c810882af41c661acb32e2356b9c27a13872a259adbad129eb5fbf4c97be6673b418db6ce40303eca561a3881259aefc0bbb2d94cb2956b18a301042721061d6d82bf09e044ed9f2ad45f353b2b0e64757463534b92c392903dc4b808e542a8d5890bfdf38b5cc0afd5928848c7b26e93c7f42ab185776b86ecbd176c701373d2654665ebce2e250b91349a83a5a43ca3aa6dfb36f715f61627deeb6e1222fae561682bd8f8c8b7d35e3ebf5dc233ea30ef369cc0de3f067acc6ba95c6f1d7d2810c67d14111d3c095cb731ed0930d7faa0717e9954440e33af88048e21a468be58fa1f6301a4a8a6b65f81084bb952d6c6aa3ea74e2b2483e9a3b649297d582a66f9c8278db571b75c1258d5066f4573c28bc7f446b013d505fecfe11e1a1886374757240dde09c1c0369e191ce5d5dc6555ce148bb4d2c569ada88635688267134f9ba7a2afee66ebbed3c0a1c58b2b5428e528b283e5ed88253af81808d87568b87354ad7d81f7d658559f4ac8fa1971551e1003392e784fcdf46c33c40b924a4367c00ed309c075c4d95c63277084590fa735b6d27fbbc2a6cc148016ffee8e077905add22c6c507a5294073247671ff443b35b793b2325bc3fb6c7bce27950c9841e3a7bc14574dbd9c7e1d3eb0d929f7880734d774d30ba7bccbfeb6378298e3a1ed3e52665c34687c982e19c92fa2256ed0808d958c52c4244f765b7a416d3a4b076eaec5b025aa33b7402e2f1a5fc8d14fe5e3ccec2da17d5c3d9bef876942aed36e8bb4297ab2a7d2fd83fc1eb190bd80416fc3156a7cee27b2efbf8db56ca024bd1ab7a8209be06665f479b83e5a20e0afafbb48bea0245170b023783990f73eceb91d138661793a7fa24c259d71aa5cbe5e78322f09b155028e5756bfefba49ec12a5113086df11a46654f5cbeddb209bf30de7eac69a70ae7d6dc971e48601ac6c1b0dfe810f4afb7dc646febf4f4eacfbcc99300ecb363281f74c0a1637e74e08cb98317bca9cd3b0dd44c6c0b81663dfcf23643e0cb51ea95e9abfc155af1784124de6686483b1e443828c37e5b342c7224e7a9f827b17fea078eb60e424325df4895fcde6cc1cb510a1872c84103e646a3840858c6625c55887a899da8bf8f3db672955559c032d9ff80a01ee7683266717f26dd398b4af177763489a89290dd24ee9d8b3e7442fdeecd4be8db73888fcd92097e853ed968fd6459de7e049c8ac774fad2b93dec8add24c9b4ae628b338346a677e8bffe6d62cbed0a32ce3776712481cd671946f1ac9a650eb75dd75d19e9ba77c62c46ce6b60bb35b2dd222c9123c5abd6a57ad96cb00e4a6cecef8c03f5ed4af5b04512fbc4b1f3a30e54c1d2cecbe3619ac68337cf41beaa1e3de0519850b9add7115371cc528d2f9189a0db549b0fae6727e5d92bef3f985bffe3094f45528d3b6b66455a24022fb548a9db02e03a1c2470061a748093707c020d68a159dc3325eba8e6ab1582eb5943df4aa45a24cf75faaba5d3ee22f8dc82b2f7165f4dd45261bbc62b58d067fa3326649d8a21ecfa4ba7291858d93c602fbd899c568327bd5a20af497071ef1b68cfc7c67d144ddab9af81ccfaf37c2dafeb8f23ee4ad947f80161ef7428176b2fdad4e247e36f0f41ee3f81d273f0af07c6129742a76ada67d26f40b86fe5cc20635c2e670a7180b66bb3f1ff2094dec623ca5686d7111be4488da101a561254d3fccc9d7446e5b5cfaf66408ae7f1323664dc819c7c6e2db000ffc7b72154be07912260de4e02335b4230477153cd6b8b6e4ceaa037d12c1571e45769feb48ece1bb011a834bdae742f6c1dce1e79d738e0a5fb2e742009966c9618fcc61ada37b193101e276f0f06d056c2bc98da12087a69386a99647690dcca99d1c3dfd3b3a26a1a79a5d0a204781bc7ea3d7fa9705284b0121c9e7249054b0a3ff2a2af44debb314d6f20a950e5331af2f2c9ccc3aa43fc92b03eea4dab1d793c5d9dd7465273e17b7a35de41a64c54f4f07e55b40b3e32e60991fdf6c9617995409341f39678c8f19b31a43f82b1b4f52227a52f8a0803f12077ae8113af3f9de7087ff42217be4105bc05415e7181a5aa3f4844788730395da3dc6dc60337835f9a3135dc46603db751f8707fd60854bddfa713737c3590cc6035cc461bb87b2d405cdbe27071c8869e54d8d35687919913fcafa2a0a6ab9556f9a0845ef83be0050596c98f9bbb614f5155c18567e565b5728a6303265a08349a2de3acbd9deaae82b4e9dd0d0743a30318910ad98573a44b65c86d4d4d4c20cc3bd19b3d75b8862f411b8d4d72329c63097e0c62074999dca666bf72f72b93d433f6ba7475942f401a7f8da7a4ecc7f9da4a40033880c3b5d2bb4c4a4d890eccb813bcf4d0179dc0e8f0bc453a136d9224497c3e6149b83081d9b064469cda7edf9e6c6a0aa2b44c977c75ab9bc74ed11c2639968d2bd6854f71bb269c58e7b6b6f942cdd1919d1a26a86534c8d9be798a8dae0a6526cab49306a604decbe85830563999b8a2bf2d0c75e4ea9195bbc7a1f85f37223315158fb806a183cd4c1ab42a25293d9c2a26080ad8cedd596fd7c492a812b19238c7d1d7164ae7c7662885a108724fa9238d96061d32af25079c55ace1153c5485da83ff518ed62f24835f43ee57167c56e479c99a0704b91fa35d301149bce8a21b4036899b2e68aec8e0c58e45ee9cc3ac1f5ca2c1628d5b4cf2fd58e367f90dc6c1c49d1894ae88bb61001c5d784e51f90b84d022d07ef4d1f077c7cf099774785f9f1caad2bc0ea37247af136b7b10850692384ef6ff809d3857f841f5c620e676498f8bdf2958823740b48c501e3b51ac9a176757230df7cc62202cf3bb2e87671ff9090868f394319f2b3ff5b497e3bf166c2c554e0a19bb5417cade247fe31d2c4563e70e2098157df28cf9dc3d8efb97a8c1bb34a73a789cdb144862dd74c00d5a896b21a41488bb2317f10c338816b768e517814f01f87af6de96eff97c2dd039c5eff24888f155f7ad45131fe371cd868efb837252f75f0c45538ee387b9d49a2df9b1a22fc1a9e69437e948ae4d022c8a5f022a4e0c3e4e2bf0d1a873df7f7a23c6ca3eadfc7c09e459e21ae7d1cca4b1670679ea599f85c439ea8af268b8a326d5d823ceb5dba0087471d951780578d75d79cc9d1105ac88bee34c428cd76f7767e26308e9a864677f8bf4c0743b766189a9244c0ce50027ff738ec9178578eba1bc97f0b5fed3710c84c21a91a7fca316eb2e2f068821b12a137f64842670c95719a38c78de3b719da7a58274a6e5a15cf1a650da1a0b1ebe5a0bc97542ba86f4d98ed413506d2ad0b864e3df7c1597701deb62673ba000de8e1b2285012f0307b5f8ab2d6330debbf21d2c4e773ba74823d1dc87f7e563931b1c39d646846eaee2b350511c3cd09de2650d915b69602ba900c783c0da6404116fcf9e03914df5ee61786a6ab8d171889ca5c940c769468ccb34920300e44020f09e8680b4af92b995658c6fd1eb1bac92bd644ca8687e847022d585813b76085c4f631b60c4648fca2205c884f4bead296d2bb91eef1b7d031edc925c180283f92104a7d860aa8bec777bf88c456027cdc280f52f8e3fac20679c463d637b57d3b54d51ee019f7bef823700b5fefe1c1610c54c718045ef2d0a92feb19f93efd8922e1ff07e807af0ebc39f14e2f138cd28d3b84b1a4e3160805e380f2a3081c8fa62bc1a649962837f15601943841e1a692748ba2d4a88e8bc046511ae23c61bf48e0f3e500e3eab4bfea0da3542b32de8d97e3d72aabc775c6255930107b5479219b422df02cf23652b04372db48341dc6f14016da831f000b078bbb1dba630ef66ea2283fad08121b84e3f114fceec88ebe9141f328787facb3c3d1bb5336260005b14f3594319aa7dd9813e1275cc5e1bf9871335e56714f7382b154dba94b6921b82d26aeedee730131e488a82103f994903d76b7b9d129c975b42a9cd2d791a11918531a408698948065c0d8d1e99205049638baa28e235d01986ff48d75ea7a9fc78f57be404ce35028832040325c095406977ef02242cf9b66698f357a500522e078dacfbcf12ccfdfdaa00881bac29357e302db2b1d327a677502b5c287ace399359547d16d6e1951fb447de21661b3e59887049fdf8fcfb8c74be606816e6c63a799e0d6487ccb17014422c55983bbb9a1da0dc6d84ee7211e2b06782a3166c3e95c042f4515982c3e58401ec449bc3967add7e6f06bce96b13df1b65840d54bdbc6452bb6280eae80e72e498b6caa73264785ed6e552dade7653ae9e0b081dbb921ca2ceca032f2d89e77d65867bd8d5cc335d4cea5f35b646ce4ba7855efb45c325e333a3514f92f91da55196777fa6b69c3fb8524bcd56201cd3e9e94e266b3ab19e1d51a53a8a9761343c28900a5ede1d3ce99f9a1e241e9c2e0497d5b01fbcec271bf9c28164f5bcb2941fec5a47698b727c1853414fe13ded6eedf5858897fd814c5b95cb99dd6fc78b408aee9619781098cc49d09aee55d1cc9a96d56e3ed124aa7e24b0bfd92a3389e87c4e04de6054a4ada0fc61039d0b8a23708a607437f89b396dd270a4450be201f3a683521631803953738ed112df77c409055bb7f349871aa1ea41d049a30bf8ec27908696a9ed7d11b745225a736d3b6de14f928fc07cbd629a43ceb6d3994e55d2d19dcbff14453ad455437e04fc352a0b48e9f47013caf26aea6f4fc5066cb2ec490f257bcff60aec645ff207580136644f92babcf666a2cf5fd859698a4e4c2562c59ffb56e8f2e82b94044e406f0360b8e689f2af753c2050e28e83d5193aa01fa41a9d050f6e648b1c4ee871cbc34446fcf673db2e890a9d060c1abec9487e6727bce681656c9c425720db678c9e69b8f4509622a7a2b36828bbc0ce77f74dbb87f8e9026e5ac1e66662caac5307dbc6e62db330ba77c578d56661a3a2ed276a6a500478cae75855b967cc5d9ca87064236349789892fb0971fd55398cb8624ee208afc1ffb2fe3bd53d56635d90b0e99ff2d1f9f9fee0f6a9151af4545769e3ad7cbe8448d3cf3a9af134ab71663aa01e545751981d6ad8bc1a919c7db53dc72c476cabc4d317a958283f5415650fc6fa45381013743f635b90d8325e1fd8b0c114214d2845f1023f05303bc0c03635a93d3848ee70a061c622ff20568d2d12128f451f150bbcf98a488af4a2f93d92dddbfd204ef9323c8954fe8ddc51fe31c2ca2f979d648fc033bf45b049bd1653286f42f85527bd4b20734ec2fc21fd16b4ce8ada29ec216015a482fb7c6860e436f41045f502b4661147eebcf31281f0c4f31c2f7c373aa6474f24aa0141bfda8730431abf5450eac030b8e1662da5fe60b89dab69476771b5fcb660004ee04b9ca27c5972396a896c2e03feac98597594cc266b537dad618e6efe27304dec998e802c48fc80310a0506e688d1f798d8feed3c3617f4b5b93edf1e0b0075ef0e875b3986e9b72119c3f811cb65cd8ab3a7744a82289f8323450abe30106a92eac3161959f824887d1c9f828c8961a34df5f80f8cd336bdd58b434902281fda63ea970ea097cddc37f6ce9e6a56be0da46d6364df767456b222e1d7d8991d3f4b2fb6e9d8f4c89af5a721d9a43eb9400b1be206d18f80bc1602256b018b1263559a28c60f08793e01873ff6ff708d95ca8e6035ea002a935e83f0ea46e74cfb6ce90620b3e8561990b3b91c5b4dbcc20ddb7b63b50474e06131b42dfda9af0db8b8feecf4db5c495568308577cc737ee78adae6da8e8d1344eb74509dc1a17f04f3e217494d8b7de412850eea0c25c449aec3f658ab830674dd6b2345a9b7f386bb8ca95e584ef1087eaf9308a6c015e374ff507751bb95c794f043faca76b5a4893602b40258e2b42115e4454f42b318a4193d12a6589a320df0c901f12290be83f992dbc791fddb78ea52306e5e14746c70e916b8f3bf0fb2e6aea82862f085ccfa0d2aea3f5b689d47032cdb235a4ccc1eb3d83a81b368a92d488654ef40cc3f981494f0b75d9e051f6651ce40c329c120c95d908d54d6360d39cb12a3f7654973af417b715af02d7ea424d61d922def222093694df52782bc0b63de9f773fc30ae6a733b169e6ce3afa32414ac7dd94b001061959672ae14faed0cceb0dca9b49055c84efbba9c757a2ff430fc92f36f12a0b146802cb37fc2d2ee071c8927c8b7dc2d8398582b975b3b89a9e9ef7326cf78a2e6a59056fa5d38f3e41e5b4542f1b7b6eba817a49d5c731ac5b7ece4e7d65465eec32f903273bb5c875b79fde3b5c0c786f06bbb8362d92d344c89343c4f38d85c6b137b321f04f68c39d9992c71e50c98ae269eb0448c6b7cefc43932cd9a7be903c761d3dc69585dca6482087a7c5e1c4e057d860b20f5c9b5ff6e930496b7a9df9b38ad1049c7109ddbf0b267d2af79ecd294dc8139f536dd311a1eb44155651cb593507a8e719da03caf416e313e8af39b8e1203175822aef09b56ee6622ce5515769f3052a9f666287eaf1da36d027401769ba995f65454669bb40693ed9ce5839fb558352baf1c69abc55d50a534f9d3c13b17024dbcec9548feb1db503863889f4abb4b6edf9ad5efd110d54ca76fbe1c31cafc09939756668babcaa82893a89ff211f249316712ed11b728d04644043baca3f255773b05d73f50c441058d4a78aa8fb1ca9bc8da76ecc034403e9e287033e136a0078d55277a96c7db693e6837ddd8403751ee7a612ef34e8178188640be8ba0f106df3e4c1c9f996ec233ec7b5028556ce1aa5e6cdbf166b3dd55e36b4a9f4efc1a173d0a79500fab4e07f317f43684eb9835be6f52ff169b761bf08381a84a464269a1132e8011cfbad4b4e73036de30d9172d7a5a09956b2c01056db4bd325cb14f2f729ba69e069ee1e61e4f435d0fda5935b748c713bd2a5bfb8f16cc94fc2825fff361aa4336b3c24ea412e868904bcfa4632e7acb289c1105715e2de76a3d34783faa75a7ca606cf0f12b13c9a54551162a972f8f221a785755f5b76d88a95884e06cdbd709ac5aa4070ab6dd59f0a2ecf89236c36a7b1460f7362b5db22e7d3294d5d883cb0b929ef47d6c4cddf25a813f6f2593cc4e4722bb93949a58c948196fe212342a7dbc6710abe42f1afe0610b34a496cd1b29e526869bf2cf23d285eb5ff239220adc6f41857e0ce4857fe35f95ffb4a8f4b88c5d6d97eab528dc807045e8b92b3cfd7dd2e5dcd407d3c6eba2bca1787bb49f93fc630086182c8f2bd9b17e01d149a1879fada6d2203186cf49116c23c0e079cda7e2f1d3a3494934cf141e9ec79749e67810046f4bcee4c92e7bc959e2ade1db819c733fb15d908541a31059dff924a9c8580bf38d279b8559c305d7c781fcbf7a554daa1f0ddd076a7b539a03208cbb428afd9bf893cf34a9d62374c7d3ddfd18026a498ba3a34368368d27816a0f4727bf72d025c21d66884cee280272f5f418642011629320eaf04a92bff762cc2fa1ac7c9ce984797dfdd546c4dc80c2c54b0f84bd63a7d3dabf0839ee23308f816dbfa9e2c9a8470d2f263005c7d5c93158528e9a934c2d0fb755fd2e7c9bbce7e062253255c788ec86eb3a2c674731b6507ffa1c6c5e83ecc41fe8672fb0201ee179dddd11f47d6351d0238335f800f777a49000eeb9e517d90ef2b5373370ca5a9e35149d87782619308d2d30cede7ae4897c002a3cc3283d44dd60e52ebdfcd15ad2e98b6d92f84bb35951ae926415aae7cba254ae13de6212af50d9031ac806d577f4fe415e1e62745f518894875ad4d733900218ff2115f08021894a56b8e97cd1bff1e17518ea40f84364d73b9741cdbad848edf65957f91407668621888e977da8dd8d26c827b6f7c4aae0285de12c72314956a236eb9b8fa22d9d6299562abba77b6f5ac0bc9df2b7b35e076c2f5546b7b8f23e8217ebfc03c719fb07a3d77fb292c1c88456a12b8a917377a26a602f73b2486ee2ac8389fd5079fba9f0f0902580fb53a99b7860545e2c227b778e6cbc6bbfb309d6a415e057709d827c30e06e8b18e9eb4400e30919eb06be04e7504bf99c0176b0b83994176a41b400efdd8d1ac4dd8bb54963b1cedcbbab9808423bd17528f4e5c74de4c4914c5b773079bd4c9315d491922b99975e31dafc6a87e16db2c2c194e1ea4cd3cce9dab9444dfd5e5879a6ba4c94872256eefce8d1d4d3b7dab8d90d112f89d59fb3359cea67fa6ecc599acd3e8fb7dd3d33b4a101fd129234f0501db25e9e066ccbd1f24e3b4ee3054b83d47b2ca3d61ad7fa335b6aa4fec1e8b364033b4550131f39da4a21fce59924555779c903205725174c7c56f94e05ec8d9f107836814a77ae2cb52e5bb0f260382aec9b0aa6140ada4b7a6310d9e34243388325ba0c2f6fa4c295139cf186b89ae8946e84416f61d07e91133ae45fc4f2669eeb49ed16960d02a2aef60c80c7c3238dc90a4265bfb85c6ea0e5eea35743182642441c44d1cd83e5b748fd91664343d12d34beb7f9f24a5fe0e388170f1a47811e809c5dec9a50b905938ff2d812ebcfccff49bf1e8b51aa671e5ba25f7bafa6a553974614716742fa4d46a260260ac5f190535d2f2e5e198d2cec6cfa567bd759be57f680f8fce2e49df9b69536ce0f505729e66526e1e2329ee5c8f3e3f5403f19957f92b7a4d3d0d2a6766525e98b158ee5ea2694745b882e226747fac798db2123ec1d433303e15071572ca234060f37fefc642054c5a5530ed4bfe777590d4768f62311534b12201e137c96815fe6e134aa6c8d83e6c710755d500d99abaf0424b2de8331c83454712bca2d0e86202c821cd81a97bdb4fee2e112ea03d41187e40237d0a19895eac86b274e913183525750ed3ceed76488dd9389eb36488475779bae4658b4e4a2c97e319ae15eebff2d92a611c575e73dac7e98330a063435dc59dd0a7f853ac33bc5fc2f661752c3e3fbb320a0f59a1a957640e490b478a4c35a41ec47491774d9efbe680301f44baee91805e7739cdf41c14a7a5b4fcd4b9e23f5e2ae81435293e0a0f4f93365a811d251c9940b4b46036af5a4729be752a252bfd3cebd02b8333877f945d01f4b5d8b1011fb0f83b0acb4ff78b387e8eeaca8b6b3ee01b7a1a5730c16abc9ec769b934ccff7af18f23dde4065968cb6254d41b3e363f403ab59b756fe7c7b6d763b140394e8a980625a395a2b19ffa5f93ce1afe62fd5c509734aa4c97209451f23ab76078dcbd90279951eed114251a2835761d701ee2078b47e58b2854ddda5429aadc3c165842c0e41119a56bb6730dbf62a6915d71fa0ac5f7b8e5cd558398bb23b45226e8733ce341a626c666e289c389470335ab659bf422043be5032443218d7360ef27423388cd6b2315f189218484736ea2fe16352644a978bf86b83c38bc61d5fc49262afd45a84e20b232a2ebeac5e3d1d021754a7a3ae8b4db5588a94dc2c0281431889785a5603d49222ff679c7d0983fff7668b4792bc47b8b67870f7e3ad9d61b73869e413b342bb822e8afac9ef6b231971226c958c2cc74fb9ff1a821a33c62d8748e5e7c8de9eca3b0ceeea0025200e9b891a8c084fac883d0687c08ad87e9c4eff57840b31ba1d560810a5bb567546f0121c9ad5e44d52bfe958182a0d6295370751ac892eed8199de59ab5019d1a218074e048bc1e6f2e516921f60c9273982089ab13e6a2fba3ae6bfc8b76163141c0f353dedd2ab810646887fb79b8962f9d8ecfe7b9d0fdd4b109564c3a5ecfb9047b30d0325bdce6bec120135a22a3dfb86faf47efea07aa62a61a2e696a9ccedfaa7be0f68c9e778d8d8918d69d0ba05d54b9c06c2dd0d3a49b1acb3051a160e9a74646279d51a6358c25c3455bd79bef01f72f00b8dd2f508e64a420396306a00a5f20552af33c3a133e2c3e314e3abfb628ea86a128c65fe398f1d6fd36497df31b8fae196d6f01e6a7629a5da04096c270f3158d2ec0336ef16e278a7d8e484397bb67f267930ee42f7e77c9dbac5c88d2db1108988f9e947ad704927a3c4b175f3be00494aac693ef5e3ea2cb0a44c4f64ee093791e74a694b9bbc26bc1944c57c74935825935d8a3277bd232dbad44f6fd2cd0e36dacbb513c2a96dbdfb8657bcddd9c9808ab5b4d8a4e7e9faf2c11453829b125396216e547249e6689c0fe844d6c4bc9f05035f708f9b1cc6526b5e24702235e4b5f8ac7f92dfaec7dfc52764a61221489cf6f963e73c8f50e84399ee73eb4e09496de84e2daa538b479bdcca20eadf8aeb5a2cffcf2c3bc58ce6db5166e662f0e299326f9500eb9496d2ec2692def1d0796b00c365a8cf1c84d5e78a3ed75573b0d0651a0c84e074d63472d860eb30e4321733d5cd2c1cc9508f2112618c5ef644a04b88ca73d066dcd57ab16109701ac2cbed857023d82c68e382a0f51ff0856a7ddb34fbd829abaa6e6e9a2af0f7afdfbb0f62d8fe9eef64619319e7bcd27470f29af182d0ac3ae5aef66a7de297c01f92faa2a1cf1be3f385c78d3b29ba3192911cc23252544c14b78c85584926767d908cf722b1d2eb1c081a0674af4c02f8f0b7ab0002350a009ed9a2024a5df9c06991569f6cdd77d53a739dbf33c923efec1db1e6cb267e019cb310dedc9edae6546f263443ea126b894e72cb6aaee959c4ccd3bf4b2200a4e0f762be86922789afe05a8705741c7f0008932605a468c75f34aa18e7c15cd653ff2ee251b7c8c1187437d51122cbadedf2133cdf1c1d011794d53cc009dd81fa05ef41ba6e40c5ed4e2ac546e5b4908f3a7b2b5f8b6af2816d2d8b45593067d3ed9befad3ee62ba203ac4584e6f6a0b402a26109e0192e8b3edfed65afee3e8c0628522d9a6b035caf4b52ebe12ddb42c76bb47d9b107bfe6cedf7aa31bbe4557a806b33018141ec919a0703cec3f98ddcd2d438aeae549204434e24226c493135a0208fb8d11b7eb0c6b9351905bbadf03103798629ecb2d50d56eaf12da01a2a46f6545eb65e3ff88742bf8e1348749cb49070fc2ebbee8543679d57750fedb564cb34166f6c9b256eea4621d21518377f7dca6f850281f2c349744903bdf2c65bcda950afe7e454e0ba1e7630893edae37399198d1dc90cfa83361493c38c0988c6aa9eb4b8960b444b5f17adb237e024ca2612f50f03a3250aa7e260532026ff5905163ede569e39c074c7c3a383ddcfb92d8efda45b801dc35746ff5b6acca5426e9cd3b25d6515528e4294ed585e9995cf29c712cacd955b26eaf9a0fb55815f7c8f57863f210cb2892488b709de8942222249a41967b55302d007799a6d386f84d33716ac05f0938088b34eb40bc8b596f0e814c5ff454b1a0f5769da81b216808ffd47524b76da42829fffe66b6228cb3fc88fb5badf2e616b277ad0f91c086a584f9ea69a197838ac5a87382f887cc766d706c9756805190158472e81cad3369f58d4c85bf84155285bfd6a89004c78efcc13cf0fc80518918c2a0f0af2ad3027839c11e5394fafd9212863f7c95f18f4fe01c6acf7c7c4c594f8d7a8054ef3169f0e63307c719a08a917288a50aed5fa2191e9af4e69545453bc89bdafe45a0792862db847f5b1098e4baa2f6d9128cc67446c5b2558417dabf243b6bfc70e0f753163d08c20abfcf0387d8f637798de6066f6fe4854e830646dfc06941b39b2abbea2463f5618e9ca815c2e916ad999fc86d8f92830e4e5395eeedce77a2eb74895c25bf257ad0a0ab72fc53a66741fe967e3b07f27945b7b50de41834d8f4be300a91524daede5beabf93ec614dc06846edcb24f091486b633b95cf1315a0ea9c352256b3a4e79ee28e6b005f8d49c5f0189056f56a4b87c052f3fb66d4be248eb4be9738155a9fbcd7c9ccdbd9c52821b2d1fdfa93654078dba474b28f2ed73c7082d191503b7e7c35472edeba5c410a19bbf13ff9e8b3be5f19bc971bc25254696936ebd7148c5e7971152311678b661ea1257cea82b16d8aca6ed718994d65b7eae4c7262cce0adf7f2310e048543c3f824801e385a1f4fbc96dd2945ad1cd55f10f7f39e2572bbd49aa481139b43fb04d04fe822fa4c5c0a15c221719fb1c3ac46daae1b1abb7ce1fdc0385c96eda45d1e79483b1d067010133b56d69cafd09c1788a6f553aea2ed4ca71fcbfe284a73ad12345d34960a19c41bf5aeeb5c339ed2eb63e97eee4c531d68822a2d699bee6eb99232e0c2b7c3df3d790832452f1a67144cd162e2b7edd054854a0d11f56468ac6a7c722a61e192bd4bb70d42fb42640fc961fab5fe4341f918cb5b3b47fa6e4d515362b453426a863fee936aee8d7ae1b20a059bb32aff7acfc4b3831f2fd1a0e43771df29d3f5cf3036b8e52e5c91e4f3fe86ccc8f9b9e8eef25888f6b99734552abbae8e44381df35184541d4ce3edcb72d1aaca6bbcd6a3381642d6648f829e32f527cc72ecf38220ade2cc996c140e63f82eb2701553f634289856c4e9dec5399f3c8748f7d89de7a5c060c4ace5ac2016cfcd10c6573da0ad97dfa6698f4db6fa62ea64640a6c84c11c639372ac3e83b96e5f9f401944e9fc0f2c8edd413dc88e32f1972d55b68f59fe0ae466b12d16eb02b194228d6114bf8e07766550b92d31f1fbeeb138b29349f6c0f16224731bfe234ee81d9beafb903da4d6e5b6f233e3d725d76183cd32b25355840d67b47de8cca18ec165b9c33726c24eada854ffd2ea248aed387d663816c85a4c2ef4d55382ef1df1265ee40358917db62e5d33927e3dcc44093a6e70915183735bfbd51bb0556c57f5a486594cd31e8e175f8971bbe72741a5531dd3000528609c7e372a439eb3ff8cedea8cf044ad7643beb96c70f759ec9ec0da84c906e57bdbdddd90c2ab6f787fabc0c4579f523c2de32191fc09083d0d97f1cc64ff13e1667ba919b02efa81d3ff5e58c267e9643d0eb38b599e538f4ba4c1b8a3cdc48a412539f2d5527c157a1b6c7149e32bfd3586b9e531be319b263bbb71c455c76851acbde24dfc7b47676ee695fdcbda8df2bb66da8062f806a08186d05e308cd2a4a8953197ddde5f01891545183ff841f75955a42e6a96305ede0050e5f7bd4a454184c18e4e6ecb30ad7ad1ab9251da3f054240424fa9f60d858f7eb750459566c2d61561c13a32dc1f5cf6ae89d60bb5d3be06c1c572c3f278192d91a39791f1fc7e5c49724c7371da26b1f69f2997ff26c8ed5e340c78bf80d1e7af6d3e2a8d9977e798fd08ad0ec2dc7a3d23af6305faed030e985f42a1552cd18bd16eae481473639edf78797b3e7e7a540677314a550d34fa5b067","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
