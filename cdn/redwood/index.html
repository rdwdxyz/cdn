<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14c3e01ed527d685aee7a8a6417b09dc7efa218534cb52e7087129dcd994996d5d6018ab8e9794f67b40e825453fe7a73596e16bacaafd317363d17420a342b578c209462272dd6badc032cd5966b79b58297ef649ccfa087b6d6cd6260ed7aebf5525fb575bf8e95f2012ad0ed235dd5bd3aacd350d23241c97b4151168c4d20f71667e4d1b3515dd924671137637e537f5afb498295b11addc24f5fcbfa96e96702f2759fab6c497a4b88505aec35a7865e6ad8d5f2daa98d8aa6b2f64ef66b1392568580f6b6ef4c5ff71ea96b894e58523da3220106c211c9befca763f1c39eaf9fd5054dd59cbcb3d4027cbfeb7f4de909d674a69815d00c1c4926d539388979349d81e8c858c2bb931b26ac784c21b682fa26296f0fb9a7c35e5cd3dca2f6e9aedeefb34ddcb8e18761643a5e955f4c3bc5484278a71a8405520d025bbbaf5473d4557595d9de60b46f1a21a7c9aba9760289ff7cf1b8e83d9108b62b458abd613f74ff0e9029bb6ab040882ee39b3f1a591406a1a44c5b1b7111772f62ef344bbfb14f4f60928ffc4683b80365d1256aaf89b53d8445a24d9a2f221aee454fb85c5b8bd8be011f04afbb3e3f68fe64d2fae1ed3102e2ef560286cb46b58ae8474a3424aa0dd1235552a0fdd5dda206b51b60d025b981af4203a8b4c3f13b49f10c36f6dbd9ec3aeaabed6d4d31fdc95a88b0a53f39dd61849bcf8e51e7cf311053e1ebbb0ca797dfd8d3ec05ef679c2b267435b59ca35ce7f8d49a87914fa3f616c71d9043130776302874fedf2ad7420bda1fe31fc67d9d9597b50b20b84fbe6a2c8624096e19294bff12a40727e80fca5783485ede1c4b908aef22dd00f39dcfdaa61b76b1e298e4b82c074774a1798789ab1fd79a4a6da0f8b7c9af78679517ffbd8c2505660be0f55474b3c1a0c362fdf0569ae4b1bfa8758f262b37ac4b78e19e3df00b90e6cad18d5342a7556157d3003989fe62e242bcdf9277292de56c3e8b275d70e8a0f7eb8c5cfd6c95c099189d9d9abc353ce33059037d12cb632d7e863544f49d11de6e6d02dc4788b2afb66be6dcb305fef20e96d52d5bc2901b2dcaf2a68e72515b0b0aad53eb208bc108b8a7c01f2f8dc0db4dc9b7541348013394deaf23daf2d13cb680f5db42fc4398bce3b6681863d9c5974ab95f547f447236f47a4e8e345e0b287f204643e4dbc89287ea1ffeea7ce7cde69621854a40745f3c678f56927d43576a3c069162d58277c81d151b4333c9cb522e3bd2d7b4054c9560ffb8db4f13285ce83fdda5abe04b8be98d8402aeeab4609b18b40eeae10e09e4f42f4bf1dc1e49a236855c1ee3bba782da8f2bd209678927ef4d902deac6e2a6e48d5fe36856b41197698fb0eff1692fc890ab93f9a38fed0db3ad4ac4bdd3faba98ae37ed5ca68e5f64d9cccb4bf3f74fb71c213959c4a9954ca1457f899eaa35fb6a66d9808899b0433cadf2e9a1ec452796f25c8e583fae0895e3d5f67e0678e01fc01daaec6bf2eed027948360139ecbf75d886119d26bd9f2d635128862ee4a7246ffc7f43511d53379e9f8ef657dfca03a8897192adf8987e44f15019f33a51c2fce477c2c285af767fe286dc7c0931ef6c38b10dd411b48bc2984bb003e495cb1748598d3b64f2cdf23111de916c1768f7f49c70a12c0acd2d52634bba964e637b3f13454b352dc459017c85a1cd7bf065df540fc836728e70197a6fe0de20412d1309a5399a05482cac752ec96417df90ffc4c68ffb24a8c8f892cf50de3d2827a9608fa8f01433bc6e95362c9c806f0fe321283e1b36b36786c33cc6a2d24323b31706022872c83fa141f0f2f91fd416ab5013d2d2bfdf23b04cd52d526c3e559bb9cb53450671e1502aac4e873f12945633d84d5c1dc1c872d67df0e57e200b94995534047a4265fba819c1b511a83f2305ec40389737025996d3cae7944d3a9a2e96f33e3485c4967a796d75463288b02edeec53e26834ae98687645e42463be503f71006562c8bb833d1dfa385ec87532906a4efcb2fe9172e570f518a0b049dfbf0b2703afb37cc1bb3e78080f6583a0c2ea182b7cbcdf1b86062250d301550d1ce05a24687477d79e2f0edd6b6c226f366d18cca06d3f17b31ff2b8e67da5d10cfa748ee1586bf7bc51b48cd75097adf96324e65ea5af0d8f266f55096166fea7e44addcfd2966aeefdd968baa50daacfd01c1f74c057f80d8ca3c6068f6436584410fa68b032f36516a7a3bb9b9540a1fbb1e54f3c3ede8d38d0da91b6e3dafce376fbd1b2c990175e8539ff75de8907d22119fb50c56fe0527b2bae3e9b6bdaf526e1757364534261998c393e1968d7bb6d8a538f9299f9b57caed96453fa6c6226486ffbb0c998ef69ecfa28a2a5d80dc36f8ef5e31232aff2ac21840df59884149bafc0b83062891e8754664a5f985191b06a478e833441d342ba2de36410f38458de1682fbba50501535c7038aac9a47a073320bd90e2f9a3374989b993ecbeffdcf551013faedbfece1ddc9453a6d95a3c348ff2cf6771f5f52db902fcf82a40d26cfcfe4b5a3e3aef48e25ad745155a9d11ccb37a86f8e519569fb80cc0d4672a49f7800fd986160e8cd72d10172a89d47e80ce5993f709e2384b6438928413195d96e44342ffd3b12e97e3b9e37a8012aa805578d577c7431a7fb4b48dc5e8d5055b7ca49ed572139a4f703f94557cebc4e31b2c5135fefdc98af7e15b3c4340b8f50ae4449bf58e65b229de77f0206ed5c7adde018b33b887e52fa77d46b1d652081dfe69da3c6c83834e190df4506699e89962b1bbcda0441865069f568316553f4fb492f4194ec578fbb15c8e9e53424cb462d54adabae1a13de7f6210eb8d7b7b73051fe2ac5bb25b4d53fa623d2da12609cd613c8fb704b5089bc7d556f6110557bcd3dc19341a73c8731851322a1da7222dda178b4aac8d7ba5bd415ecc44a875b161c4c0ff65d5aa6ccff31b8c8d751263b0d51ce1032737ba5aa416fbdaa8eba0b5df7ebd61ae3fd9acfb4ff969cde1c3ef3d939436c24b4b6e0c78f71eac13d742a349a3eaaa6e6ac9b710bcd938b8caad20627a34146620a72e6caa18bd1865bd5c4e1bc408d03f0509fa62fa7ecebb4db6ebeb6f01f73de520c86ac8b157a503896244ecac7682ba4f60c9567cc7d8a15932e69e7d3d026e3983eb42e19b2b8bd0b34833b5c0ee4d4604d17ca4a1923b951ec93072618fb659a94f68c4214fa612a55ec779f4401fd19b220635b7b4d788eac811a076a8c534b1c274ca5756e2db5d1ce44c6ff549ec2038b3dcea4e665604629ee71a68ee2fee49cf6f450cdcdbf4c0176a5cabf5a2dc2291b28bdd2a9f3a0a51af488981dd0b16514e3a5f74b057c325f00083940dd1423e15a8595c65c9b02f137b3dec8be48247eefa25bfe95b49cd17474de6dee3b785fd05b3697574c65a6194578b5a35361925b86b370356148657fc2b150856d983c7405d608558cac9e0c808add8efe9ee9df772c92c73d3876ff8e2444fb1de2f1b33fedc905969ecf0a7e15024d15268ba78621d2e5fda8f9979f2bd17a5e6421efc6254f3306cf372f4f3c343cab449d362300b4d6878ebbecb7f949d028fab51cb0a15062f58999e71072200d8ea8a6b671a28b23600f6d058ec005d23d7eb995010f6beca293a5dbe454f013ebfbaff7f2c9794ed0836e1b7effd413cec3c3a789cf88548136ac187b041dc402a8321ceba98ca767a383393a40857396892cfaa6e9ee11f146f9773d4925652f3b417770185834736a0992b078af3caf18842335aeb1443343cefd26484a08ed4ed3fa7da608dbbb92206f7ec318e873dcb847476adc9f325631fb465889faa25c316b5838e9c3d766f8cdda93a739f2df211443e605c23248291c24aa6a14a2c4057233cf3d60ae9c686e4d961ab4bd95a7c5b68ef2d4e6256919223117dfdf1fb523312aee8e60c17bf662b1f9e7fe8e6309f526bfa4e53ed8a3ea4264c35e9fa105d84a96580fbda32f80e754d1f859532b7d22edcbdbe9eac38bef707a605ffa63fb8fe335b5df331680ec0b02a5c26bd44f9aead1063af03da1a77b36254e490535fbb2944cf741011d7180298cf8d11be3683212fb6c4edf0cc635e6c0240bafbc52d11d2bbf6b10c271d2fbe05259d48946fcc0d43f52e7b7d1f0f0b919f61a93ec15cc2f8929cc3565e44ebad0ff338dad92aa58f864e71d3d408bbb56e25456a65113621e2acbb15582608b8921b0bf5077803a2b60450b8eaa75e70f0d0dd8f939150bccc4a4fd01ac8895b3900ca0f2fa8e373f7446a7d3813b3498c66f4114bba5a0e203f42d35d2adf8d8702705fad63db282ccbf86ce307a423311460d6f973f58d707e1b5d0e54e1447def5a054d7ddb31fbbdd7a06e6229731c44fca89ac4a8f9f92405b247a44f96650597d48b7928396ffd14c77c564cdec610e5377ce9421446f0b8236870e1502073229b0bc3819cc6853eefe8d51bc89dec441432007e5d43c89da543681b8e64a13550164f39e9230286fd4bdcbb117403cdef96adea4107e0b523e581ba39eebc45997fe980fe62401f0d50603bbd5ff98c38825c82c56939ac662f4473816d06492ceee0b26b908f7d9d2ccc456a261fcb862e168c7e3a5e8de80f83e7a6a7ae4d8cea4986ea26f7b0b63054b9e80ab7a1a964aba2f9151bcd4d121e8b90390340ff974498c4ee0c263c237660da7447760dc313451fb4f28f9f98af662744e83b5d90123eb1774d2cfa1ff4ad2538afe448d2763842821a6399f70a5a78aa03b2d4a02407fdc5039ff816d5a240b31d2addeba232c29330a507899218759608dacc641610d501a1bd1cacfbd076a52b25438e71965cdfc4194d475158ae85feb0129dbddc1069bb554174f8f8045ce6a9b7a8c1d7366e3e180f6c28c05715dfb7a3e356c1385e655ee28c8146be4fe1306f6f381237b4ff096fa59ece39848b5beaef9d8381b7f7f533a30da0f75e8c64f7f880608642e29383aef8da50c1bd869f52ba4e7522f4699bd8c998c8939366a8a036b56d0c64b5a7cf978bba6da0c8298e41fe152d8798b83a85e07829a01bef81c4a20a6f429a70443b9a7eb6ee7f2affa910fd0c5554c4ba2e8fcaf341200ad0448d9d6c88377c9f7d5e487142022794879933d20c47eac5cad8c70d4f0602baa308a34a38192c73877b3f8f309dde3e89c8a984ee1a38d04fed584a24302507c776df22248d7968731d626c36cfd9c504fd7570cbbc9deb34078f2350e92f4d0980ccba790f2fab3fd7ae9a028f48b1ef6b33aea1a10f035dddcdfe80e3ac5e199005019425f64edc1c11c3545f18a76ec9eb4d6d5fc38d46d8d3cc1de0566555ec615ee37eaba5ed753b5612106a4d69662ba0c8aa7a032422c3627c275129a24c4fd28436a899e40adf75e8c913d2d742c9036cfc988d6147ce3b0b7bee6e6c5159c747cf716912e05aa0035d7fae7e9427ff95b5c27e67a63bc3919e03f4e614ffb6701a82f5aac3a8b64b620e5c709f9f046128de131d3eb40775d166403eb855b043d5e033ccdc620ac9128d34658981550dbdf464ac6be947571f788f0e7a2f45fead91d365e090389d57e33c1a6c0b835df56fb4450624cfd6fc3c219add7b77ec8e0d2b2c390d346f16c4abeeb68ab0b697869582f4134346cf3e260990fbc238bb45f9a000a4a01fb37eff40bec438ecd6b948cf82d48f4bdc131bf5183e79a6d1537ccac0ed3e09fec9aa059f3fcebc624027f54be48841f46f5e3be2fee0d2994d7aa73a81c93cfc1b7687db2b4a6d82b2e7e34247eb42277f25602f763642e96057f7917b813897975698e11a18ff6f3fa7346381016a5e0db1d8c6d78e6d9354b8d9a8c39aa69175ea5497e7b00d8185a982b2d3ae5362b4f88b470d3e93ec472891c369bacb612d0c2b1cd226a3517d09e43329065f2f4b22e23ee947709f631450343b4080ddfca9dd991fb4180dda671db9ef51809114533c241dfb533c06fae00294f0cd7c273b18920c6aac299c4065e3f68ee82f74320fd2f028902108da2cbe9d3edaf4a90865dcebc63bb374139cf694b453292762384ab7ed597032cbf7940d3005ecb7d3c5ed97f511d4fe5d3170d95909d62ac2fd08a942d35e0dc33809fae094386659bc5d1acc8bf3802dd6461c4ec11a69a3adc1a8096c24bf4535f5dfa534789c460dafe12f72da0c7354900237728ce59dd7f058d42fa3b85afe6798332ef4cab6a56c80b257a9de40387210423905ebf59276426fe4f8310e4784f17da3293069515c4a1d7ceaa01b9561b8116ff88c20f8b62fba848f9d45bfe16e213d9eef66e4a13a4ea26acfaab507eb403bfb35c819560b3f1c89a35124dd862ab40662b1b6e9ddef329f0426fc638aa8102ed2a5c02ad3de1ac6d3cc05ece108d0dc4966e1715d59dae4f2db2b6ff281bc3971f710ec3f7b42af6f1c69d1f9c23e8351c2378ee2aec9a9cb85132e2e4aafff3b12ee77b2f56947d5143c279a29204c45e9d376a0ebb72e1a159e654061c00a0ce3c52c816f23ccde7f2a6abf3db2f632798ca3c1152c74bcc03c09b2416ff70484b2bf1c13af24b1fb6139de3c868c47e92b3fe58b5b0c8afcfab7c2fe516aabec734fd8602c2d059c5eaaec8b3d5325e9af82834ed1b0e4ac80f0f9e7c12701550a386de216d85338ba3c047f928370325da32a08ad3adadcee7dc7d4616d280056dbb2be521d85358ebe0c060eecb6038f722478436fcf1dc22a03ed5053fd3fad797bd1764506bdc9e2642a37c5cfb4653275c323219a98682b4b4e8ed693a73de441df9fab50a50db4a5941cf3ccdfed714f50dedbc907129c8dff0c6afd0c466d7357789b62edd6673e3e0b964fdd844c7b4508c9b738c39c7a89d49439817f933d9b80c4ba3aec29a95627e40b412cba5b75b668164028281fae033215c2c16b0558ac53888b3eac7e3cde9cc31344a8df1df72e1e5cace2348989ba56d0ee1324a0109956270cbf272303f44c37f76ddf106f69b6be3ae33a3529792811ad92f58fa4b4e253073f504f8c4c16b4df157796ba62b56d5cf702c9de96aa2a55bd5ac8340528688831e0fc3421eb94a72d0a1ab2f4781ca1e8ccfd3e46a49a1f105b526daa2405c0683291a07ed2e8099474c51034c96a3652457427a4c99c413cad4f9d6e85767accf6198344d63a4cf41cac2d7cf25d54b491765e4c5780a2a33b0c7ce8454551c62f0a1ee2fef374b87806b0ccfa87a4bf5cf3ecdedf60938de53c1490adda3c88d69f799bd655937e604e1391c084f50c2d77322f10e89c577738428abeb5da90f8a2db1a8037b0810bcc9930b94a9737e41fd68d42486ffa47b02a977e82f6830b81d1ffde8b24992a8ca45381f56b95c13d13e22711b0d8c5b4d5180f0fc09f7de8daf710b018a181a624606e28690b41031ecf229ec29fe29b5114afaccba4813c6c9a41cc84a3da6f071d0ae8ad0fbba538a220c7c3e71c2d12e20bfc7b7aceb106c8993d60ee399dc149f48b454063271c451b718900511a7696905d66e2cbaf388a8a2f6b9f2e9f7e63f1e70cd60da4f6cc143261215c6b27fd2d63f5ea2d03512ad4ace15478550bea9c5f2913d8cc9fd359f98f07ddd4debed9e8e217e36f11ab50bb83e0562f8a64a318564b8d28865016b6547aba672622327a0322a7e208e5cf784e944b0b88d0008551513e82eb1389ac1e4d0dea021eb1d3a2f603f6cdb982dafb2bc3a73fe98fc4103d868e17d2f89d0759eb56c8bf420793424448c202dce75e10e8ec422b98c089af2daa1f790729b433c3795d481f2254924e07803fcc79b62f0c10b122988787eb073ba8bed184e34c9c7e01273eb0c8ac1b58ac8a66d695475341369537a6208b948fe91fe9d198c6e14404d2c9e7ff5d514d73aa2785747d35b943a57ec0804f50f7360a4f455b5ff9df498c9ab5bf24e8ff70f06c8ad72e76931d3f19c8f8c65cdafd9c3f3584ab2a6ca45718371dfa26bb7d1b0a2e31e04726492bb2185c4d9211780a07e83f6f7efd3cb7e193d610157489294c0283347b00935eb32cc114f1e6b835d46c1276d7b7a008942cb20392e90dab3516d54267de56a40b804e2f50e13646fc73ed377440dc9c1a63ddba63802784be5b080b86a72f53f6ecbb9c40b1e08dab46e626f6247855c5f8ad0d9fbcb33d7cadb880521b2644a341724f41ce2d7463e2f1544bb0697ca32a4338fd882d2d2e5a226c9f77bafa4ef35007173567ff240595f7179d623cb3c8c153d0a00764e176f84421ad3facd53bb6ca5ffd6c90a6b652d43fb0bacaa1186e98774e72a6bae95572a141e7f3c15b18c71a52fa8b1ef0404681eb9c5b3d42a3fe942c73d2b6cc09c30bcd7ef1844fa46eb23b67ac544f7320e8af42af8b9496faf02b1d4f970745355bcb2e32d828c3c9ba5cfbb8bdc68454ef30069f3c491717e51d49515d39a42e1deba3c0a23919e357f499c441215c43af0ca79e841a1938a66a48a7cd83f87e04ea11a8e4348135defa640901a86cd70d69a60972d08d7e949e80fa71d31fea76c0946b719a6c963412cb3ccaf0677179080c150d71ad5a6b077a68609e0cc7ab3d2c062f66f5d37be8e9a65110ec916cec21feedc4c95937cb40356ce37fec2d0b234916f3eb12ba3faa559a458a64490d40942a5b1b7aca8eb455d9d4ee363058ff76e7904e61cb8ea3909ca20bcb785497689ba6f13275ac3cd72c5abe7cc4f086d2600e27a33b9b9f99b50210254f7042a227671895c74bd63b7fa2e8f971b59bd3bb201fd2c0ca6a9feadf7265c075693b35d497556338e0a5173cfef22fe56228525c6d291df39db18199d342201ef9b2c435790427587e355915ec0c1bf577b7b8c3dbfee01c1beb55885b7a095724c4248f52221f10bca4de0745d963db66a45579a079b3d9c7fb55672bfdeb85d2fe9b5f221e2ad5562cd9df478a17cb5013ad15cbf3f9263aba64114934ca7158e4c4638d3827bbfa14737d1a5d468e4763ff8532e0ca2e043feda96769b3391ee9d1cef0fc5bad2447f9854e92bce6f2d8d2741cb03c7e0bfa549ea683bafa875250fded0af7f43e630a0805c56fedffd4df88b262fce45a282d545d205d21cc0a93d736ec2651e39ee0fd9d446ecd85f7345ba1d81cd31b07adc1f71e42395e47e1fd873dc20a9d87f085b1f8565acd26b4f4a7a46043dec072dbd90d05ade43d9954d8dc08f3a85ac55df2c361d10742ec8ac4cee68cbb0116316419a4f2e6120050f3d0855a612a407f115f823df7e9b31f6c4d96021267fa9a25155180c0b57b6e3ca7a238e3034a726eba057faf3e0c4fa7658e63c50882e9c3e77ca6ba31e3957e8953f91380bc9e9fd908b0150d5a1099934c1a14f723bf9b145c60a297d1a172430352ef0432785df9e992fa2f78a101ad0d627fe20249dfada8950cc8bf912a486357461583e89ff856526e3e307851cf020b5e3e872671ea495cbe4f6276617ad34c59690b28f50620f5d906fbcde3456b275c359108443ea80ae679010a6b44125453d55017e9728fa7547da0f41e3749277935a013879e17b3d670b5686cd284551ffbd0f1e270a432cf06c2497dbfd5cac7642ef9121970eccea246c1956612fb4c4d42b40d2300b0c4cf9792930f95b05c446f91aa26b4a00598d0086fcf27b477e25993b1dac4db9a0508ceaf24916f26a23fd3ae4efbce14e48c5be7be5a6bc829111796c7e83376ce96799d3a8e4bcd7007fce665c9835f4c83f48dd53e713f6f8bf7b7e29debc668e5526dc888839409061449ab302c4a1f3cd8cae9cddcc5b0b67a682cd4b5d3d281a8f97245104d21e688eca96528381838e866371773884918cde12fca35bc65b0b280a09880032dcf99ecd35d2a5fed943493dfd7723f0aa41f9695c335400e230fd57ee34f2c9e657c6a53368554826b1c20b98ac9095902fc51a79006f300877632edf16d82528959d76e4e4c4de0c419bb610d0046498de3b92693778f616267846b546e361da9844ab048823da8c7ad5ee0fc887950e8e951cde577e3691cbfe94267b916dfc158b54b5fecdada6701397750996ee6734a4502434d638a40897c1f983546192ee7d196185aa325882c30c35dd2d7003ed38b23a9285e776c9a4546912a2cc5c296b266b2b4972d551b0c86a86694d8cfc8ee64973733088f73120275c7390aee806a1855686c40dafe666a4b53bb1dcd6ce2efcac0534134e2984a25ff1dcdb61457d2ae16960587425af1710e8439593d83678353a2b2160355ebc68d4843d8732d88fdc6f067db9a1fc8a92ea1b5e8d07a7d4a09494f7fcb11f2f752dd82143fe9795ee85206e733424b906e328093a5facad84d8e9b797efd2f9ad6a648272f7c7e9cf335f817ad2d553e9706d58db1e5afef7e46c795ddfc1e1c65b72c625831a47f43285253f45d1f2eed336b93e99a7970c581973a2ac5c94dff1a23f7e9148d7bb22173a95ccb25de17fd51b93ce0ca6850636216b140d1bc99b4b343a9f8428a2917cb59b93dab827434baf9ee1f3ec2d8f8c58a64e494bee84c121f2ca8687e10fd12b1bece3444ec44ac2bd654b718ccef338591828b54a0c2e8dc640f20b15f5ba2e5081945c1f522cee52b3950f6c7c26e667ea8cbe485a165e0ffd51bd21c3ca569269b4c5f4e0947dfeed824439c5d0a585a6c235abade708f53b76ddb12523ef06eb2d4dadecad86698159ab85445d5362b69c00fb171bdc6a474982d2cafd574d7dfb574c85967dd2ff538503e7e57f48177e1ebac1fbfb7a30537ce7d7d2aa515f8f317513c06899a391ea2782f09f105bfa304066d68aea720a11792675338eddf254a8c37af110d315305637d444406478ca72ff55a2109bc4075f0496f7af5f0958377df3d682e59f160c6e54a8d8646c99d4ee94927ec18ad66c0a5e2ad8ececf9b0b47ac9dfad7290ced3396d0435ddbd9b3158e9710b1481894941aab5bdac734bc0a16f45a7338c4d3413caa4cb2c58cf96c71005494e31566977d06c23d82cd94b6409ee58e2b5163fbffc4b8fbbb7c10034a2024f6c5361d51d4777b0e35e906abfdfdbe3ee9be67c142658fcda9b78762dffcb8d0a4333abb45e6aac3505daf1275bcd0c9f46a6ce4aa5b3d59f9e58c6aa48ce237bb585f428254733024ff3e24425badd746ea10694f160aaafbe10fd4247174534dce81ca2fc4bee065607b297d1d5dad965c2a5b74a7460535159121305c3e71a6e859a81340858f52a003ade33f361d59eafe616e24adeba217ebbbe9828ff801be8e678773672ec05183c1b6ac0e1b40e46c57b09aef48a83dc4c186decd02abb37b034eaf663af8c3f0ab4ae6e72f832e7ba6a231e511ed39555a7a5a42368fb9e14765495de1adfeac0c125dcbd80c73ed94e3803ea532f69b88a2d5197381cb731c8488a62f53f5babed8fc47aa99519ff477441d84c7728795782c6312e0419950dee4892360a121c0558f08b9ea787496ee280f2c6cdec18a3686da379420e01cbd2d07064339421cefcf7ef16c6a68df95bfc4541d34c689756a743e0da6892f7b73a201de63ee9152ce81be89284084507420d5ab1045fb46148268044d50efc3b0d46bc2aec7933632f97fdecdf4be970d7972263dc5d6dcf72bfc0f4d4ecd1d526aa5aebbf42d1b7fd1c711903dc03cb87885dadb5a13a4ba73c5a4a82c7b904ad805dbde93396dfe762f11775e3e7f5b6c506dd93629cb137d1d456feadb7c2eaf48202314aaeccbb8cca632aede182595c32964465e39f1825f818dde3648655b8e132e19a317323a343c69a27ef9a87cc1bc34799c89244baa0c43cfe44498a8408a866985e3182ce1976e1f0d1fc06eb61a650dec26585854e17535c0f1995da3171015016f73bdf5cd0a320513c7e9a043f95ec4e2e934e31aea6c0ddff86424afc192aceec9df0fdec5c40a400588bbf4e59d797618248a34485ffd3dbb15f40a514555bcf53953c649ef89cd4953ac12513b99dcbbaf94535ce0ca41d6ae53ae103f6c0280b64ad3404973a35b33e18f39c7abdddb603374201530363b4e62ff444a483798d13d35945fe884b685f6ee9bd09cf75e9d5fdd729b9fef1ab9daf48063b916dec27ea08f4a78375acaf00b52dbe109ef6ccb1043c98ec006e7ddc2e98ea78068d4f0b857c485a750852c869ecbd49c174d1b88002edff184ce05306b3448940b2c85add9b8fb07a5a9a581fcdb189e11487685c79d2d5e236059571c4c902c651d7da53ebe17d1d23a7dd17865fe756466a2b23abf49288eec85b7d953a97044bfa5bd83e030f330b955f39c170b358724b2e4a8b79e559ef65a48cf78a4710df379e5703ffcd7e1948dd6981b3de0dbad8d067d6ae346deffbe5b1f4de401314bc6f3d42e4ba8c3ad47596b8c8fbf1c705a22989d7ff57fbabee36bb5520b087cdf50bbf6ebd0e91bb4c5d514ba020cad4054421e7edefdc1bfd1a20c1f7c495309b69e3c901cb7898a40df8a0ae3762682e2d3b8347967710028302af148f0afe8987d4b625fe25b5200b3a26e657bce6b8b243b2dea45d20baeee79827965ed9dcfd8233389872f830ce435b5df95528003fdd1f75c9ecc5ac77af0f5f5a55fd7539378462592da75e757a554bcbe7dcfa7f30c2943bb1b736e3fd084931e7ce8f9de1bc7bd88d0a5e36cfe21f27db692dcbf45ba8610eaac4632632ec61c8a46f57d917c4eb4af6e3e9ca8ff6298711bc9e6881e35ecc48ec40ef50d964fddbd6c79d4db8e954289681425ef4278b2d30673b8508d2bfa7e25320fbc7694ea3be9e2c1cf34359fa4fe89a3f97db583065a6a83ccbc4d1a2a0789fe666d79add67e916337b39bd2bb4365bcc1500be60f21a5397d8ca46aff17cc1cc95bd1154fcb74b5696c02e95ad505c8dacd5344c5bfe23ca1a4c58a25395ae813f067099d92bc8dc40403dd312d034f329fe096b7ab65859321924c357c8eb1499d65abaca9236a8bd4d756daa81883bebd1111d441e74d66eb236852470a82a194db8431ee5f629d3ff232c72c9bf7d399928a4cc32f138fca49204f0a3aafa5faf5bc80b91fddbb84c53e7c4329710691ae2b9dca750d65b366f6cc6fecb757f034208c3601f9053f1325533e149efaf86090f62432dde74ddbb67511e1c1a6d5ebbf47d6c27388b87b42f91b50c8c169c807ae69bf663d47df3636edc07fb92c88722098e46ec74ad08b02c2b74260bda303b3f2f88894214ce3ad8246d32bfcd46c6ecab9ca9e9e152f7c38f35d366a463da94caf992342bf324a94cc74c1079d81103f14080d54bd66fbb813284fa42f9fdb182b3c4b6644675fe5c2d4d5b01e4d7b6f8777eba369e24155ced9683e12fcb3da6304c0cab92313974ccda89c6d9219625bbba742f28c503e68bd837f1152854a83ab61cf3fd43dccc5701e535fd1a05481cddb65511918d28838c6f1660c20d17d222f1074e355ee1a4a2761c10c340e2e2af21bd02251dacc269c4488e23f27b53dd87c7c7a383195f303429a72e9595c559e0e7fbb42f9bab05e9d9442d32c3004db15f5e268a336b078fefbc5d586cc5455b6b41ea5f6f18ba3acbc7ee8e167213493afc203f7833389e07a7eb45e9692db573f8306239d17193f733f405b58567324581a4e43c933f78422e19d58f9b3b12088e158021661d55a25bc6752a8e4275970d67cf9e43176ebe86a610c22dbf14a8b97b6156fff98cd634ef107b11779b748b83d0e3e7c8147c0e0d0b154daac7ec6d488970ae9f5c886a09ce35e6b9cea84136df08b34325e93b9665df2eb79c836e8aef6633214fa1200038ac7c547d86d54374b9a795fc938d52f46d2d49f1c7bce8a4881dc7d56c1a04b15cb1e58a903e71cf93cdeab1d795a312d7136de0eb1d3addc098889ff24ca70428d985b4f457382d2643c58409adef25d1602b8646ac889e9b298294922bfb15f2981b5c47fec7bb82a88951ac4f415cb2f2ddb04c0c524df31d2173b4d2f8e011ee72f8bf36580b8640b9c10e4eee6a9ac3abde5832f73ad34fea94945233771d79e19bc3b837c8a93c910feb84da5b8ee150c61f8c453e5dfcf10283bd84f827358c5713698a48ac11e40f0034e4644d404790bc50d9e58ed8656a7d67a6f2df90ad81e316dd1557f3ecf4217ae38fd6dc8fac3c7de542c384e7fa98e4199379da55307a9fb53b958e1536b98bec81b485ce5135d8d1efd8cf3b7b342664bc66a85e7d460e99a82062cfc849c81ba523b088d0ceec6995efac65913ede450253ca48a8ee6d21621ec176d785fc38e725085a8ddeb67936a0cfbd5d7a6a703948ce9627cf3c0cb1be60a5d58eb11ed3a876ab4154411c7f9c1ea6628d656bd26a37a2535909989534101f7aee8cc83bc905235d85b07e7d03faff2bdf4a9fc2072465e0628256f118b3c40daf5b737b25e662f9b596c35f68d01e1c401768baab00946048d32ea4b347fa28d21cca41230ea9706f13858c3d2b79bfb9d0b7ad3ad2ab8d189a88671abdf565ac5c619a1c60ec9556cd13cc75fe3b8a13758585c01f61ffdde94d64d99cb791044c58badc44d3298318a97defc7fad8922bf5a2da252bf6c88347301b2ba201650e65f922ab19e5c95d8e5cfecfd6df140ae2d0e5f38e51263cc5d1942148a1c71a9f886371d4378e7cef86968797e7ec1bdb130603e9780b4e309dc2c816387834a745c96c68127480201fb5e762b48bbaab5645eb62f00409f00727c4e17f045397b7a13b27c28a3241804b8fda2ad13ac5308da6d360e100ad47fd2de6c652035cd48244310a226cb8e3fbf8867b6733a492366dab5b574cc819b73cdba5dd212caa25063b7e660709e91f14ed1bf009077fdc700dcbefb1ae2929595fbfebc4ac263dc38585de51ffc0e0003b346187d339e28aabaccc05bf28d7316d5083b040fbbe31fe7ace8cd3fc5402a0e867b6128b8fd95b7997f80ff560f89f81f8040fb8993a5bd550388f79176179f0cae8913a25d06c99bbfe80eecf086d97b01c2ed28e969726a695b9c3fff9e1f68d04a0be9ea9327ccaf0d346726705926a4300cf4ee943b23cdc5234721dd73e6435f95f90b8a171062","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
