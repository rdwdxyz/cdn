<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e5e3c83f3d0ca83719cb6252633c371eeb5d932ca0d3e37b236b8eec052825fad96b3784632f493eadb8a540551db503c7716eda30f274bd5f7c5577fad7b8a7a138a9b48a3fd35f93f0fac96636bee3436c860d284f9d821aa8272d83b2f8a4601626a72ce98320607ecaaa053c8b951f9db9ae5b7d1386e91c62b96db195c0b14f765da93378e064900f12fc9f1a8d9a02a29e0ec0d694377aedfd5c2a624ddc6564ce52f372b652bccea3da7385169936cb9d4b7406d04e73697a108e1ae59648d50986f0468b7d803f987dc7284619cdff1779bb6dfc1c2b9dbc255adc97fd6650f8f3f9400e56cfd67ff0f7534936b6afe4382b999099dbcaa8bf8099c2eff0abd649ebe50fd19b6b80e3f471e0ff3423d943f61ee77d6869c0e0ea890e607a195c9731731aff06df5c5d15790db7ee8d09b3be2c1e353a0e437394cdae3ee168b02bcbd67c1207f4911f0ce165443c72137312364ade221864dcb17ab7be008ca43bf0eea3ed29671614a17f0342cc6bbf45c3b253ec0aacf0bbb0b6f083b97137e14ffd770d93717a8a5bc9dfde5807945e8e0f174479d0a4755a2227b9503ccbefc0d399959226f118cd77926245c39bd8c640af043615ac22805e6426c1fe355824fbf887630cb80e7b2e17194bc347d12a314b18c8d7c30c0d5888a1642caa3423b26239e8e30be6a633b94b405123540eba81d403f32b351868099cc6c911424571a591cb0cbb644e2f8b8efdc84b90fbb4b4401c7b9bcb5c671dc13c323e18acf33f70d4bcfb8940c5c774096c3e1ceb42b829694bef4cc5c152c63ca3d09864cc9db983204fe5b5afb3e354de8158c47e3c9b7de74871f991a4f05fdf567463d3449aaa32cba12a32e795e1c24a349fa96a64ef9eaf9c83c247ba2fa17498fffa72036b99250c8eb44ed4f7fcecf38804bc9d2e78b59e192339105477176119f64e381a42c99c0c8fa4a5f192b8f5dc925abbe099e162c91774abf3970793aef3ea7aa38b2e201ff4025ccada9f7733e41f04ac73cad3afa7526e007943f8190510efe164d9edc921e54d3cb2ac7105e7f789c980d9677663f782b47ca743df2513b4efcdd14af3a606c54faa884661b5ed9c43d8043a93f9f0e5169f0011ed698dfb8c73c7c5479091cf9940fd4b3f050d246d1a69d60584e47c4f9941ffd4a02e71ead43f215e49090c74ab444cb3e3531c43ea0cab074a171ae0d796c5914c779eb101560f9b8481e7f68caedec80de8cd6545d51d7940765e8b3aa56f6753c716f20b0499094b114f0ca699e55cece638f5eb103e2ecdf6d712258a5e3d7e7da89bb6a010e9c4b92c8e739e1e66f8159357cc140c28c4f9f5da7b5736a3eaa8f50391883fb443d8771f309a95df2168f2e9716ad415cab55ad5ce71adb2a6393f09f8cc73f928a7ceb7a46388241ea2616c64caa1cdf5bc744132d9602ba41b6e442f7d99b1f6b12d56b3e124be1b3ec38cc4d7c3e318f981a7841f663a10d9aa7943eb171a51ab751342731ea0064ecb93e75cd9ca3a188002f9a4f40e60bdb2c26b42e0319814b9ab09799d1d88c8b6319f365f8363065c46c5941bfb2d6bf0add69cd4f90eb51f394c67988a8188135d7c36fddf0051b8d511b789b07589fdb01cb8ddd810c487ee833fb0814b40dda75a6a944d2e033d8551407cf537483b83752fd690149ca444405dc166f5ae01d8c1dcb6ef92d1c52600f284ef950d06351173dd87838faa717c49c6af17d84e754b96c1117a929e4465f751a22ad0a5cfbd0f0eafca34ed3c6eee1e60e8dcb69ca2e6537e91763db06e7df8e42a870501370a82fcbaedac48f83635bd30a70a6976f1f4ab8597b2b6064d93cb1689ff2e658ef6d840e3b028a551cf0971ff8cc801e4953ccc69ebe8e59659aa2230f5bf107e59088285c71b67a8fc709b8bac495d0a25126bd01b87b929952393eb399afdc00f0f75169409c08c47ae74408fad55858a34f81dfd0196022c6f599f6c4eece6327b8a0f7582fbbf906997522ee5f623938474f9c108aed6a807127c42c54bdd108102c12f16a98667ddf97b42d00d4951e0839483f9f5e955f2e1146bdc7a72e86b3f5bf3da3851819dd363a686ae965995e2221227a43cc792c794a957037715c236ad523581f7b9b4dc6978a69e3ba316011f2fa729e3b74ab78f9fbdfba4c33f9014e79ec590b5fba3dedb124ba21f6913f838c0cb95162c6411212ab432501a9bf3192a1f61a371a6b7fbea69c46de535989f36afb09419ba9030c5a471995dabb82d3debf6e71ab2c47e1b186b37df34ac6c84ac7c1b631589f53d0ef89e24933ea80c8dcaea6781ef4042da3436ffddd4fe4084fc9b7c3d46109a07e1a6c54f342cd71961829b5f461d91b66ada916330dae59defb3294b02b7d7e2db1f09059239e38cbd4a06fc4a3e00cc8876c7ea923c7f218659c9b7162f02e05a2f462123019a51b21810d00f21029225159576c4b758122b1d79971cee889ad63021f14d4a4c12a5cfbaf3780f936094cb7e2119f80e131a7032486975c3d50cf4319b644a4960b775955e972d5b8475629c51e0acf83aa401624e642bdb3862ce8992b214b6358007ed24593e63e99454828c651e0d53f5a75680fb4825f59b1240db961cdd93315fde245b095ca7ac010353be7159b07f1328107ecaddf5cd8ded04fcc953e40b0443cb8568e12c4f898969fc6ac8751c39b27337f726551171d025f7ac5a6b1f4e21f1d4a8bf5fcd05c8d34ea79252ea88e8b867866aaa7b059a7b9b5b9b96bbf11e54e63a6757a80c878efca3a4dcc62c5ebc3ef49eab461b1d7695ea32827ae5a3b2ef54ede5dde2144c61d2d5caedaf89426adb0e5142a86f3e7606a5d0ffc7998b4c6ad065bab0a73e917421d56c48d84d277ac9e8183327d1ce4e4e4b7f87c86f760ddbe28f93a0bb2c67da398890f9f55d6ae9df237a7fb453c9425e2d2c85d503def059e329fecf9545e5ee02e366af07daea2ac91236233a6e36909afd72f9c40fe127cb25ffcbdc13bfb4b9bfa0cdfd1702b382a95a616ac62bf88573179e3e5cae16ed23deaeae2897aa7a2e9010c65fc39c7347c447a1470f8c309443ab4e4fa258bf5bc13c6a98663c0c1abbce23acee37839629c7627f1d1d55f14952ef7da3a652843ee2f212fed12b99ced3995f452d16841256db88da77510f97cb9ff87f0426045b907e966166b70ba45b9675a744683bba858616cd57ba209f626b5a67ede06115735c35ced945dcc546dfd2d9a3b42e48f5cb87d83fe68cca94a0f7d67e3f307f60c3a6b363a9d42ecbaebd4cb24fdee69240d2252d7fcf16ab1b8e10a39a077b5edd04fca072166348f4c0fe432a60672ab22eee3f73fd7d9243066ca8dc100964e0bf49276d88e98f30d960b177d44ff3fbf21b888887c4d23e0ac86cd82a8eed28000480cdde675839e9844645380544a7ec60855027b75c0c51ef6a14e64d65eaf462443827f88f1abd6f452f5f44c81416481a0172c62909cde0f057bccc520afb85bc58a46f3939b4bd579a04da9a4852cd4d2ac7c6910b3543da80443bb78524de07d2a6f28920521297fcc2abec2cc83c20cee13ae6c072d15da7ace4243869d2a5a8ee48ed439d0d43723398514af81a38f1e739d68e956e1fa92e2ff9e7bea92ec6aeaab95c4196d845568a3b3f92fe13f7bef1c67455a5f4c09d9d6c469acb26e38a2850d6003f4406551442ef88535bbbc0488b72e0e691efad54700ba0bb17ba2c36fbf29651f5f0f666dc3b075001c43f5551365dde96408a446e9a27aea47fd3f2b0847a4d2a5f65082195b18f1910a00b20c36f3dcc11ef38089bed3ca1a8f92ea202ba6d808e29eb9049f9edf6efacfe85eebf482ea7d30a32e246415d7511a5885294d88ed8037e913cc0b92c84019b5d9ce23d7008b8bf4d511ac3cdb120955b649b5b3b3e5f021e3aa2d1fd110c0d4cc499d3a12159771ad06aedb56792c87884140d8c072ed831b28f19533aa008f18f1bd63114232cf2d1fca1e4e645fe84edc8a690cdfa9dfe697e8a6d980330301d03268025a86f95b26753d9ed0f6537fd4245c8cead921f89fd1597be6942d83787e166e96b270161c222121a143b62cdc5ef350dd4130ceb63664c55a02880ddcc0e8497cfee0599f10bebfbcf6fa435fa23ae49b1f5341930497093dcaaee5631fc722228cc0fb4e0a4d2a511bd0df983a32104b38eb3045b6a9e12e9d832d30618d5f5df0d963d34d911872a0672ab447bdcab1f467490cd2910d0d0805e933a032fc57e64e0c0fc3527b8089f3912e528a5e69987ca3834a45decfcc255a9954842fc8b0c5a97ef4e163972b4b8ff30490946e8596df807c42e8f970784cc335a003d1c299a166fccf3f6b5b797a2b161893fe37c0cea143a2183418b6c64ef85b80c8eb79bace82a756a1c359adfdba8f2e351cf3142f2830c9002cd5c7de5d290d30154af4fad91d327999fc19ff7756a8b804468fd39cd09bfef08dccd4213217ee5b10b3428a4d302071bfc38c59c906f5f28b08d9d028a861dd5bbc09c1c5246662e45cff1b5d18d8715d301dce721c2f4565eeece9ad3e41fc08b7a8a495df4d5cfa4834e2c53fe8657ca36845d9d23e643f6583227b1b846d520da88f7230b0b52be18a4a677d1cca2761cfdcf60ae691317324059c4772b8f7ab25e9f1168b85c4e5bb478621cc33f1b1721731152f8d47f9f95b06c4f7b5fc93b4bbe652f14e7a510bcead381c4b35ec22877a01ec9f08fb0afc6e60ddd0da52e0237a065c89ecf8a07d792e17a4d340f13882a4dcdb2ff29a03d00188f18b7cfe2fd98692d60fe892e674e27bc06121e7e8042bf076dbce49ca58603feabefd892a59ef5724526a861746ca82d01eb51d6853d9c8b2d5fb00971766f31f448ca0b6a73d88ce86c1ab2293841f9c47c9b61b3f8a172380523b3cf56c76c19538a3c68e4edf8b3ba75feba70b2fe1a39302340bb6b7810619d0fa7999a117d79fc6d2f16255f91efa9065f787bc10db4587c798cd4e9518ee7689f2237604f9101465c1f01d914078c333301fbb5ef297c6f2d5a79fb4e382cd18c9835db017748b0c48888226e256ba6b0db3c5db055525b706b2eee5b3a3c54e83856075c1421b8a6db60ce8cf30eee94e763b08f6203f097783977651b943f12e33a17ad51642d9afe11f1676a63f8ba86df4ca66dff0417d1b6e01272001c27456c8fba3e74904efaa6f0027aef4ffc194d4a72b63f3ee577a3c77867f3698d13edf9a76c7ebe92d02257a56e77f7825d0896e45271187f0f39542cce501bc8662b1e38a0f1072d77a2f98a42bab340a43fd296596b807d47747155c902527811942291b62f6c93ddf6f08028ad0fdb506e91e2396a06f47525b5512f9c96cb3d92878707ff6aba2b030f580eb1448bafeff91c8c36f2829f15518b15c5ac232fceb414f2f3c69119ae7da7c9315d527813c476b5ef84acd1567eac4f9fd378f2462d0a3931882ebd7df8ff5faf1948895e28de239d292d220636f23ee3400f556228eee8b5e36072edc1af7bb4dde5efdd0e3711671683c40f4581332bfc5d2255600ee7c3f3f8b651093ea0c6e21aa51d88b6fe02bc5e0a9b13567acdd8fb2c53d95eb4bcb3fb34969bec81ac86c1f13d41498306c6939a5590fad24f2eb0ab8d4465ee476d907ee45ae36529fe4e7c4945a079b86b4134d2099d777e7a24b0db036c40759e1ae1a071f641a77d83d3fc48f3ac0aba92622cca971124a840f236eb0b4c7f6a4f7b82dabc8e2c7e7abd24290576b6be464afb69cda793e0f8c1655d835773dc070f769925232eba3f4a5b963a742327faae7a9f0482ad7da3898ca62f50f53bbcb7b3407658cd50d6032c03071111257cd5c1e0b21b4ec4034995709665c15d5aaa29945c26e1e759c331312e604969a3fb7b3aa253da8b471fa3e28fac824d4bb76ef8261e3aa74b6768819c83d99722755a911bb6b9d98ef603f5b1c8c8176e9630d873cb435f518a831f4136cae68512bae53f0e529e03b2931cb2763886d8ce3988b7a1aaa8edc4bf0e4b202002d47caa196ee72621d6acc87603cea152df5312431cb5cfabc90456b99ab78b021e18a39b4be8109c95a9a779401cccfa219ded669bf0064efa75b3def879be892c7601171146c310f357f590fadf089c98fd7c3faf3417cc772fa3f1639799f17629e9f756d20fd26c70a2d3bfcf765c86e29c8e5a1225f0366994119d245e58619834c9cb373cdfcc2652b524bb8bb493970b6e23ed2908f2d42ba95fca590caeec6b6bd3a4a884422484e279f5d8815bbac64a7590a8fe4d70f8b78b60c6505b2e98f8dd2554736241bdbdf735b21735e5331b92cb6bfba4cb4f877a4aa207b31cbcf18754204436e880df42554d1a4496192c09f104f4ffcb29c6f2d04824c389973081b359badf7f78ec49e8780839699e47ff321a0c76a397140d1f291aede498f7092c6245dc046266912394875ac21e2a525ed69e6d3a9b460eb77427bb3cbba2397f094b6aeafd90f8c72518499d0102ab410464d6fab256e3b73e338f11898fb52eabc69733da4a829f4aaac495fa74644ab31b980cc11776a3b9078532a134477ecec7a28935419d0edf2275a181c3a331ccfca547def5b6747d5d88f6a555c4c9619a7b304d9ee3461b6e14dee74bcc3a2cfe40eb5c962e8d5be52602043c0e24fe417d50047c84f98864679ed6e81490217b7f0b967a9b9a071410c92da3add3b2d6c1189b33210769bab8bf0e1204cbecfe1d67eb18902769d01692fc4b6155a10ed95bdc98bceb8a24b1352f899bce49127e3bd98603b05513949f90aa78621f17bed252f54281bfd4c86aee10e84896a3c3d9a2f8cdf61e4dfb3e71ece563a79e2ee567a6775fde91217678a470e7c1cea6fe184e887e02ffc569d7b68b76ff48f06a1934ad40d0b26794067a266339140c7393d1df06c93a9850dbf83420fa1de8535298038de1145e4512bfd9d1d64eef3a36ef9ffab3fcccd01844e3695b107831f760eccb9a4e38e19758c282b9951277c2d39e3191448edb849986c2f553e907b877db0650432628465a402268e8d4592e436b77d9d56c95242f72429781290d33909817c1f41616e38bce91519c9085dd5e1867bedf767b10f0373a0d6366620a1534b22c87bb1ec027db828d5253f050178b06e73e6b03add1b7ddc19553f14e1d680bc3871eb357d052d30be06b6a2ad2c1e591949fe074d932d54cf93ebfba7afa808c9044d1c098c086153a1a3445d4828804cb2e8187c4ddf762346a5394fc30b963bff1557a7b789b9c370c30655d29884822dc8dd30510040a5fc1c2b1e31ff052545945942db0748e8b5e7470ebdd47b7def99be4b2680823dbbc54cd38ef1b4613bb1759ec5d3bd0a713526eea5b109e62f412b2c16209a8daf26feed1839230bf4083ce32bcc38acba6197b3fdb5195b03a68909a7c9606e51c7072b6fc791400c7fb85965739068f581d0721395c9e66d9e7d635f7c7b2096609d9e89d30390b62b20205c81cd3b7992a366c738f6a96433aa8c3cf5ada56b5a403d01b0f8dcd69998e3d63d57fc76864fc1aa12ec1daddf958996f445ed395c9122a12025c19d19e5342257ddd70d7e5dd7faeec24a0c6a38d19b57b01d5c79e3b38639125edf48d0b0fe724171a2f0b250b92d1e9f83982c58695eec22fb8c5bcae29208dfdc134ccf224a356c7013ed14fe2a6df547a307ec7aff37e6db09242673b1c69058eab088a71bf894cdf2a7ba6772d78827a9dfc2262ed61f2950262e6b073cf013f7dc8a371da2291f8e2573ab60d48041148c9cfb08240591b324d301622f93d0e3280381d2e7dee1c42c228b0d16acd818fa31de5b5c3e7dbf06733739162275231a4478ab4069e33ba734011c3339ca545fd2451ce81c15ab9cc002aa3f9bec29d4231a25bf6383faf81c2c02ce925ee6abd96d5aafca220e336e68e6d40070eca70a235000de43082e38166e58877848e976f48e9ba8f7f3e416c7679db5bb22a8f7685dd15b35449138f03c2fa83521aef2edd7453662a6a4a327c042e4fa565415c448ad53a0149eca6a1954d1dfcb67aa1a2b9f14fcff8de8e28ca145b8a7380525f5707132d90f7c31dbf7a61c7a4bfc1cf1e32a636de652f75b7c31761a56241093edca3614846ef1d617a679a98583a0fd58eaa86238d30aba8e973a7da9108284bcf623ba06973ce35d76fa50d74905b388a057e6e0cba26ffe4b9b0bb9ffb0434134404996ac1b2498a9a84b69163d2867b3fc5d24629bce6f70095e937b394f18a02cb830330a7b1d6aee0c2ea4681c9e9974bad4ae987fdbe97983ecea9dabf0595e5f1eab86d18eb1a7e7e6b3ad3355856e2e14387c66d513bb320351fcf3f011489c03feb23dec4f65ed8422a455fa05545ba0c33c9fed87c388a3293c6f6498fab524984d6806738ff8c82a4cbe4f0ba7cbf32ee542528606952a5704f7100ec2d0c0f2af6bd505fccf328bfa569e0c21d340b33419aba2069a2e145da2154bca69bfacab259a5b39afc6c43439db348e0bd96f08d6b15b15b46ad109ceaf06b5c9ca8a7a4e9e358b95ab4c15d1ce2ff678cba01919bd978f23eab92126246dcb24a0e0efacc80c77ce6e5a348640643de32014e5e3005f1f549ed022818de9dfdac169256c97036431321ed58c191c7d1bf7133afa95285276bb16564f2a8c4f612c9b909ab98ad62231d147e966dcb8789335beffe33b68ef2524bfd85c515c1a2596d1a3e33407de814dbb5eb2be241d11cd74abefdcf313ba045520b6c576970d0043dcd9abf1088eae2a5462771f95003d3b1bbc2f4aaf6e3ef48f2649b5951a391b09141a9d404036e520468572145d1eb7b5f59837438f6438e7ef693b0794ab35a7f69c22c8068f34386b50a312bb15ac7ee86a4723bf6476a60a819dc3f73c8a9333dc6b8d705479a895d3705cd33f014db34428047b7fd4a70a1114ed82aa2d485bf4aba08fc9e1322c048f3ebefb23c36a05aa1dad6633607103e7d7f5f7f8f69839a9b4753c73378bffa99a984992b82bb6196458a8bc86fccdddb5d40665bef8a898993457e4c060eea19f195701294636b676ffe2525c3754c7c0223b7d31aa3c8d623d10d473c4b9a5edb81cec143061ce87290019d1fee0101b56ab02922861f2f9461f0352dbe5ee7c53fcf5a5a2f85751cd1f859428ca5f020ceb131cb8d296511571cf3c5407b666309fe809c266232fdd8aedc333d9b67519e265b5b5abc6bb2e75151c2ddeead64efcc1eb3024d58fa65eb697dafec37cadc30d9bd92d9da02ca1d1a7fb95a648e61022a984697fd7a92cd59d9ba82f1392bac97dd7dfceaa0d17ada1b2790a104263ff26bf29a6e54320a5e2d2ba8bee3b0e5351ce9a00adf31b3165244f33e60924900dc69a78e7b0a4374839b464b71bc0e3b4e5758a445b1865171ce7a7e2749db24fbf0920f6b2b708c025589de2ab481c7f29b1eabd4897f0d4e778a1c286278d3f78d1546d4924f3dac965467c620d75bc62bebdad125a11a9fcfae82bc692125394c1cf96839e4694db876b333b417c46dd355bac89f1f3893c4bcd7f4808a4cb979dc6f92a9e1c48b46f7f9a29969236d95b7567b3ed73138b69945e86142109aa3ae38ba0b8ed57dcaa0310a40d2f7dce33717a2d3425f66af2f690d1a50b4ec8ec2921b036c9ecce52509b2138b7d82677eca994cdb9d1997bb03f99968d26baab83625ba2a287690b403547c092cf5fcc008a18ed320726b4f6060d67c6024366d758f232b6f196e171d933db1be6a797c0d672f7407bfd9f679af7a5b5a2470c0b204855c9edab416d79757ef534ee21407c29bddd129da682cd9a3f5000137d2384a78c02a3129ace25865274cfb49f34cfe368d5fabe8f8fec94c288cb2fd301738655c5f4e64a8efbcd76477e10c02486b53c54c5b5ae3a81e7b6e188e2d57252c61507152a3032a3311d5683799a8733f3e05836eb2ce79c74bbaa43d91eab148ae1fa36fa7b5cb6133df6a9c438363e4310d6fdb42654643358470951d5895b00c1fa8511d49192c864db2c47c57e0d1c6acf5b7d76da2bf25f34582869db63b2895b13b14310c41357d7d88dc875a6d78e8e1ee0e509240bc9022b79ab68cc62bd5514d8b2c619a278988a6ee0deb84557e3be06462fc96ee4cee1d3b3a715f5c8e37792fe7f0a4071af14a4ce029f46aa7b7e733ae91610e2455772647ba228e396ced1f0baa85e0a113bba9dfbd2c78d4aff0e9f95b0c6ed43a8c4da2e28aa68d3779a8cebabdc665a14cf7eb18ece9ef1b802cc32cce665c40354ae9d9ad6ec51a2c2bc3ab9c959d8ab3965e25b039d1378e1ac0699b42ebadf3c9b7c540ed6b52adabf80d89f295fab85e991ccc06b02dcd1e903e10d8a14e6a7a72b9605e35f487ca3f5b1c08b3d385df6973b4a595075f61933bf6479043a06700b55ff02b17df64283048c1ae0e7e8738cfeaeb5e4340e31a60aeb999fbe0d5959390647ff6b14d35ded64ef462d328ef8289ae935dbe8d5cea370c319cf33a4af276cdafd0d9098aa97ccabf4d97e12a79066bf2d013ea23997338e209f8e373923984ab5bd1fa146e55766fa6af952a12cd5bd68fb0d340dca8449e07bfdf2832f367e815d50988e714114f15f856bdadb9495ead4ec5711e14f7a994444af1a2356b1e566a1e6b7cfaf06ecc12b48366fd4495707fe4fe042a8af4a664ea1ba52b4ac353a63ced858d7f6f7bae2663fd28c2cfdc9bac8372654aef21ba2a827203fbd6f73e33e923f3c432c7fa9de8ac97e332d7144b46adb28ad4fd840c3a4837208afa1dd57ab9c7146dd23bc1e963613a0a7959257c195512ca32833b60c575a5dabf2908a4d1e5c56e44c1d7df8d1c79b21713954dd01cd3cf454d9b9c187ce3045b1f3c02d73aea7d0a6a5df23d4c3fc516b644fc17eee6f2b99b3b5defb09a1ba98670750cfb08c2543cfe6b59e994a70bbafba037da9afe6f61ce39489da9fb1445616ea35b7c4b618acc029f19fd4a5f4e2915259f4eedf164e82c66f252084c8b2145942cf36b4f40e7e04d243d1d8146460e663247d843c96fd93c0f081f8f1e86c12ea7527459c995a570d08cd96cfc5f47117ba23d7571b73d50d308d205646b893a2e26dddb0763c224fda4119411ab63c8c4370e729703b2213f0087374731b85717c9d59c49166c252c52049a516b79f0b37f9254b9d2d8d9d5de86667faa62274f89fc50a75f086e317bc80a44e36412061da80e216498674c1c7fac2cb3dc455170745adec30df45f1cde0cce7d103064d87bac11e75ba0e9170c892f2f901e8735b16ea7207c47171ee4354e8b703bccc9b071f2ad4bdc909f5d4ff6b655d13e539c9223ef99bdf9c0144c96fcab8689ea46bfc7978dcf4c58c66aaef01567e1ae0a11d72bea8d47350e0b63f2bbf385e5d3fc312189df0c68e38ffe6380722021bcd48e06d8ad682153a23d4710ca48b7e9e78ce3ce18cbfb8465c7c6930e56e59fe3cf8d08db05d686e72b9f4c0d5bb88439b140d98455e5635cd753946c409a75f8239c3e8ab1eb48b2fb1c0fb0f40381a7d1692c4ed9a96d4a5db6ad6be3a519a14681dbf1906b761753b6e3abc463aa1ca47259e719f73a09bedf22cbb553a9658a2d1714e664d683b7486abed9de37583e6e8be63f475efb8e56bd6862f685eef18f572679570d79985973751851147072cd056a48c8d707407199887f37830b1b5b000714232bbeab9ef3c63af4b4fef0cc61253ea72ad8ccbf8596d85b6ecdea59eed45238b6f2e54a617df7a0742be63c9e01a873bc05aa75e3ac4408af9e9ddefaed44a03f7e51624eb71791b7e31595afe1f8cd615176bbfeba0b710d924331182f6a82c1647643affd0235c9fa3d356068398805f5d50631e25ce9afe932db48479940c3ec4dcf36dd39544721d12178ae97c404d122e8a8ed4d8a11b079a83549139f58f9cf5a8bbc41e9ed2a09af91b3fba9725f9e8aafba3892f39609e4baea04ade3a692341df80fe79926af2b55a2575027c06319ab0833c9812a4823aa1d8006302ec5d0498fd046646d28631f388a370325a0cab7da4f1f44d86c029f38af1132ded56f9179f5b9afd1b6b220545fb20706f7c00715970f83dd022aa39cb719f3cb39c4c2d4da048bd90faf8db1583be7be00da9fd6c4754100545779af432c2b99891f8a2f1dea0c635932966f327ff888caa2f1c43933ac28d206cb95706c3ff664a666b1f94a3e36639a0ac4b70600ade3782eb8af2a95393400790bc93c7d21349dadd8d05840bc95aa5edfa9bcea230c9808d15253bd79b0227b602fedf3758292374198774e541d1eba244fcac092332377b59409fa7c0730e00ce1933cee06038dd9f91b048fffa1e68fd17336e7efdf8a6946f2acb30f0e7a16cb1608de8ca39733038a51fb0734dbfdf90ac7b925e98be5d0c87027aa48244a64f56d5887c36e5343840af8c8dd02f67f08591a7022c9426fe7e85d2813b453fe3e21e21c95f4ace32fdd7f36378b3fa9b1044b088518218914bb47182c51de4f401230bac1c5e28c3e93e4cd4e4e936df10991c3e65af43aef526a1434373047494a6fa20cefbd37319f46f00edceb6e01cb4ae97513a7f23179daa5586ec31e064b0f88ecb32e2216b8a2e68186a332c3b2fd6e5e46943121c85698441eaed6a36af904c2fe43cbdae355e90a8bb989c25aad4d53bd4f42dc04c457ec20434b3039221b4f671284d2f629610d441f550278fe7788c33d464d9831be6e92fb487cf1154a44d02063a2bb8cd1a490e80a3dafce269b9ee78a360c75e0faaaa505cd742ffc3018f045fb64deb0d96c25ae3e5c7a6053ce5fa3baed39b1fbfa7fb81871890e302cc1add52026acbd379de2f777a85401a745fc66ce1316a84baea94f148b9e7f8d6b6c39956b0a4ae2520f0eaac38ca5c0fdde55a943bff1699d8304a476c58d0f3bda39cf509d861afa4f4bbcc2647b47a4752653a83a992913c751a6fbcb51f34344be23cb0fe208c1a3ab00d20cb5c9917aad15fab05a4ccea31875402f57f9b8f23ef6dfdb7f20018b86d3e66b13ea701cdeb9569404caaadba6068118fd24bc04e6f5cd910040c83863a8295fc3edcb63d87d0bbe1cae929f7ced70d708bc1efd9cda69a19d00018ab0b55bc69c9436572022a4afb11900093e34bd6575db51f3a7a3736a9259320422af9103901d58c7a139b4b883c1a105663069c3b38309a2f41c619a8b7faa683caba64d2c17ff34c8eaf821e2dacc03817cc3d22ab19018f5f9985cc1e82e2c726e9e9983e8deaeec68c2ea32aa82ed91b2728417eb19e7873f691b35f619075b0c518db0483c7fdac03efba9a7b2b541df7ba94969946352099900071b334fd31ded3235c144f2d5b0035cc8e2022efdd7456689d8a9bf027b199f4e6944ad2c4d01ea7f359aaeb703bfa71ff3b1bd223543dee9bd7c10986ff63757f040213b9abc6616f00918fe2a266c56358a4fdf22274ed81f69dc0c41f353bc72296179165c6b1b7d6821d57dcb5231a09ec07297a1a73161a6546e4c6f574a85d594255f33d9f6c26836a352a52abe4bb08f27b277ae3e2622b10a48e7859410a75634e1b05865f540da51144b86c8710b6872c4ec754560c4ab997ed67d8a88b3eb9ab52998356fb0dde9adcdf532e02a4e5242e7848aa71f73eace3b5235ea19e7c2aed2c92080e5f9a3a71716ae6e81cc59be0fe5e36550e894ca842adb783672e2c09883232d03242e14d7a32e7af4f3845037b19623db44837a82da6ba0b92794ea2973932f01dfdd1046370be698df28c32c2f8d7d89739beb28fd2c01bb601d533a4a463736e6956746d7c5afdbb44054838eb47e8d50fb581cf1e199edf30591c345dccd74411ffdec99851fb7404102f087ec7cc99480f44d1f383b063766849e432c30699834f42a07040fe1c28c02461ca4e94e13a914bf563d2ab99c3dc4b739c0b25f29460569847a888d932e9ef3f7341657727bbb6e8d342aa76dd01ebb6d497a80d1aa5826b3e2639965ac4c77ce156f6969988f3b45d02516d2bcedff87cd7bbd9986bb215e9a76ce3bb7f069186632dab56a93f3fafad9701f7b54bea66efd4afe05a9b8da007dbdefd9e8a95957a5991ec15dd445c8412158527687f7be7417570a699f3d5df9ce0fca6f0ecc476f258ccb67aeefdb6db4a5ef6160cd22dfc24fe5665e62a18a582e256c3df1c7133b4bec8ce76a7117c7c3b9f89a74f7f1843188a2c9b123656143e821cf737b8dafb9e2378698a49e1a7ea5c194c4a00b067e85516876acc35eeba9e55352a3c24117d2828f2f6ab1bd403edd889b2a01ed57270baadee537276e7ea9c14fc694a2aeb910549ec65d892d7d32c10d1c82e37c7abd1f398020eb8e16d74b5e61dcc74f58cbe58daa33546d1fe903ea41d8fbf2477af1a501160bceb0389ba728bba46a971a47700c2641ed94917f1a9e1681e933d08d03c821492cb06a5453d120c0437f63c5b1c1329324b05d6acee291eeaa97e8026305a95e773220b86f40fde65ba63f5505c0b3c0dd5c5490f96ff7787415e33524a4343b2af78cdbd2fb34cb349707b09f8e9a543291bb2fcd738e33ce1d34e518cf4126354054d05e56b1b4e6a2ea8bf4ef438daa11556e87d34b8a269ab7a92c7de1c4e581631f1015576443942292ba7da3b9e06c723112fd8345e1379c61db105e4641ec099a190edb8433c99e2e73271f6546bbfc8470331804b064ed227cd72171cba2c429e068cde65aa72d9ca7f0be5306134608fa62c4f4c2906d06f94ce194e21ec130fb5676288fc3dfdccf45109ea1158676ac24996589558b211a32e7e0612b0632a715d1b47f692d3cf446faa3eb3a42c49d82fd0eee65717456ffaf8c7877be4c67955eae4d84c6a7484c874f506ece5901fe87730620f3aff5957a50195294f011ec67caaf28249af8b3aeda4fb2140c3ab3ba6e4032db1ee4841798f0cbf86811d5b82f04a8981a41f593984bb19d6c44a56c2986ec63feb781169506d7438a8b73667ba1606dce96aa387e26bbecb3b2cebc8482c8a5dc287eb8ba6a2f0dcdf1f51dcff8bb8a16f9aaa8645b32b90899f1cb8f7a3726f3296e981a0cea043188ff53ccdfb72e77486453de4e30840324b18952c5e08fbbc7639c3549e04f2c74267a9ffe7df9db2495bff2303aa1a29f115e3e3848ff2ee4051d7321107d761dd959f38be4abe3b49c58cd782021b2a3c7484e8fe988797a35b86f950b9ab45ff0225c1c1643b9a38ccec83c2a8e9e67d22f2cf4cbf964bd18df2a66a7f974677275fc0c0b22aaa89fb5d943bd6378fef794a476c4220e9694fd1c82641c16ae88c7261c9233f3b893097c2f5f72b4399441bc56b98ef6f6304c99d4dca9fbe0fc9c7349fad7f2740a9df0ecadb93f3181dcde267169e7d766dbdedb3f5c5de1ee1cc855927bb486e438e883ac0c2124622ce003ffaa6114cd08e2c72eebb178d850aabe0f47a00a8f4c7a65a28272487dae6c07491af30291003e86021419dadd178d382f59ad183d1a6858077734b2487136919c8e7afe3a34d3dde83e569b5607f1aa2264646133f30bb76b0112fe8596e74406e93957d5ce05a2761008ca4339978bb96dce3b761b2a361134e66c645997bbdabcc930e2cc06b718c9b3c2632252d5f6611a7e829c374ec9a318540830fff00da9efb34666bc45964a4c6e9dbcbd7f3f8bd5685ec8ea9ac654bcc8789ed20f439adbdb159936ac4efe84de62228a8995203342a3d5c72009debed4221469eb9e58020ad22d3232b88c8cdd5514ac28d79808d93cdd42edd22769e1fa67464365ecbd8c0bfc10e6abdec1ad9d94426f998fd4a61f93bea2a799ad840c170d4e824c84af62901149db3f8a245c799c654a59f912fe6f48a4d2c1bbe5eecd7ad4cd27ca002ea3b901e1a45dd11ed3566f3897bd3cdd95b604affd535b22a9512471c5bc574bb068dd06debdc31c82b252573c8bb2e7787e68df79ff43c552aa03eb1eaf607c8ae5bf32342dba05077084ab8c7f77e0a8d64ea383ca865595938b8ac0936c9fc88e9033e519338eae6cbc60cd25f6fc2549efcb928709217c4f2ff3835c3b3f2ef7401eab7160c329cd0ff95b369702109a18a1283b4bd7c5e34b9dbb63b5a137cb800f459c2af17af1e6a1c15ae9ea40a34bfda46ae42db36d05b74fb73d6fe72711519dc91888ed8c3bcabde6a99018cc6e4cbfbd3f2198678b5d48f85b4a3fd1f7da5c7ae4fc2f9ebb8fe533674c633266a828fd423f8cbe5c249ddfaa3c2bddb7e3d81e5f709eab602b9041cb19be366523a06c97ddd2cf13e8c290fd520afde71f7fd160d6ece1164d315c8620dc340432a995a866d56b5b19c02c535287099d972aa0e71f2a71174b21545e9d2def8a498a64991806b3119de178118874635bd9c99e93d360bf77a55dd2e5525828c440053862d4874f99b0c45d2a481f7f49f70f0ea570a152c2db7a656fc5735590f0c7502b380420f880d88bdde989f854c82daeffdddca71e89ee14be04cb09cd5240234eb7f49fb090850e7cc41643b2f8723915b04e75c1964ab0516559b4dec32e7902b37caf68701372a32d460565e883e86113b2740ad406ffb315e908f9925bcdd34b33d733942e32445009fff329528d5378ad91ecdea0a121c3adf7821e008487752add21b5cd0c93689eb1cd10beab1f20e3a4f41984fa02c44d91f108451a345fafc6df58969a069c16c85791aaced4dc93093de70e5a18f9927cf0dd3ae4d82455ec552f1d81216abf064995a26a0b45838a74fb26a17efe9237a035fc3e2af306e31dc4291789d594d5b090786a9a761f5ab504d516ed417e571bbcea10c130e7c1a6e77dd372c3c397173d7b4c52efdb9e99393cd66648c3e825c2ff3baf38e157ccf7ac23903ac5ace73221cae4f0af5fd02398dfd01b02b1c930038130756f7f3d34a17ccdf5f4a4580115df95605cff736517258faa19832bf1e5ad09ae9fac74590dde1e4245e56336c69d23c643255e9e65769fdf8a80fb729de94c9815a362980fc3fe244a6215574ea80a2ffa47e7a7c2f65847678d86c784063fa7484640a3eeb4df7098c3730fea71792ce79edaf775d596a304e2c0efe179acf7ab5e2b14b5e833ade8be47477e61157f994ab761e66fccc42d106a82155cf854daabba58706dfee3704d67b8f0cce7d0fc3d582582ebeef082fd4ffc2977f3c3933dc71917929b98a657222264fe03759eb1f4605d058d9c75db6c4b8803f6efd46b59aa7f634c881d9e248e498f124c0a61a87a7c6133f9a8bcb35982574f08f79e5e72dc2fbdbc33b3b5d9bf93e140901363f1c5d75bf55f032c6818f3793f88a215be9387a93a211869ef7453b0d4d3e93d935fdc7aa11d36427975655c73c723c67cd94785414a830ca48ed9fc00c5e5f352a53b9fa9afb85557daa45577e7e4f71fd70b10978bd09f366914af58cb146bbcc77c1a8067d4537c8cade4041b587e6a99ec36dfbea9ff53db1e80ac124c25aaa3f9c0ea1f990d7bcb1d426cafa6a53188a60f198592b99df6c4cba9ff16c908affc02b60d96a276f085210e1b555ef3a66fa83f2d9422dc16c6f9eed47022c44e3f8225df7652c81ebc1495c3b1934922ed2bb098ef434c986088c03976914cbd3db0504db7e2d4cf56f0b2fdbfd30a577dd40cadc2bd828cbfa006d4376d20db315b643420e1d51b80fc9f8cd6eeee77c10e0bfb93368154ba3a11691d1f667f0ae384c1de1618a0cf2490811d20669b75f1df1bdadfd3f8159d3ea25165c932c44720f0266a89a45feaad87267c9f8e162cbdb997a5a418e1d1938b5a27bc3725474ee46afcaf3d5a805fa09298987797656df79fd08949aad3e104d3b608329789b73d3a509ac9b068b4a285ef1caa58a3860b1a78e880e1d95b6d17e15b5174c58f1734a7440b3c901","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
