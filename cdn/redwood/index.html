<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3da753e75f67a11b4475f05b0de128103413d024502dddea67251ff24d1f223d552e376b9bc8487bab07af96e3a3f2b4a2900a0cc39ce773982a6f6aa07673f3a1526143276bf377214691488f81b183b9513f127d9dd8e3da1644e504bc0dc90fc7ef6776b925ccc0ae161fff9069478b21caa457c063c917915c91f09dec7ae5ef7c16e99ddd59e0e38637b4c3c555feaa6e2cd2ad36608eea8946a1be9a3a35758688e2265619fe8355f18c10f50b179b548a18f4d881afdb50b9d4089edbafb20e18226e5dc61200366f5f5f15bd72c799f0999a3b930ca964ff81a8f974ae5878211335221e03c05a0414d4db672a12b3b0b4a55355ebc83db2d9b9daa5f730c6592319e9be934e1d889551731bcebdf5cd1dc69776437a8223519287bda1a462ae8eece8a31606e93e92cd3d3e65ac876807cc36bbf410b7402b5380649c9a35dfeaca1fa9fbb75f603884f603026dda471a99e116e97ade209ca330ee40b63ca1c5fb11eb197a08db0da4a05af2a39e005f2efc88f2549a27ab1c0f44089b9b8c1ad6cf637f051c05dc76929ca226e3e5cade09faf464faa1e72b54a2ff53cb8195b1d0bb32a0a912451377e3c629b77821a51b78caa672919b4241c78f81daae365c623c372dcd240a868adaa36591e99b0bc4793dcc0a46a8f46a9ab44abeb95814a905b2881a5a3ac437fb6a3dcdc1f5f721d2a4693cb78979cf64d09d7d368c350505849198a195885b61a7c67dff3a3332d5ee166ec9dc3d3d7ed4700a21d7cca99fe905d5763b14a6530a11cd05ffd32ab93a79cbb24db3773ab3d3168d7454713799a713225fa3ad7780c25e13b9c6f1b2c87db5d86b20f0ec10b779f6f465789d51e65201746c3818025481eadfd42001a6d34db9a31437779785766a1bcb6d8f725c7ab4a31409aaa27e52cbf732968db3ea3cbf197371c28b89e2cb087f5a9482f58854aecf0c8eaa99dd3e17f3191e5e4cbf2f305e4ac244d6d74e4b6a6bd9e471062119f6e445270cc4e17a17c1d21e88c6dc6600e66e18b261103fec9dcf38e24457944a4daa94e7e7cd79050bcf82b40823dfef4b72f5c836d418b1d437a1980bfc78fcc1eb629b1ff13666b0483e92cea7d21d83b46028db51a28156c90ee5e746d7e0e7e9a5ce0b1599daa704e74beeef21a3731f4e91fc1ee0fd6a3f95a58ca9fddd4429b3273de300397aa2b66b6ae7b517a70565151a855ad4c2786662848a63480fa306f489d42c61e6844cb23adf406bae9911c0209c3c109aafb6c9f1ba8d383664fb5791066d9f56fc57c47f66dd63b4beede87fb66473d7a659e701eafc251fd00e30b3dd36664e842d14b61e349da4f74533566f2f656925cea0378c8e2bfbecc1ddbd8a1115f0e785a262871927398f6b3913779b47e797ec2c71497bb6520fa5560a329c91aad5a7c039643676f15ece5f09f4483b8f4f472e8a4b1060301735606c9811f70f2187bb4862f25f29a3677ec908c6abacba1121d700022521d1ab699d12ed2e6a8399eeebe4ae449e9a18a588e6672ee670370ed9ba90bc14bd766146fc4a8570965757e1b5208055da38db80cf37d6dad82c60aa2c2432feef280ca57421ace3fa990bfa1fe5930d6c121c26a70e75c83b94b1bbc06b93be38385d625f69add6fd02132ea352605f56d152037cc1365484c0f497c9b225dbc36c8e91d9cebac5394c2c7a087336a0edfbf17595582cde9817b0bd67bcd3660ced6d6c2d907bd7c440f93b0dc26782e516099b3c8eb26539edf25f19c2c124a6d992d872ad704accd12282b1c8992589b992b2a1a117084defc86bee22c936be8cb9f97c0ca6f708f53a5214dd5a5cc91253d5509b8db3256dba9f9a8b8f54b5d806f9e28226a6612ccf3ac5e0c1fdd8eeca307b0f56ac90cea3b71924ad21cb2d8f30b05bbe874e51fe64e8b8a13c30ee385b9ae81000f83875d1de1e5aa26b061d003821d2cb17fc8403edd703448f0cdf333a34cd93485aa761d6c51bc3d7053309f4d3d8a97f33614107671da8afea05b71ab04d34c6915bd818ff52591326edb4adb1b477f30ca20a49795f368710025d30a33ebc134a0d10ea3d289464162c460ddd0f66cc685505eb6e80f8095f20758870d3ea811d391271917c37fc76ab3176bdf20838fef80b2d3942e8c11044a4d4741871d0d68c2d54f01a78372799546a070e1a325165d5eb4ca4c3eacda8b3c2b7340c431502fe9c81ac8d182b9fdf83b6256909996c2a331d7e72b17c0c84f0331f120fc3b1884800f20d5b33b1d420892d6a6fd3bdb1a22853d8508da988e7a7e57f0fe0efeba835a6596f910ccc512287b3acaf1a0b24052ef192fc45f8a0e550eae36f75787f88fddc97fffbd39c1ae3fd115f52f61cd56c3c7ce351b9ca9d019d9ba056532747d7797ec616fdb7a07e7fc2dbc21351f607257f28808d10060c12eb42a7cdbd643a148319d77a9e5c414eb686e18f080b263e0fa6c182268704aa3436d0dcaee797df183ef2073ac9ddb1e7efe3fbbd10c59221ff53e7d88b01ef418b975f2c0a042882f6c96c767a8df1b3af9f9b3b4775247cfe11ef0bf7dc0f296cba416de1c0f8957c5a8610b772ec4de351e9ef6274acfb08a957102b9f31e383a77d9d5ddb09f3b1cbbf7fd8332730724ec03dccd4aed7118e646b43edea2c23df80f903de4869221837050e8d844e100fc70dcc89155e30b821265913dc7051deeb87661e76439cf58ff3e86dd0ff815120f358840fb0037eec67ab022520147bbb5e659e0955c30afefc9eaa40c2a31e9d70601e9e409d351c353088d43f506c46820648043636c70c2da8c431d333ebf109472ea531680e93b22144dad3a85c19fb0a100d02b0f90083fec737717cba43f8887d36272becd77e36f30da1696a896461fa4ca90cbdda1735b6e3e7bb7dfc9e5f6ebdc2a1841759585635510c3acf9687b50db05edb168e0bc18806e33ab8a2a79ffbbe7006be5db7db4c03aab7d5128d37339d8e487a0c9e9f22b3d05f6ed00c68b3f5ca7880a1cb89820597f3b55b3545605d03c5dcda22ea76d4b756256c985b5ce15f08bf6a2d4b9a5f451842f5b6f6d6cde3ae30ad364c6212f3e791bac496e4f4d1e19989764764b22e9f50ad940e02a49a1a8e17f6cc16cb5ca025b066bdc97fe37fa8ca6ec4ef9465fc56c3674c48f9c7b5425ed9a5dc4199aa9681da40b5f5b62f15e8c285997f837cd7054c0198a541da9e756c6bb4b62fc90709f0ac8beaf499867f4d5d5392847a8c940a206113b2d34a3cf85b885291c7b5124917c4781814d938730b1b053793cee147b754bcebffa5fbc3ba271af9c3ad84f390b383a5067877ee61941c9015bf9c2b6887cbde4fe43bbfa3e32b89c242c31cefa9027772da7c5e1c7dc813b1e9f3359ca44dcc505f5ceaec9ecba0b94589b563635a3559d84530f9b8e03d572624a03cc3c918a470daa7d77d2ee21efd63fa4a894db59c16583d702b65023eaab016ecc19d96240d72a3eb81732cae696b0d6820e36ebabc5c83669d23596cb171354cc27727d386c35828db42d792111e931d2588018a70ff10ee08e7ef0ae9776ca2a84698da5081ef2b0e0c57aca60bdbdf0b6046ec5c495947fbd26442c66133f248c13d25cc73c83bae0187763e4efb8abf43913e4439441a7d6d1113f757af7eae85be3129b2f4435a460c647c7c4e2a0fc8f4845c5e60cd28b6b8c67eb3a624a513022a2135267cc6f1d954feaa96ac3376288427d1952f7bd589a9651ca8be5df6b68dfcb9742807755499a2dc14a7f87b3e3314205ab2d543c255c433954a9a582389c6d97123ccbfe572f8d24b1ac77e8977e9ba36cc596834d9d89aa9b96a951b689f74c1ebb5e03d8e0cb52a87150972ae88ead7b41d44845d91b5c08b0531ea04649c4c0b86dd87108679686418fbd10aeb09a4c7197538847dc9775402c57637e8ba4ed8131f1c69c2f3fed4ec09b45f8798735ba955900bd90f118224de10cb50d35ddb5fb30e87cab059b3e6ff696b9f32b11b8d4d7fb8b7ddcf8115c3a8765d85f85e9d78a171f0847a080a303a33484b20c0221e8f7f2bc0e4b5ab74e0fbb1f1002de2519bd97ea4ed6ac2d76741532fa1c566b58dc62f8597cee961f04a8e5128139693edc2e9bffdc0e078e2e4af37f389c2c8089060c846038ea1b2a65b88c27da0ea8fb295abf25c99591832db7e14c90a051db813a9c61701de15ce21417d518f9e0ae9e7a60ac0c7bda7db3c54780c91f94d3baba68f8028ea3b17dd167aee7bb386b3608baa68819676bf11b9798e4cb53bc52018fd4b826f51ad73e21232e6695fd3911140f78ef2d9e269afa4a95b153938f4df770462054d1a3a0b0891296f38544529fd313a71e66fed8c5c8db6cd058e8c57bbe593350cb1e9e24bbe98708874b72ff93ec50b933c9d9b8781a2120d31d2068c678e75ddb7e3f3dbf76045827d41517233df46a867915e3bfd1eeb4182dc6d4a2f89e45abdab13593f0922b55d25b269ad569a1abf04c0be05c8b6354598c5a269b7a333b46707b1d2e8cd7d58e16a8d154082e99c8d1d550693fd378561c98b0e9559a6681b5e2db2276fdd7ae9320b5476ea9c9df3c5919388777cdab7168015b8aab2176b007c324ab104adb151bd0102bb8cbe30fc1d78079329583f5909abb7acf71da1554eef569b5a11eb58c3f474f9e7e9e3564d8f2a21dcc62579d89119c4ff5041b05ace224996b64ea2c857b96f55455fd67b184028238dd9b079c54d47ee19caf6c9ca3d7b9d9689ef04c492e1c08ac397c1cb8cccbf2b2cfb76c781afe2ad5e84403cc3ecba19dc1ae74060ab1689f335b4515e0b21f08b61b01bd85f1dd0260449ae19f614ff92a5c8f19e2f3bb24fff9028bb7370fb3bbe46ab80cf5636034cb434a36575dda7bea99a5cc3b10c47284b94bb41b8c217256f1bba67a66ef57e0d7a30bbdf5fd93b10bac1832a2b00b556450647ed4c888b90fb57982b25840f47a72b2bb72a8dd4a5047fb4fa64c3fb8d9fe7f8cbc956fd6642fa1fab345e8735e83b1d3006b14dc0be3c0579c496e0fe9245abf5f1c6b5098a59bf02d88acf660b59089618375996f46b1605d5cedbc492f609ebb2da03aa24c082224ac4adc870df99c074651a6ea209db23e50c6c3edd571aacb869462488193c5bb57475e33cb8b31a223162ed47fb656d3e44806eedfed60abb652649e987dabfe72fc5e106f532ac0f2745579c0ddf6a6aae605d042b43163f82179f85ca7a77824bbc2e0d061e83d348d941f6bd71ace6b287cb4d08468c2fb716e917250163223c70c7f3d2113cdfadca6b53e6d2fd69fffa351278621973c16d42e07504983d6608881a00860b790f6ef68617c690740c63a8e795ceb3fec93961ebf69c7dc1496c549ad2110108dd1c67d47b5ad9b19128c60dc21d0958fb420cb22c525ef8308249c7e8996c40383207c0c814ea94a526c2ef8d2a3fdf03a7cf9e512a17627f22015c98b48dbc6ebd63908d978bd40b53e2f220d9646ca1e76fa8f0ef09df96ba044cbae16a1e2c6a99b6e2a00834b02257a3413e4523784fb3c792a3ecc6a0cfdaba586f88fb811db816f28d3d50d0685a2ce1888fbd41935284b2d968c2a48703484ec436a8c6d679f9714094ff09b5d8ae4b933a877aa6d6d41bdc709b73517a9532802ce69c9dd26b4ac5323b979b1eab4c26c9b5014b977dd393e89e60286f921766d0613353219494f100d48178196ef299cd0bd6e292a9777fe3811fc8b2c3cbaf8e3215ab5483880dd04e84b1d14c9ad84ccb4009475bd3952e8b1ef775988d27bb160dbcea92a3f7719d9e12f3d9b15a5296eee32ef66bc52557a4b9fef3d61a2dac63c1141305e4bcd528062c50c0ed5377b10642ffc3148b8e6d5a4cfa1b196a34a8fc545f6d682b37a87f65de79d84857c0002c1bb34989a95144bbe8a06832640392006bf742652a1e9a17b27359e4dc17903723d49091f1fd6c37f9ac573fc6d7fbf97d91d38c2a50a447a6c7db81d48a4f58924ed1fdf3c1e3f95b601384ea7ce519392485ed84b63054a26da06ef0453174a1819305350d5c0f47b3546db054d440fa3528f8b8b7ff992b87714f464e2c63b3027c4ba258d7b63d1ca4959f2349432844061003654167665cf11e1871440f341e0bd588bb7c68e7753a52196fcd163b045b3c93490684f3ed3192424d93e41df9183b7fcc2204f4747b58f7a88376e740b84bab520df1bda6656d50958ef6aedcfdf2d25a99603158ebffa211d104bf7cdeb4546fd3a8472ae1fe8bfcfcdf687f7a44abba5665a477ff244b834ce59a62504f5c78afb54c6b212903e4cee07c43f4d62231f4f6deb375eb6c5111fcd4c4c6ccd0ab07ab0b3621e2a6ed63d48eaa00f17b5712736bf3565c3088b57421044ccebc0d0027b859a3e31d9f4e22222ad37f3c1419d69a34c8e21d1612f124ed213001b4620a398e428d2b372428249a8828523f3e3c0c5bdce2a47320246e0b529bfbccbcd741fa45b1084ceb9130dc710a268266e27209c45de0628c7a3ad867cfeb6e614634733b64145a516ee757676c76d9a4550046c35feb26e9c31a42d44976cc6d15d2342c0560ee3c67e3418a2fa1e077450ee7c5057cf72f2b6fadebef8e66cfbca12c1d6ab8c35af9a71724be183b12d90a23ec84356a96af8f173b465cd7d115f846405fe2f397242eef618b5b1ba1bb3aabe27b934da2b98cca54d555b10c4418cb1e2a42a66f2743a2c2ec597194798f1ad71ef3d4b6122ad38230a5e0ab4d7a8a183592df0c3924b62383fad7c5ea5df2f4e3aa948e644c30f87c601e898740bff55ab239c2dc10966e0cf2d24c364a64946013c22eaca909499417b84dd80d74ab6e7c2985388189a912ec79a6d94d0fab93d8230ffafd8449be27617cc9e715410a6bbad12ad3a033cfdbb439d10c05b20f7efe823d933c1ef691782fc39362aa0cc3a0ea47c4d16bfd871f8c4ba76e3d9b928b1ba2ce1b6b5a928c073c997e740de9a83aa5b8e8e4d8a92dbe8e838abf43b520dd0e7bfbd1bf5b9d7c172af15d8778694757b105f10013236ae16cb600b9d078348fddff1fab64e26abaa82f2b294eae2f40fd5a6536a8330b4bbc968573b13c3017a29bbc3c5dccceac4213d9e93b581ecf5ebab5cf104b734e9fe5dfa27fb374199b52361467c09ec2c7a492f48231e8d53e6f738af8c0aba283a2bada46622e4b0e975865bce1610a979b78b934b5a4a591f545cff5bc82bcdde63665a3e19cf98c0f11f87897243d7b544c8d2e71cc52db778c0cb54c5c8ca27f7ff971f47dd035dd7c3994bbc45a5d5c086bfd3dbf56fbf5983bf4ddaa50767a94ed5d3631f298eaf10a9133333860ebd5f2a3c032c00909bec4b212d7b7599956b1ed1dab21c6d744c21277d67d3dd6c9164e8eb904f5ac30a6c7cb6eb3c1b01d951bc883be3c76ec545177006c95072ef460eef8e10c9fb318d41766aa9018d13ae40d55bd0620c860b24b69ceda5bbc4d420a6608a37806152ea6d12a98d44ee346235dad77d5d9e9acd54d87389fa08c699390038c4352d4d8fff3728d78a355dcaf91ac717c188ed208bfca788be03210813c55b52b7253fbbbb7feb860171445cf0398c90bbd1739182a6b49b9cce3d222c939d1020114b742a20bcd79feb40ecf15a54cc7b9860af3a76efb8a11fb750e8ef9901c5a646cbffdba583a6e92d7d94051b23f0d538792b0db7311197414d9b70ad977ab7e8c8491ac7499a2d48942baf0419a563d8b15bef4de40fbbd90019031aef5738d119c8909add6f6af31705731800285e10eec8dea87021c40b69128a9167def8b081d57c4faacae2cd36ba7e3db43fa981a6990922f5df6e32fe063f6702205f31ef4abbd018d4b4d9f1ac1e43ff566f1faf93235f0229b10295cdd47cb271025c8f33286628a23c0fffc61b9cac098f2d1c63568945a6edbdbf9355e5511041dbe73e558f53705062570c8d7bc970b6e6700855c1bc91053d0544c336bfd9ee431cd45e0ea649e2ef899e6df2e7ece165543d47ad220ad572877d3b8ee8b8ea3ecbc462c3a6bf84da29b3a4c3cfc4be920fd9d1ad29d87f57aa2dbdf298f9eea82aed7204f7db2d5229d590c1c9f992ed39820690d97354b219fceac2fc0630c175d9933af6c1b576f4074cc2733028ec793292ab9c8f774631cb8d95d442df5caea02433d1f213053fcc1b5731e9ebab7fa046c395c4111c5ce2a2baee3747ff2a357b98d5bfb4fb3255a7dc349c8a8ebc573e0c2b4ef381c4c931b9a94cda5c22757045e5e2d3d4958e9bec058251394a4beee72c73a8c0fb3859c6c5d1bb1ffc0037850713aaf59604f40de11bba6d611f6f3d74edae45fcb4aaa78e63667c4c10c9e34e020b14bb73644dc2a6390748c4436248a1a2986302580d409ade31936a45c4a6f756d2407f408cc441686d8cadf503220ea93216d1ab5a15e01de16411ccd54005e3a5bf4d81a6938e99db258626a4d45a7194f7cdc26e70f88e397c05fd15b5269c4a3eb47f03d113009340d005587850c742e1c98bb32326ea4973d4df13b7c51b7429d818b4c0657d18e39e875ffe2c053471a50650df0bca818ef0bf720ffc43c50200630c458fd670b7896e7b9cfc5d33011a28e451c318cce260669f51cb7649dba72141e34be992b84246aae6086b2d98fdd738ec342145b986744c14d92e437b3cc15874b6fa751f5d40ca3fdc7fb018e8c73df810d71c18f860a8832697459c04a5084ff98a6785154563676d1bb92b39ae4327790e9dd0e78194bb0b5a76dc84f6e50c64a8abbefbd726fdcf2d243dac2bd4d511da75400d8a70698c8b306690e7adeeac31c7bfeeeea62fe80aa04f0157e86930934a54acbc39abdccd6cd76919aad6f10df8da8f58bbffc5dd8e5b1cae9b619716079883c0aef0694fc4f9866d53a2a26575b5306a8da1c2b3aced0325f0fab600887e9b9735c04e4fded2515c97c25fa1cfb87e48dee91398ff5e36a73302ebab13d151bc6198ad6bae2f819f1ad66c40c9ba6360c65d9b47660013da4e157a940a257c5a5c4826078540198aacdeb2681cf0d52f4acf7281519272cc21d2f6b2877ea85b496eb9688ba18464afaf4bfcffd957cd2f165f52140f1ee5f75019918f27898ed5932527cf87c46e811d2a4d1a65689fc81993d50944026e6693fc407ca60f278f21e55960868af6892921b912c1feca4ffa2bdf1704594d2b99c11984bfb145bab5b9e3319c8fc4443c4f4230ab89be0697e34657dae97fdf79451cefc2ec132408c0f05cfbe94638718bc694dc413e7ccd8721789ea745b4c88ee164c0f5b4fd6795eec839464239a209115ae75086d3ed0f0d59fcc52fc6201233666d632e37e877073548992ba229cec543f1d08d4101f6f39138c80e66652e051e6a820543e7319c4fb9a3ffd8ded1b798079c3c8e399859dde4cd015b6d898dfe20165de4ebf17a82be125efa3d5d6f48f1b186e146390a518995ff7667b00c1d0bd2ce5c32c65e6cc207995216eb2912a9260429b3fac14749bafbd6867bce0753cb9c938c480826b3c8aba3b9aee801c4eabd73548332f2ef67f920c2106b581a0153bf4d13fb8ef8780cae699f72398ecc0f868be1108579559329faf2783a13bfc4101824013a229a7d5bd1a6c9de6d6feecb0fc0f5e8c1a5b12b645de61deeb421b15e5b687fbb936500a1ac0351c9980c379986216baf8e82d61e53677dfc9f5450f67d1582a35b7afab80f851c355b7f9908d8ef4b026387b2d3693bfda65331f10de9e467b3b798c3b3a621f823aa48efa48c62cccd1f96520aa6f30bd5e63b2cb8f1dd1d569ed8e617ec5424285888e197ba6cb5861427692a7a88f117db53e2e723f965f51b1bda275befcd60581b42c7e6419608004923d5e97e83c5244f39a37aba6cb1a7d5fff1332ec30440805aefe4aa68e9bcd8f24332247ad9f93f9d2b505839d112b2ef5190189c3a938b457cd96848bd2e03b0f67d84554f4f26a732852dfa77bac40142f9a9bd43d7bd2a701fd7bb2f68881530a372244eacc7844788ccf350770a90d20814f1bac037aeaf736d9d5aed168da68273a21e57192ad5a039f3437a541272197e5c7d2d8556f6b184bdaf78e596e0b9f24a4922fc5c434bf64cdf3c974ebbc9361b4042b4d4499a27fd6d14448302a9e2230d79ddd0d33f934500d3843153d02ecef645645073aea741a20d439677cf7a6d81bced3b148ab1d8bda6112c2b899fedbabe8f5a04bb6a24a0edeff2cfcfe78dabd12c95921a6807f49ce090f8553674ff936004596a0411e7ab3959baac9334121ea3c1fc4b9f67b7a566304e00967da1b3d5fdbd43f35025cfea58bfe64cda340a68e5b2d06ee2f74e31b7aa15682a4c98a3aefafdafe8f08c210581b62b4280fa19c60fc1bd856376264d5e5986931d49fcced975cf13984be81f58f08a259b7640b843fa6a015c7a0bac52967df12d8f54e4690410109355a3c5a77e578c154fea80358537f5265a1a915dc211d4b0a510a467e45d7fbc2e14ff319d77d6e4b17f33c62f6f3e75a47e4d44bd03b4bec7c8e379c9891f702376e43f2ac5f7a2cd9ac6c361dee06dbb8d6fbc1ba4f7984632095b97e439900e39fb0317e6607a594711f1c26acf6f39212db0505343ddc70d6832586dc18feaa548dac7973b505ed0cc8dedba2bbda420dc78f63d09947772def461849f2ec6fa469d9f5fca182c37b77c7dd72ee57188371495b1cda8c4a57ea600d01ab27f3431bd0309686d2dc37f630f32dc31c4340a5e52574c0ba01ec7c65359bf00058fed1da89c49636fb4a2d09c41a207ac7a6663e32527354948416269383f5b5152a84eb8cdc7c382d7311c3e8ef5736fdb84cb99c2e8843073b73b2c301a9c4cd3f8a9cc75facf32bb8b0eceff0310140109f8b11a5704dd8f0915a13192625ecc44ca83d9f2f24428703128b3cc68cd0a12773142ae1e20271a5f96f9420a859ab06eea3115a952890f81d5ae9f5f3b8dadd62874f93b67773edab00c2376ddc71319ec057a609ce39486f3806cbdf59af5eabaf19bda791451aebb5a5dfef22e5b01a2654c4f6708780521ff8c3cc2907bc3392f61e761023bf9b231d92d1052bba0166c67eb6cb9f02315807e57cc88c3d78640857230da191acaa0b0be8df48d30a1311a146152816f0fb243dfe20f691f66d109dc14b07b31eb2b98acab8c2ef00692afed934688f5091db01fb73e24e50785ee5a20bf2d5e96b7f4a09c69ac2c3cb441a4fa5b4e9c0b095cee7c0218faa5a2220ba1dfe92eb40a120110b18b210f265a1c3984ee918608605e9e5d9a84ced54d06492058adcc6790dcf32a5fbb32985d554c6e213e194da085c08aef86547e799e1c97d2c27068e80edeb2167319d2d401d2a07ec77a54d25de21c55530367e8e554633a0900e5b041748757ed1e6a2fe2ae7bcf162aae1a237075aeed6c27312c1354c87842a3f85ed476ac15dbaed279b3636678cb55f5e373ab00f769780e3e6b30bf7a96c27cf18ce131f4d23cac75b5990380a02590cf9fca305fec8ba5ee4f25869a1ead810bf0f87768e10d45169466c2db079409ec4daa7d681e051cf6f4c3852f48e06076df89251917ba94df04fc80c635de6bab7fd27f7118815fd18c290e37b8169a6ebb87a08c8721a940241f8b0c29981b3ac590ed8a192e008e12775371411c232d7e0ec4b075eb639735622731c6aa06539fbb0011f23ff6db090d524411d7ad0431bab0f01fd1ffeecd1f127c0af683fdb8dffdf87b1e82a82761cefc4d9fa4b4f74fad5ae17c621c16bf591a94b1aff81fd8fbaced665e72bce6a92a71f92f3a008b30086c0530cdbf8e319bc200d03db786e559a59dfcdf475a69c39f97302382afe40068c811dba599e8e1c60e4d2d18e137c04d223216a3ed6cbbb7278afa6b372049b20b4544f6aa5ea68f688ef973089ccc7fd629590561ebfe7f44311810e4b40b34d1d4905018432a5f84133e7779f01a203508238860eabfc6d1907a8e1e321b84407c51c0fc34324bc5cc54e07b4228a621ba2cf13eb77b83ebd530c8752038953df0a81ba3e131f8d58024c6f016f6e483263e04f3fe3b6c228d1d9aba31374e47f7c295cf88b3e43011316e6540f460ff5a6bcc834c3b5bb49c57ad3f08f7a9b9330369070db372f80b403174b909a9f1c0532bfbe0541c17570779567fb997972e850d6e42dae1b77bbb7c3fd96fb851e3a81a3b57cc148320336b556e6d20e9fb625634d21cb75f8179988970bb914f566d30ac0442a769ac46c9b4a16c264ff1b41b0aad0d2ba290d3ca5b679ff9765d244a57d3a2191cf34883f49b0a54ad1e33fb0c9c8ae3cb7395128eb761700e531f5dd5ef6d8f11c53b62994c20f9181d84204cd52f96cdafb9373f12151bc38d78c266ca7eb924b6b9bf81f2c8ed8f3bd2ff1d5deb4a6a55e73ce3ff3c811de27d999cb567526327be92c6de332d4d59dee4331762939b8636b7b4e79b3bfab95c318ff1ac931000935e803476e4ee0fd583b7a15138bebf035a0885e2aea629fe5242842dfa8121a15c3240a48b654ce2b7d5f261b8ba71ffd2490c7b54cd2e26b106f4eee6a2cbcbb539a7ff6e1b80305a00523db2134888ea1b2b501afec025151a3c24433650b24e14295173daf5e4a4def33fb5fd91a75946c1199ff77d89c021e31d2b593b4e70cdb055d50f1c7f29fd34c773625d4ab73f05d2f529bbb9a5a43eab8024dcc98d7751f54a4ce159f6916495becbec7238c0a1ed158758b192a7046dd4dd849b1456475a8bb5c469a9fd00ee891508b18f4932e7fb9cd47344d4af080d22f0187537614fa850ad8196b91dd45332fbb1877c68c3bb299dba68dc8d4f19de2d8fd97bb8ec8090638ba0e08b67cffb504b7136033905eefd944fc65221296b1e89017504ff19ce82b923be6e9a746eec084794d7ffa9258575848fa7cd1e9548f78e9797b3fe71c8d00a951d49c2350e530b88bde16741cade208cfe3de23d427d2adacafa0548dfac7f948212c67b5e8b9ff362696fd95d1389f730e0241af69735964ae51dc3edfe8488c9a08daef4a6108fe931f24fbfb76b667b9633d5f6db1fd6857f7299c50ebae21dfc880de209ee2aeb2bcdd37267d467194c5e83cde7a6a859e58305fa2b9789468b6c9065c0e7465f993d70f416130af094d148f486d03b72d00a4b7ee2f115a95bd3fb68d7b3009c24df39c1973361d12cf7d5c52aedbc992b27ecc2296e7f3035ccce094960bf4f41ca5a0ad92dab63e320e3ed3f6c0b94fec0394d7eaeec96ecf17ae2504c6643b477bacc63a4129cb9144a3e77a47db345f96f03b94633ae7c0e19778d16fe3a6509f6ac586ed255c4b9b3a147e62698e858a3209cc76e5eeb333f81b8fb8bf520e7c9fd59b960697d8fe6cf422daea6e5f8f96a6e30b20161e74be9a9fc992aa8086ee0fb67793f884dd9872bfd7070edb5fe227bb2ce9a3db3e80a65c35eba77cf4e5fb96d6e926e3a001a3003b475f2369bd04659bef97ebe79180d41dc6e01dcf873772b152a18ebac4a9763b8a126f7dfa7c2d7ef8ee3cbbf25726a55b6ded9386a681278ed668cc85413ed42f5fd1b18ba694032c79caaf3ee6bf3527737dfa95fadbc54c07e4b9ab1bec08192995ab307b09d38d9643a5e02d2b081619462963e715a58d8a87fee852468a06910f6bf4ce9563be2583e74dc2ee76314fb0769afdb3af9d31301d87cab85e2313209610986faf5ceacf911b2b847d83ab30332c0d328dd8e2bff07e29065afe916796afbf4dd2190e7e5c942d37a75504b19ec5379b9c73768727d94d5ac7c2a4c4b958d9640586c493177c3521c3192eb2c07dfed836707c4abf60561a39f28c428d33e43f1fd3bc1372735c205cf07b0358f510f397f4d3635b91fdcf6f1421f504bb2c024c15cf03a61b256a960812ed4d42c9bfd32410000be6ebf0db6dd77c1f78ba7e0c845cfa16878834f7d4a80872617988e75b0a18023ed89679220b734835a7ef0de01403df121b14c436a95f62806d8924d5c49fca9e82f73c4ed7af4c83e7ce8a3836e643d6477ba3d8a6cbb403456b11327e4e2c8dfb8caaad993374569907568ff0bbfae10e9695f9c5a3fd317261a23833593645892fbecc0d68ba332e9d9f7a7fa1e4a7cde2f1c8aa8c4ad275ea366302c5b0adc2813f9429d810f926e070f2363e98b11a76d726887a33c9b4c7716371ffa31f4d664f84ed4ecd34b4f2061786f18c38611bc02f23ad8f28e8bb0f48c85b91f7ba7ec2f8dca030e7377eb43b506b550e39b198cb42d87c610cdd860a9466eefea2c5f097c47fc56faa3067dafeacbde3bfd5cfed0863b37d14899789dce74da2e88cfa77679deb4d7af3e4d0e4a43ed7f27cbbea292b5f5d2ba7fa7488a05d946e6ee5b5f30d9ab206b30252cda3341c930aba238d957ea3566dceac33fe7998afd3600009811b115d7540a8c5a8823b1ad37ebc36195891bab611a9bdf4f82d97d143c32b5b0b59eddd17f295640f0fecd7e33c20e41a0cd4645019c75b88874388694e01a52d99c08a67641c3fe4b1f1e3c47d41f4d336e490a2949841d282f8a5dcea2ae9fe94755a97bf6bfe40ccb1a93109d54aa216fba9b3e58ebd5e03de67b6e7d354bcfdea35f7807329c1975b7ce4b4ad2992a51e30ad7ee991b8ee88a80610e3ad63f7e4a143d5f094829f38275612f80c2d1fff2c691142e10fdba7709735c710b403c90e1099860cb9de03f33dc76aacd06a8c1b52bc32596832f9e14df5c12106ec31053fc3d89dc2fbd18657c9a080d42e5e6479f9c13bc3b89fc8f85fe04a7ee352aa27bbc58d893d389b0962e09b7a530f619e3144010df98a8af97010b75cf535159a210ad6990cb813d32d3b5f7bbde70d9c4ff3eafdcf866a2be5e90d795bb29c52764315107c9bc08d10410ee5ce9eb56c6cbd0e1db06ec3199ec3d0be7be1b5a66ddcae07a1e00248e775ba68393dd9987ba2aa43ca7300d00ba1fb7118f7d44730fb70dba34aedcc81103a231726b5e410431a3746b12c53c46a5aba313e543467bdf8117c307642e93001d313a98defbcf96466a9bf7fd0866517170eda51f0b073d1c00e0fc29e564da929af2d6633e9c02ac8b259d0b346cfdd0b00aad59f31fec11b5235f1387ffa6b36de431b3f71cf3a806c584fa65bcfb03b9c1fa95c85e217e203ba7a47ba59c992183d0552a0ebe48ea5586b2f2f2de9a09fd952250105f7a8be81cf0a9d63840ad7b45930395174586b695da533327c560bde5bc8a808e07f6d63140b0d5868f14749c6bf860aa0490dffd3a3bdcd354e5e4b72da37ba8719168dfc68d5ef83eb7ab80b17ebe1655ae587ec4bad8108087d2518c65cb6b26db3f3f0072e8238a4955c2c8b1c2928bccfea1fca3ccba49faa99cbdbb230b41d1bbaa0e31fd75ad61064c6ae27a1005caaa6967d11a39509187769e56edd0b8a71af772dcdc04342ae89e25be4213836b4080622b9f268b9cf1d3dab24f4e34a1978fad93ce3d34342bf4d5b4530d4475f5612b50d2e51a1a2a4931cc075fad27841acc70991d7faa5b1cf7960b2cd63cf2ab9afa3e84cab598d7273147cad36b1dfc5d998636607653382116a253256870be0e0a1b7476679e4f00e8b036b61fbe2c8f9c75205a9ac6719085245ef840eed830b9b6566e15acc31f6befbe16daea7b7b7c75f30671c5fbb2c397c2c56d17a246133da9e6bc3c4383cee76866c2d32bc69ede94e85f48b6dc31f7a052452131155e79bf8e03211870bdaa185743073fc36b5cad51ae862566d449b626a40e039d2234c51c84f287cdd2c1965172aff98d961c4a15011c63e24faefcf9ee0cac789ebd613a2067ab041e97a49b395d715aad6682c70989ae40f6218c994ec92b93d6626afa234344f92efb38a64f4d3785ec8167c7f4a731171b9fe38164deaed267dbee0967540438e8a82fea1bbc72d258372e21e2469b3961d64b17287b8c15922ffc81687ecba54d9a54eca53f3f20515913eb08fa804275c5da8015fed28832487f9ffe4dc79fb82e1f20a46def79acbc99a928454cb48b3d20b957118ecbe5dd4ff348a8385c85e1ae60e94e1d0012414cb8def99a0f68e00a7689b74106cdfa21a5acdd575df242b0497f8896354d3ca9e29f1a716abbc3d41a66d54b73f0573ba2b5c9be7ada98daf83fec2a1e59faedd62d25af5ef48a9d41389cbb0a6839cab62e4daac48be02fdf5e96f35998c3e296de6136f211fe05232e19996c56cb8cc5a0a86224385d5e7ddf72aecc4e66ce4d7d4b5c8c9ec2f3e25e49eed0bb0f0055e476d31ebfb8c2b5792a870b2e30180b21dec08801a6038ff82168f98b7e8ce9b0cab0213fa5ea9ee64f15f7a3af2200dc5d0d4b3f37451619d5e740f72508e4888c8c27e8a6d554acf3f39e548b97725148e225a9ffb67edbd53f9847a2ca12b37875877ed2efa0b97c1875fd742bbfb909cea0e3d2ef2d3cc5a6738d4ee60f30015651434a5ab9bc19720e50b6d31fefe567dbfd83a11e108e41025accd69a98c86a878e5af34aa4d83cdae8f07e68c88249ba92d4b3b14040b6d05649a55cfdec46268e93c21c3f91c1f5db8ff8917adaee801d91d67b201f36d8f1021cfe60917e588963efdbc045a5815d8337a315ed904850be2054c01a3b7b3fd43967c6f165fc5b90bdde8221b972c170ee6ebb21cc5990dc034ff66d7dc87b28ba5ec634b4ebcd6962b162dd4df39ae21d41e0b7729c1e6ae79c8f44d8bf93ceb57ceaf4bf57d32238b6d5622d4822a527ee9490d6336c7393d5998d1628dcee3491354f4de23456aaaadab16961694c7ba61e5a5d9019f3a3ce99db5eebfa2a8f378693b30677d783e249148079a7589320b6983d21eeeca0d1c100ad7e1f9b27631a77de080def8805ab8ff2b99083ba6cb89e1cf2ae6c5730b28e076387a647fcadf4bf98c7044b1ae2555848a4d3b7a0f66bfd43d1120188c76951272dc54e0a27d8d2e4b68973efb817478fb408e9d3e96b2d5aab6b0f525e4c4db07e5327d2b40ffdfb058208c2e44d880cd1527c8b15885da49ee5fabfd0ea34ac9ce3fabeea633fe2f0403626ec46057356f7be00eb07a2a5c32a61314c4d97928d4b717dff518cea21f7a367ffb116b2e07e3b01da4d46639c0ca0084f24961da74abbf4139ba8dd5fffec28ca7b05853de4699f5e8b8c697e1945d99a8918d037bd6ad8c63991f41d05862399ab8d113ed79486dc6ccb26f58c16ff0c0c63c5234bbbca130932d5e66cb3c763be3cac19798e2e2100a59ccc40f5559ab3ab2bef8aed8418c2852a096074d9c8969af0920552cac396fe05dd0bb574455cff863074cba0a4418dcd205223539ce5e47b291cb5437683737534e12a0f0aad277583e8a7aa36fb228b421df2d360de2780b7db8278901bbe76b9db4ea696ccf76da4eba40042bbedf3f96c3eb8fe70a5efb6d88f685c444c82b94bcabfda80aa8ce61daccb348e2f3c321e15a977efa74691fbc8d149397094fc0e841f321496d83359be76ca838192ee93082cf725d656998c9ae8c043fdf91d247af89610d82d76a8bbe6dcdefa3be5194c11406431616aa1afd0da631fde3f2938419a12a48c3ded09af2329b92551e1575f2d51fcb90b6dae50ea267395d0b73e5c2d04badd7a33c9e3d91d671eaeead71ca4bf5f3e525f236e0a5eec94c40902f46e81acaa386fc1c7cb810a05c2ce0437c6db41417842e99990235a634b9df65099116b1dc6fe58150bff6354daeaac3d93323cd8d37ae2edbd4f772ef7befa5288e68d92ea33f9bb68a5b54b666dde6234f4965c2480d61542d013643ddb0c1522e8b30b1d919676e50467eed638bead9ab58c21b3ef9afd12a877743ada05c4298c2c7c9d9d50279a6d1b0064ff58c0eadf5d158031e8abca79190c41d56e9d45dc1f0150de61c365120754a3459fc282e07325bafeb3e4e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
