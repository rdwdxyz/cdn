<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c50818f33c18e3896596ef06ef6b44012e8744be3b105d6e918695f37ab4dd7afced42e5774b040f8243481d713b8a3db655ddeceb0e35a128a8e07169fcc66f8b6be1ca11b1f206b753ce25f80e785119b1ff91d3f91e98f08617abca60ea007cd892b25c6adb3fc4369883a065d2036a9d267e94d111fee6490398a1c6ba5fce0d8dcafda5db21dc2c99aaa47f7e4179d143cf21b4f9f4873f5872ad84c2d2122988878b251280ad7a51ec4f9d4ac2caf66902fe8242004390c1c1ea98afa0696504902f963d93cfdfdcd2e75b3331a274cbc20127cde7f0fccb15f5230d616dfacc7e31c317c1a2d60ed1f6b438c6c137f44059e6e88c4367c940d98ffc736b6efe871e72356bd7341a37a76e6ed892ebaec97e8ef81b0d05210c5e6bfc2b53d6741745c5d318c253a42a34996ce0b52ae2e379e2e38882513b7e3ff1b50ec0a344ca5bafd6af90d73bb95c1015adcdb39e2d9b6dbf0d7323f4c63259ad833f18b1deca04a8563ca5dbe58298f3f2e2866bee0f1cec73709701f49b47b0f27bbe97be43fc29094ca7fa8a6fcb18453c81e9edea819fc63d1c3fb822f3942e3689530c8c66baf6d0ff206a261efcf0b311452535191b894d68eb678dd36dccc2b6f8660e8ce7991d9f7e9a501318d027588659d3c6743cbf3d64842b9dadcbb1b0d6d4d9b7d8f616f6056a962fc110ee0aa6c9b28e46be256501edcaec9e42dbb273cebb3a44fc428197612495fec9ed86bfb7659f9758a79b03c23ad6dfa7d65468f63917052302fbb157c4dd2aa949e81def341ca5c3da2f47205c2d80329ebdde0c5764f473b384795507be070f043a9624e87c34e883e0e9824249856e935936c7f1c000a77400bfa89f5b52c9560a114bb825afce8eb5220959f0c0b5b91a571986e7c84298f0b2df6c3854dd2eca124deb001c05bbabb031059a2717799c4a879d14e708ce92d3d38101a1caf1ddefa878712dd508aaff0e77bafaf359d8bd5ccb129013fe946b740e3e7b1315d9610120bcf49d4b7c0078275824c3a2dbd125ff51b32b21c9b7b5fe5422e56d01b5a0e0755204d3ed5788dfcecf0223d5c1953eb9ce82d4b09adaa280ec9633b2837eb910be9da55212aae5d136cb2ce1b87887d3339fc9c98aee9b6269cd66780b011a7230dfbefb3690a0dcf9e4042dedfb7ab82ca6d2a207960019bc9b70e0783adc9bb4a9ce8c90b4c9fb01eb502e0efc0a15794bbbd41136233d90da97f196bcebd014f6e4837d41f55ae3c6fb262d566db004a7c041e3af29a344e97442d892107df7ea02a77863eee8fe1281f5440dd46dc95be3e849c1d390f112d2e59273ea5a5a87e08126bd82827cac2e97ef8f12f44be2328d1628bc8aa544abc3ab0d8511a7f4d40071687372c0d60cd9b4ebb976a172d8664afa6437b76ed1192f4a26468bab993b013ff3508d7777988b8e797aca1e251dd53b88e67c3bb391d69fb7399eca54ed65a7cac6a1ffc299280f905ededc8128e0cdb84cb05ec1081ee8164ad2f092b6954dd116bb4c4b6b9e415b1f0e710a7c5e493e2add8f8cef5c15ca2da6327470cdebcb0348299fe4db0b9b7ac57d6cd495a7f8bed30f84d51d7aa6fda1e8977ca994c27c36c1b4adb997f3988e90dd9d4f6f058d0b645c7e1ba99de7268d397af2ac90e8813b250826c5d9c3fb93d8144021851e952ea8aa220247429d85327a63aa542bb668f46d11f4c246191941e7f1a002bc8cd352d8998ca8bfb884784e002af069cf6529120061e25a35ba08bce50e1a81af25de9201b71717df8882bfc3e4ffdb84eb006d93e5253d8fce7ca01df9d07105bfbec5790c5fcf9a1ec49e9107f4a1ed36040683f51bad78555c331004593ed00845411236ee4d870208be7f94000e24b8f674c893c50d1c95eb5f34eee8cbb8fa5a51fe36cc5ad7d56899327469495a70a6df8d23ecd5fedfd33eaa6d0ce6c0546acce6294f8e4ce575d212b5f8586afd01058822b793e1f10eba3fa7e5a3ae07e6d4f3437cf7249369da5274bdef1d9711e4addfbda751e2fd2972eaaf152e3049265b82bd2d04a543077381582c695a5698814c4bc356892e6a2338daa441fe654f16ef01ecd84951f873d025a5a29ffebba229ce62bdb7acbc0edf3616a6dc12e5c38675be66adf83babe097c3269c2fb506837b78a144441f6b52a89ec47e05e920c2d3b1cec10d97abe4ce9f542d07ba2fb52b82406d65c8824392046e6a0d4cd852c6c1cfc094b46f6e0d1466953e516645f4617a147be6cd9f304130ad04e8c35b20d342735da39f8170d935f8e4f8deea52b0d3042937c51611006a3cdff8bb84db9b3e2f74e8e3c9d98674bf91e26504afec4c78377d85034caee1a0b8c150c126d775594c160bc25538802e6ab23a14106be3358e887329f3d899764d2edc607ce2cc899561f7042886e759beca6b216f27d167539e1a826885169021f16ce17eff6a06c372219e7d03f686f64229328eac66016b40e0f2d124d2a6d2d6c9bc4e6d744468446f06f27c1c6f9df9640cc7fb36eb413dc02cf0c7ed5267c8e775f4c6490384845f6f3cc220cab486d97d2fd8a51a02563d5f1cfb345d337fcecc5ba1a8430cfec5f1915a22137a3b19cc8c0dd6200d9aceb74d0a113dd66bee7589bf761af4442fb57b6a3e135171d7bb4e5873162b0780b10c14887bdce4dfe78b0f516e7552fd9921a2e20bb71a5811147b196677c874b313ba2333c4d03ab49796da55982477f4e4e4e1c2be6566c108a7f1c21b8f1ead24fa3a41f903ee9f194f73387630556d929c3dd6b61cc65e8624e868749fa7da1c4690b05271dcb28c1e373bffc2363e704b75d842948022a40d1bb53db5ed2ab17f610433cbc43fb7514fed4dc89048cb8e9269787e92c9607c1a6088841c722ae2259dcdc48afe1c040db026f1a9c264ff94c5324094283d911993fa4a675d4f8716be61b104d88b908e092302d0b45ce4a0adb8e9a32af770e3950b7ceca062a282b2ab17b06e0bec5d92c591b6619d365b1aca76e8bd7148f62a1b8780992a4af3a6eb1f11c9ae3a7c2a0b1f31036a938d8a47d13b7b5694988950310009fdcdab27c786939029dde41bf8c6351a113f9f61dd5aba4a0f7d7aca3ece9b6f56f88b389b67067baa0a6bf9594a6df2206fbcc4736fdb7a900e41fa2d8b9ccfa274b7898bc79c36474d89c2a6298c57dcd7b45bc9e028365e9a46df0bb7b246e803b21029166694b65f183bdedd9908b7234494e404eb168577145f985e122155b734d10f483223d5955b20d0fee49315339000b0f6a086952f7cc31f141b47c3bb19ad153e7c722852663099bf4ef0ec31fe7a7d5e10e703f7f75d27ea80860faec017c0de2a25421e074060ba683e3596474c35df217b56747661fa1e07be8a3a8457019f63ea3f7838c15a021f0ec55b7a3083347ea146161d80bed370c7f4d4417f17a62dec310ca3466dda4c81a6c368313d7667a5034a95a7b9c10e8d417e3692c1acffc4bafc5ba3d384181008b772da31d41ffe3e34162cf5c732ec54ec7ca04a4f3d2fa5407a582a913edbfd0ea043d86d49d74bfe3630735e8d9d4605f30b7c03f7df0b1e6ade9a9e315894004172875f22cd88135b15cac3b3e8a086353224f65bfe1c658a20d2eb40035093323e7fcf188f9aeabfe6519b3c4274ae51dd5637314ab1f0f33987e9507fd15f2a22e1577defdbff4c4dcd0bf14c26fc9c98f2e2db2178cbeb634f9e00174e71cabeb7670cdf61a1fba9e5c70c76e0bd658a2a357bcb60fc3fb2871901da69898ff8ed42860bfd889a21010ccbff187b7df8474b5891b0dc2a15a716b266c079e3891b4d9a30ba82a9984df1dc0e4995d2945095f1db2fd8912911d82da9a07dea36f27bc152115566cbaa3241c99f79483857c37ddb95c507d7f819b52efcd95d5d684c07fc81f9d7b56c3d7bcd7c5f11494765509b5e81597b6d22089f2340c5b7e1a6f61c16b080b6a731df8650e56b8d7f94521941cfe8eba194293824f6799890dba37ed43fda4db73dcc8c2c03bdc0b823848da1e02a165ec2b51f93702fccccd92eaf1b0e16978ed589570ded4cc9921821665bae2443f0db061d2a4cb3ec0e683bfd0a0ead3ab627a6359ad8af136170961149c0a96cc94444f0eb487e71150cf44ccd44889c3526c08f0ca88431ef10b34804cc3c06eb9abff7a2b98accd9e9fa7968bad79314bdaec781f8fd482e8a803c2714c40a7e6d7d2d4583d5f83d8bd4b30dbd91ecec8c8a81c8fbf59d8ff57ca945a96f28e1c518630c902c3e89982394711881f6c684ebede90ff2c187083599e17ddc7679f1957d6105675d1ecb3cb12ffcc841566323660488145c20becc2938a712697b532db1b8c6dc5cacab407aedc1a57208a8a183e21abad5e8c2e070a2ce4ae12beb022834d7d5ae9682740de7e1a99e87de0ef559a2199f8195e59d0e23164f861897fc9a3d392fd521774964a4850fc84fde2b0cc55a5dc98c7daa978fe51ff75187e22c262e26b213a7c2e0f7c15090e0d34f660450fae6bfea4f24df2d5f5a70d221843902bca0b7ed9b96a86c5171d2d296576716d39b5698369a7558f45fbce8730c907306c9015beecbf02d80b71a138e75aec3ba706685ef26029ff617589db109a293a3b68ab3e2749e5ea5d284c28f24a2f69aed00e69e4d0effa10aeee236f68306f2bbbd6e8fb7a991b2d8740551167425fed09d7e2a963758ef22cd2f3a2ea79b1c320f5bf1d2d5651cc275752a3d71b9514cc220b9437c647d7bbbb179a2d2a0690bcb641e23bca73358fc7636079d475be1a122ed1c1dcb37d3d830a01db8a7b033513cadc64b0fc978a0e36d60cbcf3b7fd75c6407a1ee3b79c2df6c3eb4762d7dade45a4e4a0450353a57cc0e02b2d5def8ba204413c6f4af7197e102a9294d9e8879e28e54bd9ecc2c965ddd9965a3b307dfe4bb561bb82af9cc055f263eecccb573c3107401c1505dfa0adcededfff9d7a4a9391924b4d44f7cf9757f182c5ee0bbe4317ff89ab002ffed4182ac678e4850fd613af03fa959570376770623987ccf7be9732c4ebdf15b1a9bac19778ffd470146b4791e683f456c78e3c71f62b4ea7087e2e273fc84efcaaf5873f4b44c3355799fbe44365464b7e60571e625b17561281087e65a5e49872cfb0e22c9a4bb4036ea4a9545142c5531884545589f0e87514f110c3f3f18868b3858fbbac645d59fa3fe7689f72469e647038301d504089a24a5dafb18ba37205e38bd44a4fd75a0fb68c821a738c6e1cd5c95b4ee96988c6928a7062b3b59fccefb6815d61cf7f3496c1b888598c477b89082e9472c5b35070398a58c10edee1d4650ccd5ba388cab433a422f9d3ef1f452b602b8f4bd84a0dce5354f78b789425ca3603a009ba4c64152bcf57ae3c29ce9dee74e2075127ff3d7fe6bd3425e306266ee076ef9238d7bb0dfb957df349a71a4a0b5763ee1bb5d10a0441450ea2458c9850f9a3fed2b9b72b2dd19b4044fac8ef4682ffb99efea9799402a13d004fe255d7d3ee5d37fc3643a8e0fd305b401b167682a0c9a98aada6a3651ddec4d60809ef05a463f6aeaa8a040a4aa6a7849559986b5393f7893f9e4423401f7bb2a3c8c18e898bd3c7258bc674a560d4d55067d88a775adb26887401d4d56aa2af49a523d9e495a6bc2ac26bbcfd3d47cd9c90480c7bdf6ec08ba1912ceb3ef8a55100ca713c0148fc7f1a830a9d5c18f87f899cdc29bf65e9965de8228e22c6482ee6e4ff087471b38ee01d2f3b466a4df502ae693143be23fe55d6b29fc078a43f606d14f5f90fac445229a3bc7747911586c205c4ec192a0769249cf1d980b999c89d6a137c84376e9b6133fe7c8372364d540143bc68f7712022ef39d7da5db89f891e02f3b6f12f29e6309d1b190ad8300159d10e19d0d8e7386dd72b225230a038aa0a8f659a0eef544eca688cdcc972357c7e8f43d7a6f289d64aa83f4ee75acedb0e1081fbece36483e05252b5ba4306b9731ce1bd1a78896062184e651017d6fb85da91b76b6c43fbfe5c00640f1c8f20e82c9a7a0a5770fa8f8b81b9673a3cf21c3188fb20b9ee1a4d604ff3271e0089659b7e10039956e5d15e6fd8a2431f6d32a709bb7324934fa7747a78e987e03b5e64db2c9ff9570ef401fe9a23f5b902771a95f40739e90e04ac0add0126ec8ec654b524733f7f573ec0c854e3074c18c693801061d4cc27c486d541725cf122eb3a8558b25c1beb9363c5de96688004c67452419ef920ddb8e2317cfa690b7e2339e67291f7ef4b24a17d992158687b70262414659b907bd01c5f21bc99a25c5bd93fb9ac726266429390c7eaf9dfc133c75bcaa954222abfa5f83229b9137fe3d38043ad7cc78e5e8382c5dce7589d2ae44b9826d93dd985aef1247d07cd75711777b7520d1420807a6efdfad4cdbaa357c4949d4e7e9ec166575ede303ef5398465c6147229e8330f8cf2971e10ad61b19300cb1562bc6a24d12bf133a8cabc66f0597f9338b587c5919774fd39bfb5a7868367b153cbbd42fb49c5881800b81249f45640d361f8ed33fb4484a3f4e5b6741071761a3121a280b903f981b6084da90fb0a12a9662093f5119d476a0f461fb15bf5d94d97fd8c7d16b7506281ef82d945b12d556097f3e96cc066789b3024128d4f5c68e665aca8a4b27dbbc52c8187ec3997141b9dca2059af109174a694a15895851ed131f4b0dcc233ef11f17af1cdd954c748dc3252957560b4aff4ff54ccad0e761ced0023ab628363d883fd2bf5f11bd5fec62b9b9679e87a0418a3740f9d6bb84e2afe4fb49ec66ba9dcfe3248eda6be3683dc2d56ca9be8e7302d00200c0a930c1e80d79e1816239417237f26682948a30bc74b2ba41571e0909ac9dbd99489583a0b0a30dcf46841011cbd009ed03c7f9f7b38b2d6b168838659c712850605f68e86a5ffbbb1c93e0fac22ff7317363727c143f5e1c025ebedd38fcba258f4eb311338b84f13eff7a604c625b6603062ceb921958f8e89624d0f302c1c38038afd659f92bc3db44c0b68eae4a5b7d36126b2a35763bc8f1f5f271b82d5eb7a4e0d6e89bc6e53310e3ba68d76c2f2b16d9cd5f88a3585b31d1dd99334550c2d807f0a5310c47ab3f3d8eab1c21ba9db62276b8b444eb64261b6a5349ddbd7587d8ba85caa52d307bbd563e3109f7d1775f6ca3f9edb86187a2a4379e641b0adf295d69b9ee337134802e424fd8a2fb42228da16e93b13a57f3ac44d48027063ca746a7596e1f673002916810fe28980ed10a2b6f0c2587331f518d08fbdf6b5d6291d1a9e5717c0c193b56c2e37ef2202d0d5282cc411dc080f871fb1c1bb0e2bd0ffb70e8e1de7dbcdb0b4525f5b14cb28cfe41cbc016a267eba58f14666eb54f4541d7d7ed204b99491195531bd38387af62cc49f2c05312ccacf6a65dd6a6f3838fa1548bb59a337d666764f3075f85909db9200fe5c6287e3f61222532f5a262d5ba496910fa6348f9bd14036c20fbb55751b960237c932e952f3625e2480d1f1ddcd5b203601984357d39eb4c2ca67358e5c0efcc8ef4600fba869a499768500c280ced2b702f1cbd00fdbf57355f2dd9167ed11618aa2ebf54a9b39f6ca69491c17907d491a333120feb97f9bdbb0309df006277d03872f322eed86e4a88d27fb910fdfedfe182bc5583dfa918b4bc5f9e6b134b6f2fdac61114e653d9d03a21b4aab2a291cbdcb8b6e95fa03a725e056bd7a01d5c0980d6c8bc7042a768cb0e84b83ab2a0468f5a4d7ac748a11c9433d1195b0a9f8470652fd5103e642562e74156374f6d1958a4f5a22105dab5812a138cce44ff01bbaced57ddbcd9e27a52f065e82aa95afa6deefce2a0ce6f93b9e3f0815114e208c18f9992e58685b2d7656d58755ed7501ddbc1e7b2c0d894559a7e6b744f99bbacfa63200026291a9ccddec91751422d858cc0f4539c8c2d1f32bb28ff397c252c84a3eccff1dcd4c096d0e1ecccfdfde708258808e4af9e2d1a399461092e478358fbab964f051b0366a2b33f25cf3650c9a2467c37c7573782027154ddc159978ff5674cd9d816dd127a794cf03b1c5c52c04020377d83c76055e50ad17058ef009c16bd48805a0391c95387bf72c54cb70355750606a5363915541ad8ee43c83ba3a489f8102a87a87cf5374f8c57d3f7206e501708c1797d0c1ab564f3e88d132d067d8f1ae37120368f4424c2651cec18e65ffb16dfaeb57b88ec7dff63ae2ffd95f7c359cb7221180c6410344bb19f59a2add0daa8ab95a0210db5616e737824394bf45fc682b378f552ba9e3ec68decf0ca9d0463d107d0e152c3d7b774577591109bfce44f1ebb22c77f7568f2430fb4d362fdb8702cacbd6c926ce99de547c962f5285fb7ee569b59798fc7d7adb2dd3c0341c905d8028867fa3d3615163c603e7ee7b59dd2b1a4bde52442e16d8c3911a1d6f4c9b1e56b0269f640cf69be7e127b7c81f530e71f7a100dc1c16ff84e1eecba578f7824f9b2c0ab53082c85c18952cc1df1b746b99f4d1ffb03d7ff5e6340f03247917a4a1461935e385909f095f177946c5168799dbdeaa8509d59b4b453c32c214ae8b4d43f88bc544a824bf5ae1e8b4b911ebd2e80045ff198a77ce4b1268c2e9127077bf19d156522ac08ea6f11ac5394a50a1315817830768f691243ae23914d52a68c279220f727beff264f9c49202a94beb1942eeda18638a40fab3d1b8074636a002c692348e1b725d92497996e40d4f9ceba008bca8a21a0aae6f2cb973138a087c2a5f83cb99b047d651779cf020c0783246b3bae9636cd46a7a9182cfb5eb5c3535b80bfcff80a4cba286db6f96096774cf05785d16b4412440e2add84d0bfa8f98d305fec4a15bf64fb2ebe8fe7b48e2095f35df65a80ddf483a5ca022c426129830af8ffd016242ba510d799cf2970ff49ebccd6369414e4bc804cefe0ad558e12e3b4728bb0f017005f2fcc702db934247f1388a699bb695b18f8e0cf273d1274cea17a2672b9fea0e0155b589213600e9b6a4accab4ba83f91bf555091bdd4493e685487bf0c138cf9ab0832f82ef8a48096f885c521249d96a828a7018896a0f1b048e10ba534817da149f16b623febed796ea664db4741219fc8fbac9c2e6864fa636829fe7f4e761f402616aa21ac6e1d27a085d26bfae1ac6c084383e0a7e1881e38acfb0ee9f4186d2e36af4f4549f48df7e078cc24178cdbaf0ab4832c80ae4f027f7468f14a9599f7797327002c93dd620f6070e8e83822a7bc548c3662d7ebea1b12b6caf589d3a1fc0df85ca62857f837a5d9a8cda74b6aaefc3511a18323e7ac9a1ead2dd7cd1a2069d5304edaa862fa57560535242480a9ff0c602e1d4acbfa10983dc5fcc7f35615a4b9ba3864062d90347af83d74b2a6f1e04de916115a2dbaecb81bdd32513c9998395182f18205775949deadcc1ee3c340156420c7c81de45750f875c504a6e53879a927e6f70af4cefad618ce7853b763e7f070146ae0dd7bc99c916baf76d31c29ebd6482b1813f97ffa0d9d9b70df06dcd34fd2072dc9c45f8337193199edb4662fc2e116f9697abbcf721ecea02e1277ed05005f7e51f34e667f5d35f22e91caaca33a895e90305a7c33f8137ec0a02865ba58515df62c1d63e0f9186f54abdb3106d4a3c8ae8c6f1d0ccacf1de8d2f64816b9972d6e3ac8d3c3663ce0c653f602c075df536622696e87a77e7f91f873c1f494b16d3c0ad30172e9e5bc1ca30360bf11057addcb0832fed7aed8e6bde256309f1f116774db4c6cc47aadb3cc738ecb965dcbd9d389d3e7f252d2da93cad0a15f8e5ffb0fb3123ebcd45d67009272efd777d6844a52e342a78e2c31b8ab55068fd4f6342a80f76ba8a445a904b78e41e9b6bc5f9f3e064e41a1c84e656ae7519a47a9c2d2b5bead9d530f7069962dd46fd07385ef090e172f6ed8bdb21ff679929d7ac98e9a453fd9f141cd9b20b4f56f92d0f2b89fc214526cb0d6aaefbd1c18015ad2456312a424abdf502f11ccdf8cd61be87251cf848ff01398fcf01cbc6f91d3f7abc4fee9be64c1abbe37e23120715b06367e46b6daa17a8b8e63a0fbb2f25bdd87e877a81f4b9761ff1333272c9ecaac690bf4c6ba352db6a5b94ca1ce1c693612d2d4f997f6b82b054c8d6bc474e627299d9a20ef80f2bd78c7d8ed00b79367e032bd24bbeb470760e690281ff3c22885791d57aff4b2cd6eed272c62bb950803dc4980849e069df81cc654adbda5777aff221339b110bc2c6cf1cf76edededd55af1f7ee160596c8d55ae762a7dfb3b7007e8f218308c1bcecc09a44daf60f1043ab3216294a7eb09b7aa3ded31a9c37f3047a7aa204173e4fcd8007227442fb197170b32acb335ee1d8f6fb48da9882c0e6f2e36236533c07ad1d2e2a7ec77d4d262ca2e70e8a9ffa7349fb64f8327d9dc1f9e8d6702b97eeeca96c32f0ed3745787421bfe5090758505f4cb581f4e71b198e610cebcdc920806de520300dc48751bee58fef680790cb1daae17411b54e787bfca83125fa0b0249634217777f0317b272ef73cf745fc687fada9bf13b4e78f8d741e839e3d78af489c71ea7589fa7202259d8f8da038332523b2a72a00fb69faa5bc39f1f1d92169ce3f9be844208537cec87ca9a3f22c410d7ddbc138a6482f725a026f34dff2a781b4d2ccfbc847ae315c36e86b9ec25406f60dd3ebd0b187a65ef74c977f9374fa87ac4f0401f5146cb7656b3859bda3999d383fc07ed89ed00ca72c15812c990df0ac8e69f41b04858804e928a75dd4e7c28ecfeb1c13312cd09c07342c98359c94be1d6f124d84ce0d26fc20505650b17d0eaf6413ee17d1878f4b2580b05c45e1c768b28f50220fbee60ec223602ef9f44b698616a99fd4504387dfc56820fde396c823bfed2c8f9bcb59b35c69293b94c66b3134dc37e41693632deb01e77ef9ef986b9197f6b7e1aecbb27f2bdd25284daf5038f89ea5e2b3d1c38850234f88569ff4a8dfafd04fe8f4d5a8ba68eae4c985be5055619918f0fe66b2c01601a3e1ed6f903095821888adc261e999a927f4bc2005f003b27e686872ad92431e5f9d25fea5e69c31e258e37286a1508b1d1949636bff05f26bc4bc6ab6ccce10d00e227b4e125ee9dd739fc65231539bbe89d08663c906599828f039ff8253064acd3e01bba20f1633146e311a20a3e2e08239fbddaa17cdbc46b0f3379b61a855c7516e2d162fbae1c49334d504d08314c34b0ab05cd0053ae1aaceea4c85bea804e3b8a1cbe914b933e2ae7f294fc7025b686e83767703c118d546499be70e994aa1d0038e8e80dda7977d71ff4ea663a2617334a810539d6cb14b9f05ac0241e27921227f261c83e9da334e65e1bdd27a6cf5bfe600fdd211d8bc02aa4976d84eca469ed073a4a744e9cd89197da93cc2d39aa4f7fff731dd3c1bb3e24e623d16510f655ea8bc951f28338b6b8cb2c09e3dd9f4c1eee1e3655e09ee594062d6b7c16e63f8e75bcbe3a88da413cd5a7a927dc54e628e5f36279879b37d0195d9ab0c496f34450520b5922ee1be3ba9c6edc48191b3e933431a922c894871905012e9fd1d4376784162b28bc8670e3671bb4af5aaeea075f44fe4c058adb321c60fc28cfadc45548088d191e3e438c7df6e9710e5f902acf997d78c8166e0eacf6db841f46e3d5a3c18c9a6a6b199456cacce4e07f15cf022e2c6a2c3eaecee5142ea643ad15031d8e04d3f4fd5858c332377af56e5f68c6f5c1f1b838491e311e55e4fb138d93f6db370cc741d95367a18336466fff34eb7e7c2831f51762e0245cf950ff2b2c3713fe4ce8c0a86d51e9e841d05e82135006d23533a69bf6d579e5fd4aef79affb04cc6e6bf8ac827e75c3c274bb0cc260b5f9e9178270d557c2ce1fb4f1d9c659d1114e400c682ab5c6d20af790443a8821a0eb87b7ec978be6c707193b2ad090aef596f10a289db7df1af22e66d67fc4f87a86af86e4e8aeac822ba8892c657d70669d13dfc9b5997cad922ee4cf937e1c4dca1a10fbe92d69c1b3049f595bcef5aa3c05aaf07ba299ef4e5d09430a9aad9ac085d70233c519f036cdded6be24d3d7d8d2d3fe1ffa7c3ac87d277ccf4979d3768dd6339f6d952e5c121c06e66b3aee68ff8e168c86d6ffa0265641fd192ad56d5b45fe7518fbde0f43e7f85865cecf727379baaa5ff92f6179f473a1370a7149b6f80098256a9754ae4411ec6229e1c147d6413f2bd36bec056114d6399189cc359d84dbba78325795e9187bd78546606d8e26d4e91a67ef0a5ac93fcc885dbf4e6d872d24a6c311d04f6936f48cbb2ae41a4a980acfb23c4f8d507c9502c03d55db9671f46cd9c2c8774e6c08b69642998c96951678d37f5a476eb92b826d16c16ba057ac047d28849f7c0c8bc166544d83e75d5864bae40282e5dc01fd35a0a4fe939876affd7ff59ff2ef2f7bf2679ae2daa900524bd4a5b409a469775e8b73a8937a6f9ee2f3ab757b59b977f5a49459b350641a57bf5c9b776e8b179ddd2d4c2f155d9945daa9dad0789eda75fadc175c608af1ad24a8d26984fc7eea03ea85bebe33f004c725fd82a5a44d9fa17e72a3ce5375030a1f1b488d9eb0ed9a356bdc48e8cf118e7d0a3056cc1a786db6aab1eaa7ba6d33fcb0a0d53e7fc20ccca409abb4868a943659c1070fc5ee463bd9e82d4a92c625dbfdc1e60577b2af99b60aac3707325e6ad9b542881d0dc96d7fdc17e0a5481c2c80cacd09396c53b0db71f85c87e2720a1c094117a6ed26013ac01abc78a68093cf2704b6e53fab1cc9d60387c2a54250d643148fbc12cf7d5a64af4bdee7e6c48b7a0342445508a5c1d95543602715230272c268aade664a30a6575a82a5820000f7f2a9e0927041c21ff087f5de80a70b4114662607b4371b16c919eaf9461eda838a2053da49778c6be85442d8adf09f8919224bc590fc475aee6065e150bb0caffab420dd6b43d5ebd46d2adbd63f1a503c820c56270569ee0473c34dbf7e5a16337a9742a8a51f1073651cc07a2c40beb5f72bc71572d683fecf8b30a4d86c070b95fc34b07c8c84f6f1b75fc970ef2b6b6748c4b5af6c6e319e272f3e3cc37258d51c1b3c24c2b79306958e00519126e067204cbf6f85bc5bd06285fd2caecf6133b2e338f47c1b6af3390708be0bf85a5fdee1d0c0f46bca27879c63eaad6c501bc78d5a9ccdcad6687e48713bfe03186bfb9a62da3af0c159716b51766c08fafd74456b935d10cd3d61f3a69ad3b7e55cc240940c6dfedfca59f7c9d41db9d64a8a26910256fcd45a1d63073c455b6de632b6ccacd151abb6df7aeae0fa675624d03808cf69e4808da3d8dd85bc09757766b7fd05cdf3856864ccb1ed2432c6e02f8cc822ee71cd31a5f2abb8d9fc24b2f64be5990f5c8d193cef6a9b3354436a7cc0bed67a73105aa37b2b714691419edeaa1e8a712b577c36b6691871ed8d3d7718ae7abd1f9e1f7ac47c776f1331ee918b01b07963787c70d6ed1f6a40733c3b0d210a1bc8058583a97bda533e592ffd3bf35b572ad0a568cfd23438d006e54f5fd7d0dafcf3249dee102b7a9b493447705ced54702ad042971e7d88da3d50b2895d73f3baa30b26b0edb359bf4d4c8411828264d9fc0bb5ecadf190e49209c0fee16ea6aeb330ab8a6b404d00907bf825d7c281a4004a6702f65ea1fb7af2f424c522797cad18b8a31fe8f8b7bd7598ff3a9ec143b33fb65f7eb6caf845c3b32d94b37952b1cf32282ba799e4fa9fe3f04825f22b4c58d63434bd87b199f203c077146d7b6e2f62858943e1bfea0148bfe0398d4dfcd2fe91bfd9dba4880f5be0cb78958907a1db6758820a86c4c64d1dc0e427a25285e2cc8e695ee536412eb4e93c46cc3c0749cd74240b06f91ea645c5c3a2784c8a0815eeb0f52b4c601afc36fe7191c9c675a508b18af3d90dee023b9cc9df88dc717ffe86c7823f10ac84e72269d4ae5689df3e5d98702a50439f83d32e7d025cdfe855b54da58656665e60dd111f3071c5c5c3b9879a00b73fd76c25be8f393e99e981b33b45798d669cf05732edf7ef5b4c2d35d40fadbd32c32d2722cdb5399821fdaa851508ee1a1455541ecaccc0699ea106692a797e1d77f2e5161dae8bf9fb31945876a5cf39b89b85b29d7a98c808c317076cc9ea34e8a109cc5add04ca5d9b56d30dc72de19cb0a07d077d83893adaf87ce1cfb3da7ab7873cb292d909f82d1526d55fb9299318732dd8c3b513df64ca2ebb748ca68b394b6d2338562790de378e70ebbd5506b7724dd46b53b4484a0fd7da1027833941fa6cd11055c0ca4a36c4397e5ee1c9d7a009aca8d6f31e0c9bdbe2639094567dfeedcc7cc4404c1b621e1ecf4233081344bafffffacab11e3c0ddfc5ee41ef9f1415c1cdb01f1245c68db549b4ab94e1f810997d0aff5b0427db63456805dbae409bc0d0815dfabd8dfad10f5c62460e1f58a681b29c8ac39d37273ae9d395aae2dc761a8f556d0f04cd7117508e4afaee041f938ad912f0d8f35b108d2d210110961b35739ae29b57cbc6b0b3ac88cc52d8f9f81039c4afae1edce31fbe16c62dada72aa7962ce22b7b5b18a103f318b423bab9395e81c6e85c752305202ef456196741ff0a4cc8bd4f34e74dfb6b5ebe51e90c4b55da09c4ac86568f597aeb78db144c86caf45cfb392ab073d170b9b119dbba118dca0402498ce1d02c2e9f65547d7aa7de95ba6bf68e204b2a1d414a9620a90efd92bcf7b0ee0c42d142e10c811f32c0ef5e8a32528fe9e4f2c33dfcf491e60cc1998d5b221f05112ae6269359dbd736feab6bce1c08e994b3e3cd6a5313fe87a43c2614d44a3d720b5848fb9e0aca7c32c7c95b85cabb7b925ce163c353deeb814a2ae4e1eb815760d6622f555ea31ff94652ae8c24dd678eabf98702763b55db9b4f523e4d38b6d584847b1818db5f077038031f770db941241b4d259107cda679634a3ea00f9923ab40c2921a42d03eae132babbc1af55f842afd87d5c8089a3c20323e39ff92b65a7bba62dda6ba4bd1d7895152feaf0b468d5edfe61fe9b736516b3a45cefc4fe92a7d434968424eddd9b0c62029454a68d0bd33fe41aeae2d3d2e410009a47d77ac78a1bb815a4d08ba082d298f170dedd131495f617155b4a241128a3be1077942c59df483a4f62ef390a1e7c41ab8c49503e98873bd967ec5a678c04ec1bebf822dc57b190284a4d81926577e83e8a988ad27c1a03c1800afbb8f6fd8947518e9d4da819578223e96c4e69119f93b1d94428e3f501b5e60772bb604706189a8bc9c97272386e4e9f9745afaca3b1959556d261f84fd2d942a1efd406af0bfabdf264aff218f6996e9e6c5395e9445c07b511a2e0b4e1b2791941fac5b5db7e835dbe6e96c2ec7943c730d7f64e5d3bc105524077ca1742d168d9727d1817363c234c5baeeedec32c7b1c1f888abf8f8fc267a9c37ae2acaeeab8b0d20627530de140396041f483dd79e8bb1326b52550873b290306378cc3693918ccbd8e8a4214162caac1ab36cdea76ddd337a3bfe6018205c2e0fc881643db1647d3829967b73d8e2b230a1d29d23adcf10b5b2925f6e68d6f66c1469a494b61445e8a8d187fe832ad69b7c13e37b207b5408722bfb65b08592b390bb2ad017d689ddba771823e560ed85bd6d4c6b939f210a7a169f1ad047bddc1522662eb5d07101a879602a50aa1243e8f4a594d1e6e8c4d0b3d11107c03f34e35012e0b749cfa265d3209d89d5f1e441bfec0d5382998fd079c1e0918b8d78e478e014d45da32b4b95aec7733a168b6b09886822ed9b86575ce6b602db61148ae07e9c505977bf020fe8b3ffbbc569f2c9ee26f7254b3adb51b2a06900fdcf7ff3e29c8fad0e3535d1cbe2dec3a7e95ece782b0210625d9f1d3797c2a2e504ba60645cb8e53ec7ba38f38fdaddc0c572336ca5c202701accb2cff429a81d90643d7a3d6635b08e7d015498fa99da0898395aac831589c91d5eec74eb8fa1fdbbf261805ef19f15b38c799eeb0c46ae60faa7008c7ea910e28c8ee27522e09029fca86af38ed010aa7e152a24f3babc60dbcb25b03a4f45ada6eee09747a65becca296d7f3ed36ef83708360a484177fadffe2ff3b9775bab577d807615029f272053d9f52e0bd48c50f194f27e493d1b4f3672d6c8af0754b79bc8295c6143dd5041fd30a461841c47612b5a45c4aa01bb2db17c72825c464bc1232f0da311ca25adde9aedb56142cb00f5588c88b0dece868e423a1165991fd8d2112f644353df7b4e9e1e75207ddb96c71c1c2d7de8e20d1d1750bdb1d5823d916fc5a5e6f28911badf5e3a43f1ca961943655558e959c7e271989a292e4936bf1166e8c414ea5479977f5e17c7217d4e8484b35163e96c6c71793ff149b0d178f49810b8dd29f033bbdf81c1b8d7088f58c43de11a0ce01c89125fb801b19283e71e30688d751c8bf0b2f34999e57f7391ac3d2cc6433efc7dc53ca7bf59373a57cf60fb8555074e724ef47f503a11a614959e2e62d0ecc32d91d63a21efb5b76857cb5b8708b9362376ea4dfbd64d1a30f0903aa6237ac2eb35a05af72ff32e78b7260c2e152f38de7ef5e04869edad220561e4d192fc2019f12aa4f7f07f92b38d5bc76050e2956228dfcdde5f94a8ea27e5dfe4b206e17f20f30b536f701a230cbf600cbc0cbd1ab5353d17087ee55d1c52e9593427f7b53583b612f45ce1008d4446e09e28c3d36ce63242796629fddce0aa1a5ad4c5d1bae85dd9f6197903f2be7771788fc83860efe28405b1039cf66dfc787353c85e783e21644ea07dc72dd7a23ef16ecb672c62e8d35163e317eba006a3e5caca75d9babad86e65c80601992850aa8feddd52e8df6c17d95c5496d77f8a772a599107e16c6b9104c5b65d355128d17e6894942a3026ab610597acf1fa836e6b8aca216b6deb0d9eb28a0f203f548dc439ce1226debdf7e18a828cb9f6424cb88fc345a915b16e62d98881bbbc8dda3cd35a5c78f80fe9cfbc2407cea2fb2216f633553a599cee32f20c7dce44bf9456ef3d6a4e99a4be739d25a9f1d4b9525219210c80f610f6f22bc831c3b19e8309a4af51d59ae70e591c4270cf27798546d9d99e8846b2df63a0b88897ff6ce68907b4adb7b9becf9b5fc9b31e2a2b7ba3a947ed3ea6b11d3b1b76f041ed12b076a2162b7e110f6542c6fa5c1fab149e8a0339de61e42e224d0bbc196b80328b361e48f44e3b97e666c8905b03e1c28bed2287d9378c4d361fcc5f6b6b38e49b363455c75675116af18c9298e5c9ac26cc0a83aebd670a2a364050091fb8ea0194d3814a5ed9554ed4bfdf4a9370b1883736dccc9cba6a78a8b5d592f3d891c61e916fcd1840a2b093fc88b8536972d8a43f2baec295d325eb0e403fe3b275fbee2dc1c61cfa58978807f19abb37ed354cd965dbcf353c0590c1f1bf71e3e94c466c80bab532d92997a3d40f03bf6481fa5d11460539e8ed58e78448d26ea034a0d4fe76044b3c795602d424a8e70d85d9ef2eaf58eed8713e733e28e015b40dc08d4f6902ab1456ac639026cf315c7d878c94bc67ed009b582cd4fe72524565b6c640e4f0681bb71a575f2ea3c2a96bacb6c3c994b556024f555301332e1b86746ffc0203d7d4074694c321eba1e1502c28140d1ce633f10db8709a80d23bdb488349fc9146946aec207ad5464c86dd219c9a07e21f4adf22795ba55ddf7b1f48207d9cad670d3cf77f30dbfb6b183f5d49b74105e1ae7e96833240bab100562c382a8c40f8da1e6a2eca55be32ce06c8828221e9341adb3b94fcdeef6c96505af7b545f5c1afd77802acdcc0e0986514d8fc3ed8eb0a516c6c562bcb9e34697cc98742a44b964256029d94aea50f52df4496e2b0723b7dc98fb919fbceeb71ca348de3264b18a0558a75c8a375ff90ff28fbf14ab52201a682bf5b45d3ef64a36bc3a2aa62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
