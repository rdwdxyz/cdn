<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e6988cf05858e88a5edb0a1427a8e20942d86625ea51c8f53a9e1af71827c7db864e879534682ad49ef213fb3dc19273d0de9152b215d8e2e272343a15cb10fef1c9434d6f94ad49b9d85756f25abac2ee0471cc7cb05e43bf040a78268a2ed5ed0100ef94067592502406dd42ad49dc259f70e515037f0bf0668dbf9105293b7a19aa881508274459944759596a0d770ca63408d00c1e8be4316ca0a7cc35da9b60f23637318fe92a8944b51abb45faeb76e3747f3572f50b030f4127c6f817f6ac68687c4636bc8bbf95badc95f542e456918b73dd10ad635ec6f2666416628f52542243ac9d20dc7ed3d70c5896d14abc05e2bbf45fb78200aa2347cf403110acd49ba60e5dbef80483d1feaf769d9d00f76519469f24825a386112f4e32a8e43ec6751f5b76f4e0e8af89df3ce4f71831ac0ccc25ffe3244729fa64fc298e54c936d38a7c698e1a60fa01dc844c6b2c026d5af4ad78ed0971b817b22af6e5e9b1ce5a7699c051b159bd227a190d9b58f2c1b45a2266b5d710e0a0714d7cbe0bbbbbb4f71f25066ab2349fb4be5cfab812e8196439f756a05312d79434fbbbc84c5e591e6c51c8523236419846c9abb08f1efa1590e0ed38ea637b699113740a69b7621a3a33f53daa554b5fd9fbe42a6b5ef786cf06b80783c50e0f03ee1dd585f8c8b35de0a8897fa3ccb6568be5aa9f2a90c7ac434b8ff48f0530feec1943ac617355a49e2c8d14bdefdf7445663b0d122692a3f9130578c3a37d570aebbfd051d37accc80fa3f07276fee4ebef09a2e3bbdf5924a8750c05834605cbd6f8614b36aee49eee6809deb7749c3a6f34a1df5f207ac31680955ebf66362e50fc76f21b8cff4d06f0c626ea77d2b22cf58f62cbb52bbe253aa12b4ec9a5a7647211988840bb61a0fddd30db63fd6d915fb1ccc1fec942e680aede55d177e24886e614afa19efb1d619a4bf85c2856d191def4667d114d8b0d7823fe5574f113f52012e31dcb53e6c0bd0286e2ef9424b3e6e5d134d84204ce0c1f4313798c201bd23fc6409dc45c0a3505115208521cf43964f4bae241881bf98b38ac774e23f59474887a39bf7e762247fed92d3b0e090734db24ee347d8c8b2b378673c2cf4211aee2b657ffa3a86d3d4142cf48d7c086efdb994ef58a681731d1c857fb74017f92f0715d9d616e0c828a291d7c6a7a3acd60be6146d92a2fea101cc3505dcce4fa6487812f448f201064a9a9435419c3ce95f520346da7e4dad51173967e262f2efc4a1028b1b6755d6758f3356f9bf73df97339f6d0a28654e79fd3dddc91c80de5b653997b980f5f09dd120cad704b570fe1be9d72c02e371b966b0010b0957f1aa40bc7ef6607d42066549b812f0db02e82648c0fe26edcf2e3f6d3201176009b8b4d1d33365d9140b5e044665b88e0e5c8e289ae7048e4be485db54ba1393aa9e33d38de87a1a8de846a8b884f6c026606dfd0fffcff64ab1862e9985b06be16202b1333fb9eff235a6db78c33040da6c67af3879d602d4cd51465a0ac6812b1df3342c9ddbd0e2fd029a66d2876e857bb3a0560831103809f5a919d866f12a2165734b21d1451039bcf06e42fc6fc834995e002efe8c5c532636973861e9d068126ff1a7e1dc61e19b877848610541a60ee52f18ea22f98368cc4f30899f9e8916f081656ee090a86a76361c1a05874581cab2afe9abbca5a0371ff10ad2ad9f252886437a054d111d45ad6b2462b952a4ba0a5cc7b78a07958b80a0320b66492fba6b8f7b9dc341ec6fa5518a67f70df97334ad7aed1d8d33ae8156c44eea2a57e4bf2c0e48852081ab084b6fb2e9e588454b7aeecf09001552684196722afa2332682a2a37939331f970ee5053c629efa56d6646cb3401f9c6cfcd4ca13d184ea59e5a00c19312a41593e61daa0afaa1a0a84eeaeafa20a8aa64fe5b9c028f008b40eddc9a0773ddc6a5535f10cb5124f8eb9ef6b848cae14b73850b0faa508e072c94d8c45d779f1c263e30028aae94c2c7c49da7d154638685dd294540fb8c5ff525c60f584c48708c2860a2e3d556f374a4659da50de25e4127d43ff5e3aaa2ed33ba2e318c8dea380afc0ce3f8339a27fdc7d3a2f93107fd3f3a761783a8a2ae0782776ce229f84394aee251c154f64589261bcef70b426f181c08c2dac858598057da791a2477395435b934240747ebaf00931c6da6e8d8acc1d1c4559c7ab2433268ff4d27c1edcf1882ece6b04f3dd4aa2155f6dc8b5d154191f95a58b794317e3f8ba134152eb7f5f3ac158041bb457d5202954782832676556c591e42992880f6b4c3aa507b87bc097284b9b35b3632e51c8fb1ee47ba2cac2f0826b1a5ae56bc937e70e36e1e73954ccf260d7be1e12555cf13c8c193bbc4052136477cb6acf7aeb2054097d10310e37027d6c35dd6665b99778afe9f998388f24dbd1c83ab8db98f9e5fdfcfdaa303f58207959e76835f9f2c18be53f44d35af7e66e6baa6206d44e93bda172e754c0c466ca94dae17059b7ceceba03e9e823278d820ad13d1bf1e05b41e0becb6a9116a6ee010570bf64ad7a6957831f9465c908d4cf573ae3d94a3eb3023db12c220e18c19ba8185d723d63087170a857ae60fb6fcefb4c11614f67514a99f1a71329e6349270de7f86ecc128a00dc14cf3e9d8927fb87bea8ecd80389b11240af50ceb68a17033bae8e290d8b7cde7865741f8ceea75d83d17ae578d47471c32613e5df3cdfe34020df2e1defa3d539303879606d3946d1688334909e00223200cb281db3379a1db45df7af1746c1c92e80f9db6080a6ad24bcc7b4a55b1106762675fc86462e8bb5846d9e2f690c477189781aaa1eec6bd88196a980cd064fa01ca7b8eb8ebf24bccf62b3e00888f71e60c0acebbf147862c50545c62c348107ba073efc716849fb6c8f4c610aebbe0887bcf91e995bf5de87d735e123b0276747a6a16388d7bf02a4c7ef9997ce1f506d977a8acda764471afdcdbf13e56e82ff54ccf006dd02fb36e78b3a1762b5880d84bcf33cb4afbcacaf7c213d62df98c2668106e030a4c606e394ae793db8279c594440648282b9f99203cacb2d7edb4d7cf33799c127c87e0dab73db21f933388f385f17da5c048812e429a310d773b1a8493a39775c72dbfb474559297b7d8092e6453d201cab48231ac91b1c379b199dd353da98612ac53c58f8235254392ad1e6f4e8fd26cd3daebac89894ef1e021fc1b7954920ff6e3c8cee10e731f293df52587e66b993926785caa333bad18a0bbe0dbb7614e4f027e6864a1d58a633f231e09b2a964688ef8d131bb2b14db28efc011752d67e2a939c340ece97e311219737ee564b7c14d811c751fbdd17e85d0cf8be26d5ac2652f7078ba91697113a1103bf681620900d91161e50afc29cea19f87d3515de33f3a425886eda2cfe592b1e962b0a5d8443410f816ed51f06d90e60b1f7ae7069ba5dc777c89bc762d2a2582e4ed13bdc27d49133f3a71eace5c4dc8af66ab35422100d4e4bada11a0bcddb9e92d3b8a20925fc506823f75e22a95e2d1d0510320ea15864a4534114d76b5b0afd61230246cbde56708c3340a58a4c8da797b7b67407d5fb877853fa591d4c0ef929962fad6b7496f577675c6ce36a47674fd62f8d302d924ab42be102a9cc56f39992edd893c9e57d12dc3ba9342944c959131b8294b823a45946ddb599a6e078893cc0380dcb7c1c89804093060b7b7fe78035ffc55ff34f5290b7cee6d4f652a07b8a73e7614ad851d8304aeb21d6811497c1db4fc5c73aad10750eda3b8e0278751df0f53cd2162b495e4c9039a3fe04982ef3f7b4fd25f4d817ee4459ef53063cc53ccdabd6abc12c57c412001fe5034a2c3f7bedbc2fcc718464b788fbed4b6255cb47356a906a603f6a7f4479068761029b9fb584f28822f06726f616f38d0b09ff8af42b80feb056612e07a03b54f5e9902c44387f184db4dc050f7a5d4fa83830c02d683ad225fe4dc0480cbf835a69c732246b19303cf333c99022924e67e45a87302fa6802ed3a31a20b928b64b0a439bbc968ac350ae01ad9f3279da09b07c0f05b41b37d36980a469357ec1465c87903e0b2bacaad8dc53c4bf137fce4b74a91372042610c46705b7a2c1d0a1bca29a948eb6f6d190f7e596a2535f32fc58679e0ddc0fd581c25e5199fd8a7b0d123ed3d1eec14ead9af236dbf08f6c26704e8763cd99cc3d59714fd28edb0f4810bf1b386a635f88ad01faa6272f48fd678fea791400beff428b640489ad50938ae88a02b6a8227df3ce0ddbe336ea693cb1dcccc9db240306454a5e42ecf2574c2d51a4aa5cb49384bde6c7fc8e7b6bdfeb4fba0631e5f97c502030d987c88f227b4820b45ada6c1cb3489ff533068f5749836160b778f9aa1f3a5080b10999faf9220d26b3eb88fe82bd53b447bd9765ae3753854078adef8d853a1e2fe8573be99131457bd393e4a116996646bc66a408bf9425d70b4d90bb5948cfafce5f2070625fb12e34de7f517967afa3eae990fde1a05e0dc4634bb69599a80633bb15bb357ddefe9771deb969f250d9977d59c0fbc50443f5cd53fc9b0aa98c08331f6e1aa9616d7990607dd896dc7b3a3a13a7d4abc596b78aee6dd164794413995ef58904136ae952663050bdc5c87072862a84bf8e05ca9148a09e36fb22ae54269d495a476fcf66b021d52746c4577c3c7875d717ede10395039aeeb96cd376e79bca5abfc2f55e98fbd3b2adeb2b42c443f0d6f78ab87ecb5b35f1c82d9e80a64d0504a5a72a3e1046e83bf4f2879d34e79685ac6b12309bc1d4983f0809a367722ed72aa54e795a30fb3d849a28f770a56ed4f0ea476fec1c066322b3f27e0730f34ee03fe0a051b854a51e0b0fb95808d2a170ae5754423cfeccd5f63220c903e8199d4f8ddafcddd494e2a548034eb7f3df9e011ff8b06fec898f1dc59eb20481e33777a4aebb266ec78b295219ccd958ac9de268c7c0b29b33ca78613de2ca825c5dd16042fd282f841c6cb1bfb0a438ec60a15664c9edc6182c7d65c682b6dff483a9af02a955b283cf01e4862b88b3ef185dd7a1df2b51bec8c3dd3000803f986c46b9a3546672135846e856191420aadc9583c89375c73c7267c451da2430378ee2373265d836d19eb390f0b05bb5f6b1715ba9bb9e8de0f5447ddb1631c41d750bd059ba5258e634a73d069ceda2e947d0a8d6995c28abc72986e8c58b9eece2e9b39fa68beed3a7259ab841192eea8f3e6aa3a6adbcfa3d555960cb1589e70398f740a79965d59e753a9eb53d891f740a2f2323e46ee9edf1979890f5dbea433b06f6a1f0b4b75584f539409839d2bb79a45f9c627d4dd9bd9f8f10c74f2e281542fc707ea9c7dc0717c74169f75df6170bc7328e98d31c533ddce5db0e7dab7d02a79aa274a25f0043d0c65e0d4c107d1b3f41e1429e0e4e28393aa06e39daca670b01ece00f43d550335c737da57d66a39d34e3d4438ad7b1d532c1376c80d402f74f52482463b9eb5f2b3288ff24f46fdd57ab4300338aeb9abb28e600e565a5d2dc16b8558d4ee748b9eb214b3e0981bbef6546a454a7a31d464cbba100757149c84adbc67042155baabea658f3f7fd234f31c24dcb020c09adda8d4f8c075d622006639b62b9254f352c77be3023c9d5675e99c14c3d5dbc056026f43c7f54054aa4376f357a0af539d24a2282a6277197323f4dc363c6f9b8ad6c835e5969d776a141962c01d9824850f1f713874ec8524d2a9cdcb19223cdaecdb10511fd1c7f5939dfbd2e73d68efef95a129ce986953731f8a14a0f94adff147bc994d9b91b48f5c5bab6c750806a04f97be07e4292a9e17672360020c2f5ae64e3cdde725170f0e57082cda763e7d699284e89c9ccad4830de0ed0037e31d276c98c7b7b96a2530da78f21643fc48cabf27d9b60723448164d8902835bb4f5a8de3ad1f8356ef9378283beaad84ab10ecfbdad5875e9a2fe737b9d60f137f3a8c8ee1f5aba4357c9d917f34b0e3c76b75351c6971bca5a1684394cb088625dfec4273ad4e13849159f82e94eb4fc88e1105db7273dec9c7cd67d4c15ebf71a0a0687c5b0ca29860c474591ea9046df8e74ebd522730dc0c04c024df799b6220d4f5bd4941eb32304c5a0ea04ebb58ce7c615237cde9c4c073a78da64d27f46284cbfe90906a8871707d290a0faf9ae334d5aba917fe64775cfa76d99be1259d236af742c5c8969d34540e5b11eadf5c522809edf5cfc4d0a0cb8c4768ffcf5dd6ff884f10742cee60e0e6fa7663cdecab78cb0cb7ab67ed2d5d2972dc7c9606ee9d4033854bbc9b9a37f1d7c15fdfc19383924a3afbc77b25d0ac44c27802df8e5d8cb54193d6b56f7df886d203395af98c43cd853442dae9a47c862f01734381f2ebddb1268c4f1be71e94a8af1f3a522ccf9c0a987859909269d70e3ffd418b2fe990029d5db95fa836ed103fd1b0a45b0524f5731926e50006bb59d5f571ce8480a0e8431c148368dd191dee35fa7ddac769f373290c9a5531b67b1b8f09c575754975817ae74caaefe9f960b5a60e458ac5fbc55bd7cbecb98e421653d5c094c6065e42566e176e1e15d98646a42fa7cfaa6e3c03bdc7d4f5cae20eb1b226bc96767937de8ad49f3d4d6243f876cd53b3d855ecd016b975bad108a651e6d676b409743d4d01ddce531048a6cac511fe7dad3f25569c3980e570a8dae19449b19276c73bd9c15846c9b48a2dadbee38eb380a5ce92d088df5d825b5486cf970ae87116e46402c83ad65e245a58d3cc70da1a8a73c0238284b182474c545f938fbc26e757228ca9cb7aee4c9cb06844e6a300058d3a8757202592a321c6014662ab872a5942f66d1b07590184ec135329f3835086577643ee562451e061e0ea914e497c54967abd822fb2a72be99b8d1f930c236e5ee5e4354496b14e12995615855c84c73251a5062baba1c4414034e1cd243033fb698d4b916b30806b852dff06b8c482527d31c703addd411bc694e10a83be36e90fc0058d314dea1d99a6221e5213be0df10448bb0651978ad53ce5eace7c8cf8f9f17a1534869d0d3f4202339f77c9820b08a26df586f593dc53fa412ad8bf3b1daffd99b1a9a6b6e3cbf6d0185753828e51c23590c18a3ae10a13701bbe2774d6a096e49a7686555ab1c758809f560a8b69ab345ec034ea68bd1097b24482a30f49f9adf9082bcdf37e5c2ea71cd20e43a1b186467ab9eab393d8240f2903253f95edaefe1187e7899706b50cef1bd12d939586693d292d0535ce71ed849c7d1d22efec498511a109416eb1fec5a2e9a87c7b69923d861147aaa1c657acd98fcfc53abd8fc484bce1e667dc3a50b77de9eabc70e011444c2c0fd77be00a5965b9cb05406ebaa8d0f1cfc0b19b615bcfaf81a808a4105ab5f3cb62ab88bed6f1adbbdd4955c233e1b5e3c892c6110ee3041c43c2d538c4a6102b6e3f568eaeb2c3e2f4262dd0fea00b34f8815aca034b8126f495cccd99392633179ba6526d57905296d4ea980b6a1ea86d173ec9f957ce02a53400f3d57dfe24ed28ffcb8422807777d3e201581cff000a2c13fb8268866321e64eaa140d565939235d3d98adafd36669bf72d526dbac613e26c1d01e21ab172ea6fe027af51d35f39452053cdacd254ec74df379efb58c2de164b5fc0777c2c81cea03444f70d1f07218e5fd22e7770449941b373a522f05daad0fbbe6d5be4720123d7214cf93f34b85abd1f5ee5f9be5708cc1407e4b1d6a8bb95609b9a3ee449f22da0bf8217a26b4afe4549c0b6ee66e96f4e5400e23145ff37f1a255b53866102adcfae18e425b95379fc1ed25f1e09fa53adeaba4a94025cf9b38143fa686392118665c4580b9ed3661db50b2b93c58d493cb1ca72fe267acc0df797cb879e33dfd7093250ea55d207d4b7ccd402b47ee9480ee854bd6ccaeca21ca418c402d177697ef88bfe729c3dbc4d2a02c50bb747baaf4f69bbae8bdab4d55d10477b252bdd5cd74372a2149b47b8ca892b6cff5ed89eadcf8ccf55550fc18046c16b9fd6e4f94f05840b571c82e7549dc3c283c95fe8a89875e2d69843e8357aa06b894d2023e047fd3566093295c082dea129446f6627cde5f7dabbf21b5e342a830bb0b5fccd70ed60f2c4cefccd56257abd847194decc59a317b3438542e218371056a49902bf7f5333c919d9e76bc7d31f8701b21289ec9803169b32645fdcd4e0b233a5b37c443d9c36f8b077d6c8cc441677dc78300559b5dc7fef840d84ca9ec7bc57f36aa9da203c75476cbf2074fcbcadbd40fef8e945243d176911f4c7877e2be1fc69125177fcd5861fcb68f048231ca1877d66354ca22fac85c031c4a429468e1a835a2bbd66831c112c3c50d1c16ecdf31202acfa1eac6df7d444d3912b69b23d6626ffc5345ff29e7f234a10481cf23e488b235f44d791b2100293b37472f13a306899a39ab1e58181b29a187d3cc50942084f6e2ff4b1cc156468943767f64c66e6f669c8802272a9234a93935a5c881bff5d144f4ddbf4d0f2cd4da641ae43f9352914417c5a224ad71ad9ff42718700c3b622d6952583bcf9c08c4c229fda1aa135e71dc08d335d6af0ec50e69608a6759dbed6ed316b6a2b94c13fe8980ee5b14f5be54c8743b55635f87674899ba01eddd8a06727edbd08f4a9e33d1220a023a474b7d98c435e338c122f4c580ab7b471753406cc47ae98c18aff06093ab0011fe03c73a742486f531f9a093cab108107daa31ba267f29d1556892f954ec81a786a981e824606bc37458d8996cb11c5aeccb15c9adeb41a9dceacad47af82310dc479616d6b5d906150c61b01844465e347ecadebcd71f08edc23ce25acf7d0d069f07910c0f32c33d2546ca312b15de2bad44f740e5237664f8dddf64e37579c21314e1553cf20322ce7e79e7a0d0b04a5945df7874e7c5ef2365eb90b16ab52fdee4f9858fcfebdd197142847b62c3fef8ad1e18f0943b6ff17e5864c045673e5a3d0060300bac8fe04490dccfc4856c13acaf8d144a74e655f71d7d7b478ca11d82e39b59767ca0d69a1549d610f5923801956531fdf2554f77f6c743ae9302a92bf139632ee3d01a8009b5d74ce220d19505727ba72c3f8b3d318a59e3d8a00d5cdcb597919d0c8067977f5a457836e4790dd91c4fcabbb7ec4273137af1534f7644aec501e1b56ddeff0e6f7616f056c1d9c8428b3ed398c089282165c1c8afcab7fdc8eec68f523928e2683ec3b65f54e8edfc00f763788294120a3679c0f9d246aad89b6a4229523fed4bccaf726d43fd22cb9224f86b02eab9459d8738600c700a77a6d99f1f4e21797892809918920b5b556bc6093e500be1e15721586eaa4eca50d86eb9e017ee470fd6ef698b85e48d4f4482681ba6b829e06e8c6ff1a768e5edae66f84d7af64052747e9efb98d8e71ea8fee9f604994e95b0d0655fd61f498fe8b3b332e0c90b6b4578f357dcf6b6c42c29ced8a7b1c65b525ddba7bec8425647c27687efc1e26ee622e46d54ab92d458e92b11701083dad9841a04762fd5f5eecdd96d027448dfd6466668559364785312bcdfd96422eb8e110da1abd0b6dec6175507a5861b39367d3a8cf8b6948ff47a6c98a27334cb181fed2ef73ba1560b85045b7ec7d4ba52ff0cdd53db98610b22cf4df2c233dc7f73dfe2571bb4b6a515eef9324a08a2c7eb4f3f7e2993a95678382945805be8fbce5cd62428422f66b886f1f9434bfc9b76fcb3c0eb2bff7c2ec2477dd1c81a7728bb93de5f847d851db850a766a989d9b926b9374f7eb672a0391aeabc58acdf3e582da4fb07cc05bd04e6ec291284a66fc8ac8c945787af12500273b89abc8bc15d3064d8feed7124b5c60276c966c089949239ff1e12064b97cce54168e67bc9e42c2d2f4e518201b0e948e7b70ff7f9f069b3a63a6b6372844e1e909cdfad895d1aaab4d81c4f82933098784373667946a394fecc1154d420d85feb06998d4271fe34c51f0d8a8110a36faca5748b9a377669ddb4b2d9a65516f72f23b7fda4acc387009b4e8ca12d290e910d82ea1d584b605b86a53952b6a9f62e1134dfc69908849072906282111350f29179237c10d0abc26aef2af2b9e2298c95eb642d34280b6b0e2ae145d2b30a565a2b2a67383c4f4ddcb21345c6ef24beb7bd31fedb1122377e0d5ba20a753db8bba0a0a4091abaecd67e90c253b45fe8124cf6a9a833ca98954b46392f6a39b7a1aabef85a52d1a3ad8693cac1b4d189fa71a5fa7704e4312789811a3894950e49d44071a655b748c6318ae230f041277c86f83c695f2f887d5fb2046ad2831e296056c49687bb7447461dadf0e8d6a6fec88602d6b3717e86ab7a749de5fdad26de72098f256a8f4554a12a1c3218a4e776a2f7d26815d32efb10cce1b9550e63c6c2df137b18ba387168d75ae4137947afaf7291be25dec8a971d7591a3ee8690dfbbfd4213840f9441b434075922c02f1f90d54797667ba0eca2301a751ac976d61b51f006176f7b972fe36087c287905561560b64a0ff353d712a73c0c2de581cad93a5dae2acf2b445208660ee0a937f3ca058652130031cdee02359f9eaa609820f9b481c4d87f9ad1e01a1adaaaf259c97e3de016fcd037c844fbdc2588ed848df152920ad09c49197319ab7b360d72c19839c0971b083ed64c37b718ac223eda80321572087f30af3f3207834b9fe417e22a5ff15318fbe48eb1e995e17e41c5fad601f2b2282d5d2773177a336e9b626fa45b26e45d4d4f32d69e461a1f1a84d6597ad8842eddddd6fd199a2e4ccbd21d7ec40ba2a9db3f14c7152df55649615371d7d2179a81b4eaec81575c8873fbc92181275e79885406401b2cda5b38014eb291194ef8ec47ad16cca467a98e4e49103e0679aacd3888c8c9fe5fb53bcd2de3084b6df921fba21694805ea48c92306f1da5c3909b3544de5cdb4f28f3bb6ab264462ce39f7aa7670e30ec8ecc3f2fde5330600b56cb4c4b1b7ec0b7fdbf23176f68a79a8ff4fd8d5ec00f3e78c1077fcd6261f12d7271d7044f0002e3649084c45f7600b7d54448424f9845200877d8481f1227bf633f309c3205ff0313332111c1b75a9427b5fbfb7313175d5d2ec923ac70f65a39932bb060933962c8a2154bee55c4cff49ee0d73a932c7b6cbfd8595132ad6bc0d664dcf92b4784b5b034168e8b129bafd2a11e761c17c67af6fdf33f3ca100beeed9168599e652d5d9d1753f7544a327d3be9b0fffc64fac2c4c23f724fc080711997977ad1bf31e5950e36cc02907ff372261da1129fe8c9d7596de9a72f389fd102800f4c438f78cc6ef3b5298179053e7db1328083e796055a44a334b5cab55f4d1b35f18387e513794dc7f5418c60d08ab7a98d246e820084126261707481c37b511791403f47de022c2ea8427196f39ee239bc27e77270a8eedc6fa89f99e4eb0e514b1d51d8ef42f6ade9d539bfc6b3bdf37974242cc853a85dbc77ad65c15cfc3c60b0761066e08c27b388207715e6c6ca898ebd619b5b36966d7d8b1fb8970d5eda0349efbe68e8adf23b5c5b195ba67cefeefa39cac0c80f26b9b1bf5c8da736c21eb9adc2cd156eb8bf9d698588f6746c78472e20ced680994de682b06da05ee9c30f6c8288f929910f74d0f2b48ba48949d78256694a3c90b139b0982db82a4ceb9165cf8247ac6041b75f597cd0cfd19977b6c53e8eef5b242a14585557095863348d99a3ecc03f621800bd42b8f185bbb9749c622c7c55d0b02de89341a9cb56b8dbf0587999b18f2c39bb5cc7651c2e0b48ceea468f057a202438ab27eb5f78b89af6507070fa7c6c7e388a41c455c7e6bb26d879458bcd022ba0b2b978b88989b0ddb1d76373443c04a40196c6bdbdf8c4b64dd971ca613e576eb3035c6c491c07a6f674506189f9c0f300a6a9fd748d9f5d23d4fe3438dbd0adef53c59234463de818a09a7819544f8f8d7b5ce95a142710e6dafa3f78ad36116992c584559f4867bf3a434f5661c2ae76a603f57587a0ac4bf4a9900cad334afcba576feac057c32e4cc3f2f64fbc9c1ea4b6d202c080b62004c7a5fd5d138b1da32840d457d9544d9390ef3692aab3051005714c8da1b7700e2c56f63e902b65f7c2c2a15079b61965dbc7caae4b3408eb1a9b1190971b799ade03e68f9181b39ce8231ab3f1547eabfc1bae86f13a078bde7fa8b88a3aa886551147134bc8abcb6655ad035047c7bd2b91764ee5eb702023ff988ab01808063af6dc0a19a6e7232a2786a5545a684dd55d32abf25bd34b81a61edc5b593e3f9ea5c793182d28bf84ddd8574f65e5bc1a02114f4738ea0ea53d103340010b1075108192ae106ddd0527c8083573f51cb7350aa509c2d6502ea07b5b71b1b1de281ac9d48f0b55fe14b1b9729f40dbac72847e0f9476d617f18036e4f2f18e8e4fb9698a16d1babd11cac351dbbee2eec62619eed4e4ed87788573e5c78ae51eec0aad67b7d43712e640b2e889ba2c8d53d8406015c4d28a322bf99f9dcb2cf43bbbb624a399448ee0fc7c526e20ef18ca3c10957856a0bfde01f935e710d2e607f88d2ed6c51f260497aba48242f6dc400d3ecddbba0d6d7067b74063b84f124390dfede1b869d65f030a5c58d39b8afd6fc806167895c95a291a3373fe30e611905eabc32c4e9d5ae07cfaab1c35016539c3cc5414720a98fa1618cdba6a96213267aa2ad131df9791387b1b0e60cb980ea64fec6fd0b4e72e23d389cb637b601e343a6c8d037a4baafe8885627edffcf910cbe2db184d2be648edaf9b8d6ea0ef78cf55ba44c91d64b8fc12bac69e2b01e8cd30fd6a04885781935d61dbd4075a9fa0af93b5f108e26253027ad3df01e551ffced67c908bed7b36e060287ffdd2cfb8c462a25e21dcbf107ba80a76983c4a5432f3a405802bb6356c31562e1b969831ca19154c59b9d5dfbc5485dd7c798b14aca4b8edcd712bc1a4e8faf2ef598648c57daf5a040ad7c496dfd0d2e13763561df28124eb73d4673172b77408b9d6097e9003cb11c379d314e807816129b92dd3b971fda38d104ff2cc9a405e146c5d48ec09a49c2320191d3fdc7d51cea6a537946c9a4b669cd48ce05bf7b04ccf5831184900eba84eab1e6671772891a1393051f59ab62231bbbe675e7eb0b26f8fac324ded0b9c7293ca704de95e862c735eb64f0c12a38f02adfca3bb54129ef0736b902e686c52752e71f7b1bb2e71bb6abda8d095a517b149ffbbe5aba7e335e21041581a22a61b0ed343f31c5f5a90a5fd5396791b32e1526beb500e9c848ddb3b7fff3eb833e2a97bcae3c0ee118ff6cd4242922c92e40cf5bb12be5811220fadb9b246b15b4a8ae8acab70a198bb0476b01261eed10de0fde85ec1bc7ef3d74a884ec2ca5c9823bc66cfa6db3a98e3a02724e6b46314e47add03922173b456449efb37c99f67310b8451d42ac728a0ec70d0c99efe6158a072181801d8c8cd4ebedfd3cf00b100d9465c2bd93c53d36cf98effe79ae4976978ba7a32dd47943f18ebdb3db346fee1f9a993584737184972f075eee1d27f1b585efe901d159166027039f4f3244cc796d3d7b6b560f8a7978371292bbef6386e55e40f09fed44dc8e347ae2a1dd1b62861646586047ee6ac2918e91cd36aa9dad313754fd6a8f996b99c79adbefc05656d1540962fcfd0b6912b1be025e38dd9ceed877db8ada6d073fb05e5ced3cb114e6b29a36513ef3928bfab8a0c6dd1a5e9b0b92bff4aded7cc013bbe5828b9e1309921f5302ee198706739f9526b50fbc528ce4a929da6a2f82c7703410b763dc3a3670478f6c8a7379640e6fc1de6ee6eba3e3e53a15eb72bb115522e4740926ef5b3439c34f67fec403387678cf33fa20501081d778b04e26b318602276b43ad259a22cc8fac378b56a2207403552a47b2d41c2d97caefabd7aeb1ac220df3ebc285e7ac16ff1c6805a31247eb1e9a8cf85971c05b9c64bc6c858e39d7042c9cb24de37cbac86a22f7d7e430d4c88bfaf8a0ecf2e7459f558cb6cade4f30549eab27cfcddfab1ad2ac5f6302b36f595386801c6e3ac7067e8971f94991ab74c1e1d1079b0fd65d04ad35c3c0746f28943f1fd22b06020a9ccf5e5059d03d275ca453ef04a84c1a67568d94fbc54fef1cc7cd336b9e9264ef8bf31d51875925f5892fc1c782023fd801299b2106a2bc74932d181c04f72e981f4c62d42e0f264865e8231973055ae87853093a835274bb988469c0fe170762a4898c47c042329ea5aaba36113354213ec4ff546e1e29955a1140a0dd5079a1aaac010edcfd772e03b99cda6f369d3870a09cd35c98aea5f1176b45a8816834655280ad4a1794486c7ce96d221745a8a645e5240785bf7c0ebf79c7aeb3a804526f42154ee195b0c96e432a334ac05c3fbb1909c9feb9590ad0639825e0ee0bd9e3d6190a02e8f9a0fb228f424673a2b7be909e14aff543daf0bbd767e3e453732f960f81723563aec2733636ddb98ef03019008c394c68aba74d5d21933a5b8bd67c16852be02e0fc0c0aa9507ff77722f4e8fca00609e286dc3174a51c8ba3226dfbeed943eb280b519113321076792060b88d800b09b100d3d7698ee561c6fb087019505f89baf91aa55655305f2a50c59517b5b8e14e96e97e12bc2f33c5f7d5611de997438aaf767769c802a5b5946842ed91b6f9380402d20ad0018095d95089ca923eaa66ae05ef96a99c9d1b5042512d0020fe0c4a20c72b27122219f70da1ca0b563464db6847930b84046de78a8128856d512e3f3081f1957088d506df1e1c8c3628f73298dc6d5cd3037386cc787a57aa94b663dbf5dadfeda7bd27e4e26d0ed6f8b5cf49877c8a207016529de93177e903a6c88df98f61351959303b5ef8df651d7aa61b47ea7fccef9b6a47d4ed88f01ed73ebd82f26fb2cbf94f51878a2bec6575d5a4342b73306dd4c2d18ad0d2fa9f11e826067ffcb2cf13722a262b4c404ad0399dcc767f7ecf94ad4b688aa8d0890c9684c04629105bd47036a6c297b4d2ecc901b6b03f072c1628cf4be24804c544e2ba93c7fcd78969322e2a2c71689fb433c2dd41c6bbe32b852d93526a1e5704bf1d2ce1947aa26c763fb0afea1405dbecea36532acc7c47e7373cacfc4ced0a91d055f3406f63e946b5444c5d2ebd1e5153d69e01350dac9653a1173c0a4fd8ca532cf6a5d40f74e76d2caaf2f8e895d05b4d25389badeff23b6a4bbccb0503ce0a3460c0e08e4cb55392d177015890e72c3e868615a30bcadea305768bbf8ce2a10de74b960ed6072a904744219e2c0222d28b1aa814deaad414746b8030f962820877e9d8b655e6c87f5eb723f9be5882b08df68c924d5d1fbca294f6fb30026c2e378f8cdd8f1cec73a370ee969740bb1edb3b8aa37834c852eb3f5c62a1dae4a62a1a92da1d0648a4a275d7e6c13a86400bfb8541d584a325c2cd96719cfb4da40e052b77f865844783694d07302408eb835f154f8a7cc9dcbbdd78927132d6f30189b5eb866cbacdbd5b72676596ad521cdeba6b2ecdd31a8aed7cfdd50c82927835f9b0cab9d2e17b84e58cd3b9f4546ab8451049fff6d3756bb41b3f92124de527e81a5f1b941aeb5c813b19bb2f5ee3a0a60d586adf950df1b5a562ae7ae9c57c75c3830b444b8fc238c0a8ed2224013c54e9b0f1c7a0d740fddde2614f4695f094308fa6266aa5bc8e6779ba5b9b1ff6709f2a56a2aaffce3ae4a533a3255d184c92408584c21104385811d5b62fe32e434eb8dfdeeec68ec9397b78e355c08b940b65e708824930b9eef1b63721b6bfc4fd39095a9e75e28bb72ad0b522468dcdf50290c8a76d33376b64e0ccbc78adb0dc8383be2bb7bff0bc06df846561651e961b6ebde5b384bfdf888ecb3773f274c416e5ed7955d5783a3107cca6b59ea8b95a682a8c2109b1acf1af468e0f5d6a37947e88b2c1494c4aae6427e887ca9f936acc0e80b8b58d33bc7e373e8aba64fb1e41c8c9ede0ff853ddf673c0a9a002f02e21c214441e1a2a7b49d8ef1a97f19a25315232f0b05ea4e1dd7347724516899fa32215400b44c0e74160d821c5f761936660b0aff7e771012d146f06f2839ca5c5535b706c8a958331dbc5fdbd76d53b7851b60649f9ce9b3707f6bed25566986c1cf89149880b3f65663930480f988498c86f020d9bec09df64c284b1819b683ba7ca4c38996e2a1bc8daf57ddba98ea95fee73c2fc97ba7bca7e2e2cf7e8805ebdce6e5c7175d74318537c1fa6ef588e6d8e65954964eca1b3a6489af21d8f924117c12085d73404d6c881f815b57cd301fa1de00ddfe2215836829ffd5f061109aa7d3e26cbc94ac71789d99e05137cc6e1012cf4c74c3a81163fe249aca26910047d9ecdcd05534b84dd2835d0ef9fe5cd8b7883302221ecf9caf4010d2ef53c75db64e72989839d719746c9b90c545c9220db51775290b531208c3debd3596d448553758eecf906cf0e2dc65ef1f475b84e5dff42ec30e5312bbcf17ff3c4f699d10a3e4c00c7cc952750333f90d7bdbff129247152f03e21bb141228c429dc7a8df97dc00ff4261196f2a0d587a77559c82ef9cd0acb0451341e1c64fc66bd436970cade794912a8dbb6ee6de6d36f453b3e981dc40a37191489340b39027f9b64ce3292ef2a0479da39e3039a7bb2a6724740d9bae29136bc46fb4a275b189242428efd58d9a37f25a8c879f009c8ab9b3795ddff45cd52f407101bb5e955b2357404e1857c53276e05db03dcef7700fe5f15870e944a945d75de7ce0555232c7e6c07986bb8c2164842ab9d3831b1431a26e8798344704e5c26bfd2415f3d43c311d346c30c370886fcbd66a65259f6e02a049f6f95c1f0d4866eae2f9026040f74b7534efadcc172ff10e170f91e67293d7a649a670811bce9002d5919b2d32e3d4f523c13c0f2136528755c69b63de298fc5607e7dbf43d84e967bfe9dd6add8536fdd6e64eb623fe181e471558857046e9fa40540e2d85e80b60b03a3d19f1fda70bdb4a1a82d5f9d1e0566f5cb73ff19670cd6c364be5b01d163fcabe5bc8f7f19c725e3f19ad47d90b55221df536529d9878857d35c7daaf8191edd1e0de03843cb64d52abf6afb4739ed6502757ea5ccc04d0bd64e6679ac89f9ea36abed78414a41af7075758a2d15bfa2761c833c24911eb2e014d6d74edf9f411a792df3c26adbd88eced503de4df91f8cd4e1884fb91b6697236af6ff0ee72b739c74a8156eb5de514d5e91d9203109b3666876e39e05eec8f9227561612384939bc2f0ed5855c92587974a39a2abf64b715d5905e628792420dcac7e1a034c6c1aaa251ce0965fc277e34c9db289ec83c7eefa47bb5561f2c2b525f931b467a13ceb98b5e3713e1270785f7301cfa0c8fc05fa2d31a304718c83d09ec513ab43c2954743b726ae6b4b1630b6ee95df3e3b2724a484be3cb9b5849b302f90c3e76115aef6531df90a4b89123639baa89c54f57ee6a8f66a7a8532b6c03ca33e259fbbbdcb74b95c3fcd15e60065945d006253c268e15254783dd1f60a23e3303d960a956a1c7c6cb49938b1a216e5c6fc1306a0f6bf670a98a879beff8fb1e23774e13fcfc63e3d66e83460b9d64443f3b4e659f2bae15abb1a9bab280dc102909f73c28cf5c80a1d3aadbf02d36464b433adbea1dc0f4334e807f99b996e0793dc5295bf39216d65c30e11aedb99b29e340cc0bcd807677e16cce60c1cae5520c4f6f751ddf0c57597d62f04fffd08f8857af565546b0ef852311d128377e360bbc52f51ed70a6be628b85ae8fe7b01c4b432d6418ee54b5ac23207f33abb6ee8f5111f4a0468c4be7ae1007368c759e1a7aa47556ff8a38d54be6b515aa83327f209c9ed52e432d901f0c0980abca879d9a22a8de5ca4d33a21786626f7aed672055ae81ea035c0f0d69d5e17b8bb1931e9c9d0b9e597629097ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
