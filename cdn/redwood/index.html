<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6738a9873eb1f941c0d9d28e6ae801d4add978e8c9a0d62c6f4d57bf79974f2ffc34384668109b9b321049eca0cc6b53c05c5d4ea094b11bcd63d579a9202d6eb40c774e417b161410c0537d94eaa6509ca7191a39da959b2b3955b9de159f1c039e06e5d663099142bf94490e9227aa3f7ea4c069e73e2f917fa2a0db1487800b49ced8f71b02e61301f7728977c5473e0fea522aea4b83176dc8af234fa89c78329d63dc49a91d762039f99e2553f21fc073f2ae40f5db85a003b23a1f54b103b842c540d7949b8bc2407cf868d23e5255e0c787b7ce17035726a651a355d0386ca726d11896da104169dd3c1b776ef4189a595e9e626bcedbe42f6469315ef12eb27ba64e771e6b5bd2e5b43c352598117734088c05264a80c462d006c6d63eddb9575de274fc2e931ef7fbcf8016bbb943bfd46a1328b20a933edea6a9fa8afc7a3af0224d5188a34c342f16b458d7b5a6db9be8fa544613c4a9bd067517d0b0615d2ca7124694f26ce34c483953f01a1fc5e73662d342cdd1d7e6c2e2ad1d9a18d4c80b415e49ead1650be3f95ad7ed078f718617a198a29b1fbd3cfbfe61eec54e3b6a1c47c781751acdde57d19338732b8678eccccd9a8b2240d0a1797bcea812c42a6ec6a305287d85ef3890dd3a2d1841cdea45eae80821e23840a9cc5a98968c136d771236067d75e4b08d4534677fd1e298c262a6f7faf4f0d7be629d6bf477f978852fb646febc580695e6968ccb1277c3d4711c632811c24a41b17ad1f1a6ae3d5fb41729e7b866aa36ae6ea0f86503826eaf0e2858adb757cd5a2f5ea2f71267385778febae8700c08016db05807c02b3d06c6124b67e9b0de240759ff379be7f447b737b09f8f69c648f0a9a85091ab1bdf89b7f7a472ddb0002b7e035fdcddb3f420d9622b8d86ef23a0162b4a6012bb61749b06a0c97d7b79a3fe234483609c359f7693362e4661695e57983b4a21605b7b8daae3c59ed290e71638270cbe43da8e2f44be2acac1d52dba2fd9e285897129b8c81853336e7589e9096df88f884eedcf677bec729318e5b62dfffde2ed478b33558ac364b91fdf9ae647d99bba828afc78ffc780c04856699ac884f4cd9be2ebd138d6eaa469c2124682bb06e83cbc82d021444ca552cb9dab49836ae7a5550b363fa8ed328cb89d695841fc672f84ee3b8fb48c62b1a6e0f15a4647d6d6b582cefac68090b6cf2f51b3d1d1d391829759f3a82ac2222dc610e76835b2acd68b92974f5b7cd2fd027e7d947937086e24c20b38b5c0029582f1caf75a9fb6c381deee0bb1e21d51bea52c67326952a7d476b2c43c289ad4f79bc16b81a9448672dd1909e14fe4c3e3681c80ab7b4675b69bd2f3e589700f17a55c270b374b6f3c10c48692672f2c207801918fbcfd46c4f8a2325d9acad95935a7a527e114a67e5b32aa6a2b5ddf9783ff4f078de40346d52130e9d1bafe8957525f1cd99b7d12fe00ba3a6fabc34774790d59fe9a4c6d9dd38d7ea3ffa58056f19c26bf29a4a113eeac21257ef150cdf5197fa7249b34c11e2599de0dbbe695ccdc03883d858f8165d4164e900e3a9312e9755c11288210f5b18daee60ba92b19525496e8764e230ba7a896f46f3fd4ba1e98285032d209a5aa2fd0a1b84d514e6f72c18c373b57622dba81f492c5cd4e070276980a4ecc7ff14f9801d52918f8bec4f1c2ca62b24b29df3d5a9eee00aa8598db127f47d8bc4e2f3cb57c374013b05ba725bf45c0a7faeff807cae81b2a0e59a9ea0662ffe5a795ce0ae8055b799560d007550f3814a9171faa25cb8af9094f6f10f464f56e48daca422838c8a479ee9e14f74fb531b305aadd8a0fa2c70c2860d7adbae610088429a8e738292221e27867098463650cbb5053c2d7a1108f27060f15feba8052b434d9a38e492dc54b4a05bfcb589290a287124e71fe4e297c1d563fd5dc05815f55d79d02e04af520e78b88a847df5292ae077f85b2fe187c2bfd9ddb6977f32fdb5f65ae7017df9f7f7fd6017bc19093b0d3a5373db75bd61d2ae5aa936e114ea983bbacb310378ee5cecd83f850b5e40c886c9a3d6f6ed57f4e7d50ce5ab107831ba6a974ec2bbf7b944ad3bf21efbb068d8eef69166556407d05c52be48e308bc718aca53660f9b63efeefc95b414add01ef9fc831a6b70418f226433b08449dacf19a940ff50798ae28e17878994ed31e1a138d09b1117939bc45de2abae7ffc139af0ea1718ee6c12f846206c3f12ec921f43b5a7894e3db27e2140b06212885bd945aed43065716f69063aeb64f6a3b0e37ad01931aeacb9e06edb092d2afd59dd9608c5e6e8971b07af2057606adb7fc6205e566f5e32abdd953cd1f11ee41cf80d3f79f58e70cdb76e925f7ac6ea3ff224e6204880fc998f1dacca19a638270196f84c4a4338c1667f8ab68e075418a59d179fa869dc83fdc0af063d19908af97043f0f28b6709beaa28662f614830ba6df6dbcda11f12ee6af13872e960d1cefe7b24ee1eebabd017fc216049591dd2b33179841e2082b5ee8c5f92ba6588cc5642718d81089e07ce00617a241520812c52c229367ee4bee3636ab17f1c82bdebf7bca72c58b980bf191442cfb0b8c94e6d572af04d3d0cce7a340e6320eee266fb881b5765b05366c2beae3cf5ff1eae886230e53bb30902d6021c885ca72799115b05b841f5840279715361856273503fe8da14998d0a30d1f325f3a9d378af5e855610b95560316d74c277dfcc7386bfb06af5fa693ef2948c0b6be5165fce302bdac3d4165b7d18ec56426e40999f2999392552ee061fd0300eb982e13d294521513522331172c8abb1a1dfdf2ac193e29686b39fc3eeaca62696bade6a82a567195dade4ad0ad72bf4a3d4db0f6b9191c8217c9934c7144777813907c5895503cc78819f074070c1bfdabf6fe116b2f8d860d746c792a07ea95000ee6e58b46bbe84a031517a784c5f93aeb6bb531bc8319e6ee57ac4717951db61615b2256b2ee35cc921badd1a79aa786e74757ea80f7bae036abfa4aa153acf5466c497eadda48d4cb2656602285a168a34fb080181f89bff43aeb5d5112537b8b0cacfbb9454d541eb415380ee51852e6f6f6c3965f2da1ea5c453e20e073feebf79ab16c3531732c99bf51b2ef1dd9c59d103f66c62f31814d2f7e3784d8a7f05e2dcb25745d83d6dc9b776c12b5afc36ec47f6d1e9a3c2da45e3e2d5dff9e707b002df949191108db0a83d21f95e633bfbdc34a922ede88080cccf55b90aedd5225b74800ba71d0a320d40e87b04c90800479ad7d71668bd0f1ffa3d8bb6e985325460afefaa8ff8851313dfbc5415882746429e2afb7c932880d64463b87756862f299b7605f25f38d490cc1b31cf88fc0bd6bdf70eeef3e81ef10b2b01ce095d89d56f4875d96deb831313baac9500b5b29c242c65fb9bc7674838c33c9a55afcb2fd04069f9d22941a3e0ab599b5aa8840a344e9b29071603f990d8cfbf71ac9b22b387e27057c3ea74f01a66d5cf652afa78d2683bacccf5f63235da4a5e0ba5489959d3f1c2b3b902166ab7a2d04527fd6fe6c98f5522f4ea73bb27f7241b3ac77729e4cc6c6b9ae3c6c6cdf90316aa2a5570be9b72d22831c32abd65d47615666ddd5952fc6b96ece289e6cb89768b82a42001045682c19d8abe8be4197e8a1a1736d63e3709f6f99a8343ac575ffd83abde61fa130a64881aa8697696cc5ac8c755bfa9757007583a27d5737a62182eb9c834255da0c1bf01c11054e7edeadf7ef64a8740809facbdbde1e75322bbbe2aca290b1555111bacaf50799722f36418a8844a5407eba75599655b36bac7b865298e27022fae64068b6fec13870e9395d81b65f1e6f200f06530058c1316bb5408896dd198fe6a3de407f4374a724a1192413c2afa7312b146df790b9feab4a5f78166a3165834a63583c4d7239117801e985ac837e64464f5491024da3b664fff315cef1204df8385a96e4efaa9f7a6420b45b8918cb24244ce44759a4a3964ee70f841d15c16a163f54ae851dd68bbbc46446f64d4f0af6003da9115d8464f4d0685e4cc4e43c6b55a3cbe3fdfa883b7248717cf19870d27af197db22707b4e7b63709c80a83bc3a8313f0ac944d7d6e59433609338e7dd3136c3f8e13b1974f6be9134d5a4a75f5325b0077df23bcb020b0656715aacda2b7f498e12f84e0fdf5ad237bb34156f610517214340b64a20d17fbabc4e34a07b8e26d7e1707feb2818ae0e51bd36eb272392542f6e9519f8c89d6b79a9baf9fc3e5034e7d51785cc671425c534c17f686413b8b80b8417c0c837cbee567b1d287d57c310f69ec137b5fd6786ffb34cab1237d03d6b5c5304df7c4f29aa5ef2c5b0353d9241e59733f7d8bd1559d995d3c164e5422ad5be4a0ae933e89984680e8e8d596b97235cb2c51c8576e801ef844c0ac6d4a5c5f0376fbeebffc37d63b061d0c8c93b758d1fa052b125c41d97d30cd311fad75670854ff88c779dfb4758ee5e0f74e52c088ed6214438ad7aa241bfe0aad44f3932a1b7bdf199cf5333fe2b236515c05b0b1584fdb4f9598e2ce6e8474f3cecd02b5910ce13d5da94fc09d7225481e24b54355c105fc2b57e3e515eec3c88997a7f8b5c40223b707f4bfcc486c712575161d606180551920c1f9150dbaa42ea61fc62bd58301ece6d97a17fa5c77f8bb9ff36ebb2a1e59b3e1cb766b12c80201da46539ee27c96dd3b67e3eef3f196a32ecc56e1b5b2955b5e77ac85c56fb2c211160395ebca12d2ca3ffa0d4266851622b9b4705ca6ddb2db58ee61d733c43442efeb2f905ba739472fe11f549694044497b8f92cc763ca3381c884378b6c1a460911b237edc9ea53aaeddf577776fc1a3a7acfc1ad3b1736a55044f764baa41ee29c3f5135fe7123d3a06ff9b1d41b131df161447a2b6aa0c1a48228571a1c66819b3655daa2a705d803c0df3d6351f7b5bf2dd4935863ebcd6bf232440ff597f3033d6d3bf70c97bbb8f14e19f70bfbd7ebfd52e509da0d7507500f578b3423e4ec5ee9f3374a6e0bc8b079e4ec0d6ea60168608f59a4ab4e8b7e93b77208fd02a4a18d5afad9d0d2abbdb150ffa36122da3c70ca4c024509c8b23e464d54333e65e2cec661f0ac70b69ec7957960966d9d9b20407dda6483282a3fd0b3dfc1ecedd6862faeee6f458d77f9c904d895147dad4c87fc109be41257eab6c2c3a6512303bb0016bff0ca3616f2dd543d92a1175f1e9099034635bd3d8a5bc007627d0dd514e801b1728e221a228273e72d28ed3a7475303cd2032f4a2360077f13a4a8af79760e3c2d38ce535ba0a6aaf0ea988b34c5aac597afeaddc5f080dd74fa38368e55a849b3f614e67da338a7c8d49a31a59316c837f33d6ea8a2fc8b312dd602814b4882bfb26b6d8d63918a3bccbcce1ee3caf185cae0efda0871caecbac460e67019f66b3fe9a2bd4651308fa3fd290397d1f238d1c93cd53f1eaa7be8fc7605cedd5a055dd4c69f3e2b82be7af066c074f4b66d3f69ec03abb001024c3c339b0767f959c91f2311937ce74092d23e58894a40253a5853feed99f43d182aeeca7ee4ac2c87d885f4be54bffbc36f364f68bf6a96484a2fc4a5f7841cbac38ae6c87b5982b043dc4e4d0570d93a9c57e56e7e2cca107f757f8f3cb6309a186377d74a91af5190a6ceba3ba66c71f47e62e5e7318b01c9de467a78285fd687a9f1787e9f916e2970fa19d76bb9cb5e669078682696695f636f356a7e0bb47ef81fd8aefb7f84d7e2adbad43c634559155ea6ba83138ecd412eebf794c6c7cc3ca24593f383876fb0d996f917b2b50a302b590e021211096ae7690be97caf1fda295597164a7de845f76e7d7d87e2050becb22111275891da4387ba1199319b7fb144e536e9bb6899893cdfe50d48bc3030e8a7d14f95e39fbfcebb9349e2be62935795173977d47aee5fcf1f8709ec6ab0c41600f3febe789386a094d755615e14ce388bdfd89f977cae7bcf91658baaac54363c438ea84f04c758a3a711266635413cf8159f6c77b3fd760842583d853b218f741af67a9cd4303329022b1ecb6c4094f81017817f7f3d61387cb19b51d9e70926eb7529f6ef2e4627055ca58e524319b8f6afff1453e58bae97815f98ec2c817eccf51ceb6da9e29257ca5fabec908d84b737c76b8e0cf39f84678aab63987d4a2c9299563a1ed18ae779863c5577b5e9d5742bc274ff219c4ba79ddbd6a50c7cd26847d75dfdbca288712b886b305146993f6f8589c9978a396c5b96fdf461d2f58f2dec06349c7be583d4c0f0ac3183fcb276b34dd9030c5a417f202781e033d65d39f6b1d69749d8f2aee465e91d98cd69d161f761b494852fe85d2ad67b7bb6ecf945ab4f3ccde278d8041e01ae81b6bf576a22549a744b67da6bfe4b99a20a1dc3ee8c28f91fc61522bc06c3b4d12a199760ac81082aa9053d3f59b99f28e9366711c09fef1f5ef902c2d01409e6e62ad756449c473608c84af879429e7630427ce651442156b3c0b090f3248bcd0bb47125bc05fe5a44a9ca2192389dba98d54f367bc44fd4bb5d644ef85815142968db86e93fae51c3408d57a94a26f6bdb1733ea393cf7e4f1e3300369e2637be855407bdbbdd053ab6a4db89fa26ebd8084931bf5c687bf8e6cc802db289cfdb768cf333eeaa52af88f1738cf1eaaaa5aa761a2664f8a4cbddd82e975219c93d4091e1b4c623a37608b90ad1034304236c112cdaa32dd700f82960030b6179f7910296e289840fd1fac481dc5c28d29af4e03fa1f9a02cd07b6893cbfc29f23f4c26576d067e884b0114198d2f5c2a970210227e30b713adb5c624d449982f2920ccecf55383a2ae0a2751b61f441c2cb379aa3a011c1117069b2e573a13b18d5119581e3c671834e40730e6d37192c6def22821cafbf2ed03f8ee853d5b9dcf09f8ac5122baaa87420c7d18f0fa46edeef00de7ea35eb01794a3d7a494fdfca6e8df6db1ceae901e534d16156c3a920bf8b35b739d69d61be2fd985ca1a0bfb51b742b7c379ca150b0d44adfa5c0253948131a0bb0584973a98c058ed877b7724c637504a536042726dc43eb20820aed1b5b639509b4bbac8c9cbe884b1b80277e79c7bf764fb7535e2f1b75866257f340305bda6ba4c9f7025db022479b79984fb3409cb667cd6ff34a8212b5ce6ce7419752df9de3ca3bf95d24351428b130b8ad6f3abc074269642d8641ee19b9a228bdd187a8a07d3560286097325fe251d2bddd33264539b7b4f5483fe0ed2743536ba42a812c38f615949365fe6a571d0ecf5c3bec5079021f666723f22cd3352633d7a0adaf80484b319feef2c7e9aff637dcae91e28ce83da5334ba4fb107ba2796630d4c8be465b4b5127aabfc326fb53b350879c3b10921298ed6e60a90a193030c736920190cacf6bddb69dddd3193c302d5e290cac85b9dba603ef550366b33df605b4347d3d3a6711476c8ee90ca1e64b85a874541adcf297f9af895c4ef8ba7e141dc9fd46621cd3fbd6d51879e1841c78c115d8f8fc0d825db8475c4ac8af4b1430339ead324d2aae81b470e9b43295ad7b24a9aca91614048e136365cfff01ecab6afc0266f24935d01bb42c1923cb9aca96fc3d8bc43e434e7d32de5d1cd4f7ed4d1dd17358337bd9d84ec959e8ebb3ed8c95ed630fb8767732330985806ace89916723b8ba5fec144fca07d7f6505c59c1d73ca69237650c73b30628b97ea6c4360f54ed0e5835812238a90b4517fa3c249c8bb8c7e41c5e7f2bbbdc051bc1dff878ceea16fbb6c00c1d5912bce5bed80f24d017978ace50bd3e6cc3675064197665c1f72a75ec735b19646b660d4f44e7ca6a7ae27db75610bd730d7aac6a80b4281dd4081935d8752cac2f481ced9f53f362bbe1abde13b5cc239a8103060e7e1e463aaede0c4d4561aca02647550e4df62d54b72f62fe40177577b1e08a9af48f8b8b57816e72e9d98514229206171eab1794c588449b8c0f75e76617ce47a64fd0c9c74219098fb56a68f6770828a2512b29f518a6d5f2887c9ce2b59ed7bfd967bf993ea9ece46be96c93c8ebc5480f055ff4eb29b38573f94d386859a3bc696388ad0b88f36ee406793dfb3f9c6537b7c41e6254f2f9efb9ff6bfaac99bef19e04b289b405c340c39273d498bf2f2b1c98bb381d6172519264d63c4985547ddb767eaa0d003e7d0d973228555213ffb2bc25c927477cd83f56ee480cd9cc2e457931829019a78648c1f7a2a1f2a9b881d4d079e80a11922b387211977ade21407a76a23d9d5a6804f779423211314210017dda1f6df7252917375f07d93aed482bacc6ce7dcdea4cd63223d08dd4218aac456ec330fddf4de9cdb10cecefcfe59249451aee07da5d8bcb1d6ede21d55265eab92a1fb4c397bbedf252eb48d7fdde8e4da87cc33bfa04f2fc48ab2da3383299d27a4f2e481b2b23241ead35cfdb47f74cdcc512b12df56b81847e75a492c88242a5e0e9df8c7d71403d1774b7acb095c762cd5bf5175b381d2988da2357ac429abc69d88b9d9a256ba14980b9fb19f733aa6753e4aa05b0eafa5501fb9f5cb884d950db4c75ec4ed33dfc1a68d49a9a8caf36a87c8c4448698f22b59d6d7b6b9a4e7f61a8c5dab9defa05adeaaee678c3da94354a9bdbe763257eba7f8f197721aefee2003e974d7135afba1a4b43a873ad1c0e0f110e6351b88c3405a802481aeac5f2622f5ee805ee514aef45d6c6b05dc2da30e6ff73db5bf09e22bce1e68caac4981f84b705202cce0aa85b5a8738edd13edb29994d1546ea12c4955c9b65c9fcfc0012195b7726fca138e4dd1af33ba2f557b2ccd34fcf55596187065201242e05d1c1fb847bad15b81c90f59254f077be296214adc5e3e445311d2494bdd04ebd1ad3e3c04958feb28e60994d09538afc7d9fbc35178739fec6ada7c8e4d849243cc51053006160133a8b4bfa5f133db49acd6295075d7b9c2366c3b6a864ba28c8a6d8272e39816221b6734f17e5b5dd4dc2f6f66fc09c14b8e1d3145f18a35cb7509b52e0bba59bbae5cdd1120460e7025f5eda0830d5c620c6334f41f33df4913b26115e26a41e63916d2a73993cdbf331ab7f73dd3a75e4b4f7e6c7c2707c8c8f74027742db276fd6bacc3a694f8390bbaf1d46c31ee28d85685e8240b2205346d8518aac8abbbf68ef1a2f186533fa1c9c63a0e0de6a532feb01b1050f3fcb93cc88566ed215afff9dd5532ad17e69a4e999591f030e6c60692e66b3d78af6183b7cba99f1a33368589323f9c46873e45a480da6d569c28bd32e639d0fbe028f809fa8cd91ea91a748339b34805f64e89e488f208f61dfb0caf5f35c27848239dd82922e28a322a66828ca6c1260b7725502544078a402f123d2d4632965085fa0bc2da16d66d8a53606012f9e2a6ae6110a90d48ac9b0aa1cf802e540ed4ceec345bae2d9cf9a03dcab91f2e5be69c25f94c09844c26fcd39416ce017ae4ec6fb5e707999b262ba42328d4d3521f8268919c64b55aea622208711b9d8922f6461914a14c231f1bd2d45c0e31c7881d91eb99f9b73267618e910c8e7805fd7f93bc3d2e392bcd89f3cfa1aa05ce087a9e70161700ac48a66b7c0856cf44729cd6067f7ad06533668a2e9ddcd687372cf849a54ee7be300822ebdf614253984328328c877b9862fbafcc7bc1966481193f69c0ca365bac82e384a75c234c5e076011e6229ad0c78576582b64f891647961efa69fc0dc5ec8e46ffcb949d913352677641164a7239154e91ba8ab4589fb2e442f344fb64084d64d9dca59d7f7924d7f3fe3e253323f6e453d69f13bb661562423256c7cc7b00dde0f07e9cfaace90bf005253b0ba19f15c621163357dc70653e818567de9afaefcefd8181e62bf35e982def6a8cfd02c5fe4dbebbb5ff7dc47610f095e1b0aacafa2d3b32436681c3dd9ff0b88272da4f769fe85836268b85bad2f57dc4c0638973916088806fd25d223025043a635f0b82fe3af6eff25895379b14b58d7f3b066d3a18a856e4886f36d74be0a38ad9b072744936759694e936dbbcaed9402f8ab45474b5ee1f78c19affd7736005f5eea3f55eb137d00d37bfb477d221d9c7808f12a49f2755fbbd800b45351190412f17e1cee7ba41d15c0820b0292d7645075002da3fd1d635b224f7b84e4d7e742c30f29f988e9de4d5c47dd9a46665093c4d594a04afaba343c6095e2c5b3ec475c297de1b59a532e46d5fe2b8a4ef4c9bfa5b57a93625067ac888a3f5b4aaa4ed06ebda5e91078b20acdbce83d881dc9f6c704df1d32c57d8a8ad402bf6ef64ddb5894bdbc33717712566bb144e17d839ba9a9184d8ae92288416012fc1932b5bd2cc2787aa9f5816dfdb0dc4b29cc43cff3f878ad9b4b508f645c0677bd5219a5ceee96d27a86ca633f9b8b0a5768a47b997c97f6f6c7814c957d4dac3ad8cea72bbbacfa100cd1bab692b0a92d1868fa02eeb1c9603a1b3ac0abb058a2c6cfb2eba762f490089c96463312e9a17832418b52b00cf7e58d866eeaaec19b4b6b8be3a01277463ed6633ae03a762ab97c351274c3f38b14653257b583f7108575b8fc59aabe236fec71c7a7640e4ae5f3be066d059192fb57670122433a8299fa664919f541998fb008673c0b4e6bf1f4c277f4e4178e31f6778a7a90bee69315aae462ec2010b4b5ab0575fef16aa48d79e28abe7213d9394b45f177ab7876b47437e8fb3570899ea2b57726fb9c9d9be0e51a1a838107b764273a53abe3c6d981268af287c6d570a6e254ccb7dcab9c20ac4b60a09fec1ab8c953df2abd7c7dbb1a4987865e06483151f7f5bb71778c689629b0021d16cea3c936e7c0b81ef5894b17d838e72dc48176cd8e25ef9905701d86e83ce2f77ecc4452fb853831ab392ad7147946d06d425dc3924e82cee62cf547eb9ad96fe279c8d825f721f5a3696e7e08f4020b426823f776d92ef4d7ec7eebc84b23b3419d509e877be3d8817f552074b66bedce575b97a7bae7205344ee201286985bf2a4d0bcae60dcc3e6321e955830a4d5366464deb616eaba099321ad0de4af1959990fc2ad7bf4d78a087d10eed3989a135818c39939c2944c57d7513ec27daeee27ef104e1e9ea99e21845605972346f25c9a87bfbcecb91e28beb951f9959b946c20e9c055af5607c0c9d0b8c3daf0ef5f855fa76f7fd6a0c21f9fa7eac4616fa11682bf020b34d02739ef91496d69ecc2ce194dd045d98e360ef44b07b4b6570f0a52cf86f786e6008f7c663299a54fe3883dce74495bcdddcfa82241c6df20c8bbaaffd139f04e661e72585bf98f327dcaeadb32e512e45a070c6aee414455b4f17d98b5437b5dc165473a8e3923c5093dde859469b4b884235e22fa12f53f7ed0ba693f10877f3f0ad540c6d3680dc9f7c4381f71e479a8c7c5e0907db5ee983c5417618d302d0fe087ab376f8f67346f92f261844778c49313e2a6b141c26e56e0d2b67c3a8448a020836729511a257efcbec37278607f8623243b22e3f515802b013d4eb88f83319467607a91042c4d9384806242ec8cc4f183e8922cb33a4dfd28b843dbf3ad32235d26c7d83625fe6f293ad6b88f5d8aebd39e55eb3549f07c0b9f9ada868c184bb3cda74dfea509bbcfacb3f7b2961c8e729a91e337af0d615f2c06f59c42191501a4209d3dae8988a620d00b49d2831d98e0ab0666a7b834183c239833b7675ff19308fb487566a7d2837434dde3d680aca484a0a467906b0b8edf9eb39fc535214bccac0089cacfc0e5a2f4cd1ef3fa75d18667056360edcf8c34775d04a6f209c04b74ab1cb0dbf40a7448fa3d9ef3985fa39a460b677fd1ead520640d98d9e8eeb4b31493bada0ee6ba49fb75300b9ff7b29cf8f87bd629eaed43e1a8ed31e6ccc4d828af8a7497a9a896473b494a41c7a9b1a9fa4393c35b314c3a7753ef5fcfb5ebf3ca6d44dbe7a057504e837d7989e2b44ac5c824fe9c38328f22ac52fe6a40137dc746b6f3ce6cf3b91ea8173d2644a76b922ab20683702cda6131aff19a29ba22222ede8aff371f8c8c698f9326d19205a4feaaf1de060562eb13a8a07a8199b024c9f3f598d8ff9cb42ede700e4f77898714e96e66f8f0a077aef1dcb1eb01ae1ddec33f93b1c627819a4d42c5015835e967d47bd59830063342c5f29e86134ce9bee8efb1b95b24ef0f5c68248dff44827d3ada72ba3a830c7ca03e240301bef5085c42ba54e83d1ba53d8f41205e7cc10fd549fe3c03d7af14e8ce600a72086ec6ad478afbc48ed622a0d360e5c93ecdb2de52614c0ac7e08106dc8261aa2fcff11bb49b76ecc9efb1f51ccfa6bffdd5ece9aa2eebe67cb08c8bfe413fea1a266b079bb7a317e8b294644f1ed5dca1a4a62655dc10c8dafeafb09f0dfed90d2786daa46c88824c508119c1dda52675daad75d078555bc0631af40c17a05444511ca5dbd4c7a6da2de4ed4976b15fc72393564eb35be96eea7517e1bc6c4605c58174e9838b5a58f42e02023d859b25eb3f8f5e7a0c43c1e04185d9b06dec4503b26b4ced139578d103dece1eb028829ebaaa0a5c47b8d3d3d1e3680aacb3d66d14fc5bf628d0ab1adba98ccc87241a3a1e664eea22df4b515dffd9beb90c936f22d679e282de1446ad57eaf71287db5ca2c61a660134ddc0a1921b94833ab41ad0f0063b402ef369e04e7d4d9f18677fda1a1178f10fd4b120feaac1faea57955a111c00f2e7cc4a7e621a02f3e71e059c6fbcad37862bf8cdcd20eb0e73ea1bfefa7b689feb4a707c6d62addf6ebee5ee87091508a63e6d57171890f81b05c82969f3dec7d0edad48f095ae504f3567cd7e5500f12a77e397da05d6b2d476ef1025213cbe240a98cbf483930587b09180efc3a402da9f9389630aef5bdcda8499e9dbf8051252145c9d52cd920f4528b6e8a70a1c19167e8820c4f1c4a4679e46578ecca3e12571bf30de20f3fffce5040e60465ba1a11ccb91e4aaeeb587af6b293234fda444bf03d3d511c3bd73a255832e76dcf58c4dbbf3100dfa74f2667baa053ec1d8100888d0488362a7d4cd531516114680419867be50f0126cde173a8348d9e19115485148c7aa2ac3b903c16c0bf635d0b4466b973dce1652f69b4ff8f65b61678a3f29e8255699e156c9db137f1aad49acfa8db35d80e3542af899462fb2e6dd8c120d79224b3906ac16ae60dcb4892aff41922e7b6dcb12fbb3b17f907ee8b645014acf0df244dc61307ee207fafb0cfcabdefec1a56e2896207be974734ede738489d46daa8e502fa60d8d391cff8dacafa881523336a3ddb946cea0b72b66de7d000ab52769c5d556b688ac0ebe8f690d72035e2de38172e59a5faec3568d730a377b6c8b39cf5e8117542eb875169c60c456be8be2b5375cee8c3a9646ed20c6a778a04d948c504a77ddc00ae48426ff3b5e9218d436077d147f823b750b780fc16faf1d5c7777c51ee840a0c642963fb1d64645423cec08c92872fa7dd340c578d373c1c1f231ae8338d2ec23c117106b10a9dcd36f765aa909ea10b06222b5179beb2cffdb8e5f7cd06b131df9c0160f140be85cdfed64204d5932ab4ef8762508a7d62662f035a15a341186c6e7a91c8cc6f329bb69037cfe211be383668c993f5bfca6da763ed893cc29e578b50af628100d32ba9a1ec4f7e3a3d91ad8f132b98c8af616ff7f55fbb11c37d73258833b464982f2c80afbcab76fdbdb8b165ba8bd95f4c91c1d2bf655e60568d5d0551ec5a42aea5bf9f0c8ad13d110ec23fbe75d7fa33dafb1eaa395e5c4422c1f5c4a3a9a6ec1c70fc8f5bb5bd9a96e8fc6ce549ec250febcf4540070f4276a7b9f5e3e873a1765cfc274586216f0dccdab5128766758af5f96246e0c598447b451a60c13d29b3fab64c6a1807e0976f0443612a65680cd2d7dde35ed10c34b025332a7f8e38dc4c2f86fe7ad19ceca2e955f8cf5cf342c80d701e3effcdbb8b5ebfd24c40aec9e24b34bb55a8ff4e5e77ab0bcefb78eb9f7e10748ec9ed95478da6c5eb149a2dce69b5118040e24c79e5cd99f6a23390e778ff7db78b1fbab36e5a07259d96e8518eb42d1be5ae3facc966838ad227660a8d4219dd363727a4f6d7d0d84e14092c7bac8f906b077056b89c633cdc22b1eef8ea53e273562c5735f62386476ddeba60aa81c72e0db9abc11907dc097e6bb9f1d5d6e58ef2ad3d0ed59445d1a6d56cd0af9de5459ea256b8007b6a2a10f1d5dca41ad0cf04af967a4955465f8e28fac23f066d4de33e9986452b356c4a5ac14bf0ef2270789929d6d0d6ddb865080560c0e439dc7e096eb0a526c5f88850b00631dfc62a9be70579b6e9277d5e9dce5ab0a514404c85aaf6e2406e769a78dc2161a31e7c4357a36de4894071c1dc412cdee65b3992718119507316610009f03be7ae77c29b05ecbcaa96e49bacd2488352281298d332996f0046636fc472995140a535b3582ace9dcc12daf35f473d1c453061bd82d8a0d1a605e972a9c6cb786584a8b900fbccf63590edf7835cda83d3d4d8626df688186f5dc49305d817d0e5882ebf48f61c6b98ac04354565d107e6daac13961e1336c126ad321fa939301cdd8407fd63091362eccc09e7d3170cc4e8501fb5a0608ec1f0184c05f4286bf264efe0fbb41a1d6a78842ac948a5fb924ab70c7733b5a6d82ab3dcbaf62a6a0524b6c4797d4b4b866db53e2a0b0e26dd1f919135ec2e36499f73d54c703b63a543020f99231548d870254539dbc15f7e6690a16a5aef219ba8bc5fcbfb25057862d5f528c5fad02c3fa5f292dfd885056be49e93ceb1bb7278088fb1cae019e9a2844e383cf151761a1bb78bb3d782451d748d89837e3c3e66f6c3a489e4cebbf41acee916edcde9fadfaee5b1ecbfee288a38050858094bb090635702cf9c583c96c279f0cad8b17253de0c5d9fb363bab79d95d669ffdd4b751e6459f81e5629014c56d3190aeba906cbdef83ea4f29920bf6ff6f2515cc89cbeb98fa351d7418cd43e86378127b2b1656a767666c9b7dd32cad964a287b431cb2a1b9c3abd34d4d9c76ec46d875e8c35c56ab579951f9c2f15b6b6a408131c70b2281938e4c891ae3975cd68f52bc596849709e2db6407f6976b10c244235d50065840883184771d20af1b73dcb8f9dce370af62b6ed9ec43f8bcd126a886cbfe776a5aaa07add6ce390c08aa21f02f7520b82b88ffffeece30e0ca73f8a401ff61a628870f1b77a38054ad265398673f54528fe6eac74f70b6d198e7089f30c30d8099bb9ac74bcd8ffca496c5112743f8b0a8dab5e8e1b93bcbb86db34da0e0538ba073c0b50a0641000b92a6e44090386e786578a88aa02ed9fc1b4656330b98b50c4a855502af415207fcbf4c67debd1e76dd804f5513f94fe9f5f8e34ea29e482d922bb320872abcfa40371a025a5a2f02b9e1ede5f2d23277696320ed9c9e004efd8a9412cf839d99911df5fe3789d3ff606125a2866c431aeb9d88a5438c9a428da4cf12a30f918bc8a63a4b4c351024d1640a66d809abc326dc8ff839ba935484fe972964a3ecbe0e7feea11d4b71cadd729043dcd97d3363c3726b34aed6d609ebb4dfd4a261a7dc702be148bb7b7a011125ed307f439c402973eaa42c604e381ec90bc5e70bae1d1ea6dfe277f6af7681d75555f2cc9a8b6c82d6198be130e6e21913a13ad37175b0d572bb8a495c944935ddeb7be3d36ef44f40cb480024df054e70d19f1667a9835f6cfd1cd0e4b18d116610e497ef59a294b2ea8129ecdb35281057657364c840ea2f1dae256168df67def02fb6723e52f3a168c25dedb5208cef0756963e0b9a80d06da4fe7c3a090f19fd383633d7d1570c8d7ef9b50fe9f27945db31c8e25e85d5f0a8c8ac387f9a25d02febc57dbcd2155595893c385ff37bf7ebb637c836970b93a8c85f49f99b23fd6593b5bb6142a19156ca9119fb8c26c28eaad58be18ec912ac968b9d5ac604ef08d7ae4675a522645314180a6d11a715d78fb8d2d052d853cc32c4ee894a23d8c7755788e79c3437e6c395d587646c3c3864a2a8c4eb7e1b63f8788e68840ad4a3585502e56239b06562851000c56bdac6fd4d69035136f55486ceba0eecec5750cef92593747d15aac10ea66d9c99bbb9eb68469bd456edbfcafc52ee9f5c39a39cf403fcab597b31a70c6f106fdfa5b2218839eac211bc4708dcb31d56ab0efbe4c9c250576ae736049d66fb8ca0ea3034fb49317b6b7508fb5f4e84f9f83fc2c36b2ff46a64b2878aca5e8cf5ba6df96809177e84895804317446be5d93d137330c9ba167543d076f2f184f29a949333c687392cec733b95985ce39497f8f846f68f5bcecb1e4534b17f2ea2747a550744a2cb5aaf17f825108ad01405ba943b39346a2a58c718c19a3e2c02acb6b016ab982c5f7e576fd3680e594db70a11df2578443240d5b0eb76c6276edded5ef3e74a17744ba69fbb4f6335eba005c4e097192f52dd7b399a6d0b402a2421b2e4f543696f1b9f3d46085b1ab0c21ce1509620d11145f30bafb4b96c0275cc2ada8f7c47e3b2b4754f6e7a4ba31c27da61068cb07ad069212883115091604c7e409ed2809c0612f621ba5a359d78addcda564dd5c502f01b17b222d3733e15c6e3066a24f38fc9102676830357466447a44e733ad577b74b81b472515d4cbdc7670691f239285d45214a00e879904493d9d76dfc6dd4e629978e8cb75a2746780e4bec6a853d688c5236a4b44be59315dd5cbb8a520498e177db0565a5003ebcea9986d17b1aedea47f7740b5a1d78bb99e265d69259831ac575420e41d2410109794fc56f68095eafd2dff56fc3cb5ac9a6b6a267244c516cb0dbc6b5b2f0201c9ed19a6b460b68e750a3c71b9ad8d312f8b3e7485911827908edbc6081978b6584349369c193130fd0da328e3bdbed18fa3e9e912fa5c0b18e2492c3f91f2f01951f8c7b1b044da5347635bcf0b7ddee9f89a98047f9988ab02d8a7827ade8b0463d551152cf787f2713c273661d1132cce9100542fdd5f4dc05a98098cb0fb93c036057f56df5c52b63c00861b553adc9f35185ba67766a8ea810621f6112ef58998acf30033561fd94ab2f1b46618ede7567110cdc64200687606372e9a4638e8a30c87df53f077e0cb75aed4716b3b0e49455bb6a82dc3cf76f2f605178f2309c769f5a8e1f86160d85b6f21ae01d402c3e2df5dfdde71de4bbbf6731b62853c5d7476df6f98f6c8d06423146d45778e48f9c9de3fe2ef929737c158819bbc6d6d1197981926c7d0ee60c6b60447463c071db3a4f74795b01ac5f1284c89cf761622828a2854ad1e4449eeddf51ba422c1f15110277431511c2c901d27a542a94852eab9c45b83a4cecaac2b3cbf8c38a926a256e18ca2e699b814699e7081fe279228bf630c0b0983ede083e9e7f2db174c395f73aeb33634245dce5027f673fd8c451d62bf7513e727ac99c8706a3666b420f2151b9b2baf1de22afc4a0694f6e9bdb083d04b07e377394bc7dc7c0fad99210d9294fc26f6b6379e63e4e6e18ced10adddca67f19402776b435b62ca220a736567f43d7a95f32301927915cbc79eeef6c95f2050fca13b1f0efb23fa11ed71bd0157e1e6507284fbaf503ef1dc16fae1c8b052cdafb3f17fcf6f7b1f52ae4d8e81bc03993ecbeafe05c9d7540a3a46ae7eb7783cca9eda6419c604460d1a90c47a165fce4158fc9513100594aac4fdab126b522fe654686fd9c5f7fe12e99b9187358e74fd06bbb53ead25f39f861a5eb9a6b49b59ffd16d57b21b5e5ded6f7edd61869a13670cf9eb34e0ddb098a9999d299f86416077b1a10e3001a5e079a7809d300b6f866679280004087479a2e6dec7235d1e6d3dc7ef67553a8a910891a34e0ee5ab37bdd1c30326714e3cb9e29730410b1a5ec71f57560c63fadaea1706573fb458b929a1f7e947f33ec2d69bb3e4da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
