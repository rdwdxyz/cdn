<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9110fbef3b6cb0e5f8318ee93843524702baf68dbba47d43213d9c5e11884179d52215546d64e9f401573bcf39eb93d183253cd5605bed877170335bbaa60c74a97d1843e0f78fbf12898b9d9551e7e7f63384e5cb2769288adb8ca6a072dd9893618beb097ef316d48c0c99358f31b50eff5cc2dfb177aaf01199b2f3ccdd0b5521f42bc278ea34012521af791f7693772e0cb9dea321479ab709d7355933677cc7bf1ee2013ae5c95990b3a777ccd3d2bab0b2e291213edecbae509f0540b2d4e25ef05beddc48d2d3a243818c9b633ddeebb96db6279a4706cf370680b0e72b075a5f9be0ca8fbf77e6dd4f7b615a737b1f41a81eae5caaa2cc5ccf4b3de59398b1db39685818bf995ee9c384ea714fe5685c1cd97c3fb8778beaee4334440d4801533f05c65d3c3a0328e0fefb18d31b43fbe9cfdbfcb0c377a08436b3b4eeceb57b783b839eedcf7851d7f69701cb139bd1a630ed3877fe6323aa58647f6b264ad570e825f81353ccba5936194668a93a397d629f9c2bbb704fc87869883e005b0031392a9a3f6cc17cbc3e7637ce166785b1636ab5a754b242fbd52046e185bea04539b1ed167ac2e47aaf6e68b26b93f822800042fa6fbcde9e9925740c065db4d0a07b934194ef7cf2bd9cde32343b83eb1adef69142f4f3472d34248bfa4a8f9e161dae2460c983cf9f01b3a05406117674f3bca32870f402bac441f18d0fbb32172e1d268ad09fb0f1b9cce9551c6ecef24e349fddf2ef640fb82f0f96f4032f56d7abfa1e602ffffa0516cb9fb0442046163a8bf250a8f4f68db93fea708a30c5cd106fe0f6ab2b5037e6c9af548f5fe5d01087e6e69da51bf6c24f6ab55cb13feeeb33ebc17723c6c5475359d40bdd4d7a6783ed5fa522b100502accee577b8c6188801caef9570ad4f04ba8aebf0e1773e5d2cde44ff71cfbceca94d1dd0ed56a5c0de4b8d1974f17631246a8809ae6b13adf05832954e12f0def319d75695ce321d6019cae6a51943360fde43ff1f20912117513fcbfe8be13b56e45612736b55bd88ac5fb72dfc688a5cb6eb9a1605342745b67426db4539e2491306fac7c6aa504d8e1883e1ab05d6d1910a9934f30fb37f150f5b40e9ecf2a718e6ab8084e93bbbe652092191863e6be2df15b85395951689fac3b0299823626ad2106828f7a22542783576d8d88498fcdfab310ee0c4d523488d8ae8d33b6d5909de59a9e79636dd8eb1bcaf334e01acea8db220c2bb5becb246dbb12d89bc3044e55e62be26970c0c9d05866b3760ed29425516b270a67fc66d4015b7600aa055ef4535371c369f26c66b98d062a235da99e7a43fbc8e5f1d08eeaeebd2c56a6135398890d83d16645a8b1179f478054ca19d4b01c11f8da048cad30da95b942d244db9ea027cfc0944a84ecb6dceedc849b6870767ef25597e8d5deea89f2e3032e26dae002d618c6662a1ba1e1d3c1accf75985cb752ac976be39a7516b386fbd7a7b9345ed4316e9adf0de538ec88efe770e31d7bfb536dfb9313e810737e6e311200924031d4c1ce5d473adae0feaa1107a66fa07ef67720cc1e17a5d01fcf16d44b9d4f031509ed32c9bb79fc2ffcf13f3a0948542f8f02cca7ffe8863bf3d2fae292e8b5d3b2eb2f340b5bed643dd8df20131d0252de43381ab6c3fa4ed47987543db8dc7eb9ec0b3de1771b277077216e0ef451ede6e3a5b7c23637bfa1b74be4ac1a79fada82e7281900e6b107d6040d445c1dfd69b8d4460b6a9ecece75e4b8dec2ccfa2e1f46ef73f77989a0379b1f15399f7da91b9501dfe15a481814849304fec7d8b2f37a59b4e1ce58ca2d38234fcbb903d6bf20954e382c151ec6ca11b5c8d795125c60e431e3d87ec8d56abdf1512cfef910878acc52df154e682c68fb96ac7db63228d4785e73d1d08de3032107399ad6f84735113144b5df535d09d561732de9f514a504672d645ab889117de8760e35f16b8e3c37f91bd9bba4c258bdfcea1523fa6b60d59246a9b059774cc6459df6b47f70a83ed613aed4bfc806a2335a069c515fa4be2cde0d9c572c3c1a9398051bac1edb8cf8b32e4cf6ecbcc0fc9cf34f6918f69539834b321244c25bff361a328e7d7ed9be9b973925619a7a348f38c0c9fd906f81e285c2427f6232603ac1556545438acca9d9be85c94a81bbc8b080a65c7027a2d81768830e90e8b4afd828fb6457d2cf823b1cd9a1675b635b1d8d988091940a526f9189abdfdc261fc9bbd1a0df9b01eca207c6baa6e0f9d26986b7691555e13a1e9313180bc50f0b92a7625ceccc74d2718052bdaf7fb435f6fa7f4a0434bf96b054547950a4119524688eda1c6adcef42153e4c7eb32496cffbfa82010d3af27babdf1937115931567ddfd160dfce06dfce4dcecd2df20fc8c64ab23a5789edc50841fbb2eea3076a085c68beb7548604d374300cfefcf572a446375426fd4e6b591f45d3a3d267489f4b5e984d90cb251efef403d0ade4c9ea40c411698de8ae25674e95ccb6ef4cf5cc5c59515d8d513b5d19a4be048de24cf506cdac57830866f137bf8365dc4abe342a2358f21281afc41356d16604a39461f0a906bcb293c131c9e3ae2972715a546080249947f968400588a23a54ab5133f28ddd16f66b1079a2db4155f523cbda77e0663e828888808f4db48f8f6023537707abc14060656b8de2b2c818dea9dd4d2cc245f73fc7759a5dcec357b32ffd3b154ab1f64f484f6c076785aab1a20dd1a4d8fd768a15f9694eb48e97afc471ceb57735c26ffa2661b35028f20d66cad8628f7a5641232dd1280cf74ddef6d6fdc3e4934fd8b3cfa3e4ddc5960fba47656152283ebc9cf95ed9aeedf0a8dec44c4d026467a3e3aca830524a1f56f23ec827b30cf4fa314ca7b45bc633187b7df531115aec7b3acff3776c39ea02f78ff6d90d1a8fdb00b501104add1100825909c22ae5140bd47102a5f075f50e3895168c027fcae1e324f0ee023f3e6cd49f572abed766c822478ca43cb8d2cc389dadde508ff9d4b6e794721d1a797c50f402154c3e3182f9d51eb7955dd2553538679d77232c737d888ff09fef01674a7d89288b18a0516825e2ff6aefbca328d4678efe1e47dac7310d70909b850bb4f4abbaeb794e8194c9ee219234f5f45dce1b8fcf791c6c35a5df390cebeeb5eea2fd12346ed9a8e81cc257203a27c1cd28ac422ad9ec2d6c1308404833a02f4f8df8bea9f82bd8f7221a69f0d0a213f060e5f807dcfbadbe281a7494254d5b3fa4fac74c7bb2a9c1c155a45085c6fea22d9674f7fa8fa46d831369c770c0fe42d4b947bd6429f07cb02aac77768f4843bb9894cbcb90530b63bbca1dbe5cfe58a3d3980f7b47459686b56f431bc4d553a6b5481436ecfed5bbcc22ac4aa6882b34ce209e1115c55615ddff8616034972b38703715d250d275e67580288a66466074f25ec3e8c8b886e40212f6c22336dec0d22816e56dafd91ed79f14896e485244b03dde19ac2d26f1188dc501409941abaaecc038b71f1d6f826f6fca9c6c4acd38ce11177c03ce748c15aa1e051c5fb1adb209275cf8d8d4db79594d975dd7b96179c42e03bdc9bfb66af6f36440430205f6ebfaf19294bac844548fb33000413d0cfb8726d4a177efd52a20728ba6e27ca86746e52ec66f7e106b9b4f518a2f6f2e90f7cd15540d7c520b570386f4c0d25c4ab959b81dfb78069d75f107cb241ef66522e03a763d373af26b71bda32c0b78cc5e337e69842e586917e24334495d0b87ea14ddda2c48e91ba93e78f0a02e25b18a6b061b5a1d47ce1f2f28952681f5c566402d389f6455ea57717fd131eb1eb16062dfacb05168ec3d137fbff758c03de24b54029146bffbf609ee1eedf1f3cdfb1328a64e5d6996798ad44dcfc3e75460516fd597495301429b0326c3c6065c9c43f753a6a10a669c7fcbf885ebc8640e9fbf303c6dcd9bf62796155f215ed7343837db9df36615fc002062b04735c3fa6e525821dbceb7c562037b3351977bdb47292bfe1b64d7bf0bac5b73b99519670773fac300db4ca01dac3b759d7b3fa1b4029ca3286555054845943dfc73acf14ea726a61a479c1dbc1addcfbb6d558b67b49a818c4505cc079cfb625786430d4e9d7d9c280a5eeaa9ce4e06419c5fd49f2b6df37a3cf845449b21e29eecb8497ae82f3353bf3f5b85a7d41a041e34834a06e2b41700928f899cdd8dd11d778b61537859fe9fa5cafe6f6821932075ebda6a771c20bd684095b6a59713ddfa33bd1e86b79a53650f2af9997c714c6cedbcc784db38a87b2dbbaf3ea680d2fe5f540f02b70d32820040c8d6981d9eec880ecfb25b398415ea4a065d92613947d688d435a50275a7fd8a4f94f8896d13ca1982b32e8370fc2434cba57fca8ca5a673760d0130c2c8cdfa6a983c99046a9a0130b067f34f3c5492c8e449363cc160815e4192ba776f4a39c2b9e31b2c12bb5e749184328298f62eb3ad7cce811ab4bac932e66a6764c0f0f9222b8618bce7a5537aa1d3d9b65c0dd0fa254e44aaff47bbc8b830ddff5ed06f0b0f122359fcc292a151235558508d839877c974c315325a129baf460f96fc651616c5f565225aa6311bdb86dcb4ff66b86158003b45ddff08d75dae011db51ad6ab20cb95ccc235f4bd363aab70f582688db941c7b801fbe9e594d7f12c58b9a3b18c4577dbc22ed97f0bfa5fea9260852ae2a14a8b732c010f86b56e1b3278731c9ed9be08881b49025438121ad52c904bf58e46e80c192d5bf7465d5c499c66eee9d4e5b70c7f545a3d57d0cdcaeccdf32386551245c85a8b02a63828be6a0dda90bc49797e6c560a3d7c473ccaf45e6c0cdb377f9d43f163ec4da5633cddf8dbdd3f1599d91c68641a680b9da202ac97d82b8add8a2d3cfeeda38fd9a90aacbc950a986f4b29c9e19e6be3e873f5d9d9e67804ee002e088e1726bb1e049a424a8eb01f4936479a5b2460b274e7d4a473b49aa8155445bf8128f5a88eee381360388c295262e44e2b0c51624ad69a2f0a493efa95ca26f35c162a2b268da8d48fd626ddaffd917752647aeec2d82562936d2751ceb9908e1eb33c3f2712bff1a26a79f4d87659b5d45d1d935024cb1059583178476ae6f903aab1cd1fe102283242e52dbd17e1fc0dd820689182f86d225aa4d6eb935fdc7b1505a3b84f186a452e39ff951f820d18d0392aa63aea8b068a5ce29496c61ebe369860e3719fedbfd6a45abbe34f83cae9b0211bc2c66760be60e8ac4e873b30a9b60c9c737c5a10e53814c95e79552675bcd913e65425e83c406608adba0f697c4e57e575265e68836d571115663eeaa1ee0d0e913d1ba432517c40bccf74be0a51a7c8cce1370ac0609a8674d44e0c3df8530bfd8a67c2561becb381f2aa7ad29273c3e717f4f10be0f0889c9b89b60f38d24547581d52ca8a28b6640539458f104225016ddf8f8064af72bf6e02fdeebb413d69db4e644e65de6da36ac8779f7d0e16e152b4f040e732f0462ee0246c53df881b2028b7eb3f6b8a2434074ef541b13b1510c73a196b624d9b941897aa516d215c02c60ea20c2fc749790ede99c45ad453830ac9239ded744fc8ed9685d90b281c16fe65cee8e6dfaef867d73e8469f988c82dc88ecbad3a697c9a6785e324023a73db6658582c64b83733a657b4b31e580e3ca3dbea9983a3e05befe948186fd2bb66baf013fa482f7a1d01ea42ba80b0ec6f502f5440f7b44bf1aea8ab912cbca89d75c57938f9edc137dc6ee48f922597a395d0f69f47caf2fc7045d872bef2e2706ea798e0aa10ad8d32cc4ad9f7963fde55f575fe7a493ec81020661505ee1b5978ffd1a195acf90dfc54d9a190822e0b9b9345dc6621e0f1f0c7b0c12a919419da8d3b670245d6c5cc442ea0598cc3c761bffeb2f9ae86d44a060fa4ae4ed72720237032e252e7122e77e99b0cd98f10940b6f77b444c12ceeb736fb142dad44c892352d53f8ae17270f6b20b3d07815b3c55967fc03d44fdb579204a33f48fee89d9a2c686ab1c4fe736fb3e165c2814bdf918e3d932ee99e233f19f1cd715c817aa18239c38fd19662345821d4f35b70f4ceb7bc37fdf9bacafdb56c420e3721bc1098d64af93e2bb101a0c58b7912c3caeba8b433c6d99892fb3c965ce70f81f79f7ba97df14c4ec154fbd97151b051dcaf1ec400acca87154cd0dce3bcb54c9f8860d706904493fd2ff9811221e057cdbf1be7733a6db66e58ed92e9026d2702a8aa04125c523bc035082f4b84f76c9e2054af21b91f52c676dddb51f1e5cba4cb6f0b5d0bbe0fd57ced1df65e45c40e61783032a1471fbcb9838d7ec79c4d836b4ef6e8d96bbb876020656d5e776222e270fbcaea76550e2a38942611849055ec4e9221b8ad13f47cb6bd0bfe1d1041bf7f77a278b57c187eb7bfb28660dd5a7d94147f40e868c512616683a727cd74fa3f8b7d46a26973374a5624095923e8533ef7358d69fec5881859cbd53234598297796a94df0dcbb682135683c294a372fca7359161b5668ffed807386f3c29058d20de54a910298c493fbf975ff0d1a237e7f519df43fdcaef531c36e089ef8aa6375cec0652ab50c88fa49084172bb2d418caa14be16cfcf7029b2eaa93d8cb4de5d659a36e54f987edbcc1b538b9aee430579005b11cbbbf8086faabd94e5c4af7ebb2345f056aa1436cf678345b516eb28fcbf8e959384536e3e08f7fa92e6bf8cf96bc3431c6ff3336746bfd51a84165933e7b4a6f4f2909bd47b10e5620bc2c011ac1a1252f5c99ec2d8b2099267950b169fea5b600af8ce2a2b86d38aa53e38e2797e2df6defb54ab7531a3e60d43c15f8cbfca74b50b7c646b732e2298abe2b894207b090788d9439994f4182888e649844cff5d67a8f4268bc640f53b1b11e55ab9fbb2a9d122d07317ba469114b2ae89b1914a861f79c9af788c3eb5ba9711048a0b73b37159f28312d2d06419f7c7a38f3e1d4cf213cf7aab6488d9fc570b7f145ebabcf2264ab692b9fa28b70e7f72bd6380007ed78b364f2e019112fcdb2731c31eb591b349e7d061174b9b694a97c61ae709ef8ba139362da93a3020b8af1d15c53e0db49f7f58ba4b67e34ec5cb4c54ba392d2210fc0fba1d1f62ceb2999298b39e59f4c04f98a5b5d724de66c17e667fbdfe22103d3c307bedffdaf0a8c4b0ea78aec6a3c6815187320cd81f5cc52bb9af3350acf3ec9e3a6c44ae3715530aebc382d84855e8dbde48c33548b7eb019fcd1fe8b6b428b25322d35d5972814559b544c4e2a36e72cc417b73b484f89d803434e9b46f702f80b70a32717979ba412f21e95aea90d58ed518cde762bbb0ae0f90d307707c679a81e7545fa7884c75b48535c0a0aa4b641e9e22ba7a3daffaf1ba997a10c6f7415756a4c8ccc299fb7950ea35fe9c7540b1f09a15c8c2460c5fa44100c1b50fec522475fe0a08aa081c09b2aee63e83ff89c11667bd8dab51137fdb041c917630d5fc0e5a825a7b62111efd64530ca8fb66952fa9fae3b9b2c7a1359b756294fb9627a9faef733eb0803531ead9566a67ffc1015002d610d1003ce0d173c416e4e2cdb711f59dfc6d03e65ba878118b70fec266812ffe32f6bb03f8a1f5183fbcc479e4472926fdc7b4a76c83957ac04460146c2ce2b4ea84c92382ac54c91618d01e42919c2aa0dc6da566b3c1a2553a00fec851325ec0072bb7547b8b492d74b1ced16e282913e96f759fca38dda47016738490bc5edd385f779219d4b54064778fc6aa8f5278e5b7b7ac656ba483fb0c488b078828673871cbc6efabbee7e63db0f9fc1844d39d138c093b13ccea5c8fe5a308a93a55c4db50fed2aaaa055b19d36d2e3c8f46a3fda4283af06b42058ce963cb17f58614e1d6f9f61bc2ef80aaaa6887712a9723ef6433cb9244360ace4b4a27b92f977340a5b4efe86d509cedf2e10fd09aec8478976c6cbd42fdaa4b5531c9d275e21bc3438ffea8038e4ec15079e6a95e280a7d84f92559c5dab4ca9f01e2a1f21cf42867e84095f2684f1ede1ba6bfcbd5fd4c7c03cf2f063b5e28fe3c445735361431fbbc53d0f5a34a31295ca2dfb7b48895c137f6692084eb849b533991fbd896862bb1ececc74d06fd4abe936fbf335b1c73b194f479a0fd82ebcd8383127671f3a15feb88db5e3b30f81b8889618167e711ce414b897a1a013a0aa88e89d73b0759ac375683b160065a10159b73641b9f7a2cddd65e85458553d431fd4d50a6e953df6c55f771ba9718264d658c16668af58139adaaf58be34d86070749cea99ef15979a6a8e06a65156befa3bad358c155ee564757811c901decea47b4ed949838862dee9aaa8a5dc28877a1502ca85f492a5e2343c4ca564971850939648bf3fb1ac3a28ec02b2a5face7710cdd72410489567f4a0ae60286435f577ee7b3d2015f5f27100721f2d6abe6a0aabeda1cde2e4cfcdba4fcb635357785885b693452d1891f6d53fc1b22d4f3eebb59886da9beeb1f0719a61222aa998c16db8ccd70229d1af9303cd03cb15cd3f6042b1cc593c26be6946903aecdb76a205a7688f5fe0c3f4b0b5a5eac7604bc41bd43d5814dacb79889ddb094dac58c22afa4da74bad73d80a2facdea1f31b05ed9245b420c3c77234d6562bf3de3ec365a84f9a27cc84aa666d4e10fe6ef8d24699abf816544a17859cc4929ce89d9620a11b4c2e6abe2587b07b36624643db9ffeaab4a7a6112d5f9d6d99ca94e8de6ce7eb5f8b8f09b5fe8b25a85646f9ca23099cd8652bd6fdbdfd5bf90e6d0fffb5293c574bf4f3e9dae5b1acf4fe2649591403085f2eb40f2555b6eeff58638b8a7f94418d750b2a3ff3cf4f4841aabafcd7ae7932fe118aaf95ed7e40a98757aa79f4f7ed438669e9cdd5f5296a145a708c5bbc9889d6bb9ce54dc3fcb7071345971436a1dc1cda749f57726ca280302b270ee2fb9a4bbf149c6c0da95ccd5ef9af927b1fe64a1488c144aef39cb3ef8874a841f906b3d1e6478b1661304584712ce9392acc1dc928b386739093184259aa449365d93f6bfd9828aa5c08f5192ab883be5ce3cc1661c53b0081428351488251c2fd317c2449596b6c73d2846a8828823a3ec9588292de68fcd4451aad30b53eaf1f411680fdc958dc89d313710f95f81e166e5b6f06e5d2c4c1267e28765c44a1fe3ad874c4f74397da7655e82864e91d42186dc34313a130bb4890aade14119212b5189636abcd7069a0a9b639358f1273472aa80d4165e00727c360599ec611a145b3e523b3f134fb78ea90a480d51f5ecd7cfc4b1207a4b25b6d47c3c2a0a2b54a6938e79f4f38113587c92615a1bb5dcc738c23f0b557d6311306f1d62f9b832b970f41fcf95e8e194bd473107103db2cef84bbe176f2f607581231b13384d39ba2070faedb2f5b876bcadee531dce4df40e564483f5c63ab9cd26f5cd323728a30062852b829c8509e77c9ef8ed581e0acaef12c58dfffc208b568fcc2bccacb25bfa9822c91ed22d5bdce5a1a3783a426677f3f63cda5a9b7991dc5b0dc67c75d74ca0362eb8ae6b47fa1234e271ea7b42b49c1a2a8782ad60f130e543352c18f1ad542e0f83c0dd642238e2f2822ae4baacf382d7097b7b64eeec20addcaccd4767b1ae5a6049f2e5a65e7dff0a4416b698e40af46b8431cf93e25b59c551e8bdfd128a325f52aca74ccc26391ee39ec60729a329067aca08a78bb84b922f977b824f5e34f5631fd5a8a20c7c363f60636fe68635084dc38a5c70450071129ca1afc92abdb4850269b788361a60b03ebae20d85bc2834130e48b39bb32088abfb3271b3fc9f8414792e3825c8e510c9465693e48e2aad2d504912b915aa3666108f23e6909a7c81d85d6bffa26253b96c288ca1c106371ce050900a33676321856f3a0fc6202a14e073c575d38a37fcad4c940701bbf522a95f8a7f7976135135abc5cb376ebd741a75f614e77aa69d5861c5055604152b2051a763c24e355fb427b73ab8607543a20ec0b9ae3031c2c96ba55aadd4c4428fd4403114e3097a6eaa2f7af2c921bb7655eacb7b9f918a8c9122df23d1239e7149ac00e510cbfdcb6fd2eedb3cfdd50be783b9f858dfdc61cdcd1c289f5ee34c6a367b15bbb4fbcb167bc09be648f67140741c5c546caf872b6b2d56c67b62ea3004eb284b0eb22231c186060681fe91f13b74e49ef38026456b330447b5ea529cfe8fd511d11ffc0a3a2ae4a3db872c8af41bec1fab9f30c52a6700e92b7ae1a26386b49b679e3d0f99c6b31f5f49bb1f6d0835cf399c0b89522e297967895579b2e86c5b6f54f0db3cd4c9cbf96b35f4d9bdfaaf38a54fc2fed6dc1bb577fc3f5a60db5bf065d58d01b48d74eb39da8c4eb562b335ea5364bfebd6097254015579f5350d0b61a401d0a0c8d65cd5b2967602f318a920a8a6c5abe1db4593c078e9355dd4b3414be0422299ed7f7431915d359b9ae9a9dceaf905ecb1de65654355ac43f75ad5ca9b377bbf105bbe35c3630a0822ba830e3c38a58e38017523a69d90173557c374f1331d6e33c2d966a930cdd45a79231d739251c683c5e2fe249328c537c4634e6f9c4d96c050d4ed912269a998b0b7bcccd46357e1cba136ca288e36e14537784f09f21d2dc06ff0aa86a26654b3a10b2b230f6c66490659cc6e335dcc5abb68f835ebd6e702ff49d006c7d0419fcc2a65c314527f468969c4ec1bea89db9d5a511610d864462133abbc8c8e6eb0e47aaade78f02b74fe60fed2fe485ab77e8911a629d2fd8b5cb101e0991d759e5abf2f7ab272672591621812f48ce88830c14a3df323b263042fe4ee0a10f4baaa842c96c42c0cb55ae1fd96be9ddad6978216f5cfa5d7d5003348e5ac7dc272bd5405e40cd2a445fe634efa88b98c0743d926903cfd57e699c511db957775fcc9e15b426561bf9a561ccaac6ecf4ec89356b8ccf94aad3b77e7cfc06263b404dd131a5555b650bb9252094b8f3f5efc9563caffdae7d2687c5550fcf12a24adf77409f3b8e24f6506189698f0f0add08986deecb64298f7caae9b890665382cedecddd008af938fc3e3d9a4f189006500fad660c045a99ae43f4ba98b356979711e550df2daf9277b628bc03ec5e5fda19ea1bbe1df51a835c065d79b1a2b880230688edefa6472a1cd40e2f23ab700dc48206fdd1d60ae8011c5e9384c5423fe127122a550d2540fd3f3a15e487a18006e609902421ebac399f1c045273cb333bd88f93f50ef45934ed2970dba1931b7c9885fea66b36bd30de9b685987652221bf756c3f2a0d404d1900bde70c12eaff9b11dbe90234bd453b4f73832e66d4eb5fa67162b536ff3a87e95ac25456042f6b3e49f347dda6efd0109761c118fae736707e9d41ec730fbc4bcdb0c20b2822ae72776facb515da97e7d5f715b1b85c7aa6155ac4a4f8c284f7abe0b29cf57dcd33a28e4ad53673e11e591002878f2075d1d250d96ec34d8269423088f2371ff477ca4b44362316da634d0511faff700f146286a219cc8057b277ab9627897227a46e681a351bbd902992e7b55b242066d69b947640d56b4de76162c584d4c4ac42a2c2404217d83bff715b22d7212252cd13d0dbebe213270cae2cdd584b69be5c042a499e0ed164acd312d55cfd47f0a405ed28dbdb7f30d0292db8f2768109c13253947bb46a533616008c95e4401c3103ea33dc14a25861202ee85051f17791e307b15b68decb3529e341d05fbb7fd242bbb7feb3c36e66234230c2a334da52b1e70605a11b87bad8f5536ddafa59583c09ac8e6ecd9f66eca2edb9dd49fbea4c261d8dd4a2b93fe41babde56e47a599f0cd45f56b4fbb58b2148884db9eb8495f838dc7370cc70f965388c5b593fcc8824b83e8ccaf1b730e6fde8c4971bf660f7c4dba451a97efb5d9e5e5035cc41504208ca2b8a6fe797f76c7bfadf9419af87e1a9a8b09f71bc693d13841dd74aea898a292e7dd5beca1e9bde657cf817edb4019e8884d0c28a374193aa6a5f15fcfe64403a076327be825dd9ad0453ef0d3d015eb354713ca71f8eb9e99c6657373731d1629c164feab9fba268791553afcb0d17fcfe6e827a4aff96b91d94ead53e1b67552b484d4aff6ee9ce423545fed064ebe6e2c1ca755bc8f026e2488615eb39934e3bd93b57797d0b010834184c3697d2851bbf398d6d7650aec3b5710f597b977df55820cfc361fa7c24587f0fd933bb1838d0bf0508d7a85bd31fa0b4015d70d914a0019b2f02f7978e45a1b0ef9357841dedcc8b957a7100f635611db415d3eb8cdd16d3c1d167260f9ccec8b5e32b7fc0d5e5a42070088099a7bc07500c460a048af7f889213733e11eb4d9e815b1e2725af0a4c25ce08022eb803a8f72b11a51b7ed2367cf0384f47a7529cf48cdca2b3290c440e3fedf140eff7e7374b02906046868a8195d6478b12a26ee466dc862b4086b7c8c42ddf79e730fafd46f8a1b4a51831e1fea3210fdf09b659ff0fc7f57ae415c3889ae7014152970ed079fd29c6aa98b103d6f0cca54842b02c6ee6ebeea439e8866857847d7bb4e6fa4d54374fae3fe6c5dccc2e59ea2be375db6d6cda2e82aed6fb6fc59fba51b4b56273af1dad67b51993043dfbd27f787f58feab2b6b67408542f7c886fcec25c892b54814415972960b48b3c68574004466580a94bcae50beb55e8e811e81ae3cc809d0300b546e281bf002b129080e9827bc448c1f8c0c693d29f499ac6bde7d0d91ad3d5985dc4c3071619eabf2560c2140556817f78d8cc094b5654a1729bf0226c12567721a2dc0ffa1ff9ba095be82ba6190c2972242d904b10b62083057bec59c3b51b05c9abda49fb7711db6d48921cc91d2fc979d9e282cb72ac085db925bdf40e32cd01bd1eacf4b88cef08b78b8205419be622003f6212c7bf2835b3c77000198bf4aae7b56111968ee439f7f4d6fd2c341362e70dd29767fd690ab2efc7f5ccad28265e0605ceff16413f8780a01ab93383f094546f44fa377624316acf1506b329bce509cc09128fe1d2ada59ffda65d323975047061b8c66d4a64d82dba2a464a282a6a8729b020d600ead018b685861831c647caa8cc9f9e8e1d55b7c863e4ee51984977137e428c1b98e8a148d51afaa6a064703ac8d94362f8ba1b8d2c0d4e7ab88f23b86b62e012323a1d655d787b7584c96895b1dfa307887186ee2ad545258a8fddd70722cf6e6c46797b7200149d7be0908d9f39b2a90c907c3bcb03fc9e3121e993a80a822260727c24e7bcd0c6f7a3886fc7dbe56b6871b87d6b58b6016e7376318383e26f39cc17d516be89225394e52eb51c0a1fa2dcc23c33b639364b62b20a8e9e8854fb54a622e95b16ac4b49da940fc3634f28acc781aafffbb40637b54b1f5bd120758e6dc4dfed9af43d1204c65790fbe9332ccb17fd0e0d8a1106896b4518279fbdbd7f4d934efd49e46ee518d49702321b11a5a24e94496c7897cba2d41672220bbbbd991f5e2b2d7d6107b96a2e20ca7b45402e5174f79151103631d99cd40f27dc237db749c13ac01cfcfa31bb5ffec3daf826953bbbae9e7e55e1ccd1178292e9a8a62efde1004b201295e6e8f6d79ccba0a45614adb03ae5fc705de39edbaeb8f31d0c9470abd001227e4e9591378d95764d12954b2c089a9e0ca96458d73962bd5cd4c1280516f494a85ac104bb86e1b60663da7f7cd79b4f5e51389c52e830ddb88f1e01283bd7f4161a1b9e90a3f5760b2e35fe918702fb1d8809668750850d55cd99e415363a3754d73a639bc6472d6660b1ee38368656a072ea4099e80dca89f2bb02db9f524520dfe8357359c3726b3d44a71052db683960558cc3bd1e7d3fb7ca63b470bf6c2d0e15b3fdd437162d5c1707e7b4eb1cd087cab7867e1a1bf490c8d46dd79beff4889f6bb50020b0846ff398fd40131aac9d13f916bf00b9bf228fbc38ce71af0ec053e8e6ee3a471e3f4e19453107058944efbfe8eb1326a49f12ab6c1561ea24d87ded87e15f1bf9e8db2759238e9941ba55db04a6bafe561ab15649f9a157442711ef453d45f3a7bdfd9a28c77b4643ce77a4e3797639e2615b0a77e545feba0a6b9ee393d47d817b170eea44a9cbaecaa85b18f27a44f0e25e06030c0e6c2a55578fdfa8763663aa35297a865bfd0e9b07ade8d07d732941a22f6a25a30187a47c9bf7adb27a15ef51dff955b16cd92ec18f4468f02be946243bd9b7739682724136a653b09f3bcf3119a4cd7bee2e912f48fc83832138d93f398d821ce449bc304cb7aeb2911d1ead73114c4e5cfc0f97c2ab2db57bcd00dee394e3bb463e3bde9dc0d1b5a3f0c2f747d70fb7789a41d0d6f38ea85f7af3d5d7eb0e126f51d9660bccad588adfecdca9f65a16455a7876199b38aa7afd29d15a90f317af9d4b2e7198d639670eb18b8b4d2339f63316009925d4542f36b6d672692883ba97f79a94a47e24050e1c5e71c7a7f81bc81af3765c89391a6262848f1f3f1b225b4c85397ba176a042f6a9ca2a9a90641c994960bd04e9563b17b0ac193eeeaaebfb6b60b2785e448a5b245da6ff57b5dacbbcc284cdbce71842fcbef0e1c389bc7c2fc80ed283b7c77cab21c54bae9ad874412f342f55db5addc3027601ed84387d9793381f6819bc7cf944ff2ee937dca30886f7826f9142c5aa605a41b434fb2e0c4cbee86ce726d750eee19e800f2c5f5555fbcac4e2337f19ad02f9dd8fd7e54bf125ffd760f70058cf7583396f74616176855f868cd461aa7676abd939665639457a17b7b6e8a1a5303425a543239d197cc20ec20442ea8d73780adc8d72e14f4958a8a1e66d60e514f084b7210a9958bf8e83a6430e9fab356f97690430eb5168119c482fb6470e4032e4472b25b774378ad4b084f1b376ee43e9028166d35d36c8107efb6438f95e30498062b8dc657d3b2fd9132e64daf175b5f8812d4a5ab41466587970deb0962aecf9b8519eac2feb3cb540a5643c2568d00138b7fd102f01e0643791ce3b6120f9589317384896fe52518218ae20e345ede3a00bd1c92e969da6412f12a63154cb34de4fb84cb5926e14a37c626eb5c1b5cd3a5140cde08341ff3c2caf2c18143810020e9462fe57ebe38655c271f8c3dd0ab52ef2414727be6861fc4f17ac5f832340b8d5a2c60ec27b0d3dc2afa06d0b52f8b799cd37f00d50e885e1ef45bdd6c8637190866d3d40bfcdec8b1bc67f4b3dae48902d914967c0bff1a278588dbf5d4efdcc87d33e8a7c86078e7e3ca5d59a5c9bae6fd675bc55c2f0b983526e38bfe8138fae4f9aa3944476c2208bf18f2aa4266dd313a953fbff66cb31127db4da7954b983219ad2e976457498011dcf852c860f9a781c1e41b8ce37f626906e089538058098d2632b606b184f606e5d8fe78480d74442ad6337e92ea6058ed9572e8dcde25e653c1ce4b9e42d0cd40d2726d6b9ac631deb7d70f2e6a41db3175e99f8ebbb2727512f64be177d7f184c3df363d22b92fa45e096ea09deb414ff6a8859504ec0196470e46624d973390f9ca680a0196b21da51c7d8c15164ce9da120a13b8f59dbffc90335d74dbc54423c1693004a2e7237ce45c4a0a0a382ecc9641108d9b6b3e44a263d99e241f193a39259a12f937d4586c0e04cbeaea7561cba016036f14fde06aba1ce1a2451cac413ea9121473230f3f7e00fc02a460772412dd3737c05ee79cbc87df8619855c757663f94982af98be6c5b6485ce722e71de4b1ef5ec1eae93e49583f34d7e850cae27a67f8b23aaa7ce3d35aa3d37b51c20c68016f26333231f1472119c45d71f524c839fb7ba147a79231bccb44d1c2511828a9cb5cfe8c2e372bd21a3660e66242c634a7f5977adf7eeda35c10f190646ea3a99850a9dd38871d513287c320b940db7cde8773b3694dff67198fad16b5682cb24514a94eb220545f7488e93fd43e5ef7c9580ab84f9c32e0bb66327796b31c480fa76dd29718bfbe48f1ef7e30d6c4937f65d8d1b4551562c02972bacaf391eead780a8add604391304cace70b412e6aba685e910d25a18dcd89cd3b74b53789d93ae81c5306040ac32aa935348bcca558ace3b6031ce9333bbc8941b7fd0fd1bd8241b0203c6c66903bee4500f82f8ce0cac6158cdf2c19082b58a7fc4882dcf0b9435477809b47c25613e0a91267d984e1263333fba4e443fde7c400e74683717fa49a101f6b5d0d8a9d384682ef12de177738d2bdd17b5aee0e7551afb7e89b9db646df6c6185096701ebb72b12064d161b1cbadbc8a0eeecc4254ae27a4374a3f0277b0fc859d9b84c5a9b327fbdac14dc3ebdf53ff0876f99d8120930ab2b2a042f5ba6c08c4dde58b590ec5b1861b4ee9413531de4e32a1e5edd381afc4a38163adfd2d7e1bc368f034ce53a1ee030e40f8486e80566a6ecc2db67d96c8c4be536c6d9d1d3531d11349e24d15c960be98eddf176ffeab9a035f09f5f1b27bc679a845b21676f8eb88052b66924385952cb8797f127ec153afaed8cde830ebe5a3d68e9467cc4bf2da863cadcf59a09aeb9e80c3fcab8d1dba1b5e73bc7aa9354aa71f63c48210172d30b3a76856469ff8ec16c465649a70eb73a3c9de461ea97fe1bf9de1f546815adb1ee717a86890dc50482697f190e73b19c8f45479f2028b5c4b29d4e118f667fa4230a4a828f7ccaf2a95a580348ddbc11fba47027264d8b49db798f4fa0b2c759105577e064497e12c51286fb22be97441c5833a59d2c44761a7fa6a657030fb61cfc0490d9c4b87549f41ad8cfa1d9d5f5818ed98baf5d5b6f5b5ca643ef1d56cc2400ac29b47a8d284883bbd4e36e4045b5b5f4aa90014ea6185b0626c04d98448422f7a38f76b50f878ae0fd8a81e4f89debcb9e271f82a8e2c94d6f2f3562e35a787a3a11fc1b9d3d41615ec457961210411ef51d0ace71d088741187a96cbcea6954efcd1830bd508d4591a0e0bb33ef3de09e2f471b8feb9c1d42a36fa6bc38717c8fd3f35177348d7f1b0737db605bbe8393b019b5073c80eae473ccb9d69ad6a0f16bb44f76429baca11cb60183225bcb21ff7db77699f365b8c0781d60c1b4b8187c0afec503a4056aef23de2233e4cb6499f41c4379acf6b91e04fca96152b1dcdd91e71867cb8c8101b26fb66582737ace2b31a8e6eb5dce495e027e7305bac0b0d219febabe5c04b8a08b774ba5c99d91b5c9f2907899154746d16611c0f7ecf4c7af5591bb50758c317657b4291dcc75a9461744b5345c223e30da295e19d30905c75fffe88364eee043e59adf092713735179407983c30243cc47a5d725fe98a079001b77b0bbf2b50c8837a14b3973b153d25bb3bf163b2ccd598885fbe6fff8b32d3e33cee943c2a921d465195c45b5455190467d03e043e7045c1b228ace01d3b37e39a4787eb29dfd3ac1855bfc1f3171afa12492a394b3fc17db1a1995c3ef933ed7b5e742ee6cdc28043941d306b305528c9fab88d80b0c64d72b9158b24515d1e24c999b7351ec4070b1eb22b825dbbc67674f4c094ad1a3eeba4d081f89edaeb93d7114cd213cc72ca0b8f1e6db63373bb46cabb695cc3cfccdaaf0d5befa9c6b4ff489ceb2c9176d97ef08f9beee8ac9840995e0bab22b83065d366ce2e12fe0559bb61dba3bca5362a116614776519415e67f06785349b5b128a7dbcce5faaad5a9faab60cee8e5dada35fffe95e237b4755628539350b6913fb82bf9ef5cacd7e3f6dfbb14be94938340a11819e16a9af80fef36efc4ea1f45c45a46894520c5e52e6c41d7feb97df5446e2f09cb0fd8d50e62d7647f1372463301aab26efb99b84479a48c8d891727fc919738e722034e1daeecfa64c1b027568a0df093dd2ef299082a23b5fed43783fcb3ce91f18773b180559f3cfb3e4b2040885cc1143029d5948b75ac5eda50879f5f754bf0ab3546acf477bd16b0824ba4285246e7461be788b682234b3b356681b7efdf2b02b15f45e65004459","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
