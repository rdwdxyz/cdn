<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d2db4bc3451d09ffd19ab2a166852993ef2fb5974cf4ca7297b9df9977ed57702481596259b9e79aeef8a4f9e591106d6ca93a11f6e5b78f9909ff02af352d0f78045a36f7c96c6cb56114b6ab9818be7c12c9ed5e05fca1c24e1080c99a9d082d033e8b24d9949ca7abe8477733bf4da394d5cb27e0b4f5f5c5649561e60d2de8efb24f8b937b81ebe3969546c0894048bfa74c2f36163182cb508bbe8853ed809be36b7fe2563e68919121cf019beb6cf1601f99c5b3ca60b18d21505525d23ef777b5b450bf58c9423eebee23433dc5183341e151f0631b71b189e4b537aa1729791871be8fbc7c3038875e908c4e0a1f9e3bd16477f69505ee8d00e101f5b4b7e20a33e2e5da606cc0e87974e86008bc5bf75b54a83076df3d815f53671337ccdd2397b436de9a032f51107168d05661e1571fd9cb8fa58d60a618621de31233a9e114f7bc0bed5490aef6c88e4c055f5345107fed62cce1d5ac2f0b6b2c0450993cb98224ef1bdcaa556f04ea7289d7e7f98ba313fb225ecab15ebf40b1fe0b94102d3972a93c42cd78d5fb48351d7fc0596d5118277c945f06ac9a9182e49e52fe3ee720386d0fc01afdb38c8070ce7786e739e8bdf53f31d6fc5ff7ef1da938151acae9a8f4017569c4a8929ba8000923fec72bb49ea2f26bd8b2ac535dc5805cce42ee1745162b3f8b579d16e9ca01454cb4237859fda0c0bfc61286471b3c97dbef720ea4c8c834c70377ce63f205e2f8007419a1074bc54c7c217417d27b1237d686090069fdf357025fed2ea531ac08295961370c28f6438887892aee6ce5a23437e04c6969706bf356aa08234cafaf7a2e055bbce13901f88eba9fca7e9bc165ad7b060dcd593737c925ef2060052281f2187ee9ecabc9862287b3bb0f7745a3f465b39e54bae0ac31cfbd44c8abe563132e233ba7bd063deed123e47a0111a6cf23dd4969e84b8f5cfc449e2938e98d1b0f663bbddf3afdfc1d723fbb7b8bf13a90e229d298925b4d5ff1fbef87580b0ee468d78b76cbc2a6ccff86c5df492a00050fac0ef147a90df79df8445191dff570a4944141fbcceabcacc706770c9b971a7c167ac79866495582e2dd406bfd34ff826f1eb94063c9d8c8152bf6224fb99e2900932609850ab2435aca7b0cac2591aea401e6c34f89c97250249597d4677bc0174d130e4d221d8796fc193382bd6803b6b2955e34b50108e45a22986d9471ac2936d468a53426876ba32ea617401df0844560b97a43c670c2c3d4a4e9a59d27beae8ee219845823c9391bbd14cd494406a67fdc44b4f507df83aaa32a67bcfcd1a848f10039bbee0d409a0fab926a148fc92eac06928fc7e785214a3093562a06c6a841a314ec0872a50fd3b128cabe9d74a11f713d24d616ce5af995923266b37ccfea817d34a44bd353266c940697cba2e9e74234e06e2f64483d38cfeb872f081e3e3f5df654239958001d9c92f8a3880f68aeb71da2d4733dff31afa7c6999ecc4defba7e919cdd8d6c2cc156771211209128f74f199d7fdd3f70942259768866e8a9636d94f3d8a932a5b94582b6b1ff8eccb3c4256291b0c7db5b086f2a12c77bb7671c8ba3709084283f48c6e5a427691b3d0289e0fba315e44bdff4797662f772d1ecb2689576348eeeaf85eb3e285fbb8f68d8e70533f668072717c855c6efcced245682a7b97cecc17a905c2b3cb0d01e12fbc3c8aefe9395466a849c51689e926867b4a72643f69f05a8be4edac28dbf6833dd9ac01c288d0e4d0af3610454caca07f9c40a74897bd98e8636a1f2ad7f4b5a5c8fc76e1e34557394527a213175a0699d81fa7c497d49594b548d1909c54023b5bed9513c52f32dfbfffa06d5faeb59a6a329735e789ec341b7b26048491d70de46a1407e3c25f414a2787f5764743ea86b0426d6ced44ccd50cbc26fc56f63fc7320702cd403fdc93054d560eb1427db1433bf8cbb8114cd8037c71f678a8ce7f7146187fb2152eb348c5c900f152caedfd594f355a2a1a66a70a8d83e44be28191b3b84ff93ca07f4d4b963b13f2130549cab7248b2b1b48986edd3a6c14af8345e5fd26cfb521f91dbed4bdc1018e9899be17f23772ee4814cad2befc04f7bbf97db27a850d541e021d88fd9b200235f85727d241e25cde17f63fabb733e19ae18caaa57c7e1608dad3d3ce03c743ff7d18bb44c047d29cee63cb3b231bd18971b8b8005082c6feb100c35ef766a834a47661b390a590c1f97830cf1ed95e604526bf2ddf9d680ded266a23079494b702781e0ffc9fa08c4988c7c354d822efa953a03b5c03a707f69fce253299d57160a8775c40d7d8416123b386bdbdaee65b8f51f398a3a60b40742437b3cf972e00b430b316a0810dfa06f2b8bfbcc358744ad0cb76fa0502e685024b78aa3a525880bdb6dea1bbe37cd31f48f9f883dfab81495dacfe4c13ba9df4ee38592ef9874a9d92c3e90e7f4bc8c2c191bb9989c8b073a23e05b8febf38cd491ecfbb1f9b1e61436b400544ae8da3474ac5c6ff22c2a0a628250e1cde4eaa9ad28066995a0cb5eca0b13927dc10581e0ed06cdcaa761aed96bb45145eacd2928c35cda790befdb22625ec77272e2854ca270b0e56ee21b599aa2129c075206df1b84b0c93e348038162650f01535172c041dd6de82dbbc56521f346f284d3b9a529ac6d3429baee14871d3b271a6a0939fc4b5a20e2e275c9be459f231899ea93fc158fa13563635803b2d7208a1f0a176293dc9f56cf764d239288b079581c3480e083fcf9decbd75f48c8076e7a39d9af6702ce08887562ee81c0fea87666dd3098d7a888d8c05a51d22be3d77f6fd69b91afa774eba4977945fee948ab816149c312e30afff8843e44ee27db7f21525de621fcad1fb355362fcea706e25eea13d711db9a55121d9dfb60ad8d12096f1f06c3785809f4953adaf37ebc4913a0d3cb277563a19b4c06df3b1e511fe871ce3e281ea2d2c846708393915564a0bd151b007fdf2884793f7f3da94147d9d0769de38d3630d8f3dfc8cdb42714b22ab60c651e90ef5acafdbd0e1be06cd1b659dcf48d47d59396de3ae3a9cdb1d0b193f23be03a76aa32e36b82a378b45d7460a3dc54cf95da92c492c44fc91958bfe51b8afbd7bf0c0724e8d491489526c6c22df685d7a7d490f38ef2bf73a7a00cdeec293f3416566eac22f854c3bb5fcdac38e66235acdff9aed1ea34e2e3d611452b9b34b801530c6d5af599bb1d247898dbe3ed5f153cf8e30df933d982bb084d26306185a1aa9e4d0bfeb9b7b80ba5ad0583e0cf1297781f4d9445b0a48e1d49362ccdbb14a842cd603cfea69b58d1655c9aa4760f15f491fda80cc3e229b5bb6e77ea7316193be3d83c7993cd41bc6a429f51b463727b413c5db9cf9e522fdcebb5cecf98b8f305e56ba2666cc41d5018e70fd5dd5e6f40b1e9501ff369c98510920a6a4310ba7e4f869e5bb4fa274f0ae5df22f332a6362500ff3c6b8a060d6b593c1c3b3a3f2e3729d9530046be15105a237da8c551fe100d9bebf3af73b13829cc0d4938bdd14cac07f2e835ac943002036a52263afad31a7461ab2540cff225b25e39c89cca0f9d93818fbc13b34a4211149b6766d252560010dd1d6eabd044acc732ed1e63a1f851a577b850e3d26cc09ba587d61c020bb9028039df28c3d915f135679c2a771a0915274f1968f59189ea6295f1465d5545a47c1ca1eb0642bb917bf8e41dbfb0f1947e3659006831e440c81c17656272e53c730f8e4e5e2a43577a171a9cd964eb518fdb0e6c3d2af41cf6456084cf13a34e69acc7388cf874e424a8aca136e96bafd996690e3a271fb8b8e3d3f92f9dcd651890bd34662017db008b08b94b5ed33256de2d5135a81cdf32e5dfa6c84b82588e7adf0735a7494805c140fb9f51faf35bbdeaf48a0d36012389d2c9a4dbc21b64ae02cd8facede590fbea99bdf061117ba1f2cebc410822a5e8f5a678700a0f19332b4b63972e25f2c0f4cd632c3b39141c0fe1b29c9edd119d1bb3d91fd46b2e3158c1b18a98d30093f6d02c3144ab07ede68298577d8002fb20fe763f262c396c8cdebc6e51ef6457a7f1d48f96aa89e0c9fb691eefaa3238e57b63cd3a59e7897c3ca07e940b178640db887e6ae4021701b4ca3574e0f24d6bc88f02bc272cd2226b964e4fbae039a6499b3fe73970f713baf8a295cb3cea981451bc2bf1055e8799f2705cf9ded38408fcfb29a99ba515d8dec33fc7a10b2beaf86e9de8b677842dc3dfafcf5cccee1d8688252579bf4bad862bd0e2147b465e89601d30d3814c264fcee4dcbceaa09e4e30bb14e87aebd715fa9495ce5281548d6f6fa0881b31ccb1bb4b1e895174837cd67d33fa62925ac150570c32dbe4997f451d82e1727cc55d08a53d7c41b715975a71b3b8677cd7a9ff36d006252c40e200d44202e2df4293e99c41b216eb8e6127e38ee164c6445d51994197d1951967431df76344eb54ef195616dfedc42ff4a4bbfc8c99b3dc370d5fdbd07eb3f3a92fc2ce4bee9818d2bbeab932c1824747e8c5644474e0e5b1571c983de5832b0ea1c1689940bf8ea3b5c804c708935350a3b0fee3f34887d3fecf531c67097c0f140915b3f46fe4f4071fd843d4c311af88e58fdf00130e367e02b65618b562387e161a05ea51ae36c593ba283cfdce2092248f0aa953a2497e79b59492bf2d765758c64170c77523ec1aaf5f3b594106c02d54b19195190c04ceb6fcc47f8dd164a182afb5c2f423e92edfffc82cd676e7c13f36881d0a48b90b1a9c3059607099b1e7eeca0bbd9a7855b787c5cfa9cb7f5ef9183d8bc54be689c033f35bbfe3dbec0d7cc6afd1c52d18e993766b95226685306a0a6c64b3d3526770a461ac76fcbe75f70574759c97cf0c3993909ca8bbeded21e3380306efe81d36cb5b820c8b51c7ea157aabd3c6c57895516d7068f88d4c126f1c6951fe882106307acebe3e89811333d8a78987869f6d3029e017f3d95a6cacea1fed5b9d06f22c04ab45a66ed52df92e8bf1b1105ba308f09436665852cdca753df093a1168a1828eb3b708f3046e1c06fbe1ebc95fdba3b680f2be1f24e692751ebc0a6dee6833102d03c3bba0eba5d0b07bea7905c311c397e8a488a9d4790136c7dcfcabe4842aa76340af9c523de80cb028c65d508c9bd5f867ec5db51d2ca0eb8436020a867de1dcf6739e0f4f7fa3f1baa2f5c87949db4ab9fd6ee11e74f80fd425217f1189ecffaad05cf7061109c6555ea7a9fd4dbf31c3e49a9aa58c955f2f28d7779fd4ff08b407b1a84299c4998e998346ed82d623abd39af8b7729ead96397dae6b1e24bf85a73f3544ed79d29f214fdc3bbcf37943799ff26da633e9c4758a646867be16cc89b499726548c095df1b6837eeb1edd006fc0d5f3ed8bdb2db4afa8dae9175085413b8cd1ffb3c51cfa66a8114b77bc41488522663b029a0d3e36a90eb52da1b2d590bcad5223e6bca6f69af230e2f32bf6b43d7b27bb29ea1f455b516b4866f47712a2315f3a07635f9cc1d5e2553809b6589303658d921750706431dbdd4d4c08a009ee6a8be39ae2c235ea7073593dd8756b2c3a9e9d688567e6837f5c8f1f13dc6a404475ab02b516135d93f3ea4f398d46727649b20c62502cb57846795cb388c0d97325fc82fc3a27941ed08ce99b64fb5bbc73df9033a70056c47715c5e4f187ee3ce93cb3dd2fa8ea555aefaa099d822004094b7c8aa2454049f39f51292abbff6120843f8fd5f65a1e50f546898c5c0d478c5dd6488b00a12e157e928c2cd81cdaf9284350750334035d88b973e0d45b471dbd0c20d61e989035550eea8138197c7374c3707f9178e88a1f4767035fafda1a3db8ce77773e8bd981e92560d094d5e9eaca6f8b4d6c91c27fdf34ed2db1763d0b46a78f4763a6ff9a660934ba4d9a840d50559e462a2640c8b252aa3ef6b44a90f859bc27e5a1cdb7ad1455112a90b60d3ce22784fe799fe3ff9c3c4bbc967ad9fc95e1ef11d15d3ae5a62fcbca37efbc1b7d56c6b2a033b8d4dc4a5da6089cd2c11dfc6a3b82da101b813d391df7687d265efec23507d764ed2139947975a0074e5562e438e5b3775f6d4ea82f37bf0d93874eec87787f21d3708cd5747784024d9f9b181f3047d54acf870aa21c41ad94d9347c8eb6eac96d428e7c92de9cffc22614372c92333ee4fc5a37333b68e729ed8638566f4eb2d60d3e3903503670c0aaed1229d345fb39bba630f7ef50abd20e06b9cc654475ac70172b02c06de2150fc2a72db665a101cd90cc1a7503fffe9b50b2c4d95a0781163a8ade62175671fe6d5cd5dbf8bd5641ef33c12b5961e22ab33914c1f738e0fa12596c1c5f87805af2027af0b43afa233cd2f9e341a0a4c3f7aad2aa4f7a865769c1a0bde7bfd62d9446caffc7ac4f7fa3c6b95d80c604b217c6133f797bae90c037dfb8bf3e2054a36bfdf252ac63e9105396ccd541f28ef82a5164a388d01c25a790e4b4f07091f2773f6c9a58bc89d0914d9d710f5bfa0a9e33970de9926a7b4a90f72167d2f0163b1398f908b7b84ae0c80c9e6efc350f8fe091b4ee227a0630d9764641157ffee665d0d4d458d5e2e45e9b3552fc9f0061a1f695e11801d0d805c907264a62242bd6f5be4664e2117ba5d58f59ee9243052d04bfbd453365e47ade76df8c6a2c72dd8870798353102c4f0d02f6f87181bcce2b04f9b99bb9f504549f9640678cebd9b32889c0af25b0eeb9ab9ed3169122980daaa603e97de2742e544ceb7385d38de729ea5115991cbebc6a2b1f3025ef880c8ae0963bbb9cb740c60277e5aeb2d301379cafaea3584e8a73a8d40be7504bfb4f7baaa836558bb9962196ab4066ee837e44d31522ad5ba3cf07941dab4ff1c2a864b1b782ae29f840262c3256c3893d1db8dcfd4a8cbba5ca1acc33d168b7a9b6696e247d6b757738269fc3e61f95016e8ad6f79e21d9f66dc56731edc15e2606f91731ae23978a3122508eaa777fcac83f2b94e53a5ab4e5350a8a37648bcbc2a12122cd7f70a196a0bddd4fc484c3024fb62f5372c25cd748ec868b7126fdd7aec2a266f30b6e03a94e7bd5540267d9b0849d5be7db29a71b8fbb7cbdaf967842a3c4ba439608de0e842b0d7ed3cc5b8b7c52c00be9c873ac2b0781725bda9359329dae30693ba260407801c23076b1a3add8feb8449b9a495878a5a278f523dc906bdca9ac5d29436d7385fc8458108f58a487b99e807d83d195c332103277b18cb8faf29444e05375527d0e7076e56bb95ee84b5681be6babcec5aee5d5a9adc05745e43c8183b75f5e9695fc0ef2b34584b832e6690f42a530aa5023aa160e68da7f7f321b005b20aa321a61528d659ed99bce958b4b3eb9d9a2b92a0c45c419fc58c5e3ebbfd768deae2543880067f58ad9829b499ceab8679734eb8e0a3db97214478410260f1e634126fa3daba71076328784f3c93a475c991b99e1eb6ed24e62852796ef550eb47b19b7e9e15d23ebe07d7379c2de2dbdc4da80b02e0d2eca5ec2295f78c0d555ae23d3b87a6b27168b51ba33bf8fa4bca066de3ee500051a331dd99ee58ff83b9a9dc15c086dc3d5151f9ec067c2da7f53654692cbf08e9fca766b1afa68a0ccf449ae9e6b10c5b1f43f94fd952f4860f666131d431b4a4fe660a80c3e0d07475901c09b7e4277696ff1102e33cea9656a421aca2c4642c58a1b9ffd2d2b022a05716afcb188324c6e6880325f758b0e65dbd91557a0cb2d8c697c441f0b70e449e576f91635df7fcc1bfc7458bcb98ce62327a2cefb6047fe42e1362883553e138f18e89c977f64672ffae8c734f03ddbb494b13613c7103ccfdbbeb37dd3ab3fe4408071677765ea91d76c8c4ae27a5e3dd71f60e36e5e1d80106116458239f0cb6a63e3cdf898e6789632385336609d5d24b042d90085c657478c5322eed21bd8641bf5197d3139bd47fa41b8a539ff989a6d534c2377c2d5268293bf516c336a3228fc3beb5075feb4f44be61c1066179e737a460075817f1324350132d6cebdbb32d12847c4e706bf1106f188827a7f4c5bbc30995c80120076e368fdd1bbf5e8bac97ecc8950ff21412daec947f3406ea846b61227df8584ab4f19e7e5efb36ce2f2206f2ed9399093733921c52364e73271e5a2ee7fd262c7dac94550838d21829fe951660d54e190edcd6e2c771dd4cd334ba51118a17693c35d348956b2df26176962ce42fabe394d83c66039ace99577490d665aea61aff4dbf13f94365e5fd9c4b53931f503730f007ae62ec50474c4a329cd27bdd9ce607a9f0230ef9303767c0a08aa9172d1fff1680cbbc65cf1a0aeb8735f7fefc0be6e7871fc9844fedb8d8681e34066f22e72fc58939f799627f409b830915ae0506499baa26ef71b1ebcd64f18997f4c2c0e471d5d973ba522e2b0941d0f76f9817b7152019daa2da9e9de44405e673362d723a19723e929963645e8b211bf056dad1911cd283e5ebc7f8250a70c5409bc54af79cd821d4de0804b6e73de1e57aa4416553814379fcff8e9ca83338a3b8a914eeb11833eb06c8a4989512d808e2169e4bf2e9293be0092baef03b68960408fd42889a3d5447c3e291ae7321eeab8bead5a677d36d333d2e1cb90b6fc85d72f4ddf9c4382c523e29e5ad10034dc54ada46cb7cc51b7094ec183ffcf89e8f2723048ca729d0804c18fc06ffe3ac5a0ab0a7584cb82a03b6871f06cd1561423f72e13c13078ca0f739e634e543daafa14eae7523cf58b80cc3cb1fc5dad4c7ca8181d9d9ac0ade48a8b91c40d0fb47bbd469a0aa3efbf43d1481d96c847ccaa915f2f06864cd0f21e307b725ac1db7e9e3742b8609187dd37993c54b522ff5636af44a63d382800bd132683f699259ff6009932130c892c910b11e25c55ad9ad06c62f47bb09d84280b14626a2422feb916c63bfbfe69d8d8c6f7fef9e1ddb21e9a819e8f11f96539b58c534b1e30bc28f98b1ef4351cfda9e4d655fb65cf0c1825e878d691b339a19a3577816a31e2bf1011a6cb2fe4849f7a50d31501ec7576b97ee09c694a77d38637b82d37d9061fbb36be3961ecf006c808a428787f1f03efb09ce0fe3410c0431ea12937bda543ce1f037391a423abf9fff3432acc5e0230cd5ec2cb81c3797906617e327d94677f4f3e730bb8c938490c429e173d36825e29cbb763cef7c7649b2ecb040830ae389733bff75cd766eade175c53979ce9773f74b2b2d8e7264f2a21717d9d9054dd467d02a57fb315b298589aae9b99f68bd5dfb7bae49ebb33eaf1de4c58227087a9d0e96a717879f084f71ee3db9ae60b7f71d8a5a75620b9c0d9492e4eb7aeaa4fc3065449c633b91f0f1d1ec2380055152ed213df581c3f068e0d1c627543c6f30b5d2fdd4ba191107ccb32454443b2a270e2c159e18e3c6a572a7625c7d81c9b9f354e4aa6862a3ec38551b8d7c5d87f823550be66e7d277f85a1abdce1126d5948c12fa7d9815be82bb983f0f8e786bb899af03a82fb584f7dfb197d04c90aa45351774a0b52f9c8aeb2ed7f12cea6e81e69a5afd3c4d301c96416020a60c30837a5cca760f83190669de88b9131a7c6a5d44b730546f151c09f8ca1cb083c4bce32f419d1eb2a907e997b517c40010e23014a33bf57161f6e52af5e8cdd2c66add27eea55d480fbbe848a913e0839fce509e1bfa42aee5115868528cc26433b05476b7b97430563ff0fa8abce817cd7b5fc5ba9809a55c8019e16b91eba85592a034e6a089cdc0691366011b933af8ca0a54324a55b6a7d92f4ab8049f19703b8735b90752204d7fb92722242991332299e6cb6db651a86034bcd9b670990ce117b6a4b68010869e425fe99225cf8a8b02dee205e40f7e0f5a29e00c4732dc5cee0c42cf159704c70918e8f33a6a5b866cf8f3fa0e726cf2cf255c8f2fd9b568b75bc65838769f68908d1a5afacbb744852e0c4d65aa4261167bc1e8df023c516cad6bbe0c10c5da8ce4aa1592edecc75be610e91b74c5f7f2fe761eef38c120106bf45e32ecfea7de2d2c3fd9af5c6db6402a976244fa676f5507089e44a7b64f90b89430857e6535227ada66c30f34d26f96b7ce4a86516e9a218013b0ba9d0fbad3b24e4fb38ce7afc9f74206d35e93bf51725a95c54930e5fe4bd1ac1ef9c776930e3326bf767ca5ae48bb76e2baafe807e9ff793cce8436f3d19acfd4a5fb060f90035168fef726e5844e5316bd696e095a0e4edb1bb36db8afb43e9b8dbf6b772f3828ad5c5420dd2c4eb6674d7aa8411b5607d840c9fdb6a8fb6c5a738013a08b4493b8d4f3203c893e97d438b4a2f0ac4b481867c0446c3ac88cd1908551ed04350937eca844ed68d3d5cbfa1453a680753279bf2461a5d897bd0bfc34cab2d1b3f144c1bafc7fa507234a00cc4c8e53d1e794bdf65aa8112aa17da9699957b43800a1a0df0cfc38bfc0664e51f0895fa22ec33d30826ea59afe2a9ed9cf04ecbe4d8e4f810da8bc78a2b93e00ea0ccdfb9ac13b2636b65555b1bdf2af10795476d4f05e005cb0e88128dba0003af9feb4ce20ff20701ef63de7466290f7affb5ef1644ea4771a02d0e607f7c1f358323167338220ac0ce79cdcc9652e6cb9c11b5dba6dd7c2f91eb4ef2e80eee00594bf0f2b1970adc35922ed54c06162c74725f02d04ea65f123e40c148056053ecb247bc09a25e61c20b0c3ea3e5bcdfdac4a2ff3d42cd8ff5214caba8b20bef04d68fe84070b547f06872c007a2d0d22a4813f84db435b64f289d23e7e6d807ed740e46d10572c0ccb9b768ff2f23b5cf49f0d0ea70fb611b31ba372afe11c52552783a37a4b5217be46f4fef2d35834d23c213574c2a48a07334712289be81ba7f62e27135e3d9c90d95c1f529f54868f87f480ce9932c453aeb6aca5ec49a632e5cc0affa8afa8f85b126a561d56adb7a86268d56ffeb3edf42c85f34111718d867e5322237b6b8c958f40ed4995e57d478d74d1e74a0000654269648eead14a06e89d3fe050442bd7f5840f667b1bdd2c202b058c9e9103815a9306de53798cf3dcde049bbc96c940d1bbde4ddb14fb887f29e4e0900808180055ebe517d4e41632b8e6fb25c918d4f086f1e8e8336b6007b930f11d1c2d01c0e18134c6bcf34375197c2797678d8026d5cfcba4f391943938516b7723753a2821c2566de4d31adabe7aaf2848f78b5e0dccca96d06ceeab326717d912a690ad79753a4602e9ddcfbd83689bffe2770969f37684005ef25802c3d60749930226a979d9bf7b1cbc9e9d98f9d626f251a7df5c0e59a83a678d381393837fdf880b03ab91babd19db7cb180c6744ebf0a151c231fc2a1fecbd7445f1492ba8798cbea17d8a862c942aab445b4c48efe7d914aab8ed200425f3831ef1d2a4937cf6d86f1f23c89b57c1aea0c8977227e0020a1884e4b355ebd7da6aa9837eeb30416e6e7493b7cdd1ac44c76e067dea3909fc06355c8f3c9f37acaedb92427c10e3210463de4f5f98086afd35f70cf3962df617d6a958f579057040f54829639ef598a107a750234f74c163744032cee79afcce5fa85bfef460e24c2a32c6ff9c17ad9c60163235b644b95bd7f57094469f95a738f993b675c2a357a43efd9a5b7e5a696ca2fb191a6c0a7a92efe11792f5595c3a75f4ab039630f0cb193955509f2fdc6a97ffe505867df547d80e48e2b825d361ca6564d5175680f3100c7fc0229290ea04933d61d0dd7831ce0adb28d1859e4bb9f517448724054eb964e2eeb2f11255579632cb9f6109f3022c4e8474937cf9fbf542a1ebcd4e2873ef93b9aad374c19d370e09ed3d3af6b66870437901cf5a5d06322ef7ba5a69857a53054aacf2b50960aeed2888747b4509ac29aa1af8183885bbac6ca831714979d458ea56487777f385a5d81975d41ee243fcdb57fb4027b8412ffc078882d80dbc58733d0aa71863aaee74bc493d2ea308c3647d84a09ceb45c580fec74463c7417a0836087432439758a3d9a3f6d8027055ba69819dd6ef9074794011c75ece76ac9a88854536ae1e70d2a50f302e6fa20640697f2cd123e5f054f43cf50e4049d23b5b49d349650deb5e8d24ae908d27c234b9404265d7f9b661606bd3995f2cb94e25e23025c76dcb76c633e25dc19d8f7b0b65c1137e2076e1a239ccf600efdab151ec5d66f42224cc050b4cfccd836003ac540c6ebc1261195adee42e9aabd4ae7385d587d1875d927e91962f4cff128ff2ca6cbb3881ddcd4fdac98d9cfc62ebd40cfa368501adf9b32e81e500373d3a0e0d2c1bec57d091afb2682ba4cd2f9e1ed8b6ce67644eaa079ea374aeac767e43089cd9a75860a20a0acee099ce3540aee845219cb77e1c6888cbab92dc4059bd6d0565f5489edb985cac5cbb15fa684e9a99586dc9388caaf1bee72554a31ff94717b3314c0685931bfeb8446366f0299689ba8fa570f4c0f99318a8650ea6bf8aa759dcdcce97957dd703a7e8b38791cf54bb4be310fe57961e9606143fbc3d52d34bc4f82c0e12a435f38b6085d361a6cf3c35fe73c8719ac2da31cfd7236ad5d7ce46cf8a7d2f6ca46169259b71fa1cc7e810774877fef85e88f4d1c0513a671ac077d43fff7edfebacc633b2a22f048e54fd6df3098341dc2f1c3ca4f9988b965f3abd7488199aa058ba031db0086b2b5d4bc4d3bfb0a93c11bb7144d6a8215d5679baa4a30427957d5099e1c56c68e1317400c8ce8311a98f0340e4a792c19c5de3e2838b734c1892baad28b9d96ca05d84a5a758b24812e5da87d0a46dd5b04614e68501ca28832199db01c9a8c653a1cde548cd8909db2073dfaa8845b464630bb14ffaefa4928664746f9554bad217a2d3408cf63762d775dd3aeef832fd42c074e6932ff740198d86b5f0b5273889508e16f84f9cb22e3631433ff7c190755823c2873c60aa81de40999a217b7f7d09a7e108880cbcdb4f4836354933d56ef2fb391d87abe663c4c8f943529c3695f70898bc36fa447797e0ee7c8052427135f9a9e197205dde333f49efdc0e478862fedf255e7de2228055a2172058008b41bf8c619cce5880ae1e49d0fd9bf5df175865850eb5ec835b41c0eb651eab6a02fc2f54114eee5d3170eaeba5670005bf34b142bcf73b14ab116fc037ec3f99d5791a9c10cfd8c0687d92f3e41642b8ff1339003acf33c8c22313065cb699d541a79ce801d1be38a12ae7fb45747f840731bd230757ae8e0a1cf84404b3f147690001314cebbac3b165406ebdce0427de27a4b1f83b1817fc8632f11c740a308a6d5e179d70d9be4eb244c4c2e363d07f66d7907f655c01a92504b2dc10ea78547d63749498827e370471ac5af7573cfa8c175f28e84ff412f580f4c408816af938943ffa5c9c62b647f5669e708c7908d757a24cb6b9e24bd0db833da1f4a58cb4b188e123a9aa93c41eb316287742d3226e7d5e7398c3e88567e1cd95b4540bd74c9893928b61c82d6765ed583f829ef44084c195dad7e800edf5610ebf8b0b4522ed18c8d02b69628a746c0b00e7248a47f363d43311938c6af2e56faa6a51260203cf39ad0acafa066956cf76efe4ef457a720cf05e49ddbc6f8544ba32552304df97f2c6a8e8b9ad3da60387f92ef8b81736091bdc529929d99b2386d4698712ba4cb788efe8c44ad6ee36e8fedb757a65f9394f8cd8b80ff70f3f42a946ed57ac87bf3c70fe9e0f0db04410b997e623409d70dd6694556fc081a8b803aa318df73ff9bdd80fca98afabd0f24fc56498610cf0d98426b499fe3af92660dc211274e70487e60b0efa06d5311b7afff52ef9c23d5764f4b044310bee17d3c07308a5db973b921996ad13a1f223f2f58cb4558639dae36f14698fab0d1503640fb0f8fc2736f920fbc031fa1e822393bf95a5fffbba5996abc563a33fd817b65f7acde73579cd7d7e8ea615522f63e94c4b4f80f5fee3c43d8e14785b8acfca9b26067a679fd05f9fcd97ac5f1156f2ba5f910ca674cda75cc10f55d69b002a9c622864dc7da7922df868e3d25c353cd8f576e880ea684bb44211c574da2f8c9fa58bb5dda3ed6c75ffb65575e258bbcc8ece8723a5f503902bd24d31d7fdb68162e38850d373fea45e2673fffea4646a7361375ac08d31949515dcc93ec9c8814ca9edbb38c25e874f4b72c60bf46bcd9cfdc9b0c1828ebb9ba7281869778dea06249c6c5b72789f293d21e8a36b71f957cf5cc2a06c5a6aef9b6935e4e3e1df4fd714efb875a30dd10dfeb26351454692e8b5f417310f378489b32de99282f08f419440d7caec48668a37d457a52514eb8ca7bdbab9d1ad41a6208fa7c8d88659b343c544cf77b3870e85a7c0c0bc3a5a2e5d0b53e31bf63e313a5f7b11f2014c8a287426c79593c8782c1529fc0f147f94a9b58a7dc1b34a071469958e08b2939ce3534310d2b3fbc48d3de50738f0d3cf47bd7f95b83d9a9affc9f1b5cab59602303aa1b73a177849620ba829d04622a300d92210067f0e31584b7f0454366c25825bbd509f297b5771d4edf275103dce1c1f86a9ba1d0d1d286b9284c5872530d0890e5f00adfb1ada0ef54a7ff3481e96c618712c2df80ca04ca4bd38b2fc8094c89e5658cc4152c337358c2548b117a5cb397ce7473f3c288a2aefc0b51f3fc76cfb0408d1fab902934fd2d07017aaf3e4ade6062987a74f57d3a363c06595fd386484272db858e50ab6add10ed650703edc7430a89c613ff704b052f0d896fa87a87db314186b72d47c359845e7b7a5134bcb5538105bc2f3660eb28f19086e9d857fbc04a2074d9bed6c09cacc5926f2693880d6c5d243efa0346f3d78a5789e964f2cd77d98cdefb4dae977baa967c25f500b54fd28f7f91b3f2673cb491d3f20ea67462ee2118c082363c81d1fda94d8e7d1ec5c8e1731937d05aace88f52ff30f7c079b5fa5be4416dfffdf2cc7607845b3cda550df82c9f16443c07c8811dbe3e8ff47a7be009c8a63934458d612864aedb81de100720aa63e06882c30a9ef92d302950c0c3632595e96b0a21160f1bb3fc3e2c169ece8b7fe4bdf32f0a48765b6260fd9edeed6f7eaeb29b1c4eedb09e6c47589ae818d933cc224c3722a47d9658cc587244cb4e0544b36b912b506852579b69ad5188458199a6668ae67487071a3a19aa24941865fca902c727475f2fc2900964e916aed27bd6d2c841d24de98a20af55e35d6a968485cf5e5c3142941ced3b8894a87bd30ebe774d2fa727e9bd55fa08c150f44a1e9abac9a1e03d84b05e24cf0d28ce9583a3a4ececf732ad063c6f96faba2a91234acef1fd79941e725020bfadb5c8632a151b4cd73d055ec8715467ecd73218756074558e9f34676a10f75664aab57b0a28ccdccbd15cb2edf2f6828de8c63f6c8dc3a990278df910065e7644a5952828c8e2522ef6e7ae887e3dd2245f47292e27e5ca4d793965eb2f5655c4307229369e6afcc70e8ae99e8c7053fbe09c9c6c8e992ff0e6ccd7e9e5f88066295bb7e36ac19b33207b8025ace11c0e68db7ddf3fd70849633853cd763b00f98e18606c01da2277f2653369bc3bdb5215ddc576bd728ff6034a6d2fc5f3cb0a683ed1211363993e00e63bccb8d7912ba472e52537b9343155cba4ce2f821749ab4fe934ccbac61eab18e02045cfd0b7ccbef3486f7a46ddbba1a3face286140c1019e01ab52ac2ff38e9565cead061d306e5f9e1b11a834fd10937929ecec51071e18efa74122e2459140d5f1fb2833e02e9bb7a7b1e7cee4ccf84f6c6e77f637c406ec5f2c5368f73e6e2e220e17eb6b4f72ae699c376f0b2061eb48f86abb0e3b3b8386db49aa0651bc695bde8fce6315823b1db4173f7f706083b26f43d0a094f600739f55431030592bc51fdad4e67fce971b1ba4cc195c3ce48b599253cbbf3081e7b07ca7dc1dc094b97b6b44c4982cea73b9eef907fef63ddec6d9590124cd9345be91f966707ece1ff9c25d1819b7f2ae34d08862029dd4a0f3eadfb824485b5e99239b211291fcb9fa4faeeaff69afef74fc6ff594a43cfc6f1e7348658fdf9c1fa64608a0714785f4c85c71a969ef0c9c67b7b91a9b679dec66e7137a871b834776f419d00c0a640d660ccbe7c4a48ea108d73b7545b919ac1a29c6d6958a308311f46f17e9c1ba449281d7d7003812b5669480548f4d8481e3ddb06c1422ec11e766a44661913e229bc623983bcbbbc727eb098081f920950ba17a78392dd39bca9558b3243209a4a6264f54c54d155563735712878698b713d43694a7ca4a1e2fa401770444d92e933db33d841bde154bbb967775f9606d073bb3a2d0edb57aa7f82c17220d57a796d65c8e9e229d14b2ba4a66bf20e1386948d61fa3fc8ef2c426b78f34930e6a1df1f8e9eebc1a254678f61b08a7a22683fc561a7d53b79c710101127b0e6a9790ed3e424caefd557de66e5ee9dbac1f265add556ba7bd342810c1aed304dc11220791d29c9198db95b6c66889a37bac761475ee29763b9efb0200091739e0bed86b732f98ba3c3e31a4e8f3357b41459e78d3a471f63e62d9178293b8f3e56a4f7272fa602aa64204bbb5aada21137bf6c437cdc613f46c8e2b97517362b56bb18362cabf9c1c10481e2700e7c5243652eba6dd3482a25c78259184b658a818e143d3d6106894496f454c3cc78a5086f9c415370c64022f8245cfbdce2b5accc7aa278565ef74f6b32dc97f7c59a75641c1bd12f2c6be236890adf1cb9ad3b54b1544148a82226532684a5835b675fe60fbb8040525911f70a982df71aeb683fe9758c55c9928d386ac37d770a8d1c63d617b53888c2c13f2dbb5680661a7211f904fe9c08badd5b8b5367c4a75f166776db5b98ba93164aa6bb0ee6fbdc995c73a5f724015bad96e9386c05463775b86cf34cf7fe01e4cc9aff72f9a1ca929e94c2b89872b04cbc773872ac0f9811c831bd9b9160a8489937635df198041626dc58ea2f996efe029587afb9a01fbbf9b1575d94f2bd2d4f25f6bb68f2c214ef5258f61b761d3d8fe5083c4838a71e3d68846246c13065d490cc335b18f0c55c3550a67b6b426db50bd7ae86cdc2c16f1e1942045ef7bda3c9fae649fad12375033f55ff73aba41da917ff69a3d05146f774f476d8f7035d8ea9da1589933fb5698f16379901ec81b5945f63f260171d99f28c5878428445d70f0849165207df60d14c6524a553a336ade19e9152d2ffe03f0b433b5985e37da476b9e78c579a6c227828df7ba2726c62e0cf27db5b1331ef84c8818d6319ffbe8ed8d7c97a837401dd407431ac6f2d3df31275c8211c08d9a9b46a85808b5b68481bb98b88ba4b657a53e5a7b82699dd3204634a25b86a182e724a180206ccf7cff4c71b3595896297cf560fefc54180a43429d200f5c7b0ba11fe811314c657ab7f26d9625d8b5eea008a5e8ab0297c43f78927d721b1dd1935dd5d28bcafdf9004bf2a8b104db9d075e714816e928886cecdd53f7dd9eb5561616c12e90e285d22f97c7747d0a973487d3fda6cffe4995128fd4d492d7460aac74b1dadd5c1fa01ad5b71642da5ac4b9431f8758bb6074ae4e0f58f267fae07a0fd4e42e497f1350fd58de66b8e40bf68be4b2d597a3e721e70fde26f4cc2dc9adc5fd551cbb013361321f7c1a35d73b76aedec38950ed63228dea1b1b2d30d86716e5097fd11a1a95bf22077e06e8741252576fd76eb62299236b02b12cb649146ec808230cbd087a125fb694beae167a525a0f031b74a0107baab6dff29e2524fadb1da092abda1ffe3336e7f33974eb30f32a8f4b18dc72ce2dd4d386ef506f983ae9431fedb2df551bf5285b03cace0a955a45918541976948fbf9a132a4fa49a97ad3adaebd75313ca4111b911394c24290d17e738959098182315ac4b4c1eb0b165f29a6d90199f5fcb10f1f85f091b7b1e738fa4b43fb368b0b0d976fbf17369d0b75448b05ebeb66431eeb38617ab85afef41211","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
