<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ba60494fb0b7213922394c88ff9b5ce35a1dcd8ea3b35d903a96a96e20655613d0bd003441c728911c2ba28874b584653449be60a3606969b749b981fc42015e487e9bd7fa8f7a3632a8e253f7f389e511230b01e1df0ff8a473e4f3a838e7c047a88cf66ec9dd26b975a6dc2a877b60403a290900a71fce8153d518d87cca8245c2769c96f2d355fe7f3c7a8bc207db8786c96704501ddd36f5984201e97f538b3bcc4560ac0640faf0d15d3331d94609b79ba0cb9f92afe74443858096ecf64fa8be6d930b7bb872314cbe499f4aea40a2e73db5fb4720040df796085ef75826088a6e4f8aaa766698225e35d233c1c6a2bf442e90661750c1beccdb966a36f7a736b71dff77b6fdb110be62628744a8baca7ec7535f70bdd05ff78e1c91465282354f50a47b0a72a10f8049b2fd7d3d8124e34263896e358357ff0623ba99833bde8b05f8f0d5f239a7da753404cb73b41a360a97b916dc80b47636b7ed6a0d09ea93707c2ce56daa0da0ed1c8fa7189aaf7a25817b7664bdaf8c77dba585ad0cde7c30d73341955a148c309cfe6c962696510c5564c4831dba8be59f381f73887060bf9365df07d88e78249f838387bb226f1c66475a104c14bbb4b9641acc0702f1fc4f6963dda09556b497de7f38dd2d9555f2f5a8403c2f0997777fde1b8852e10cc8ee9853383fed54788edcc23c4506a4b036cdfea4ac1da3065774655d0786436e580316bf6bf29d1acdb9706311305f290d209dbc19d9002a9e0618f86114ab5b4b82fcc76f58775e7d4b8789c3e5247340955e6bac97b96db213e5bb1841c3b6fb06f65f4ef46c07d7edf0fb917d801cb4ddd65f5d5429ecac09b2ae1582858b9ef970aa512b1e24663b2e77cbd8b478d186534e415cff29f537ea30298bc57b8ec79a0a2925629aef1421bab67d675bffdfa3159cc0aaf64c07bc1dde8aac9c12837292d35a5bf9ac27b694a24b27f7a96d603ba715ce3c4fe9c1fec06cb499a889a7308659096b846962e09c4adc7f3be210afb76b50d6b4d859fd0f2928161f2390774b0c1aebd26b3f8ce653e00d8fec05cc1485917801bf1ad98d7c480f950536aabf905e29478eb2afa47a34578dd848063864e8da9a0ff0fc3d48395b29ee36337c4772224503f21021439799c768da8bfd6ffb1447c9a65678ac74decb5c984355b128080805f1407b573500ae42a3bcd0c7d88c9394d89e38af08edb98ef7c76fc51fdd91e82934b60e005699c898fc2d7c8356172c1ca37d654fcabfddbfc18fad27df8af3f91b1910edfef3c7fb6783d38845d0644c62c26ff8ba263fa172010e59a4697f4d21729e4c1b58216cf6c110005dd4eb9d973ce314102bfa59a42bce7fabc081064c75ffc530569d654b379055260b404ebafa36ceb7130a315d6e74c2e51f4b199f0fa75ae827a0962ac76d1e424ac3b01dcb4684b89a8fcded9cf34c1f01324e4d6b30e0be29721a73e8ee614f0accabe6023bf6fa9927cf7223e4746d92aff82ee38ff7b9da1645a5588c697f85e0418e711378808d16da4029c4cf60135d997e7921d4b475b90d0197abbf62ffe9b9819140471863d08e99b3f715c848b295f98eb4137c6c4c51e12e3dfe0d8319660c12afbaf74c8de129be59143985cf8294ae6c42b407be72e1594b7ff8dcd188b5768c0e188bd6ed7d154799a1ebcdbf41291c8dc18fda0f6bdd6cd1542ace6056cbd98c4638e3d36c285b043c53df08ed07ac36d4961f4bd66e68d0cd9371c7b8fbe737de92d22ce08e40706e02abd4fefc4163f918c83a96bd2cc61a5597b9351e36492744863cb5ae309df989d070e1f1b437f0452b0e2b2df149c4b3d80b23808aec5a84437181422fa00e1b21aa8cbb3e2966f874437f4e4713dfdca37a54479509f8fec2651da83646f7ffac1adb36566f70def39a8b975b3ba1ed8f1a34b752b12330addb4d3b1f65f1ceafd0289b3500f41c535cfbda2eb30cd543d6df82993e0aa028dfb2e7ee993d009833a94921c9cacf22829b2dfeb9f71b60c9e695bae7843fe4f2bd22a0376c6562eef2c3bb1d9ca125fccc893ba2c3053ed83c90ad7009e11bb6603afd98c3eef6cebb1cc1efea595f6be155518c7ac133c1306aee9564973d0ec5232462f66864e5923ac67c083a7fa41b86d57a621c1fb8f31a41c72e8a4a3c2841537e1dce83d04c91cb3d03fcd68fae8840df037311c06c0fc005f030a096a682b921465c2028caa25d0b6eda3efba978d0d47187450cd16e2fafdc1b9fdf99b16229d8e6f3751b0bc797c58b16955a3c62de49c623f085fb2a378f96256fdd152711175dcbfa6478367b71422f69434b9bd94f62536c325ca5ce2f1f70d2433011ee53f16d3495123bccb7d3ce15b1c6575e1323976d963397e846b39e9e178eb0a61284f15e00cfe241cce0488b285e0e3530b3be87e0fce2c74ddda3e09bd7e00fab11562910ecbbef4451fc412917955e1c550104f39c377906130f0a26393062d7bea9afa6550375b8ca762f6d901ff561c5f3e1895ee2c5ce21023b472514d3c23d777684761d5bcdb1ad61acdda7e3b2a077afc30b0be0704793c1f92b97a55f8ac27bd6ff80a79c675e9cce3afb61a391c38bc019dd62461e28a111b93232f179555250aa39573db4e12e4d0ea8da1a3aff180db4d30b9eb61aa89e92a34df0da87c66acee2d0a3e2f62108128b4ed4f1353ce25f0a9607536a922698746d2fd808a77e84ca50edb87c7f94a89a2b06b0dc78b9f0b36baa384f1ff05a3c2cbc6b46c0532f25d995f703a050c87e2a0fdf60ccf83a61347654acf53a363e0a53d2cc86832478036b8c42ed002909adec2b58f567d050e99d2c31ae3704c58246c7e1d41079bc28bd2f1eefba696354694525f3e89474d3242aa47af40542aec2444142692c2ed706c99b329d62cdfe629f7b725254f391b8dfc87498bc3d692b48034e2fc2152980ace91d962043c5454122dd84cfda8a9498e15d4c7d19aa475c64115c113c72a959cfb5485ac0f9dabf0d9a784930b03194b7ea3385327ab5e189c271d1689b8d4f4681027f81d0085e7c89e9fcf5b982845381440f5d379ebb3e454a06e7699995886e4b49e170bca89c7fe5a63d04a5e21c6f0adac68739e74374ff769b2d6780a4011a90d40b898474a001ec4e177b21f93f9c252569dac28a19f7ee982ea3277b19a5494998f833090dfaf5596ebd73b4ac09fd34d8d79edfd6de59b2466106491cbe78c02616a614ae8d5516754b0c4ded8106339c81ac036c584b76909bc0cdceb24d5604a1a2adfbd7800389f02a7fb0a38b585324ab4efa82c32b35cf5807890e35163fe79e15cef273ec32877dcc15412592ba44ff97d59fce725a83df5636e3ef763148a787c15e9830e8d43d497c4a4d0dfa3a055899485234b04521624c6f94cf1a1d2211b4ec1175571bbf20b98103ea2685999e63b44cf69e744717764b41596960f89499e56fecec0e620be32ef23bad218ed5e85e379ab8e95c26d58ae30fb08fed0378a64989da2ce542a478bdb76d0b7d4d8798eb9edad3ac5285d35c9975e828c84377e394887d799e45d3abe30d9c99183a4ba8aac5370cf308bd44019f04e77aa33bbd0eecc77d15866fe671abd86a012a5e50e7c40f2b51b7757c95794e25074ecd9bbb45553d6206adcb3c5c6ed31c7259391f281efc05f0538ae15206c355724c0e4d984ccc6ae0cb8b3815d88b55e169ba7dc79ec948b2de171832ea1b22e3d0bd3574a60ae88cf91ec3bc5d2e3f1006abc042c43999c2b5d9b0e91e7fd9116afa407b169337e4fc7d31b03a559d9a3e16f487d359eec5e4ecadec92bf3ff4aa848edfeb54d13381528415a92988f905479346621452df074732b1ff099c360b2f9068f0e3b6fa6de037e54e1104abebca34ab7a428c9791792c353df4d96329b596e8c905475090696babc5bb53fb0fe638191d90fc41ee24c08d9ae1d3f2e97ea46832bebe7dbe31000392efd5938dbdff9a56443a3c19729247c88b41faf45b41ad9f2af01c42d252fed41ef43ffa0f435e81fd24dfad0966bded1ab92cd788da937f82aff25707c80f98eccdd4b71092127e14f4ac4cbf8c71f11d2ee6230eb3905a41d2f76afa22adf5eae6934ac58ffaca70141d5b9759bba78e30f53523c8c44b29221e7f3b565c36d6ad5346dfbc0998ed7a9d13cb4033659185089418cc07359c0895499cdde865092198e0f72771e59b552fd77c0ac8e9c947cd650c6ebdbb909f8a006aebb7f5bb353465bfc8b8978fc683986a4d74889e56222c6b85af16d0109daee3beb82c4d0bdb73b7283f3588915a4f41dd06ef6941eddd37dafed873a36bfc0b16de09382f44fa36ca02fbcacd190e67e2ab49800fd8830d08856cf04fd496e1bf85240c67c827a414651865d4ad3edcb0723a80cbc99e12706c39a6ab5b4ef2e44ad843de05cd70f73692bca9553c052b66c725f77337b62e7a2191e4307b2e53886989546f8f50027d3d973a79c6f56d348dca53f30f77ef47744e3b68b55bfd993722eb63cab966b4f2f23436fa673820a51fd1211b57a8f4c0a9f417e58e16461a6a0cd0297201604ebdcb59f4c16bd8930604161bbc6f6ab00c28c388ab14cd60778e51f5849d6dfb3177fc621af49c1f616f0f857f71402fa203b1cb56ae80f21e765e2eae5c4a5de2cc3ebfc6d55c92420cb8cb71c2a02de96704c39f75407ce74b28448e2d7bc150215b3f900d361f3d28bb0947a1d4da86ed6f1749fb3ac61eae5646d4014ce8fe5f15e68335fba6eae573ec05041746804bd9e832093839d84818e695b28a56e5d090511f8dfaae3469c96a48794229c04523aa9f123a9cc08f16277de68315157704aab658bc1a157f2d5e81ec97b1350ef8c61faa8df75e58ba229f228753594b0d8755114cc06fd6849990abb4bb305dc8005bc9f2781dba371e27989eb118b162726fa1d6a43ac1bf335d5eb0d6265c319eb886250bbecf592152aba97be9c1415facfa7aea5a84318150332ff25cc917fdb06fc9adf8528596141068a02a63b17566c8f5423af8c82312a806fe60b44b4b73ff0f49662f8c4f51db06c56d1de45891169f4732f10dd307337a33a03f19b1641b3dbd7c70f80faedb5330ee06e02d1d6740401b45b62d6adab2b3473f3cebc970ff7cbc9a5344e1c2a73e547bfab846a4b3b7f24a15a67de6856c0d5049f6a3354d75cfac82ed13696e673466962c33841f997ee38d866e8981c29744a054b452ad46905361363287c37e9a01a0f037a04a53db1c4cba54f8c6fb05730dea00bbb7311ddbc0a7f92892057dc9c3e11daf2968bb3f7e574034c086d7886db15c9a365def7ee411835782aad757c5935bf3eb21b1a9a998282ea001d89c3c6055873a6a2ef3b97f3e4e714dd33d574e7928d9f04130faf90f1676aea37c490c04f1ec596f49e9aa1ae92e5d244f3c3d25d5e83814bc860971db7101e50918d4972fb99485503911d2177e5d60d2694f06823d892db2198254a4542ae709f63959e1192e7179a4bb8e9a441000505ff83784b9fe48efbedf931698a6923ebb051b2d003222ecb35b9e466610e9f80b68fa36ababf3286a06c120f9486911c7110c5243efee7ca46fe25547047fda6ca97250b3c10c42650f27eb7ffcea443fcaedb8ff095902f4406949faa9e7a8bb34b437e4f1f572bb5a13af9d5290c561e4b412a1c458b7b32654d898b1a4ac3dcca0fb507104edcd3785bf1d7ea3a201ef18258e2f0b4f5851d5a316d715fb0d6dc61256eba03fdbdaa898a5867792f90fd8711a31f2b3b2de458467fa620ee06b2e0dd09e4bb79adf81714a3ae51001a89610a250f72c9a18722a50ec45389619e8c56734d3533841d31510451e04d36e51ae027b7cadfe9112e2bb13f96d6f3ea6405a19d2b58562310349077983ee58844f8c354c8f78e111e9e21d2a124363bf40cae7ac3e722803398c203b7abe1353f3362f7d0e2be93a57aaa3ec052abeb00e770aacd9bb0ee3f750402e094c87e9f89aa7ce937ece16d5fe5b8abb74c4ac1e8c6f13f098424d82fe1f3dc535f840aec81b97dce329e5619574e47062f1638f406a74844e9a4eae6b2f5a8e903505bccfd5b9e2154726ea5a6719c90bb55f5fd93b223591f62c7dbd1934a9c0c2cdc58f78d1290fcfb03d61b60f3286056712cb50018843367fe3d2066cd7c5e99a5a4e98d912a32128207c73c7bb6df07e70f6c1e37c6480721fa47f2ae9260b023d2d07913f031c9be610257f98085a22167b38bf6dffe1bef5bbae84bb1e4c9aa472328a54d7a82a39eec0bc1e30c7f3d46eb7b51f00010554c815b5783aa5c30801caa1b39dfcb7e6005f9a5475e12e46d08b8479c4f3abb10a8b579038d70093cc397fb1710b479cb3dddeda67a41d0b6b2181992d9d71a3001a53222ce217fbb6a9b4f27dba232cac4656fe3f0535478683368ed023372516b89ad7373de536aa7105f1ef6554bd0beb6205390c1f85083447a0964f7e3855cdc31a0becdb8a1d59ecce62051a6cebb7d982ef9a7ae7281e52476a9352b154a4d311f34d4bffa42a86a016bfeda9824521325570e4aef000ef50be3c1302c6bc2dcba83718d44dee465a38f0f2e386ffb82014a7a18fa87b611b00f2776a6f836b85e49c8e5a714de4b2ab8be200b4922b2af3520c99398cecdc0109e4baae8201b62c5d6f21ba9de8b3aff50c43c6370cc6ae9bdd47f8e589837251a4dc4282b2a1d4677be582d58596ba11cffb98c61d2150eb2dd8925fa715e0152362b2cd13da0cc250eeb98b19648b229d2facf0717e086c0611c564f3d2f8ea2bb8d1184b2a258744d42dbfee66a9b91666aac67528e603aa972fdcdc2780f924aee7a6c957e3acb5cb8c8fdc3907c9e1780d63246dbe3411c5ad731b70b4d4f351a24ef7a70021e1c747d5e7c3c56ca826e0d580943360b5e37762ad1416ced14dd74df7983b5c8b85c33e6e34033c20ab66380dbde06c9fbf455d73f1a0d5f5c679fde844e71ecd4d8daf588f3437c533ca08bdcd1b69f65f2d74226626061d2a99ce79c6bbaeca2e205005aa43921ae58cf7e723a7462351411a3df3fceb5a4bebc281f530c8657498f819d693d3ee464cb6ee4bb6dbd67cac11b732838104e5190159a9ee467522bd78c8af4ff25f329fb9521a66c950696e2c3f489a521826c203b594c68c72d26e451a839feb7d859c1268cba8a0a170a56c3e4c21f88d6a5f350547f2f5841288521eb6358cb536ed0bf713c943f26dda38a18a9077551a57a0c75c6118648e4a740f695239ceab3fb3bafcac9715c4777128842081208012cc94e4ffd6adbd5e909844f4c24a97bb9178cd997569f0ea2705b04ee31d6638c98eaa68fd96ac205c6acca27dcb375dab6982b9aafa9d40d5bd25eee9ea808656359c523dfa74e7d6f85a0e44d9d7bed926390eb7b994e74099c4858b94286f560c0b9757ca8749030050774b10afb9a1884b8d53706b8ca27d122541fd0c91f02e514da04c7248915eb935701cdb6a25418c8e71d18e4fb12387da5c7b35dbcfa9bf0f484135a2373605bfd1b85a15410adf98920e398bba7582467ceb3b22a482eb5fc48db7a3068d0586f57cb830bde7a4e7b291e18ad4d11671ab5a575395e2463e501e0eee213cdb412f2e3b96e684ff5577565e809f753c0ba1c702aa35ecdb46ae3860262e9d925f4e53e3038f2761e8e20be08c65e1e80b4eb966c6f57c959892929124380d126f81c4878d7a47ff3e4a46eebbb6731d0231ff055c6a07d2e72f2f70c305babcdc86cee76a40f4cce74b61feeb663d8c99139686bd75c7303d91c77ed1ea6f74e660ecb509acc057d578abb00828d94b4612b9e774211c688e59e98c34e677fee5b9a6f9b14d8f37891fea941729cb4ade930c43a45a480ae8020b35a3023894e60a059954be71a4d35ede3084da2636fce83edd99d6055fa34c4b0b91374c92081f6c3725d1520af2b6c2bebf3269d2a7c441d6f773a4e38959ec66b145c7b3844533941279ca42a879769647fdfba7f87fbc9fe9c64a234450cb3a1a9bb25ba98fa5ce279a2cf7c159de6b85d570d8ddbbbafd88351caeb4aece383bfa3cf406c5cf2e3433e1dda0ddc611845bcf2a705c65ee072596b8840b684f0850d0b7e0d20667bd0d6085d93179d5cca01a0c0ddbe2ff231aaf350b2e8aa46b8c1995e5b07401c3fd56d178906b5cb46088e2bae4e6bb6e7ddcaca937e3b244eb80ff848a36e566ea01b04ec86c3bdbf46b35b824044db668d903fc82c1424c4f24efc983a52d6eb4eefe65f8db394c7cccd8c786051abd2c78abf092b9bc7609ab02d949e16c21b3c1f0a638347e9e4c54ffd4f7e11266d4a48e27942d4634cca7dc35c57335ead5ca0805afc4937a1fa12db5e603853484ff7f3df6076881efdc0774cd219fe6514dc1914db7e1ebb09544154785b48765fa9a6d4e4418d5a968546d2a70a18d79556283818508b510b4f9bd717017133d17b837e06fa9184a63354518a3f22648ba4790ab6aa418d75e2d156f876d1ca272fc0f885648c5243e5432a68d4345926ad2758fdb4c59a4a6e76bc6bec89c6a677d1256cc8980250ddb30a08c6ccd50bed2ba8dbf94d4eace02b487e595cfd79c9d525eac8bc7bdf2ac44118b1b6ccb9508e19fc473496720e4ed291aa58b19736024e29f97a7a2ca05af7250cc4dbc984ab8e5b993076fbb71a14af0036fc9b9e5209ff190ffee2d36a5febd907aced40c3742c7e0b35de9ac1d364e762c1152248cee34982608e3376faab9bce1839557b3356c65e446fb7f3b9092eab9e86069780cbebcd8e7d5ab33c5d40727ec5de692d264a4cfc2a9c4ea0a82ef8a36a0ac7dbabd41ac0e991008966752f4631bdc0127cb3ff20e58f68293d4fa4336ab822ea5374c9b52195e2d977fee7f593f585f5e33b5c40111329b1b17600d8c8b94f999d4e817936db7f72df49e2b7ce831b4a1f20ab4d296d46e9b4b5b200abeb194d9b08fe515910d9841b6e25e67d6e1382a95898d6d68b53ebe794fdd8bd7152784f730a8a671ca01e96f50707eb8acd378a34200be1d5f63de4e13068df8399bff803faa080cabadb2bd882f3942ce27f73ff6b0a63d03499bca241b012e4b916a838c84006a8a702414f9e433300a25383e5f46264c5cc2ad3b3ebc0487bb7fb13be04500d6a969a3cc6b46879bac4595a17562eb802956751d481db6cb3c5701ad70639fc20b907f3b70ae960a2b92ef8246cc5b93b9590303372d835a40ec7a4d5d3c20474902c011edc2acfa45a0cd623fdab0e5c2aa1990090ea4cdb036a2b99678e1efa772921d48bac51a53f16f9785c6114ae011763d6b15fdca19f42889134169a64f12917cfe7fdb9bf3c1c91dfe8e773690eb5c265b42a0776e3e7aa04aeaa44a690d15a9bad527124a00ba3560ae0acf1423d33fbd85caef709f7221613341c688607ef0b4dc45d8b9c921496a38ebe40353d7fc97826295ebe2b1f609bcbb992dbe45c3c29199a695a4d44c96a83702dcefd8f69197e733f08b071ebf00c8226b1c42810a6185166e59ef0f8244df8fbb4c8c1de9a0d521a297a6dac90247384af0b84c1d75941b37e763c2609b672ba0c5ec06597c783bc069a591b44c939de0ff8dbb930c25ab5f36a6ce6e4fcd6943dea854a8a6b8b4a5617c198c41bd9e7c768d58b9360fec1e7c5161cf6747517d444faf017712620033b6aaeea1da3501797261bd62048fc91085297c5138421cb58107a8cad4d99ba02fe356079f469d6e1a31ced656793d1ac2c26144781e127d94b80edfd09a6e7dc6a56a0112f72be12576057eadacf1016c7a267a78683343ddddbaf16cccba96301894e5f21e1afca9efd9cb0bc4d6fbcffaa29042f9d21c76dfbb90589de4d098743e26b7bd72962bb9cddb2aa34faa8604e94269e4faf32256eb93da006606fbea930e438bbc6bee74be676758e43c162814d197583ec7d9c01883777605b1b7c54f519eb42e324ba519c755516ab34854bd4082ffc4795895a8166c6121af9eec27442ccbd48fdbf47077e895c1141b28e51bd653df01c16969e3c924a45d39444e77a67ddb2bf3e1e0d1f65a149074a1a2bb3d1b10cca4f236d59ba9e1a1fb8f714d01db04d481e812446e42fdfdcbf3848118d57b28d4024f4f1942e04638244fe52690017f7c0c03275d455bf2f5513ffd76c5c44cf0b6e4f8bf96f7065ad5ee1c4eabfa35a46171f6e6278d782433986e8c26efd1afb0d73dcbb71514c581d185dcc6e5e953db82118e6e7896296ea92032d92750c7f4c77ee77628ed364027f50c9916e131603b8a24615eafefa08c3549ded92dc05ee583df0e21fb632506bd1bbe83f60da0944081c0e78d33e23c1f1ba372d6f86eda8456f46ebbedd7a7e2e4b5322e4bcca95f12de8e8f08c19fee7c87706dea20ccbc95cb7745afed6eb999f4b95dd65cadc31b4ea218c12f98695bcdf3ccf1b7d77ef331a07fbe1198ba851fb9864ab507e4ad261ebf87c961db2b4dca1d7d727676eae455c30bef4430053ce6512367ef1d837e9512f5c95d5484a79c544769ecb0f9cd3fceefb35100544a419724c9f012a4c3f051fade911e678558dbe5f787e53759fa1657b3c95d71a09fe57367b2246403e4334891ac6af7f3d8cfe97fed81961b44b82f40e5fc45f99d3147abfa75cd5071c55c97555218f47fe283d7e6bca891a4ceb4eb5eb148b337466dc5247749416f04509301a9c8054ce042c496dca675fbddb2355acabfeae1254340e12e99562418ed2a60ad2f73aa04bafc065a462d90e8470c27199cbce05ed99da0fcbe3feb47d6f3d9eff8ef43129208d4a90fec842eebfdab4df857297f68a865eebfc6342531316ca454fd2ca27e6be2d7c3931e9dc5de55c350f2d444f159d3f7651a632dc04fc2902660595020ac6837abb61544f2d878c3032aaa3b0bea749db21730aeb2d78157d001390efc6fab3d5f672daf68af64f8c11d3e07eb551ab8eec0e1fdc595ac9c970420140562e6d7bdff798d9377c7ab6aa5f221d16e888efa241e46149e265df280c3ae6a97b393041a4e059893bcd2b757cad71a31cf8c33123c363f5c59577c27c8627fb570d5bc3179a4e34efc59deaaeef8f9ee4b831a8545069c7b3dfb743f6179a7d866eee26daaf1eb4a1196b51216af51b9de6e6cab403da4d8cc1ab249d624363ca0cabe8bae2e488864a73503cd19cc17834d1d0cb1700c0bab27415995f11df69b96edced4a87bc0246a3fe611f00193429d5609bb73d226b604e6761598b204989db3f4141287ed8ff8f2f3a75660f0813e23338c3e6d4c90044c74f9d50b3311a31b747f6ab1b4bc8c78581849709ff7215f0b30dd163f2b58cb4fcd6eb692a4779d674f55011c633229cfcde15f3e6bca6cc2741e6329ec836902b7ec39d3b78b2fd1a7c6ce3b87eb8dd27110e8f8532a13ac4979b54f77cb75f34aa6a3089f9ef2e9e3ea153d378ac89a3f22c1fa0cda7fa14e29b49b405681ffd7bd2610f3876cc044f567991ab1ebd4dd1d993040f1dfe875d6f535a3fcff4e9f5dbd52ae2b23b4c12a7095f69e05827400d9bead7a8b791f83a9c7975e6f89d21c2c9b0f568473493dece13c1f29f262c7b7a938793b013e33cf053a0fb38e2183e86848e31ec63097d0c2999d2f57d6c00d3896edd06f7b7c34144110c72400c191f7963d176c506ceb7d98a73c49123be4451ce294b7f97e8acb83d433eed1cd7c4b86858c6854bcc83c0098f6a4ea8a13bff65d778897674b4fa831a5f98c650ed0723a1a5354d96aac338db472a32d809b532ea472420d5e76575a1cac75898d170a4361aa365e4c6cc79c5101f69109509bc2ad554ecbd3349a34c42e0f5b1257abb6040f63c1294899cf84569d21d9cb3a84cc74cd5e3e1269c7265681a11c434be5375f18dafe8bd138cd93231f836307d8deb349ef3e68d76238781e7796c38ceac59e1640216b28adb629216b1d2707e7adf0ea634d65bc4849172ccf7f392ffcbc2a296a466eff51bcc99ebbc028f872c8d8faff1774655992afaefc6fb90ae70fe9c390320c4972e0368ecf1ce2e9b12d4f349ed902124bc4e2114f520dd90173de34820d76e409b482c82e5b87b034b9e442b8233fbaa0d1b915531533c4417dd54f8d417915777251e255364c0a4d0fd19e20a94bfab2c786eac40163bec08e9d2a09b7e815dae21d9232ae0931c200b648c945899d5504f1063971fefa43dedf1abd77827dc242fd6b5cb10fb3bae09ab2fe49fddb78b1e868d23ab0c60d5684a6b0404b305e73f19e41a08f91038d630f12a6a64c9d2754993d065df6646530d141709acec3d2a0a6b5e67e51c446c565cf0aaa566806260477e7d2555e2be6a95742604cb0962fe0d019629fcc40df0e9adb6172b451a9cddd6bb4e9c78df6795856c7c1d48453f81d9f452dd942e63af814aabf8fb9c04c53686423ce315487ea4f048b09691e7c0a83b2b0c224080c0f26ffe51be3d7c15fcf7ed988e883d84fb2fb308e19b703435359386bbef1851041ec1d9cdee47f58dbf1266d2e612384e58b17634a2068a6d1088fc60b406e06059ea32a03d6e5a627257f4bc4499a5d934f8253d9d12ebba43428c7c67512bdc64161482e1a012cdd1779c22ecd8e1f28cdd6403af2df790580adb147d2ab9fe752ae072b2a38bb71176930961082ee21b749fd5adcc2d4d0397e0b562fc98bab3e4335b93fd81093dcff8445209607777c144230159c443bef92ddfad54f407d591db063e3bc8cd3b522feffe1d66882d8020ba4043ca9a2667cd6eb9a8adf9a419ec5a32677939f9d9c8cb0afcd1d5a519b13ed55af36e7416414f698db36354ed64e8e3f57cf4d03e070f04a49b7569ce9cfa45507141ac7682443c74e6b4d7c8bb70aa3315cceea37f3a84370c8bea1b7efb3f2ec7507ec511ba8f43d76ba3778eef1b1c491adf59858808a9d067a900f8f00df47a4d29bc1d0aa3625a42235f025a2d55e060afe21166c1568d2dce27ea1d4103ab1f08a457247e75e24292c63806edff7747587d70810d7890b0abc5e94a0b7ce04fb9107d7459c0bc18e7d178d79ae7c33fa171550163c46ed966c74596b7df03db2cd19f16e367c506d6136a3f745cfb20839039d2e9f1d661f032ad2177e0a8e9a0105b1abb52c2708fd4eeea586845e30837dbbd73b4e33960fbbb4e6497f89e33daba95e16a86eb68fd5fc277f33cb21325b612e17fa6a4bb533a59041af186f79ef96ebe5baae413a4154dad320ccfb5d162d8efc8d09ba853668b109f5869be0acd4584e5c5dcec0dfda606b5aa4be4269e9b57a8770bfd128b75f245a9845d1e4fba9c5ed0a1c91b58a2396a4e7fd6b667e005794f4609b47de95a7a24aeea58dabf498ebaa44ddca296195eb27980715df7b097e30e8ae19f049e3de08346cdb4081942fe5e6c07ade43eb0c670d3a4ef6109e3b4e5d99c9ee38c554162fc672bac91256fc9d801c9e3c92d8834fddf6868d1e7c61499afd1529c95be64df61d404564135aeea7d0d4de916e46f811cb02ba9d360ef033ed490b58f290f7a0472f3555c1faafd101fc270618058c75a0570251bdc11912efbea0d9ee06c41ee0a7bf6351b5454a86c587fa7c3fae9fab263c13f8d75a71073aed167f6829192724d40fcef726de2bf721b7af135b7029fb69fb47117f175dd9d39375250b30d9629fa9fb9b6e5e1a634b3d4a6379fb4472d94ea4ea68a3baacee0d3c7e21bfa97151c261675beb91b1af1de2134b5cfcc21655cc7ec8c468a125948e017100da4bfb61277b8c0586b0954a83bdc97dde4dd5d940c65519b1a8c1a5475df84a9673872c70788b7c9bb1544391207213d9782d1d8a8f5683e6d127c1d6a1bdaf7e24e8f4cc92364c25b5bbd6563ede1f4d3dbeec789a17d4eecb20985ab529faf241535704b319efdbeb270b00eabc0421d0279196c2980b4ed1616d990fb7783616067514eaf5eb1a7bbb2a9d2e4e5e18dd66a91db77aef10bfec319866fba75f2ab61a5e10fc331fbee0f2d4e79cd06225fd25f45d95b8fefa496323c3d4c3004aaeb2144b3913a8ea270204442c5133529aaefa40f050fa68028652869f5283e849dbcd24396d66ad2013a49c5ddd7b2e91fa9a0e230af81f780e641013a8c0c726ff1d8a0a6456c94f533bb152ed6c779936c41aabadd38e56395791c9b4c3c534eeb3bd3f52d884ba5d622a7a3c580cf36a2100dee2fb0fbf043740c3c2e3caeb29d5eb3ee77c13c2873ecb2bb083877455c3fbc02c9a780f44df5ab64e0ff8f93c69d9306a2f0f52bc7d61359ea2ac4ed9afba5cc8b122d6b13d7d20a9006a6e07c2f3d82d5d3ffb3431c3e22ed2293be74504d6eec6f8e7bad2d5c0cfef5d899a0d5d767330f31ecd79a1b2009b9e71a3b37af5fb251c2d24a4d6560d4fbf553a76d5d07a88a56b1ac9c61d035140d8380ed7b9efdf3e8ab178a0df6b9eff415ac706f962f763b3975a43da4b977f0b1402f45e542fe1d97e6ca8de2170e4de21251657dafce65a92c254a30bcae8dd5486a4020af7ceb57ceb0cd3333023e003215ff512048a96aa3623dff94259c75ae9f6132454a3d45085cc36e34a260f427092df03eda4b02bc9f2c5f3e9fff91bcce6a07a4eae8ab51b7687932fceefc95673d879ffb42ccba1f41c321cf99999490e03c03a37c4159c2884dc6f8cd4a159ddbf03b33d96116835e47447579a748b01a250fda078379377cfef01c578b8205d0a0ccf389232379ecff7233a28315426909c5e7965f56988f4e1b43efd889ca13d534e7571066d7fce219e55e56af4a8ca2d932ed0b1924f109449bbc5145867e0309dd5de62252d7684864e58c1124ba9f641ed219f94fe12b3a977f60063d5ab254778ae75df81a63b76ce7093b23009763bf2649d86ce7059902469112ed47f3f71272a97af591a9caca3be29768e1f8a27bf87ff150c306917dc0631cbd105778415d14061da2889c8e92aec4853678afa6d91d0e531c8a9088d9d6053f309b30ef1d5543772ac1a5de8fa8efd1d670106110014b2e98f2b5f4113476c1b5de26e421722c289ee45aa5f87d3d017d4e181563d0364524b7f39dd1373effb56c7ed544015b856407d6428d40538b84db20e0bbe6b4fed0a20ce63abd58935e2b1746bf2edaeb28799f09ecd1b1d3fd1382bca3f2b404ffb7f097914a2ee09fc17e3da4f99bb6211a440504ecc3478d898192254b31f021ca158e02142d99457496a744bed1e997e6d957b12ae376a7aa367ed94d0bffdc97388405dbe35a457c4ec55d77d5e7d803413c3e2d15e14afacc9157c194b04367292c803add6e013b1ff6e5e8f1bc9586924a2a0d76dc038c7d8ef9c0883a3910b387f2259c878a52885c7e4da6fcc5db4657a374c92c32677b68fa5d1ec39cf81e3c42bd32c712b8ac09b227fb83bd0963786509fbb933cf2633e5b8e81e562142b31b9e64c308adaa47bc97b34ac732d5bbc07b60652dd21a45923fc0a8cac85ea2c01f6300037ad6b0131c02bab3badda04774419445f97d2980ce7b672f9882a9c6154353f0d545a4d2de4989f0bcc2193c671338f9e37654a1e49ae7feab44de3cec068517e4e335a65d6ed17c40bd1ff8fee1396ce40362db162898199fa876ec12af10751c3ea20819651e1ea602c5b91aa31affe14b8174a6cbc9387934db903f97d839c27fb3df85ca56ea138e341942192d6d139fd19a151c5decf6da0620205719b8e05b3809a356ab9ead8b1977cb3d0a53cce08b290e82f845d6766a7c3e3e0b6f402caf40cb61cd5068890b8f6e4440d7a966ee96ea04074052c2cc5be6b63faa11c8f9eb0fafc3a527ec8df4a6c8d8c9340f5e6ebb9c5b824c1c87981b1e6d2fce9e88085f78ef4bf38a909c09b670be49961be6bca142ed586199dc5960574e602eae4bcb37e8d7783e1ee0cf567a46b01eec9b5d78ed7c963dc29497ae9ce4fa1d3cc29c9e3ae4316e600b67d24d8b0a645e618024958bad6bbfa91b8d642df41c1a4af3db17303d6ac49a43a9051fb5744f418b91366b825d0c9b342174a8918cf281ecfdcac5c5afad7878aec73549c5171593f79de4a83d9276317ededa0d6750447e44a13cf89ce8d525a2636928ba4319a18a43a89cbf46916394fd1dddc830ea68496720cbf7df2f0d1d33e49b1ec4f94f90c8d3d383c3c904cebefeaec659675e8d3f004558ffc01be5e97cac2c57691c2fcae4d90d3978903388db9ca25bfc8b48c12c290ccdeefc3fd8aec6c2a6869023b94a501126b9aa452e913e9442b0fe65e1a2b231043f9a4a3dd2bf8889dd5c4ea3e166df82fc72fc7c613e3d6b6dbead85a2ec36e78b2104e7a8133e65a50ccdce4827dbc871943b3319098dc170237be20d0f343d1eb4287597fb2b9790576345a36b3306690e75cff67b7b743e7055fbc530aab5481f654b43d638cd0cf3e765d7eb135c0f124cfcced880585796ab95865b8a0a2b89f719b7530dffba2ed3244e8feca4d95482accfe59338afe87f836bcdf2f9c8c2003fd1c4491ef96ef210d8b637014c4bc6af46ddf8d74a2eb613ffd8366a65b2a13ebb4d6d1bd4a3e35844ab0f33f316647950232e481faa765df12f7fcc5f75169e081dbb1efcc2fbfe05479c28921871e8cef4ce5937b648c9cb162cdea65d604949f6908b2261414273138b6a0fd2d42cff52d432361f1f4bdf6ff1ff9f4c85a3d94d7fbac196a41ac687bd149fca3dc051bf9520c49b6d40bd6caabca0a814eade771d15dc72c247ae70596e9f9225e1ad1c42cc63c81c1e0612626204d95ca6ecb69a60fa655813f2fa83bc934e4118e4150da41240866fc7de4109a53ad08c4b4a44857a9502180937a80aea195fbd57743f8c6c576a8b28285a9d73c85eba12fba9d2d05f25c9471bacd2d968e3de87002d4327925f271d6f55ad7dde8b115a1ee238fb5bda2b89005cd9d5e4c5aacc91799826626403d342e7a192b2c950cfcd3496f3200afb639061dc25ca39c66768ec0b0cbd1e709d0ba01e3a48ac3dc0a008a2e90e581407c989e8cfa5f8fe6fd72d9ee6807e0f21590e4e3c4dad27bcb53e01e6191fd54e9eb1150a7e7335726a94ee55c6056110190c86624e70e5ef7685bf955e40001111a6953bc98dda68c99f67220b2a30c4ab6a10d68de199a60ffbab1f86f3d19419cb790d669c919fad05d1d4485e236b98e55dc6f022213ae01031d539da1f9218a4299bfd2e74037baa8b2aba113e158b9a1e9eb370828fd932c94617b84550d412339402b61010529646d8d3d72b33134824d89a8515c93a7563c0a5e396a067815b50ce1680e6eb35e7977b383158bc526befcb897288de231da7e55f59082fdddb2f4a959853ea92088e1777f78a5ebc17f00bf7dfb650db5128cd254a8a24074cc573379215671b8d4a3de0963676ac474d2846b13a23b800d4d895591479283ee6f9f991577700a0960c3b64ec8adf5d4b40e467c098711e60b6f8c66aa8ae31133428a6fd79224767273f776fd715064938299db3cd25bfe9518c4fa57957d0550fdcacb981c8624c0525ebf6e2af333fd25103859a5d2c56df2e1de3f925d25c618891dda85aa43ddac578cc3bfb6928711adf3af2dc4db52c52d1f3dd68050d1c6500a3319bda154225c1372fd282828b4744bd7eb6371a7c8916ec3b5db84aa250e58929ac1a087b89fc86731a63402e131cfca39642a61af3d8bc6dea5659772f38c7cf1e197af4539737f48eb62bf339c40abffbede806dfa8081c161adb759bd85838bfa3b71b7a8c049790a16fedb6e38536c94cef55a168172e601462841a34d701b9d4825434f3054a41704944fb43dcbedaecef5d4196011de0d8f8a8cf9f9f0ba60ca8b4b91765e77b0c15af0ec9f258135048e3e91b54039b34645e9276af46b7015ef1b27a3367fba7c3dcff93e48ebe62e076d98ddfb59c03ed05e6f28698b0ba3c4808","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
