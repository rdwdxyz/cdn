<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a43a7f0c27c288bbc109f4187f5f1dbb166fe054cd29918fe091a9bad4a83b453cad4045d16abccf00ace9561cd022e94248121151e0b66acedb1f34d2671e0c6eafb3351ae790465ebf33f8dcaba9d78ba30b2e0050dbe2903629b4e952222b33f97a8dd41d49b3a016770770d78d970b0e2b9b520ac85b63f6b4084666eff61c390f1d3bd2dd1625b54be0a3eb1093e81fab89788139835391736dcf59d289963db9807216a9c992367fb742c831a3d74108390cf5db85467c687ba6e8e6cf4cf4ddb29a0b52861ddc6572b49c86839785d2bc7488265469f0425c748874c6d9fc25cc1053cfc29c773b3f9303b7990c461593126693f7e39629db65ac46277854477fcefc0de23e484f5a2e05b84ad12ba3031cc551ec4c880cd2f366d6acca87ff4ee7ff8e8c25712fd67f2a1f69d38ec9f76fc7ddd37d00d0c245d9d034b2de67a78f0c15876a3c2f4b155f2383da94b4afdb6c7377de78651f3e0cfcc76b53ae609740d8cac09ae12e09a05bb6c23351a29b7a279e4d20a918ea5ed0f882ad4dc132d85e2bf57ff506314ea6c7201c00bf83fcf14618ad3a360585811ad715ec5e641a82664c8c55ecb6aff94328e379e7ab8b2dce42a9139a1a58a21aa0f5a533a6f555d86f586fa37219510d33e0c4c64011e289e4c159f7f027030a552d3266783f1f27a88273592731bbcf186f002e04ef8f2c06a627bec8309b8be625987c00159323fb935574fabf8dd5bbc7d6a154eec399f0c236021325d03f1f4ce2f2bb72e9fe62cf50edc80f14dbdd9a0a9f20eea0c32aa43dcfb468ee7d281182735b7da64e8a1cdaaf6d403b639421b7f996bb4f30918ce005250da214943310aa97d75e04f28cd88485f245289914b35086f715f81c7383dc9eef807605725dc21b1f1106a0fdbd31887635306cab776c64e0c7312c6be05d43a385572ef80ec9dd25f1deba6fe0f6efc9bc338ab32b67da66cce804e7d4896392917a0bb127e6731167e76f0afcad7f8a61bb8de2d24165b16df9af75c1cb65b0e54e6709c4c04bf10507bc677f3898b317f450ece7fc275c67b2d9fd690c0cfbd9e2b74eb1fc8c9fb55901a5e137dfab4b190f7662b04ea1bc36965cbd74b6f20c5ea19fd55b5a3a5b2a856d25d8e97d456ac25be3854c588796bb285bd1250648382be1bfa6cce528e0a6bb8a00a9fac4a2fae11bdf97ec29e7e9b67295953336e068ceab3af226e5a64a43c103b482391d1751a63622b2d320d60f508251912ff94859d96b8462d4b36b376562964ba3e5232f22d8aaf2d490298261de95a3b650cc8c440c7c0cfa23fe0ad0788202ee1e7bfe483d4af608b93a9995966b24da9881f29946b4cbf404b3a824c239d61e1230d67e43b69e8dc9618f4904c8a97dddd9599950b4bc303fa42739444f5fe4dbaf80284680131d2e0a3bd9dcda0ce91e95757b2b51a0d37871dfc1e37843aa688bb01cef3b53fd442319e771000da7003a33d56ddcf24125261cc7cc29210873e7a5264b33e55059172e299941172fcc2364f5ce148e118c5476b502c660c77c967bfa449014b03d67eb60b79fc7883ebea6a79cc2873b18c5c3becd76133336934e02c87c3cbae561b85a62430f8f67dd7d8658bb96d30f8e577a2e14d819db9106ad6fb1e044dc43908b3cb6884456d2191fc7207f8c9e1daabbc15010c0ff71468b8d0894f57c3e42442848f3da40a8f0b2eccef538bcb7f247d4225ae20146aa0d6787ce5e8f4eeb1304751c889590f5c6f0d292385958bbe45d4492ccd61c6b1bc6600bd014f389b1f37114e054a3337762cc1187704b0258098a170d2807baa8e37ccc7ba121e7195de32393f75123cbe6dec6d107389014dba4b0b31478eb30b417083a65fa390cc6ed255c01f76cb2f9cbe2d8bb9031dbd5fee04adeb958eccaa876a0eec234d20b85a760e9aae580de853eafec9517af5fda2063bc403a944fca6fff3d3102d32534855d410b2e98bd34653960253d25d6df41c47e3a936a95660400f4a0101ea0c5999e3729457780c13371cda6a48e5299eec88292566f4afb73e30795cd54dcf0c8dd2f9488bc0f1e22e5ab2240d1598789c14373eab6f9921989371b4634fbe1d8a39972c973eb401c7e9e14a4a002e979c65d5bab51a0345b397eaf3c9793499f9504a3d2f42d1b8d26d66677ed67cf0629f0113f63c70b1c31c6a9ceddea38b7d7ba6ada2d1ec5611012d4cfa0b35d0a1fc7171c9fdf902be989aeeb5b09b261357b50d6397c88a09a08d9e26415ba87be11b03b26819ed07b1cd557b2cd21eaf007291ea3ecd63d2fab8c343ec18bf749b1e87d542d8dbcd6b8eb4bb789abd909bf9615ff877ebbffe3ece24651b6e152ad2368b58588ccb966602c52ea226cfedd9fd45dd67af3e1540071527de51278d2555e6d5654f06aa5e84c4722866134a3cef5d66d2978a875f6adea7e1ab3908c61243885a0a5cee5d39f7b28bebdcb9f0db742b14d7ce6c8cbeb761183f4f45ebd0452baea7c246ad0c632e425dcc4559d99b5f41490cad39dc30ef55f489285a479f0fbf4562f83d37558f2af364cff957ca16fee4847fa6b3a206c9e78129a3a7974d1dccd1ebcb13e978bfbb7dfffa3214ea14558480f2da2c18d0e082172afde1dd681870006525fbf96420e17d2990b86b67f926f85b9575fb2a0a3bc8faec6d4160b95933fcc668d7a3f729e61a1ba6341c26907216a243648feb0acc8e4d43b539d44cf2bda31f89de501d9f2156d2f34a89d26a73aee279fbb6c80df9d19b41485d768ba24ec59afc5e2e4826d082aa59ca1182d010f903e36f3988d1aaa01bd7d6ded3afe1be519d0cf719790e620c027e92b311d693a43c641ec90ffeb6c99ceb89384a9ef7fd70911ccbdbb3f02e2239dcd1167d6d62f07c8fc4ea3d53113fe20b1d5af18d58cc8f7c71e1e869ea341911e3340043495c4c356ff7a0866048c27b91c65763bf1f68aa46f7a300058a88e33e69693fabed5b9242589a32ea779a32c9d60ac2f8c506c7d2159732f77d07088d87e4bbe9e9d292e55a29e1dab4e3a849e52cc4a50add7ca75d1d61491d39bf14c7372a21c1ec4756a7e9a6dcb20a17a9a1dc032012c19482d286a9b778fb5e4753b2e9e5db9ee8780b7a71d6ff7bcf805462547fbe7054fb3e049e8df7a30f739739a2ebfb2de57da533cf3df9680d7759e27f1a89dd11ff764def12afbb346706ae5db09291df13fbaec1d1506d27eda911df7de00a8c52526e0b996558198333a43d5d2802ffee6cf526f156d426567cbb8ff07bb7673432a62abbb27ecc11e1be88762dc2bdeace24d7a2d97192864d1ad7fa164b00dc108786b584d2c2e8aa5c535d071a80a0b41ec094796c038d660aa28da4db9f64c48f5fa76227b4338129344bd2ade74e1a5f99e18adb594ec4d87b1f2ba897244d5fbd8cfdcc26aba53d34081187f9c1780f19ebb2532dfcabd9d4fd77597410f4df7c45027918512b61dc313ece4e00cf3fb9fd499ce3150253365846186fe368f3e4d93a62e42698b30c97f6546887ec8d82a10e3dfef2d5bbdaa9da5152115941e0576e97d6f745f28c7179e522c89f856bc3d4d6d5acc6bffd8a0cb2827132ddbb22d4990dc4589c35200f004b6fe1d7cdc9041bd60e120792666c5983bb41da66097bc5e263fc9845211ceebacc56b44d890836a0c79c03b0442754afedd704465a91cbb3af184593b94a5a24db5fb03fc20e4db48402e87dc86577d847ce59c41d9eee8dbffb9ea112a2fbaabb74aec0afd7bca0ccda98142fcaa5727a1b3dfdf0e6ec53914a2e7d0fa9bdd9ca0b82c1e5492d1402a5c6858aa82ab8ed4b2ef7c8c1a0bd3368c0def07b04cec536bf436eee195b880a4aa8f89703d6e11a97d90993e1739c4486c028a2a8311350486369ea4a984476ba8222b193f1b59cf6e9379f09d80bb81ab05cc48ab2c203994b2dfd275f2960156754cadf875cb8d70bdc0155db3f526198d309400b9cb706fcf944a3dbc087dac0f1be2091167303c487b1b4b31a1ea03b3d0f513030e3094e6a1b4284ae4930395c850529eea118f62b71624882969926f4a402b5630b15495ade01b2c5321998321188f8dda4e4635aea07f40ab31f15a03f5f73e7ab34613b1f97c276fc1ae882246819b3d90f6399d5b3f32327b647bd42bc474574a01d7b46e762a1a33d36f5cecaa325d492d4fd5659ba3aa16fbee5603dfec4ea5901d2c06f7305369cbf666e18bc5dedf2471dfe275294adeeea1b6a37938b21f5105627b9ea5e1866e291f377b6be85f90213d5fe3462b3bae3c7a47a159a9e429d79fac1c791b5e72279ad275c7ede80cad92b3748a4295e954acedc4c92b9f8f9bfafd01f321f54edba8fedd0f349ca2db3ee4abbc689f841f1a3dca1459fc1137ebc4a4fbd6026d1dc2b60ed9337f85084a6b7d8f2a40158bbdb9be0e1e99f89a2fb5f29f7d7668819183e4e948a4d929de1ef90409a837975e96a74be6edf161cc5c98611260e5a865f6a648aded638166bcc2691e9d3d34f67122513ee0706dc3410d620c8dbeb9bc533a6515b1d64017f04f9b7301b51fd8af44c737d87be07d99ae3edf9f86e43d9fd59f0d195246440936cedb38f3093415800b63c37eb72fb7a82bbc889a5c6ac6101eed852190c6d62bdae6550cf24091229cc0b669a84d48566490c571e5b5f85eef41a90a1b529fa8166e1d9ca75fa555a2ce66b63b900e333eee636453d529b8ba0469d15bbec06db6267ff0f1c5ce63a8fc7be4c86b42099ab9f6ebaef2ffb2913c53cbf6da13af610eff9fca98f627f92649c30ebb1ad05b78ab55ab7d5c8a310d2e5eb7138cd55e2572be4c44a3f73b3eddd3e2b0ed61e9f7c2178675498187c6ae113868ceb15a9a5c2adf594bcaabf630d013c2645993acb9a85158a7dc2f98b41538f8642d4ee729f14556ffffcd8b963d1d1178174c10687a5c78e5747112e2f8690cfff9b83546dd02cbe65b19f2a7610b05b420a72671ef2662d20672e6332b95902bade4b2debbcf14818d8f63e8ebd66cc01abad064d10157fa9855b1e96bba38470e002df4ec996836fe309ed147e71e0cdfde733b99cd70d0648d69265133e5c035128e8fafb6fa7e93428d79929e7662df73a4b0022bb4c1c605ee4044a2b2c01299b7d3dff75ed19eda436e0b11b9b6f71c7bfc40bfacd074021c52aedc752069de4f279203bf2fd663d8a3bd4c129444a17bbc2918e47e643d6c70bd60e5ed3867aee01f7709efbd48ebe6f0443ace25858e5030807707683b06aa257eeda9e0fe3856aa1836976bf916df27a69eba2d5854f77f3127d8de215bba081c89e3d156d8d15294959555449c7353d42a882c983b37c6831636234aaacbf0bc7b384ac5b5f283a04d0c598dc610c8df1e767b5a551c187e29f4d830cbecc2536edcad3cd05b1800b5877746c82ede0516f32f05c6448736d88e0087eec2295db352f2b1c1586bd3073f99b76fe1babbcc5673973d7f80069a1c24dd5b1bcafb6d57295ec04ae0ca803932ee1002db277f94f9fe545917c673e4837de2d3d7b9d453dd1e5bbd7a51afc35091cec5a4def52c331e30f507f69ae2e2047b7e0ac18eb49334594395db8c689d24cd1bb4ca092d2ef8a7dd41cc9255bd2847fe247b84e46c933e2b6f7fa0d08416865554ac22e03c48c1e5a20ce66f0f17884328c84777af8333a3e66d35899fb12d9360dfa2db2586120eccebcd456ee9144667dc6fbb455b6d47180110a35d4caeba461829bb520d94d993f8516ce1bc0bd742c05d796d5d7aa8de62f25264d672ff49cddb9a93cc5683a619faed64f9de1d99a25cb847c6bf81733fff298e4d3fe623f52da9e158ded43b5a9622f86bbb6d37b42c1aa6b4ff50a1f74be9c2bd745cd11c61c716c73b388de475e6e2ee733454b09363ca54e3882fbd2044e98f29f0831c2e99cd66e9e5846340b16e21cf0fa8d6920313082ba1b5d840c285f7fc11c2fe31283d70775195994058f8218add8d74c95437da9e93983af8984d0d9e689d1238d9fc7d66d92d0bde1b15a3ad3199666450d02eb48ee3560261a487f482a315ae79499c72a682f7dde5c65df2868d25b0eb75d0a07e1d8c89fc0c8cb5725aa4a19d264438dcb08f67c30185293f7f217389eebf6800a5a5c6a60607cb3c7570861bc690d0d0f425a83b501bbf54f95a4f5271863cdf9e0b7580598eee35a28dce95d19a61506d606b2110e5a7ae144698a19700d6224f2f540082532461811e41e23ab2f854e33f07941c62a41f57d6f0dac39031875fc2c98d271b145c3f950895ec379d425b2fa6a2cfe6df14db4b3313e62a023ea1d445529b9e0c5571b89e2ee4ed9dcee50bee87bb3e6b04d5ba24b9851c2d1785eb26cc9faf4a2dc0e170af5a8da1d7a33908abe61f77df163cf670eb6e4f95e0f2972f6f2a7e19c6567c6af119c291521e54809773ff8d2bcc7ebdaf51d84d2521775839fb94f41f1c430586e4bf5dc3a3c0ee640dabd5a2f8dfc0ab991d6e3e5cb0030b85d8686d6b3e1f81c997d0cc17e51c2d982e1d48e7d6a6ce8dabb866cdeaa2db4cd9d97b1d1f8f095a6c4f19679de167ea5166df32b5dd5680b4c212e2f3bb92df87c81497b0c3812696a2494c64e293d61bb63ea631ca3098805e6533949deade1807e103d7c0cc10e85b4fccae5249a46e5595eb29833c504253f766bc0b28e9cfa7dbbc22bde0dab94ea301e768d2ccca44562698c49445858c0d4d30af11df1dcf7853657d8c8733f68ac24b897b8bd7b98aefb4237f4a9b2d58201d5a82c94fc8fa0289856f566c82e5b731d03dc65fc31e038d8ad70346a57d79d7dd03dd937dcc52bad84d320f99111aa5bf244bf98577e01d6c20b8e73cbf50f83e5efe9c54e322c01bf2b0391a5c94e2a5c9953f950c66ab6e5bdb0353799226b9005251e451a9388803068a1e17d0c68d417b8acbe4fe7034b7000d1611080865d88dbf0567bce71de48644e278074f1c9d9515ea6f70964db43cdc55dac831dcc7e96776315f9fcc5373268af96c5869c11885742e884a2113f9e46efb14a4ab22929d69c63bd1e358fed415d2ed07c3083ffc0d1d4066111b775140b55aff6763a4c91d18dc7f61962b5e5321c9adf89a5d6ad0b8cd171c762f772132b3a8f1cba31e0b9ddd74171da637fdc049a846f8fb1c65421db622eeee5ca7d576136ba34c28d5fa2dc1b000a9283c46d8c2deec31f31fabac74cefddf8dd4856db8b23d8a4fe3857e779e95a0206d82f16125f401e99e85b1d3f36ea7851de74c5e412114b21edffbb4fb4d1ccbbab2add27f9ab0163cf179b5dc379d154c67d6911694a8ce5d76fddc6b55cb0fb32897d8db31e2fb943ea26833c48cd166c6afa2e101faad0e8d25840a3d9f3c49bf74b3ecad078a26d98a04f5dd1e61c66dfb9780c7ce22a72e1f655d2efe263a13e741711e82788426d4599eec5cf252d328a895377aafe8818ce99eb21cc22a3dcc9bb650433074c3c089bb3db0fc30df3aef5c14bca33a3338fb5d727ad4b843e4cfe9a63dbc4641e847293dba8ce5fbe6149914729820413e04b2c19d614d059df570d517c1b13e85e832a9f45da2c5ee338f5f7ffcd1c39ecbc8a9b66cf27be0ce7260dfcd1796833b8ee3650f38eee19883e96a6334faf7e5cf6d0141427ede221160a7ae0df4795d4f4896c9c30dc9053a92e34882669279690ae379bca922683dad1f5d6f1b832d883d7fb7567cba1ff98a114e688859ec823f94089039b31141ce581023b60c0b21ae24c1825e6a57225ddbd3c4991d4b322e610e2eceb3de51e8203c6afec4dbc3d3c63a6ad035d56de29ad62ccbe1ac032ff6b37c68d70a34f9ac03ba5194ec378d9115eb3baf1d7b4876661454ab446cb9142f7c4e606f2f8342a30551460fa348164752d4f98feb10e8f1af0b29990fab279ea176b68f43ae2345de950945c7fe492425f6ea7f7a4ba66f8d883b628a39e44a409d20665fd53c08d704acb8cefc2396d914492d3861409094b262ee4db46c1c675f6f7ab3530f3d05585a2866227b9041bdb963c8aa577671d11ea3bb08dbf861029be443a3a765ef96ef0ae2fe39f9f6bf461cb99eea7f5f9b526f86579379cb7788e755b43f76bf3db277abffc637d3452858078507f167c05525bcf9726ab094b7b893391160e85204effa2684de58ccf54aef5c1f7a616dd8e24742dfe380f71d7bfedd13aa358887700df02036cef7483c5e8994f942e89134c31bfabec8c56b22e56eed3e39b80150d6019d5f9928cab4a754c01ed44bf30f8091d39868d76f51c2cab0b6e8898da3c1853b026ec373184e580e24fab14f2fe0fb6dd0a3801d4a26584641e9af0c36fcf50cd76708ff44a04e2106959432ad9adbb666aaad1aacca46b2f1d7f08a859790465de11cfc1b3cca53a08d4d2fedb86c702c39f3fd943211078e9697be05ba2930b4e4737a6abc5dd0c738656479beeea13b1be6315b4df8c92edb029f1d538939ccd0bbb4d476c2e9fd2d5afc94fe71dd5784a3bfc88901920144763224f85bab14d938d122678b6a407d2c7a72a25664fec2fcb274c9fcfc551fcbedfebaf48e57d3526ce2f5968d3a38c6507c9e95283e4b4182b69b7723e8fb4c7602994804d05ed96a54a367b2a2ee91ecf94c5ea6d0da477197088abdee7535b9ddd3ed24f27ded138eb4fe5e6d25be22bcfbd77dcbfb6706d502fb65699ebc1284b154fef6bc6b6e47546c70612730a1f33e0dc7b2644a6b36d2e41308e779d65b65278da2c3c5ecba3586f6862bbaaadd3aa93d1d5f062db65ee83aae834f7fddbd223bd6d59d1844a9274eedf7a2c8d8a436deaedd2d5ddffcd5083885009732991df077edd8f2480994f1f9561772278c275202bee3ae60063d621932efd53eed5ff2f61e25ca131ec1f20a0493af763748669d8fab36b81ac208f71e91ea31b6b72ad713a2d62ae55b1bd6c74a9bbfdfe1d9cc32906f31db5770f328b84a3ed1be172004023ccc808cfc9dea30e71e99a22990ef260f468d314000fb55e029a6acea8392fc3b86cdb9e842199e8b2f19a3f8c448b7491becd81db4700aac56abba12bd5bf961b449f298c9fb741ccf2b0fd3821c9ed681b6acb832e2cd6424a10d34131397579f8000f300418fdadf6e45c83661aa2394cce57fee63525087ae92106617da04afb096691b8e4b53e6315398937ede968f4fc7624da2b8cbb5f267bf44aa84e30f0e14b22b6e3136b51a8b07de10a90847202ff6243c9580d8508cf65cc02c50f2662462e9304982491a57513c0556e839f1adf8a77de9e9fed2d0ac1c7c41bf7b9f1796941cafb682d05183b322289ca0e9f4b92d98b73c171d7ba390b07aaefc4923f0060b15c4e6743ed4b81a8173425d986549ef97fd552dfd1f4cc44442b75fcc3db4f8dcae0f69f56c438ca37765d620d2d18d8a45d491a61e6a2e252bea49f260c88cd195749d852b439de1233375aaa044322b59fb3bd543b3bdad24e82f15a9a9ecb5e854d5fd5b8b8c5ada354cf209012da5bdb2f7e580730f5cb2a3001195c2b838c1daaa9a7216ba1005002410e7deb7a8f1be97831b77dea38384072e977af9bd8ba802e5a38b028144111b885b7e8878375455a7cd5e348624c62a3febac11709af23bca292406b05ef5f8d584241f4bfd4e781d5068db1f9e1956526c7438542ab0acd2f83009a48749d92b5fd965a36a48d836ed3e1b1d3718f602d512fb802246f396c2de23da74f397da20df1a9eca670727e22757b26eb7ab55482210b9002646916ece4c2e81cd307027cfc78b296c3fe8d000006abb45a4b2e2e3e51c2cde3d5b50f30947d6bbb8d66ab2759829e3955ecec7bff37dc9b7732ecd2f227d957a323989e75336f68f5d166fa299a888b8156ad76b7212a4a95fd8d9f058673b316bae4874ad73687313572db4f0df796123da2e1831f415fb9250553fea144e63cc86509229c8aef230150f5f9854460086f390da9811f629c46c47b1016e759d05741cad7cc04b8baa7b0d6ed0f89ed0d5b61b1dab3b906a0072b8c620b197ea5ebb51498d695ca45896903719a52d371ced960e52a4b4da53273eca197f20ea8b3479c28393d4b32a176c86c33ed17df407bafbdfb53dfd464936981007cc59cf62134390735dd87fd2ebe2e865f9206f2f07147086429be39a5e26615c1081dfe5b4e45a401e146fbcfdf3d4e7b66b2b704e9f52de3927e4a21e909d26c3eac5ff449d2811f6552ba586667d0629b6bfd9830a29aa6014e952d1954579f986137f9b67370c2ab8635b7ace1888c9bd9dc7401c242e6153fd5786240bd8efc3e9fe9701576dd20efeb2b7bcd3048f45aed0a735394a51f9aa7d952e406fdeed5bc5fa01cf8a0cfd953d94fe7f3ae72ac2163ea6bb8c31800849ce50ed45721e0677a8ae875b80b0900a6988aa255861a8a47112fcb65f29b4e3457238ade433a2a3918cc64534caeba4b682283b5f3dd03f8e059eb0462164bb1cdf89e5789677f2eb8e4d150b75c0cbb97a7ec69f9cef574a5670825d12e9cc77fb038b9d9d3593841565d7116b6d75cbbebc36dff47c348bfb0541671ca8f9c332f0a2c5f84b5527a76f5e42f0fe827d97bf4968a4045dffb8a11bc9116df87e9a5d42b02efdecf5277cd7fe18d614ea0c2ce5c9660b28d44ce83f40005625f5c28f7f9bd1cd84eecee5236ec7a5369406b871e45c19f28090a056a9829285747296fd90be5e5abb7f0dd302e1e06bdfb8a408954399ad9e7c8a27797affca0b975989dc3b3e4595f5b1dda50cc4c4ac03ddacb338f08e768606f67fad0580b156e90267ca4c1d59caec405a11c2ce4d764a33875f1ea0e472bffe083807b94325fac0e29b3fa6b1e953e391d9bce5327417127f133735bc697d18d6267d523acf64b15588fc8f48822b0b3573252b12013b827e1f71abf6f105524673e4922b23e145abc47d22c5a1874bbcb38aa47db54a3dc8122e6ecd4cc51823c0564cb220015f335a2fb72f7a708413e2093f251c1d3d8fe760f471f197b179740126a731c3db2dd8790a5fe9d474c3122ed895b25e584c1acea4b773fee5d8c8f52c3f7f6ae565bb644c490508532088001600f0ef6c75eddd22693513fb1da518f4241c4192e885bb7f54ae4da404b93550d80cb35776f72b4a04de5bd6b6e4d84ae8ab0ed5fc5b756097fa027ec8afe0625d111ac8ba98d28cd0af90a918ee5b7097516663874df6141c92fc0dfb2a7c35f4c932766f42fd26e81d348324183ae1c8a07aefd6b21528421862e7d6092be9e37eb36235b879a1026f8eb43dd8bcd23e17c4c6004880b50a5efcd3afa19c0a3684f5839a7a0dbcead3b790f6f64890ba27ba53b402ba361ddab94bbc75e77a1f8e82d79edd112b35b08af189eb5f87b00aad0cb434d0070636df21f7681ecdec1fef40b9f613990ba9fd6fae7304517f062679e7ea1939365c71841360a74ebbb2293892e11c2229dac9b19821d9e29fb3d010376ea20d9953f1ca122de76d1e14869cf745986f8d3b714616236b1a898d697f9c0c6f5ed753d635b919f8fb190e6b58ff0c4c14863a759bce8dfeab663120f86510d023631acf68553dc337941743c1295dbda73b53eedafc966e98bd5b5c3901d25fa78b71db4b9e2b27e21448ab608d1a9e7a1fbeaae74344a860dab722ca551d407b66f64760c5efea28d8b38ff4e95f65ea8a9e0620b90b191b78baa2a9e1d322ef6fea0f129d458a4ade94a7aa47c06b30b9a411a9cd9d969e432306fb6dd5f4388ebf68c28d6f74f5198a3ea0a5ed40f7576ee716843bb3efd65503f22838d8f0f646cd97ca80c747aae3f0a588796e3b9c50ed9aae9e7231a3b4ee89cc3e73b1b664ed4a2386d3c5796dcd1a010c0aaefb1dc13795adaa5428e6daf1cb97cc2145c3f067c9d7b5181225dd55539622255cf5aed8fef7e7d5d353bec479897cc16751b69d8cd5cbf383df2babed4985b37d1dfdfe3b510795ac513cb89c1aee319f33002253e8313f011be8d1e38443f4eec9b26f689265f35c256a35405c6b1c87fc5b262e4db00343f2eb402f2d96d7c88f8719b4e6d365dd1b940ab01ba37bd42d698a3d16126c2c2e72c549c9eec4051a78595a98c026df975c4b994c315df059c480819eea1b5549f03e5c26a12de3add39d8f955ee0e144e3cf7933bc2345d2d550dd9926e38f8d344193b8ed0d4853ae06eced9351c2c0f6190226f0db7c05158c2aaaf8cfb64e3e5995d45254394556361706e9258cd38a8826047103d814d511855252d5a3bd35543f22527eb4ae8384f7ac2910776a8bd2e957816c6f8cc5a1382d7760e673327f8a3a5b1c98465f1dfb672de31a88cb6413961ae7885c1261b4e6958df0ddd3f5a9c3aa94afdd762df0969a777b4258ffbedcbb1543a168c88c535989ebea385bce3685f7f53a41c7ad24c656f4223aabf2d40c9dd5035f81d0fe901f4b988e023530acd929337cf23dc7216a1e999d8d4b9e93758e651344387485c3c90916516776848fa177b4eb7da97700dae9db8ec02e81e4ddf51991aecef1dc0512f25fde95df732c8ce0767dab97f23196048c8d97aaa921c89ab91dd6ab8b8d0960e29dda4b034aecb1ef26bbe170c341cb61358caee360942f5ec516739fb14c9659d87803498dc0cec5cbd2221afebcab431c716db41a75a565e3d1c9dec31feb5863191b3ffd2780a8078b3cbd1fc804e138b2acd92adf48e9f1df48c67c172822df9e8af960855b12782dd9eb83a1c3339b2725161181b9062507860dffb77c4652ba3ab51f5cbcecf1cf15a5691ca502c05f0a163cb9ce5a8f423a99e1342be667b0dc839a3cd6c6f5b243c7c8114412d1e1c6f2fc8e3a0d7d6c7f2e571f5a4af4fe761ea96f29b8eb262cfea98a0e452bb3f27dd392270d429bf247031969b13d4d291edc84db84403153fcf46b512924aa34e840278bf7c3cfeb16bb9c8e2132e052e796934a9ee164e1ceccdfadd08e4fd6f3ec10d8b9ae0b07cc3a1ff22b36326be7fb882849c1f05af94e9db8555b3e26a6077b94481fb55b6550a1d47e2ae9152b037a023dc7c5679710b1dafcdeb89be6b057a7af89af45a169f6a81d55e6c3dc95e67e74a07d4aa0aa8cdcc2070b53165bbef2d289609232e695dc8f5eb7a805f33fdc2bd2fe68b47c9577e52455f0d249aebc70e5c5684d98fc7bd0eabca44d5510b23b500454442c18393833b47d8a1f60746daa8149851525781e9bbcfde7ae6705f3449b6d930b1fb6b0ae535c8689fb0806a41efa92b0ec325d69c969e9942770fe5b24193279ae1656d2c49e117ff17b20d7e74041c8dedf4b482ca33bc1b635811435cce158df661c39c6bb023fc76f872c1f67f6eff9c7ecb8dec26c82bbfa2127a6c62515459fff6e210e3d41cc86ad529ab9399bc5a31a0734e3906295e51d08f04101b3d84b2ef6fb3568b8069403294689b6bedb96f967a71f849c6c042e0db7c314b78ecd30eb5098f25f820760aacb23f7592123600b4b956b9597d5094577dcb2a4f0711efb9130dc51c40481c266ead7b2b75fa74b0e7b367000fcce3a4581fda426be8192e6c6ec330bf4d8db767d882200dc57c38b739a6e771caa5a38bc96afbe1ccb3d529dd03a0b9cddd9de62b4a740479fa715ba0fe3de3c9d92bfe9759d0bb3550cecdc2df8733d7fbe4045c2d16e4a4e1ea350358384dffb5545b05efc81a47d8b9b88577da4f9b3d1c69e47d37d5d82e54556cdaaa20ed6ec9055ad8e6bbaed8a9a5396d69ef9654d14e4ca845bc0c82e6bfa6f91a569cf2e6b0b94f8810fc4b3c7612145c9d8c4e54a22a724f0199e1f66ca1cfc0d9a2e9c42d9022d0731a1fbfa69839597efc039ad5f01cd28ad2b5860d88d4bb40c996aa90c9f1f601568796bcb30b529e897e4eca6c86b14ea34c87df5dd5a73b3b864dcdf4957ea3fd29a86a8a72ec42de1694ff493354782263d0cffbe294029393c2221c482ab969908133c060d33946bf8b38cb9fd869d26c3e38e23b79ca1599d72865e56b0f11243c641695dd2164c17db0f5eb62dd8a33b3625d509f10522a5075c51868d31c06e6df3d4bb79f3488ebd3776968b8560c600df0d8e58b46657ba4ac60423039b04859815c17a87449841e63a90255d5c96a398f1abcb52a41f39aea5dfcaf65d1bc7a1f84d3ed2ee347ebd1b8a7986c056a7489007a481b57e10a59d5ef0251c17c16f42ce4690e9b87f7de95bf9b5814e5faeeecb28b758553f368aa40415a749d3dcd2150c17851fc3bda461cc1d892da795627f9e91cda8556151b82d811c915a5905a79f03cf44bbc8ee00e7ab02dd00d96b9228fc7bdefcebbf45336b66145f65663718abfac72df252d460712aa49cd66102a8c41df47c71e17c42f821adecbfea5edca4adb6ee9c192516417d12e3088b08eefbb270e568c33f01c6ec6b195094240e7aef2b49b41c7c2ca2c3fa09a287ffeee340da7180af8a65c150e71ee07d844680f7e6c14bf65e718958ddede7c6b8eb64c51bdfb253515e1136e47e58e3be1fa825c97503f984268df2fe12acb613a5f4ff206e45096628a3b7d800a2e2cea5a75750f25765d7deb1061a54f0876c3ccdeaa5947df27cc8a0d463894638c206efadb5385e28aa7fcfd4268a883524e9a40ad3a388da87e12e29515c510477d5953ac0a7e14e8d58acac3eb34495f98003480f4831760af2cb45a046d53c3b87f0450437f962d61beee96f619140909c28ac427ada96bf30e4e4cd936a0f800aef064e88876017c691191974dac47ba5a79760e5dd8ba8df9658a712fdc22d96502e34417760496316bb4ae6559cccc895cb36b48b2c01c4c03e2bc0f9d980c2afffac2132323a6a5540f3401aa5a3a24fbd6f3e804f1585f7c33a2d5174114fe269ecbd9e63757f23aec0fbffc6810c35c54bbda9556d680a65628f6c05b59c983b0e06daf8bcfdd25df8a6c759bbf1c92149cd82b0d50273d26f45e6f7f4b59c95b04364f348c856c0606219babaf406c2212a4c389c2507db19a602e6c495348950135002f65e10e9ee467bea7b73060cc37c24724b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
