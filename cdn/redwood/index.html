<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a28ca2200375c07bb9b374ecc87c3f7b2fbd739ead0431bbb1bb69fb04fba80c1b765f1bbecaf8ec726334f61351621af5b755579201e913849f284793c3baff7f437ff705e779a554d9f7dddadab042b1be1ffea4ae92a43fd2927446f44d261bd62fa23d9348f8296cee672d0235e3f2646ba574f9b40de9a707e64951b02af19acbcee345d89e4e9fa9568185fd961d6ccb21a8a406440d72a9701d09a7f299fb39b2fcc7db50fbc00eb081bf67f6524f2ca712d4da3dc7fc7182221f4315aa48467f789f59f2b1c7503d0735dc5a9cde8f48b47f68b61873fa9a137d408259ec0cd4aa73702090437d67ccf0dac627ffbc122a22eb53d721381daf63ff0c20443daf564fc71a0cdd86a0f931f8793a434911229f9c563e656d0ac935148a2027628819c93137c28a3f9f8be03485939684d7596ba6b464775ccb134da65000ec61eeb59575e30b3defc5f443838663357416792efdf566e1385b68fdb848b34f376b810da9bb2f598fe92b230ff21c8d4d7c882b5ff150efb06f58d7eb8cb56d382a5edf14bb873e5349451efbac23257a65c0d093025878a47f2e64eb52b00375eccb3751785ba58009b08fa907defa52179c0d713efb20a56608452130173186722c67d52700ca86478815b79816546454ca3a9ec9da698417d28676ece752f4e2e1060ad0c6f4cbddee3ef1c277232a4f5d98b8df2bf1008155c52d4d15eac0043088f3857087a27e2d2e07a58245f299b08ee238803e80e664ce884c51408d46eee7e29f0e349cc91b9313a571b27fc99e23f131ca3707702864d0a1b3af70b5272b714bdff7e2d6045125c621f15bb4a8ab0841752176c509c7d4f1ff30542dce296802c38d4311a35e1a4022bac9da8c5094da9f49f8838c5a6bbf6ceb4902bb5a0ecce3c297a0b998f2acadd5b143b4a26f664ea28605e98fe6e994827605a099734545416de549b75219876433c146576cfc2d65b041e34f95ac27e2ee056e7849dded75dfd7658198f7ae4e356931a7e38062958912499b4af721743bb1df8acf9f03eabaea112767a15ef3fa9f9ff4c9009217e4b071970d9152588892e42a16cabe80f65591c2216f96e75fd590c1019a92b852e30ba955204657468a24f8042e8fe05dd358b286c957493593c8fac83451c53398cf0a786e05d3ae515cb329394d3473ca2a3513c8fb1f230ba9d7fd0042ccf092d04715cf7c42729b7b6d74dc03ed6a8273d5d86c73645b3188ca62c46316ca48c52be30625fac5b373c48b47f4611ad6f73be92f919922b4b82ea449572991dd35c64ab77b92d3aa1be731887be727627bffcafa22de597479d109bb02df94c6b9c4a9959f50b99ef968e9745a37ebbad92fdd04c893724bff1dade9cd5d95fb8ae14be40298468e0a1224e06ed2024e1dd758e0b5c99fcb264840c7b58ef751f740e474f04f22fb6810ad6ef6a5ca4f6c464c320d455db29b91d5fe314899d42e2cb822f21fde3906520d1c2f8c63e803e61548c649a1ae2b70c777873ec99a06246f7cbcc8af4040ebc60fef410904fd2a60e495863c74551355f61f8610a7c46e8922b8ccf915b42fde75d02038e81605fa38ed1d919e881e60a043dd76eefd3d9db29f81233b06317b758963db5741d4cc6497eef74ece42cc0884c349863868e5f51197ef0f4d9f598944fd5bcb85eacf196403fb1b819b8ec9e96eb0e64370c81121393a16689c152e670b8d9d61c3e71ed2e1f353d8366dc2a94fd53c498624786fbd72dcde91fea8e3505126a7228d1f6e6ae98f61d8d4386eddbcef72483074768ec51bb8d159cb8cdba12a57e048395a00246b9ec15afe25ac2a78cba5809d6c6a70bc72778ef4ca030b24740420d02159b233dc50e3aae35b2d95042f7da90c5c2b0236454fb1c6ef7e2f6e70895b3258e988721e040c984f3065c0a2c4de9df6499df99b6fac5bc8748ae3b3d4c725b8473cf9d47308c901032ef164e146ec1b4991db8273fab9b9cd6d6f182d9e959a699572390bc1a6fcfcde51abf0ced120a4aae3994a50950fa9ba9eba073fe1a7be766857b0f25753015c4bbe3ee26ae3fb91b91329b774cf2574ed2df5ade5546734f1ac93b58b9121fcf11f14bdb4b315591a12cbae1636db1d64cc6cd0bfe92beac1098b5b12a55d9dae336979a6b79a8924c59935e08d25f83b925051a533a5857e053c4258bdfd174d9617167ca4f48a6d192697c4a892ccf7388a3d929bef86ea412bc32dddd55071a422cf316093fae386afd9206e55369751d69fdc8f4eea10946e71f8e1dfd8e8b7396214c7cf863e185b35dba42da7094f0339ce987f2fd4051dd34a2ad75b6e0eca59b30c17d036f3f3bf7cfadd0d4bd05c2b81bef5aa551af44e2b191a994bb6264d7552a5b84119e0bbc167dc8695bef44724bf67a0b69a97931a0fe62fca75471fccdbfaae4f84de6429a70824d3ab56b76d01e229e5b00692d895c5bb40401de7c34f661bb1b2245de3387d238c8eee6cfc5441e38ffa4093424c656eb2675deaa0e6e4c946a6bc0f5dd40fb8d62e3234ee851629cbfea9a314c756f3c61a9d994ce120070361e7218b2bb19c423e5fae13cdbc2234ce73be1c57ec34ab8fdbad3de01d3d162fa96a3f346b1d6b078ea44856655f43929c5dc30e2e9a285efef3e9afa64606d624010ed9da20a66a5382c10e365287cd7781c93a31025101b9a16d182911d919d99322134d94f0bf767f2c2fd029af14b675aa336a81d8950a521175c76d9390016d61347009ad6e2746922dbe53f6467fe6ac2a7a4c221b1e7a10b7be9976e0bbae55f6602b5c17693763860b93e078d48bc3df084b543193a9fd1c28f01fc816c2b1c0223f32ab432952f9cdb5ee698ea87662c9776046c4ea00f1643d2ad14161e6167207dbd184d54856aa10dd1a112a4c91c9a647dd4039398cab89e74fb07619603a316f080181a45374a37dda51775e5d0073e63c77afcd38db3b63e9fe631b11973b3a26c37198feb13467d64a56abc52215d7c3e13c1fb354b18e4733208a8bcbd664cef1b94805eec1b119d48b5d33c9941978aabe0bf7e085c770453ee1f6ac4d2786a7398c107e8e97ed69ebb7c6a86f703e38841d35d57c974ccad932210d491d681236633f9a01aab219e4dfa65147c673e28c6576079648ed5b32c2b3df7c5bde9cabcc961c9d0afc4295e672c0efa4a7a2d5e455ddb052953cc6085e01fa7cdde358ecb1b7b3f88e9918108ddb3e2a865f7a9d593cdbcf2230285693d5a1bbc2cfe07142fba5ef9d040dda058b067fa011adec5dc479363bc011e732eac899171bea2b69922268fb4ad0d4629a51b6d65bff927c0aa192cb62a931058a8d7d76b694f84d0857b0eea1c49316b2a91d3cfa43f3a1647509fe14329b1a40ae488243ef107fdaec21768a1785e6acb488d136354097f5b8e827b86ecf1e89da1812df13ddabb1dcacba2eece33e207e03cef72895a02afcfdd68b4381b0ec7311798bcc343aca3b5340544a44b7bdda369631ad264f2e389672ebbf637f015f3f9e1ffa3e5aee97d25a3b2e0299f55b93f2c7fca546283d230201f00b57a745d5bf28f0024735876a1ab7210ff5d8a34d36602d94ddcbbe1d1511e212cd0451acd54e295af49a846c6a35e74274a39ac8d82382f4973ec9c2b563e6bf0aada5043b15ccf27002817a42c2d274e4742033b2ba09ec4fc7346b5d47547a4b2ed9bcc7bc0754cbba59ad0557fb2d8b731a0507844b5b34f16cc6004a2910bf3d014a79f4416eab9ffded8f26ba9b5c2d4b39442dfe4ac7b9feaba4c2c92c456221788901d233f80ee341c4d29f1af58540b2afb95b348f739774c2a4c8bc16f9df29f2882eea69701366262168968eab2596a27677a09403d56ab8d73a6b07f2904f3191a03515351dda85bda4a2a8c63a8edac27135fdd79168d02e5cc3501a7a5a584eef5a4afb1d8b5b4bc2fb27869c0c01a81fa146b478657373462741cd21e111f078be0c96d448e90fec1e1c02f29e296abc65894367eeab89d2f641d6da18dcb3fd4b1db8c78e325e835458384086f686dd0621fb7cb73066b9669d4fa3f686586eac2ee1adfed76e1644bd2afece10ca12f470ceee7f783cd4f45d88a6df2907511c47822b7ad33ef3b0ccb4961792799541b13a5ea439586a2a7bc4597bd3e19d14b13f5e5492a74766ae96a92b5610eacdda92652819d0dcb7f7dd3d56f7cf9335d26ad180cdfb28124230964f89ae44ed080481f398877a0916e4a0cf119eda4cb6d07d527916560f9df612c2c81183108cd37bec1739a14d1e26952383130a545637282d96d0510038a89a640af6e905060f5fadb2171acacfaceb41baeda2f5a189a02c19a68059053931d230dbdd107e9aa3676656ef67be80dd98a439d447ef58c2bdaa2e8ed0d49370848f225c4e2c2dafeaa4822edd04a753a27d3daec1590d9f3a2f6887a23ec60c22e49c24762ad14c3393b6e02109b493d8abc835d2ace28121aba13a9c2b05c6b0369823b6849b1a802e9cac6fcf753ed776868de378634aaa9fc60f6b6c37b01a98b3067613278af2bd280063390414bb5a96a6c0fd793d0ac7daf00f116590801abee73595d936c37a148bb246d6f8164539ca7a1019bb172050c497820be3ac05eaa186204d0ccfcf93080071e7a2b7b713bcbd7f0955d7830161cfae60585127ae2d97fe3261b9648297da68487f51b450290665b207b6b585e21e96314052e6429251567590c894bfdd5b4940279f4e7bf383aba558a6c61528a813781b0edb2729f66d6027e9c9cbb64fdf127e7f3d168aa8f636d453bdcde54ca82964072439af18e0ea0978745d5a4e6d2f688b2fb5577e28de09bf01f288573b358886ed54daaf9c7e23d8290aafe32c8362767cc4751dd9d73cd0466d302306a9dd75764cb39909dc49b9015fb617cb245d31a47080e6bb5e3c10a94dfdbe1d0f2bf16cee43ce99e0852ae75a1bb41d96602d6f32dbeffaf735a98e8071bcc63f7a67b8a1ac89fffed3c885668726b7c6fd8968d149c361cea9519341a986c4a48b76ca64401b3a71ebb00519ea13481d269f0ba4e184976fbf9b4d0aaa7a6422bdfddbbea77a913e3978c046153a7f3d09a049ab80bd330c9cdce44ddc30da4a454d8393570fef1713f6971087ab3137adca9e52340f04c9818f376c3e09594005a8b35ccc236f878ce1fd9367eccd939a4c53484c402b298f11e323a4cb7f0e2cefabbec39f2b29bd15900cdb04d8b74499196785ccaa1f9946757eb894973d9f9ad95ffbe2be10d38ef1d877d721f5e2a56256c86e8f7766a1a5092112ab14b904f889bb2ccbb5b68a42a459615d9d9bebc152836f4d5d16369ee6957f40984b6824f8a217d1709bee8663717491f8693f29fbe4998ff9e9b1880d96649477954447264126321d1ba043811956a534e4cfa645a752c6b43c8bef83a99a4c81f113409f1c3e3a8eeb2e22cbec94726d8b213fb03e1404ef12b40ea2d357f8eaecef5bcf870642b2c4f23d431ec731153016ad9ebe656532d7b250bbefc9535dd84354477d98c6c19c40bed552765298aa8a59a01b6757b865c8398caeff90a33151e0d2192e0d1d1170012517e7c362244b4eebbfe743051cab8608411f8d6bfc9d6a4c181dabc9c6695d983f845e9b038d64da152c9f54238f30b024a781f70362a992dd0ef07cc57b8fafd3dfcd19ab01f3c2d948f781c9050d6c348ae413dfd20e2644aac4b9f7576cebd2092b6129aa68c8068716b4c661f082334423159bf7e831f0d5db2f0e3b9281c8f91128593d55f50c866d219ee0f7e703b9408aed72e5734ba0e4f2f08fd15814909b59ce47f84ffb90e3c805595e0abe788d490879d34e2c6cc2492840f3e1c0bdb8c033d3c2fcbc3c3ac45fe6a894dd662ef6fd56c277de00b09d6b183d7fef72a88069e29953c17ef44a73de68d7832b2c566a4a5a2cc083dbf9c005d27eda9edc580452efe001fcac5557aa92bf1afc97ea0c8c97848c33c6dacef492b25b40ca0a2b7c225203cbf7bf7fecac69ecbf0e8f88a5493b2e7f0f2e6c8d25d56393177dfe8aec6e1b3b277cb1a9592e175733421ac3f201890a94c3c6ea6f01c7ebba74e6f9de2ea37142ce3d9e8fa7e3c55795d7ba82e8d53d6a53a6b1b8c29cac4070cf317fe1c22a7d97226f148c3d8968cfd0bde8b2ebefe535b2d2e8c337fe1fd2a276bff98493898986f5b515a038be32066e20381cf769097dfddb51b48c9ecd323f0185c431164eca1c56c8c259c0421fd75ed960556a7fc22ef871a45c022538b8d132d2b83315b815cff7119e54ce39ddb5dc46bb27051c35c6455bc1994a7255308d7b1e3dc59bed4d5062d7ed4fa943f59f875b3b6c66e0ae8bbe25c17dba79b91d44a95d7a9977570c2caab512867b1ce21e1e71cf377869a24a4c9b6ea366ae7ec3e45edbfa2aae772e58fb811d8946499238fee0c9390b4684fe292849298531340c6f23a6468219ef5da5083004c3b4835d95e1a8c221a4c9a23fa7eb633dac26945a30191212a2d2baa2d839b450a33f8df47edb26fab23dd5ad5cd0469b3ad98d3752245b082f45cdf4d21ace464ed833d316b8ffdd40fead00783812d02a36bf63c32b6697991f83ef86fcde487c4c3c7e46785e5d87e60aa30ddf5f458cb047eaf6cafbb356f1112360b0f9da095f7e50e59b182349a8fd5b101c299aa362ca569053616906920c30f2a55e6dd21de27582430394cec559654a82f8c7f0da4cecb7777673e6fa4170e8337eee23b3f43f1cb4630e29367fe0678d7267d67ac94d890288e714fae273f26822e42c797e606337f685e3e2b250978c3882f14b88fbbc89bf82f166e01e032316a41c41738f0057d0369d6042026a10de9614a5ba17747a90221d131d14e943cd8f1a231ceae86754e74d708dd8bcf9485a73277205dcf0e8811950b7f3e982c905168c5324019af8eb5e770598928e470e856eac9cc7ddc5979519ebb7381c6c38caa35740800071908a1cb4770b15c027d0aa4dd510428be13e13c73181246f792524577c2cad1f41ba6ef243d912bbe1aee853536e89ff174c34782f983577d64abc978cdeee28f6b0289a9fafaee7631b7f48059a247480523ff6db0aabafdbc32886f57bd2c255c629b42c72a0c1f737d1cd58b169b397176ec3d25bc4bea2105399e3982cf2511331d70bda0586624fc280513d668d99f238480fdf90fe8e49b7ed7bd9edd840117d9cbcd8e6fe4f8e8405823f98366c9b90a1733daa7e7fc98bf08b8ece4d8fbdf848fa80012ea24831bca45f9b5cad907dd75b7e27c9c2e0b301af9bd24e5efa28ed1c5ebdc744e9553da0169ab4d40e8ce313acf0e9fa10ac35607b2fe7ab9ac0ab6559833c1c3c423468ca855f67e649c055b822ea31730c6ac8b22120ba3744be83dd3af9c1a19156b81b982293dd1fe527953abe3e9e6b7cf35496df2b6bcd6eb94519f7efadc27757f4f6c942f86cb45d3bc2627bce92f4b2ff5a4bb5ebfbf6f0267dd2fd477f80045532f142472c3fcf89cb92edc9e57b7da2e6075e1306135392429d2c5e724aed293d5a7e43611c6ca87d96bd7994d0a92d756c262ce7c0a4999a2cb7cd1e7ae688cf20e4ae0b0e2c5448c5927c165bd6fc9f81b6b0f9110bfed2922e828fc8c025ca6907bc8b2925e1c18f473b394111e94e101e07768ba90afddaf7a6ff4015b4f91c397ebbcdd896e3a820f7b88d6f65364fbf4360f357128b1e5e0eb1d6c59200e27c65d8f943f9d480e371242748149a169a6d8064f28fb5fe41468878bc2f0071a4e7711877d1b19797246af1fbe320777cddf27e44575920a6c8a9f6d3aa8e1d93c36e4f6af12fe1fb36bd60205c106d120759da65f512d78210a9699ea345ef4e0b19887171df2c7942bf939a2405d7252f3584d712b23b7c7cbaf286fde3be4e0c449f1da5b212d372a6df6e64cd41e0c23f18d0f753e6e0808dedce9f65de464b37cd21c46e89e1a480b9cd718772f14ec73d918a3b0b8b996766a407be6d3a3f9f5242042420d6df2352090fb40db00afcedd7e045fed4b3d61af6ebbabf2fc02a611347e9476270578624b9a35b6d62114f730feffb790c94aebe13500780053f9281233725c98154d2d5b8025335f282f0994e4be77fb532f10bbf9dc467b9f0493d23a3e5b824a1217b1a5bf480cb144d3b9b4d061217b8ea93571da4eedeb24b4395193638bbf020ac412a850cca860d8e53255d5c946db5f919b69a4e6e8521975e319937c69c3e8db3186805b7dfa02381056de985a777835c7a3450771cf2a633ec9849de04f0a013d89fa03163fc088ddaaf3c8579e44d2d1a5e1951d8427f77750ceb8e36a039592570c0e5b015cec60b177f9e5ed1612dd49b195f1da8cca126994205a09359fd2af1b4698afaaef580ae4e9633e54dac75f448d931b41cce7d2caf1e27feb21260955cabf5e2cf4aa6d8d6c37b47e9543861d023017697ac0e6434324d61cf138b1d679c3f82a6b80b704d19b75540a0b3258fedd8d841a775a54003ce7b2d7536b2fe5da34184f8cf06bd22040a226f1b30e87f2a94c84279df7d173364baffe43b19d87cf0dd358b10dfb6356d63195146bc51730c92647cca214c4ecc47043178b8ce02576a840c6ac13cdd8f9f2b54824588060c93f319c789d14e5a120ad63ad8e18df4158aeaebaa49de7a31e077c62ea509a5afd9f15d1db0b26fa779a092c47b0406b2194afa02dcc2a620de0cbeb2e4915382f61bb604666c4df237a2339c3e367077468e2050caecc2b604d9efc4dc00bd0d36e3cb9da7878d73633b0823d18e011d0789477d897cce6c9f27067c56a4b3a16568a286819e1fb47e5fef274dc44cea575c9f8e5a7e825e40dc5ccfe4f29b74e6a1d7c833ebda48686887b93fa6658aa04b6ea5f44f038ec3fe805020d7a2ec8d51ea2166107a9d94945c9613eb076cab5205fa65b368e73d3eee1f91c814cd560877e87adcd962f9d2e92a9d747e33a1d7178d247e64b6900a90741b3ad7b61f0b21c89243943af428fa503abefecb5505e3baf2f82ec756eae2c169ed15d91be80b361a95285b60c3b45d3b8b72a2fe2f0e603081155202f2fbb6b4ddbfb245265cedc1f32e56c220016f4c2e3a0db494b5a03d834fc3762e732adf301c56be40f553467cd7c3fd1402a9e2c03703af455672804b807e1458607465f38d7f74b933b59c8762e9807cfebb07322223d12d8969176979367cc11ed05cd5321b4b00aabfe82c739911e2f8c7978bc530cf565dd73a2d96dd9a06732a7f4d061e2df7bb3fe999c9a378e241878ab8de0f8bd23e670d9bc545175f3b0d233bceaa561977cbee9f4def4d5464a7d9c1f60585a1c1e727f7ace9108f2448eb3878be6391ba59ec14a330f8ceec7178fcdcb5546b96d1d3db358daf5d25e49a7a3e07190ae26bd2814b3991e3764d06cab41a16e39d5388e7ce73dff34443200cfb30fdaaae3716677567424bd0e176dc29668e36c77fa16fb779e5a2f2e7d1c229ce7cc45569da8eb04d445d7161610aeb4b1ffe1c6f22c863c71a9f059996e690d560334af5f2d96f95129af0abbc1c78c65f5bae8fb0999ee385b78921a066e119b6238d7fc1061c25fa07e563133f0c792321ca1e0c6dcd13e8ea512d2364f21b4d307349fdb533d290612bccaff07fd293b7a8eb7b585aca44d6b8cc2167761e92efa319ec15095caac210afaad6efbcf3516836daca26a664fa3339dadaa574e5541685e17f6de126d991784b47034af125b4087bafed1458da6e01f453fb485eae00d700f86f4458f3f4ba0a12ac1af97be3e1813fee7140a5f9ced5bb19943bf248a73b0a092ee273e55fdeb125a6acffa9ccef048281a3410f1e57e2e7c75b3a3f9224f21ac4708bc1a1a409a0e45d37b1ae9586951128dbd69eaacd3b459b148f701c86c05dde2588e80fe424d9f183a7f112bd591b34442e68f9354b807dce54e9f3dc38874b6466f47db3c1f8369db58cc2aa493663f49471c041f4f3d279474aebbb36c21948cf6c244a085e2ed8816ad99e6b0f40374986557f6ab61c1a3ba00a0b6773a1c284bf231875de306623f5cf4f0165ffd83b1899eff9d25454d5a92437e102c07152f405cea4a9607da713cf57f03fd704200e57905195f83f93152877114d24337a11ac458c4a52d451841046dc57d4dc2d2e8101a4e224358fb5442c3aea6572955b220303295d857202a06a62cd32956beb130f4ec49425c308a758a20ee320865ec74556f12c90d91250957697002f3ae59fd53ad021c37a237f93be9bf7ae13f9454534d9d01edec59f5d2cfbcd5a53e596dc292bcf76773a1c536e541ff020c76517879c501b31cac8d4749708d82fd1e2f9e7676663d628ecd4b1f369f488799dfaa46cd4f025251acfcfcbef64f5327f4698679ae71e6d62086da0779f4d4382b62e6a133cc2058d593b3f2b1b8000c5dfe03b6e69e2e3588d387f4d3fad9bec5a3cf4a3c0326200543325e43118a7d6d9c663d6c87d1ad24b6587efae5c5ce0b39e41af8e24e06b9a7a65fb6244a416e996a288ab7b173c4ef801062ef329397387bbf0175d389b04e6474aaad5639a5fad960fa3f0cdc263cacfb22ce770431a106c2b2f3a7c286c33b02818faf5ab77e8da573d89af6b7cb8405ff01e37354914339e02b3ccc4e50065c9167c187e181159510ffa6f3f5167528665bdb472bb800c9f582cf560f414dba88dfa516dfe6d2d681c0a4cd10cd05f80a6acceb329ed9ed2d9566c142ad207729e4c460ee54a89cce2d7700f8a5882d3b67df4267d65d643db1002ebd906186ac5958a581586f014160f178aa7edf20f5db23a5090fa637e5e086e472a09b0f9edb0809097b7e560fbe573f3e4a488d528bebe57f44edf071de7f1743833e811a384cc989f3b122a8efb47766da5ee94325ec3a0e7305ac6bc55b42cc5588b6a8409e083d84b2f5b7ebae819e771e4feaac7c1c6e60216b95e51279f42f80993cfc59035492d9c21545a4991c62462a700610846ba8914a850d73facd65414cb52ad462eb3c4e898ba8ed90ffa98c79f4b000dfb7803818e467c0787ab5fedbe5a329a0e71edef84df054466ea8511d26518aaa9e32e1cfea4dfa831eb32025e1d8285d9ff9eee3f94928f905760863102c3ff21fc14c9ae25607614451a69340ce2f949e809d7e2f80931a3c9190d10127995ce735689c55a68f13672f2be29706e73cf79fdaf6a4acaf35e3909706f755c88eed311aee574a955098fc2565ef3c350c3201e0db0aba071458f440290b4fe3710a4d4f361a8d15b8f8da650dc642a880e869fa4a47c6a28724bc801d76b65296aeb01f79c0f9655f25216b3400557c44eadbfa81a03ab0590393d80fd15fe2dd8ccf64b49fa83def1a4797c77efd05f38bdefae4dadf7e6df1bfb275343a3b5a0e4ef8499f48fd5f5df7fb00dbde7a9b61e14ada440b540f97aa9577814bd10ce1522696c12a34a7c1916104fcf1a9c4eaaf7bf81397464383c473faa8e48dfe6476221c6f5e2bbe7ef733b2c2d7171599433e2058dc7666a0d8b86da83af997ff2ebbb00fb6622779a56ce0f73bd769b91d807cc10f27c1d6982e06efa99d61c36a51db9687cf0664d7f9e2447f2ba3c1035e458fb61fe04540fdb7c45e038d4ee5ce69a3689c3523265d9fc4318609d1e5e4cf69ff4dba6516b91551b3f67cb8761d3b824326ceabb928fe95a5c62a98161511799f83e49e00476b2f97034f5d1404dd5cdae55a6d57db1cb7da0a9c29ad46714f413927b831433a2d2a5caa5c5cf1ccc917183d485d183718576a455f7aceb449771bc3b4a9fbd0fddfd696df1e652b4ddfbdc0f977ded0b0f77deaa4ff34962fbaa30332099b9d45d20e6ff49d45b338a38015a7fdaeef85c9bfadc9e8040ed4a60b1381d316dd19992d70e51bff7176f49c99f3b6a8ce4b57c8fab77faa1a800b63daf548a5d93438b6ac4dc72b243a004a3a4d6a107fcba3322cd07bcd65bf6b1d2f36787d2108ef988aca7f2b7ca189fed6ba75106b71439b19132921e31149c7e731f081ef8d968f8993927a5b90e271260bcf5631e656d030257f2b9619212418791745ab5886b313ca4fdaf7b495bcaa2e10418376ee16c7c6aa095cfe98ae10ab4f0d31a7e355533cfafce91189a0fa4c057707290d279198f23bc3d275eb2e503ddbfd82b09aec536d01c5a76ff8e261c9d7c1108088fb4d39dfc8decc0bceeb7fda026e41fb63daad97d3d50fbd622c07f55279a9b7dd24b6f355c447296ec6c0df426a5804cc6dfcacb29d0952b2ef7928b2d1bcbc0bf819be91f5b790b8b5334c709b757678b64e9e49651ac39adb9044d94185fd6ddb37528871ad8daabe1605f80b9a826fae7e45da2357e4a398762b53f92d08444c89866cc95d3060c709ed4a297c968d9d974ff60973a1509ab0605d6ffaa2d26852b5ee478808b20dc60eb7b2470c26067677c132b1b9f596e893a62197be3db1e21176efe9b5735839f1510395c5bd2a1aebe12d8bceff3e971ef6f40431882392124663aa975501f2c6b7a7d0d1039c220b4b989b7f54abe266d633d24e8ffda094cd644a8d40e0724661ff1ba11ef60ac25e9c1c906c5df3644e7f14cca271639efc2f16f01ce2c93178f6bae7a11bdb6de0f9c3dc58b7d6116dcab6c915faeaf10edde62f654fae4064b34eb1428376c4c36bf0818ee1660bc940bdb3da4ba5f4203d3121ee2479e49a6c2e9261a476f59a2109a3cea5e60b299fcac924c68a1846ddec6a65b9f099a97f86230d8f12c6cd3a7fd5ce5461ff846580c00748234c0fae15b2f74695518489eb426c3f45b5e54c7d6fd40fe9382ddf810ed41cad875b7b7fc956ec865acd09b4d02c59f30070467503932c228144d9ef57d39c8d9feaffa2bdba33edcd64ee313cbd49307392a01710f6e1d74134429580efc655a891f040628bd744730a6985182a2814ae29712f0bfb8e73ecec80e42d7ea448f1a54004dedc54ce1cb77462ca2464f4befb5c4f63364d17db2463929e67a4abaa4846a3844e776e19896c75521ab15d8ff0659026eed108313de7c92e36a2e5184feda1bbf21490d8084fc28234a62556a58513d87ab06b126e9c9d33a9921a2ac8f9c408218061facc7f14377f2efa8d19031c43c3b2e902696a860af2ade18d88fec6e5f8b3bb748eb612ce2d5abc45ad5f627653924a4cad0cc43e62e02704634ce43ce63939df030a6d9f82e4811ab474f879dd01a71924b16a407cc3c3959427f40e48239b86b35d8805ca80f6a4810abc005bf9070dd1f2fb2137a7a05a8174932bc2a893e73ac45c089e9c1d691311215b705b12a98950e545d7ed6a8a76924f4557f38f97d92f7b5a0c702427b2ac1b691bb15448bd304e82c79ec5ddf80a0cc3322e8ccadab46dfcbe2b1aaf97ef6405b86f472d1e4db53c6e1066b192f714b8809a42c1da1a5f84f5d6ab4e1ef14d16b6392c6618a1577c303cdf244dea02443c4b3fef4351943ab6617c8a51c82974f13666ca3797e2e3adf2cbcc5c720ceca6d552b2e1bde157f3a7c1a1eb6a6c9e2a71775ac9d6568a545c998129153995726b5e85c1dd60f40ad62155cfc4b779aa64db57c6a33b479efcc0562fe2a402d52817f94f8f6cb4632076c4738bdb160e5414724f3b30db634bdbe590d8a9315ae80cde02859b5faf387ec588d4ad26ad4581ec1b4291b7baff64ad0bedc5d656bdb56cb56b87d10fe06ceb73344f81b048860e38e90b02b3c003d0eba1fb23ce4fa51a27d5bd749672276d3b2552d8fca0c3b630cbe04f4a00846216759ad8d6086cdbc7fbc86b4863f580f22656d341ada12be1a2c63ed44314130adc5f2bda164fa570fdee6f7c897265fe13c8320dfa3fb60b77eabe9daf94d7d85ecc4f5eff08b242c62eb4d6a7a9baf23417144de0675d358b1e39cc8e246d51c5233cf0dfbf1aa21c7fcdb2724339a9ce9c114ad7caec977ea3cf333a200e6cc738966e0481a4bbf24a16d3b88d8fad641525ee3bc37ff85af15efcca2df619686de7ab3d5eaebc93b9099c1e4340cc6c8711e91e3a49486d270940091fdd887c9ba01fc3f18d42630060d95b36a8b8a4df2265478b5f3ac978f5b8a79bade9460570660f7a0365cd6a9f35bac4e30021a57f7556db49045e16ba5434eaaf6e6d7b35a74e842a94cda584ec67fce120754025b29adeb4dc0533a7dbbbe9f9954b5a5ce597048e37a71146910435ee8ee805a78d12aebb704b531e8998377ff3946ce75b810848b96d887d28ba93dcabea78e21da1ee4c152280c2243c54ecc446ddf88036d05faa48fde4e44afd835aef3c47a453bb661f5f9552b05e4e42f6bec4e8206045b620906bb604fe81de94008fa853e75ada6eccf2a979ae0b30ac3086a3c4d40eb262e96124bfdc65ef353048ee24c4ecf71175325fd96296f4661a86611dddb1e5bed7b162025a6a78abb5c78066fcded6312773c970f63d3a8d1458fcda59f2b6f7b0c5d3ead83b06e3a9dfb098b49ee8d767f7821425f37e28da0c052f3e0edf209a08fb43f004f9ed522d94714410f21810b487ed8b9a1848bf779358197e357398c29f3d2038a405dc27513c4cb9057d793336ad86e73ea5ce95d40b5411a2b3d0af4df9f1ec25c30f289cd4cf6dd59c77202636ec8c8705aab055f9e3810d81dbb8cdab321eea0bb6b9a1e51c210c75a0b47f7359d1148fe7269f5237be5b836a8a1b8f791d783b1fa08be774f76657ebf8a8abbc354fa84dc5e7f8b278f57cd9cd9142be922e14b57c2777aa320062e6eb9d72903a7e58e76ccf9757cbb568699efde4c58ad0b43c7d8ad89f17e5dcbc60540b6101142ee121880f71b9f49da38cfcdbf031d1cb9858b8209e723b78fb9da3eab3c28805eb094a359fbd3952552b7030caf801f17c10cfb95bc0fc42a137e89712b20e0f3f25ce386b0201a94182b28d3a15afa32f1148098097490e494bf157355bcdca39aa3503afe0dc8b1ae2fc4beeddae5cea68238a8de77f0946fc5ca8a9445bd9f9e434f7d44f547c8324d1721d5eab99bb72eee8e8160dd5f7b5ba91e7036a22264f063843a29ef576d43ef0465247b21cafc41c92e8cd79ec2df783f03aff37ac67b429ce4cd0162dfb07626124d997e620f11473881a89446e2e5ae206b8f96d5b7d4c1a6e189cd07cd2e5657c436f74a98b9e49ea7e3b4d0b9b7128174bd001ab6c4498ea04a06057433e10bac55dfbc1ea64c53b1a06c813a4ccd98e1936ed304635b9f2ab26bf3174d580e1fcbb420d45e079bbec001b7453c6dfdd0fca6051896590083cc858c84d7428c131fe58b46b9e6ade6a78235d7c35885cc94045f54d93f82319c8dd1081b4ac9847aa90d594bd38cdc74960271ca3bd1695359316b7bb7979a717b9fbe4f9c48b99fcbf327060935d8751b1b20ea2b2f6278f17a5777e4482739560d85f632c33df6d4d50feaedf18667093686d7b26c37fcfa0b79c0986380c3e7823bcfd1d4d0f6ccb0b9b0138d9c5bb0140b6ff65ff2cac61776a18a12caa2917a795e329f2400c7bb88868994b661165a90a7c6e0e63d244731f986d2c2b175c5bd348c4a7a18567f99f75d603c3cc2171ecb3f2e79442abafdb8d25d1add63b33f961d0d291e6fc79e8ca5c2ef187236bbc162acce2405eeb8277864eaf4d966fcf2da99e2f0c81f7352215c1ed757fd4648e9c10bf8e2a0c1277c83933dfaa94e50a99504c36d7408b085223802cf167b2d948f2ecac65b4b93c65a95e10dee69d474bdfbccb095c947fc1466407c3eed6f8ffd5b25a70f73da0d08148a648231ef1010b31d154a90374854611e1cd5a976491b19d4e32320061dff123b06720c68c6f45f807c7598cc924e8cff488ab22dee53296fada72b5363d06a07b8e8a078fb62235b74be202cad3dd5870140a490d6a1d7f7c0233225a0af547b196f1c5b3fdb5a4b5c8b663d3d29ecc7a07418d83d18136bbf2ac4a9874a61650cfce7f8c899b16776a333a96992954924414a16506e6586b326ef8733b13d6857c5659d36fad59f4cb8ba14831029b9f0ee46f9af90939cff359c4c1625b41e4a7573bab7b30b9b863e4a36cd6742ecbc179fca6545407cad0d5744a5615bdc0a7472b4520677a41e1e3f692c51c60da82e2518634ce2e0b398a33e0163a2368c96e573ff0afa7f72dd8655df58d1547ca5e530af935bd278c1e95b45ad7b9996559ba676e38a03315bf3368ea55caa57305e01b21669f0ef679d8ebda9be3a71db0593a674310be3013e5748e092b722ef4b29cae67b13ceedb3e30ef361709b208a62c12199fc55a869ae9efb0b51da662df6b4e5e883e6f24b6835f61de0bb89865220f8691eb9996522ed4240044fb6fe3c88b8d1a08235c8dbd162603d831caf8bf6da92e668cc61b151b5e771dd6e097a4f1b7dfa9027a33074762952fca567a1ad9d70c2de52bf63e17c61bf4bab9ef123a3b9a9bb5208aab612aa912b5d1adb1c25cbd8e0c9dcbd36236e4f622d26f423176e752ce0b8883e786edc7e5a2b3dec27ff1263a594baa39930822947d55433be45ca89ed1f33222ac1455ab2cd3a31daa51fd216d0697a40e4fb6f8ab73594a3e85c9b5121b2c166bfb822f9d534c16896a16cbf1f5ffe0d9321accb0525340a80335a9cc82c8b90de528da36b85334fc91fc8c4558e9cc70aeaa4d9307f6bb071e7cfc3d70e05d4888489f7def4cf5d99f5060ec2aeecfe54d240f4313ec6d85f0a0db186f60674d9cc1d1803a1e8716e765346abe16f6e319cd11b1860b9927d23e3153ad758613c7a969210dad8c0585a6f0f5f782e249b62aa79905bf70f0e9f733f09ee525c410f3d48e8adcad3fb410e309b903775ee025f9d3309f52c179eed649430b6fb5f23c981273601bcccc3f93b348fff432e8bcf71f5cb610d42a76d7dbcfe130b5e6fe40d3b93abc8e0930eb0c694065fde3c1be9e0299bbec732b7ddcbe4ee3bf887759e6448191932e69b821ef537e3edd2ec313cf6c8360b71d9e3114e21aa6f7510e7b0f44bb363fb1e27205b6654c008757a074b39ce1be61f80ebf2038284715d427fd4a6ebfe5891e8e2058ab9d45ec5b55f06fb1ced8ac01edc69fb3e1cc4e57d58f325547dd17cb21ff088450502305711c459753b41ebf8e0d7be104b46bc2779d68b03833448c32a316dfc69049180ec3e809e461eade7c3daa881c4b5b17e828995c9bb35ac0263e4664bb07cd004f7325534046c7ee3ebe5a4dcb77a530f0ff8a11be55315379294ad768caf57a011ec05134fa439209d6329fe51ab7c056c19741c08540c046678c29f377bd4cc8c9506e53b937c487e7a95f783d96a41603e254649288a54dfd9c217e748746ac0d2c04905eb0de3737840b09f88a4dfe63381eb4630c39c3904b42b79caabd51c6754ecf1b9e8b1532e11500b44d5cb94b5140330ace43ef936e89ac7f53a9e2dbe6926cbcb5701bcb7671a0d1ff17088fbd5dfd88e4e713f183af6d3b8f169bd8402d0e167e86c2268d9fdd620b5126ac9198360dd15226c9fa84dfa2f48a564525454e5b5cbc189064c697ceac6a3da33245a8036ec2daccfa31eb2923a73b86ff9fc7af07f478996cca8834cb8f2398bd667a3fdd1fc7579b3186e93f9e1851455713f6c8b8c666c181a3fd65c89511c942332ab5acfdbf362b395b2bb11c3227e6bf374e9f442a9dc58af2fc3a04123dd6568552d551938a12256ce1b27c8e4121c2630c4e88acad0c5b67665b434ac38068db2af9a6360ac989c69eb1b2b11b6b5aa609d189bcac2ffbdcd9de9e8fa05183093f5ce72cf1665c4b124badb3b30056a6400d152038c571985369bde806b4ccd6cb68abeca2f945315c6b5d881594b478f3c2338cb4909a0baf4c61b1724ca717d239c6295659c2c6ed2ef66b9c41996383de98ef5b72df2146daf75601f42c42782c127711ccb7234b1d8bb4c2eedee2b12a01ba66d5b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
