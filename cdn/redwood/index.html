<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23795286a12eea652afeda4257de75d0d2d4d20cfb63cc89d6123f9d9f3f3ca2688f8f1b34076cb96f68b57a546191a8282e0a7f3de31544a04630319d7d2781d8777fe18ccf68303d496b0a09f784be33075e5f0549cb1215f5798731c89c901786ed6d796daf5e9377bf6b1a349f5d0406203c1bf1963beaf32a84347f1859d073e6675a13ea90b6be10177419972cb48b5c3daedd26fb6cdc3310f89fc71d78cbe28e7ca34c5a4cbd629fd0b0654a28a8f284d33e61af9f67917d9f9cc7d88b6db01d341a1a1ec851529559039427b23df91dacaa644f5e066779b85377a0690f64387ed2f79b423ab915ccedd33f66f19f74f68e49a6ec93454ec193964849371a5688c266ca1ced038603f3a1128134abbc5e7872d532c4b33182afef41d170939ba4ecdd9f2767ef1b65084630b33e5f4a5ac0cb871eccb0f5a929eb902221badb193637aa646bd95550e715a42c794bc4ea386831957ebfdbd2f257003e2b1bb3ae98983927f3e6fdf7699809faa40ce58876f4ea63ce6dba4e490838295e56b9fd062dc90be0d4711ff75e7f8e3f04d6302bf0ae46223fe46c1683195211b6f414066247d2e176e95148d6e9b5d01b0a47fbf7aebd544d1d06d884af3342c512a6870ee5b894dfb2b5a2fa9663008006f7a5d9d9a5254faa906263bc9f7915555c26b35837ec99f5f696b5e3bda7b9acec18ddea597536cb03a6149bf21998f227c6932e789e4662f9758b0bcdfcbedadf372b701b499b27eb76ab1034acc6f490b6e9d387202bcc720530e0b6522743268586abf331d2805889f01c8d65f12b0ca62428dce79c1286d6576154e6fd7fc433ebe0f007ea526f8092e0cb9289ecc63d7c6fa398f95bbae6a00f89a028b97055252d3fb6019d91ea0a57e50399ec8da8bfc47b8cfc3f37e4ad8137e53f5f41dcf80fb1d38e64176cf837d91e1b6066d3d40a6c722065220d1fa4ee8b91574524b3c8198fa9a45e1e608d0dce9609876761b20ea5e3390bfd78ae8d83d15235659745a07a621d4771a0e26f3398e16ba1752fc31b198909d6da857e3019610e7e60af0467f44f4402c7137135c22061cf847b4d5ab1513967e4e9b07d6107c42975e77567972b359214734a4f84ef21c6485df5b94fa93da3f58fa5dc9684160c9f7d855bf57a9c52f9decf326f0a906f5414bacec17c03c1dde70f0200727fc647f006f4f236f7457a91e282691eeca17679073fd440238e0ef297dd3bfa66c580fe2595e0179d34bebd8f1ee84ffdd76075308ae8ef865336878b59643184f341e8738e07f13955a22db8a3bb9e81a1a91218dc111916dbd4159369e0c3a3cf725211154fad1f5c3a1918d57f9d1ed13fe3db9c5f35ac10f61e08f33a93a59c88e11300aff6fca8619241a044d5a05e5ddf5b79180d27c4f676b7e182beafcc62c32592117bf0056799d4659b2afb5acd8229b1de65afa0319c1af8dd763ef85a7c64cd5169d4858a20fe7a6020fc3e0fe95be91a1f89c00bcb5041f9ed7e0a7966260e163eeba6393db7aa07fb54d04cff55a6cb30c33277fd684465399f264f4781ed5aa751189b701948753ebe0bf4215dc44d8aa93cddb89666e9165ee2fe618e94609138c3356164639ef43d5addb46edf056c7654458e06fb3d674232f85f92329df35ee8fdb09dbe6e44d6f2bd9960fcda1223f0acbaa1450f3949e3d6f6b318deedaaed81031a1f675fbd90887933f22959684a1da82b332bdd6e1ed7d25000aacd9c96bc63929f4756b0a2aa7bad43592ebb1923d7f05093ded98a99b396db00c71c75f091bf8c7e6e3ce1e679e83799e6a92bc44d3be265fb05ba9ec73e9c4368ab60316cfa662b25a05e22f634738f966231978b1730b8b1c2f46b768e33a6fffb4e269e47b31468304b8ac9e1a3823a2e0355120858070454b999f1b7f00414b98b5413b0929f98dc42ad8d005b75985c87c3a4a5199ac60d4e2f55495cbeba9bc4861d1467b0fae38d60dac94d3b7a6320ae7652c6d395c53f57442c25246b64f71a7f1001ba65f639a353654d43bffeced3ca259f4de05025765b3f38bdcfbbe1b31e8a8e0ab24b8d4c34e1bfc42ffec6c173e3969d9de70f1cf5f3556d062a4e25f9ffd77e0d0c01eea1a2e81874e88d349654fd40f23903bd521e1c422ce420d38ffb2064a7afd26066f6ffdd873d2b01bb3b6e13803b0e40e8552ac2e1e8040b78e28863cd158048a7356824d256298460ca19b884239d00a8d80627f625b374941bd229768507881ac32d04ca97a757b11a1c8856c871e914342cfe6a7d4e3e0cc8c3845ecaa5a7d3ec850d096e1b1ad50f82f5b8b39808e7d60410b4f2b7a4fb40459d6619a8031edd7ea8c965240753e396492d0fe20126f3a3f3393c4dbcf4733d1a839a04536ba6a9ea7041db3bcc1be3ab58998ad8043c0575e894c5000f9729e728b8d1359c037001a06cede9829111f875cffac41ac77edb63590ba27ed2f565fabd3282c85b660799ceb9ac86ea41cd6e59078495dfd42603ce87d330521393471a93cedb7da79b14dd8367536abf8ffd33041bd0b1abea8c3fb6aa546c16ff47dfb65ad9474b3f59ddc63007e9851150b0867e4b3322e3d8410af08f8e31a822868ec912c57192479a513f6205aba42b4821e69003e42e3517ed38260fbfeeac1568fe8357314f8c0bd515df8aed532645971406e1804401ee0887eed76baf127ab874d5877555b3edf79a400514d67a5c5a0ad9b7f4e380d68d29881986339e242b9fd726c6af35aa4b00db1fa5e1dce0ddcbfaf2263639b5d3f1441bd8426009c779fa1745fc88128c0c8fd33f39d2079fff157b95c9c418b640ee8059c1887111af9a59d027c73d73d072af2457f5e94b3d34e59990efe845cf964ddccece133802a764ff8bde9b337be846253baa752ea7e9aa0f517067534e2e963e176fc71f71fd6a361f0fb905cdb563ec315de499b3dd590aae1ec8f24fd2dfa9ed89aaca1be41f1fb3478606583511042375888890c3a42638283755e64495b5a166e7ba717dbd487dcb4f4d3d0c2949f08436894e04cad89166d01c04135034e39bbe54ea573d0013b9376deb6223ff9538a80bffd6d05c6a8d1defad3bae46fbd4564a5974706b69aad3fd28c37073e618c1a39fb9fe6cec0389874b1fc9d7a3c9deb33385413808e6373501f08450bbb0009b85395d8e2d3998a9ed9193c0722e1902052daced3f1f1ddaa07f18c44eca382142a3f3e3f873829b727d8e935991d4afbe335f34d33442e080edcdb2ea9ed0a1e88957bdb1dd5d847b4352b64ac749141d47a738c3bf1e3d7c92e368050f2353f7cd974fd7500a8ea10731b411b556de21f75768c3722ebbe94047d7e8b7b74c4f0a7075f070be2b7bb3e8c3f5ee01d7f56da03f916bc9067f8479878149d0a545f20fb43265a9272470abc36c872669672b59c08ee15727ee79e84b057fcbd897959a0b1327c519b0c81bdfd076356d90fca7b7eed0d887408ffc9bed5abcb053ae1338d6e0f518ec5e9d715e41cc0f841dcbe254e3a89f9da5f35d95131c350f24156f42511c13e72b02b25a7dd72b6792870d705bc4c3cec904b71cce0dab15a8931e04a9af50f9970adb0cf1811515313656b133f97b3ef53e262ef2a177e47d33a3524ec33572b356d61d23d969e7a052ebd7dc8213f859d3b131079b27fcd5d260db6dd7610c4153475081f1ce88f02ebe6512dfe3a56a3b656b08e4ae88b8d6ec0245e72cfaa714b588735a5d009cad19f6de1969ef44fbc406ab94fc63cf1a141e3c2abacd045ffe88e4891459171cb495370449e8efd1501aa827a8a5e6d18781d868091d93f0ef9f1afc2f947408b5fe39fbfcb218e204908bf0705c622ecf1574b2e61c6915ab01aa7a2d568a705ac05d22decdf0dda36e5866603b2366b67b327b824ea86aa248318ba673ee132f0c8e373b06afd68fd5ce6ba34e4652121ff5b3bee36f94f6a907ca49f6b00f8b94ececa7af7a50de77c1682fcbd97cd0372babe23122d2096fc70da32ecf4b55771e3be51bbf619ae6686df524f7f8dd4d1787e883756f23b16fde062b9a5ce5148ecf39791b2ac1ca0e7591c51f065820890ea5f23b0badddeb408ef842b9f10861125ad1ad81834765d8a47e4f14bbf63976a45658be946b17498003e117af8a3ad9f153fdae8cd59e554085e953777748e4197231d97b6e438208e8467e22363196dab8728fe58aea09f70910c381c511d7f9a091a43adffb8bc5481e5cc57797f8c14f4fc457c56b25a1768b538418abbfead54623dacca3b3f023dd7ada4c7e62dd42b809b7f4c10f7889a5e068a1480231356f5a85726fec1755ddfd0a3c06a127d8c1c546d85d1f668164d6a8e2a08a9ff05f0719ed1e52c0950705e980d1958f1bbfa1f2b371be9b57a3c3b5d39bb93afa3345f4985345664f50dc634af83e4f724fa36a0163dafbf27fef627b28f986d8418f66bcbe19f3c28a4ef72bc41a8b611b06a1b2f400df5c57a733d2f21ee67111c050e0a68f46293a9dcf747f740e7825ead4b8f0bc8d5fd1f98fff00fdd7b32cac453e56c5682d24b7c8698d5a619645c9147f6182dac612b69ede519a47f51d3f75da2c369c1494761cd504f28a7b5e53a5ca1ac183e7583fbde6ca3432320a47ced1825e44922206ad7e82d3b28200749d67c735585116118b74b0fa03c305588374d8a7bc1c3ee71bc8a5d723413bce3041c1486804baf1c1d25dc27eb19329e594114a6cf2c912ba534eaae19c1f3289891fbda78dc07226adaa1a7e7fbab384cab4692e258dcd54d95113afbed30016e1d3a4e652d39a1ff3e63d0e29c68bd66afce1e219542318b098b293119cd95405a4266e30806adfc162af5ecd585c5e217779f5dc18bf49535191d22f37404d73aaef1ee8a6b01cea1f4a28073359719f8da3d90604aa9840500c2e44d9b8ab62e25b4083f12597f10ca2e9486c341dd6bee6b6ac3f5b9e5caf0b5f09ec8edbb711bf87fe6a22595ec3bcaa76cffaba60ec231617bd4d18238f8f67a9cd931077e17bd71c678d359fa958a2f7844872af8d79d20bdd413a36a0286bd118f7b4dd23a5aa1c241f0bbbc66b58dc6f3f0ca0fd221b110d91c660e0a71ff3ef24f44804db9a82f8641185286cc00aa94ecef166f6af03d176978321874a0a3f34e866e44fd42548e96de43f2fa56e5326fb2bb7ba8a7ea38522bfa7b6713938ebfbaedd066c6821b490300d7d1103463c2dcd32b8b6766b224a417b22d128c23e17ab01071098531bec4047a373f5bd9e1bae20fcf98bde23affc6e3fc4f78575cd80aa13d3a729b2941579c0de0023256b9db81fd446ec2dbb8e075241c6db7a5f2610d7e0b26a05878b52fce2ef3779c7b3ef9ff48e75fd9b7165488fe2c568d845cd150b27077f83ef98b3e18cfb0c0bb86f3d296b484b5158de1634615196eb210cb18f5e5238e44e7011c4065b337299048fb4c93b36a33977d1fef38920826b978de055bc3be5845661b3eb982f115418639990b6a293c11026335f681a0c2fcca9ef7ce2ad78fba37315d499d2997bb8a9cafe932fe26e7c12f630458eb9a5f902c0033f1815e04a18a634040bede180286531379b04bec894aafa82d56493530cba092eb62c3e4f2ec799e166ecfb21832b9b00f7d145061ee254a65950772b959917e93e54832d4b30f9f06e9cad1ff1a3ccd99310e20391cb97f990761716afed2f85bf075ae21e3e7418fe34c4bec5e356b4cdd16cbef82516aa30355115f72597a925188f6d7a92d75272937015785ae788a24f4a94072789c2736e8711a4100e6995af6024a3817978183ee94b5721953d8cb623551f5274c4790ec8c4e39a6803e5656daeb28054fdd977c70102f198b25fd2a39cf956d70504878725296d4dfbcf3e65c19de0f80f604457df70abeae4736c454933bf0e13e453ea5ffafb72cffe4882aad64c28c95d6f89bdb5cc87195765cf79803aa60f89cf6c5be096d468866dad1f5d71ebfbe4439d2383d70c3029f965c26dac33a1bfb639f389fc0456c75750f53182a49de94dda7bdbcbbb4807c445079bcf739eaad8e1927ce473a835ce6a9d0f91159410cdcda1805c1a463ccbfb23add613481ddbb03955481a02db47f3e7810bf989059c2f9f4a11fb60ec5971f0acf9d2032aa4239f433a40ca86f260d7a2442f7f51436bfc19ff4754b98d0eacc219afad1449d5c52d7366c6466e1255f93ad4dc3ecdfb3ab609a911be8b7e45eea16cfc191991ee2f84e0fcf4f00985bbaf169f4548d565b460adec15bd26ed45e22f89e8a399b4319418cbcac119da2791da505fce87d17a0114385be0a601048aae1cb3b51cb099e6145f64671431d949c83ef31605a17bca73f745eb19622675b8bc3137cbf3577765d61090a5ac7f93c550e13efcdd23638d47648eca5401ec0af6123d80e3f41cad479d1cf30cfda017c5f1ac91372d8edc9ecc1cd95b3170c7a81cbd1e9d44371ed7ae36af52a7e45f9db4b8ba0272817d60547fe0265e8b0a77db8f1cfa829c24b4a8822a0dd98d272dd856e48c50bcb9561b0a07d1884d0dd8569ad2ec9d34c0968bf7285f5cd0f262c65cb8600973f1a71ef9a1022b673806733d146c8ee6d831117134cb1c4ca894afde2f29a323e882ebe510d7ab15371d41bed5c5d246ad647119f2032efe8a37c303e4ebfa86b99c3ca97999860732c69fa1e3feafb02ef36ec5303914e58bfd05ad5a5bca8c1a7586e1c215e92ecaa1ae95e61fd981cbb06036c969fc26f204dcba4c4577a2843ceba1f88008a23680e03089cfe4e2ff7cbbd0afd31ea473aa0bddb4dbf993165f572069d3d995e9a58931ec21294293e4cfa2477d36114dfc1f093c3d486ec948993e286e9302a4a25676ce78245043c3e2753d2b443c7a07eb24b011bf1f383e6258003a1bd36261513d701e30743ac128f88cb0bc83978b1d7a762bc89ff38783582eeefad2c65b2a1b1589348a194d17aff3d54cdba2f51377c3430ae147c0b0d88158fd29adf7a29e35ff4a9b5f00350318e45debf0882a6533bdbf5ff01e7ff8a1f40e62be1b5f0bd74d41f5db52900ac047253292ee5839c45a476910914138521af6964a994d9a79e0fe62f26f7d621127d6de69fe2db7853a8bdfc34c8db2978a36b490b448c8bf87dd82c104f01a5c68cfb0a061daf81eb7e0b21920b19dca4f9b6d3016300b4c38a70b286e9da532f43a2015f1d2265ab32e061c7fccbf552ec0356318c0c2d19386819ce7863971dd6d32f2dd3121339703e266d37ddb8a2480ab50542ea58a292d6df3c265d4d116cb0a6db50594374d7ea02026a0c88d5511cea894c523e1b356e268d126209a625e730af34cb8d0e1a79f3acd67091b6e99e4aac79cb3b3d92c084ee33a8e497a698ca7328062a19eb21e60c750d47ca1d8c681c2e8d8fe59ace8c85247feb566584a2fea77b435510102a9a67fbd44c14997609fff3822e0ae3ab5371f3875f648d96c0c156cd32234f94924b7e81ab95b0d4dc208911aafbe9d9c138c6b7d287400528a1e8b1923925ce993fcfa08822fcc706e6bbfacc513c2dd245bc441bc2638b6d528bb0fa8c16f9127e7155d00db43d9d2e7d1f16159ebdc5dad9677a8a2686a0c39d68790e7448e604ae97e449d58a17526dd4446c9fb1a8c6e8d038fb8917c89463d8db7de751a209300f4cc2b570a68b0236e4d011ee600a93d6c453f701859a249a52b0376bc1528b2c312d555b0fd4778e855b5e2ab13586534c92147803b9ab5d822ce8a79b29b568df2876ca25dda4cdcb7b273179632c2104b28a970afe158d1493e000a7d6f55a26f0ee3f276d0c17f688943353f94983d8b238878e316c48d43ae9d7f166b529cf7c701817802647dbda5fcb0e91aaba55d4de4bde4a30562aa5642dd11e94e50e6dca2f16010615fffa323dfa0d91bb612d6a1e53402358d9bf326648e812076b009018f019ca4e9f59d35855451566ad003190efa47d23d8f9fec6040d592bf0d63f8683e3288a6b2b9bf8c0da7b42ae82e1432321b2304c6362fa272638cbc98827f14736a3a7310390efe18c8bd3bdc9cbfbec4d48621e0829c34198bcd9d12e92944e25468f3191aa456c8f4311995244ba216ef1809fa47181a42021bf39f359f69cdb570058ede12bbbe7aca18513084e8bd7aeb0cc7625483b110394d159dc9cdb8a825b0144adcc71be43cc35575453f2838cc391c0420d1cb48c1a0b1cd111a12a8e0a4a46b122d10ab5aa5f88cb2c6218d517e96f577448dbafe06555a1a12d7c05826ab5083611cae166ed0231933d77bf714b4ac4cb0ef502192ed3429e34d3aaaa9c555b69dc11214c9fc43086af06682720a82003eaefc302106e3e0f066f8d526335af646486c56e5fee3daf6e101f858ebc1620ca18114dd6d3785e733102459957464550c57add8abc146eaf263f740dd1c254cba785340b1f3a71c2f6caa9cf8e9a77ff31ae981feb297da3ee54855e405393fbf4c86a596dd52c363099e1b3edce8651fed56a739a1fe70900c082976d2c74ef99c54979541a57e9971c51726b9d5e1d71ba0e9640a1cced5ef46018e07198401a390cd6ef8052140932b62a82745c4990b32988d39c730f526cc88d6ba5d9a258d586aa15eed7d2a19e32327dbb1c80e4e32c2f5d2d02806f5ede8966332e5ad1dbc5b9bd109784a18cceffcaa0403a6d66be01c1c6b3b44d73d74df5ba8866cfc5607a5b0fbfb165379a7be00b6c7bb45dc0c64448e98f606e2bce177b81a81e93a763fd566af3217c95bd650092c34fff4a83c190e63724d275c40a513af21bfe79cc14d11fd1695036a74e1d299feb9936c4d278a40932eacc9194b14951aaf3677952289590aac68fb00a27213063577402dabe44c714ff54f747226b74a46a248fa27f16ef4e983d1c401c74688a5d4094dbf58582d010dbeab80139dd90c1a914d09de6a67cefad12b5b0b333d37d7a559f0a504b3de335ffe6f1bd83aba84a1fda8ba30279d0e4133c7bca52d77add3624d9b8de5590613d7cfcbfdacb41e7d9060738805244ad1b05e1b1858a907e78272b6d2ec90ac6504f99bb3b358e6f38815bf5d9ead8d75bdfe46a30832817d5b2208dde2432e5a49930a08258cdcc6fdeb6c559abf24d2be112b8845c8095a03e3002d397c383a5a2303ff49ecd05caead789b500052a386ffc27267fda42ee849e83155b0637883dfe5950eb5d5a627477d38b7ac028e5173bc251691102ddcbc97f6b7c788d6188722ed773aebb81d5a128a820f04f94117a5fada10e88330e7b7fd139bbf3ddf7fb1b80a94d2ccada138eddbf4d093dcc9a98c6c9eaa603099090690433c0f4171b0ae6e3966b6f76bd6f9c615c8657b7cc8b356d0d7216538199cadf9b8ede7c06f1a92b49268be5c0f06106d6eef4fdd932ee322dc0b8aaa7ae05e5ff4a69b561c9d3e9c60fa9280a2d21d903e358826e951849888f9ebdefb3813f4766b4d262d7444d0e3aa7b64753a8cc71f3ff56bde581f8ca428863b622fb464fa1a9460fd5521bf8225b951ead64c712fa45a6a4d7b0ce17a1f71b1ba283ee68f94843893554ec12efce7c1a914938873c103e6cd45ac5fa9e52d912b9821db8a4f959d80cd8447ef1cbf5a69f0afd06ad9891e6b847869dcca0eff7282f04b2865d0eda08abae1c795721dccdd65fa4396fa3628725536103120280c5bc5d73d9a1197f192e3c6220633c11c60b78d32fd9e88edd6560c65aeadbd0ac00f3e1ee8b669d132c9441c66cbcf1f189fe34f28a4db1bc15343ad40946bbca86a2a08f4c0b3459c2a3e2a4e6942130df666c51d9155234598a5719afa8530546af2b7ffcd2832b547ee844fb54ac018e8df108df63480aa1eb80c03f650ee8873ad51e028ae99e6fcbc1ff593fcd03f2ffa7cd5fa2f2ad400f7e26f624b30c3793473c214b55dc6b5e584065250dbdbd2b2d1fafe497b25391fc2b8bb5d935b9b91b189a25c174432cfdca0b861b31b8fe5571aac6809817ba75c9286a564d178e6202951067ffdca7e920f875b9a86a97998b4d8ca608bc1f75a5c69bb4c4bfd715cce485c3a7332f2793332966958550d7962d9982f6369740f00eabe7b1a0251a21d6bd794215c39e0563ec7970096076c8d8f33e63172738cf7b11277a2318c930f254e55da01375e79063934f79d9533525ebe36e37d5618758f9600a97a450010d39e441b382398f7ada4b6089be21d0bc827bb843c844fa0ade8d23deb67c7f4cc8aebb9be2c30764c7ed3ad8f2cc9e9671830110465e92dbe9e2e8068c0fcbdb079d9f2ecda9bde64dbb445cb04663567deb05cbc0b1dd459b2e26b9967e9ffaab88055df924ecae49f8ecdd2abfe7d96e24cd55ef2349ee9b30d85026a81adf021f7c23e37144cf2f50c9f8529244ea6ba891e693a17ccf8754a40807f9c65bbe2652d535710be62dbe33b0b0d794a2423e8ad0e5d26b62d725ecb3267d0933450c828edb396a2ea0eed936444e8dc271a62c3d03a62fb114fe3196cbdf5be58a41a4d9c139c22e8442fa5db29451b21a05098f0a47c5c3715e6afccd3d6e450aed5978e2bd6a4d9ddbec4b2c575df0bf5a3a9a7096df37499bc759e983f847ed8e94d844c42774e27d1b4039e9f8665ac3dba823172a54e30f6323534cf7fd780cf1488ed73f3eece2b4db27f812387fccd46e3334bb0f07eef039cb8e82e3b87b87b3d9e91750fa731953527939121a1e45af5d03c73e83953424f0846f8dc926fb9469b471c0937d0eff81304aa667c390143e596aa6f6fd75189c45905ae5b457653989ba14ae813dea0d2d48ad789af0dc8ed020e1961ccdc9cb546410caa96e48c8f2777a92866749f0203c08e2ce5d755f508d44b649c256decaeb59b2f4c03d8d36b1e6b261f4f8f54e0e751443ce07d8c6ac32f336b43c4f7d12b769bdaa5f3d079e25477d2bf255f4f8101f7b6b4cde7af5beb906115a8627248cdb69e47dd7e18a5f3797950de03530cb966a1b61690d9baf410d1dcfbc814e45555e2ace880eb5677867f72ad91a8a8a73f8a53e4cb58850e06fba8ebc05102f6a6ee044a2831cbb35f4c1ed821aa3477f9e1adacf6954bd1e69bf2b0409ac22c13f6abe01ba63ec79521484c69564da39a21dbfa0de88a45fa5b0edd1bc243f11775f8f667dfefe2276bf762a1f345fba8cee88bd8f311ad06e02187af9a43799001a986f4a0a27d9cd94234b19b1ce57339e537dba65e34767a6976fa1534a1f845b7ff3f15407b5a02cb7e868b6bfe76a3f7d053385a8cc56e20b58c17edd1a041ca07a235df36f6b95b908a8f85391551c3c4412fa7c72f5e7da6dc93c73b9f4632ee531dd99987acdf4eec1bfeb4ffee65173fb6960b2522d212a7fb2c79f6db6f2966dd6ddb0e7384d082da94d870769b1765cee2833626cabde66c2338668b9676ae805cf747c951ac89ee636d729586bb20b4b9347d240f337b08b0982172042fd3a3cdaca6661044d33a5f009e68320d7ed9bcec2f3ab9b5d4dff316fdb88a5469547ee21b708fc9358cde9b4f86fd17bfd7dda617671bb92cbaf91dba0313f3253ce37053db0904b9cb359d7f1c16d6efed9284b033d88d9828ae66364f1438119295f655b6b93ebbd10661fd5ac754bcabd37ac233784481f3a4b0ab5744696d6b6e726c409b1039eee3e07fb583d12f2ba4eb5321a6de692e22e8e1c492179f497a4cfee27049c9a926d1ae1038ac0b1b6c4c26aa2f763f5195c4b26bf62a4c1529e83e21f441e88f6978b504186cb1168bfbbeb3d4c87013dcd6c00500e6bfbac0e83594e7078739bcb92caad3f44a4f4edcb44a4232242ea163162544036a5caa4b9b18d190287f00eb1a90908082254445e034b077c47be198860c20677e4d47d46bc99d77c84e66e37f0ecece4250bd9a84abdc21ee84d8ca9bd53f675b0b0d44b3280dfe868b9f765d602aa2c66b1c2b8562555d5fab71daa85975d85306569bb0699d557fd9bb179b3b38d113f02af81e5542b2c85b0ac59f45356fcc21b2955686aab6a0c439b7a2ecace111ab5f445847bc17218437759af3565612a8c9f307c53497bb2baf0cb6c134c250efba592b7d4a351e317e8c3b5162e3967b3a57e8254d0f0bad9057831177f0a7d12e0223fd4cf96760c25656402404173aed8f111637c58ef8bb6c41c96a07012e538db6c990cf9aeee48605d286543b63d1b4fb16b0fac9c752c1a64233bfbe64a55f7f2b36f9c2911f2a202ca4d58bb21cc56190ead9181ed9b11f2fb0f62134940cdcc94bba8d906856e099915879fb03bacb7b17ef6b7cc6e7e1a5f9bac16c1b61335b6479d921991b9f064a6da424d08ca54f8c95f670acbc23981f55344c97fa4f58ccc89cf87eae338646da037416437dade702e300bd5778a5fc71ca81b20b3ee3fe92ea8f46b72c26d15586f76191d57b7348188258ad379774a92982a8987d2e34f93c76d12f231579d117d2137302e31954a99a5575575288398bb841e921e9f40ec54e32747236c6520282da4dd6fa891b17109d9fbc442c69a54cc84866dceae76a989732fc3200b9f1d22cf82a936916e40c8c2345c9c36b1c5d915eb97fd23064c2957ad5be8830b83d39224e94cbd74e1784f06b3ba740534e6adcb5d05c44e8aa48d6aed16f35ba56db5e1d4bcfa5290223b6710dd50587b9dd0ff8d6aa0338c47d367ed4111e7994fddd3b90e1ffeb8dea755eafe8a6b3d4e9212714c63585b1613b54eebbb3d0db638b9e14928d7da8688e034fe455f499ecdabf5dcc778ca2dfa1afead1af7d13b0911b04e57fe64aedbd7595701c82741943e23fda9e837a54fe8242dd1befea335a243f80b20968ede2294336a0b142ab98cb5febd4680af725072c613038a350f8262e73e47e27d29edf0e4b8074ba6911e94138919cd431531663c57c18970e576c712a8f21da5d9ef16addbb3b499cb4ad296e4670f9dd21156d80a0d73f39b49e62e9a0fb2ece20075d0c3c5d35aaed5d19fb1533d372f04d9422eece0ebc36ec1001af30e67b500e243926ea79c95cf90a0f68270e269381180b4d01b86d07cdd6cb9cc314915dffe3c1a29aefb0dbd04ad0b64afa7912e37336c0031830ea5a35f8515d046c22f0fea23fa57c3d0710c70f2434c0e893bf719c55407bbbf0c41c0c9a620a5a782eabfb0d312bae8fe0c699b10279018f07c2d57d308432b2af2848499f4bdfb4b939af2e1f822b724b5b2c7455e52180bb9c9e0c5139f465b6a50a2c96cdc9388d031cc5585797bf815d3b4ba1e37c11bef14e6e07cce8586bc263307bbf99a845cb3a2344465befcc4856f10ad37ea9b683a711a457dd0bf363c18fa9745f880c38f3a3e448ec38459495018df46fc9d2dc181e9c520b6dd5a12f22c5740f9f34e238dd4e7c9a2aad966c74ce64f68897a073a5e667000c604e829e57757711930a23c71208c0d436792dd1fe469413d76d7c9fc904e5e95c341954f8a0e8b9399e2e4457c5264aceb2c83a25c44686581b83598815bb0b15aab36efdc1ea0a49f2671f0c6532baacb153d6940f6c725496f0ce61fa02c83ab21e08c06243757457331cac5708d2dce8dfd0119d37585f869b1f33f99c680440582318ffe145300b0f76f66b98bfc0136d1f15f7b46c0d4cf7ae4fd2cd4d66c40496a9e72d4ff82805d3f86fc9198ded5c02c2edf292fe1a374e2040d9b3fa9174956cb0bdacae6075d5f5caac5a1e0b1edf32e5a0a4f70580120853f908ab553a24dd9cee3736c95fc9ba7c2cedb335f039020d46128799bb46cfab9ef0039623a12ec20f68fc06ace7f2d1be76124fe4f0293bf59b8eb482845c871f29568b9881a5eebb92b9ee17fc3c0cf17a8fb2134533bd7192b833e96fa2d45f7edba072cfc212e14d24dc8f83f0357e8b591cf4f2f3b4f4d1893f4c5f027186e8ee04cc9c9152d1c5bb8183dcf85cea07d20def6080c1ec2aa00c2cca2f12c04371f4e1d8836b0049de946dbcf4f016856f74d9fb22d7176a4742d519739db1474cb26db708c795899c5ecbb0cacec00530c9d9a424011bd147df192146e2dd9dd9bce8e8cfa866094c4d14e650b9437ab561d6ad99ce9ab306f748f0916b205ed6199da0bd84524fcb19af79a2b8907d9e758cc4d5cdae8d647deb1e96a74ccf56462a6cc2cdd23d93d6187018fa3b6f2ac132c5b8bb09894053091f32d8eafea93e0bfd5284376983697461570182e1a0130a7aa2bfff27f5f23070dc5e5e3ea38f3d02222261d02b389396fc6b052ae54f3cde552d9109249d4aabcc034854a5857a9c8d548ce00f5cb1f44c909874bca7a79e206d454e504481fefb4d606602277ced3c6c86e405986b2c2dc8530c9efc99ca12732aa442ecaddf0811df6eec00e1c007eb5e1f52ff78cb2811e1ce9f52c07f6f3cbf0a65a11a4906fcc52e780c873bb77b5301741bb58a1a81c9fe700613e205682723556ded6ce55067150af48195ebfb62b13e4bed30a6e5b202f5a5ba3e7a94f72f12c3abaf1c4105a180a71b09fd30cca731faac235e44a5e5497f9c047aa80442365e943f98577ba6493df04aa85e194ee24df77b8c2f78b2551d7f72001ae8701d434da78051f5fec5015e49f7534b2d811940c9255095259a44d5a643f0c221b489a3eac519f0cd528e201881e44de1520375d17957035456dca384d7b96e4dc042afcfd6acd8482e26008032127609ab4f41f1f8f4988e059820fa97a251d702637603a7642b035e748ef793aa7698a0ef7a0ab55a54d1ca1c9c1a5c2dc0a18a3e3026eac480783ba301da49431d724e7a4bb3f6ecafacb2fb0289429f484d43cc0e8c7a5ca8015e5408411a73a103363dabca4d8f64a87ab72626d3d61473bd5a3a6dc5402a892debbd12ea6016b4ff179bc08cb26c939493c5156f2493d62253b5936cdbbc9bfe26e04e79a4230226f1ee857d8c0a75cb08b2ee1613726e8061f56f4ca076f9759c079e9e85db8423f32b8fc118f5dc3dd50f17f9383bd2518a15e4ef020ae6b6aae283925adc151f80b61510775ff31f4ac222e170be694c62caf26e18040ffb422e8b6385cde8aa9a06df2b7909863e78da7f2716bb5ffdd514f8a9a1103274de81fcd0f83ee323712726d080eabd808ccef1fe516e2fa47d879449b1a928b2fed378b6fefa96fa97d6cceab84b00f08f94e913802b3ef9b5d947c8cf9f05455be75e35af26488b8c455a8627c46d9c198215babc32e3ca245dd1587121dd27bad5522adf550bfdccd117538ea3d01f105aa78dbc50965c5ec5d5641943ef62e0da99f74cb2e0e460056bcb001c33ddccde9ed19fb45ff3fd1640c587fc5df810725eed4b62f7ab793dd757e4a9e95d25b30d2a322e5dc939a19169b9c96518005a86b67cf8265f07c79c6fa3e2b896f3b03b004d2356b0f965a116fa3006abd03cd9cd2dca61660582d4c31564e465ab985ead78b0f58e65598e16dc00f33a65c3b4c3f0da76eea043ed39515b8d6841538ef5cd809eaba1da5f2d46e2eca8f4e9c876a6d0cfe3a68e44e8ec61fda69f7b51702cb3a961137c2d54287d19215e802c6f9d5c57e2d5ece7778ec1e6a3dfbd47fa8c24eab7580242df9738b0899c64b9ccdba0216ccfad83b8fd2b0db5c70d9cefdca6d6104e1d1cd8228cf64c6673eb29028c94ff4446ea3cb9d6bf47eeb2d667a943cb588e793b081c3072af72afebd7a95548dfb9351e3343a00ba599998b4ec7242d33fbb9b490b743dadc3bffed7525b374dce755618ac98a974e95b4e22c1cf1bfa5b8149812283df25f1afc0393d6e41b64eaa82f0aa237cd3328b6a07745b2df407e16bf37fc65dfa5ba4096b68e371dfd0f8b2e705ad7936e110789f1d8767a926cd96f1ef7ebdd4d0798e304d6f4686e998d4eb32f838db5c2b3874da424ccf11036e5f1d5f00511a6ac6e2f01d5f453f2cb6ba7e141eca66f2581678c4c0801e711ee5ee750503f20a996f029d570e395294ef69ae4d316cc90fab90cd514c3ae7d1a310dcbcc2e6404645aff7e63f82298a0a421d77b3f271a51d509dc55db7b181d31a768b3739e472a45f99bd186bc64f16af48dff07d580f5acdae5b8916f4ff35f3001f0383f691f1b7e81c3c019af67f84bb5182b2f3e1b7edf0d338039b469fc6306cef7a02a2e88ef962aa19fe5f8728ff6d97131229f2e56f8a59553e40249af71e66df5b5d5c73f0caf608098a49591901e5e570f5c9987416ed0096577cd180cb8d97074f8bfeaf4dc963d2b3f4f6bc2891831c446a09998bcf10537851815158ba964906967e102c004809e63b29f0996ec6da4a03fb020ec54f7c566ff44a2cde500847e159e30d02e81e44eb2052fe4abe193750ea7e4b49f4f05e9d0601403e79e9be9769540b23702747b07829cd24eebf29a06bf908c0c7b59026f2b5257ad79a4f695fe28b83e466ee7498c4cb95b223b7158f7bfdea412d0e74858e57cdab2baa538e0d25556f859fab2e0a236aa4d5e240be202b3498041429f25ef96b388415eec0622d26aa5244e3923e714d0365925383577d392f9c0d68574e4adec575ecddccc90676104e0f2081cfad9f16c26406104cf294b21ce96c3d19f2a43ee020e8907daef4dba92750dc28672a03c5d19d92e0eee153ee4358c30db91dc94a1e28d569916e432f303943dd507157ce29ea0c07e872bd8cfc7e0355ad51e84bad9672725b1bd6fff2bd10297e2151514d9731c94d50c35c0f7d7ad18ace1bd753a3fa9606db99ec60cd25c4ca15d3c69730bec6ea0fd2863eb9da6824cacda2b461e7b4a7e1c2fd937912854ee55358f61e421c8bcc5153a8b9859393595c9cec5db2aaa6c08476fe975f350a080a07db93b9101a5ff60bd84b750549744286594aaf6b72496191d705027ee5836f1e64ba20720cbfa12a295584572ff62f51a89212e04e8c29bb245639dee573835c59822ee55ccd8bb45a252349ca84f03d03efdb60e6f7b345bd533da05c532614cd358e0474441e9565f97bd0f741f602a2da85c57ab276b21ce72321a676aa85d592fb9d7a15d453e15a8e6f8c1ff2adaba9643d5f8e52b8e1558d8f9d8366161d7327a8619e9648c3aae1eb9b3fc2a25163f2e997a16b6b207137cfa1ae16cc0905871c992df6c1526abe72186971eb83723f32b2836f069c56042a9029f04bd5311abd08e4f2bc7813dc46a3e6d546de003a2917323fab94a4a3e44b9e1f1235586ee16cbf18a3840a99faf25da19a61cc5799a51aaa7fa3384f86fc2f9e211a1942b386009ba9fa519629f69f58e5636248473ee06971aa7200600bbe2ddaf47fe0c34f79241d6b4802dacba29243a24cd7f2a624b735937a8002470612c8330540abf5edb091ce20dd2aca6ed710a9e7774a5b73155655441a89108c616803d71b9fcd99a810b36de62c66172e3917e128ce3c1c19394ab07bc93e2459b69c6450fa1f30b33b59f5e01f3dc1815ecc8fb89dc0c9ea1245bd5fca41e99045a894f37b5b2f5353e0a360c7be312a6c2aeb87dc3118ddb7f20a26c065a061985b4a03a629fe4881c45757e6cec7c2155a5ab6b97a084620776d6b43ec566469fd9356451916b8e13ff8ae688c34c9b1997a5f41006a31f1f3d5c5c5efda48b1caed76451384c71726b88eec7e88fd4767e8728b918421f6cf2e79a4abd76ab4df5023d9923fa19e481b971f074d2838b9c167c00dd7fd4e6e30448d27e1582ed8ff2f18d3ff63e9d8eb0ba450896bed090df155852fe81df991abbc640155d9764ce1cfe25a875477e273b6736f5bf01f6b0fd75a3ca6e56350250aa1024b06645a898a183adb95fe04ce9cd242d9591fb8d97492893b6ec41bc0fbcadf59140177324e4534ef9b802f162570d565970aa4c1d176424796d8af322f8e49918991a1da88b381fafd3a77761bb44caf9946426f97ea1768881bb8d79613c50c520f38cdd4d9661115f8d60b77fe95bb35003057c5db73f229680b657e509ec60a3eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
