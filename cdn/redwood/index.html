<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47c6c02bfab4c4c3a2d226fe0f10c96947de144256d926dcb7600fa517f1312d51276fff6bf5446a4229338f7678bb9304c1e48e92e5d640cbaaea8a2a322139402c4ddf27809c1cb6602287ae803b3d5908e681c8c5b292221a8bedde4ec13e654900e5b822c685c56bcbf9130150689d580d6ebde50deec6694be06ca9017ff45b6904f310c0ca3eae97bc59d785e47aaf3d3721e68ffe8baeda9425b05428337089c65449bcf06c37c5a31108909a7a9207dc0033147ae3235b08ca164a296c9c6fa1442e99a01abc5144c5e4c76a6f103b6d046ca66c3259b920d3dab8995ad397706798c0dc00c032b82f73a61404fe944348fb8567995ecd6aedb7a864c6a9d59dc6458f5bcc8999d6f1ec042fb46ffdac950ee835852a4f78cfbd48f41a5b71b1774b7694f2929268d1366226f4c1d357622735dd6ddb7f3c5b138222e77d2eb9039cea38361a532373f912ace3dbffef8eeacce3b64fca9d56e5242a94c94ee827efb2f526417bac35d35213562e43e6a3695256ecb2709cd588b22602e3bbe3a0a59807fbe2a4307b3b619f0b0328180dc294851d2792d0deb0bab851f0328c46362bab98f3e8279880ac148c4a90c5dc5edabe90aab9a77c9672c4ff58d36ca4448163bc6cc2f1ae40856227f4ab13b9330785af841610a93d5897cfd1ee93e8a8ec93a2bd9a0913de244e8fcf03d29d067b4360a72b0cb91e5efe4f2407542060343c49de56554d4295120ccacf4f930df6120de053a95ebeb09b3c8e61a9240f1df286edcac608492d890c0537ac5c92f3a150a9326b08e71a8f7a1c99893422c865843db77c79facd3098dca8fa55f8b4809ee25db690213215057258deb68168b2a2ad72801dfa35c863ada87fa1c16c406c0d9144661768d68c546e0bbb1f7c870aeb02ff140d5b1bf79972bbe1860d5e3766d3f97662ec474a6a502c250c037f0d52c9f63ac24dcc72aa75b61ba4bb78600b8b638d444e2cb0003f32ec386a994aca47302d01805a8ed768abcb4d1c773602569d85586984161dba6d20dddfdf30dec7d49d30fb1a009b7d929e0e754088bf15b9bd08e1812fa1e6724c038274688c7891a306af906e66bbb8f2327b28acc2066d25fa8fd31ebcf3c42b2efa47c8a9c007b58147ec59c89278008fe1ce549fa5c180f026f0bb99c8f786a0748032afce46a624a9c3cd02a736abb1498bbbbcbc152440d24b75f78effa8dd895567d1f1a15f8137baae0e531377a0cbe94f2fe6035416b73b3727b120963777f3f64524559f34fd8f6d7e40baf919c56c1e3f1ed805807788541f34c2207b8413ef49ebc0229b1935fd0e1fa7b2da237a4aec1d980a42057b8e831af7bb323bc48ecffe47ce4ba3957ff69b7ae768481f509384e9a55055840525edb985b8d33c8b24fd60e073206b1c8d0f23f3f6557e1fbda0354ae4c19eb61e895931e7f67f596af0eee50bba09a1f918d060c9414b3ad2e54d2904603a5ed839c098e10e9c3a16ee2afbbb68f7b5612fdff4b322285185b6a73adec7d04a815993a54cb0efc4b78f577f8493e4ef56d56ec72c8ed6bf61184d4537d4c93f1692b903e793b70e79700a79e3dd10339e00dcea99a4802d20b4c3c77277a753daf0bf372d1de1b01970a1d2ab942cea0eff3087d3958ae084b95f6096df3b21a46eb5bf56a71033dc580bd4a7ae860d2a65dbd85780ec2ba914a9d5a5f1e96a10d27a8b09f6b352da057cba75fee9f5ffedc8bbfd897db2d5479647a03a590a311bebc4b5aa7fcde55c8a7170feb0bf900bc5456fcc4c924ddee0ce2e719e7d25b4319a2d6ff6d3fda3cc707ed5ec98768eb30a0075cff8084d81bcf6a4476e74f94a711b417242be11821adbd9cc6708e21fbe3e522a89dabbb9e5a01ece9d49e60108bc14b7b9952ed399267b9b4442b4fe1d9a675dfe56d313aaf7e860e98224a2033fbe6f3af9c97a6307a96c7934ba63ade204fec7c3aebf66f3de3d00f805f009df926d4fe3fbce752f46b9ce882e7ac19cc0ed3a99fcd835afeaa72079d1fba893fb4a636a877fc9759830a0d94499414a9170c38b11596997fe61d4d096105fd902e2e2e0e067de37a67f8d86d090855235e6709a1c4e0d4258ca12214d3fbbcbbd9036d72e0ca025875c05f7d257306dfa36c3020be9a87e0020a973490dd4b17cb4625ef3dcaec4a163301ecbd72a20ebe48bb7f58300e5b9215a6c55a4166c4bfdc7269357a24c4349c22d9be03e9620dbba90e8ef217f6cc9bb6d10a2cef4a4e85f2b95cc0954ac87acb7b7df20b7f2d97a97e2bf9bc3b3327ce02c41fa5669f340172f71c50cd5261e8013ad074a42b541ae63ace2e90861a70265d1a9c601528f6377d38fe974688fe7cc64311cc65a4443f3625318feb481a0efc884843ee0a46214da0f781c373b783d4c597fd822941735d5bbfe24b07177848e05dec848e93b1e5c8454ca7cddaa490104b8d9e94351c1d898535dbe262d6bbfbffa2046775f875a94a2b4beb449ca50d6287b55fd17649b491de81023751635561d3bd34aba76801058e20d3bc7bdf8d9bd2bf407c2fab658d1ccc2031494fe171ab3962eaff76a6f715f532caf3081e72229d6d030fcf82c30db14b3e4150c62eb06c63f56cb0c2faf235d52ab6591cff2f311c3eb253f52dc97ffdbea976a2634fed0520e62c05895d65207a740ca549714fbe604c031edc5ab94fb43b08e88363eb227dd865e44cd1fec7275c4acb29d6b4a88212d21a57baea28297aeac8f068638658e545a47d494b552a476dbbe1aa81965c85b2ecd8ffd1b2f76e1483e3d10adda0ae1ca0ed1a90158d630d745f6b5b7b91e7ccb1aaa53798b488ab54d8b281c86c184e5ef7d5b727af3cf69859620ad61b09e757c243d7baea9548570f3d91616a46f0d83db750f8df524eff98d0888af9cde8ea7699664518b0b55ed22622d42ef40faa797421bb60fcceaa1212759dae2578ca25aadbec55ae9ec58f043d73a9d92471e4beaa247ec915b20a6e7031ba2131d7b88930b4a1b8ebb00718e216bd3f2ab3b7ce1242f696d0d3d494d396e5071ddbbf9277590e5b1a2e636189d4158f3600dddf23d3cfc3c0d3a76a5fab9baf50574ad61079438d654cb74eeb0778b876ecdad93891bd72592b6f4b9c370af8bf20a32d6f0478292d63d6d44fdc5953fb21afac97d80c5b8f414c769b5546a146555a83d639b1bdf9f594737103671052cd636926b6aa3dc90239719cd4d2dd02966d9ec5550a086eeac662a5e9725c4a5857a2b8be8bc22df4d054e77cd549b04de90c9d8441f33040c4ea3442019e2a4bb7d2a4ffa3eceb14487b9c02b2a623f8fb1fbed7cb2cd300bc6a0348c9698c1491375291464f619fb8cfb30dec1edc86d80b707a129852c7d5a4164da333ccababb7ce7db13ac5e5807f50ac9a9438eb2b46ed33a10db6802f3d31981603123a943da8315c6f2628331801c207f58e37dc0684d71125cc74aed506bc2147931c6c5d7a68834539ec337d43f27033c8bbb368fbc53c8a5aedf7bbbc76515d31859a4ccea757951261c9b7f472a2625ee9304291bfad1ed7a84a32d36a28a5899c432a6293681ca567d2b19179d0576f0cf8cf545177f1dbdd81fc0015c52e9b7643602ef5199efc1c7bcae0f23c683e0b391e2cab6ed80c58660b3020cc90ebcb6659a55e01f8abd4bca876c92eb603c82e36e32ccf882aff827fe33ff9998b1e5b2c74108138c0c77b289703a8a7fadc07f4afe10d217a0ace497a972fc8e84b8dc380c58eb2f81b5f5d18741e716fae4ec9db5959e77a68cadae2503cb9068f36ae6ba52647621df660385e480937f16674fb06232b14bc69fc69d82d3be1deea60b342d6862af1b9ddaad9303c5d3bc1e373d7962e367210dc9e9d751b3b771a646d5e41836766c260588473d5f88ae5b64174d544e27043d1eb4164766ee4b805e343eb7dffa252ff59f5acda6c075621c43d46fb3124cb7c1b2f6cd76b5127ab3917726981fcd761d63877d294bb196aa6949a28809ff4e5581a1fcc34a306d05b95902d7d44334d8b3cf927af5be07e7ad28e1fe67bc5e5dd05b5f14f7c7010512ea67a4441192af957887c8ece055d58e5cf3dd070895d3a09759aff67130d593e7665a35d5ded9ce99defb27cdb0016f913081d22623b41b19edb6884a23a63c76990ae4fde00629e35d58794ebd9f40232c612bd4b3711c5b8b6a87e84d2a043e377ac8f67fb3416820791fc34aeb80c0f16d9b7247ecf89a29de10b2ee5de891134bd364f09dfb85c8bc30c987098ee465666d122677c5350f355be6a359443c9b9cafa6a2f1804a2ceeee12c8b95cfc9cead359400f7956a6fb9537b58fe9b07248e75f5c146c303c92ba12e9997a85b1c3d9d6c07e4610d0bc2270e6238d95f36f2d1489cfc55fd6beb2bcb549277c7b9cc98a50ad02e08ddd4e9fc346d1bf7bace394e229f711f75c890c8487ad3cbbeaf24ada1312af2991d867da68f5a1c77233eed948a2742c4b34df0b860854375f935b68cbda8e14337fdc83ca5e0ccc311475ee96fa03ae7de16dacd34de9f71f4ceb7678f4675073636fcaed18782353659bcf11fd44099520d90623847c27f4f8c0caca00ed46dad8e737d75da2703be7ecae9ddaf3c6aa82fc671857a09a56503db51396e3f4d4ab9930ec284add474cc1ddbb555c1f6a555ca8b366781d12b3bd5e43f86f5f18a7cd574f63bb70a80b0034417cc84e708763a7691546f89bf6d4632d1855815f374d0f917c79c4d611d67c11ff1fe59269dfa63df6600cd517a02b54814329d63d373d92af4c9d525e68efd0e397ec0b180f374a07f9cb3dbb529253cb3d641464e3385b9192f8210cb2fca76ff8c68f11e5b7014467d305c5398cf16bff37a2690d5dbc46037c323a1f007bd13355f11770679fbb4b2780c7618e4302ef84d1ba4cf74163980ed44b81a287bd914b4c4e4c300d862a3126e5fc553428b8c3951cb851acdad783f514dbe4592b0ac0ce0f33e23216e7301aa6a13ef027e65060834153aaa85190e6b24a402695ab8ff69f7dad3aac2f338122b428b71247ab55d2713d9af120674856972ae144d15369c6990a06994caf46afb7f87d2f1b3bb7dce4415a4d517d43a11a96c70affcfa4c4ba74d4431626036b08c2c62680bc7e045ce3790a7e16ca5487a02129f2bf5581f539439e614abd380732f3e985f70c70ee502553e36998f02401d43093262f60a147ad0ce0b140d75b09b40e06a5a2ab8a434228261e99cf5fe3508b0958ea1ad5f938482f9aa11327f37a66259ff24736f11dac1704f74a33c0b1a941775bd4f672f6c0f5270803c1df2fc54e06c2c9e809cbc2f737343262788d03f5c034d48d24cb47218f4f2976621df58021f4575acf674fab2cd4e40332ca1122f96561ea122d9d5f1dd4ffb8bea1e2f1d201a3c563d8fcd55449a7ec70412024e52951dd83896695ce561c17f6ccdd3a9035945908217a7fa680173845973f5f1b8412c15890001ff29e14381c80c1ec658433611ac5223c73095c74e684a740e285287c21038b8dd562b33ae8db8d6200be765dac41de2503dba6fd5e96c83985f486ce60db0e9c44b068b021510ea4d93fc37fb559640b390290656867d0882e303e8823ca96db833a3a04c1256a91dbda2f719ea1f676e5fb376a9674c2e7c7e0d024389ec54520ed87b94b133f4f72406b74679d6ad6368d94f8258c8c9bd99943cdcb325b569ef59f0559c5eff3b6244ebcd924c45d51a0ee4a1e8b0d1e025ea1f9f78b1f5efc42bcdde03ccf59d4d0b97fd9e93d85afe1a7578e442159580690ff67a6ac78b3885b56b414333a39c38a19a2f664a375708211ac0fd7896b70865400e01d2f23f801b702b74bf9a4c71510036aadd48c8d3e1ef36c65d32afee5baa4d6f1ca763d04cd653c8af90c2913b47b3daf5fb061410e1e6cf3ec07aa28472a6179ed3406342e8a8048363137f5bf6e8f92577f866e6d3c04105a19b79999c9451354158889d9f2c44fa4aad3dd8e71b36992fae5ffcca5be26017b35d5991c7e42a10b59549b4b2dcdec8e935a2ac55ac1bba6e7e602fd64bb9ea039b897c66aa5ed50e900b980065a1c33edc4d6682b3ec90ee90eb1e36525c24512bcdb952d93d32973e2311f8988c1f35b1a72c5e02a58a360e0769a7b3ba0f79eb6303100548203b30d21ba4a9f1789bee5c4cdd7731277c4f4ab8e2604be9f0461a638734aacff5ad399b31bc3616d10136b584e77462f59183edf8d7c01370901bc0440e4980407596d7e817d06d2618a69047e3d1ea99c02ac517f469a0a4676d1010204893d3c7dde4ca99b0b2f9317502bc62ba45cd335a2fbafd9beafcdfb95a2572b6224912f7405f56c1257847c20e23f55a2cc8dba1c2119a07f533e49ca6fee5c7a778d50c8aa8c7f9389b46ce5596a621c7004a97e355a159a47768a7f2d9457ba2fba9d0a131656daab3def3144427dd208179e4221945764d96395604532d598533b1dd21e286dc9c386eb10792aa9ac1f5e7f80c36ba4961bc7e3c0ed747e3f5b5e4d055883b913953407f7795e4fa7f84faf46d0e58745726d35ab74c40a30596db879d93aa4376600f8c86eb0fae259947294bc2748ce61794ea745b3def5aceec59c6c9c42a193c41d4da8c262d0df8414ce5944d42f9eb196077085cf59d808130142c11d683d9cbc8f36f4d3c8affdd5dd22773120a51b6efb83a8158fee9c9bdead17afcad9e387f211f75cc97a2f8364b1e39ed2d960b019d2c966ec139b908a1faebaca8d367d8b3c449d21e7ccc49601c88c1d87e7c1171fd8ac8bdda9aa1f8a185344710083b79c96cfbf285022cc9920cc8ce08ce68a2aef54f124b2e2afb001997a7f27ae5dfd8f869a9f0c7ef1e0c0702a76fc54267a8248f094d07c900b7a718c6a92497831931f9f683a09b6b23138d52322a18f2f9a8e49343c44bcd07b9a778816b8e9b6417e9e1ce6c586a4c33e127fe0cd57e436afa61948e5acf220b3c19116bb122451631e7304225300f76b1a31920056ec5e69499a6190639dd47da019dbad88fe640fe01302ff3a60bbcbe663ed7227ad29150889ac55900a7dd13f18679896722e35b02478facc62b9f44d230618bd14c0b0a8df65678a6decd56af4a1f23a9fb2a971af1eb6ca92c7236b9219a5bf177bf689f2bc23ec3395c833efa7939de75b2085d926a0554dba813dab003688ef535fee212f0376afd6c05a3fea42f5b8e09bf05ca6741d658192db0d85cc546d4f070f42a3cacf0f8f280cee3799df03d78ad766a3879e2fceb5ace1b0d7d74fb53969fe9e20cf0ca9c42a9af583ad1080380fef99b3245d9eeffd3f976d3ad22247b207d49ab72120071fef7d2069a5ccd90c7313f38b02e82dd5cc1fc09a0d0f8f90b8ea56778ebba56b2f21746d2c9c1cce7c90dce8c3b2e2a8e3c67966925e9773b17f7a2e16e649ce5e0e73cbc90ae41acbdaf95bb2b44e03139bb16884466e76a99896dce0ccb56d54010e3b248f05097eca981bd1fa529e40d1c3e54ac02afb3646a0476c60bd399f2faee816961bf8862c557bda619c5d3c1d2965d897718bbc17ab5a61e37dc9f39dbb0c99fc4d05b91f819b0b89f3836521ba989a4c44b471e0ec0b1a0fca0c6f500d58beb9c285af8dde7698d28cb7007c824df4cceba41a05ea7c19db62223ddccdf91b88525cc6f92a1b07d0f86c58f268537683f01ee6eabb998b7579a3a80fc714c6f5fe122ea4786125430857b6af65979db6795a87b91d78e8617e1c0636935651cc3926b6c60a94219391eeb531765a0ab50f8c8a54b35db6e8fa62cd49b6de2335526769a8f36f08854544798a6e32ded350cd455e472a81e7451d9c14f58bb365d38e84ea8b8478a359686b694c5d26ba62ce67d8ac885d54674218bac7ce5b6f85fffa51edc7a0c9e8481cd1caed5af8621047fdf2144c2c71be5d4cb786eda70c8279028deec03eef9d673effe51ecef5c0e7bb4eb14b60277c0b4018c34e9ec9c3e3897cb5bc85bb3d3b1c2b3eeeee851310f0bcf39b95346233bfcd0ef0f76eb4d638ff1b3d4ef830a61a1b7e96ad26824f69cfb9d485df189e0b84fb1a2f9a3141530402c6aae8a18b05a092b981199a992772d985354855c6194e699279a8ae2fd056bb559a2657a74200d13e91b82f4214b8446eebc2a8b9ddf51310d1bf96a2a1c8d733cbc08d16c1d6bd28a5ae38061466f6d9606b2e14243bca650d86bb3a310389158b345ccdb29379969ebc1743c9501ac8cb4fa9f3bbdfde11e15f0267bc0249cdd86e032639fd4b96d82f6ff5404f755d7798f1b39ea69dafd8c85f743d314b663dce182fead9599e99d1073f37b882d7999461dd62d75295cbbd9a00be7dfc705a1f655ea23a048b46ef236e73573c8c060bcd0ce18ce17a733f40c81110d1a0ae4a939965ac2324985bc030019797e57f58a235b53de30d8e11a4ca2533a962946e502026612ab0be974cd421a9db2e980ae79eb7a60cf630badb8a7d79af8d5d672cc780351113348d34bbf1a304125b3513054a387c35b04253e00cf4a949700cbac254d414e02d78f2c3e5b9d200090cfd018cf270d930bf6a5bc1cda0ec74396f4f98b0dec37c08e180edaa880c97dd03a0d38d7f24976d8fdb31879157ae2785ab80fa4be9458a9ae99d477e1c209f76f303445d428c7a27040b761ffffbd2aae64aa7d943b549f008bcf47782fc575999ad7914e54361e2802efff386dc1769115fca80c38e8f4a54bd0ca1e42c1e91def67c615db5d06655f3e01a407975a415692560a0652a64975f0abfa3d48486b61a88f8a192014f03984a185ae7722599d75438f1ccc76f83515f877569b75a856ff220986872d5547b4fd9800b6334714a107dad0afd8cf80bb392a88cadd67a7b082d4c1c6af37b06ed6f7265b881df3bd8041f98b8aa3bfc0cc4c2840951696330e523cd07bb08d76cfd41d3c08946eb154cd6b5276dd48d36cefdbcd8497e42a6b649cc3b13da07c8e2e6ffa80f7c6c8c787dd4b590c651d0b114bd4e3b04ecd8f2e71f351ae47d9381b4b873839cfe0d4d0a6f26d6f0cf91d7e9ffdd1808ec9370edff0422d570f359892128f6e5d0d92393e1933cbee8356fa558bd3482c50d5d64b10ff377432b196d642494cdd79a416556ce191c631f797da6612444917f5c97fa3f39914188eea303c99d9c2c3e4d2e90275e07d1dba0ef7ddf9f26f28e9e896aba7cca0fd16f9779cdb5785992a48c78f98393cf4fbb0af6e6fb44262c8161b546cb775f63dfed31fcb752054da424dbc2208f7dcc662043a8b6ba612d6d8d4ac950dc2fd1dbce3c35bdb17acabb03d19c4142ce6d933a82761885b07e56daf551a19810efb581f5f72ff2e0e6857693f9c6f70dacac1689bbeeff8d346e2ff3d9c3f24efbc4eddc15c4a1ac8ad9924f670ee68f428efd48d2d8d4af82e64df3ae4ba0e139fc4270a7d748774a03f0639f10aff427d58f6f373dc9e05185d5114b8988b7187d9c6c6339db916b4d2739ff2ddb774e03950ea99eb6d05d4cfd07379d92e34f829f126cdd7a3b9ac83cf1dbfd1213046b5f72a42c165d87d1e1dc7e32f92f1db81d1b9b1a3ca5d410f446895336c19314907158f102dd4ee210c23b09a9de3743da289869b124f089b1922df839593712c5944877df2f4779a1f72d9539498fdfbd04cd8e2b82c55c867ca736436d504e1e4f7e1ebd2a0e8581e5db025844359e65f533c454ce2c203e1fdae6bb23311aef1bc3f43e63ddef9b729be27cb9c32e927737be69f9738661dd5b85cc4ac0734ed22b8fba7a9e7b4fbed1108e8faa1bb7f68f14686c943c8734a23d85d91d2bc10cbdfa2e4efdcca2fd34a7f3ea5955c8e5c170f47fb68ee81ce749d3be6200736f9f32718f1a566801d13387307d1b635291a2d1f6bf77644ba6bb3bbe08035ecb06547b170d0f176b6935240133cc04f4e890a10e13c22cce5acb40656bcf9ac554442bcc56254bc14c25026dee5c0b389d8d974d10813bce23c92ccd9a5cac9fc8c5376d9093e3e8d2e010febbf0cd5184514bc30c825c20d36f953d9b0c698a41bfb9ef0442676e7a873bd92c474c60a96219ff4b36734cb64b8dffb6020ee1cab4b9ea0b42f568035e1d22ff932c0226a18d6738998983a0905c19daa16db5b0f10166551275e805e64bb531fce10e035c5a200de02678fcf270be526b8366809532185d764fc05522cc0b760648a826cea8ae3af96425bb29f57fb583f0c7bb79324a479a97897e6d952a593d20583c702de525b4ea173f9e198d85ed933c5d17522c053fe6fe0f272baa4d65d21941ca0cd192533bc88008dd18a6a6a10ef1625a9fedb4a2e8c78d75b550596c80ac26f0294334d069e302997f6fea944beecb12c6713fc90ecc854afe0df78f0217fe0d54fa6bbbfb5ced8dc96205bc60cb9e99ed09f82883e194b437e6274ee65657e85b4f678f389722769b8246e5beee78ec24f16dfeeba790c3ec865a3dcf19a8e9c33ae6402a8589179d76f872bd9d7828a0734c020ec0b8c9be8aa9cb8c9edd8d65251c49b0d6af7f2aca9f9a0f008f061efd766d79bd6b066fd2ab2fa93de9ef73969c8207b4b417eb15fcfb169ff313f3ff0742a527731c3a0e5f695bc7d28cd9e49e3061fb72352f333457990a2e8bb41c8bbf5d495cb39974bea21f6f76a1c16a6d902952134382289fd6f7d6920d3147b04f6bfdefd622a4e52644bea4af0409aaf6596d0356c59596048a8d028345a6984c0b5458e536aba913c1767f0260a152fddb06308af10dcc75c49d6c9231a88448e8d49622f1b9d86793a28276abb7f9e877f27a23bf599ead9278481160cc46bb8475aeaae55989b68ec70da6cb9edff4835980c3b8bb1d4c8246781950268a9e3c0a06fa693b5be938c925f65142737ecf7d9909a2e1fa88e662fe9d2bf09a5b0b5054fb07d6ff3dd7655f9aa4ad3da1223e4f0f6b50b528eb605b307f4825ef990292b16d3a16d29499d9049973d7f43b7f1d3132c83ceee9aa4dbbb1d6ff793f3dec1baa2faedbea70ebe96a92bf6c01061bcde9b8cb5af63d6f17bd16e2343de6b0fdd4ce93ff44f90b52012cde2e4887003f34525eefc89ef6476b3cd271e4e6bfe121472373cc10f7f2ffbf4ca40c943fcadbdbf8cabd6fcd9d0dd972548408ef11eca439272278ff2e41c39207eda31a63850ff4d913537c3ee18258670ff49507930da3044bda9036c5ce1828b1c42f6cbac282599790e14b8033f882d93a185e07988355166ff56b42e31359f1d862f92c769ab37cb708c3426fe894ba0239560fe2da5c673c973b7cd87adf1d093ee7f814042d9ebf4a912bcf05dc1a425ffb3dd51e6faef0536b55de5467c0796bb4dfb0431ebe16a0b084ee35fd0b35d507a9f8f05270cf37a7abd68edf9d05dd2f32c6c8518ada6cca631573debffb8f1b263cb187dd114e025edb657a17429d7f2f469acef4da5001db16e0c9df322331895c92bbe44db6ef48ec11fb5a9ca8087b13fb19e43c33bc059702fe9c8cc7ac51482b5119993a6182e96678a4579cab018cd420c04f0a2ee3b4832683d16329a52971653d6ac88b008c1e773e552948decdf4e3f3d0ffebd474b7f5ccbd830adf65b295c4764e794f71d3212907bfff92219aa531c9a8aa47c14bc58c1fb9797e9a11282c764d3a609101bd367a89905914cc1c53008d041dc56d748fb8ba1a25db93ca22d48ceadffe9bd3ca49fe7f995f40d9eefffe834e5a4d813354840a0eb312c05b5ed6e8b0059ef259a70125e821ed4bfc26e3103ea44d962884208d306fcba5b9b596ccf187b8760388fbe03937e598bf09b8edd8b71fcdca5312cb1be4d9bc6e5d1be6dabcba9dcbafabcf01c16b72e192d285057482fafd9f0755c8b697d8a9145dd2f8cf8635484aed3a29683ea71e8ea33dc7a88a81b890fbac0889a7e6c66e85407fa1452a16e9e5044ca950c7cef67d02dcb49e1e57f19974ea0271d744614094583677b3db65e34ca5b19dd3b5aafb7276f82aba7b108868d60225e59b51dfa524a44450daa688351cd543fd50af06185bc244384b2324ce1b4aca70facce9e2807bf147f07db7eff500bb9eeece022d2e4d284969c82790c54fcf56c2e376e1e64537026937c33525666463a3b1390a5516d0605d4a6717737f0d3d44198caa9e635d063d886bb6f8127bc28c83a3358f2b3a599a3e63e1b030862d3df80a7ed7d5cc730d6ef60c171aeb8ff765dfba2963bda5049afa772167b99605f6dc7fee4872b3f09999bc68728ddca32ba444678ee945b43d0760fbe3cd525e0e85bce5d800407e83a0b5ec6387a892e562f1630c42432a4fb995c71ecabadc6ff69ef9db8ca69c01969ecd175f491f855f0df42fdedae628bb294733b3623eadb9195b516dac019f3cb04cbc81cc4a9919241a143d2a69e15d29c98ffccf73ac2f76480451d698f443be8846c6a1d55a804ee60b1706c8e42f9e99c938a6cef84028892a7ab4663085bbacfbe4b7af9af3530a5f11c1e71b58c70fb40ad9674f790522cffb40ad2e891155eabc6d3e5766ef58fdff892669350e265f51d789065f87515c5c9121eab7ed508b43c05af85c7307ef2b614c8c8e5ba22369d171d8542633c67cac606fdc3246cd2ed7242091c5d779d6690a4dbc0340bc9fd70ca851cd394c544d2e49aaedb51a44feefdbe66381137dadd0c8b55531af09528b8ab1357bd3ddae7748bf92669b44c054cfc83bdad14301ea72b921b80a7eccd51c8cd23756c6174be08c5d242475ba4f9bc5c1fa61e934aaf3a7e05800932d58c6af8756e58776a59ac17c78632395c5d30f00111eaa8c4c423312ae5d271c6e6ecd01d11965e89118d01b4be11a7107a1aca71881b64e41abcc43e8eaf1d06da92e933c4b33510604a1c2c4c451e3e1b631407134fb4e8d48bf74d4c44ab8c59a1db95bd77e2dec6912d588136b84e17c948b09e69f84444629bc1b0c0bd72db16461b357d3d3e146f8d248fca25bbc26c4a8c630df601227f36ddaecc5ebaf59862fa8cd59da6a69ffa9adbf087bfddbda896bf2269f83918641cd2e7befaf574b5efdfe5c7f93ba03fbda4741b2c341bea080dd4b22bb9c2e570deaf7260249e2b37d7a582ca41367701e919ee70d4d26e3e570b0bc69de87f410d355a6b2b66318d2e20c7dfa38307d869790646804590dc6f0ca3ec972f1514f4ce8b6c501769649e108b210c2d908e247e16f5f03f0e487baa6fb76b3053639b51d02f591151b6c3872d1d46609de82ae55bfe5247c41658832652d446ceadffd3777bb2798de783ef3d91f49ac5548635f9f3855ed34005e493f928ddba12d9220ac4081619ec3e0153a2132dc2206bb8cd5a08956fd47c63815a5662f4883650733a810fadfa0fc82d31367d666016af3cac62834ca6e39d383300ef090a0dda38b97ba1cdea3e6874a53797f1fd30db49b91c68ad9aa953ed6d2357477d90bef89c25219ddc736adf275df4351a81575954b7eee230f984443ea4c515fbe462cb25226e05bd2b26ff63047bb9b5579717cc646fe57b142caf78669253a30173dc7417f6162fff327e116709d431e0442f0b0439950d35321dca6268dd06dffa072a901f80a1de9a8d367bec38cbad7bb1fc3c741b68d9898530555f3aad6dc57dce5ab17ca8b7d8c32e66c2b47a2185ab2b199e489b8c5eae7851cd8f66c5ba6abe89ac0d8cc9c599d2fe5b4c474c67e9fd4983e9bc8e021cf1f950c6f34edb433a414a24240477e18bfe457a2cb613380094ff609844c33e28e345fb0980e31ea8e3b0d2e4728c929d8c4212665425d56f3c6a3a3390702a7602727a058c3e3b4638e930e8f858e52c121ccd6e1ab0fad02a38a931959a086c424b4a6a62fc5dbc2d2c96709c5a5c4c9a77aa6ed503b4c2a45b54e37643f0ddb9ca33a75b3d8b6a7dc6c1f79d320cd6cc02ce908bbab6b22bcd4860e41627683a4257e27c2f69c5a0073af3dbc7d12ffbd25a1431a5b3382b847158d832c21c43306600c39d18eb7aea930d25fcd1ab318f0b58e89fa7790e2c1ea34a1860e73e694460372dadcacbc37bb519ae7ee7c2fe240499a79a53601f95e5b2bdd1b6fe7f3abb2048c010aa68e01205361153488a4f26186e8e59b019c3ac12264054220a0f89a53f5fab1d7444d61dbce212f482948fa712fa2aef0c0de5ef42a582aecbe058ee1252092a0b4a274162c6482d31dadd69a54e61591507439ae1d66f8ac3bc9a2e7228936af74c8269b26f6d62d3038f91f213c0a1ca88a68df89dfd49fe9175ba969925440ce54469120b375930a39f6f592fdc4ac7176340def6d7ad003820507541e3dab3fcd1688ddd269a4319b4f4d221f908f3e9d485ad08742ec6e8c5e1f043570863b0d281b6d5d5c10855131e3293b87ac0b05441fee515f508645228c5bd297518695e61a758b20a04e330c65c2a2961b1a68892dce2c6434bcbf3bd31edeb9bbb2a3da07ed7b30eb08c2e30f4b89be2491ed5f1e5936510dc354f251d82e2d5829e337fa8f5b5cb51c3b8879fed8a3bf120768187f939323717b823dd2e04039f3e45f43823e90a63781e35d74c0193a54fcc486abf0a2d83b1a31758851d22686d9e87b01f487d164e0f622543381909330af4ce032f89d06812a0802c4721670319ab502fb8a9112296feba8309a13d9dd4dd71896039438166e4ff5db01d3f574dfc2875e7d4858c46ee9fcbafaaa78e9ed6ea22182e93d982689c6a5bf42e805f53b7223b8871aacd506fab8be89caff7f111338f3a4b415134e2765adc4a29a4461698dff54b5c9750e4c233b02206e0c7d941d1b4c0d407ab29fde8752e984d1e6c5da8e7395baa70ccc41b767de4f510c4025284734820c0cc0e892469597414e6bda297f30daebba9d1449230eca4391b3cf18a3c8e49b3efba3cc82fb4a00c1f4fded58967fb987e247b258ddf122f981ca4b38b9e4f9f6e893f61a699253273c189b9babed8c2a1a6ee5c15aeab81dc7427384e31c18db845c86599348c9ebcdda2f8b50a9f913b16aff4aacddefbb3d217678442dc43394285e82c5d3aa2be7c724738368b04887e236753fc7d72c471b04c0dd1d25d06b12b5c5cf6fdbf00859c8c9403c69c2bfd340747f26df9a96f5b65f4aed5c70a86828274adc881f416bf0501c312d1133ea3e15bf479437a158d0555d2ca47c6865b849385be2c0b37f5d909e8231f6db7bbc7158eef5836c8ff87b63ead9f281e0afac9a34c6145a90ba2f73c48a87393b73cc16c48a39c0232de343942e11add781b9e780d52301053cff9b21a02c099224e8754137e4750ddce76abd5abd571a765490ab435688d10f226894ebcb0d251346f3b31fa63e3e0ae4aa1d3be7db18121db7b61fe3aa5c45a8eb9c6e7745037f7af953cdc4517b2807171986767e622beac2b18a44b04e29f83337a4c4f64f5b11e283c5382d39ca7c4dbfafaef207d5d4fd2b55e2a482927f6c3e340a6f7fe2ced114482b8dfe73ffe401b28f957a77aba10052b9b2fee87b4028ca19efb19babe44119eb9d1d652b308b6fd3f5a5ba3b825027bee01358aa6a3e987ab8c6582b3f3573cf050fa806641cc083c1540262b1abcbd47d02e4a6e180b8c6e36c3aef5c0c3045efdfdedd18a30ead75a142fe42815a8e01996f87e338fe8a41d492e6decb52cc863fc1cd955192e5a8007fb5f4f5e18700d6aad25c2f6759441e3f3da3952ee23cc56662928c7958bd8fc4363d8e373c1095206959bf6a359e6039fbd01036d3aa4f1377a698a029d7bc4981732502812b3a1e97dd7fac222c7f4ce5377dff3b9ef1181d934ba08fa12a01f0cb9ce7bb03288f7a18f3db017f6ad639812d474c517442a1f5172c20551d63e4870c2853a2c000e1d24d2ce4c6ac28e1781cdd7233d77d9c65edbd5cd1dd7bbf757ffd9924392cb93b8a03a8974fc3d8de22dc0cf24d5e84a07049c8cb568efb7e477dd89602e1d07c8bc5003d67d77783fa53a4495ace7871a994ca7f958eca7419cf9db52b96f0480f8359b10ac2c5c7469e2705af16add0a6e27c34088cd7922383edc2b3218ba2ea9ce175b098d529b229d8c22a1c081940bdd481a212be9ed297dbcba6c6dd45d3982288e0533ea6cf3ba26bda5bf8a4cf7f9dd959383b350c49fd3dfb55f3ee5575ac2866259eb629aecd5b54cb0ce893b5b81c8bb5f04bca14cf42c8c6709177e448900f57aa15b203f56a654ec2e76c7cc5fe80dcd5c0cbc027fb2f4c23a6584111fd16a89638d84b582e555d6d34827c294d87223b3357cff6b46b71e1e3e4aa1c193cd3d560da5be4b65d6cdbb437feb5ba0eaec44fde6f27ebdc61be379897efaca267bf2b52fdb668b8c28cc78fd844fba03545df8c9ced54d6509d6b8465a55c776375ff38eb12e6b5c9d1587bb221575888b00b83aab849cef3efe0549d3417d7d554b86e8ab2085693dee2b099f796259d1e938a833a666007af890da585e8e570565b6a344327f8e3ca080779c7341b62e61e239502be5b29dc801c6d6fac981b5c10ff9f5277d9ca77b30bcd5112769f53f33680202c2a422cdfca20e64df1d4fb488d8028745ac8155bd08e711fc08a4f8208aa924a2c5664443151695dbe7b8cfe348b781646698c7d18570be7fbb31e8a600be237092c5c85284d581825c2e61c4fdef865a8b635ee06526deea77653b46bac25eaaac1a426e8e6c885b5962e44506ae15ba591032cd2f5fd02601666f57bcc71b1ddb2e8d5221eaf9a148989ee741fb3575e9398bf2fe6a4719f3aa8071878267d81e8b98374a10dd9e47c51f966f8349f711f4189d0382e090433ef006d31af22974c9d97c411255cfa8273578d954c823289972c2d97009de189e662a281a2a37af41fb1fa85b6f3240094465fe721dcf449c732eebf964100a44a259c6a2670052776c03447a941980d95a3831fa39ea36c51c7666d3c3695082c032420c4de74a4f7e470cff4303eb5bf47b03833261ddda0919ab6464a6ac62e91b425e9cc4b2f4d42d246d708d22172b60f66e00df5c63b59592067287ef5a58e99f7665c17ff02876bd41c61f95a1864de37af555b7b11f1a43e7fef574c43d7bfa8531248467265df83978e8697cd590c065808ba96e26528889dd30bc6cd35f1b64b68ed016748ac98764ff26c6c8fd61a7625e67f87a55d7fff3a3321f02135fbe16a834a82e0e10291c49aee0a256d272516c396ff07d8131a657b96ecbfca38cddff5882b6bc5f1513743e677b7c292119ec61b29e69105915581054bcad47cc2f5cb9401eb2644761fa37046ee7fadd15a93c06f2d6f4986c5c20afc75a607ae0b904c2351e30ef6ed7309b280bcb98671e043ad9316300be866e2b364963342a36c2246909bcac035844a3692b466f5c50a870401b02e72093b345bb717086b3ef95b8ebfa17b71c25d1e5555282717e67d6d1fd266d95e43d37254596c5ddaef61198af85f2ef92f72c883f1e280304a3c3e4f13d9ebc060c503be17132ea826163d0e099b77fe01d72c75569827df4b5b5aee20a4a6c2ef8cf4487b7349aa8db35e30f99f03850d6dc9d9308cec510df084a5e677abe77b207bd849a8baa86fc7dce12eea8fdc11bf1721a2ca2259bbcb09bdc498e2c672a2777a44a17436406c432a42dd4e5fc0b9396dfc76655191006a2c441bccb54db252b701657eed397716626e7da4d4f0e9f7f074f7b8888764afa7bfaa4fa32ec32ff54cfecf2c3880465ddcdb5c8cfe5cb169f2357a7a38281bc9ba5c23ecfe72900992cd16f4c2683b4cd313e0586fe4e0d56e68fcb5d732a946425dd385217f18bcfa836ce6e361b3f8e1d2c6cfe2f8187b9c39f4c4059fd000a7351427bfd936addc8a4ebcb1abbcb62053755c389d3c2cd815aea75bde73fa19e3b23dfcb016b5281c9c479c22e8b9da84e954fbb2b6c7df51c57cf7b3f514f7dbbc527343ab924e6371c20d923697","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
