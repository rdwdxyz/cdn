<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d211861d1beb734589e4bd7ef4a11ea3d549c7a3e65e14c65338799c82867242bb6c6e1d6edcf176d9ccc03f1a724208e9bfb488445039b14a68fe9f83282a00c4504b90b1021390d73c91f0c38bd7c7918669876d48ef9a44a90206dd4f12a8b9ff39a53320b42cd48e634c626f30e19d63488dc14bcf14380f9d2297802cbe27c7b77676b339545a6645db77f41787f421bf79d58511851503ea74188a9ea1659dbdeb50aaa0f9913185ce9c7f26bf80aeac27481a97dc46555f6e0374ed46df6be054ca43d0eac8c5960b65ad8f6776b05a6dc3e25f150b650aaadfd71a7aa0b228ca700f52de807783e0c02aec5cb383dffdeaf2c6de6a78f54b80de02388b34e90b53fbe124f67adea2b0f62b1657def6f0367cbd03ad79c2eb577ef0b2dfa72d14403894c277bbae932b19683d0a79ab1b8a3291237150b05570dfb3914f960feb4a262ad23806d88ff8ba2a08a869ed823536dbc29ba285b96c5d90589e17d3cc2b84949a987a9349e57a06eda2db5e52ab040aea852b0596997adfdb235012968a6be481b7f7552bd8317fa6be51e8386d9057272e943b2e4e8096133cc068ce85491b299eb85bc8f2946352d4296104d668f58a814ce7a6b0d59d8cecb61466937216a5ac015e9aae44677a9e94ab576e3ce114640f6e8c4cc121e1c26b6098684921fd66c0142167fffe4e8dc68030104ad918357b049fcbdf4f291c4c0254ff8acec62c75e4520cb39643b50918dcd8e2de1204f502d8de8c3adb9417d96149355ba16ab642a1749e36a67c361815a7b006b04eaee77646b190d7d27d6801a12188050430fb4caca18e9c4738f6dba0d9da00b9edb5d22bb8a6689beabe47896292c0d561c76ff4bdc714a5d9dc1e6d70b3228142eb56d1ede68c49eade807f1c2fda2488f6a5b64c24c13a6c3165fd6b0de460d296ab359d1f520be96eca23d2dc508a88b5eedfa9d1f812c6b3ad89cb5af5b9bd8f072cce9d281011db1f3b43cd7d95e01c4af49289c8f99180cc9b396594a9bf35e4197be788256d5044c95a94ccd88b5a5309032142dd9162f842f3442b12e57cec1baa314350133e36c0d90eb45eca059cab569f042861deea3007a4b96559e3b903c39ada61ce6bd2e39f4a7159b505a06dc2a908e500fd425ef0de76c2a5b1971f160d09d8cd209cb2510a11e72cf3d7718012725400c7420d874fb4d336b1210a86a04843c6e1cbbc25a1d204ff1f1dacdd47e078290a5585811c5c50b1a649fc73baa3233fd312fdbcad04c6fd29abca96b6f115702e2a0b89c39853879dec3e680db6a8a621b81ba0a2773a3ab95f01b91306ccfbe6637f75a388dd017c2451f91a6a8cbc2331e84c0c427cc000aad789363f1a30e0f18f0a4c438fc13603f93c7add18c799a381008d982db0ff8c633b53094c4d568363b18024dc4fddf8cc361fdb1676ea8b1eb2ff32b3793a5553cef7af27d0db4ed90dfb7f376cec8deed6fc94c68a1faf3af60a9e7956646216a9db75e16703d6be064940801bc61eedbe923317977f95883c95faf63cb36ab3fdb093fdc6d251d83e0f609c87a4b76d1bd426f7dafa5eab14bc031c65651c072c1d76904d2e5b75943376fdca3f6c789442d44fd3fe42cb5314e3ffc3c5087b4b216a6bc48befdb4a92e7e31baae9bf8b59cf05ced7c498d78db9eba1a602cfda959a67b0e6ecf8c610949d8faf6d67918bd2d0ea7a9654446a9e4afe6aece5ba03e88ddc04d26a7c0f71b24930df0707a8594aa28a912c6efad24614495c5b92b84268b6e6b7c6d0abe8a47f693189feebb8f2c4f9d8f09bfcdf56b76730b4e96548b878519a55e321d71520c58e22203baced7c335be757d75445db69c78301ef16745512405c8198a82abf3af5ba3d51d9368c720c4c3c8eff75f3038351300cd5210c9c2ae5e5cb61b2c1c252a86ef5c10c9bfd0722694004201fe4ad5f98fba8a1d9468e2bf4dcbd422bc79036188cb8c0859e15b4daf920b268e9720be6a336aef9f577ae12d2923b8409fd1a876a6cc67a073d64fb4a6a1923abdefb1c29ea63eb66e54e69506a19729168c8667df5e8b64b97644c2b4259b6e989c91cb533223342e6a56d828f89fbfd425e07d33133e567f01238d57a5672c8df188fe199ea98c05d77736bfa050a9103453f0933aafdd0641d93c40efd54e6f5caaeb0d6d17a98586808b84433b32d8cae1eb4645b37be4b90e4b5491aeb57ac670ff8a9714427ae864f0c2787f6a564fb722edccab04407d55fdb367710999018ab8457af8ba37986c50cb11ab08711dd0aef41df9591de063d56fe99ec7696eadffe373a55b3c1c0a2a077240f7d7747f963c8875633cae311632e0fb41effd068b6c0bbf845be00d6fba7f18d38db4cc92da37c1d2959e2654b1efd32f760ba42af6193f5c30b70da0ea65391f48ba772a626b9b6b14a8938446e17fee03f622217bd4e109209a32845f2f8c85bada7398de0d6c5a6016f678d9ef32a48ab5f481969641d03f87efeb314483b1d805964deac270c974c2452e908ad5846128ee067d8d7af3fa6cef08787169678069d9fedfaa48a4df9305f4e5cfbdd51803e7f4f2c22aae9bf80a3ace499f3a8b2f59ca37b68ba6fa2cdba45ef1cf3aad62459613ec55ae03ebcb79aeb5241e9bca852a98f29e06d97bc50f9fb2b68fb26785bb6c93e7644c480a96bcd19778a31344af5208ff06bd60dda6171a3611364f3061ac583b56ad7aa7480a8e4f70de6c2e5f7ee384aead88294795607f4e0bb722a04b93fd4ad461c6032a6f3727b058c59e05deb26b86c798872c6be0aff67f0ae9b171dcc082e3694f1ca45266f54a48a4542cecd052c2b82dd3944ac5240e6e7f7013d748a0be72be6f472053cb4269112e7505864a0578af07685c326614039e26bded8a35d29128afc2e2ea54c21043f669f676ed7ed7d0649846457ecc2560d85fc03251aeda2952ce63b5b0af97e2cb9ef7f5c12f477a8adaaa10e179b30e8befcdb89d67ca60c15699d18149c40ea4689df374bec91cde6191a25e80d0dd39c2e2ff48f2eccfd7876b225de2ffa6dc57f06accbc05b99667cee7d6447b015f2c16eec5465fdc0a42d8fb8c56572449c1aa5d61916abf7510810cc5bb64c09c222f03a24ce553d72475c5fc24aadccd9873d46ea4fd96b9a8151a6796d168de51b832dcab59ed51cc92805cebeb143b09affdd43af38840a9446985290a37fb640b45d8c05ee19565ecd7f39f4a0ce9b03e641139b781003956606c9f7848fe6a9558b46d04cad1d87fd15c520e4cdda81608b85ac7f68a2170f53f2141ed221c9fc81ef4289a4e9e2820262c6684d6aa6cb64ad167026913b5af9573b49b86fc4d895743dee194cfa35e635212c6aed20ad13eb6b64ede1b0a39d79e39ecb07628a3b21636189112156e8a7f3f3e5f01e55a80959980ffb8d66e526654af1dfd84fdfeef780b26bd926c7d499c9fb94ae86e85e85ca3cac44f3279846fdee11ce2a79040bc34a755bb5a2c9552e1d62701f88e7e9747757b6db5436e9731118aeb663a296e25592c04580f07daf4984aa3879a0ffb5c1335a084d065d78e5c1d30a93699918c0d16c5fd064ccd86a8fa7b7a3bbe1ac463d6d35a6a399d360a5a01bdb0bf687283868e4a7f826ae426456deaf5eea585c330a49b56e003441e8dce90e4dcfe1d06ce1ffcf134d321f8a71642459a0fce18037a6de1ca19f2332e22d163b74cf7cfb9c5ab8ce965b2ad12774331abd45b3f7a9bb9842cff12d3211416c188d361d76a2780368e326c699201805264699ddd892ff0a738693d6823c24bc2f5f1f66f7cee55e309a89ece6dd5730ad6e951087d67653cdec52b0f76c240c495756e8279822ae173d19a3d13f826ab4bb2e48b0c07e14696f7d513cecd43f3248801b45522f00c7bf1caeaaae912a50cf2b18b09a4f66ac967c34d7acfe7464f7ffff30b39536c0cd088e4707ae5291c82e51245cb616888373d8a26685f516be69cf6c8ae2b53cbcb86e21f4570268c6969ea3f72d64d2ee704bdd4375083ca4f96466f2a774899a8a83ef8e3a9083af9702c2e8f5201f76ddf744f874efe37be699ba2a854acf33d44762c6c601ef29f27eab01e4c2059c2f1e9cfc6f0d58d3c704c7a86d6c7b5d9e48bb3d432f018ed6718744c04d828bd61c4357c906267fca9bf6ff825c7f37aab96b4b7bf6f878b319f2da06f7dd082f21a0f53f8972a15618aa0cfa6a25003df3c3300b5c285eb74f7d2eaa9a548c6d018fa26e9d5360543ce1de1839686f02c55e6129a60eaaff6b770211ebf8b09be6b95e36173aec2e829e41e62e1d84b0f6ef446aee9a9ad6371aa50bf9337d559686562305d2f7a8a557e2745e1cc87bb48efc2a613bf1adb78e4695404d582346158938cf1b9d3d0d3c2a4748c54f764cb2bfe7bd4255f8f57b3b525927b7d992feb486812ff485dddf3b4a989841368d6b38536e206148b43e6f71b6e7e80212e59da239c22e08123c1fa239cb91b6def6cb133de5153dcef68325b6b8eb83c5281df2f23c3d4c06ab73c7e5facd0a785fb99b883172b6dff85e8b3c527d77dba26e1be5257527ab03e3a0fc56828d7f2c2044da98b909293b9c2801baaaee0ef7740ca6dbfd9dbe10dc419ba2cd12bbb7b67a87abda278d7909e19eca504dd04ef53f0ce1662e04cbed9bde35c6e5bd2910fbfe2c231e5121d03e72195af28b83d23b8a0924d85eb1a2965d5be69589b117cf9e90b21fba5b998e003c9dc26f257472fdd3b72f6414131014d565b2fb5b3117340916195099542aea529de941cadd9528d15d1ce1f85697e0a02ded8bd351ca1849c5d7d6ec447881a515a99a8e8ce1d78d798b7c0037af9b5bcd13d7011d0139c39aef42c04ac3cad9846c1ef2b948b4712fc8707f65c922f2017a03d0899aefe26b174375cea74e6e2f0fab95bad962a66d13fa32d034b516999875992068e5df7287e2488c15f710d3d0931bedbd06b9d495668b0b2c3e4fcee9fb268a83a76a11360472b8175333851fff0fc98d0ef7b376c7fe2da6d10a222458a4b85d08c6f1f038e3053a66145f6238c935d3e93d620598484db92a2a3cb224ae05608286e4df56fd54b04d043be6ffc00ab3f1248ce56a07c9364bc792c99ced67aaaac9446556152bc86a7c2029c4eaae0f4807a7c6ff8cf8f685dd7170332e50a33aa2879d78c61b3f03df83fa3aceb95725e295c1c5594c11634d59801e32f82cce7738ca1e75bdf60508ac7e93cc213d947cab8722be2437e791ef0c990bb6985954e2642ce8a559a904eeed3e6f2b39bb41383748f35047b7906d8117653187684ccddae7af29e2c657f1458acf8ec46aae8f6f2c895049a562889fe58f07ba7473f8b21d9ec789850e67c0b57c1f197a277562ff64b54b5f35b8025cadb8a7816566af6d4a4c057110ec7e5af3f8898fdb529ef877907eeef11b0f141d4861a8f6cae3ff71f577ae1ca8524876a7c7c9dee2ca1558f8f1a9488e2c47de56957c4140d3adb8fe00192718b73e39478f6308099477b38921ad3e6e89fad1115aa5172eb47e666dd92afed9201604a9b21bc72a09db0be634b1de2628b9fcfd3d7f8637cb22a4d854350ab74c7413217780ecc698807858a8dae2bfc22f7a00c18829d6490c67ddb643486b030372555d3cf949cfd0c6c802875c49e088f1b981517fddf84a83034ac6996ff15e85cc48a095fa49cd842dc1b6354f16695fefcdf68e278d98601f8bdf5f4b4199c3bac1003b09deff706c55c8abbf0522982be0e0b30eb651f0419cba5d1e76ea75ac448ca40dd9f6f297681ad996e815610b4f107911aff844198c38e735f49cf4818bff19cf06c729f1428bd204754636e7f10bead0ee4f021f442fc7bcf72643601e4b7aead4ada31497f17e123e3171d08a7a8131b21ae94338331aff36b13ef753ddbf680e08211ab33f3e35e7f9ca5d6d6c5d1ffbabad4af2d517e6f080e1105cb3cf4302e8a0e33d1df82c4824268cf50209f59e7967999d7453e3c27fcce7c12b1cf4b8982cff9e127a1fbed11e1080314e0c4a08fc93966ed9cd4405c96c6d5431ecf5cf8a45b76014ff939a2a04751167265482fc43dd913204e96b5767700e3ca1a3cb1d2e5df4f902fd700b122840bf1e10f9ba27a843a7379a0985cb3cfa5363f2a7498c12f8c9aa8049af2362fe8948d6608f63db3d1d4db0b234ba7c267f69c38d4720e9bf46430eac6a65feec599fddd0bd9c89aebbb8c44e3a5a50de49bbd4c27dfd59088e2106b654651af10d563ba1972b05700a2f56cd6a80c0adfd5360ab12738a88e5c1ecb19307ed5036c070b97306ef9c130a162cb477a5522683e6a3bb8f391a869ccae9c1ce6be29febd837b06c8b0a069d1dff5751ddb210bc6ed6bf9fa983332c16f2d6de4f3c2ad1e84cb6188cc2678f9012ad1d59d709143d026006a35e3db1692affe5b527975653e2df2cfa56d2b4bdcc771a6ca1652d39c3ba879af215679a9f228cd4bba93096ffc26095abcda778c9ac9a9e32cdd3195b94fc2d8eb3c705840dac15f63a6edd288c66a068e084fb5fdb6ecc49e6814c82d0aa14abea8e37313c43859402bba1d8cbf0e5d5ad8342a4a5a300bc8ffefb1ed740ec903365520def206e89d4db23dffa5e2bd28dbf93c82aa9e0c5035431458625075edcc39a1e9aa12b2257532bf527962b31b478bb690a9ca5e831e33638cbdafb8a6a2f5742a1ad7c7c094d7c21f6b280350f58c8a1d214102e1a816aba0e42aecbcb562040c71ae7dde58d430c07755f3d291a036701ce930df483c0635e3fbb914792041a331895e20646f71752f6acdd0141a7929bac19cb4f815e64b098d8f5a0348e53490017df1cbaa78bd10f46040b3ab4b8bc056722e5d38fc346c537ab12fa893bcfc3569aab58e4b697f4eac93f7ceb90bd9e012edd7f19229686c9b78ec73126a0b1cbb8cc0ee2aae1f6b9ee3adb77e2e1ebbb232aed767cf0a5e28c669d443fda40b3586ee14425839a6d973bed78be7f219860121936b68b2a2ba2bdc5a64b6e13936a760684e487f1bec114b5a46c27b2c83bbe3789e3be3db96b83cdbf07971ff01b254c1be633cf725fcbb64fa01e6e3a32ea62bbf4281551ab235f132370c35e0f11d3706b54872fe57b7a222947bec441245b81798d804c2090d4b12ad8c5dac112859b76266aa513e97ba9927044ded33f9b5278b9a17151712b4a17b107d0015c0b64256842ac16f020c4d0d5c3dd059c6cbbef2bc78e80acf928578a3441d3737e49ca27305a122ff3a88ce8fd078390f69d88272ed1de227d8a0e8f242dee0995b06f4c036eaf438a0f730ecc4fe2647384159b945f6aa58ad60df8d2a8abe4425614757969579e7af4135294208fd27ebdcc5db46d652cccf2076db6a6cf2638fce8cb79688d190e5c73849f4831ef8aefa6567e73b256373e116d5affa078baa1361ec265a8743a3b4386c2e69059b9efe1157814d37ffb5d4ed73969b665e7ae5c614735d71867d2f3338045e47e723d0eca7fa82ff04afedb5a3ca20d09d0ec85a13cc07dadf254c1485e354d84529c6612caff3d9965bddc94264712adc40a8ab31f781f6c4b9c6ea521f8d3c9c8203ac793603456b8a5506883e64def21e2c71b089fa664803e3e63248f75d8353feba25154b6e9dd01bf673969b260e9d17e3febc14adeb7dbc6406172464fcc37d46369ad0442fbac947ad2a28ddb46bf0c9196e88a942002800a0e1346e1d43e235df06bb7c95f0dc24df9c70b72cd85210580362f8dcf4a5567883ef3a5ffb446de2015e23b94c54fb3ba14547c5d2b597db36ba0041426d2e711ad9e8ac8745152b9cffa360e19e9f5390297bc57367d2d166b76f6f09b36c5be839e2e3e0da3bd924a5a73995730b2c99cb3cd6114554cd94d43d2f639b28837b37bff6557e81ddf18b01d255649bdc8ec6319b14f61167bbc06718ffd4423381220894ef7158cea75aa18c71f7295583b95cba9c40ca43f3906013c6ad4bf3f11670bc4005bd212d9085c47a3b622c776090cc8237e71c966f0021382e5aa53e9d79ddea1cc81334fb61a406c42908ba0d6cce4cff1ee872254ea5ea8aa4de12109cf0a1f0ce35a808e5b99da3e186f03a0560de5933eee2066fae83854ef85689762c48e52a9071a2471dae61647b3658e1438954bcac3311379af58203f93a42fbebe09ac8b53913eeabf421db1005b2f9732bed03a308f2be23531a3143b097ebf5e9159057cf472cdb5ddf6ac5cf4b89eca9dc369f877f282e487ad806bb24516bbde919df9272260c2142ebd5db91ca2efb23a443fd1084a01ba2a38bb3aacade7ab620eaf9f6b0b71a3f79f9f51a5438d4e2f5ed77311c3835907e474585ef580720fec47124ef85298434b6e58248f2ecfedce2834af1ea311c9239bfdc5b8eafcfcd6f358f3e96569ea61baa944e8bf5ec11f48207084ca571a4e69a4af9ac9fbfecb4a0c2bcc7d6b5703aa03a3fe82e40e0f25308504e072d0c7d259f4c1d0bddc5ec4b7aaf037d6bfcba308569cf70ed7c38df697648260dcc93481d9db350a8e434f1cc96ba08f376fb05af5e9a710bf029e908ea4f9080885c5f2c28da07424d4fb2758301395a9d8662c4c5d433f6d36552b47360c267d00af2f988fecc7408b324b4bf73245cf3977146df9e41951d6707ed8696d1229bdf50b067afbaf4b4599aa456dc6acb3cc3c09c385e5d84e7ccaa3e90fc9534e4059c14df5dfe9dab8895eb3d03b43834cb738c2fe6cd2efbc1466fb22a792a1bbc8fbafe08f15e9dbe3f47a3229989df5b3c993b0bc6dae01ff7116aa4ec9c4453bb82d48afc8a104d09ff6b4f119c5fc70637826d7e3ab6095d667929067d5b567579c2ceb769f5a2933d5d370da978ddd9801ee475086946c9b56ba1c370e17277ccf605a0077a58fa676f04f835976d72194123e6d600bc5a81296269124da717d7e4344a2bd7fe8dc58d67c43178bb2bc20d11ce62e2fe9bd54401cf52d120f03c40d99e4dbfd6137ee8507026d33b7820d3683c8596823e142e8ea239b1c5c0f9d17722fc7d946d89ae158774f7ca02260534a483c89de9b7a115f72e7facda903b3a26bf9013173e976494ed6839a57ba2ed7fd590bfee47487895f06e6bd5d0d3dc8df590c282a4644086f3cc97cf69ab8cc2baeab0ed61fa10237e158f2074d091b863ba7303f18bf9ee39170bde444fbdb1aee1703c7316e65abbfca53a66ab77f51d0e846feed304cb2e0c5357d6554d5e211af1bf2e06497f7af73c954bdfebd506edbf4d1fe7ab000b566ae499f402b1c8c8d0bb817a22fcfeaf79e9250675d684e598d06a462ce64830e18c48e64eec75d15028a8c31de8e96d428c9a12916545bd0b7f3a3dce0ccfffd604165c9bd8c920c6c4d6981589c2da1f6b76c445017a84176fb8b8548133b51926357dea10c0c9a3761b1dcf5361732db17226a2382c9cbf58c0194d6cc1954d0cb38efaca61d405f3d13e3a3a5bdd83f16e6f7dd6d8dd921c75be2673c3aa82fdbccae5e977ee1ecef6b1b725fb044654c22bad6b05b6c99dfca8c064ba11b70c14d71913ffc74d80483ccabe4e9b0a9a1aa0017dd2b337c316533f0f9be3620314c48c973bb28e7afea2c74ab4c8fc5b14a1993515661b56f7d182fddd1c6f0c0e1d43d555521847532e95d403c9f7f2801d91ce458d6407ecf43f66c6e7dfe5343f303ad2638c955b4a1f928e3712b2f80109b15b2c7ebe849144b182cd9b92614df852744e20b47e2ab2838a007d8ac2b327401e43c502c1affab4f2f489d246d2212388e580e109c4e08ed68edbfaf510b627d4d02408e9c7231766188c64f282ec06ff0868dd204d2490e712ef17af4537fec3ae3d7abc681baafb728cd882b4f3cb3e1a59356c70034330d96df2b46b6f2e5b5034fa6b47f5c1976ee0e41cf918a29e9d0a7525ce7a24ad8604d4022df7570cf821d256d9f09d44cfe2bc625a19500f2e4ca760c1bdc04760d7415107d96346964ec5eca00c05244f7f888937b988fd21560c9bcbe179da0c75e59ed99bab09d8ee879733bd92f28b38f28267a65a24a7825ca0ad3a3c124132c3b494e76aed9defdeefd74b83ea51ab24a7d27527ae15e9cce0892267fa31ae3931fb156f594f849884d852b4bd0eac057059c87b3da13e107e62b5944b1f748404133a96364235d7578ded5f509256d2d844dd46919250801b461d0ea46bd1b14132e9df6a84a59fb233c51ce7933aefe783b660ecbd1fa8497e37c21ed1e9eda790c6ca31ba2a3647b23f80e7650727054ae1bff57e096f586e3536aeb10c4aaf7b25e21e1a2e40dc382d6cd431","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
