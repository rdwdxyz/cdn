<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe84385fe0482b7360b6c336f9a214738aaf31b304d11b4c33cd723be40b0d117f0694e0bd3505608297ca2db6ec307fd28e2c9198ab5a50cbbb266fb05f208952662256394dadba8f7191b8b2a62276fc263ca29668160c5645be8615c9fe15df9ae36f8e91eb42996c9fab13cd396d9ea8cde5002e2b4966f0644621486b16d15569865983686765ef65e787e3a2e68c836997476d1c36ce64111d0776a5c325e221f6eaeac11160398865f42f324a2b2303afe47124765abc902b381a73fc1af135cb7b0a0f22880a6325259a2464cc41b91316b7835cc2a40a8abd0aab37b6a9ff6365207025a343cc249f8e9841badeb6e2387aa3897f730422939b104a0e2757e54836bec5458ea479c56ea990ddb15026ee5b570d3aa317aba1b6b2ef859dfb2edbd1999a37a037baf3d8a1c2e29fc696da7578e6e639b2f2862c16b02b9ef7889d925f244951b3d3ff26eb7a472f4ba35b6da048cb4298b5a8eec71e4f1e8241626cdc8bcda7f9aeaac79930293c950e8950a71f13c55e03f96b6f34841d8f2230cc275c87cb635ab82132251a1f3db9636d31de80fd24d377b98e6fffc23a169111fd2451af0326684dbbcc422d0466f4931b7cd650b2b4da2dc8231b135f53aba40dd460288416b57e1ef137d0a7f579aed2e15b6f5fcc8ef90b51220b945ad201b5b85466a35f661b1fe6ca7d726d2cd2e5232cb6eb74cc3023898b994f3757bbf9db0ec02f89e4555064e1ee2e9117cc35211517611b80a03678d512fbc2103ef68138fc89207cec0a2d64890257bdae2c969b98e379579873c936945154e3cb4b99b5eec32b1a2b3e7fd5c3ca1d341b462baa56a00e32244116b81e747ace70327aaab90ef1a452222572c3d8dd7b2ad53acd556f58649f8cc2b3b8275df1bce1569492d8b36a39fccacaf32b3c0fee53cb419440a7f98755aec1b4d7a657642c9401b21bad0e8e953601b01a5420f21c281ace5f9ce6a467cc68246e75db82f0b0079fe5158992963bc0586ba3ba7c4d2de1d65a1fe88ba7eef53011749d97a2d8d50fd0743f987da63325182782126c223106687bd9a9b80e440d762c1222ac66ec61d1c8e268f3968fd11bbdcd3defcfb24917570645321db0c710a1d53d3bad7db06fa4f86f3cf40d93b7425d12cfb8219ca8c03526a1cadc8d2713a1e85c4121c77057b34f7dc9d460386e3de87d4b72cbfea612ea2a64909d579425813343cfa6654bfb2bc37033afb71b286bccdaa940974907f4bfb0947a5ba2144c895841739b644e5efc4d4ef7b2ed72123cb09949ae0b26c941fdad59a77d2974d8b7001dce513522ea9b646a3edf98bab7869535aa439e73120498b2e84ba87696350b7c9ca80ee9d5cf71acbffcfb441e31278ec1f2e8d0625e25bd196f814e220f91f081cca05f0f6f7b600e7edc5f6409be5f8524ca1467bf1cfc364060ea43f1856589270462e484867665d274828a7539c7b4adaace5bdd4a1869067262a4732fce11335b545276727c11cae68fe7d5a06549d9b34f00277923663afaddb7fad6f6f3636836b1cf13310a3f22a6c40dbfd0be1bd58e65c8ca3b805f15d56999a04804a2d0517e517bf0d359bb45c7dc81686e1f4111e182d4fd7ef70f0824c18e803f78d3c04a15e4187ac777fb9f0d36f9c7543122c4624e53de847cc4425c59e683173be56a47b6a7863044f6cc04cf2f99f40c5f083d12bc0840309ee7192b9725aad0957523048511543621434b33a0786279bf71b693211fbb0ecccf29a165f7df869cd79d86406816298fc2154aaf08335fe34de178055aa0edf33be6c63f0b6931a53abd58a536d06bba6f0373a8d5540d4a54bd2910a6a1c147400f3c9e20c9a85a32abc9fa608a366092c68bb9ccc3f0276689f08b75857fbde340283c669d495f1e5afecf9e4f6c06850ddd2484ea42ea11485767a7bc809dc4f8bb0818108a583b9765e8a1ad25b16905e5c94be6fcae505a122c42e3e02ce9014809dc167a7ad3fd367739121b0fedac9b5eb1de915f14d63d7eea2efd9a60864742e7f1dae7bc936f76fe5d9a8ed901806442b502cdab5033c00b417b4a335c98223c4d591bd5cb1e58247106b859f610c2d32835f89381d07797dea2864a76ead59214f40abb7a866819b28da085914bb9f82bad34ff76bfdd4010fdfa11c959c96f6caa4f68a22ca48a5790b3070bfed9e26b128a8489bbf9e3bf26fe15dec00aba02c00402090b750b5258abe321f30f810a3ef5c756f6b876de203eb89ea97ffef1179d46ee5afe21dd6ef13d23459109414c7804ea3a40cc2f0bf13969c1ff19e9ba13d969ff65f131e1624faa7e901c4c875f1a2d7803357f674d757db17b649832f78acb24b2ab89364370004167812fd336c800ccf04d91db385695f7c8a94f5f3a8d5cb324f1567bb20a0efc18cae9521416d1889ecf08579fcc0fb009afc9f96555e515962e550706bd8cdfa0180a20fa71a7a9863c3b7d14a935c7de4d495d7104d886cc8a69ff1800ce65c5755a9c0f52a6d5aec562cdf9424f35b9bbb41e4a0c4d535367ec52b111d60ea0275c47bd131dae1957f1e94a7947457809cbbf3067d77513bf064f3e49fb86c0299454418e3b531f52081874d2d95134aac8928019b38475ccfe08fba2b205cb644fe25094f85db0b64926f309d64babd5f7ab9eafd39df2e84de451996ed5ded69e028b9faf8c9aa4c5fbc5bd26fcea211bfae61d9ca6d21db41db43395ea09e6d0ecf6d67878e46f9c8977b8e8249a2e300dd91978c50e0bea5de912e9409ac0033a73385b095e2dff0b16a60b79ede3fc66e2ff85223f1daa4eebd92615b54f27d4babd5031af637cdab569e721de1b5d2e1898e915882d583f3b0beac7e53825242e1ae1ba8e693800ca7a299dcfd73d9542495756f0da4bf7016816ca10676909bbc26a743e3a1d20341a9f6318ab97ccececa2d79cb96354703685875e7e915dec403b863341ce78add5fff638afbcbdc95b76bc07a85a85e7f68e371435a233cc1fd3c5af8df824ba03f230dc1d88758628b44d0af4fa5fda9f5b7156bda4aa6471a8b1d4aef5fee3445d70eace449a250bb43d72b9794b539c739e4e8cdfc9cb36d0f32b23ba3806f5125565cfb174655eac7a79b77cb968514b4c98db4dbbc71ea931302c9189752039503439182fcb9393f641440a0075a76915f77159fa46d62693523411fc44f7437d5ca6f3914d40a20583350092254aeae28ae6a5749b1eed90e55d082a7490f54c0fa9991a4d999d743472dae8c14627db627c21f5d3ef86ff22178e5183b1233d83513bafa282b6ebb546c65dd99f3e250726dde0a223d6d029818e8c5c0885cf99256c91be80328b3158aab2290cc27935a48452e9ce1cdfb1de488f959103f52cd6b9412947410c4cdd54c12b13ee16e9375138076dcad919a945f487d554a8c4c1cdf49ca20ca6f614660d5f7a8a4a69c12b4319629c4448a6b9a0b25818ea99908741bfbdbc164df8cf7a2bf8d245b343cd7db8835e5d36bc8e9f88792991079373d19183368005d5ef883c467beb4aff42595a39ec681eb9b354fd864fca4a7330b0d3ed6088ab16b768dae2818501fada2b65915cc3ac442a616b5943d7ff5504574f841c9ec1bfa2c525e7e270afd48880643dde9f8e7107b04f7f71c5e9e6189cede0d0223ebc93a9cae3da0549c2fa1e1578eb678c99c2b8014cdd22e0833d57ebe9786d7320414daec6b111c5324b490378b67a97c9215a8cf9dcd34dbd0f1e236c1393398ea95130b408aa2755a47f4dbd15fa2dd9b492bf25fd2488deb8b55c6789affd624b5cf27f61bb48ea035e4d04c1df02fc25bc548dda1abc063d319296199fde1f5bcb8d334d80ed639ec21876c966b542477b66191b084f37a3dd4deeda0012f871ee01a4e88172619a1b6c2140e84b1bf15cc506ec092d2ca6122171b1ab4d582a1bacd03fa2723471506d576f623d81ed6fb5768abbd07d081f486ca3344984acd17749bb1eb8bec3ef185206cc4a1b9a90366b9251cb359e4a873a2748afb5941e8f81fecfd3cea650e8cedae625c1a25f20abba7a8a7b823654673161ac19ddfa9a8b53ff9db8824e119ba2c9a618be6306fc060447b9d41e2b1ea3c409936428a913026deb3dc753311cf8180b2f674aef7c1cfec2991b69051e62a190774eb1e692bebbe375fbf8a22ebaa950c305b648715ac8977caee760d42ae28a5d14276d348c805c22e0ea5062ef67851f6164d1dfd4d259a8225eb3d8f2312fe5ba270b7081c8e7db4bd66b608349f3174a0f7b18e4a97d13f9f30e575dadd32527def0e2adcb9fbb77a799ab37bdfe80834d516d8663f79d7a7a088af41cb6bc773b3c95ae671acd58c8676f4e0311098fec2f436030333542b50321c025dcb1c1a5b04f65543dd2603389ddc9a18cef0f8b5b0184da1f480ffa75872647e3003b064bcb3d9f9fd8ff9f2deecd18d1c53594e10211cfa74fbc1e7486187e6741a52784805e5b5db4dbf68915649a15e3e782a33e2965c6fdde1af0abac3af448c79218e65d1215c3fad07d447f86a9dd57199a216a3805fd2205702464a94ec07fe1c8039493ea1452d9e0580a490fad35dc03c61e402ae8c6ddfd38c06062bd287b853b65333b8960ef3183e1b6297716b0956a1812d4b8c4803b2d3f0ec787283be69228e435b1f64e356fc39a072fd741baff066c7b84f62959586ccd02570d96e903dd3a6121b789f6974bb131eaba44fae5ecf5c6b63ac9ecc0f6c7ec57c9298528ca194b3a5842d6a82860cd26efd53e233bb13b2626662270bfbfe68e1a285bcb684f01be15137e63834078f9390761fd96be283a146f4cea6aa50072f2adf67d7d7ef8cad189d10dc33dbc88c036843d1aaaec1bda9b073745545dc9f8aaf2a5a1dc91fce7c6f8bf5c277f938c3c4c6041ebfa552bfcc970e5f60c73ca0718cb60140550f219f9fd8e02359e07e150d1f68387c53868659a53f64aa9b4f80d58cf3a8a9fdf6895da2af5a410c1be6d84a19524abcbc9c3a4b3758323cd20ac32e10d6e1d7d37145d921abcce1910a469775e675be0cb5cf850388f93194a4b5bae00576a00b6f5e5e38571789464c63a2aa159d7a92ca1be9ff24edb3024a822007b5d0c1e140b3d2bd38b2e49103e52d7f7581969d696d301a9bdae816764ad15c891a351541d9dc32c649ef83074e564458d3a145f6533843acab595a5d7488343e95b05f244df2db50a2ef2c2c452cdab5dda7ac20d0e979a7abecc625a8692558f83506466378f7dd1f642b4c30935b2f7372d0fa38d5a0ac8eaf77e17292f575070c311d7222103a927af8cc459457be44ab0c548ff019291a6b588759e8acb4355a09c6fdd2157902b232e538edff359eb5709d474db8facb153d03682ea98e704b3b6befa4e84f02997779ac99d0a238ce29cd17e4ce191fbc0d64d5903877344dd36c4eee60d7213b1776c7ad11626ed4efe07212c5b4b8d6aac818533f9a0db1e49da402e3f33243b4600edb582ca6cd049d61cde086592f7a21772ab32ff1a0026d073cf79a684fba05d1459ae1aaa0dea782f3310f991b276bb8408e409cd04f1b15cd04dbcd7d3954701100e7882213fdec4f6f6bd32f23b747c7a4949dd53e7fec14faeeed40f94b19c492e2fa5a8ab319987634dca904e43421a3de97c01f6ee3481c2c2685e404ba34c8ade9c985cf8e6aa21f249d639e5f91dbef5461be94f1931fbfb29000eab01825fa37e992c5a4bc6ce792fa4a882b27475600452a81cedc794a749a9ee02ea84e39a1be39dfcb67a2ec6c5e78bb59791636682e9281ae196ffd3b5e27b022b8c4afc1c1aaa9e1e21b4ff3bc956e9981f4ad6e8cbc36b6f19fb53d388102facff9e8bd1c6530db20945c0c4ccfc7a6040061dac8f682428122a6043d42919f3b8cfeb49e266b367852fe450a7f1077263da38c0372a4f732e6465e915cebc5df1a57553f87434e6523a19329e125acb1b5edd413105499285a33d0d8a3152cce24539f993dd0b413920b2c7734206d6f28b73314c97493266804a4c94999eeba6c9630f94c7c32fd53bc31ce4e461bb3d690db838752787282197672c31d1b68f93db5426e23e7ec1280a9e413b36ffcfd2a103aea92da8be791a1404d05a0d488753c0ec6ef29208291924e6ae2a34831deef5eb5ca3ae929aad2cb23c60919a9af8fa098e12cfc7678299e42c2d0d5a6dbd35819415cac4115c8fa679a23ee4c12c7463e2a8798394b081a9274df5e17830d305663329ff03fcbd19f25a84c252260925bbd4c955891b273705ae18323e93d9fd53277184ef5876a23aafa0fcd9c0425f7e3851ab2e9f6c527ea4486b43327808e4a78d1bda98e01def9a7b3098d2d5518987c2c14dda437afd94ebb2af0d492ded6afe74d6dcb0a6384fef482ab5f6a2c17c5eb3396aa99fa8d12a4b13c2f95d8df5568e4d8c20a3b404d91ebd6f0392c5bd26e88fc84e1c821582ac8f1e26f8273b42dc08b0470147d4cbd5e4d956a0790883ed2861323a108aacd8db3ea15d3772720e79a1be76ab74250ce54e72c737173850928cc4ba816b5d0f0076c9c2e4ee94e2ac1e5a2c0076d9828d2fbc670140dd4a867223141ff8781957bed0330cadce6b10771888778dd3d72b676921ec4374dd3669c7b98cc7992e2d23c8c446fd95598e9c57fb46696b4e4694808e68b2e0dad8d7bc433849a676e909117709d74b6c3daf507f8eadbcface1633aa13650a6e9aaf1dc0f0bb032c2ea89db8977cddc167f059f52dce14ec53863fac916a78ba457e3fbe810fde64d3cdff4ab296d74c45fe3a0b59b35b72e3f9c917a44f28358fb064e0843b2d3000423e59e97db88b3226b003db7e50704b4e5b661b7a7d7188a9fcab7511e0d4ec58d2611942e220019fdc2003d6f744fc68c10f8d0bf17fea674019b6431fd31fd61970a08b72a17ea9724157825940db4add07166021d41f0845b4bfc41ff69a95d5ec4ce84b18673e8d9f04343f860ea62c555cba809be4922f54d0072bd80d46c211e8d60dfd3a59e7b3b70a34207264f73348931665c6b3d4ac90aecc2b36465e1e876d6264bf71b96a4526a097c7368f5563c89579a07d1bfb677b4d29cfcdcf90ae3880bb662d4e53d31e93acc5b0981515c5a7599eff9200066a77e0ab2ec91621ac15b696e43e1a56bfa70ab81b8db7aa38c116457db2681e11c2df9e16ab24b2d1acc52e789285f36a1d6f23b214833503e441ece97c5eb9592a3319b14ffda659d256eab69805198984f61af3dcb10e935eca99326f7cdd2cecbc6e9949ce6b9d851d3bf3ede816b21b6cff29751aad3ebb44a0fd5917cf3a136d19e69c081a5a269ddee35d736affcc6363efaaa5adf2960211a041fe9373b682b871af1913b7d23ef1c09b9e71ddbfd64d5ef802b6c4b91c8c970ffd740cf769fbf6b1c40c7ef2113b4971b84bfbddce735e639c3c5c11ec006755a364ce2259d4a56e4d122cdb86aabd01b023c501af9aa9ee82f0cd2fc7cc2c9df0b57cbf405f389aad9f634eeba7328be767b3a40ad99bcf4eb41511a62c587bb3aaf57827a92b28908b0bb61d925f7d610362dcfe19ac1dba13a6181705da1b1ee33f9be877f090a9381f17d3b785645b9da031aedab430ea0fc028c80646341c2d07e5efb0304c0cb7a30b23971bd77cc0283b24fc46182069bd39a348ce1397d568d444504bc8e1deb9101f574e1dac97f6f29fc6b940606d66a57578961669769b70962ffa0f9c49a91967b5212cf949805f3c6ac532969868148ab536ff4d240f54a685f24ac52a7e46ea51f95bd0fc323591abe1a12de4618663ae36549218f4ab2bc7d18dd61ab7eb342c208b79fc8a8b70d5340fff9d36625ba2cad2683efb0715d17d9117d261f5fb5401c265e95258b189dad1d381e167c39977d1c3f67b8531e26bd08b13fd4833116902a5c109df448a495c881a18316b6f9e04f5a65e0c9613619b4120aaceda13827bd4e87d19e52b86b1caf8db19600125c82639f6f36bb0454eaa7ba5ea6c0de5d6cc95f0cb2b7992a99b6bc8d9e9cffc6b7a687fca9f2c63914fe329672bef0f4fa70bbcb7b2de36723df7ac3b8c9fe350ace8f9782b9158507b59b9fb7b279967b140c30275aa22a5fc548afe0d36d19c78b503be18739f071305a97debc079ede60c36ec3f97af5296a96f26cb5cb696832242e52661d01e716d4980b08e90e4b38e61f972499289d8a49c39e6e5f322aaf9839903399cbdf19b87690582b784dd54b7156eef12b69a3cf65ff082b0bdabb2b98f2aa1b036adf6fad47dd1c054af3cc2ba303c6ec1c9c87494658d0452024029f0a6bc70cf4a56cbea30a6296854072ad54733c04dbd211f48fe6209adb9e4ab2b562b5c009acf9e86a41f69b740dfaeb2f65d482060f912a484ae55aec1bdc58097ef5f98dbf2cc445fb80e551b69205911b506568d57a15bed75179a0b099cd971eb7ea039583790935bd2735a0db1d5c277d76ce0af9c65b77123d454ac6b523611b898de38f0b042348992d7628279b8087ce1a7f12d1e95e37cb9a7ccfa65428257168143919e369a1ec0d6735660df425fd5bfe3fda3256d3699a95afa07799ce5a088a8c07fef6f8463b2d44122ac4eb556a2e7702b59e28b0bcd84e803099a45abb5e48c221631a97fa7aa0f232ba9f00bfd7ce951f17a6f93ac04ed97c2f1132feada2d318b143affe969f219b8f23b9c5d6da5a4d0fd4fce4ef6b5c68054820e81f38035648894d5dbac10fd433e19f7b95cea20331fe346778986b6d234cf6aa6d8caac85cd95db9bae2413ee809791c068d4fd2f52329d7e716705c575dd2578ad4250a287ffba654a0903b4fa8f3406ace5ee81aba5b20eb5c77e660f1cf529f3af8a488ef57c3a2eb25ceb1373bdab8ac891d2349bedba490c6d2248848ba4b7dc0ae28df9d2b036516aa2bbf4cfdad02c217193a133d7994d6524dfcb7c14d94dc61f02c83fb3f711a61cc7d9f8ddded5dbc5bc0138044a707cf4390bc24a2cd5006e8d6a3a00adadda760b533730c652b4615ed94a813333491fa7cab58c7874038cb32704c81c7735f6f351b9bb8d2cc3fd4a8d02dc48023b3fa50c4a27ec616b9f237071b3708f60b80145eb4a2dcb8c1324d4676a3960d9d6885678aede2fdb402521830e1852a3028c846e1a94877ccf50b8c038eb375fdec78caf37f2fd0e65ce7b5329741f36ad66792df1e356f0f1e7aec8cb0aa58faa700066aeceff2e18080b3e467c11f1f86be1bbe8c52f006c04c395a5f1692672cdd8543b533a66f044261dfdb2d9c3fa5b08ab35673b15ef4689ead86ebf13cf917bf78ba21f11a44bc5cfb4dd94b5e36df83cf94168145960b398f08825ef994f9ad92bb123912eb855aeca424489578e222f7936c612b6988877dcebef88a850726b0d81a6d57bef3874361e7f79400901a643e3fdacb921ea696ef6371f349516e751b11ab71b92e6f378cef2d1e728af1b679524fdf80fe933226e9f4217a49162c3c5a2fa46794a51acaaaae5bda1b38d21b63f7e8e73bc3babffe244edb193a89274da5c36be061c08b141e38ac0f715af2358409dd49aed0b9dc7646e2dafeaacdcc08f5a1b1d5860b8dbc7da50ff4006f94549821a42fa872f5aafad3e30f3e7834555deaea7b974e3f2aa0c668ecfa4c46c698de083c047c8d5f162b0ded6e677e9e4150f1443bba76b37d7d03411a03700ada7bf038395ee2dd5816fb78ab928692ae3ca5436a84a0d9334ac07567c0902477a02410dd066d390c75f25f45cf3659c4f7f15cc19de95de92d87902f9f26d9d676de4025762ed54b6a237803add3173134193797d42b71699fa842b270993e8e4c908514379add36a976fc3569cc8d3af901e85f8be7bd54418be01745655bcbd09301bdc19717af689c642257675d1d9ea4e600670094767d92c065127045b418024f427b6ec65cf4d37fd7ef0f645c4b8164a96a59fc8f91ef24b4b948b029a36ff8696d6d33b5932d2f606dcb28fbdb8e3443f18370196e40b4708e247080fcb108194cb5db5e55ba958238cbc7c5cbe1e2d9d187945e13314b0b552b19798655b88e724877c09d7985cb5f6abc99d4d305ae2345025c020fef447b39bdb3415201e60a26575f125ebedc1ece9d838bd6f2ac1543587a26359cf82c6be50925e7fb4b36efff3afa93cbf83b1c7d7fbc7163693cfcf6a58b022d1136013b747fcb94d53ee5313f966c5ab031a4b4c1904880595fd9267e18bd5d38e74670a1de2ffca284f55a1555b7c95abf297be12ad26c2ada3d3ff2323848d2881e6716a79d2d17950f6b3426240712d6ce9ad61e5e7fd36cbe81495de5a0263a308da4f4d266e15b25ebbbe8f9974abded1a51c08de80ca45404afccbc4b503eb52bc8d4a6293794aa40430111db7f99b4769f456dd2da434ad6d354426082df639465be298f09a96b7a8a8c9c1a8c870af225c751cb1be06dcd5fef3e0c3a1f77597e0e63c3f7f7b811149b187bbb3721ed22013e3408c0685433693e28ccfc7144963ede3b922aac818fd1f9b9ee5ab4e5cd78f68a08d1d11b053e512e5bcd565153b1a3fc81cec1e8644d87e1b06ff54ec4c949243a04dbe83576bab4f6f06a1a3988b84431e6948d8da6e80aeed45fee407b102d86bdd679772b33fb7bc389aa5e4a5ea37fc701874449e6f94e83fce13dcf61b676d238d9b675110331cdf98b9a3dacd87e1ce5e42436ea466393010b8f52cfc2cb4942bad9b33cc43031f4ca0f773c0135a452a957267571e5dddebeea5d1cfdb463032db71b6dc2796c0d6dc43f704e23da185be52a93fc507bd832d8b12b77b27b86b018077a670d4f2f83e05b3269b32e0980636b3dc771de1363e144185a3ae293340695562860dd128ce695424693a4430e92ccd12cf04441fcadb7505699641fecbce6ef851d3cf3fa49fd229b7698e3df43a04b446b0b86d6b9fdf5aa9c0875dacac7a74c4a485741acdb62759145a30cb0aa66134f8dd121952f417bae9213b2ea25709dc28aaeec4e9ec641dc4762b1928ca7f1421b0048c626101de39ee13ede2f1a8c36bc8eb92048fcbaa24b8c133057daec41a311420541682aa7c5668dee2e2ddd32859e20b5b1be6066c9531c8495c93d0030123c444e3070ffecb3938365d684f58e7f6918ca53d34df5d353760c5aae78929fb298b3d69809708e079e4e936a970a5fdc007f8f401d9bbb04866f99515b07dfc3aedcafa1e0b0ba263d2134d24402f9769f05de3686212b62afbaba242f3c7607b06fc800c5ec913fb7b8fdb466026928de1a3b8a3ff4a12176aa7f648537db3f210cebed9dfcc3df1a33caca98d488ece142a6f3c286ccf978748e65e3118b291964f3f3b19495ce90695ba43e2efd5b7f0468a5ab336d369efeff687dcf6260456ed30e545bd008031054f24a8741b06f80e9b8787fe43b33286f193241e30a9debde058721208a31048e0a7a8f311a2662f0f8fb547d63b9d46b88dc7296769440216f5702c2b144f16453cc534613ca8ffbc93481e278ca8191471ba5c48b88d3c91dbeed89f4efa4c68aea9422d8652b275b21cecf04ab2ef9c54f16e603a01a33eb59434244294412633dde8f399de1791cb1946afbe45ae2b2145d30c7332bdaa00abb92a9dfa9ee6d129e9114c517268c5aec249d244e6f9cacfd1b45b71f62e23ebf21178ae59b58a02a8c8744eefe49ffd4c9ff1e384451b919b688280a4fbbb0fbe9c4ce7855866b2d54a54005c95d1cf51a3af177280c02fa4ff3838ff3470d722bceb7426432aea938ab22d0f5be4207914f693e3adc9b3ac0baf130f8e3180e083a4fcfce4eec7837eae5b179f058031b05546d3f4907d8ea86bea4f7743c2872e21c5a43746f7c02a05cba2481b2f230ed5ac78fec818357289a41208b511323714b6c763a52dc6b27ed5ca68d0500e1eec58fd7c159c429937e6e418ad9f9b0df1ef3fffe734a227b994eedc9f4174cf7eab0439235443b3049d90c270e47530ee4a5b0505f39b0d5d301761b103bdeb8aed5ce442dfe9942e91b4ea1738daaea2ff46c5f8f8b2981a378e0ce3dfc045466f85f94cfe78816ba5ab548b824ed6c5b16fcef9696545f2fb70c7889917c6da292bf7d4872284b4c6a236313a10670f3231fdca6f90026fb479e503575c5b36d63edaee73e17231e39f8220e1046a7f6bad6b35014301ff904bfe98ba1cba17a457fa536cab56cfab31b06feebb2592d9097ea49e4e9dd5cf5f97631fb1638fc6e96bef9e0ca6177340b51c1734718eafb0f56794a50ae4398a52c5190aa22e474df67d8d7c4c9f806e0551ddbee7b8c7eb76af3771a2690ec601e5ae28c2112fbc60f5a756cfb34913e3b701db1a4b482b9809f7a70c677cb861566244bc0d9667fd574d7a748b1e262e6eaf3b6e7d706eaab496b07d5e09db6ded2a719f21cab63aca63e4a6567e97f117a56e1f521b9460e12c2268a4ad32e21312bbefaa0ff740fe1c137e52ceeddf60230fadecc1fcb921c88d9ba6c880e882c3911def843c2efa4c995ede8c643cd1563e7e357d6f27c0e073ac07ac64c80727f657f50713e55b5c84a74f31b0bb9d6f6cbb3564b0946549bbd61bedd33d8904764a28388d3ce4dbfdc816b99cb326ed52e2ccbfb73bc69a2957ed5afe935da46d3c08f71a17102ec94e0d34efcdeb4e118dba2fca9e2cfa245e1027553ea7717f3ac6d86c3746d8e885bbed5570ac20e7da7795f56ba833f405160a308510468e71f0ff64dc7ff7c90211bab95766349d039d67073dfedebd2a0d1a583bb2b2d338b20b9762a1df15ec2d41930aef8afd5e69d5e6a0f7dcf7d90069e5ec616f7e41adf2451956122960d1fc0a0384a98da484285ce93d75da9f788517c1fe92891b2beb4cdc1c32475480e2aff9a561fc53c735df901f4f76c02be70e4d87d0b0c710ccb3921cf2edf7740fe12777dfee549f02dd824e4ed2624b234343a134641ad9d770d92e1400b895026c1ac3a00b3f1bdc32aff35c145d982e73ecbf4612414ec9cdd64a9d71df91810aeb1d779b490c85598c68bbbbce1cf2e4592441548b3f333932763c74e0545dc404a79ae2b12b6ec19873443d2eccd2cc193e02ac9be6bd9b2523a44ecc0e0b23a864071e3482060a3da621a7194d2b355e6cf6af867c6868e38ab2019adec00911cacb928d9672d9c9d84ad3753e6010fd4ad62b8818780d59a409daf9131f88c7ba1f5d82e543d4e51581ecc9d71700e4a2dad07e4457d6c9586710318094a63e7a8de7d91a240cde4aaef7efc975be7a8220c1c0c30da0d5e9623e0f86d2b4bb05bfb33d87ea33bf458e332d3ca7d7e8c8d2bd142449df5d499c3f8f44e8dd4a1b31e9ff606fdc43d6d9f33b634a44f5d98a41fc87a0f867e5c7f020f2f9272263d1261c66cfd4ae93717e451408df53d3f563e0ed3e277b73cac9ff375a8028b04f497fd4a22394084c54ef1260684ac98519ba890c3dc50b336ccf2cfc9a9b652a337913d749635ea49b173fc83e6b1e58aeb2dd38acfc6612e805895d14b15b492b5126e1d8838334c992c4e16c60f8e524b9c4a102ffaa2d8c737ac518aed2cbea392a155a1cea70f02b1247f51db3cb666c8a970b2faeaa10bf8169987976874889085f552493c346d95d2ccfc5b96e90af034d4266afa33ea42bb419411787a05b5b6e3097887ded98a02406c3b313b96c3cc35f90f6253265cb800ac13125b3f08fe2f9b3ec3caaf86d409e007c6e62b8747689accc1fc1fc60dbaf997aabe181042e7ee1051ba8cdf6dcb285f49a05d276ce32834bcaa81fd723f07f0a5c8c6508d1993d31897a356a1f9fb7f3d4d5236b4424d2f3a2046c28dc1c50605ad6b8399c9eb27354be3979f1fb2184a688ddbdc9d1501fd63907a9dde798d81916b61779e89df6368321c338cbd659131cf6178bb172ac5db9f9a048cb8d803266f3765fb76a73ec53636fb047d0cb4a069fb9353c3606516e43b590d382d68cfc6f9ad457b7d72ca3825eeca477ea8980e6f157b8cc590e232ac327e8f93c4f9b1724f545162a6a07b835b11fd7dbbf4ab4edc3ce0e3b718206234c9aaa271a908d9ab8e46df856ad5681d3ce4b60173e7b1921f27b6d3a8cc9148392324fdb7beaaa7d1a901d6af32dc2b1cded0589f98007a895b86ecc1eefef4ea8301217770bc14c87aee9189d643ce7e243b551339b1224caae258b992209beb01797084e6b1abba1866160ac2a7cbf36327b47f31cc4af318bed4b2a3b3ca7496a0f6284eefc5e11835c6f2ed5ba21d397adfc0118059d019af891f765ebd70000cf111fc662c388a18b7808b167ba4093a900e306b7b8dde6d8a9fc1e0ed10cda2fd6facc949d400bfb053bdbf1343819b762f97611822a1b690451c4d8f69d90b973c205b013d29497347178d1de53be17f47cbaa5c0340e23f43b6828f21a384c1ce2557c823231c5e56aca8c995556d4e48b90180f398d9e26c0d714076bc5184aa5e0399e2b67bb376dcf4b3715c33a776df4b10a48ed1959523e0b6611a27e023f2a5b20550929a992aa84360f9cc0518e625c936160cc427d11a5accd5010c9e582138b0b72c780f9d7ca1a0712aa097cd828bb737c46237885fab5d2d70b0883549a0ac458b87e09bd70c84307b54730ba90a37b15495f554f3c5aa82accd2cb4a35493fdb94a377476ef9a8bd4fa6739935a08a90f08b2ab2c4f9c6406bc42739e15fd25f94c9c376635e89b89533cd89d1a712fb860fd17b478b6f3959f7bdc8d7d24976530b3fb7197bc1c6c7a11e7de92d4a0b4ae1cef48c022cdc62d85af28f088db724bb99e0c4a05c8d04c3c7854ae62bb4b06e3011084f2b191df0426ceb4d539f4a328c61aa5429c9465b27d304a0f8557183748a14176abdea4b4096e8d8e3ca059d1d79db12fc7262d5015d7f848143d5361079afcbd97bddcdae3416bc6ab4965a8b0319da03559a1abaa2945660de3c82788e34e66736d5ed2f2f230be090a375a654ec444fafe0aa783107618ab0ac01ae24bb8b851533393cad150768cf7f9671a6e313e8cbc4f1daa9e0a4ce0676fe3700d907b846334bb0d82bd153dd2d08cadf14e66145ed20e17e1a5fe6d48dba961a75b5cfadf0fc8987be441872db02e6a2c2a45efe95e930d56625cf8e1f239552d28c80d3eb54dc2adb5365ffe25a44cfa20bbaa445a05d461db5bc8956dedb849969427cbf34d8b9b6331a2ff2d63b5e6897dd9d2a2f04abbff327ed9a31e6dc52fb56772e7c2bfc437064386a497db0aab87f35ebb42636c60fc2a8254ef096b9ccac31132d2d31a3055da29f1a562b12172c9e1f920e9fb5ab9cb474c191680c27c43166c01e617812db4f59425c2ffb8bcb9c79c5b65eb56e3ccea351af1ec39f86dbeea40ad95e8e27c2d1cbd081365ea92090231ff48d0a9a52d7ff59f4959e7ebaec1d5c9daa5fbf7856203acade275443eaee114f5843319f82a0b41aee873f1d251e8605435e81407aa4cf4dddb56d0d0cafb2f88a87b8fd4dcfc4b4aa5416804e2a3ffd976847b47ce5fe75ee2b0a4d7e895f2bf8caf94a9428d1e11635d2f6927e600531a96a678faf6871b3484f8483e2d4aef11d04c5aeb220a80f8fbe73aa120352dabeea34a9fbdfe12561c70dc0d4a8048e2e4a24987ef5820ff9aa91f45cc5a4ad843dde54c237630a1e546703fb2219a0da29a9a4c0efc72f722c15a12e38ed34ce4fab410adc2b3d6c4851924293774163dd58d48bbcc444236e1a4e1095d2e0b83e9bfe365397b961a49497c1db432e8276dc1648132c64e8c53e66f6c0c67ad4dfe995b3f32f52bdbc1e5ffe99e0a5c6016225d68d45232d3b8ae6d99726868ff08c48308e396132141cb9b23bf1ae5444ceeeac9488458642563914b71530d2ee2397e201246018a29a1d3ee2faabecdbf75deaf68dfe3306ed984885646f16bf71e33616914b83654fd9a92c2363d067e0ab74c9cd0209804d2dcea9272520c6450ccd509205cc3a7af53aedfc157921d9ee541eb45882edae7735f3748c2e70aa6a83c8c59ccddf1c9ea7ab40c859270ba9d5763004e5db6fdef85d0de4d76a865bb892df1f35ad6bcbe7f0a87549dd08e3823bd94fc1452e6c0849720acb15ee4be49994ac1aac4d1e5bdfd3857bf403d4c6a555f6de4c8cfb32d31b9f6078698f6e34b4687dd5bd1031de05af52570219d7dd89cf1cb4ad31134f37e70b8d4990b23c15efdf6d705c61eb91732cc5e8430c59ae40d60f3bcf32c8be432b74b70c97e098c919b0f2f588429bc2062aaa7044f404c016060fc4ebd80b6ac0c02f4f504623e0cb7a29e86ebb0c1513a62467a37c56efff308d638022b845a4338848fa1ba631783585ffba178383633126352464b06a46086f24b48c02d940aa451848e8a5ce7f1fb33372368e1376340079ab33fddc382e0cae2ed35580b1cad5b1281bcbbc426d2b60c806004049d91d95fd4c67ae1a5a1d78c5b10e4fd3226263ea9f1b3e2fc23ba7e51ec1b79de4747bd1fa1b5a1335413616ffd39c6cb7aded242389e9eaf11f05ac140c3e4bef6dc22572df1005912156753eaac0a29e5ae3cdb6dda9d7901b75ee3064a961a7b799b1e6f9f609bf3d5d9f0f20e2368618282be093b762a2c934fe2ba66aed96308364dc875f7329a3058a3e852f2756b4482d481a83918843b2396400dffd00e8f204a012c544c371a9e5324bf0dfee2decd1b6fb9cbcef5d19ad8080f56b5822d1ac9a36ced35b85c785448bd830494da2df7d9c2769d9ca44bdd0da4cefdf5b87e7134b94beddda7432c6cde364896b29876dc9c3040472d2e5bb2b6eb41252e51af9aba1490e7b2c4e892f9b84110d8e6a28e6892f76d46037e08ee85b1cbe077e57b3b200d25b9952ccce904ecc54d1e9a131f8498e325552c2a0b3d8fbb406cc57badcbbb59a1d4cfc770d9e6483d1857cfe9556a9e48897b9c910f2dddde80a1e14b605632c559bbe61504c634a02252a21e96453e85d396c1bd9d29e0fd9ebd1e56be54bab08fe7ed707cb931f01e977ad24f841f34f63c9965e4447e0c9d965b72a85f67d34b21993664db6de552ab6460d8751d5532b2e28520d0c296b54a2288d7e76fbbfc26c352b69536529f64f09e06e60818bac6b63dc40ea62f1b00206991debfdbb3a848b26d8505c90801308d28905993f19bdaf2aa2274dcc3f023bc650d6588fba8c0e13d06ab29e90471c1110ee1f3a264bc9f9a23b04637797ce0c7aa114607cc49b628de2bdf363ca1bed564003862742e70635c2ee0b39fe29ef4c9071279b12307955b0b03db36d80390741d29a9cc1412f01966bc91dc5dd0f620b78da0308bf252d68effac6107775ae81984d7661fcbbe421522146465c0ba81f40e1c404c590988a34e08dfa8a1a617da88c0e6cc6ff75705404fcba6e0a20ea613f3a381fe7ff7c4488f22ca67130a8838cf4d6b72b0fd3b4756253fc980201e5bd6a985e59fc860ec2ef3018ea9bdf7679a8bc66d89160aeaf4753ac6e87fc2273d0fe2fe4442f7922580acb93ebdcc63fbe25de0cfaa03548caa9345d33a7aa2a90baf13d4c6c04461261cf6911fe4c5ed43c058de636eb1455466e6bf7f769515446a6e6408928679c610f3d945300341209f1e09dadbfd058e2ee2f4ac8f354b3a359bf19d08b656e2cf578ebe4601e81cb7c29936e52223921240f714cbf11348fe74ecfe4401745592de41b1ff269ccadf3d155cc94f9b95cda4126b109ae700a81b54c23a4696858f6b117dd8c91e8e48b0102420a20275cf29bcc230ba031a150f109389cd73b68f6ab1c8eea8b6347436db75199095b4ede8cc5a31638dfb3235d147cbf87ce9d207955cfca8f1a99db88059872d8be5596bcbe596ff5594c75b12809706943851ddc7f5aa5a9269b1d025b696ae4391b5c4d755fb93a3bf834e35fddfbccf4cc5e188aaf9fc97eea236dbed3ba744b8e69fe28","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
