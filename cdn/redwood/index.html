<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"80be77e687f3bd3a8cb506538e8406d5c9b67e0fcebac932e4cd568e523acbf13585bdab534119b618cd3e56b29a4e5e1d552e3adb312e25dacec8df067eb97d5635350ffbc8a5d9a0f8a9bd75134afad7b320939853d8efeb80d51f3ff179b75d105f6d928bd222f6fa069eaf1895af1ceea661c71b1d50d1cd4370b1b310fa887be0d0123032f0da0716e4e645e74419eef921bf7a59fb3d8e62cfe05031c26730678bb15c56796f6d3b1d52805dcb50bca471d02029467525ae8309157a4d25682128936e3fe85214a70ad1c1f44ee16edbb961d3b4e9ea8b60dbd89ce8b00f4732e654a5554ad22e072a3b6e6e20fd1310280d5a7c7a34929743282de1027fe41aed70d46e5834e1d36c2d5ef7080e7935554b44b26b3ef51eb386990475b3cab6d83cb860d433083e15091aa64247458ce07a34b8b52369b4ea4c705f5f8e8acf428eb21836b889001a315653597f104719ff41896a387622545bea6e230b72161252ea035786da434eb10455526237672b2fea6e2eb99f83dd84fddf3144f6bb257d49cc5cb2c30467a59216ce79d5ee8a49901e5e362f9b98e5a9448ea243bbf4bad7e343e0b48163a2aa7231988434a774c67c393662adf69bd8bddb7417f0b2cfb0e1a091009a0cf2459e5c52228cecd58ded6aef59603c81a34c88d1c9e3f1e28796cb69d62eec81f163c9e8a902a145d1d6db2310edc43cd19552f3955d1109593d871fb26753246e9e4d5ec712adf07a8e2ccc17476bef721917f8cf245f2cc1b929db26306c418de2159a476f2de103f1755ea4bd6182601a0fdd6ec03f73318852702e9213683d164f99c57799e85c42d1d8d7fa3e217e4a8ebbedcd9a38cf6cde942ad63add43cea3fd13a62a67ce8e7b8f203595e742c8b365777593f42c45670e3bc8d77b6ebb0cf5cc79434b9fe2da5643ce9a031ae80b04c269894831409753aca9d97f7e039860349e2c5968917da4dbd713edf5714aa75deddbd6d44313b690fae5dfa31a375d6740ff09a4acc9c0bee67a289a6daf749f8a57beaf716f95bfcd2e63af5376e17340b8de0f5aae31cbc3a8f23fe6029c8e69a488e1f5cbbc053855d319ac07f4f7c9a569be46d10be136bc7562e46cdf91928b34d48161c8abfad672c495905e295f1a807813bc933bc4a70db2e5a6a025f6205c5df502d93a8ba592b9b8246ffa92adbc43a0c61d23a3764971048b64313030ebdae03e8566e46a8a7ebd278ff85702d6d150f28428c9fb68da73a4b05be6b53630a3a5541771707ade258b59ad4a57826bb99fbe764d2dfa78bf5bdd9c038198e92f68603ee81a5f381eedeb2bd46df4eaab2326ec5a2944128bc2799c97ea27932acb4b92d9ba0f0e7d7c91a1522b17fd5a8a9c67411a438b31e0b4474b888a753c445acef5a4eb476df94a36c745f8c133317396727f19eaff6182dc82a26b4f0659539bc4b646d5e63f2b6fba594ed791b0b915cd89d100acc71ce76a987fca7b97dd0fbc40694ef8a4af749dd2160e6ce94bdba87006c5fdf0a7f7b7af2a3960382104fc9a2cf4e9c8c11c21ade874a110b19dfb31a08376738d00f991f52e6556e9862f856a66d688a653e6cfcf0023106ade2e3091b4839b07bf903b995de0f3f366520c37d711fef51d8715e3931d6f3645cf7cfe81f5bf1438724cf20f72728f5672361fa9a9ac59957ddff95a66ca46a4941f9d56dfe306bbc1f854f4cba8d78b97da00eb8c7c7d528e7e001e8b80758fdfbe1d693557546f7964ab2bfabe4c3d1ce1a1489f1d9218f154f624213d997840bb3f7651d1e8f880be985ff379aa962f08a6464c5f244aaa8ff3a6ef7379df27b92b37fb8f5722b014089813c509ea33ca3e322bacf03620953441da75eac48e496352113dfa8f12c1eda0ebe04e7c4667cea727df893d8c78a64a43f5b09a068d9bf11e480dfa6d2f160c527e578f8c0e4975132231368dc90bce7dcf9b3c978a51b68cfd662f6f70e63aa314579fd4dfc37d27aee9663da0cdb07ab603827d8f05890efdc79804b8aa6cf8092b3591427bd201bd926e59951b22bde227361ca984fc56c2ff1db11905894652af4f25b94978beabf8702a7ef8b573eb7ba81f333edd44de038a4e1b459585408596bc2cde04a8a8e9e955599642bbbe585e9d8d64109650a5b88936bc852054fcd1db02fc8e6b383faf54d4daeee080323e8c35190cd35b553ce62c0feff30656e5a5452294596dba707c2f7b98f1ab40019da0f18dffc56392d9c207094ab4b0fe2e4b7820eb17c9e9a42d91fbc2e184a0858a99682bb4ee7e30b21723e5c1f3352ad67af0d78621fb4c9f0d9c1f79cf65ad8b97ae4d6cecb30c8496d79fabe1d950a371fac0b6c30bba398fec63d13bf3b775cab0011610315b7419f4458136aac4f51e8896cc520daee16a3d5c4c06f9012593235747aa078a5b5a1c26de2efa1827256c8d956f29c0c5f7ba77737d0ffa36594f74ee0e2404613f8f9f5472847189bc2559bbee03701e8fe619844cd27d13a0ecc56835d405c3c8be5720668a166643455919c0a2332bd0dc05e0f3bdbc92231cbdeb60a527147e87dd6d654d7c5baca2bf2a9fa7aa664bc1a8ea5057267fe1a04f2b1e2730f11f47f12d5f1bc4a9dd43646aa61e869962e2d62e2937a38e71e33380f72a425100ac1e626a79a973ec8575be29efac6f84c49c5a0ee84d1438863e0329acf5b4c83be40c63c07c1990459ecb520f70c8c66bf5bead968788185e0de70cb6d03fc23df0f6a26c0504417fd4795d59315e7246b53726ed96da7586f7212f7134c387c1d30d81dfa325d5bd23d828090e745aa98442f26056be112887517111979f7daa60e455a1e1dc195a39cdbafe5769a968b6b97b68a17e9d4b671132cda979b85ad8e2e7a37994f0b4493c58e5d8310ff9bf3cf1ea5856da4fe44dd912f9b5eb7118cfc86c5d843263668a38ee509e681ced1ea7be1fd77f506c9086720b56e2724692f4a2fe483a96a79d7459fe877f99026e039c5e508a6521f4d2214325f5495af61c46dbfc53a9c5c9ae37e5e35f28bc157eeb6dbe369da7e4356b3a986954d5cc27f326d5249efed5bc61c58963bffd841f39ca3c2db0a0257e47fe9384515d7bf20aaa401bc3f3417114c1ef57c3473bbdba56898a39e202f3b9d38771c97c9c74373c56f2493194fe0fb94a71d8a904133cbe2679506e462fdb69447647cf00674ffd2e4141cd10ec279ded73d64764dace55ed495fe5e179aa462526a96b44d4307881a0ccbe10e5bbd61c7da478338f3543d271f5919c381719a939a223ebd4e0901319c29cddec7d2a26a59c3bfe8b3fb85f6746c80344750f0c5a3be0806fc8eddac1aad9223a01a98297aba61be67b4bbada0d7ba0ab05bf0dd39a8474bd944faa991867057556b293a1f1b1a8c7751ad59c3141e003b61b52246e69480ef13e56110426a5acbe60560eab5363ac020480268b5ce00c8b79987709b4498dbe6ae05cf9bad2b0ad1808072175ef3ec3e461e2059767324d8b8202da9ea6efbb43cee1f324b1e4c7d9fcf647d9f4436b498f0239770c11878db51ee7ba701f5cb4e7f33fdfd569acb50f0b99ebe9ac04509d4ee30f49e758c044994a4f4f71d1afbd3894038b27631c658887be8a7038942081ad2a0e8f69b1cb2e11e316b6243a3c5b6c45541fe918492bd3f3b4b17cee27e553ff9b3a95391e338f230627446f23000c54007c659b8aaa4c1e4061daab70543f64d7e13bfc472f65154f275f4de5aa8fd03841d9b9db80ae8a5edf269cd00a56914f6042462c3cd650ee940958e53e24dd42436447fca7ff5c538cc31c8fd735623da2c23994e8dfed63d6c05dc1bbb49e0e9a4ed5805417e21c894b8be1537d79d5f9831fcec11a360286a13d40d690c98dd8a169a16045cb122fcb1dad9f7cedc7d41d58c055d31eec2eb1e61758bc8376a4f3efbf34c354578719ba6d57b6b7217340f8619f5e8140d8f4df31013b2d2020cea1841a69e5e8b65c19041512a7afe6d6157003db465c2ef93808b605a2bd65794466f2cc2345f302238356bb4d23a017b38051809d4a3e7dc4a4d8ab1e590ee56d2941d6327884bd5b486aedfd5b2e3c4d58b152c5fc7db11aea5f1971e230aeb2547ec40784ab1766e030a6361e59aa64625ab5982861b43d27eb8f0adf537c916f933cc12f27537bafd004e108070a0ea7ca96cb62415d5405a809e5a9ff36d7a98897db8374b420660259b15b77e49147e4eb7ecbe4bdef0869a2017b5365c4f8b4aaa79b69b90124c0cb010f7e22b7a3aa6cc8b959cc132928c5f74b3ebabc7ee185acf3ced5adb246a6d132245fca682ea15b797cb55a786631ca75cfa447891be53495e7f0c0f2f601beac8d1ec9709b133d6cd2fe026d9d3e9109499a26bbc79be9bd6da550c73f96e0e50de44fa5a76ce2f82ad62604040c7eca02a854f237a057e05f288659aabba13e0d482798cdb6ffb681ef147e29313b17afd2ceee408cf647782a8826857977111fb094fc1238fa660fa87eac913f622bb1121dfb4e378100e72d7447f5b4b638164622a44213085fa457555dc63129487091167badb219a7cb40ba33e05ec16d897e3f4c111d95233b58f0d11610f5d726dd55ec3a44e42abf6ed78d7004a731a32f03f5ea6f9f94bc6ca1e35f943b38c28d299b1009bc009fc061f2269f4c302f6c3d554d75dbfbe592f1fed9005d1a3ad58af1f4cb020d33d6478912b7dd1a37875ca59b10c595b4dc8335e0a662353bcf30c2b8d2c18ec9c8e617547842789c53afa1743219cab30e62ca5926d6514141097f26c0e709c5c8c2ba0f07edaeaa91863ead6d1bbb559e2775bf1ef5b2f2ed53e210f49d95f518c74d2ec7afa0efdd4c72a2975962da5256647aca3127c02eeac9b9a0e143339c592ac1f9ecc9a1ac5319c4bc771a1c0d31650ec73bca3d8c852b635f12716ecb9477589bad31c7725c3e1fecf3dd78e12c1008ab7cc6992a523fa14ce5eff22f79cc35b3512dc791498ef8159c0b63085bdf03bb9eefb8833f2365e2bf13c8d61753d9c57faf3e84a92d0fab7f73a3806d657f60c558798b43d4c61fd45a4d21d675e40eb572ec2c60b132388ee9bc52b5716decf4c15e5055802e49a13133d4ea1934d2781282c57b503f627d51546d0f001fdcf37ab7d491918cd2b07e7455baf9f392aba6a031d0f43ccbefa8a88fccea54bf8e85ee812d4ac69806ff4f8af67ad8004df130fd7a3686e5bb6cf705b93a7640e96b02fc7f6d157ee0c46a31c5adeb43762bebe9c1753f477ca0dd868bcd05204034dcca6f151e5d792a00072196040ef5b20e63c0ec3859e318b15eb2b47ef1ca673aa3c37de8b8a31b37250deaef41237a41af3a39c8dc0d671fa44602e17dcdc97ad14d4f82acfdd3f0240c1a7fe71284ab6748e46b2f03a7cc037bc59ec3318010a61dab7a89c51a8693b36c86b7bd58bf92a98273c6fdfdf607ac9e4ba7f6f34d2290f540a31f96add9ef97f3a6f1b7fc98553c695c18a1ebf22eae589012f764d654e596588d21c65a95c13cd44f1fdebd5e741375c0b0608a6687550e63375673a45463c6cb67dd35c4158bc8b04012a958169e462cae6f1e6c36ebaba60d501d58eb20b4e7c8705b064979e3d2e78c82b8ae6e3d5f1a21ad0e3dedcadf0ab7bc5c22d20955650a7ae4f9c8a4c17870adc21dc88608c437f7c918c53ce2824c7d2f0c9755c76cee15fcd6ba1bc2192e886c8a055602cc61a4eccc6fa3a01ee43ebef29c3bae8164d4a5645e762d239af483011f8e470895b6938aed0038852d39629499482577f5f088433e8b76f4517b3e9ab16306cb2fdc8266e234fe28495e1b06936becae82b06ceb4c996c0da63eb6cbe6dc002efb357a4fdee301c53f7ec8d9ea7a6c62a9898e3c3ac25396f036c16d3366d048973aa3c1969e39fd10c639e058debc8728abc656feb848bc61d7c09e441a45dfbe6444b23aec99209f15ce07b84af4c422180ad3774549630e2b6eefb9e3cea8d19c70739f0d923983cc325ebfde010d18776b5161b630635f3a5830274dc588f19877f9ed96df54023ccb92536c6e01904c122372f74b78e6f7c765f0ad75abfcba0c89c5d38f3d11bacfeebc921a0e4f589e1792df2f6179ac6ac11a86d88aa2ee05d97acbde3c84b79c7f63aa13ce70d0d248964da1c187f8df950346a4d0abf28ac952218953f61d0cf6e4bb1652a275f8a1b00a5cea7c4029a7f24ddedf883c45b9c4c31bb7fa246ded26e19eeb5d8106cacafce54d29a98cefebec9bda4ac3decd059e3e2ef7f5cf265dafe41e7032474e6d387034738441f4c697a5b9d1e7852ac22af656758b1f76ca67200d6a3a529c1ebff4c1987decddc7dbd97eac179a06810c1c119a3b74205cf2a56893857ec61adffcc430e26ebd376dff89da19cda98bed6c1d8fcb7c5b85ba631cbe7d7e2d638df605cfccd7f45e7a4fead0636c6216c10d5d303d2131970741de6df9d65165a2af75887a2446aafc5d0eaadec511b77d6a9de39aab11f8d823454621be7080fcecf67d90b2d4ea80c07c08a0a3f4e6c90bbd26cf46c2283a8da6728a44d15842c3b858e083d3c6805ede7da504969a7639253bb394663b436975e18b612aa91c0c683ec1950150bac1edf1fd46539cb3152d465c225aa984ac3b340d50d8d6a7018568f81dd849f6e05fd74e00b561549ae381eacb659584699b63ce35f5b37f4b15609bda7906fd07e5135e476c15602567011a3c4e98234d10c143db6cdd4cf68f536ea961b0879438fe7bb7253b768697ffed343b8134a07d63b86e94e9c7fc65e679bd1dfb946fcfb1b8f54e35e29c91fa61caa68548b0be11979c699beb8ce5b048b8174bb0837135f358e5987df884289dff387800399f855165f3d5fa16272d733a8bc15155ac3c3f6be64a9a11d1f7b09ea0678f26d013f49a198140e4d1c02f2a05a854bd38d00fd8dc235e7ae66fd32b4b66d9dcd3292142bbb1688656d852d8ec7dec0c9fc34910bd6ae6543674b7f4ab6906bf8d97a65643df28ad971338132c7f94a0fe1a809e2856f41cce9fdc75e0d436803b87f91253d7e311a382ecf0d2fc1f70b91d6725d17e28105d1e9b9b55c2a2216a53dac612ee62c14f0ee961cde2261439f67755aac00268317d0f177578268477f7a2afc5e3e3e2c09cb8d2781420265d63279c7d9cea3dab686b625696951c0103b65012972a81af702aecded4438da294ae52259eafe1de2c894c0a4e4d27adf92191d272f6d469d5af85cb03ce88738b9337a99af7c2107ffb606668339a0b13e21d7a7e6b0e4321c3f6853ddeeeef4118351a6b7fc5b58602406af82f385770ef34389d878b03e7dda8582def46c6043a9dabdbd18ed4e46a28df8d9f630dd58e8fb64dae8bd0e4870c5ce144c1ed741bc254f5e8f021c43561e13501cd948c666ef8f7a64dada13076513c253111e1811828b6c4e5e6b67e37e424cb226b22adf2d1f6c69e3b1594740420e917d9e36cc60a2734bf2c7a0d315cd67001e69cd186b06a921d6ac12ca5f821665605e74e9666230564da328110eb2fdf0ba8eb13df0bb71cef06d987614a2d24904478b389f5ca62710b564391d2f1c21c6dcdfe4c81038be68b40cdd42e0722d8ae1e58f691c56b568cc1030a3889cab069163c24501a9d570b7f03e34373cbda2d43ef99ed2e290b3761685345b3ce40370264bea4855737d6e3043497af04b4c6b19b14fb07fc9f0803d0efa4965f3f47c8308eb42236725c7d52f66dd4fef1dcb048f558bf3d00630ec567276dea830096ad4682d7bdd83071f852e5ede4bc6a232fa58d00aa8c14ff4ac8744aa0ec8059f448f1231f60484d6de9e93c5c9696703478b091830bf302e6490e6d4fd0e2880e60221d3087ee0c7a1d07e2d83ea04fabb2b6c89ebadc9e468e21dbddfb99d2c8b5e4c8c048a8e1e846b1976c45212b36c4da9dc31e841bfeb05a1eb497a2997ed41f80e95bcd0d67343c638baf5477b58118f19b422efca93e47fba85a18b9406e60779f7a74f1614a9fc3ea86f955ddecfcefba728dc376e745538159492ed2354519e256c108ac49edacda6244c8c5aef7eaf7d3ab012a66aa0fc5f4cb6d0ad1a51059fc8ec5979b13d863fb04842210cdbe74b03c0546ce32b6bee2ba9ad60c9fb8e800417f888df3d43f7a1f02f02cf130523af6d1c695bfcaa7d52ba043d3827660c09912c641b0ddb21c9dfacaedcd63e7da8c3198495a5c7fef9591d0ee955fa0ffeabd931a958f8af674d9f82cd91ebd0ab2d27731c1e1a10b180ebfbab91be2da704718788333764e1a56a87d946fdb68b6a923144ea27d80e1cd2af5a06043bb2b28acdd68a038871ae93904f0c0b64cc68afc055b0275f6ff21b0cd8998af195cd4383c153517ead89250bd36c85cdb9654e7aed4f893eb70a71dc4c3f581f3fd46160ae11dbf7f47ede753e90f343de993acca0b5a28efd0a07680cc7f1b151bcb1a6558333c4550a5cc09267db70c4934b9214de2776eec598dd5d65cd63335f811465e11286c6ac52874449147f3a4c9cc5e101a73a12a7ce52304976a3321e35fdf61d8f7fe8ef0fce7d99b572b7cd80d5bd2942190fc475acbe24887155d327fa79cb4467f34117026d27b428b53195a2712ed2370f6ea42b09fdb751e316d635755fd10e8ae31fd1325b2980ae1c580c67b5d3afe6e51a92da39bb28081db30de83d8b619b29ec32add2df0c3878054ea513bcbb7fff7df6f60316784881e1e9c4492e94e45cd3e1ae39e58a52b9806cbef817ab6e01eccb7b5038e80f2cbbccdc8309012146384608e1d0a307bc07d0868cf6effc982b02ced923a9382e6cff3dfb2d22e79b2e4286840952a2a0187d8b6b055eea5abc8f44331efb91d2b83838d56587a34598b809ae506763daacb500b62d74689baf8cfbb36903e052ef57655a9d23b725232414cb4f1809af16696e5134daa97b6f8e1ac420a9c344a2ed6d3342d3941a67f0f9ebe94693c01fdab35364f84cebbd15114bb12af3de97de47bee004c0e870c401fbf36b15a0ce08cb1c9a7a0e371d7f7b6a8ccca71a3ecea85e945da1fcda4728fd0b07c419f904097ad3bf58125734c99dc00a024850c09261b8dabfd3a02785e451ac6269b7eb7bf246b3c7429b10877905502221d76b6f9fe2fd0ecdd16e3584508b07962494790eda183e702b6889241dab9284a561b15ca1f56f999e459d163076b7d15344b495b40b99291337dcf6ac8a6747047dc2e5fc029dceeda2bc6ecc63554612f014f43952fa40b690cb3e6dfccb76d333fe7a8e9f69e5f40c4372293c27ce6647a66c7d0098243ab9531ce32ccd334b08d1aa168bba9bfcb4a50796577644c9a760f8ec45646ffd059603fe1d3f30afaf5100223633c604b09a4e728c71f48d822df275713f280a4afa6ce023e60c475d6d3b014d0571eb87138450233a0a9f4099da7a575982f2cc35cd6806d4f81e005b339a6acabc0eff83a96e462c4ae1709693a07c00f96756af3b19feee6263895d5068144c11a2a00ed921022429980902f062482332299e4c18dc02322375c1e8957cce20fc56dd53b751d507b8dabea57685fcac88f7063b61af59e43b4937a8ef70dc9f84ef6ff5d67687519e8fdc5d93445436ebf972aedcbc65c4a259fc2bb3cf28107c709f63cadc7342509fba16d28a52158ba802f77fc5c15c29f4787614afd8b520203a0ff776a4fada971b5ba4bc995ddb543fe6c3f0bd9a6d69f52e2849b71493954e2749def0aff477eb2f479811a11ff3e03b74eeb3fc6a0fa4f46d01524e0e87d29c178bdd0256b2ee0ab52b77ae75522241760adbdb5c9dbf8461f81d07bdcbc18e88f3db536e93ffbf5c80d3e2c4e18ae47fd9fe45eb529011284d14ae018638b86ed30a5c09e8e378df9e2bb9d002758bf90ca76f16924c3b7c50fbb77fd18e7024e62d825b1c99a99416cbf7c264d463682ce1bdf2cf2953808e88484cfb323aa3db677802ac1a24a91cb4bf36a3132386dc550cab7c9a3ff3a0b1fdcb8d162af717e66d0d890b721b94981b518224580a1f2eedbaa627ca26ec1e50c123a960c93019eed106e340797ddb6e89d051260a4fa114d669134093323aecbcd3708357ce4d7e5cd0f2d68ef8ac916696d4cd18bad834fa6d3cf37e892aabe2fdd811057c42ed602ff28e51e1da33315067fd098b9e172bbcb096d8930acd72e077e10240ea54530a136b1429de81564fd4997a21445e29826b5c016a9639efa9735da1d40c6cee60ae22e5e718ebbc84db6ec33c3a194660da569a4df649c04f49d5ec962766b09905f3a4193d122b0a827f859bd22024303a9dbd6a535b83cc7b78b07f1e5e59206917606f98a39f16a07feadae293348ebc27992d0abd87baf437f94c36fd490736449aa687eb69f92cc87e530c4797bd9fb26ccef3678ece26d17f40a683e37d55788f3bbd7681b391ceeaee1708c810ba3b72d804a5f0ba5d90d68271060f5b6b82817bf711f3beee9d64f38cc7a6e6d4bc4de7d1fa1eccea30eababa4eeef3054bf5a56000a7e1944e9bb8bbdc158a109d9a4dcd7b77ff5c981ad361f581228a70bc95aadabe0a88425c8af00b1ac9362691beec67a92039de81e4fb276145128779f0b952204cb1adbca17207ba08f60366c8137365f5b492e13889d3b68482d2d75707a1c8572026d9ac645e0a8c0b3ff3f8c5636029d0d02c7a15d6e073cd30c3936e8e4031f47d771f4772f86a0dc41689c62ebd3ded555101d49f136e29c25771ceead795a395014c000f462ceb692b6ad2baf68c464392ee11b5ab587ade39d2d7bea4890d97d66ea005449e74512052b4f45edb3e9495c89976ac13ed8f88a502f523ab1c5998994ae686658c91dfb104a65743a871fe075f74a3c7976406d2236c275db3bb4082aad36d10bc2b6936e802d2c84aa768bdeadaa3f2e033ee6b7897da52b59acbe9f55e4fbe38c3d9ae619f10c548e883172168a0b0b7c8a712c82a2b5250a5a3a04465ff2b1cf6ee1bdecc631f64d5daf98888d50b9074dc36981519ddfac563c506cd086ace06de4c68428e0a5f519dc440a9ffbb7fbf6dd98c2710750d6f445bf782fb7a80c059d819f8a59ba5bdb89a92ca3ef12bb1eab21556d41b19aa23629cc73901261063183a872cd3d42655c61423f6fad426f7a2855a5af24d320c503274cbfc49486f0d5f06801ebeec5fae02462c58ff315b19a590785d32528a89407fc345a35ed410f104ecd7e4bf3f5ff738e1c9634134472be3bb31c773d593a765e1bfb86f8aa9d85e4929e7de036be7b0d81ca49e4605d1ae2e6e4a79577cf7f8d384cba5ca83ce17e60e44593fc3b34627b2928a3d646b724f72fff673f19ef4d68739dc50ee5b350dbab72c956fc0bb147123191b2fc4767067f6c271d9a275f0582f4b3a44afce889c79922e98a95fcb048ecef1e084f4feaa05435942d9d790dacb49cec41e7e5a0fac9606afb5e6b89ce3eb789b4faacb1815a85bf8d115b2032333d5988bf76cb8def996b71e3742be121e056840c77a43dc473f1acdb0cd8bfbb0e385e4cb4a811d65e8e8f07dd613e4d3edc414895e633d360a9ddae818686680d6b6ac821a694d9319ab6ed68845ad863b61807d51c088c1e16a82464a56af5eca81b0655f46d1ec83c2f22a543c577422fd3a7547b7c7d4907ac33119068d452d8c9996e2c1c20f5ee40dae271cb036078518f64866be660a8f3fa233dfcdffed34e182adc4cbfe8cef96ddcb44974d1974779ebecf574bcd9df7e71b2d1d4c5cb5b3bbaa10e69433d99885b52e781330038b868f64c57e9fa77b05cd9fe94b9ff74b5bbf11a7a87740bddb06968cd57001a8697f54f56aee5d94c7b87d94342cc47466c45a75ad3d013ab225991af144608e9b4d15d9bbc4d4cdfc52f7ec423fd6647dcc5190727af90f6bf2c1f49f6dab365d7b36dc950ddaa68719181b8493cdf47c14cb1c60a7f8bfbe047bd83307d9adf30ede041e86b2a3be59f3f6b511f423f0837cda87f4f19c42aeb6d4b836808979cde95dd6b22556cb311105bb1566e53224336bc2b56829248e1d390a47a0ff0c620b6d26db6b349ee29c8b8e271eb9c6f6ec144711d03fb69a881246dfa1f71fc661c3508a10417a3ab266f4e75c64f92d465dafde3d66de4fd47c2b772656fffab22d272fa0e9d749b0362b7ebf4074486832f674509ba59bef14181e7c66ca1ab1c93a3122ffb2f4cd2317a07f520d7a32d2f07d5c63de2c95d4cb61f2da88d2950a3da1cbcb7e41c90781266f257fdfefb40e8102b0b18d0f5b7abb79d31d5ed488fb9b31cca6b60c04617afdb4fee10754a63c8a20b5f440c4870fea51811ac640ef467f549d52e4a8237b35de6c859cdef481c9d3b7e000b5ec3d5abb6a1d9f2457dc5a441887f36ea687fa10c1b67e41bf64b054f076ea6d925384fd175b1d4249cae19ac9788c5dd6e9f373ed8980c467b59307de5c2fe24619510eae7e2a5b8b7bbde73e2943857ab17a05bd1037bc7344f722f7b64cd65fc66c8a0f0ef6fba65ac041764cc65805228e0e89b8ad29c99f7296a0c4e35b5857d7da5521bc21edfd216e5d1a96c2cf8c6edadc8ea44bef08a9d1d03a46a5a34875bd1b28857296976ce6a6d7e9a17ca471e305e6bbc00108425fb848e11ac9ac4c1e4b45e7822a2292ecfac8245741e811c25561670a0b23b39a2e0284a253bd2caf3ff845f5247bf134a5c0e03ed67450c19bd167ab8dc4bde63091056d71e98a37ad13b17d3d753db9b471728983daf64af51b043980ffc37b3aecc2fa16ffbcc0a93580e4ce9d79d8d20c47cb3701f97d45236a2823462b152458969099761220e7306e35ce90d4fb2d6231c2eb72e5f7a10a79c6ee55c1ed95aaf3f550c6e1abe1e663ba7b886962df1b72dacf18a1b3c03e9f5262215c15ead375ec28b616332b94d9f3fd8c443973c13cd695121c08891a21be9663a0f723c1a80002d4ce5f8686f1736c99db0a88e581ab06f5412916594a95a8b709f964f305fbb9336b507cc53a0c5dff4498367427b50c42ecc07b2c474e02d137028a60598f6ce7f0b10e45cfeac380800eff733bff2665234f7ca8b8f94f7f3a931d32d38ea5318024919fd02a7bf77633c910f5665ed4bbfb2144f532403ef7568a9497d2c91ef51516475d992eefb77c0a5c5b4f2bde0c90edb290dd1f61bba173c4ecb17681e6c3b81f24ebeff950eb26a228765703a2d62f3e25d2c0a7767c1585e17555c2f198a16755e8f40b42c2354069d74f27793130c6b362ccf910405908733e4b378ae5178edc8d3f1e098826d783db7652030027b46c4aa839e40656bc947174153247e39d3f4b7e3e63254bdb791820fe227f404cbb4e5f9abf6cb840bd73d83ed4722f6eb995f219718ed023342810e8bceef42146c7b7c47150d02a668f6f49baa64ff6a5e13a282502a1e7169e4532da691c2b94baba1bdf9bb571698d9e9507de83723b1639ce36e6466a4e00ebd5d2e4ae5fac3bccd629bf00cf4efb3c1876386babd943eae3d136774c938039a41b452eed333db3bd8fc1ec7f1942dc5d133ed477a0131764687880e48381414fafb87f843cf83b53d39729961cbf3d842fe42041d24a960cc6b5279d2fd7eb49b415fd48b23502385213fb3e577a43db7ff830195fb1dfe9e447f964d01e6f04946cc5a418fa28b09ec491110fbb77074b63c15ab3a95ac0f7a2ffa270b1b93bd1a0465fcada0582edaba294a5a41b4a5700741c636219030d23a8009a0494a7bc717550744914478786611aeb63e16d9a31c4aac403b2c540525fa2b1d21ede48f89833440e9403e9a9b9ecdfeb4ee37cd6627557fa3c855f98f2e96c04a866c3707882995ef913ef4bdb0eaa1071d7f660d1c0732139d8329f2f7788a089b8894638f61c4d82e80fc2bf4d15ccbf2a8defbaf6983906fa89748426d2854ed14ff0b4a9603ace690535a3fc5b4bf2aa03cc87bd8d61a751dcf39a0fa3fdd77e8fd4350145ffaaa63e5ab225c6e7575192c9c0ab7d9cedd1350eb1a9dcf6df2f731eda3011aef4c13867009c7db1778b7da405b69ff09e1ce29f917fbd1bd14cb705e340ca88bee37d5cb4d8b2c278b6b2d162c27dcb0390694c997fcd5cad9ede1470bde5f7ee1b6d75d1efb7e1636ccb75cd773b4062edfca65a17e905df378f13befc6662db00db1bfcbd706a05869ee3d01bf0a2b9c3ebb85dfd5900a68bd10386f29af8f1a14b6fba339d9a744a7c7b18bb9b689a3e8bbe74c4bb6e91499f9c9c8f67cb426b6928b1d248a1a1380008e6b5b1906ecdfcaf5d4cea8dce81130b2ac38bc8853da1346995c8ffd4113c5143d61d9a12d2f92662c51e71631b31a334851dc1a89616e9829f401e95cf17ec27001672d393165950f2cd3712bedbb68b00508488ac73f0a996a7902d3d43163b80577ceab2808597dc168558f22ededecbfeea34a11bfb1ff6b477bb5500df833e9200ae7cc74de143a408b5710a1bee44524e833e96f43cac8c104b28880ca5a9400cc605d4c61b1ea3a8d4cd14c88441d4dbce1f43d1d697670906eafcfeabfd533759b9620f1543cb53b05447387fe0d5d3b98b002c2fae802270f51799870ca81bfd6442005a6ed2dedf288810457cdd5450eefa53a8ec821bd0c5cf7df148fd756b388359402ed7eb670c4f4c149aaa464d28003d16c87abde67fae46c683ef873229fc5a8d94debbd13b1b91b5652d4559c6b01839d50c25e90bf8e785301ba317a5357f790af2d81637fed8d3248e44233226852c2d018d375b80e2d26a66f4b8ea00f93805dea852e37e5fa7ae0f29c293fed634d46e3ef5d5efee0887cd62fabea0c9a38089472108fb04efdf43bdb2d8625f1914cd44c6bd876349940a12f21e164f83f198c28c988f4602ad4b28ca09bf61badea4cae9acc153e1ca318986bb11f27bab287a86476c0f28bfe96b57937510fa0134fca25a3c8fa8f07e0a0ab45addc30c8916550b1dc585342b9a85055439badcce552ad85b6f7252dac58d2a9f086eb5a5b461b3e1820c8d041701467e1faeeb43c05a3ba2580ac869ebfdbcea2bd76020fa9128d705270844d602c63e9384e871064cdfad66b9528f1d28c912e8befbaaa5afc58e5d4124d63af768ab7cf22baa3d83e53d16581aa218efe925e49313af42f47e9e37893578e53784aebae3a887a9ab5968d2eaf4d94c30e9658ddee82c279fedd2ca9c024d7f276e28d93e072f212139be6dbd509391015c9d4639da3eaf95e7641c603bc00ad3fa0209360f808d4555c9ac3d2bfb4f9610fbb9eb5960a49582a02398ea6407da9fcc64ebd02d0b2e8bbc4644718a22b38126e7b40a744d417457ef0a6b0240e976c8358d22d85990f2cbe8ada6cef37a9af810a54d3b0270cf69bc0eea254c37c79631ba78a1a2c579fbf97ec6bacf529941a23a692b781e3e947c3b5c6cfd201428fcb711a11f04101010497a020483047038eaea189fd66e6519ed79842e2a41351fa1774e267b6795fb7496b71019d3f566dbdc154b4e4a361c89068431fa66ec923c4805bde86b0e775bdf18d4e0c0a6b27d5a389dfce1b6981c7f3dea0856f485f5f97e66d6b0fc605d0632d87411138617e8febe83a3d715d2b303de96ba4aa97751737f6c32a878a46ea5e40cca8a95caefab170f90bd493b34f3563d2389759a823778e5704bc2ee23ae24dc2adcdc29d429f475512a66230f4c8ef159ee5adb401da2415c6c86a4cb35898e73bd60da67e1482eabc4b34d78439f83b77314e70f6df2bf90f7fab46fb0250294390bca56664db010557ccc59aae76de896600501d5f76c8fb6cc028ae4d5889241ff2fa94637f3eca1cea694bafa20314598e527157f5c99c14dce548a2edde98bd3efdc37c3a7a1d1b43b7c02ad9791dd260de67cc343ebff1d5c1dd1eb54de3160794e400c9fe697410e286494232e9b847af6ab5c58df51d5892e74b5493ccf16c24c5f3085963fe20f834609a5e8d13a591d0929aa99949b33a03d9e37d4cbbb37894a81a90fd2e139ebba2821438efc09bda5cc99e963c16e0d2d3c3511cf11a8960fa5a31360e6cb4bc6b863765e4aed3712428584c2f817bf44cc3d754d7cb9076ec8f03e5396f98677852fcc5257fc9ea37891d10c4e5e60c7c79b93818971bcd681119307f2529ad320165e949521dc134d8d1365b8bd22698c314706d0f073b9468d6e9808ac91511cb003dc6dae581ffa24571ec3c3fbd2b01231577477b026785eff88237341296b8b047766a1e0b7613bbdb2a66c25585dfc75d6a26e437da22fded573f4adde025c91dbb9ab786becbf9789ce969cf590ecfbabb3ef3a7959cc01c140518dd5f00a8dcc4c75b37f4db7900237515d90d3b61b54268524f19c02d2b3ac823a0d96c461ad48e351fd2b932984396dae6ce400d761ff10b3116849bf82d79ea59e14aedfe6ff6220bc2fc7a276fdb002d4ec5b5a4c579f9aeac6c8638738090039ef34d863a10b7e54205e23591a9dce2ec136234ff901d04633a211cf3e25177eb63b7d985632e0ad59175b4f3619e45f676a0ed2a0089c08fa80c8130aa6db6ee1ead406948be6af7a5a9597309a383413e3c96322cec5a3f0eb8e8094cffae1cd05075f6457b62435ca6cd2f2bee9dd3eee8e881c70b55852f7e3fb72610714d4ba419bd6a34aaca23a524c3fc5c606b5402b94dd002cb963496f809a5547249140c3e1d30545914c5cf3c140b16e1a7f7c65b7b7f98e1bc99a9613e8758323150fba43c002800c20d156131ff226878e0a211999cf101f935405f58d24334099950cf98ba9b6e423ce98c26ce043ea8874ef8c0aaa5e69a2b8d9bd60558c8cb09d53b6967bca9f6f4cd5393f0bfca3b0934b8eb442652e230378bd19d17714dc898f84185b14bd31b2feec64d7112ce97e96db0dd80a2d3ab60264bc4e90f80d5a21738c9cd211aca869a8f93359afb9a0135ae4006b17801c4f24b57c93b30c4dedb0411bb6d0414764fc28f8601e9649ec3f54cc4887ffa14242d28e8ee5a74513a95d1eaf45579069fadf3d5172489c5dda35c1262cb1bad501503f4d5fd595462d9b9a7df2c04a84f52454d2825e685210ada7c1267e1381430ba86ab73eccc94ce916465cd1fcc653eb780ffc32625f83700198cb36535c8e89137bc6a52e1a8b6ddaa8de5d7771968a3c13cfd391e77ac9b91b55d8e9907095ed2d37379d16ab180b7d34a9fd5675df60f0c839f7999e944b64cb6b512fdfc57d1fd939fc1f9368935c3c6c7ac3fa9747a79e7b8d7e110b5781fb3566627a3d32331cd981d71b923821b67be5e143fa4b3d8962521081730bb42375c48f2c479a1281f67c45895353a659367ab1a606db97e1f4a212258a7cb6e87c23bce34afbaff2796667c2300d6e53cc54e116b48a15d10f0fdf19737011d34ddd595a16c310a288dd4e9e6b8e7f6bbe78c1a2eb346c015065fbd73ab857d963ed3658b5b7f7527ccd2ce366a9174659824c036157e62121269365e5dbe5dfacd7d9e6ff838e80c289c8a3d9c7c4aa3aef19470557f87a844114edf14a1edae2aca04df3a81232926d747cbbb37a14656bdfaa75572aa30bb242b326d7d2171a765f6b31a4f8f396bcd44da6083067666fec6f4460b9d5596d9a8e5bf392d44bdce7dd99326796a3036a8e78f5acd0b40de679da15294e5d13bb76bfaa5e5451e02d92a507567b8e51bc862935cb5043b41a610cb7488638b246addc3080aed14948582179a24b1a49af37d838c916f264870e770819763416bc269a1e261abbb5e9d367faee95da11f1611ea39b476a1b16e4f41bf24c4fd8de099fab6ec0ac14ce41d09f8f9e6fed2bf83d94eb387f7dad2eb5e7655c638ac872e543e5c9afcefa8d8414533834047369133cd602cae52a6a83d42b3bfc456576bfc344364bfdfc2dee7f3560e19d128a6076a233282e5d8f5b8d680deb472eb834484","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
