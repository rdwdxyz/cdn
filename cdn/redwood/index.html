<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6f743d4932494e3b68aa8238d4f6d0ec12541ea569c266682b2067f278f1062220189c2e72f7949344c114e595df7b0f05dcd4c216daee70b28d688eb7a048f2a808e240031a93e02305c27999fe2a39e1453497babc7a5fad3be5618fd667f52cc868d410d2b36205cd6ce1e482089ed9e7ed16b079d23e6fcd88998ea7a4a62d3162f18207a605dc7733b2033e94b753c2533fa13fb96e0e176be2f927efbaff4015316d128ae34b8ce2acdda7418680c9ff197ced4478e22ae9519a95e25f5849d34af9cf573220a27d52746ffe74777246266a7dadd30fe69f23038267dc947a5cd1f85a6983fcc1756ad43d485e5253e8571db28df5a7535746a52ef9a55fdda34ae5ae22035cb41aee9ecd71e54d4b15aac8146e72353274de1481ae66c3487ff981e30a7ca3a948bc12234b9433e4d1de51dc0220238780b1893e1671885bf74f75e6e639c6cbf6dfef4840aff26de04d980586bb334095db30a67b5a81a76ce6c361338aa8ccc3d4a67063ddaf575be7b505e6ae964ad496cf29a8f74ee39d1b5938ede18553c8656bbf24736774df95bec9edd98e333225210f311acc72ed6d26c024125711bf1404f4e17b720a87bc5d0c6bc25ef6f1c80912690f8905d8cf64d99bf40225cda54be56d7dde0617e7f997827b2f99f2dacfd7aaa3982d01a78201e433def46123eb7aa2b75614eac5b3cf6fe8bbd404514e09007f35cd876b540fb02bafb373ca78de32514df2cb33ebbc868dd0f1c8d1ff989354aa9ae53280fcf697293a63a3dbc83dd0f5d6d54a432024c6d60f06b538117b1719e28b814c457401f69d5b1fa04afb7a1443c18df6b6906aa85ac899b04c18629f2a87b5d8ce6a437b94bccec6e4798be601b943c14face17978439e5a235ac8ee50018705cee65245ec562f7eff3e5533b0f5af6503d81659b63574265d0e3d606b72ac7f3d86933e0a9c517187bbcd03d5f3cba3fd92722c0fb07d22a38fde1d800f5b68c3edae6eed8e17d8044cbd49947273c799a3558e27b9fcbe450cfb6a355e74e266226734544efe7b7d5dca438a00a441191924177cc0296b2926d47869b10f83a01500b86d39a061af15b02054b0b3c65a81c4b75643648fc3329a0ad754a5f9a7dc57e5cb35e116cb7cc33fbcefe3acee5bb63044148a15236ccf45a504792c0d920f4ac4d1757e82317f6585b60a677894fd89324df915ee8b1c92dce47806240d3c4a52bdd51d571f8314c7b6ad716cc49f4264ed425531f183c4aecce99e398694c9b6a882d5d347f2580c97beebb7e79b1c98254eb851e655080825fd408ffb85b13d8b4efb63388b0e68ee26dbc63fbebb8f4c8f2662c7801a0dddf1ace310f4ef53258aab1c873e0e0a527974dd771c3cd3f2b0c6f534cc790f7f5b711b78561e7154d21f32ce2b85cc0501addcfc2ce87de42a307b218c8f3d12a2e4dcb77b5561366a60f0ee9538adab701d5dc3129ab3de2149fd174bd01445eea062cb71f8c12d94729d86d3212e9326a5adb1477cb3097a10f0605d1a8faa837e6df662e3f6bbcf489eaec13f50d026ec8ec80adbc944deb73932349a645d37ee917b652fef6846d8d8eaf78c87e809ea8879a940db3382a8409917257e6d3850d90074461349a04bdef2263f8a0e4eda7d5a305c0966bda4830f1f7a478886792abdd3d24cb178367910b3abb56f778747cd1fb504ddf661d535c425a84de33b610f651ca19b1a166ce7e95e3e83b117396027c1c48f20c7374d3f6dca4bbc6fc7e69c23d135d411eff5c88d895b80da48ba9b84c0c217a8f5d9959d1427492604ac3ea64a4be7aeb6ec530f69467dc30bc5b428f240d6cc27f24dbad84a94a3bd53b6a8c79291fd2233529a8c4a7bbb9c5b98f51036afdc803bc8f5acd3c93d5493a432a967fa92358c6780e9c9551aa25ddddd5e0b3f9ecbcb24da934ab27ce602bea33daaa9f2ebb11d25022f04408c6843fabccb3fc9ae813467ac5315e3b800f8fbbdd721a8f867af14a623a91a5f0243ed63a0ba0837b4082d9c5fec77100e3cf9695856d46eb21ab6c95025afabc6d5baa9c7b2623becb6185d0835344b29555e4d36cfcc1cffd66ee95094ca349dbdf1f5463d3d1eb53b3bc153196f158e6c81a8b00755548d2264f14fe93e69da1d075e50758eff02fefd4e2be6e6e4445011b54ad2c232de78a1b9da13ce05c088f126e6fa2e829df1c6294c867d4989f68fa06e1c22024c6b65c81bd6c3f8ebf257e62b83ea51548da563b0e387e9e6a35ff8daba2f287c6b3c02628161859073e739bace5aefb7027d1c2497021fba553d3e2431efde45794f75b1435802370995826d19f988578d5fd0e6602905f7dab6a255134793fce8afe556d7634e1bf870bd780f3d5989f2dd27c2b489977150f62b93f7a62eea3310fd682ebb7526b3551ce7aa51034b7dbdc710276387e9c701309ff2df0808032ab7ba5c880472a3c322bb86acef61b1fa0d78a7c4a082eea2190e1cb3f0aac9dd97f69f4b86452208b294094320972988efecbdf565141d135a82d6341d0d0530082635c309039f43360f3d927a4a0ef6a73ae34a0c0310599cd88b2d6505f895a4a7ad633b583e40e4e5a1ab445aecde80339b9553af99a73000d67507b0a99bf425a002a1d9cd71d56288086a27fe5e00a25746c535ded78bfbce26fd57414942a6be844b8b07eaa7d484fb381be674124a02fd055f34e036e688f5976c0d93f2f26872ea59bce0ff1e003f6cb2bfb7e06977ca0bed2231b05c270dde3ba94b23674cbd6251e21c7cb291926c4d85c5ef3d4a4aab8afd37509b0c4494ac8fab978e39864333efd8b228a51d95796d777a16ade83a6fc216ac478d272a9c7d7d38c3e32e6b3da8a208c0e9d7b2a75d7177849b4d56fe4367c3bdab6e6af901a9eaf13d820295f91f65270703cfa49b64381e8f9a896865ad89f8101b6ab39b488fcb5dcaccfa8e4ca00ec5add688bca06f3957cd9dda8fb7bc0d5f6c7a49613c92ff88585786d791daba3d89958767d4aa6ea0292382f60c8f143ee025e076574223e4b092b989f08884cee7710d8da185f30f7bdb42913c1b69cc6c24a4d88d241670feb29b5f7b0609fb6974761279e15e29dfbdc087f7147a21d75cb108768b52a6842f77f6a03ee71d5c467ae8b6930669f772221b5cd4dbeae5cdad152b4a0ed5a6b25917563e84b7d27f3742abcb9ec01b5c68826ddc1d58ac4b7b9117b8b7a76b883997d4736192d2032c502ee202377ee844b22ce43a78b9d135f2751937d1d310ba56cb5e3b3831082c431c4f32358df7051e39291c96f8f40324ab7ff7a9a415d3e44bd48b3c1c5c3dc729c872e66498e343b052bc3acc2e4e0b7dd2f4f3e7ccda4229b4ddc5d3ee399f2bc39a5e4ff2af1111ec873a4b7efc1069e28b8238d8e8a0639a4ec754ceb05b617c9bea8ef3815eab49346fbb30605d2e41ed604551028db43dfe9f4d3beffe1f1c9fa965e6a07198b85e35a26ce9e2f44e437b3d24bab9760a684744064ed9254e290ded41f944aad07d16d392e25f52313415cf6e61dcfb57200420a3a28cfc57acfadb2aefb8759a49e058df81902e4f0735ac171146017f801f6f5486d14d1468e077c1cb8debfbeeb6c83b6592b8e4ab4f52b4193fba2322a3a748842f77f3b0949a6c346140d2062f8c14ce232e407af06d4e8215ba4662c9c1031f99df867921cd0736f43ec283f741a974a797d0d3389364be4f04331c12b9f5d1cfb88bbdd3231e09c8b57fa190daf564fdf8a28da8f3fb3a231a5df6e08bbfbdf9308dcce39d041415cd2d041f6eaef8f04176b4f5cb5b230865c37a088ca42a9785872d1cab4f0c24815b37260aac4422b5246e7863f377b82fff39c904b4b09f5a4bec9965b83883c76e2de5a775b8e28e9ea0270254741b0da30eb1e0c5276544bd1cae7b9528fc053ea566a776de02d9d8757db81b1aa4bb76c0671b8ec2f7aacb910b285a240343619248eb1c8076249c7b4f6a1feabdce953ba3c65d5a1c70499128f2d4458a8642d770baa8d35154030cf4735f19269bc217a2e4baf147b513fbb66440f0cc685941ca353b4dff646346ad96c77f863259a949add2895a296b86340c62f0eb89a35d0e0ebb7b03a16e0675bc28136e76fd0ebb637082f9d5c1f84eed3996788f3474f6137bf9375d7aa449a81db4bc93d4cd5dbcd04038781c1c9a187a99d90a0e00f443232ed675ab0f453689bb6281ddfd16f1cfa16cc1c24f9c4b4ce92993bf12ca45bb3b2365f847263c07c4256d96c8f734363c981d0779755e73a133076f871ecb31c9d4d2bc5ff280a9dcf3ffe40db32c3fe072ae9f340db1c52230b4ed66a03a9615a4bcfbfd3e08b63421174cb7a86b75d092a3685377cc83e8dc901eaeaa44864bb75bea039354c15f80343e2fd270e75e2471ccb172d41191a07854436f074ab2b33844bb3e8731b68620a62d04dea1d0cab0b5c50810c34d5569dfa84817101860c9e1ed7cadab93d49c8799b43c1c0373b2434e3c7ece8b1746112e168ef30b3834c0fbb2dc9f595ee7b020ffac78d072193406d0f52c765413b81917b055859c8e1f661c2991a0a7fb11d8ed40ed7577cd6afa7ef1b45024f1fe37fe065b3168cadd35d9b254efebcbf82a2751917e614c575d557496725546cb5ebb87112a963c936222fbc71635ac2a0ee87aeb2bc6603068bf5d7bcb1303815a7e5144dadd436a25079b58e0712d5a7b13489d4f550c6d268c851e5f0eda3087169d9aec33c9961396d5ab7f2d3eb0682b953c91994fca7d34e4c5d4feeed5b4ff9d2c608ad7e60e5aee287a7784d3085060da47a885df1e47ed659b34b27062a0606f08b6dfbd5fc2c264521aef01e514c6042789e6c2623d51dd1a6702f5f8882aa27d9e7b89f8e13e65836d3da2affc524e60b54a694b9c35283b6bcad621c5599e1acf24bb19fa02f0ab3dc1da1eafa03f96f82b96fd4a686b576b58a60cc45ec392ee5ad4bc70342791882567bbc2696d2810e808bdd954070b28952972fae3d6588639e9debe6261dc2b61306765d64409ce2686f16958a93737218f30e57883a1515b9b5ac89fe291eeda45a9f70440df7f7899ad51274cda374605d6b734d97bb3f8345be5e27e5312d94e01c08960e325f4455cca9d168cf4869de1ffe78f5cbcb9621c3710964db4f6159f4c134101acdc6702158173cf9e57cd22135c82da10158d0f4023ecc628cdf723b8ec8d4572f6f4b144b72fea5204888a8a0599b15938122141ef83f45b7846c8bf74f32cd46703352f4558d35b20dbc2748ba7c8456738c64515812d52ccda22f8aff034ae4e9580a04c05928efe37f80978ddd49a4f01b44ce4f54e7168696d92e7b6f7d5b3f469afb703182a272c97391ec3d744da899a64c6ea309987f9e5a1854c53176278c791d237fa5efa164a5fb465b1764f02edca1d676e51615711cee7846b83f20567ebaa937c513ac16598abe5cf1beab6c417fba69a22e1649bd316d90e2ecf7359182124031dac4cf44d82b89028f2012577bacd2e6d3a1f442b2ff7f01a6a9f0665ea06102b58ba8d0e78d6c1b93d0b78cb249ae2246c046200267ab60bce4371d636a2253a2e13dba083579909ba5d8ccadeb3b92e0ffc10332a93756e90a81f5a2164faa3355be217c1830a438b326b09b2361403a90e2acf841f88e22cd08d3075a1547eef98a7e4cb18dcb613ed60dfba5a418e8e124420bb023cbaa8b3ce21b201f12ee64dd8d8abea2f264059e1628f4b98963fad2e4c0e8f975ba4d51f28add4f6687fc1e1f2eabbe3f4782bc433f9dd0ec55cf09d48709fe0dd5beece4cc18e90b83fe8346a1feb211c348aa0f1221a7c23357eb458e822e6c6413ba316600672d8e0a827a374ec702e54443e65cb569038d52267c606c0bf3bb27c8fe82d943b6206523ae7d5c7e3229c1b66676897423edea84d800064e9b3f9a8cd79adfabd0a61ceeeb5b7b83e4ff63698aa3450c280a787e452b496dc1afc090d65883b420bc50a41019d376415e9d163cc8b40d581829384401d98be8015c6c79bf4cb0a38588209760f86e30baefd532410df377583fdf86a92457d371b8d7ca28626bda2ad40350c2d35630fe04ddb9255c7ff39fe338ea81e6129ddb52be4a6e1dcaaf7f0946c2652276ae22d5b7301d1df19f46cb25c53ffd21d4c33b76d6357ad2aca8e073389760a2ac5bc8596dbb05ac7f7393e445a01d1da625400d5cf5ea00550e3f57f9579bba0dd630dd04f9ab713299c70e7284fb9ebfd83c750eb8d564695cb15e61187d7f62889b4ae16f3b17d86b26c6a7681048bdc4ae111c48b2aa78f4ab68115ef85b3d1fcd1c4924edcd6c64dae1cad0ca3ed97166c036ec1e69c316113a9fe805800c902d20bb33c021cb3ae42a07ebb7424812ac84e71934fd1ad03f74a3e5daa89a09a79d14d061e0fd3729ff77ddad0f541e65a158d51b65665c8215d2afada0e6244dd6229d44a63c75763c27a59a37190a995c6ac3d4a6fef3493fa55e67d5107cc492dcfc1c283a9dcc70da54cd9d2678a2bc858694d7c860b9d6fb824d79deb941c82d37c423cedd4ca74f5a950e0a965f85b5e8047d251ec2ef6a8806d2c30000509285f01fb329c0ade52b598df5b226d972e3d26de25383b273beb80875c81d9194d413d354a28f6293d97bd37a30727020c1c39db5dfda91a1a444f0466b4c722d6d746198ca4eb2389a712f1befb2cce20c72bbd620874cde720e7db56b164d58feb597b7dabb3190b27f3ed258b9fafae7bb392b1c94e3801d2f3a0161765d5d03bb1ab0572f8f20b5ffef7c740d143cba18d68d46ed453a21ea31eb7199bd304f700dac9baaac9cc59aa9881477c648ed99de7fadaa12df1780c3495b2634f827ba8d25f3a0d1c886e9bdd31a713e0ca7a5ee4a11f7e6dc8fbadbaa4d1e85b3a34b9d3f26a4dd55c1e90d2ecffbe51f4ef6b6ec17b4c24f6ec6cfbb86e00176459bd5c28c488d591b1551cb933c209d59cd92d79b64750566ba1570a7d1716d5d6b000103eef466ffffaab8ae653e477452551fdaec4670ac038b2961544f3f7d756a2127491534f52b734112a5ec33a60f96996f0d95f2698dbeb32d61a37ddea7b69c63de762fa98566e07d3d34d2503d5b9c70df6bd22f934e651f9c30ce56d09f4452d1f46912cdb459af3fbb5cae98612c6ffed5b765e411100b93cff01256fcd4282e7abd2ce18d92165f480e808c164fa0179632e3e69307c44111470b3d24880e070b4c4043ca1df44713684edbee24b453f19c0d32c49cbf0b32bed48c369aba8cc5fe2f22daf3e57e1a6272c77a09bd1cdbe1f7e7f5fc94e577c866341b452ce52b768f42cd6ab9dbcb201e8bd777cff28c586b3d74e52bcbce2da6dd148b00a9043c0c4f51e918aa772465e093726435e6ebd196c308076860800c05fe47c377e9a7a1250d70375532dc6f01e9a1341fdf635afbb7c3cd646d231ffef291cde06d6d949a0e9add497bfea2200b424c07a603a2bf4eed1ef20a99a772484788466333764bfbe7f34b13bef58010277001d7c9b32543b73c87696f022bf1286eddf6c28934066231121235cd6b49098a3a933c9e6e6b6f6277cd194dbd694c0cab8357bf75c860b90d8bdc630afb634812795416024f9807ec38570997bb32f381eed7e16a0c95d560354950ed23a0522cb8ccb0066c447b9eea155cfc41af707a51059b710d22eddb7af909688160079cc0f4f7cc54fd5c8520e6e6e3fed43e2e85d9af14b57a7b25e2dacc23d95f0c6c249f0de1c6abdcdaffbeee38ed798d45573591ae71e2321c55d434539ea327072a478f2b1299a7f564ed0c589b18810a38f52482feb0b560c99880b454a5d08639f0d817ff910b177d4c044e1d50d1ef69810ee51272adee096f3841ff3ba0a2507ef93b32806837c8dcb07a2fa9a909ab6995a1ebc43d3777079a52447d88116c6b19e303247f2a15a36033fbd4cfc8e7a8f5009348993e9db5124acf1db6c2ee031cc3d4e8297ec5da999774f79c4c5dd1c5a0797adc8457500501ffcfe818ebe79ee47dcfd33a2f7a7a0a856cef7dc1de788c7399de6e7906d6f4d18f04ecfcac64ec938bfa4d495f2718c42c004dd9a3f9fcbb39e277b831b8e8250619e389e9294f9a31e8bdbe14cf42b55eb29c946f49fee64f787865b0de9a70defe3d8b76beda3d5fea13b832057720ba8360c3e93c12ba62a6fa5459b09387ac75a70b87a4935effb999e55e1985c7e5c95d4d65136307ace61a5a43d1fa818b0cd1b4caac541275b07aa04beb6f2f5db2f08f2e6f456441b17b1430b030df1a8524beb830feb057df9a5c3cc192df381d693b6d9cec1adc8100833ac3a7b6db317dce2912571ef3792d2f664ce0e58265d7f70784fcd88728378a721b9959dc15e127674fa9e9af20d6cfe5447513cd9c010407b1ed70e067b0c95c222de7c558cc748d07dcce8d317a0398e91f92fb5cff5c982efa5971008d213baa2339475cb4993a9b4aa444fbf0f36be2975f91493e4b6c26a087433d16d68b22aa87f8b11220449e6d37c882c534f111bca5e0c1824642efd62874c7d56709b89f9100ba3af7fcb402511b0c55cd9b42f9ac5e271e9b672b629c7c8c3a9e07dc50aea81cfe40d0e59f1781c5e85c713a649cfd35ad3f2158cf2bacc03fe18769406f6c0732084331b2db934fe8f7f24845b2d2580a83c6475d64d40e6a75a69a470ac10c3f9bd80e0ef5d4a0d09af0e738b458f9e64aa0dcccafe7122b0e044de20c7c926a80c45d2a12481fd8b7b230049f2e259e4c9af0a7ec4bf781e2b4c9432908f695fb996d4be0e50bd8fe0d7189fced46ef88bde35a805d6e089ad2539b0fa8ea9a4a9f071e979e4c73c087bf57e349d4b64affda96e7fd101b93cc235e85715a27e9157bf86489db01c09a7d865a451eb397e5d2d9b15f0768ee513f410da981270ab0c2200b2d797a2c56542fa7ae4fe543f84c55092354956e2907162f278fbabe5a45da87a2f4383fd7ae4b0c02775f79ae0b134206de0c4d5b597c575b1ef307b003111263d1623251cde03bad0b6a72f4de88a65f7be33118c39aa6d118b516919d5466fe912371fcf1803b1595b5ea8b2e06caa9d06c7c3864e98d494893477976668673a5cde8b90f449b525c4351d9d5371675fc64c7983b2f94ff42f8defe553a8f30fd699423dfd237d1de17c85b5611128cf1597d3ca03e441607cd5e1fb0138e6ba33cd1d2a26fc9f08f9978637703b6a12a6a3c6718dacfa0bb74a27e77cb096f6a01c421a48aa222467511766c55fec222d8fc211fc787b86444d7e51dced822ee8daaedc1888f76bf04189ba1ec244752a2a2ae38c8e1bb9c4ab4a37a940b1897148b33223c3871d600e98af818b7e4adad68121ae74db2b12bf8465ca45378f26528b133a78720d6f8f724a607c4345d59134f0f36b12d1cf233f32dac423c79a328250eff494256634f4e3e259ef54242e5cec3149aa652dbe683d65b85bf9fadd24588ab01e6cc797e4573a7a2cf2b3df9d30db133f71fbeed78eaf89a457f2b7d998202e3cde02a7fc229e9a4f298dafdbaf738762b1cffd88c73c4c4217217e4f2952d4ca8c50ac2aaae522fbb4ed2f6c43aa34fd9c1afa075f58296f5b428b9ce99fba9e8579f79f81f6bc25fceeec64146f1a62cfc024c1da2cd71ca331da70d2ef43c8dccc4ce905b21d9b6a252bbbcc748a0b908a008abb07c73646849ce969253c47f99a56ec60a93a5252cc86fe4badfd35480709e213a212490d5b7431e5e3362e249014c941601d0d7e11ba90dae97b85a330bf3279415aeb7a5742ba10b21db625661c1b6080121dfb31d72bb6fd6417d737bc090590fbf1b84da91e40883bbb164014e616469087e521645f99394277905734263bfb92da52e52edbe2c9ba9e1b3da19d9bc131c4dd045c3d0752ded98f434e2f390119d53486309303103a108fe947e864102c3d96686000091f02734d08ce56c9185060dc342707390c59106d6733c6bf860b5362fdc6894541af82f975d2620c51c955f5be914c57e8d2b2a456b272c2f785411f059ae9aed32ecb03b7688a80640db12c94f59a0772ec529d7946586de3158723ef37fbc7df93f940d085ab18da7fa87cb68c76d1126cf7cd267925e6c6cafc0051b2f7ef89e8ab346ada5405c18c60284bed4ab7dccf8bb268b96042ef3197b091f149c301951833e461fec6084269a0af5ab34d94f559ae462a11b9257dbbda8c1f59d7898c87d9a96c73f0cd201d070cf66e86547b24477a5e9903abcf1ba2d19fc52183256be836b3d490e7c797c8879bb4218f94af690e9405664395a565822c4290bd212690070dfc74319d146da600e8169cb44a9022dd04f1480d3f67510378aa3fcc9475417e20f7ff0c148759292a5b7b9517cb9b50eac17b56795fe1fa3194e7b00ee948bdb882fd33bb640a39520bc171d5db6e47ec24cfd9662ed73aadeffa28d3c1b2c756ad586dee9466cbc5e867587f66e1e36efb179a0c755d14d8417f0a8a590ef69a86c2e141ca2a0fe84ddfef65920ad091f45851fe660dd7bfe0d7b4993e7283f2b4e3ef9d784d8f1f32ea77dd419ed0dbe94cd7347b1d411a1c8658f06f320264333318483addff85d9eec5b1f70d22053945e940882dc6bf6c1cc5ed7b5a238e3b15b756f3fa5ba001b5694efbb4e6f8761ae2c2032ecd18071bd1fed58f8fe8cb772c3892f24a471a80cb60fd3f72335b3dade4f0d879246b921b19cb4f659f7d0a20f235e10deffccace1e72675fd27b5929b0e72eca0367dd1add79d3d3657aa33560eb30b041974e98c1572304c1a3d7843edb74fc75e3b2d1d16f7a8fa565f660eb0ab288364d49c4271fdd6b91a27dc84b7fc8716fa0fced70e2b30084854edab57f7aab90ca0c601d20c92d9f2cb360f2ba52fad8129c8a360fb4e264d1003ee6f307fd937172d8bbc279265b3d4da7f6c28e1ef7f5f519b22abfeedbaaffed81d1a752f3cde583cce5eb0b1eb73b378809a82cba295c117ed10a79c9fff84158fedadf7a4bcef260b0ce4549ab02914b9c536d0b7a02cde099003726af944e525a93e03ecff83883f298f08a8a1f98b4a476fd8387ee2fdf2e93d5b4b9030a266362a6368da1fac1bc2b58318c07a7ea4afb988ac40f6ece8f99777fdd0c17ce31b07c3b4843d369b5911d510eb016255bf348e79e49166a71a9f16fda769d2a275345fb4def0b2aa8fcf519d254e9c8709c00aa284a9f60bcda60e249508e34adc16db6cdac90b5b5774e13e34f23b160d3b90a55ad698e3ee185507fc4832daba21e151b4e52b2efef9e3699a283d06acc31d09e2a1e11e395a0f0d8a6948b0e7e2c95e0b4ebceeb1e623eee0c0f9b906b9afcfe06030420b6d198d3ce7a7ed71e9e9c50b6312ad306f76d560644b645b721b0de599173d33608eff0bd9e220ab665be018539c8de3b8f5b2b32d01f3184073d33f8c7428eea7362c813f1565969df9994b5750a7297f46ebdfc148f1655b830785b2dcfe6b833a2e91bf58181c6f44c7607dda1d3e63af16ccfd69bed48353d2d561b95302235c741127cab321357a1862a92fc6ff4f5654b062f4d9f5c45764adfb17d3d5e72025220c880fe2b6faeeee3dc6d2595040c3867639bcd162b29bd54f60c462d2b221392740f41e489fea110a9021d14df4e0aca3cf07067281c8f7744588ad9d6ab3da1a2c9ec1426a056b11a3fb49f72fe06538ec902edd3de3af496d47f753d7795960c6127f4359e1ab4d951c34521794b5b9b1ffa0b41c3d9122bb2b39250e73c7d181ce283a30bcb8a576cece5220a2c29a1e4b8a699ff001d872dfb512c4b305f9a6ec3110291fb464dc768ed05d07bf37644556881b8ac2ce5f9864afe01f650a0253b4505dfb3df545a3589115e481759a79ebe36997f195d6cb55aa8e0e516a66583b12f6547d857801a1185103714da8cda417286d6ced93a89aeba957cd181cbf6cb4cc200889543fd3b79eb2364a36e40d28630935e3fdd2925ffedc085d728356d9e051f5943995a9662f016184e08acd6197ad99908e78ef22a79779af26e1510ac3f23e6cc182b7eeeb70e70b2048636b26b447be1d7f9d33a4fd619d49f4bf09517b61db8404480100d9a29db6adb3af2a228f4d7f452182de07e2066f19681cc907ed8c904ceb701fcae63028b850b81a89294f4b01d120bf4e013da525a4648c0aab0630cf3142c155e627fb8a32cad581cec5d5d8b7fc4609669977b424725989721b510b41c9458a456845956e0c2d27ddc78bf68077701549d5f706b6cebe3483b790e1141648b3e9e1acb7ec57074920a2e6cee4038aff621ca20bdf838e172cf66d3fe12f850b76bc84857559b5dd4ea5d15e8d07153873588314ae4a9a3917347a6bafcf0d216bac5fd9326454d64726da1eb0fc9a5a74e5e515fe277a6d46a1d6186bc5301e586b0e4678bd7c666327ee39a82f32bc764bea9cd778bdd5686d901f80d714434655aea7a9a6c4da963b726c1fc810e4916cdda35aa32bc384ac0d6fb68dc6d223292d7418b1d7d2b602cb7510985b7a0de1e18282fdd4f2b6de02233d9b42a03f0dcdb170ae78bf191b66d2cad8b5ac39847c64d93e3ff9cb361884b444ad3b6bfacc76f8b9dc5324585caaff01442b87860fc64df0c533187bc50cc719ce485df0d40ecc22b0fed65a99594507b7516ff94da8ae06990680198b15b1a23c8c332eaeb002d9cd4fa6322f1a53eabb6e167521a314bb49946e1801eb5a0235e5c5f198403dcc272826d5711f4fd95fd33c480590c518b2e4849c743b8cf25a0c3bf0d4b86a8552c267c3d17ca7c47e9b077c7f954ac86f89581fe6e011809a0ff98c56819de034f6934cc1abc29b3afb8ba050a3bc22f27b9c0368b3d4a63f6c4e687a13adf19f74067dad8d8f1da4cdff18da4ec802cdee219c49a516dfbd2bd7bf3cee9680c9ec1c533edc599047721892ea116c959fc498e5f7e4f665c00f386f24a7f202cfb2340fe765b8fb3cb17eef5e36a66692f15a5bb1347291cc7a8f520ce5e72b05842d480430ada91d218e573222a96ebcbdf3e19c3e2ce960598e21adc4393c8da9b074f9ef4c0b5f1741755bc2096ee6ca342373b0cee2503db4680d72f3f39073322804bc30eb8d9961b0a05232b6a4dfbd7926f3c63d9040f25c02ebccf7fcf664a1e9ec524a2ea23a612e4cfddf6097612a76f88204835d1ea1d6b43e35816ea508c0c7f72fc98aa23be4fb1a0c5ebe3a9204caba8a608aba138bfd12c121d3539f4d294ad9972c9a9f9806fb56dc3ef3de2354cfb51e186410274db5ac3d79e3402d4ab7bf665d55fc57392e436dd3b275886d89eb1b8e2373c8b0ecd06822cd156a001ffe12deedf6946d693779d8240f861148354b1f3312e2ddfbf7a389416c80647439f18cf651cd5652869ac4deab36ec306293a60d1297145b44d70d38d3f613b38a7045e17116618dfae21f82921f35ca6791a21eb3c8c3efa722c5c868cfa73c30ad597c5ffa95572a981b9afa774abd806dce8a6072e0a9ba551c4591bd23b3141253fb0555e5db8964b4e702f22718d620a3feb6c167264beca8f62381687d9dd23e1069bba10a2e45d4748f8ad1927e726999d2da0be3e50be10841579d7330a4ad5ef00b845214cacd8bee9922bb728de83a15ff26a4177bdbfdb2c2e5d003b42ed9334a866b59a6f66dd8b8caea0758312a4a8a46cdf2fee5eca6f58a0f48b8fcef6ffa271b37cdef62309cf6c4e968949ecfeb409163e9ecfe5b24c7a0e5640c10722dc2e1c2453305a37f60e24227572bc437451cfc37d3ef1924b48266ef1ef9232b55b803ec48ad112980ce2a506d515b5831a56ab8306929fafb95b8a19cc647a1ace8bbd381382c707ac11a53abdb7f2fe34e1f1ed2e9a4480baac45325695dadd84c496eb3de072cdcd14130c41c1c92a923975fe50472bd9f7b5b9ddb375bc6a4d2edd3373c6486dbd217649e4d1a05a15d747ff5d9eb35a0b9d9aada6dea98e14020994b6714e1e8d2d5572c1447f40911796538a53b49fbc33932623f282025f37db0f21d54a002f0317a7c28f2ac971318dc83660ca1d122d869a901526d4d128a1c46fac1f31ec5c25fd5dc8a9bfc338178ef240636237b6e275a8ea85c0c389c3e284ce3c149c639aff47da33cad7833da97cec161a93194c701fdc7a0a319c4c923e2be6cd7e9bc00ed0943f90ae334bf3efdd84901ffe29b61f0d6ba74fcf1aa92beacca46e3524ea490fb589045cd88b022ce5ba6d4fc3b63594834fc881816d1ae879ae9243139630d0b9cb5f9e8ff57009af32255eb65e65aac75d01ceea23b12d82a1e16008743a758abb697bdb009810b4238065989265253162e096272d841f30421730ff353e8cf9313e0624a0229f8e28872333d9ce61552c9d7a865ab1f5488bc9e97aaf48bb1da5636133b3d6bfd2acd14fb219e1a8dcc29f217beeedc09aaa34df9ac4ebae9a3fe351cfba77157e4f60add1fec8a30e43fbd83e14843674af905b5ebc19536b5612d7754a74cf31c7f8169180599d0459174dd6bd14c884cf7bdf8e35f855504e584ec40689da71441e4995a054bf9052fac8b40559537b6edcd89728a2d9df340d8440bf87248794a2bd5057ccecda5ddef4a04e195c1c33a66326804235a1aefc91411b78102053615965045839574cf9d7f69c79ea76e667db791204df970cdb981647de2bc2fd2e281dcf1eaea325dd6b5a6bab19a51375041b229cdb8ddf5e7d12edc887f6870c87da7ec9552dd8950ac008688040a076e265d3d6893981fb57985ad14743590aeb9bf8f58b3e200b32055fc1db6da77e0d3d24c348a7178148e4690e6b4fabc8f17d8c0d4bd5410831313dee1a3b9649a5ca4387170ef90bfbc548aa4c75dd015b8a8fdb61272f8905c4c3ec5bd180ca8ebf8c8e1e8f7393ab6a290f414796e6d78bd0178fe55cf74f70668a44c3550e0836e6b9c60f4e2cd5a34fe1b764d4789e800a44c381e49c8d71346dd2100b2021f1fcb510d610f0820a9571b68d1954d8cdc0b609d0d8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
