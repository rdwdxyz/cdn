<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8fa9eeefab4966bddfff03094b5a938256021106d373f144e6e2c0507938498b530a814cf5efed1a3e6cce4bf021c011d1fbd0294717f92704192d0b3f3746e9a1f8ac52f8a6edebf129e01eecefb074db44627accb534ae0393a4fa9046999f0b734a1c43ff11941fda0882036092a9ef2905b94890112ade8aee20cfe071889c5e8be921e889110438916171e4874dd87bbda4f6210889073ea0b587335d0717b631e82c896317f9dd2448ee4d88f2a039800efdacbc24c9c86c039822cf21a0031abfe7c5d5f7238d7a26ace725ffb7a831ec713400ca1114079b7f44625de1fc26f115716eb269efb48dcce3293c96e7c69e2a64053e7b16dec0b4741e97b317c60cc55763359e40da4f121eda2fd6c1ef5723d06913acecb589286e71d544bc723abcd94d096125d00290cca0c911b7c535fefbabbc2e67356a54c490932d2caadb1fd675657e82abd55fd8c4e536c0e6e803c50a08c8df986ca07fb09595b6c5c389a7cd6df0a6a00f1cdaed5a8cb629b138d3c96342d22ea60746ee668898edebf2827e0bbb7117f6b9cd02fd406a2f33b13187e73b49b3e0021df039853d2f2bd8c3bdc9aa4ae6d853db1e61eb3cd4473c471f4734f8c4128ecffbed4104c088612f4ad61eb9aa73141beeb5623ac44390966ff8f246e7426c02b3c1490372eeda044939c481c61faa7d8fe3b7085948ffee14b762f1a68554750f568608f2a2a7837f89c6b31f771204f91a72dc5def3fc07dda965351e61b21eb30f8bcb1e9c3d3d9c13b8abfdef54b6ac93ce11df5b0e2d45c2e729884df4c6e61c00c6ef45253b2e0da2b4e8d165e41a74b9e249922cbfd2eb8c78d12e525c624b16c84da9a27cfa449114ad1e8a91d8885caa4d86c5f2dc7dd275037837a9cd307078080d70c5c021e2858be79f3052823e62a8978cc0ac785eb218bdb4834cc9f9d38f1b772548639de8cb16039a78790cf8b0bdf16ca8e037fd69c482e8ea59aa7c575842d19351bac68e563734be4c4977297fb7260fd004f07ba0c3b3103e10a772031e44635711efe1a311fb92596f2028a977e787e6a6598396200987f16f32df8cef30420ea650215e29fad81cef14ba903ae043f70744454af4fbfb0f834bc06c6fcf75689fb0b0cf12bd8df769ddb11357ffd08205585567e1e3065e990ad3e621ee18d19d9a49e974d4a9f838c272fe2a7f7b826b0c2cd48c1d8eb26dbed309e65fe18b0b7a79a8320b4d65c4151ee37b5a65e6b43e0b389403a48dbe23f368bd0191cd4f7b864bfa75481a964661f4e710d88d5fe8f1141a9dcfe75f5390c2a7babfe3f9a4797e1c167b9a308d8c70700200ed8ff8b9f626d5c1ccdfeeb236b3e0d0c24884bc313f38165e03b134a030b43db68c4718ddd49c5d469019cb0cd13e224d0e87b8f7fab72df984507bbae2c9c0aabc3b4613daf27bd36ebc139a7469d34ae5320d3909e82636dd6a562d1d76bcb4e58b5e9abe58e2373b688048c2676577f0c1bf2721c5418758efcde1cd76873e4202fc9f6f8da12d4983b0fce4f20100cf6550f38bf35e253cb8762776ef105ac1e4d8e267ecd917803911abb8b106e8ef1309169bdd933c41a4730082fa56fe1a82bf0b493dd93f18205aa6d51ae64ce6b44b1844466c02f4337390da7364ed9d6e13339f92dbb3d2c33f681622a06c92045795e05eabcca70fb8b7ecdca521332e5cec59fcdace88e43b4affa74e4c324c1bd3123112227ed62a5cfd2ba9dec1b58fb3981f8b06c84b8181120d61cbf341b7330a7998a1b3592c9a0992cfc6d9f85f676edfbab93479f57612823e399e6ac26428d3436d6e9e636852070c7493ec2cb3d08a122a0852168df10a3b681cab59b72df831edd826a519176849c9a9a3dbb4f9cf1eaaf80f5fa185b71f95267eab9c7f592310609abf08d983aec1ae22b11fe9beb95e80437d9bd922d7d87196bffd2e495363667904d90515815bdf29e220a34be8531d37e812c8b1fe93c0d5027e7c7fc35a9dfea184489aa10fa048da88a17ae2d8f351d756fe73f18e4888819e14dc4f427b4789e80ca7dea1ba453a052cda9e81b470d1f25e68270414074ac1c56cec572be4e92709c617890e10946a0517a0f721f2938e729ff7954be8afd217a26a157aff5aad1e08876fb66d216da9a13738763aecde8dcb489b6b37b8b0fde3227030159dae88f64cc77602f36fb29b33ba176b99554fb5524ef43d6f15af5807b57af0c6c04cced1191da25f57350efcd109a9482deb2eb4fdea094acb9b4278d926a5db8a888b0a86943cc7ed833db31145a98e434841e72a2f32983cbdb98af40887cd7e3e7b3310391a8ee315a49b68fddef3dd973639fd38bf65ebf22739d2f2244acc2dcb80926ff0509b2ccf077df5def3a4553aa678e26ff2cb147b049064126c789948a5c929e1872557874d3ddd18476ccb32ab05f80f36cd8ea62c9a8b58b245eed5fa6ef85dffe719a422f4ce394ab3d87ca13620b73fc47d95b14006f2062543fe05f8006c1f65c273d318e4f62f954ae369218ab7895d6187c65bf45edba2c62121f67667b957bb8112faa21c2860cd593e865a548ad637429f950cc299ec358fca7202ac1066af0bf019b1b499738904de972f22a34e7e4064bf8a42367a1308c8c5369d86148411ba55be328a5ba0d58044d4266d2b646c2b2cf3f27df1f0cdc4b44c80020d096c34cd7be70221d4b1eb35a9ce6dd1c16737bc7e69bdc22c9837697f1bee9a3249d4c5f28f8a27cdf472ac87220a5511338a1fc7efe6b264df6d810afc4942b23513d0683896aae824c5c2c65da6889ecd9237afd6d5887dae95e56239382e76aa0216bfbf3db679e728ccdbf06e51da5c134717bec54781e1a52ee7085adf596af1eea091d0076d958560d9aa6a3425219b1e6f5297ac3ca2f6cf9b4a43c50db79be3d3c7c3c419534af2d6d4056e419763f7b962fc051683eae0c3f26080c180feba98647a1032c122cf3055e5f73e1c0d42b0edb410e7ebfc879446cfc5240fadcabe8d119aa80c62fc29da5a96bc72cda2da01d1f5dfdb8340a582dfe04550898f912a72ff2e8c992dafe99b5dfff83daab0b5f56fd193e4046b1910d896e7631e684fd728b8225d86ac456a2158c44ccedc31925a2de55aa8683e5161595440a0069c8cd51946e14fbe33244f8ba768512caa7c7ac3c3815834d43c850f97b4ff97746530257047fb0e49a2c7a09fe2d1cd047038c3a0bb4374c2f80bcbd365496975ddb57716239a769403eeeed076b2a681f501ab0b37a9a4319706bb6b2ded06a7db0fea569d1dc70a0dd645e504e86f34abcc237e00a106334c37f83c68ad480cbf3ad211176071a670b2b0e50af7aae84f813ca745ca4f743f9001f7059b9bb15507ef794caba668af31cde22abb28640906895984412d8912984c87eb0e703e3b42fbea88db8d96ab9b9af0ae6643bcc8f02dc74579297898376499d106f0a80dab810b82d45be8e52942f9bfd3f75f4a5120f6fde5bf8d357cb35bc78652ce923272437108e7b1c330e898500b03070e11103d2cef784d4e2c2fc9544a6c968a706ac3e9dcfcccd1129466cd06412ef7a04cfa7592553b1f4afbb106f711277eaf36753d22b371a4d94d56d6774b0f5ce0204d77fc2dab936b553363ec167dd9e774c2193f8ff103684deb25b41f1440cefd607f8206febee7b8c68458325c3b8b8a654c733a8ab02be78a8cdb8bbddcaf97b8aeb36e6a5a6765e7fe88922fce7e17049c8f4c1ec49d6f68ea7e743ce27b8213589ce371567de1b491676622034c6a4050fa44344efed2648144c13860cc558cf23905008d8a986c701ac6803bfe01280088ce765742de537eb6856127d6974a4591d767ca41af5125b8c7b0092f4ff8c9bdaf6f8ba48bfdd786bfcb388f2bedbf4ff8171db27d0bda7762197822bd0ab8240777daf99d35a40d8b7890ab17d2d3e9970e6b45086438ebb7006e1c502329ef99340e994a3848bc72d4ef3e0306823195c5c4d885a8779b2182c1b1397c94e3f0e104c0b8a7e05ea6eeab6e6bf3742378e864f1bc7df890e2317285a668ea83a9dd3e859d02cd343b8551fbf956366757ba77da2a51389ba23aad7af92dae1dc454bec000ee1792cef4a4c877f24b4d799225b2807c42a36ab33238287ae43b2d9c1e683ceaf638e9801ae7464d5141f98dfd169bd64c25700239f7d1edd730767d6fd83ebc6ed7efb984bf21df175a9fb5035097f32c6ec0c82b1b023d96fb9bfea525de5b12cdbdedbdef393e85e22b0ae890e6b38a87db5d273611a7a34c6a9db58c9c15b2505a9cca436ef20c93ada53a85a4148c38894e0d3a08631a97feb85c6ff146b036afcab753b072e7b99463bdad8852ab88487fe8dc64e01801106866ad51e4d88e1773160d72111b0f550ba1ec9866725e535771070f1ccaaff4c8ab4a85a3c070c0360ecce562f077d08555cdff8127f18ac5b13c973f129a4af14c311046134f55837beedd3d3786f6ffec703db3b9abeb60b9c0b8b0f4cdc96e17ab5f5a42da49d1787274daed8576b743d4cfb81d7623ebbef6432fcd6bd3f3356b9ec02d323403a2e1e9d182d629809d421aa30ec9632115cfbb8ad16004f29df401f71ad8f2775185f9e387aef0e04929bdab875d488ce1421f90d307661da89cfe948a3927df938c9bac829eb2c54bf003d9f4ab7905acd1b994556349cdcf688319e8acd187a410fed8402da321dab0a4eb62adde9329857026757973cb024fcafc8d0402b9d3d2b97a957369829fbd0324212f4228911e510639b9277fe7cc37ebfd9042d7dc87d1e6e5ccfdaae9fe6d1a653ee9ac7a35f461521661397d57b5f5eb00c0b5fdb802d51c5d52f4b3d231e8b5725adfd6e173b96f9d5bccf270b9f95feace7d34864966456b2c37532c02e17268c8c43a5e62d1de90a51a585352a966862c2d3e67586a4c710683c19c3ba09a2e9690ddfebf4c4088e204930a561cb814f1361663fc984cb3440be7a6356ac858eb6f0d1a743c10ce32e6064d691fa30290980bcd6587e01cb74d2ce99588e0b80f0750cb780e0bdb0f0c4c6583e52c0d8bc2cd87f638d31ef6067da15e866aee881cd65161b91d17173d78fc2139e6af4351e26e632a9197ba0aa8f93e408eb189768fd880b199fc37d9d1b9472f2a929f07b9aa74f4a00b60e83acf7d21d9a7efd5ffe1b655d7362f4059c938172de7cbdf222a5a685c59ea701b072c3052a8eb013e3f876f19acc95a9f185784c48cfeee25260a806e6f2ba1dd1aa96eddd4670daae9b73490524e52ca3627e9fbbd66dfb1c0eb3bba0dfb8647cf98d72c2de653ca980ce6e9b1d7244a3ec376afc21bb5b71d4a682f3c7d98635045896c971f81644fa6b7a0e082484cf6b7f7918093157edeb78d873915435501d26388b81400f111ffff60ebf80bd343d20ea055796fa68b2d19b658a37c15284c0fb7ea8ab7114da66e28761e016126da183be6d0a670f28b4406ef1dc271b6fc4a438beb7e42ccf362858d5569952653bec40e26887211bc0590b60acce1048d9fafc876b61976f40a3dc6f8d3237ff8c16391345d7ecf4bcc9cb1630c1221b06a7e33991974e76d8810df08ec9961ed1d7a8046a95c5df59f22a47d8e82a01890f88209387fe59994078caf259e76a4b54290fd380854cef5e10605817099688d7de09dda3ecc5ca7d9268de469b8fa221ffaca67b7a0d0adc8a0c2ebc15df31f130516cdef236086f9fd462891b123e83c1ade9dd8907012fc91a5ac64bd68aeb3a2cd52d5d0691409d9ddf7a6be7e652de0978d8f490a01f1139cd938d91d0f439c26f9cd2757725d3f9de4b8516be19f2066cd927f3bc9aaf33300537ecb7a94b16b235933a1ac29d90b5a012ccb24f042bb7a050a122e6c9f4ee9ea2308f954f14fd864840092ae3ebb29622d6a790bd4320c137585afd7b21e0e3215a0721faf12b40d6a65be5478c4b814c0c7ce2d9180ef670ade92e83b4b6a58980f06b93a25cacc1713e69a04c94f5a1d08f2728c8df0171895479bcd15e77b670d2d53829df77f82c29f733091f13396cedcb90be41983d7a090f9499edc2ad5c3e3e19aea4b56967fbd8d4e012808b8bcc2f5d76c6b29b1a180f80cf16cd29aaa39049a5e588aca6d451d70b8d22a6075e71c5bc303531ffa7ea3045d22eee13ec933138796c0a8ca48b70fc3d4e1caa40a9f321b210eec11f64fc9e4ba89833dd0bb2ab679656b4f2d9a2398e92b71f443ba3d884227a1fe7ad6c1049df232336d66211736cf73671ab713e0c658a9a02aefb178fed2fd9a347b3822212a41728d5f365ce91351ce3ea9b021e3d5ace2b35c1fbb4361a10ee03a71aa3e22c864fab972733fd619e45e2e0a803125b44d634cbe9dec1bd847c14058ef36445705f83edf14cc4a1663749b1f915983af1a7c42fb8b817a8a944a8d82d1eda49dbd9a92b81225efa377adcaacfd14b5cd679b5969320fa003f7c7e96ecaa73151af7acfbbb734e79cacb761c74d64ceffda5e0dc130197e8e6c34dd90d814c72f4e541c80c211f13247027db40d86b4e7c1838bbee7fa2c37b3d170a0d117958c354a7643329b72712994a5457c765ff1b7f8a3fc353621b3dd14394074e4f74b321e7d31ea4baa0f248e58f45fe9f37269bdbaa6fa40bd336c13e0254c8c2cf819454e49649991a223e680eb21c5324a58310a17a478c3c3c8b0edadde8687760a36f27a3ab17eec77e1e5cf94a11b30e6d513dfccfe072d2c9802227b7e7f191c4d9d06e175cd9749f6ac4f53782e5d3db12c9601b24e61590b25916d30014460e2451ce87d8712ffa5d522c9d4fe0de87761ef828a76831cf174cd672c5dfc0f54751a8d38267b2d879e1e726bb13d96fc6ea5c0150d1f9cd3a1db78da70b71b4ebbaf48a280bf76117bffcc5cfa1ee12e273148f56285587272aa7a12ed19209c768809bfd311c58ca1d24f7af5d60566bc0ac022f381631ebc2cda03e8304fe44b676dcd53a5d903e0774294cf806adb9799b3cf2a844a8597bfb705a5258ecec5875ddbc097c3666746f31ccfa46926513091415c0ed7674b7c6aaadb3ff1a3c4794d0f64928b749af2dbdd9e76210241cad5dbbb896b1e9bb6b26e230b389a0f5413c0b6b6e3cac29627dcb83d8401343cc090a98dcc8f7b191edb60d148159ba3c2329d5c532d3535111e6e41bd35fc09f02547667befc7d02d3c0296abf6f1af3fa14acc28d3e684bd5b6233053f84f753ea5fb7a1e5544eb66865db4b46a003af01a6e11220beab1460d696814eb15b3b5bd8da90dcfe4f3d9b424e362016d27621a46c5d816f667fcb67ba43f7a049e16e8238f57d27c676793e75f0610d8e7c6f4a37b871b34a67b5882b785c14a791ae38094b7852b3fb0aef95f3a64d99a91451e5395de61dc649167aa54869c910cf01ebd61929c0da8d19029cffcc821f57e62e77f9390e3787fd27f2d97c2182448df7ed3fa11c157e81a29e4bfd25df2148995bdd6d0786bfd1db6c5b13a6e913ca40bb93b683143acfec17ec12eb8099866dc450f31b6a1b9dd10c794100a85b3d36a28f7a1e433cd95a786ac0bfafe5ebb8889e6702e6420cd4cff55289d8c104d576b0d1ba2c973cf5eda38fcc1bd18518c4debe4a9a385a79ec6a0b73b384ccb0afd9f23892c740d8bd9737a2dc6fc82c68794e056c3ec95a1a6c58d93d80a9f059c75a5936760cd9e8b5e6ea94bb054ed4a7ccdfc420857f9033e047c93f3af30ea30756000362531a04cace1982f71f86b23a0acd721525e8a81b6785f0e04724cba4bc0792fba299b76430c82646e6e1157cc3b472b2e20b47dc384ea234f99e44511f11f5989a22077447b75826127b3445c43603b76b2afdad4a0c2a7b3fe870cc8946cda357295386eb4eb89160fe9c9be8c2dfcff5bbc44163ab1d4ed6efb793c80705cb5da8a36423f5d96666cd07ee853e51f5d4b1b45ddf40511adbac0d9045562e551059e3c3a01cbf0c7664d7d491a0ed5dad62965c7251dd724e944c17582343f58f4bce96dae8a35177b6e5349a519138b9f6cf02e2bca206c1ce06f086f62a46087771c89522f402f71d3bfa30133e71ce84682f2fd9a376695b0ba6a1e62e0dc54a37ada44190c06ca76f732d1a97531ada0cef6c522c8b02e229d4491d0b772bbabd9f0368bbab3ca5d84168d75e539f3c3755fcd790335c0f376a8209cc42879c0c81c8c6dec90943decb89cdddf0dccad0d97966d6c8d17dbbd9ed47b928caeffdbb3efe1f4c635a933bd83753f6d4e5edd266545f65303cf92c06c78f02edb2180705770a29ec2e933ecd6e2026a1f10713b9fcd3d02a3e86a26a32910b10abbe711ce5890235ce753e276942893a9e11e5ad777dd7b27135e2021e1959f2be7fd55baa3529a0eb25dbd53b85a3d45fa48ed96ca9bba513275c5b634c879d00a2aade059bdfac1b627bd52b78079dda807bd8feb99addd5c000ce92a6fc415c270c4d89d9ff57c0f3308fdd5445034eb6a77ad47905853289edd4ec3ac392e2195cd703b9660444042528c04756fbe2a69fcc7112b7df6fafdd734f273b67fe9347e22b899a6cc97a1c60ac9b4974256f42715ceb479a5b11360f83c39210b29b8548db6da6ee122b7187663c851b04fe67fb1253332194231c6b47d1f4d91a2dfda05a15152a648051a224777cad0d60754b377568f25fbca78dc67a16cefb682a60bb369a4bbdeb7b63b414584ca552d0ca7355d5a4654f683a43cb410ae8b61b06cb73ced68d6658ada80a5fc984060259eb63865fd76b2bc1d7b9db37eb8a9dcfbcf0cc27aa4a6720f3d0fe5032fb504ba2961bc923d25ee25bcbeae4e1f8a043f87ae611116c2a5c68afe286ecca727b22bfca18971611dcd72fe263b545295cd103f87bbcb3e02e6f33fb61301a941d5ced64715d67c7116f2c7e1a3039c17f7b998a47ed7e266a393c842d6ccae1e200801fa130f22f1ff828096893174f7042f0188da88516a7a1ce6cefda607d688eb9075f5736a50a5fda97b512149466fdaea3aa3bac7efd68ee4a7c8a033a5908054d6a601843320d4f7ff58e897bea9e04969d7d1f465d394f50090f977fc43acce2fca14e2d074c6af49cb1f2b18bfc4ceff498a997c49543e372f76d0f35943e715c36f1504734539c012a3ee67cc3e8311507166f1ccbdb7eb76f14fe0c944160ae9be1da4ac2556cd94b5dfba2c81b7664cbde7912830bc288cffdb52ecbc2d9a1017bc4b345e82e0389de6afa5358153b8f93306fbeaaf794941ee8ceed9b7e4a44bbf3c8fd0714b11f7573099609c9d4eb54ca5ef8ed33c561b25fd868f7032858e6cce13bb1ecfc67e32cdda92b127cf04e08c925663f5b44639de8ced446b17791401f1274c70a4f1f69f84831813dbaac42b7a07f3635ae042f0faff4b6d59c2874b7cab3bd45ddc0c7ee677611557a166bf00fedee5f6e05a193d9345f806af36303d63d423937684fd9e8b6c3f9a41245303d6af045f24388b7208099272fba7fe3887ae147a61b606fa5032f017d091e478276343c24a081eaf67fff9292e7c23fbbd11be2ebd8158d26f11bcfca5cb443a240288b8383cf51eb9ebc9d47c6c10ec858f2e6fb3949305d58297a9157a4aab644999d3fdfd6a5600dc36d9edf03aed2fafa710693804b49e2e1d3366dfabd4632eda4393ba74346270e2a992b63c67e9ea504c18bd8d078a35e0961909a466b9207f2eec90706e48864312931372e62a320fa404cfec97d5b5c89debff7bb3b2c337247a92805ead5e9b9db74a2672c7364c88a26406c3f17db99857ece4a4d295c50a8b240c4ec1dd93b97c79e0c1198d01cb976aec1e80a1716e50f2bea207b810bff1d43d432740e7e77c32209bb0d307fa5fb459130faa9d7cefe355e6837cf5c698c97deac08b0d359ab818430f94f34ec9d5e226d65c936e5e963fab76a384543ba4ed14b39fc70813a9e2231603309a8946685ef55aedd420de7f5930ef8b63b3567cee12ad9c5d8cdb7225aad597deac11badabca2a0b3e43208fe8960d856b8f0e9ae50f73018807208a80c630de07b794450dcbd5fcfe23ccc0847f2adff84d8d5c6802ed8f5a5e392693636c260a4b8b84df06c4ef34a06bcec12f5de4d9290563bd965bac4eb63835d2b3d6556b35b75036bd1cee5f2c0e5d627c8d9f0b4f4224fa302e7ee5102db812cdf741ed5ba995af4085914c99dbff78826fa41792d5a77479f0d11aacf2b2007d958fd304f792edc1fe7e59a4423eccc37c1baf155f8973d0bc7d718ed4131e4f7963b2d5cba5c68abe11867fd94185a427fe5ed7a216733c77dc3f6198de226ed44910b46b29343e6a93070baab1ec9f40c3e51260d8b7219052f873bb1e83670e78f9d9a6c93bd53f5b080887dc5669c7160168c238eaed088b55712de91f5f087e16748cd87c68fb01f78555d906a3986efe840d1ccc2718d1eaee2b7081a8b11cf9017b187ae8b3726bee05b4339b7c862e8d29163ccf0966d2706d62f51239b8055cedf4475f1887ea7788c1b765dbaafeacfa2c38a973736dcece3ec04bc8937cc768a0d6fabbdf583dafe71182987f2619b1ea6db147229e74b90eb9ae1ce27e2657c770c755e1c61a78cb3187cf7615124a2f067bf7307b1ca549be9040f3fbd063ae0cfa4d06ae3f0bd656bf6d2b6d7847092a6f0a03099c06c20d5f4db3ae09b805a9b090d822cf8fe368efff004ecea62e496c72b63e0fe461864af9027012404285599fcc4f898fcf12ffebd05b7951c73a719cd2b24dd64fc705091c0f6dd6e736d398f25bf0d95d4b7f36cd5613e9438319b9e05395bf91ec132574a351ed6da076b3f0e8d8de1ac5f1ce54d097c4808e19dba433eae4c73d72f9ae1c86fa505dcb23c1337f71e9311ae8b0368c8edbf7ad8095d151b015d56cc2906ce51af329715581909536c5a4944b56db7da4553050059468516aa79a4f3a16c577a8be5c382baac80e47e367fd9073a71ac5cccf90c0dad764368e25d355c9c7ec8e4b6d4dc7223a9467f55899aa065d88afd397077ce8d5f6125be7e21f30a062105194cf2ae63107222eecbf3b8be1eaa5920426133206d6cc7190e9e858da2e8386f0c863186e932cfb146e4cfab31b01e42322ba6b6f71208ea9ddf5b2bcb835be0b5f5518d711fc2201d7e1a46691a0016261806acc2e0f08171428ab1f84ee213600dbdfe5952e6375dcd3682f2619a1bb021151795459cb513d3d576f95d001f3ca29766ea4593cd728af1f4fde08bc8943ef377d5e8e55b48529284f507fbd0d9e4e3cb19272f4d3fb6239f2fd361350c8e689522585aa8c1afe6cce1d585a18d24fc585e3d4d442b4aac872f13e99edc917eae7310e72d3162cc81f2ee9b31860d1a06f99a608379f28d695daf7f1630fa729303cc247a9ab2f75f3273c71332d13bdd43044a3208519c16e5c2575143568abab71c6be774446dbc33ec9bf8fc3e58b634c8dc071ede52d022f38d8773f716d3ed4ae8eb92b196819f4f3919da913727e1e0e70fbd8c25aedced14f9db0618af6f07a030cb6ec4da0744aaac1be9a8b1699b9c8ea48ca2abbedf9b71870cc859302e7affc7ca4af572b640b7f9c0e0b5d2f7013a07222a4248b9b1d9bbbf03e23cc87a8c18fc30a69c1d47901419a20efdd88283e20e6e814c85b558570e9ce81aebbcd51df247216eb5360a742e0336fe81895898273da31cc5236f4dd3967353e36edd35ab117b9a1a647d0830dcfe61bfe4f45824580176d5e9a6e986d7feb10c5fcc39130c908e109436b00c2d304e4ba931cd97e2193c7d3d9fd4f63d31b22339fff7538c2ee3f4a0f7736aa6e01e668a9d424aeaaee90216384c915a7468d0abe222782225b760377db8a15d7b1db544f55b155145178d1f423c94a6ffdfcaf6fb4712e71ceada4cfe59d3b7cf6baa44a6e9b2c70899232f26e139277f944d6e9902b5ad30be4eb6ff269b85a78201c9c4436c4cb71362e48c60dff1c04fcb9473e9fb422031a290084b2f043e4ddb885af26ba6352349cb26f8dd0396b833dbb6c06673bd66cbbb1bab27b8f4364d519f84a95c1a414d2f7de7e265effa447380ae4e81e86091a5f6021e40f7dee81edd232e424fd257642ea615d8fc556f8c67c39346adad7584bf2b0458e679609c200e66114975fe09b3cdf4307afa519c04fbfe92de5222a6429334ebb9665d3a1b52441ba2616da26f88a5ce6c027e89ebc9e300f1fd4b04526e3473e0b8547103effd967f0c39b9f7de6d2c391ad109536dac0a26afacf897951393c60a14549eb49c032d6a884477cedaa82ca989f92dca554d4b6e1d69afdf8d0136aa8451ff00737d7f014f2f9c0e07c0433d763dc62d6d2c56b8770c727a2dde16c6be1015d1774a92cf6d109bd9a47b258c1a4f060b0bbc3b7dbf23b432831ac5604030ffd9c5fe171cf627c02490f09c4724cf61609288f9813c9dcfd3f9082bffd240c5ad3d00769b009fe3da695d409f8b22a09f883e4c264716b7aeaa386d4c198e32fddedc605cbf6baf274dbba0c074ca594269dd77c5389fa38ce909809c996d48a7c36fb239aeb47d3a20fb9f32dddc8b9a682be3e1901ae9874df75adb952cb2d5d5c975c9c3e9cd22bdc3d289746555f648a8763814beba3a594f47e1a1121bf3e361d2b2f5f28a15bb29817d780ab39f4d1390f92c15df5bd5c2be8503d2b4248a54405696f08bf0016813575f827771c591bd76fd1585f7349e78302b1bfcdd7a8e4aa5fb5b0cc9a656f8156a360d12fb81aae08eae28917c7cef70f72cacc4de870f3e74d75ad7f266d135884176ee13e283ec0291b669495fbec1997c39ebddc9ed097909910542ae8e2f8a7cbeddabad19f97dfd6213bad0b680db77910bbaa8c1ea05e7ebfc7a862312bdb6faa5bea2d3b8aab5df33b9ee5792881fbb5e7b882bb4cd799a0414fdd18932b343f5e97b985820cc75d4ba56e17b0797b8c7b0d2ad8cb92085cd1d8c3423bc49d6bb6f1705d4c8870bf0dfab737b09aa0a8b42ed565844de6280411808972bf4e6e485efd9bc7b9a1ee265f30b8637911df26827f0f01072cbeaee2852fcef307dd4e0f62461ea1b4ccf08e3ee1505d34489c79f4c07940841f8b2b4b36d915b537c55c5bcc176e73b9db3bd6e3b87bd9d0777e8990d64a3c4cd8093e30fc28e6e850d0ef6db72345e0a9fecdb8456ec987a711a9a661b3fda8705228043812acdc46c33b2b49259c3031d643ab0951a7af44d6c71202ba54e00c9ac5067def772ab268574ac457433c9c6d0ddd5a44b1c62f689297a18b0f386ee3d82d9568ff73dcb1512a0c343399f57535cf58bde4a2feab5ea915b28201f88085beb5813338e78ada0f1c56d4e6cc72ec67797d46be55dc1dfed46b28e2d052e8e6de0887d43c425277b131dd7e5ce0b220dcdc8f4e8ae2bd2c242bd55319db6d99f43e8198475d70e5a2f78e8e81128ac2b97730e982f73c15b6bbc10a3e2322892c2369106c71f739956b572f62225438e74a4aa32b296a64206351162a7cd2df300dc10e294b536f0fce98b32924e84f3f847d09e5513535bbc18282239a4737c3fd0c4d03f1bb7169d13b4e0e74b716d48b50c70591b55671863293bc4d490f7764d3023c93d31967ab33c2847d940d47b679d11b6851184b823a83c0b9326108698db2617e31e4cb968a0aca12a9b973209bab51236111dd4c3434e533b73895e03d788c350fd879c9fb3277188dda7c2d7a609bf9dfa17cf154450baed07ef2cad1a55a42f9c435a42d09cc702d0ae8b50732ec2f822b157475721fbdc12780bdad1dbd7c8224598ae22ed6101530419a6c194b64ea27de9f73447d357833ca98da24fae025f07dbf81d8f9d890e72d384ce5520c2f8d825dc9d105977bc864fd7afb5a912611823443dd65ef3c43a8639d607cc49cb851ef9bbb08d61e8b34acfa60d54fca5b0cb85bdd71139b859dda9883a94f903dc585cefd43055d5315ccb63369d2d9cecc7a45e24ed93abea1cf44cbc2e1ef653324f3aabcf27f60c180652b36a4f42019de9913295f81a951cdd7881a19d506a80ed548e7f9f75386bdca52c91d2c52d2058d2d5ab5ee35e54ad29ce656b0f887996f94edff337cc4101d31c4d262f50f2decc8f1d2830432e5b1846e7c85dc671860ecb668dbc7143f576bd475877ddef473147e7395f9b162bb892c9d3e38a34245aeb9b296ba062cd3b288c690fab08338ae63605fbcb68176fb8a1bd883646fd295e6892807970e9ff6bef626c9277de8a5345dbdad0d6ec010b72d42f5f22d001100c2e8a0b2d3834306712bd0d574c3dd37b864ec51d35e69afc9092d49cb9c75fa03586958c98d50756452077310a6522cc91df914453552e2255a1b27b5442c2ebf1b035d062085967ecab6320dc74aa85e05b3c34d925e295f96ca638ab461261a09e6eab46fd905ff973e0f61254155e4e1178ad858b2e7e39d2ae7677c5e1dd2378cc6fe118504399c512c50afd08c149d7bc4ffeb523b757837c4927ad79ce234551bc2d08fabfb57ff0aba56a19498172c06a24de2b180ff9b512552f3f6a1b820cce81b42ce7fa1ffb1ee623e396c1b7f7620a88803cb1e0170b5ba46f756a52fb1e560e8fef2b8e1c58fa2d794c917bdcf25359d87a64fff83fe5259f22ee44734e2053a388c4d484b06df10b295786a9aec7e7850405ec6008980ee262428551799b42d8a748d7bf2835cd6662cd15817e0f84ae1fa5497cb1382d9a74c45c0e408f3f24fae4a54880a59307c7091a06172e916842999b3149865418101422307779091d7894d65ba0e6f8189678466f07a1007489bbef2b376fee4596817f0674872e90f5f34f2bb104b22c987a10a20e924c154e6ce07b7129716a2c31846cdb558ac9d213defeba8152d78c50fa8cd5eb5a45a5234387bf9774d39910606d43f970678d93f90d1ee7b108fab97901f19fdfb796636100aa1400c9d957a93dff5e17a0c858619949b02cc5fd3d40bbad5460bfba39e14c11995f306dbf44b478844cb3e8f14e54bd218a5a43d6d92a6b75708fb3603cf432822788b94c73f73b2bc838751550e1c3afb7d8d268d86315bd6e7a53d8df117390fe0ae9450a39eceaf0b43962d3de00816d6a8435aacd0b78f4ca0375a9745f1f048dc23e5a56315a30d0c88ce6b1acea65cdf13faf53ff39bd697cdfdee79fc27b3c9638adfe3edca99145c72878aeec22e4551b20a680fe1cf1906cac568fc3de5563dae88b548243373644b0ea9a6b30b883f92a2a1a731b53ee286f4ed9914b068b46e5d41f9ba85f382bf8f1fbdf298a3337a43df4dbb88e30966ba297d83e22640ca3575b8f9070fac3c52f63680d3ea0c7738e6de72bb510734f408a55a65d977ec1741dcd9cab0d066b50487e3ee2851d31853df4a0426ecf523ca9f39096ebae6a35e0efa9d3be46d83e4e682fdd5734f2bb48903ec6d4fa9591d6f22de3f2f9eece434e7c4e6183b10d5232cf1ddb7d6dcce305608e57e843d7f7273f22ffb62929a1b804925a1dc143beedff1bb7ebae8bbf4f91d780d9772b2a18f95f158443be48e696673fb5f0ee0287064cc6259d3d5b01a7698057e6fe65dfbf169f6dff2041982e3abb0d1419acc89b1ddc6c087c5aa2af8430acd1fe79db0e1b78be33b331a9ba9f246c5680018453d148e7223c8f824a0c662199eb5a009341da2d1928b618a6ae669bb601931d2aa1af9c99a8e51c547967c956f94daa85788cc023475b4741e06e9fdd21169c2e7349dcf082fe80a59051171ec9f1f435a9a5e63d7502bee04923a097c454cde9c7d1b73ebe59e0a2089d064495d5e526d35a05c4795e737b0e0308d3f12590d021782b7c8122c4a1b8c15e3e937a570dfecb38dbada1fe65b363839f779e8b7f9c356018eddc81eda1bc071dc22c1f6172aa42f6ffcc6bc770be65a32c7850f2bd2826bd516423460c90e44a2766c8f8d203f4a595b0196421958e350a65df1d53865faeab6034cba10e2727e0c63fbc174e456ed3919af380935077d110c29179379576b99cba3269bae3501629a8c3462d19bae7f32d58e77604419202d77b03cae2644553e48a0ddb40962ee5af90d776b46e7aa140a4a581473effb942b3932ade7d4c21013993630fc061bc810f446f8047090d722cf6cfcebb91f45cd25ccaca8a8c915ae94f1db0ffb9fd7d92c48d2b9889096f3a161b7b77f1facfe817b36fa8d17e8aa65f91b58a782ca5ca700a514bb9205ed29af7e442dfe71892d06b05a236497295e38b7918be7375119347ec033b292153e0e08d9555262136ebeca8c08e8aa31a73f76981e4fe5eb8c2e500a005fe12be2ef1ff931c1f71927f51223624e563b53a9aa08b7c8b3ab6327e2679e8dae37f15936d5a223847f4a0ebb1f38061da0eb29e7c3d39fa67e14161cb83385f67971fa06bdfc6360b66d462e57932b85887b30de481a1b0d68fb5f72f21e9b16094bfffe12b5fe57cefe6b4103a8ad1ecbeb0b879c46b0c6749c848f24bab7d355c2da42a9449562f9a56e08816f35cec1324c733331adcc4b67c1cb9d8d7377310c1c8e01e14322d86e6df5681d3ef6149ac1503dc011c8b53da18cd4fc4e81a9f13100fb16ea3569583d8021e9cabc6d052afb192521e96cec23299835bfa7958440b87820299116d25a7e0d8807b15fac0a97aaac684f7d80a37e80bd5a7f4fbc87e4b72299e27722a7566076a124805b4aafd34b3dce4ade99215bd07242834a78e0622c2dfbaa58e4998dcd3d69ab54aee0baf0e9247c652a832cd452eebdacdff7fc70415c36f4cbd013df21a5b1a6826e380322c8cd3a8bb0e7c718d783733c2eda11fa8b46a74a8acc5de95539f0ea4c687a48c3e0d1b2b9d0d01df9653fc5ed547372eee0e621351d500707328ce07713dd025a1808c74656969b08559a1a16391ae10c8fba98f7bfe31fa49ee62e790010335281dabf180d75b924526c1b1f1b40feb560e2ee454668523776bef6e4f6caf418a88fa2767910b73d7cea45e9cc1628a2123e51bb8c7bbcd750064266b53d016eaec4b0c2d150911aa70aabd109d7bfc9199401684f4e37981a1ffc978578585cb74efa1e14c07dfccbe3ad3d71ea97775eef7141b936ad91a4929c8eecf6e6734aa62889207035ec5fa089043910391557540dc8bd37e2260d0d405c643ebc5950578576550804b2c2cca53ff6b29a2b77ae12743677b4c369818be7a67e9a82d020de8e279b14a6ef9376b3f4ed118411d87d7287a91cd85ed7310f8ddd9f13e05fb594fa1062d74847eefa0f85be44a9a4b7e7ce85991fe6bb0eceadd1c860e9917bd53fabfffaebe09e37eccef2a55d2800c20e87a0379bf0886aceeab46a894cb045dc6d63be507b705fa1a979f2074b2ad24b5453a3ccbc675692d77b3d281cd2c3ed229209741f4333cdfdcf4e782c0106768727a87c5ba4d305993f26389ea9a27e75ba6d948d8a5890413d94be31b2526554b04bdcb1a1ace2233e0ba91a5a7f4d6bc040976da4389d04d45a2fbe4334c76aa9c570a9bcd8da635a7372e4c2efae1ca3547e3de6cb36997e99480a844b0353edf8b34801187c33c3e28885a16fe8c8ef8a89dd0a27d7bc9c559b60e48d12915602b3b75fd6771845f3685d50543e499fc96a299f6a0ddfcf80a962c5a8bec5e6165c1b401990973b4ab1deb78871c36045c89e6ab2b94a2f875dbc2a107c9e11b1ce9e635e1e023a68a7e72ec3b8e5bf20d55b1eaf18cb782cf96fb3694deb96d3b41a9bec7ef49f1e0029e60cda4059a24e910f1ceac76d4015478478180503a0170ef67d0d89d6127525b420ee84198528953b94c9db017254a8ae3f902abaa29e1bcfb47ee7aa13bf5805d3a8a27816f3036718fa512dc3bf8dd8e53ecfa20c111de076c875278cf702920479fb2abd0bdb3481697d2c91fa508f3ae0d56a59893f20950fdd3a5a0719ec3a32138eaa04540d3cab554389","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
