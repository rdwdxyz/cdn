<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d18b00a8228e8b0f1d2244a504bde33928b6fddc3b4b8ee0003059f23f983d0b272f12d1850e1e72ecedb7b593d82e1fdd9afb13103b116205a5df4787768772801d81e65e5f0bf1ee02d9846042d3bccab757da7dac1a03f4fa7e2062b87aa5a75f81ae678e13fc6e48e84a467aac661159d3b1f4e58240f74e48864c69a944509d8fc6d1ad0530f25b4fa0bd8f14cdb36545ef5964a48f12083dbe294daf092b9561dbe40f8943d94b563efd09a117f22b38382052edb00e94d6dca2b9ef298ab63f24ad0aa0f052ad02c88c3478a0db3ed1fda5a8ffa78660c19106cce1a5d4703dbae8624dd06732ce10e99a5d4632f423ac7fabb0ab8abb398463aa4b195cf4be864f41fb60c1c2a43d19590d77f1bc1980263e888d08494f0942e6ec696425567dccee414e281f487127ced73f30b0076a58a535035730f8d9b67413d3a8dd03a9a87e04b1f428eb0f3bfef96f005c892ab499a44c95b2d9ec6dbbcaa863407a62d6cca39dc43d6fe37483160808f30efc0b87f852543ad520d5cc397a6ec8372ddbd3576c12f1701ce573c4f9044e19f417cfff0d2bc9fc62e1609fc649465217340084e7f08d764c5944827f1d29628208e42c3c38ac2185f83bc121ca2fc5694ecada7875539760e81c95a108e5c6f7ae160d18ddf24bde3e4f755a6c455b691944b4a206f01bb1a5e5512397df07640ef6e3056583513e825387213ec2b8d9f063be8e86d86c5f27642d5fcd4d5dedcf50155cc0c72debb5a536025a462b08384392c38d725dd797a634720fe27dd6add97a498ab6a508f29fb90b7092147c0c194cf9e1638dc11ca08f6ac6c82dc23b49fa27ced92e459d55136855824ac077bb68fc73da89011ce43f5b2fc316dd3d8089cea05db64ada856d17c9e3886e0cb8d4f88d7eb82da6ac593a220e0c67274565155c0b0b7d1c34dee30ee618c3ad73347521754bc7ef9224f6d0be307fcdb0d6c2377dbb83809a2b5d6a39e44d9b21d7cb502f75882b7f5d250f0df3c6324e8052eb6920ee4d0c4dd955299452431166cb31f0c6c6a7b302a839247511a990dadba02229beade72ae67e56b3d16a9b0d83f692ebc9c0d4d2e75ad4526528a7b7b7549d9db348faad8c1b976558f645a6981bfec3b175ff9f53e391f1df2117b4524ecdeb70e9571e77b48d711cb6d5e6863d8d6badb50e8d766760726b5d38caa0d27946d640e64a731bd3e5e4e8f3e20c8ee382afa7bc86b121c80f5531bc7890b7e2b0caee4e08c5250f19286b2d9dab79fdcc55da44c18cedb3f2158d25f857ca8f39407fc2ed4bd9c2f6f487e7a5e085247358f0aebb3c4f449acd8841d5a3fc6edbe2df4dd4f2abc100565095e98d703139ac9f2bb7d1b8bc9e8e51d7f78e1be80e36d5fd0e8b0776c21ad86ae3ed188bb17e86714588cd7f62711e5b29628eecc0bcda3585e7e3324a4285551350676d586ab8677f1cfebda8f4ee7ea6940d591a647a350bf06f95d7375efd790f53528a243edbeff4fb397576afa73b1faec776babe4b8c56392e63a1761ebf2aee647368edb8319831086c994ce42d35b07023740d46fc1284673d6e3a9ca2c27978f2cc1176ce09b4bd0ca171e9b67fed51308feffcb1c5ff9fa3e6d2be9a8d0b37474b15df510c03abaf184f7bcb574c4fc55537c707b09d0e2d9e9c99f50908c226e5018c16dd6a445c75759a9e0ff352a42384fb2f15f0d774a1b5d44723059aed0101083218ede9cc2939159d1c98c10136391b386f1ef1375b1e4b8c94b324495680d225f8961b9eec61e5c2b18b437b61631d1a14e9b0033e9dd96212fc67b911a88a542ca595ad10f724efad9af8523c710cc3ec67ee59d80e14552753f3cc61137345ce105aec671ac3396760f27fe7f9bdc1869bd5553dd0b479db9242f7c910f0877ecc4d7f8d29743112edf044dcff920e4234ef692f10328ce3da65c4caff77bd1b8fc5777e26a83c4cb823b2eb6da3ae315ef341a7e9541b94cd5174a39a1b821aead54f41964da3721da8498bf362f43735217c0e745579747693f2314c61b0f0100ec100d22c7871b16fcb8a62e468e7f491a32c7359a08d58a9db6835f17c89ff56a9662ef7b53c63dee15217ce1fd354c62515f4b401657e9c02ae90325c9b0d9f1857044c242fad5a66c0e11d0eaa79a46bf8410326a7795e9dbed7292d7175a712609d06d1bfe05126be65a8a2b2255713fef851127eea8225237f9719c70c44100a601d360ef7ab12d59efd27c8722127073d7982d687844270c21eb0602cf589de27772c3aea358ad691c8bd8951bed38ef39db092beb31a9ea9f6e67e7b773b0aa89bb9a5425b1471e3b162d731b066a5ea404bbdd24d1b4bbaa738236b046b0aca38fd8de7ad573343b80e4137762e1a7af551d97f88b1317ce4a3a87bd0672b288a389ee922ae6894e01a4bd722114161c60b8b507c6465cb6f47aa57f1f953bdd5558697a17b5ba4147d4cc7b1f6c1ec9de46428bd96ecc9bd0b724bff893b21aa3769e6937efad7fb3769c181f716f60fc73ca0919544f76bb2dcc5148f8b330313991f02ba207f3dcd75d2c7d467e28738af51ead261f8dfeaeb13fc2fa8e9d6bbb5efff7fe0908593b9626df6b9b9d2f8b9ca213d3cce36095fd4b0696d4017beec1571eba92f9d5db8c856358575e5fcffaa94286ed0591d1ce42a419fd6e1734326a81dde1e2c189c06969e49227a328859add0feed02515f79b08983786d610d1dd6c37b3e9fcfc349a09e2eac2b82d1858b7ae9060121411ea3f61925bad9be1ce9bf9a4007b88ee9bbe1ade6a3488dd5f00473eeaaf3e58da13bc4317df8d55540778669064e68c95f2057eb37c5ed01b4c1e5fb3a90dc9c2b947bac29ac0bd5fb311a9bc604efc20baa988422ee0000d653f1fa7b4e3b64bb715c308d538f0701a6f8db57c572094e5793d81070f92588b3a7ca180bfbacf798fa46c81c68cca4e5d742f4e8e732cb9da209a0086a85f0fdf8cd52dce8e93b59b2d001ebfbd02cc15893f4d12bf564a80b325c6b994dbc07c70750551c82651cfedc3c00acecf5fafffe8fa53d4f83d4ad6735929e9e1a0655cb2070bd9a371f5139a403df677d6c7ff866a8f3b31b9c3075f215be746eaf30edd2cdbb0a29b5cd486bb6719edd6c6836943dbeb785103338678afb86a5097e8004afed914996a1e06a60f8226a780ae3bbf9bfb582e453998023f5b5133694556b4f3e9ee471f54e2138ad0170917817fd94ea18d49cf2f3987ad89ba934db0827b389734e4d6d5a54ea94ce79bef3cc22ceb37d3459ff2a5c261881fc6e2d75ecec4af4b87064d8977d9fa8c3bbe3349fe2652b2daa2b61600dce5c573dd34938f8485a0f9152e47de1b04e065cdb1d8e330d2ee588fb500990f63ac1570eb9b758ae066d47a5289407a6f482cde5c3a7f2eda88860f7162e4289ad5b1570df911b76cc2d3b34bd545d65f4877ecf4d89d52f9ff1fb167ccf32365b2c312da64566afc24ec19c866d16b80891b711a005474f460f7ec3768cd7683612c1dd9eca818d20cb383c08ecd07edb6753d6d9e654c4c9db29a19b8fff7e1be19a4384b0e5b188121873ff350560e7a34bedb05e8c11352543aaaa73993f96242d7df2fa722fee0461ef9bfed8354204266ca699cdfeee39da00b15ef63f9c133cdb721e4c6f486f3e54d079a4416a65028d6516dbc917f44da7e4cdbbf34a0820e55319ef4d8aec8efe27948372026ac4f6e44d55e335a49307cf41c25632c00bf13d0eb5cb9b1360ed6bb4434db169f63738ff4800268b3e0ab3d8b61324b3674ee4a7d61ce55c84a640403722972c709f661f76263d653107d4c2b151dfea1f7201f08ca2b277eb20b869c9658c865a04ff12e34f030efea5984eacf09e570362af4fb290afad07dd5fa28b579a4ba56c4d84a148a8e729db0b42c930b2b5f3b183589696945f0fb468a47b34c7224eda786600d7d40fc053d1ab461e196df8433627e96f6e43c7db083cc73ffb7b9ae977b5f26b6a57ac96b9a49af06f74d4594b2981c66b4edbc0df9461799649b64374290011c67aadcad1f4b25747e688eb5c795d875491bca6436d9b697c62c18d9c67ce4253840644ad3f794924f4e44479283283cd98d2a79dfe374b51ec1cd1c8cff04f2709c329297317c0ec6382a66a1d74808bb99037fe80c9d9abb3c3c9d190fd9895e2e7d539c8a52d0303a94fd98325dcb938d7f4a5f546094bf247f24630fee0d32a9c20cd6247342743e6e693ea004ce2cf5b70d82c5f2ad79db84151585ef58602abb36540d3fdbaf088b5b1ba95ba2693146abf35c7e5d003a32c26582c8358b93c4f36ed047e98e2cec24324490a1914defcaa05d9eca516fc00a422a30a71994a92be4a2673edd042b3fb44467bf8f37b6015adea2585dc928c946081967376d46b0a6e30654e9c9879aee75f363974626da16e3da83bb3ab1b91b5337abe4d0a3feb8bde39941d36248f5227299fc077a5858f49fd190da81e4a6df16df5ddf70c1625f352cd6c349ea0735d839940f4cb29d9f28690bede7fa1c703fe832c49a9a45a5f16bfe8ee9e87f50a780b313a81a79f9690cfb80c8fb54af0a8e7aff4c8f288605c83e3c8a432563c3d87bf63c7e21a36544995a9989272f96a12ba39b17bc196b1efc438c5f9c42b8c64806582d1d0b1a518504256ce69b4e26b1cfe78a5728ca5b041d8f67b6f9070752e803af471a4156494e21237ce0751025076dc14d4c962c608eb1b6fae105b527c7d7f913e0cfc9f0d1463b625dbcd17a37ee01a0792aec394d27dc5da831312e4a14cab98a9f8ec52eec2b7e223b82925abcde1cc710aa409de14fbb095586359696e7ad83741924aa8ed51cafca3d133ae5539e0442f48769db49a567cb03ae1b497f1df5856d60a5bf1daf1b33db867f72b18a5211d60bf6a40df30aa56bb1d52e2aa7275dc15c525e678d2885f717eba6dee3c559f6e1bc4e65dc8af17a03d2481c90f072c3bc095738f343d1099ad2e4fa2daf23c1af15dfeb84ff5f455e2b96c423031a920cb74814b6e6b8c4d10b9116758c500ce14ea270f16c2ab1a87dab27560a1ac5d4d4f2a49ecef33d4a2961856ad8a9295684c80f4e4e5c02fd84167d4bec520b00ceadbeaa17bd12faede549cdfc3de35ea1355d2efa61a9a15fd2722b8a9b73a0d9a3c26efddf27620cbb6776959528785d726a4848178e0616d632203dc5bf8e4dc4a7b88b6130b84408d9cc77d497a7939b6fe0b620d708c21b69f215c32d693040d23256ccf653454163d758d2288b58d2154ff281b2aef055d68a73de3c73eef852e587ea7250c913385655ff7b58599b15631fec8f03b95d476c83ab457585ae323346bf68b6dc026c34134b6fed30dfaba10324e96d90950e7dc5117a127f7ac520bc315c1620f8fb552f2cac0b2830b5c365197e4095e4312c99ea6b1172e1cea0ca0c51bbb7a4df0135b94b0c0a17135e44fb74427ee1f294a58abcc18d6b21c479cf7ec57c7bca13861600715f0141eaccaba20c2d657d8a996939d94fb1f940dedde32dbe3998160ddc0556873b39ede778e528acc1e85cde54551bf86e397c77801d52bbe27d5730acfdeed9cb1f8e59c55047bd4d74d8ee6b185d68a9dfad5cc17bc2af227bb7fb44af0d16066a89089c154771ba004daa550a536f327bdcd6281dca9f6d814bcdc88b8bd0093577fd0c1c35c7bf1d8ceb68a76abe8c7bdf42a7901220445d66315ae7288977e4ccae272de6189c6d21360bab74a42e19fcc501f0bc1d694e3d9c17d9a6d0ccd3fb3a422ca53ccc219f645cf8c285194737ea694f7b71ca21f064964e703b5fc04369257245dedb62f8baba21c2d2fba30fffacaf926d2b09c585982fc71dd8189ca5476dec2c06186bd80a406faddbbf955bfac22b63210e1bf9ac24d85a394d1fa497ff5ca0b29b293f185c43e18824aa5c86951ea932ac17dea1e116980fd38ee9f4a97682eb88bd99bc72b5c1352c2bc7bf0ac4e373301317aaa878fb4e457b336722b2a953e866a474c525c5a0f001135734e6ef300164c3fc1710a811d57ef028873db059041c916be4ddc26ce4d3284d0ecd49c2ec875c50c52ff2b15ad7f5243139e12f38064dc0960c041e1ed6effd8ccce5ae1d008fbb6209edea81f0e907acd79c8bac8af480791054ba1ffade6cc3a9af5b71745165b7689c6402481e3f1c863d1122bd5e5e2b2683c4ad12d3f0f39665c0b908cc2d85f73fb67f29fa4bfa58848b6567e2ea027b0a085a436ad9e0d146e6069d63260fa64d77741c027e25815d5af132ea8ce67e9f3ae1b3624466ebd9e10dea07d75d49f92ded68c5113611b234a764ffcefdd63d77d4f4119a8387a2575e5e4862bbf3fe6b821546dc5d3a255be61ae060375834897901c40dbcb49ca865ea6cb1416c25e92e10e087b6bfa5a7f3c0c0043f9343776944e88e76658a04dee7708030cd7eee3a3e5e91b252b80696c03da8a9ad352004dbd6c90cd11236df32a5e9836e8bbc04c3ea51672ea0de2f06ea3538985ed1a9f1849b9ba697424b8522d4f31c085b2924e6f8ffddcda345c7e0c37533bc58d499fe68757e4cb12c26aa87f11946e9a3e509ba8d17f47ab0e39c064b20439396948f5e33a61bf14273e334c56a36f35e71faaffb4218d8d1656757cd5bcb2ed6d6ab12519e1c52a7b89e50e6995c5fe449350a0a2ee2235c8fd70520bf757e2f2ac517655bd0f4c9f6ab0095b28b9dee5a6c44b71482c46830f9fb07dba0c4ddd1fdb3a0ab274d9ef164c617f078db5199ab6aab7cef66c01fa55dc5e37e5071768003c5212ee24c4742fd62c9c8cfbe82ff55b6423d43d08aff88ceebb68ee02155a4589bb8753d761ce7484553f173daee291bfb2a7c73ba2fa7f1eac98fe444ca2dc715770610b96f448ef8a598545bebc3ef675b588607dcd718cf072e4b11e77accba66ecb3219044494e7cdb47cc4d45cc46c2d1fa5a8dadcb054f76c3403e86eecf975b99a2f8e6e485548ec4b01936e12bbee01b150e40e5eda0a458372338bdbbbb41b20558b001b5872a206aac39ae7990805100c0f259965a1b809df02b1fb9b73b48885c8c26310b5c0a1aea5a5e2f670a3228e904f5c6e1f9b466549a4d9d14fec9c01996fd0ed774dc5901baec66f7d8afc99bd18d2c05f90b48204980bd14823a36dff1946c03a8b606506506f67c3ffcf4349d98f1429fbe1fa0b11aae749498adeee4753823be393e323cd787c0de0c016265f56964653fb982ce0ae9a3dd5c73c79ac7edbb26565d81f41f9b87e385307a6326dcb0d969c42af2cee5c7d563ed6658d82d4b7176b1c1c453e9341dc93c72797aebb709a492b34291ef2784dbc407d6019b3d5965a12d48e60b3a8d4311941863022e1ce08e130707147e8113fbf10a79f6bf88a1cda9e60fff5ad85085ef60509932c6a7890a83efd31d520384123a576a832a5eb8fc403833d8aaccc731fac346b35775aae98ad9b4d3734eab115a5510d2f02b445a385100da8abd7dc3b8c777f583db834cc53b05d61ed71d396693a3202aa5077c1fbc83ee21f957e358e9256ed869f04531cb420b403bf3717ab356d9ef2bb7504fdd701fc156f8c1c10ce441137d1133cd24a450d6e652839186566d7be6072c426186f93ef24cf13e8b5e078bb87aeca479bd9c588fd766c79ec82fa976bf897f1b652b4934b1c102fb08f3d8f47890db8230397ff3d416d414e610e2779453270ea10607b8cc5d9590064c57925d62d75c8c5918d9cd338474ec775300d28be058ad2ca32d702656db79c9805860095152d58e27ff62fc9eb3b5740e6ea24e2df846e49566559ae86b6231852a387820add9cf6305b6df5983693e147c1b0deee594c825aa116cca3ca59efa0fe1bbd99cc8a4c22c16bb98541746f52e3fdd3953c65dc6fdaceaeece15429e0bc6e3fb3032bb5c4bb283038bf99d62f2189ad820de4313a08e07a7ff2cadf349d63bac0796bedc5185f950fc55f6dfac9d2b10cccf72ad528300b8ec0d68b2d06739242a378f2b3a8b984d406587e5891218651b76b3a9cab3d971cae6803a791c1517294e82431bd7c1c3820631d1e38d8ddae0bb76c921ee203e31d12227666a4f883f6e423ef130c01a7b8c3be06f8d5995b79f73ab339360ed0907e1d4647f36905ba9aead67536511bc0de46267b7f6b286a607002891f90a59c7a64542d3e6fba5d6207b8c89413c08cb7d0271a369ceaae2f327c6bc199561b0cd5a18e7a8fd5b66da6cafd503695bc30e77314cf2dbbf3cdfac669e69054018162064df013c298c8f655ac9021ccd1066f369019a2f4ff45f6070b2917e88e6c6a25322809017101dc00fcfd89f01626ea3497ec5d9fd050fa58b8b0d7468dcb1fd046762ff0c4c0a4eb02aad3e8626b741b65654e09d6d53df617b89b64c680757df76d8b1bc661117a24fcb895bc298644bcf7f9adb67747f883e5a89441ea31a136b05b3ea193d4f39c284945367781dd460a214ece39b775cd7bec447f23e68cf5d9e6df33b4f9ac4a589d128d3f46c46e7aacd933185ccbc9c13cfc29e23a39cbef2c650e37ad614d73cbfa020a0342151529d9218887e9a06ad9c350a39056207fb34961ae19a9acb0bca787f2cac771b70af93fd82898abaa69c242fa96bf5d1c421db86c98c30915276f7d46067846c73ccc3b2c2f949bc318f013c62c433955c785d01f0a03e78fa2fa038aa123d990a8f7d93e8f60829c406206e9f476b7e12d9e13ca1ec0691c48c45512190461d00c39d36c1f39c4247d850ded743351b4b239b349c779c0bbe9f99748748269ef1a4019d7e956139d718fe60444c211c31ed5aed1b1826f62dc1814aa467d1d8ccee04fa95a93394209991fdbf139d959d079cf1bc8c9d9657419652f1250fe9e7b932af0adc1a68443cfe4f9eba4a9079448f2d2bc8e91c6ce67c30a0e3677cbc0148e3daccb10f059902dccb51b1e4e3c1954294cb3a0c642e5a545dcf4222a59e1e6bee246cae83183f603b720dc88a6c6ebc1f6de743c9b7166a2e8f3161a4dfb0420dc43e583cb1ba7cecb1f3ba7fecf21c61cd5aae6d6634833b8ab813d1264e8772b0c1d4c51e23d17e1a43b5cf37418edd62141cef71d7bb857ffcba1ff363d7b7acc2e381a5a6b6506758ecaad9b0f81ce194a50e0b7b56f454b06d2a12a777633239a3df3cc9e281a08d22228c8ce14ddc248f5917e28a47db6b4ed3ea3e954e1d60a5ab54dc598ffaf9f856fd41331323576869daf26fc78b5a91de3367c03a873cec244a4f824f8ede8f5294a9620c4ac4b6fac885d2664051e32e8f76a1ef1fa72e818faad5e78c4f46c4def1b11e9879c2e96faf424416f70ec35814ab607b85649eca69e744194bbb35b620e5118a4fdbb3f085054278c934f22a542803f4e775ea09586166d8e29ae7ac4d762531aa7ac0d0e6102a048b0e45cceb00fd49e1dd6f6187fce51fe1233ce83fb5fc6674bb63577daa1d7c94fd144917f58f4d1f99da9b1c85a0ebc7558f508d545395f5eb0e91d40af425f729067f25f9785f91499c7de9a5f916afb6c19866219a3731a5217bb537c6e426c1898191b143a7aca89d1924cf0a47e1415e82f8a087e26c0a2d4660c33a6570fc3d0b9c55f6c71a3f544b11c5d0137b0edabc1eda090cbd4ef4b4322e10595575afa67faf858276b15e881cfbd09b1f61a17372dddb4ef48a5277f1af90deab0a0990915a72ecdfebbea399f83e0e64789b01e039b5e5061c1c13fa67cddbb5851c03990707f97c9dff97311a894ff6554bae1852e000630823f85fb9be6911ca43aa2b5582681ac6f9dfc15c165ab78b89c7578cc48cdc0060a9a13274b4e227d600b36bf72ec23d58767307a3eb254bc6efe10eee0ff5af28236de5221649d82fa8222b52090618f6aa4acdd0c97c90b07d95c19dc050059c7f63abb394120037f18557dd3f0e25fbb1e8f84942ba6da97f13ee11055d9638a522f3c353c98b25a9bc1dc25980d19bedb203363f371e49e122bd96e6e3bf0958b32181f0c5a50534fc9461171147b0cb460349aecfc7940c61697a8f67e9b080b384c0d0281d837b0fe447b7e0c53957e15746fef1ab5e6d72abc5ce83be43d7395612286d010def7d1a6cea960205dd0e1d518135027a39b225122aa4dee04500ce4497e7380f0ef94570da41a39e6df569707175282de7ffeee28f9b24922a979a9a7bb5615d2ca4234c7fcfcc5e655eb120671511e64d1ab749f71a8f7d5cfcf5633d9cce9d2d433cffd1f2f205058f8779473e19223db30311407b71f217714f2068af3d398db50335f5f098660d98c4c19cbe968911cd80708fb8931bc820ea4c92950801d9f272a985bbe6a0680d0dc663cca4eefb74794fd75474574c7090982809a866d7c148ed61b21b0378f5983e017ed2f02855d4033f139deb6e7d2e1b5d87954b3f38518336b7fd4680b4b25b1b4f6e7355e8ba73112f8590291535299dd050d1fb7f4d95dab26ef6455c19b099a932af737d45f91835787c4768f69a26c0b5c2775ed9d84f307f779deb9a4fa13a2439314d33811c54c6ffa98ed89c8d8f574ae89313a055c372126851d5c493640a04933117d9dd550a765bf32afcc2ad7434dcc1ae4b065ca89836216b990e3abf6aec5207a3c96d989e3fd72ef3494ebacfe58804a3c9f85173fc9eb20f3c111fe42552651ec99591896671dbbc8a709e00317106cc164b58a6c5f163f3b60bc74e476a4dbcd00f8e49b2a80c874661904358dce759973b61dae3b841fcccd581e7a02a323c06f55847d3784d814cd91e9167214df9cc6af1838c6b70a28bc19413452868c18bd6d268a1e7141ed41efc796ed7e5f07959c7ad4b47502f7fb85f5f6e0cf6e757bb9cf9e940cfe2afaa708640a6fe77d3c883d7169ac7db4c831184f84c902fe06faf548ad2f62b8ec5f256ab11a132c5fda614a5ffc00d6551a24e451748abc15e2e7df1afd6586ae307c9de1271f24f6416cf7446433b095da1b058d00aa524324ede8a24556553a75a9d35e629324b40619f6885decbf1cfb8fe8f20d950afe612cfc4ccacd0c09e3af73527dc5fbd502f7964c1f79cfa61d109c1d41db8f75937daa6336561d35c1b01bd0fe91d141ab2b0d84d1df1c93f46231e0aebbfe785ec9e3ea69d3d511c5ffc26a7bdf081489df72194075b8a0ac250b1a1c39f66afe6bf0a58bd02c85cd5521a863e419eb0d820999fc259c7a2efe8ce70b4584de939d51b3a2c2b4ac0878d856a1c83a40347ee64f1d677c83147cd37717d3a54188164f0758b464bc7b50fdd470b26568480c76449629d175e8826cbb84ee2219c8f4055b4d76f4e83da724d79180f9e3d4b0fb74085b31ec1763cca290455fbe4090684d491fda36cce373b7e88d1bfee365616155956797a2251d1ddae915dcd821538b8720d9106773bee9165cd9bfef095feff9539eade475ead123595e62d9b401fdeaccadf134e2248cb4eebaa9846aa265bdb778bfe44e83a537c69dda4781f92b1db00d9f58b41138f79717b2329109bb2553bb0bcb39d154a6743c199a1dc0332167ef763904b3b84a389ab55e10192dab753e25083d475b9172277bce385c7137e33ebb73038de707e9bcc5b2f755bb48ca538a7d2209c9e9b63d7132f05c0038c4810cb7a18d2cf87da1253f6a00ca79096a88a7385594936487743a697beb429a71879919316995a461b4737a6efa556a891844b8732b9ebbf46ce79149edeb688a357d24ec09a1d07cee9f78950d49aa7d219519036cbe6a00fce7c2ebf1252e431c9841b3d8b35e6bb41b2afe3d3abe6f282a0f2b1cb12709d31956c8f397dee4fe781cedc1051ec43268d5fa7ab98c4744374f86422789818178b4ec187a6bb4450407d54b0cfc9e94e793c6d3cedef9aa2ab2f91340127362e7cb977eb9d9b5cc5868bbe9d44606054cd4fc64e70aa6543ec9665daada3b1a7a1e442aafe6e45e740dfae9093a4f7e0b6413d027de69e987199e019aa1ce37b99019c746147812e111dd7ea26d22e618e890732b7fc5717ff6e2859ed30ef2da29d2350a79072a617903c93a90bcbd1c2aaf403e8aec170713dd1cd908f645116a71a233159136326224ca463b6e7e770b2aa5ad83911d78e2f9e80041cfc647e5dcc5c500d0cb225a01451268ed01a347bf3c391244b53eb9877d33d66715e05138c3c6928b22e33eef5142fd71cada33ea0cc224cebd7fd165cde7a554efd8ab3df28c07c24453c1d979de29295e67cd079903d8cbab534795164ca1e16e5003c859f05e49e2700456c8a43d5ce7412521e56005db5e838aca6cf6e8135faf94bd2c5284b0f9cd792dc9735a29a8795825c87d857317af3370c5c09105a77ee72dbf6902648d426b3381a3b076391dc0801151e44aa859ee111c914086b6e0a3a39816bc13b00a84b47bddc719e0e23ea87be28b2d57279ec5433666a36c6b280bb3b1ed24501ac2b091a3855c11d10718386480d826f38727832076737cd622356bcf1286cee4b4dc3187ef3524968d6f7cdaa0698dff5ced4093c4cfbf6516ab5cc0c5c0cf773f4eda000066994af78d550b41a3d46fafa209a25b23d16b9455a13811fbf3c48c5212b8ff3d942ba30ae567a06f4d7d1df3caf92ff33eed730d2d33eab5d8635805a5e11810a90b515789fd2cad1012e00bee4e8d8e338546bd77dbea019e52c1c930f89f4c56a6e6bd410223f515908f3bcf3047e10a47cc0448e1303bb77e51fa6b5cc67946f3e7c54d581b8d3fac49b24c536b0c1e244f45d4fed8cf05e298c89b006b1fe3c618c24dfab008537e5318420c1a328c61898b59359312ab49fa08463a767c60c5ba8313b960fa74bc4e6fbbeec596e0518e165931285f98642b35ebd4f2f342ac8afc538add329a315546b3f5337bb2ca1787eb72d414f8f753efa5d3a2bc839b3d68191a87ce60349cebb5bc0fe43a02c939582073b45269f915add329f093cfa77335dc780701d1d804703f467eeee9606067503da2191d045b595268e41b680874415d24e3b863d73bc24a5f064b18b4a9c3d7aa5fd70a24b896131c86112d9ca2a802d904be45434f42deda31178fe51a45094b3525ced81f6f9340c347de5d6e8d32133803facf5f2ed282d8adb2d1362155f859504090db1b0b35fe04f87608fb193eba88a5a18ba28e527f3f6f0287ee7206276d7b8e510bae6b30ac6f32ba7c601c983d4d1fe4839f717dc26114dca63e09d3b55425078aeb681c4b76016b99fcd0533fa7c55826d197b8bd62c2d665a99dbdecc0d3a67d4bb13623b3c7ffe965f3eb774cbde572448aa9b1ceed3d6de2da29fd4790121a1590966b406394b9aa14e970549f799ee837e8d00a1acc487f9a8ab84af9c12c27ce33e29dde02ba6322556a51df852933860b4be9bf89a7d0e16124244c7622b2bc60572df1df2e51dc104c188410bd6740aab861d83827fd7565bb3122588e576d62b939bb9b1d3ba5d04b7a1eddca8b759694e227b61c65fbaca0955ab8db98d92b8ddd454a722c798c9f58f3d6575ac88677bef06f421334ce9a691df0a29cbf435737f8738f2e02f9ece2b828d503ff1ad77bbeebf1ecca46881e86e79951a91dfb1252268f7072bedb6b0739a578d0dc640c481af5e80bd6401543deb640562f10e8ef7c43528da5d5ddcd854e42f93e59457dc9d5f8dd3bd4dd79a589875e425aade403faadf27f0003761f662da6cfe3cdb8af7b3a1f7a0b632a18d603ef4041302400c7f5168e73feea1dd4ae37c13c17081897559a46bb08f9bfea4a037610a08dc8e19edd636978b5563737e3baf69050b9d5a16f0125b27de06eb2234320997b99425bda653b770353b3b1ded66dcf43361340f8dba3a62f0f765d3a1a37ec7aea90d127340c5c2973a4281bd5b0d455c07a97ea6cf993f3d34efb92bc83a0cb3e03f42f4cf865248d31e395378c2dad4bdeff5026971c02591498c909d952c9ea895ea19dd4c16d4421ee1d7e69bfd456621578bc44b923d5bdcd16d93d7e89fe06f257575b47df2b9ab88dcd7c4220b359590b52200f5f819ebc94ad2924b49c5850c7fe7b3399c193048685b679d42f874a30b90e37b5aeeabe02e477bfbc1773fbcbd1eb0cb98eba8061d8e3fff33e5f625790498d8f8bcb47ff944fbe035e29fdce5b9870a38e16dd59d465e0fb9ff60f1ecba18a768a8788f2443c9a64bb100a5c5fbcbb3ff3773bc87ebaa0f14ce2bc992756cf0e3afbe994d68d2e1750aa3b793b0253e41f0c73763d0a64efa0e00da804912cef3e5770701f20a19c2e7fcc5c5a02e267e477ca1f29cc46fa805bee836488b8be90540968b7ace46932b070874417e86bc403fa1ef76b68526565af8cbed28e282bc6a4c8f6beb40986c9e0a74e7581a283681be524ba18ec2e155e37f0a1874c01e5e4eb25fbd058f92edceeb35e179dd8b9d5773bb46c03248f8cee44049c11046175a10d04f8853a470e911848c7b8a2071539943fe095f0f583f1384abf42c2432ae9c066ab43ebc4feffb9891202fcfb03bd0ea4e7af6cc71f07e81407b5d34c97719f61059f72b37f8ce33f7986c92a7d9d370eaa8f9b3d72bfe95d1a2441933bbe80e5db3b2c38e97f836f9790e9729af24e1cd3e695ac16d5e5778fb677274b588e3d0402f01beecb62f05a1e3bc4de80aed85fe20c9e3d27ba38158cf7614b2b87debbf314c1abc1ab5fe56b72393d3977a22bca0b5d685bb267f7fde07e597fe0949d6bb0a0e335f6f7dbf31af3af0e7fb174f8e8f624e487703740577d2cee4a6b417e760c05fb6a065db59c64b57fa1b019bf4fb55bf542164f43aa706b162bb666342c688dff7cb625303d66f5c4f596f3def300dd5639d0cbb4dbb7d316a87c9eef3e90219383e437268bc40c5e8b3b963d0aed289617873974a5c4d1eb36ef4003b4ac700c1144bcbe45e5ba198b97d0470fd4814218079066cf885a0ef5979fcb54b400fa0a5b3b2c89c68409a7d695cc391c202eb30a9efec0a3a787abfffb7e2cb6f059c1cfb1c4b43311afe3bde671edbfd7132ff7758726e311d67c7f986a806ec318d4c35dfc16bc1fdbe0e24c6625de22e4e1f098d262ccecf30b9143ce43cf93c008907abaaf9a7e9858ee1338d5c794f3021aeec49fe9799a73aeb7546c8652cc786fee1e8791af59dd5ab6293ea99813e5812c7e9151a534b1afbd382849d6e5761e0ebfdb2415c2e7df727caeeef6e775293713986eba7caa0cb0886b80e32414ea9d83964eaf828e7737e7a14fea2edc716be0ec888c1377aef3c874a8be329279f0a9c35d83351e1f1fc23f1a750e8afb2e42e35b3f0f4f728f90ef6a225c5abc9897bc1f59142176d4d0fba38aa28bff0cc6f34e70fb9b7985bcfd0cd29bc935cdafd20aba46d11ff447a362028756a62244e1d9ae0eb3cd56af99923a3e1daf9541bdb7b809152fb0882430b7014a4d782e448defe407232265f430e5879d5044af47142146856f0d245425d3c98a3e94145a4efdca319017edb03e330032abd53acd7bf17ee6055a6e44a8b96cf3b10fa4a464533d48e9db4e5737732818d11f34e3ac67b7d48e42801ca16859a132b45f35a59dfd0eeb0661ac923440870f250b0ce312683d6ed2530b88df9c2af47dcb017617ddfa35878ba90e5c46ffdc8d19a41ff9cdc9e1b4cea4bb6511d86d3b96df7504af25ad05141b31dd6698b11f0c41be9d08d86979a918a0b9fb1f5cb8a9e22ade5cdb4d5dea9f4b45f857daeb0942a86077d295000a29f47b15f54d8f57ee0049f9a31d72810617ea7d88978c919b56a7d21b60795397bf24b1ce84d605b0f3a27660e490fefe604083dd393b755ed3b44d8326923899bb33a3bbf07bfc42098d26d6ed522412514341655e075276b7c7c4955b7fa79d7a3b1ef41d4099a6e3a7506b644e9e8d915020a9e7fcd33660060fd556656451c251e4be3df00405f2c7e19a8d83248c4f85b13ab4b46e4395513bd0745dd04208fa3096192619aceec076d38a116c724ba3405c2a6014ba4196dc12480607d6b35b6b4369cfbd0d94e7fb1c981d0dbd82c6ded7aff10f483561d0e5151e1b63da240bf80fc6ed9c5e88598ef2425ee0f6f928e08538f5383a1f7f4ed5f61cf5dab8bcb79deba285e1ce507e0013295b0874f263f57580477b533acd7830506b571c3d371959cf94a46bd9c6c28fc947e2f967eadca74bb32598327541df22b1b322cea812f04eea022ccc630e72013805f42e6e905e747df8838d04f558b8cb28a2b923196f0ea0d46ef3e621b7ee04c30120443d0263fc64cc131c6bb4a154de74b9497fcb0082f6c2ad80c30aae378c5261ff050520ed0c6b6404055b6c04a045b1b9549c4a4b73815708ea073ab04f6899fd9c26330925e4dba4106be0a4844dac8e5702ff5bfc589177d013aead254a0af05e77babe3d65d17f7934c164ecfd883c730c79f284e5fcdb33e103c555a83fc6cef770ca1716aa4f2351155d07af8f177d8f827922d6c81aa3f242e4bf86573a734e2d420b64d1b611aabc11670980fceafe97c3bd3d752b4b9cb5523c7349ab8a0b3c04ac4a6175d83638e7ca8b42af29553335430faa8faf59fe9d82ebca31624c64cf3b618638f96bca58435e9dee1129af6e12ff2f7832ee2ba95d5ba99d3ef83734aef2ddcc9cce08992821429cec2ef9ca004ddaafbc9d86138472dc63a998bd1944f845fe2e445a866f70e1c8c1f47cfd184bc09451003383ae31391e4924a888cd4ceb942b948b5a219b35a7a86abb1fbcf638b71639101e6590703c553aefd3ff89ed088af700c3f04a40b23350585098a380b2842088d34627af82e768395d5a2b7c6b08ef2664c4c5937b55e05b958ab4451fb051d122f301328d34a1fa75c603acf95d50b676d9b0ca4e79ce9b33d0f325d31e6ad9a2979318c7752d5ed42719c669254f1d41980826aeeb00f6c761c1245cb50aca24bbe6c28c98039f5ba574e0040ded46b1576492caf9b42af25aabc34f6088efa03497617cc650c3d01e896ff52d443ceefd4d99eacd82f8a4a8597b379369c2cc9765731877e5fb5711a4911d62ada62d7be1e6cf92de1bf39ab3d67a745a7ab6124b62294180f9dcd7be035f99a83e72a3d2cadfb1eb2cf5f0eadb1f39987642b667c0564320b280969672c1320c70eedc93523f970e60868803784e6aeb0217cf9db4bbd007360bff38ed409442142a083e5512a7a1e4248232fa5e5cf709fef9715c3f71b73f0a566358b9e0591b25d76a01b22ab7388ff919c4cd3845869ddcd3acf73d2db409a6f9c17187d23b360d3cae01c75cb6f175a90944dd8d454ecff1d0060d8d0abc5164468a2a9535715fa3ec53fd88234cf8eff79351cde719233ecbec6cefb0f4923649085319046d918d5263e560f0ef0edbec21bcf642f71e6ac9f6fb1adf49b51c5b1c9d82f7c5d53fb89f44c5f9316efd5b0a41ac85f618fcbe537038961ec0c07092ac83d0245a12ca9154592899278eb2bfe87ada5f691798554335911f047366a02499649d75815d711496a34c5a025306522c899ff629bbabfad018da787ed86c91e852632625732c252aeaed0c6b7f52ddd9d9223b66ec6eb9b2cfd8f6a69874c589386a6a1065f0cd8c4a5d0eb7bda657f1302a62c622c13088fec67ce79dffa48bd66cab98fae11c3679e0343b59e62d4279be8d6e9fe57b2e16ecabd4ecbe13dc284d1320971ada0cf7448b122227910e3fbc3b152af7f6d1d76ffd91aa5fa8490af4f9031a8cadbb2e2090854ae397eb72bdb91bc55cf240d60c4586ae84e9d5784e34d4f58079b4efed44054d70061b3e5f115aa58b9493447185467cf67de20f66dd3f7af0405d1386a1060892f1670e2077264ddfb6779a71db4fb20cd7ac3df7b0e50b1397ab3dc0f082247e038a80810cda112d6e5357d6ac66702d502c128cb9ca24250703d937e7a9af4201c608383f75f6a43d89d19606","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
