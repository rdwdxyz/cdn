<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"337361399f07c412277283226cba501e1f0582e7edd818464058f23aad4f0be6295aca2245876b17354b89f9e231308c9617f9449fe32aa2f570211ecce4adab584e58164214ee5cae7d3b4b45cd6dc8c1d2b0f3fc76d26092ae785cb1733cb69c8bd7eaa8f71ccbf5126bc3e64a8034e7ae9ad152fd48370b4b535afce7829a022c012e00231a50197b344052af93da51e60efbc048ad4963b59407de05c8d5dbf67ed92698daf5650e3b0569f44e30e6d993cdb8d15e2899ba5e50c2503f430b11b345f88e4b0669c2905d8182f99f93c13bc3f179cc4b8ac4342b1a0f23788b32cd7de4411b417fa382b2d829ec1a48ac0024655a7e7792b7dd9ec4b2c504a634753397fbbfcd4994c6d85f6f9b9b8dc152ba03c45bae671f7d6dd7927dd9ba32ed3fae9db90d91bae4172365a7a17c03c3bae0f5d7c230463fcd33c8b7f5142277c97b15c4944f59f85ca2940b38bdb4b142b7758ba0d36d3f1f347129386f3fbb11b7daaf7ea4885fa338a3f9c1699e13bd45d366644b16149c82e497f2310965f7c8e1a2389ddaa0a89bd6a358d5ee5de2a9e0f4ed0590fab6a083e44451302c4ea5dad0b3b44a0d10d884981f2961cba06a563e3dd93dad8ffb05f249c094d640a2b656b5fef6237601844c353205e166dfd9d8db7f55077824e08805f0be165fd108d3debf0b3acba704439ba6b7981128fdfcd919fe21cb7128fc51b6a00769bd8f8a96a7eef450cabc57791dbd002d961083c8966ccb30b26a09cffd958c45a9b185a0c10091abcb0a052fc44ffe53d78cf189b4a563fe51005181b19cb9223342d5bdbfd75354aebf2088d204b8e091e253772e36f4376c9bbe1440cfbd9caed521268936458e46cc648b82374ac795429d30f721bbe45f64e65becae1f099fc6f1b0f6a5a7a2b7d533073aa16388deb39059f89b38ae555bb4af44fdb1ad5e140b44702efb7ec804d3e5b207aab218c4a61a13d3a47388206e810210d3901d428dac7a0e11ddf111b7815c1b421bb55edcaa3d64f175fbe45a5e060f5bdc27c2a1129029d6666bd0398eb84502b926bf17e1984692e81da347e8a09dab66d07683209a98419c9ab3133bb9c7961d734bc90d6d695bb84dd8712c6fe3d7eb38603555340b27022d18b45d5d4b55dfb52f13123eadac2aa01d42b5dcec88b9633c348b215628990546e985988e4a1826ad4f20c1acfc0013885afc3329d1b28ac9d5a8c89b8829c0e6627de9d3e354561caab0be46a87f64e3870834e857882628a63e23d592af24a4b1709d2c1e3343d383d35d12d951d700ab83a1d385982d321acea7a92526efc98efaa34141f11c3ef92eecb74cbfd8e1c415fb781fcfa523dcd08ddc1620fa7c9c70c1eeba7fa909baa15f992d09e518e89b57244c4941c08a4627c19144bd9852f703c1c1fbd3ec678835df9e768e21901674e163c178a0792ddfeb4c8bf0052ede8a6c37fdd69a1549afe6549e219fdcb4d1de5d27230b15d4d738d29570af108fde00247bf381b529bd87038c554f58114d76b49f772c40bcca306f123f4e96b3af61c389b2d41d42788e7889b69b4a6d0f01b9802f98e98ea7c0f83a3c9a9a02d255c84eb0d3f9f3adc5420709e4a37ada4da0bfe8e4043e003258878b54546dfbca1eb749a7daa5803eb37b17945108ef01cb29f0a9503fbe9ed22826ccc64686f9f018c08ef58590c2b499d204e260b83d741c4b1e6354400b54efae2c2bc85a1e21ff2b3aa4ecb0b5f3e788201d42d61cf559956dc71bb7fce8b3daebd8a23126f73cf78cd92cd9f65b9fa977581718bd802c5347e64414c17424690bb19d7a49bfbc210dd5543dcd4f98102f356c6268214fe7b9b6b5276f0689a8c8856c63a0aec1b22863329ef87281b1fd76764d776eb06955bbeee4d742fcee5a2c2b881e72a22e4a79800134340f84df7e6bd699970defda99cc71a8e44547da92ce6d1c4bc6963e1a5036a6d185ebcd2dfcb5909c3af9861026ab5279edc557da9e1ff2b0cff04e6cc2756ece3f937135f6fa6b5597c7f30799aa451ee1f83fec288fb4c9f9af262001f391ba5fc601d31a7fd9ebefa3eac319e018d736199ad5e37e8890cb3826f8d332dc216f843c477d43245569d45fc285c74b408a39e678ce30b7fb1d6f1dcf22737d0404ae5445d248a79a126e1fd2e279a5cfba5cf3d84266a92ec4e3be7c8d65b8a68a8f323541ede46b156d7bec606b90e36aa1c349f677b499ac11536ca7b8f6b971d46ed76f42f9a61fb6a581877a9d9501728349be74f61b46dbdc85e27e7fc11a24fe4e359b4c7ac81ca999b6d1c3174d306af08ca0595ece39af864af1cfcddde977207cc363140638504a46392a0c7a38194c1b44b0c5f67597def1c4533657e96a8fc5dcd2d79b370cc344bd05bec71ba416974d6c6b288d80efce5efec4d53bfb68bf85b2d7413b8c1967c286376c1bc4fa55841859b3535634f96492e33e4510dd747fd7410bf923606cf1b7ef8db4d5ed2c22170a83e5e2dbb111081828bb8e7da49ac9dc0130a0e7df891952ad43deabb45fcb5344236655faff6a1816be66dab0627842de8edcc54e404cc1abc9190ae0b6f6a1cbd7bf2fceed69dd0ec1bdb2aacf5b8741b21c3d6fd07460a042514a83f3d0e4e49f39d440c73b98fe0191a7ebb3b54cadd1b307266624744199b0df5c922e3bee8a13d027451af5b069d12132a02dee7d934cc44d2c766f3a3b13f1131db84122c7ecf142d4b525a1467b89c4c06496b8b65c028d1f30039eeae32b2fc3652ea38dd8fcae0aa1630ff2a3f227ba39255ffa1f63252a1935221f78b47300479d6bd97574beb2cb79e9efba613099746aff53bf07fe1dddb5b0dfb90236c8731d29dbc9e45e7a84bb8ad6c977c79899e48d2ac37d040839adfffe839fbea6a8014f198ab73e8b8353643dd78a67028b5617bb9fc710fdd6fe30f9d6b85b070063842d83a04d8a50353dba9a7d0f7579a7c2689c556ee0551feafd788f94d2ddd10b90bc0f33c32f4d69957e1f70c4a8ce36d88f392c9bbc921b58c92ec2e2255749bb73ccdeeee55baa75772d9ffd33e2c3177adc86c9a220ef599b7183d29b057818c9ce7caf96519b2288f54d8b6ea5a415e2d888d89b1f9adf2cf912dc45d9128c1775787cbd03113e2558bd34ffd9ff25b20b6f5bc5c60831df987732b668458f0dc4a581dcdee441d2e1cf2c873817592f46714312ce3bf06c1c233fd0f636fc2eeb89a7d28f932a5237c7384a7261b988bb0234d3b2146112071fe0c1c925fba65c62699c63b853b7e8b6065a14fcdac2379120bbe912e54b9287dd109710675a201ebd96879fc1feb063b2e2f1532e5af45b4f9d67296beac742b5496c1769f1ba8d5e9e2dfd2b015ed86548b51addb194aa8693254c8d9be40a90be93130450c8f45b1f8c6bccaf826afe23620820af59355ecaa4f2be1fb8a75d69335a90c35b4e1202fb61412337ec33f2c54bf14123f618d9b7a04f77ea06c706f41402c925c89bb9145234addf693a6945e4064bf15760fbdfa37439e8800c839cae15ff15bc84f9912ae8427870932f9e8c0bc8c10af1e9e4fbac947b3fa6fc3ced473a2b70c180b11234cead2a8578c96c39bb0b8bc9f9a5f5cc056e67aafc0943792c753746326922102612ce38a607c738b74e22b521a73ba00c725a72776f21bf9be0b73222d73ec6fd000c4d6d69c134b4aac07c3af6559971c8c31350f3a976ca8346e9698b6745bfc7e644d446756c89c1928ab0c4daee7fe7a6270f3e95af789df075fcc0e6d7a89282e43673fce99a6440c0d25236aef442883b6d337b24645137d015d0f3b7ad281847b616f8514e559fdfce288f6556aa1341b5ac343278a4599c65bfaca624c01ed5f22103b768fd008e2df52630d949b458e4b687fd991869ba384177e1dd4ad297b0f0b08b45460a49c7633aedf1167dd2631808be2fd7901138b9dd42749176ca566dbefcd2db89a23a958e6cc577ec1295af1037a20c8a183fd70b0cf0cd1b0401cc6e14e9c4d03a9f92f5874ba5fc7b7b66f65087e6b64438da052c5b5a26a6e0ab84ecc944d887761984449aef6ed3a6702bff0104cee2f6cbcc066fb4eda837fe9a0c1d0906a1382708ab756e87db8bded2d0051fafff2a096b34df79f89d714c8ea61378525e7f21d7481a67564255f1d28b00a4fd449bbe181908461b626e391e182853c53520ac8ae4bcdcc3e350f27777f5a6dd7779a91ebd39f6fde27b3a96f3eb258ddcfd532ada4abf6b98edf762a2160dd2e860cb9cd5e05938c385fca05067549a3338011b1d888e6f474855dcc22845d9adc51ce1a0d2b96bb819dde190b6732b289b167601374c18da621b07bdd394466c4188be69bb796ede5ba85e4a7fdaef2019ddb63b1ac6d677f1234b6019083c8a528bbc8a804ad1c5b0a66cec1fa993d2b3f128382df4cefe848ad3858047f5eb0ce86d5220d155d003851ac78b2f2201b1a40fae5698a413251d000f79ee2a8eb04aefe01bc996b74d2a8b8dd625d568de6a0b298107f58b39e1748fcef8627766a91ae3c28939c61a0116eb10b672333aa39af0334f347653359fcca8bf63dab0d847b57ae9d267fac9ca294cdac9fb84e5eec845fbf0d692bae82bd8ae0e253dcec5b6ce17703646acbe566d015b88968982dd9bbd9535010f0e7b48db66429da9bb095bd9160ebb09ed5616fb4f34952fbc9a0351471794185f6ab88d4b7d1aca65be060dde27f6782f9424c7a3712ec7bc1462bbebce6fd7fce3abbd2bf07cdd617d1565c9998ae1781259a9a790efda95028f7340692354280b11d59b32d5f9f9ac44f73732719576b58dacf2a4fe35a35c04fabcdcbc238fd9d17e9ff98376f86b64c028ff593e66ed50acc4c2c16de25eefbe299a62424c1014f9d81fd8c998834be4a74f670369625e9707ea4263e1033920ffd405509830dc4f912332b7ffeb63b5316d515ba67f15d84cb6864aede66d81130cd8502a77762f30c006553ae118f700285becb076da7ac3bed9f1787790d3e2578516762b618f4f60520179aeda11bb8c403d8655bdce922b5147a0a9c8e6c1f0a52558bee6f94f2f3ce198a1ad7fcf908df30b4de49333335475745d7634c28b4f6ff7c1c376c35e7e34575628db6debab64e7bb93618a76f783e21358dde197cd0851e096ee0c470ce48e574c7294986dfcc85db6d405a297365452e051a00aa200ba8b59a0d539dddc625614c1c1a7d513bcfc985606f283d0d194a4c2bb0f1f15ce3943d1605146d01e9982327c081b49d5de79736af030129098640b6f02f42f1cdbd877e7f7fef28a3e3c0b5d0ad2271316ef6d7ef68e186bf4411f170486e1cdbd27dc53c56a9f394ce08897f9e2439e24090baaa967d6a029cbf8e6d7d0bb032b96c9c03e045cd2cb8c85544a887efbd946f5dd05653cbbfb42b67ab73de44c4b5a10c93c411a12a1379bbbb1de2b46765e5919e68a07321b495646e5e0dfc4288c77da9cde6d8641cc2196cbe0ad495a1b64b5417728c61e4083f2603edac59bc19efac7489e65b7c64fa058acb8f38429e8c104fee8121e49c28754f4b829623c902575b31eadd758d4d71457b3a1ece45b50c12eea4051742fc5719978f8b5336233a22f28c65613b9be58075192dcd3e5e03ab24303192e985c010e8ac8f95dec257e520eec418b539dfaa345989c38296820433dad03e0079f3871e920219c50f7ed2e3c3e986e11628b7fdf5ad95ec4e2f51d2c28fa6a6e90e81c3895ac58f2301611dab97344b5a8c87088e5490eb3ab5909dd97f74247b5871e0f1b75468c4ec2da105063b71ceb74061b248207465729f4bfc879c512394dabcb2f6e2d4473ce4fd12b63d476c8bf5a65000a76a97ef1eee1b6a95d9b940a16dda2c4bf9aea9f09d5f111433e2280e6b51755cd62f260eb7f503e5f32a6643e64447b30013d0c81b951338d406c66a792ebe4295e9af06f3f3fecd3d62e41a56646538ced157107fd28c68f03b6a4ca681a51aeeafc0a99aa9944fc180ed054e4fe80421c6b27bdd4bba2fd2ad5ec23c2f007cc8ef9264dce8dfd6490f46f2ed554530a846ad1b6b961c11924bd80b6a506dbcf67afa174c2d8deac411e4690b8cbcc53b570f48f028844623bb74389173e86ba4cc6f8b21f25b32a41e06aeeeb91b75f00844def51ac41dc1836c0a80992ae0b2a5915c9e96c0afcced87ff9af5a99a938388f92cf2e873264cf2b2966f7472b70f09ffb5ebb320c3e0ccbb750f0266d493b60624c6e8aeeaeffad3d86b2307d9546700729a2da9a6ba9ccc9027eeb4a9619d391ab8633dd1a0d8b8e7688a98dbf103e93499d5c4c9261f27728b6e6f354e00874f1cab6d21191c2d523cf733fba0944d1ed4bbe4cb9a3ce97f87872301c8013acdb496abb4d8531c25925f6856acec2f08aa71c4a2f259f7d9a9b07180f8416cf09305b266fca9593fef235a3e80dfc8fc4b564068965acdc43166deb1bfa57e48043fa608faf44e607eea96764d9fd6cfc649156195f3a8525bf80c17a82620e2c91ad68dcf0c49e64220fd82899cfb11530b8b2ded42ea8f27f85f5a257d077651257eca7862a37dc9e7b90685b26e6f417db120d88bcb53c0c3e8cc09a0afc4a4277586b8d289baaddc566095703a9b4c1b228cf861f7093f476a3aa1aa14907fd34e924533d7663a4bbc80d1bf2c2e2874828a45a37b50b6da4cec1fbbe034f624536b359dfc4b2194fc173cc497512a7d7698ace2dc20aad650bcdab8fa38456ae8186d50d9b9aa6969f4f7118837a147560fff7006ef060d71e2501218c97f17ec7bf1240ca683dec213f83c99eaedf1696667a82d05d3e3c942d5dbbcc73802b93397d43a6a56e1922d04142a6a0cd2b8833ff75f0d6f997e2b6d8fca0e0879aa71bf006d74c84d21d86fa99bed74d397d5f03203f6994df7c7a8694fe95f25c4fd5ff706675c797281b326c6fdd0a49da888c773303a3f5d1b8312c1b82cdca59860ea60ad8fb7d2bfff5d53e671ee30f08d9690f04fb6c595e46654c06b5490b80f7fd5df4af437728366e7d8112e9d020c95117b586c95f944f56ea8b7a28ebf955676aed95453a1b115f99d37f8f0ab8a623d9684d18af50f51a67bc3762b6d47c4c37cb125ad77f14c583811d5cfd9ddbdd9e88b10a0534872dd0d9e1844ce62ae28d26392faa557e3753688dbbf6f0b28422081759a06a8a90bd89f527d0630e7a073259793bcf7fa2ac5ef73f6756ebb7535345af8dfd8001b217b8e12600bd372fdb91f5a5c61c4f83f8645ccb334e358369f9b9f6c548be8777dca3f369decfd79fb480f045812993c54337090b97b95a9712a724961f1dcb898655a68fea7268488b6815e265f8cd70463b2ec80bd8f071d193482630e7abd6251e45e1796026c2f9cedc687b0f515d596c3de851a6ef863c18744604f5670399e1413f1b26f6b731e2766f2966c11e7ecba7a0271049d6aa73b4444ca275fcefa73719d1beb5a26b5e2d14cb6fc89fe1a47796770ea6830c4b343bb182e5aa3dde4995d4203f846ba4ea55d4211b60f908dd31ad634282a085d9c60b1d29dd85f7af31b62c6f8f23a8d9976219745e37980f1411b4f5e67cdb9d29f592d2b6939a659bdd1cb9adc074a3648b5768ccaed2f7a05aa5cabc7a2abd6f0bb032237fe0283d03fe3f9382c2fead863fcfe61fa4331ec8175047355bd3e5137289d4d7f35acf133b7fd6af6bf3b45a2f8ba577d912772fb40333e4d401b6277b6e6dea71f96ad89dfa6e2544870c379f411d40ace6d394587fb37f8da10ccffb2e9792ce116ff7631fb00e1189a890a485b55dd4ebd88d35db5dec45c32cdc23b187513794c25c2d40d2500e35a0892307017f8455aad6babe16101cb0e99c36da2141211e9bb4858726b3fc74cefe55683f29ad4544d595ff184e04b50fa454e92f79784ece46583043dd229b97a608da95367fd5f6bcb52207d46fba65354a80992d02259dfdac2457f563e739870ed9c9fed036101c659250e559f410bed54aaa0e414a9ac35516c7d2f3e755923c4dbd3125bc19e6e4a313964ab763dc26d4ba49c2f6f0a3549142ae075c05906983d619ffae584149d30f400e93f928ff1ec42813897a80280f09cdc1812d3690da0a158a2b4595af2363f1db5c989c09f952cec52210024f51118c91ddd5f99b3bb8a24261614864729f629e9f59ca496e7029ab9bc4a09e1cbe81acfcc219af0997fe4624851114e2d8d6267f90c03b7fbefc8fbf81cb97b822fd457a0a871010fe292ca2538c6f29044c63fe1e95644645a93ff7703a5a05719366e4a1f74b775ce1cb26c5ea1b51a0d5dcbce99d28f2d8280a1e61ee2eccba53528fa6324dcfc2a2dfe37ccfc252cc75172fb7436394bed7b098e4949876ed206dfe57daf54d49c65ea447d04582f63470627f1e1b8fc5365a37225e4e6e9b1cca9da6d445f929bc0f60353b55228a6561a011f81d03b21995b6b53c0ab1f2b0728e8cbc3793758c69e8af1415754198f22fe17a2977967f39eebf385179e1232d86c6f822f61c04ef1299b73894b4dbf203f9bae54e29b967cfa431e1a8a7d130bd0a23f938f649fae8146c1e4937a7e1e44267e0451e806fd1be4b84f23c5b5781de98a9066809f4a76a975d1efcb80de75668c5b87fd91372aed6270650df92cc0a1df9d572303eeb77f4459cf61b513a23e51303e955a6922266747e5b4c6cbf0517ae4f5ed5e8a8296c9c303cb15ae0fb5d2a84b2ca1451bed85bce6d97f6bef0964b4babd4348a5e7502be8936b3625c85ea70d8f002e0aec1f56640137f330490a677d95b54d957496466e784c7e27990fa6967b21350442ea21eec8661cf735128febfa4f52fa7d505c00237a98f14630d5929ae70a635e53872329e08025e3e73d2aaed20eb84394c2e33019b802152d67f7c381c870d7b2adb799b714864e4f071478276f2233c3959dc90340f12ffdc73fa0583ba76c6dc9a301b07fa08a8caa8e395bbd7ed26bcaf39175c954bc249214c0f2b713cdddd6ebab4d828e270f1364478b67527f756c7d9a2c59110ffd15f4028dbbfbb64bb4cf8e70d1406d750caf29114103eb30ba12179f0b5a69fd06cb252d4a6bc776165e651b4dd042c2a2683a84e024e120c5aeb0061e0390ea5863493d264a9884c5591a14d5bbaf379895a43d21ec60a894e0f38457e42b5c52e205f33d214b8c560fa9d4ae525d4074dcdd86e0d551caf6f1004727d001cdc897869a9c432bcc63c9f177c1eda04017aa752ec9e1882f920946c1d2227e9ed194300e73b8e1118f48cf931f66b99494ba15711f660e39bf0cb8051d83fa5b379101748bf846b2110e7355f0e57b586cbeb8f4b914107111641601df6c77caa6e635a783da3df00ae7082188e53ebffe0f9cbd82882bdc864b24eb8129717ce822a72eabaf3588c01e278da97b13cb3fade7d8038c670b3ecb870cf10ed785ff3148a546fb43ebbee5d68b91cdc62e1fad23dddcddfb09e03f6d0704e9a37ac350ab254f5bc4b7a35d81b494595ed10bf825ae0f4523e57832dec49666db32ec4228778c03c6345b3a203e425cbaada613380514fd72f77bd4005d5d5516e7a0cd0c9212f2b651e211f17f711df35cf1312aa620b4b5794a465347e84cd5a952dda63ffb58790a500d646f8182908da4b2e528d0f250f57472d068fd98b286ed26776f6782feaf8eddff1f094a64beff3acc7365a4c22f952b8d648dbe6f5254afcce8898f7094b1fa1e6e727e71b6e7472ec2827e38ab4f3f7c4580f9f12e3ca2bad5cd095f90a93ee42d518e97c4484a073364918f311fbc14ee0ab63a05d0c97e889dccd4c1d4ade5d1224898a2e3a17b48b87a5be4ea6de797661de3dc35e217bae4ed89f031348496317a1c66c2906e4aea45da5312afe93dc3b0f51baeb627762361f9ef430bed1ebdeb646e21cb18db8c56f66138fa2217c0d6fe69f30e42d3c63ebe29364095e3e072762d01138c851df5874a99dd76b89373ebafe3e6da21cb81486859fd5c6e5a750a90b1e52255593dbb3aff02c558ba399250e10f88f6fb02cf0234d48eebcfe4a9d721f9ae87d5156f078b342aa4a42f95507710c1141c8c1c562dcb5846ddef9b52c04fd16fad3028780ebb94ecba63f96139257c4734f83d23d1e2baec74128ac0ac8c5b381a4dd17ddba513355240cd1f836df906622cd9032e8d89501d3f1a79bb7925aba7bf42011d09061b23f3e7f822eaee966b21245a5c2a1fb4931c45134903ecb098a91a06a12baaeee8f26f41eb77f61f7997336ca28e47a4b19d236b59c36490605e0994ae5fad7718a15bafb1476b230cddb028b7655cad81f31ba6504c5bca1a6eb283f59050566e32ba7ee7e09e7a3d7451cd9bd2678b34a63d6da5060782ca673f09899a475738164f672b2072d13ece3db5b115e040e86cbb4063745d27bd004366c111d6183fd296cfc7e9214502c8900be182f64d461052da22d583f2ff6cfdb54b369021028a7cc0a89973e90c5abd5db42729309247c981ee1674364cc02b1d76b660dcf4a87e50eae731165095d3457257a73c9022a7ec321a64b276e95e113001e273f47edaa60c09480303ab0ce96b6276d85bb170410103034a3384176193a08ac95577ba595812c42cfd50875cdac22bc879fdd222c4fab9c647a2595772800848ac84c921d053fc19d9e838421c66db21a73e6342164918d2702220ee1631f08a6b2878a823ad25040de22f5df4cff7b14045a7e57717bff8c06cd71cd9a48b332a1d8b4dc74d02b14e139dc9f811e64636989dc6743bfd7d8ddb8ca1e9beac260e120934c4eb02a5c7817c240277b13686bb37833859c25b0da89307686eb094286c7a4676567898988395f62ef2ef927c9ec7829786f5f38a76fa1b163cfee59ef42d16cffb403a58117c261d1724d98ba481fa0fbdcf1769e3124c24b887aedf0e3def884a219fddb6b1af55372da7b836b6fe5d767ec1bda6d9d9e36305863aa2201e918743865a5c006e4d2072fc03acf49fd7020f4b36a9d2f358a1b5438be7eb706effb25529144ed2f2c11959d42db7bf951d6eeb3d55a122a1ff76682db2dc67594a48c3a0e2b759ab3df0e1da58ba72ded6d09a10b252507256bbcd83b26ce5a8aea0eec0c66816f6255f1992a178db9f71a7521b51d21d1c7f2e5f976d408da32657c266c5015e8cb1bbc31bc3bb039fb15b743d0845e828dde8b5f3959bb8d01bb064b2d6c09ef0fa4d34ceed93c4c857ef04a72daa3e98eb57245565d296a68fe05f37ca42d3b32176d038eab11e1d8bd445c8a6b3b7e2979a7819fb667784834ab442e15cc5278757d81f3c4ec5096d2a7e9c07e43a2a7b31bf7aa23f86c25b3b3483470262c467479a55c75789e61bafe89c1bdc0f1302375d3702719b3d9187b1e1a105172ba82b2b387b93833efffdd6d293eb675ed46eb46e9118adaeee8fc897ca188b777e12a1467b90ee0fd3e5310de1599e9916920fd1a6dd745c3f0c935f480494689af72c094493145acd09b73c825e115032f8a91ba14bcc0ce675fe98b28fdc02481030f8c6ec0651b1de02044b8b5920d99610fb297ad1fe28ec9ad524d0c167e04f773da34510aa9317bd5ef6a6bb14c48403eedd220210fba873526f22247dba78d0a3637490e1fcafb8d7379ae8a7a5891b33b4e6faaa67d85dd23f30b972f2163251ce447c1c13e6bb1055a79453880c317650ca0a3ac5ef3ef359815a2d26942732e1334b9ac55d7de3a1847b4aa0645b4906c0d546a542604e8a9ea139ec870401144448722d26431033ad754c26f5c163279d6575aa16fbde11168fd32a825be2566209f3d4e15227509e4a67634f2163de7da6d190868a51d6d9a5407fa9e20fbf9ac99acc130b25f98cd61c71f65cab5396da23adf54b975e70582336316f7f21b74d5c6737210936184b157182a5216e253e24d69ef0d74d4a4be6eab3e53f022b84e3db6bf29e8aafa0becfd42319f9c63d2ece3703b5c108fabd95029266aa1063f0d24e5953ab7ce5e975d6798b49a51c068c46021e1320004ec57e4cc03299f069ba6f234afc489412ae96bcaca2d63f6da4b9ffc90148e2d0fffbdba21ec295fa1583ab5971b3762025f6269096e9b78c16d0e8f99751ddc654c2ef1a2e01d897d3946fe2992c47f1b1e7ff2e4920c19e0138ac25807fd34cc999b6018f0b254e96832c974a0e4929404b3c4563d4cfc9b0e2cd9520da235a27d65f072c89ae936df49650c74bcced27a48a7138417e3a6003d0af9225616127946bdf87ada536efefeced7171b0d2291aea1598195f25a46c17302b7caed0d02fabe9710ef50bc7955d5db6dc33e736852194a1635f14f6c2d095684163ac8a4fe146d62cc754d6fd705843e0099dc0fd17ac4998cf8a8d73cd6333698b0e95110da0e3497af9ca802321c99e75fc00924e821aa88bbc767bda8e5cb7918bcd84e3b76c1a49f4c58e2ec4bcdd33bba3d5f53ab5f707c642ed3a5bb775cdff3e97e9648728787065a4fd7eb095f5a7e986578ecf44b38f7c4bd1546d3db2c8f5149e96c89ce600e213d16a83a10514b3d4b1f61e06fa104f5b04e698c0f93f1c1df7b36c0acef43c7c51457c81b7f18114e169e68283c1cc3e18d71fbe7be5ce4b55b0c18070ec7cdad8684d19d08ed74d91f25e7d59a77fcbb0747c465a61c27757dd1d288084f5c7ae5dc0214d173369ac10a17d1fedfd9b2ed761fb83e4dfdefc57e74d8e4dbf532270616a355432ea4e5050cbcd9ed91c74d53c066286b7344ab446dfb690c1ffe3e5cc9af1a4287d503298d4e2d5711c4cacd8af4a8616b203541a6215e4e0aa193416af40cf37aea195ea827d9c44628381af5121a1e23425b2fbfeb183135551410e9bd415bb0b5e52ea4f802faca25120cab7781457a7a2bc6117b17b89082a419e96a51084e654051abf4656d96c11932d02efb024e934bc6c77a1734a29eefdc86b90e7f4502766bf10ae2197c045a0d2284a3ba45f89f933b2d5ca19e0d1f5552f513384509cb15f5e67bf2d234ecdfeb001b88b4c84fa289a4857d398da301c2df4cb877c54492a470f0ad3bc051ae1b49a2653c4027ca5fd64596698309f9c968e2c33b0a5780e8c6cb839bb7292a4349c1ae3c57cce96ec20f20d2a27a66d6bc72a7534666123cdc7dd2254275b94f374a1d9c4b689bd43b0616142db69b617b9287707dc7f8747c9ff9184aa582729cd9f7f759ae507da5b17efbb3ac55caf1c65a5d9522eda40fc586e0f18726ca06b8e37fd023af802f8ade760e99ac4ba3f12991c57a8b9a02e3f9b7582ae9f335b73632bb2014b1518e679390c8a28b824ab35c25e9b313f39549e09127d58c826e38e792b5bd452d9e550a2391d4ddfd580c050b940b22988871cd0f68caf9782c52e3a51da28aebeb2f935c2c024d7680fedf481007e27f7c758d5fb7ee8de4b2d2fed741931c588c795e19a5812c823921982a44e973f071efb49dda56f76299fe594a7583783d20fd99bd76b153c412577a823a73b29ad651972b7dc2f15e2025707fe07d4181399642c78bd85d59ecc6835e2c69de1279062cc6ba7436e40a4411cdf4d2e5c1d5a3dc4f0f405416c22805194265a18914dfd76b282a637d908b2643e7dc562951889802bf6449e1bb29f6a16d458d7484d86624c7e54ca519ed7eec8eb8e066cfbdbee716223cab25b6c3402db90fcb1daad76977e170bd1d6738aa12823e1054f2f43933a658652816066c16101336a02098bc1cf42952c451ff49abd58a1a99b079c081c6c58b00cbfe1f8c7dd0200d4a9c2c9e72868859a6efb162487b056a15c55e634e4999dddff7c6ffa8a43d993530f1328c4bb6325b3407e147c887f7f5406bdcaf76b2b7dc124ef9bea62379e73bb7af7e6a2a5748d951ccce28f1c4910b652873756c561d4cef1456f256f6a5ca0e42ba7585040503ce63b003fac7e88f397f0174c61672e905393f930e117c9b96416cfea93237d283be49f23fd9e51c2cadd99a2ece89b56b991cef37fd1db396dd1873bbad29017300cdcb27c59d765c8822124efa1c97cc1de37364ccef74649aadf31172e10a8ad526613f073ee152d541c18f1898f0eb499104d89c3953f1ae231bbe9cec337c67f32dd2909751ef97df4ce2e881336e21dec6afc712d9f1307277593c215351c023cb274959293a4a87e03d7ce585eab3eaaf1e639e747fdf2212ca9fdd8f73fdbc484fc70200bca6533f0874cfc633b019503265e020decba032b63022ebae461117f0e1fccc8deb82e6fa2108bed539d0053e3f386d55a864b4bdec985b82d68cae39f1e84214da4ec186fc680f9aac972785991f12f2c712b9cc8e9aa03fdbc6a7396ff9e941d3c78745c82d882517665af6652bc94bc2ac259b2ef5907c60656ba7fa19bfd529249026372d53067880e89eba6b623e0cdbee36d75f04b38663ad14db1c6399631b379086bc97933d11afbe6cc6b785d0100604457cdb3ed1d26cfb72aff045cb6b5263ca7680313a44e3463b943865e0d6a5c330c18ac909532705366b5fcff1c4a42a864196e5608cce628af9bf2c25622c65b19246217e745e4e5209e3701fcc10cb9e7f7f07d6d1e683d267814c794ff9004883085228a8670edc827507f144fc3e26b383681e8fbdee1004644cc8fd75e4d2b10c94f833cdcf0af924bcbe488c35523415355a10d0e93fe4ed222c3ec478ff057352bbc426728b01487b2f7fd4cfaf3a797e8cb19b7c4e09b18f03f7f11ce432c74932828d69687890e6dfb314ee71f85c6af7ee85776e930af3792fbb4eab2b8109f1d5734fe1dc6852fe5f49c9659b9c5cf2cb044c9ee1ad8da34055427ba61c861fe8a901eec8acb967989e0dd80cb63d5eb68527b80f85c338f498e9e98bb8aca3ba417ec776313322e6587dcae4ae21c88f1b6bbab8f5b1a3d5e7c760899de4a2436a9788e243b5d0ad2fc25704b1ab4d621da51dc82e9caebbe45fd8bab94cebd849fcf4e3358fff4ec4c95a4e843e1436ab408dcca251b78a33749b5761aa8fc9388d02ac6744414744487e9f542c318513001fa666eccea21a9f05b3625fbb4ea759aeb986efe9413aa358d4cd6cf74b58a9d37209421c5e4e86f9e36de765260a11d6afbdd96d4c2d6abeaa2ed00609d79cff64bb88361360c299a649d597b2f482121521416a5833fff863fe36f7ba245d1d8746261112dd72550ea6aa99c26e7fca341bef341cf34c193931ccab6a80ce95e416a72aadca77774abdc0599ee650ab3c549f7786fb86a3abcc0a582779d53e3f9438af434371a09496f4e383852886e98443370633966d2b4f1341dceffb956d6a2bb2481f4afadaa6aaf42fcd52fe412d14be700dc64682bf6d1389655d840e374dc898760e8bc1e249b77ca0398ccfac391479be70a14797413ce4b4fdc4b22127da3ee067ec91d31d6049fdd2c512a0c6652e0575148179a5728784cf1520f76cfab4cb793a75934f42c4950187e01a0d086a0d5138ff31935bf9a4304b9e5e0a29b77a5ea435e9ebacb9ada8527bf14330ee8964b332b3f296892185f53cc707bf088a3580aa620734ca4fc46c666689e2a148431ad44e65dbb32b374649c5416955397cc7f8ad6682db1438a2a9f1acee7d14b82c084a14aa471d44bc739eedc678497f73e1c3ffbae46950dcaf78277f1929e7f882fccce1bbfdc2759a4a0ede0c787be15b07133733f69701aac278188de202733912a78ced4e1a74aebeb1328ce441e79948cd580a4f32b13f8880c28ce22dd098fc6bd04d5fd192f7bc4411f6c5ec893969eab465fe623c0c30dbfbe8d98720c95218516ec5e7cbbdc29a88f8c6276e4e831e0f484a1e15f3cc57ca603f03f60e0f2dd3e9c014b2c17cdd6022e5c4d4c01e09ecf9739d5fa0a908abd432c37f3b39cec72525e3ffa701a7472112937f82233e432f3202fc0545e4c877fcaafb731c9e56440a7e693071e5e58a304f1a10d45ca66089544c613f717cca66149536cdc392f324b6e731f00fc9981a2f2607795b6acc94204a10afa252d696d2ead8196494e869ded03b1c74ecfb685a791904ef060e4cd34797e72ec8626bd622fd7d0346499c2ba341b806238c3ced63a1357c30db831efd3f5ab5c305c8b497abcdb7ad683284c3ff358ff3b368d2b7b909e725bfab9452e37d9ace42a8f289e48e63af7f03cf1177cd92c461b93c0a6fe06c47a38e4e796ef4c88c5a1a32c7bb12755cb98d31d915e9464c41c6fa651323cf812269e48bbe6b4b81e532a7da5674a7237113be73b6ff31ef53ca19405d0dc73dd7d87baf684e7aa8425daf476658d6838d12b849f4b892d16e2d19eca915246c9f36b059eb9b0e828a99e4f1c3bb18e77ff62dacf9882cf04413537c4e8078e70eff843f1f75d843c495e58f5f8c32eafdff903619398249ab1e3e806678898d011d9eaa128598c1f90eb1d784928da983575c08bea2f5fa43f252282ef6436bce57d32db061a833369d5999652d0a0ae15ece7a25ac8bc31d1b2eeca4978a09455e69d6b0f7ecaee7d128ca705f4d371bdfbebc3b0fba8b6379b3455e3f5478d79434b25609180e65e0942f596b58c42112647e0a94df8c22a4d807ac810087fc2c801fddab8e8249534d35ea43a76c372b75623f1cfb3c88f3fd81c6045d99e7b750bf7578a950b2ba9631cda585391e25439d49c97926ebf27106d64f71d5f2b26c251f4f45d7242c3cc191b1c09e1905768a522140ec30c2db90a8c19e30962f2b5f0326665b91102b1dfc6de6c22ef5ed89ea72aba40e6c57120644b6fe48eadaa06eee7b9e7e06720249b98250edafd69d47fd10303536ffb6a87c804e228327f790a1aaeeb2f6a146fa0b1cb66610d76e3ddc197f88b352981d7806bc9189369adde85cf83cfa632ff014d3e9344f84214b536c3e7f4e1116c285bcceae61905c5b94bfaad5c5b6eed3bcb419fe8ad5fbbd1a90498bbd65f4a9f0d849ee258ac9a92c6b15a8083a1c2da0a1f15040e35a2403e31c3be5f6b80e35d7ab9f3455717234ff2f52125a20645a298b59b909ed071b683b610517d2a6cefaa972d67f39ea5e7799e07956770790ee9bace427c96ebd4c0948c12d98915d60eb15157759380e6847af0db9d73360e5f46c366ff77fd362bffbedf52e26152442e4b196df217d603d8a4e9a83e19ae0e0fdad2859709d7f3b970d8848abd30fc7563a581de2c3b43cc8228ff0b0b90521bf3393922d4818db08f1f01fe1fbafd96b547c066ad5a7c53174371d492089c631213c70bf5cae6b927167b4497d0ffecbc03bfdda41021c621cd266d121f0dde4c735dae6fd05e076cf33953f559247374ad20fd74ac114298cd82b28c1cc991a72fbf7a4c4327c6cbfcb3cf6447d04a39302a30486619d2604a7d908c097e8087b6dd1d8902c1038dab1a0bea048d69cfa4a6174ec743c00f6b64eb802cea58158493b4a46b5c0c087aa302934078441c28e1c7dd6e010d73f3309a16fedccd6175fff987c02af29f8f15d37d7200dd63c74a9d56bed8dd20134d7289a265d74ed9a6825eac423ad9497f6bf6bce685338fd2debe37f5ab53ee714bb2076a22efae8bc65f6655f566b422f7f63b95188151bba7a09b31b907cff6d7a92af10238c8e92b36482433c612c2b54c4b62133f3b4ab1a5e0e9559db8d578c8f786327df3c62720259ea1e9213b679f64fbf5d9369066e7bd7f3f47ca0cfa6094ca9513a18cf05d251957c7244e724edf89777a2e64c5df010409b5e0df71aad967c383dd696ed06031548f3e572b17e50168f376a23301721bc25e0ae3f04a84abc8973d46fa7bcb5b41851e333953834ec47bbb42ebc659c949fc0a747d0ecd60ebf6d361feee67b37763d27669c216a561ffd4941834350f7c70db725146f7043e1fafa756ccfa748c6a9b5d7eba6596387882e41aa6bcac6950ed830a8b2018d1b848e325b9671faad97fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
