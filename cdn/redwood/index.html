<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a328e249e06626e9b942b7eb70ac7f53a236cc40b270ae67251b79f07db8961d619d95cced862979d7cf0110a149deea4895e49b06d45cad1fd05d258d7984acebb2d01e76bce0b067ea159049aab2daf87d9479987b22818126701168ed83240b92f5c15e2796b3f28ae8f2cc83c4f092ac12f5c0abd5447287ebf6e8edf63d5af4e96347c1965c0c3ba536867ff480fe18c62b6d7253de0a046a887f609854b2fc4140ee58fcc1d5672a03fe2789317276231f706134e23111903ead8c1ba3a61fca5d780376be796acbc5d194006a32503fa0af85555dde8799a54157228b23ff72cd828607eb4912df78c92dd79e1f12926dd770ed0a8e882c07cdc4037576d9fda643eead52ff86b3cbe4bfe8dd4dc6d3b514230103939f8ccf6a90136ff9625449fe36199fc1805ec5e09572d8f0a19dcf8cb5952366184374f01dbde644449a83114be5b997a1f004365181f3e82e1deeb39566dc7951bde09ab4300f2dc05a714116d966453fa4201dbbed257d0291130680c36e5b1d48cc5a4e32b546dddc5ceb902c8a6aa496244a41d0e1d8d242ca74f9d6f94c2acfb8e56e08dbc7b600989e365a5d57d839df8963f4bedc1be9513a7581f3421f71e4385e22b8af27404f432a8d7469481de024b731749a92107c6ad010324e6963bae966ce8a4fbaaa622ef56b3b43a5f5267efd837db51a7d89b9c490c9a30fff5c26c8b00499905c99b9225cdd9ff3b99e2a878bc25ed24d507dd1a4fb1dfc05473fedfad33a6414319a4406030ff1a266feb68f3812ca13dcf47ed17a22276962c1e68992aa6c7b65591555e36a34177c289e708c14b18d72f1545f993313fbcbf71f21a037bbeea1a1941c1f54a0649371b3fb1995d634138709941cfa56fb68d7820f1553e893ba126ef5a9eb8174b9991369b527abc0c4c69e07672479004d961022fece35225ac6f626267dbeeacec106cf12faefc614470f0752d6137a0a90f3198b0dbfad291999dfbef7bf7209ccd7597cc0826ef1446225fdc8eb6880c1efaa64ebb18c405adc53d65e5d9aa99aca2ae97f718b601e174fceb701c2263fde7548b564991fb16893630fd6add0883243ce35761dedc0cf4159c8728a61c74dfab40f292661c1002d1130070bd91baa24cbb5dae3740b92119d2246b3ec2bc01fb50d76847820ddd3fbc36c3d41da0a9261685f59b5c49feeb6d3569cda935e0148fe6009e4d5d2c04d5ac69aa249352dd728539c2d513bed6811ce7b6ae510c7976fb2250cfdc37c5b8310762122eea3872d827f0545183535c8fb49f6729afdcdda2fa1fbb02742bcac8fafe2f8fcf3af15b8fcef51d511abd7f4c68f43d710ece0d4f9e2d81209bfeac92edbf4ff0c27293ad6951af634f5624528fb17b03bfd8f337695d4f7975a092d99b293ea415e041a366ab7ce2f12443ebdaa62c70a6ec94ff034f9c1127b54cbe521890fb769efd83b246bccae2e0b0fce6dabda616662e0b0ef960f9ff39a7e07250207ecd4d50a45535e5e98091db91b8d76bc66bac23f95e240b58069a9aa4b2208faee3fd5847af522b8c5085f36f3fd2a2207e6000b4a7e6ef1c5822b478fe48802fd39cf0fd51a3ec4f5c006e79876044ea294ed1fcc33e6e5cf0570b4615610485b9d8d58f0ba74d83d362ca646f2db1cde9dc62dc15abcfa5308891c888939fbeb2601c22b5218541895bf63bc8e68772774f6030c01a0916dd899789d0fb421902928937df9d3e92475c3d4714499d1b7093ce23071b2828802d0f2ecab01b05d3760f3a5c9ad100122e5b5d195bd3c65617a9b8c0788eb075edfef12828f36a3700088e96f7fe84d2d946280d9b030814c75dff8bc5de7d545974a2895d1fb19e5fe03a1b66747928a3652864fcdc7c29d69396140ef70c7fe5a692da75b9a197096848874a8d020341c41877f176e97d011417789fe41841ce352e6fa953941249b71978a408a0b7507c8261fc66aea6ff477633ae12bf827fe8e27bff34055315c075c50f624f5d358245c86a30819b8732ffcbe7276a7cbb87cfde5cc2c9f1d08730d24575188b798c0928d5d4b577a694ef730638dfa28d9b425711d60c676e5fe37c1c857d393adf72ca01cb1152ec67e24616323d0a729ceb615a5547be7bd317f99c1ae62cd2a703d87d2a0d54f5a0e6ac41ddae30e0d62d16367457c1f7229560aeef00398c74406c936b83b3dbca3fc8b74c092e25882d80263006fd74e7117c4733bde77b9ca7c9a5a449699acc3dd95249668a2e7b2c0170f6097d2cfce4c99b7f037b6d62ece5b7f616436f5f57c23fba1fec312bd9d70644b84f93dcf68fe9ef2f903a16f50975fac0abd083b4c4cc9c6b963ac8d5a0f1365408c100c830b8446216f6251d12ab46428dae4347b23e2ad497ed1bdaaa3dfe1d3f1c1d92c92408eb55090f0869155db016c83dfba5233bbdefb0f39c082c0efdd38ee91bb89f2f1782208e0ee3f58cbb7a1d28076b51412e4a357d3e74c7c74c9dcf9934766244ab688feca694c73c6df7ccd8b95c50fcad4f7c65eb862c378878650217b144d7c356537a0fa4c4e29e6c6657c79f885e7587b304518588cbbcb24b6447924cfeca09ac1454d656228fe170bc8ac72110cd51afd287e297e3b73676b47f6598c8515fb38ab225085bf215c25cad62aa3e8edcf76acd5a71f3d5d1a57cde839ed3cc418ffb2ee29bb101023966621ddd3380d43a3c3a763bfb05a203d57aaa82189789294313eb1e48c2f5eb5689185fd0d1f92442e381c5b3c8249019d29e8133a31c75b05c585e5ca6a8979972137ad8bb61f716923da3f8568b66f394fef816ed6dcc107ef9dc4aecb901a85f14855444223efc9d32378aeab2728303b77ffb0e6fad5d11867107545a20ee986a599b0c7e7cb5c9bddf98016669ba37d469affe61e174483f42944df88cf4aeaa62182065397215f43cfd6e1b246d70f0b9bb833b9e7fc575fa17e8362c60e51849942b9a3e34b75e7e9e4794d2417690741bbcb63407cabc9f1f9a99fb54c1cc28533ac3256a672d388e7c6d540c489081f1ee1de506e34ca31a85b7f1f2c58489a586b2eb11eac345c57d52a5bede08444a8506aaf0883c2d03f7cb9b69f8d5b0582c64b5308026f296b9cf940881938ab42ccb60018c1d6df6a66b5d2fc14374b1f48399c8417fd6a2262d8634df348cdf67ebdd09023ec437cc491d615c4e258a929586a669bdcea877258a3cdc4e0a5fe2b28f904a686108321c4a9a00662566103a21578a410aa77b4aea5d9e249315159c87d9b1fef68c344456c232f01d6f0fa0f73a974a721cde2472e9ade309da45e7bf6a30197befbddb29821be8deb1410f36db4ae6a20e5d2ffb67e97d7f713c227e587709ee1a004e4e38cdda9105a35f4542f0bcf2a573b7e044b05f8763a037be77cdc288e5c798a20a4ebe16ac47daa0445e74580825550fcc153f65acd173be669bfa53ce7849ccc91a2d258c6ccf403c96628ab9c698d68e62682e7b22e99c99c32d3a75a3ff16ff2c849e9846b50d57bf36596f912af466ee2cef9440cab1fe2b2d7115641c7dda13d5f597f9944685f3d4480712f969f7db46cd9f74d3dee82b8a6eddc565f2d415c2e961eaa24868cc11df30275ae200871f2c2c15abcb7f975bcfa389c094837d24de19d321aac2a3bb4fd973953253144c445f9c98577554c576d30ba52ca5909896683763c258d52f2e9c26a5977a3c11b2d8b34cddffed356d0add0ace771c1685b834a5b912cfb38fb3bb360c84e796c6192368fa2dbca7a582980347711599ea186e97997559c0ee57e8c6bc8a3e6592d82e8bc1be8ed3a0122f2e98cc7422371c61c2ba926da1ff273ae74e1a06f37d98c18237e4c897f9e14e77515c42df4d67d12ad849a5f34ba93c97f016147d14787ae857e7770803336c5a629c1bf947b044935f70a6f42d422449aed7be9b7423f9d00a1cbbc2282e1e9b461bf3c32cff3e416057fb0216e60350e00554eb72ce564a4e16304e879591ead2b6b9980a41ed4e539b815a0e7323b67a769ecb83b5f35fb3ea74488dd028381b90f827c4b1f9ad98eb73711ce7dcf1f9a731af502beef0410e92f1d56835172ce952126717bf315ce77d76b9a3e7b8f1b36b7fb0ba10edcd9792504ce306fbe1175ec452375e1d81aad186396eef890ab5ef24d16d34b29f12012058f6e26b6a66b3b7c5096559f887954a5d8f215430ef58cd4d548505d32d24fcacdaebcaefcf145c3a3d3de3abc3a4c4cc6de496a9dc9019b44141558435ef7dfd51a1b58ebdced34439bdf0dd1595ca63d1cd0103e9626630b709758e5e2d43fe6c83874900a3a4dcac11e0269beee6d85d49b2e3a1b3b45a0aef177cdd88c08bbffcadd5205d34247e8b6365d68e9e7665a19e6280f568a066a62f116f4f359b7cf61f256039abbf17af7a8378d9b83a929f9f1ec3f2da83b709a38740f97d6061eae486466d7ee185c68f75abae4cfadfd1d71448866e6391deee2dc6ebb6a4ca3b1f2b6b1338f26f874dbece65c009853769dbf488de1f3030fafbbcf3b1a85456aa13b33cf0c8297344b522655195b1db88a85120735d5dda495363488a8f3f81993be1bf8402e27ba511e9a0bf49c61d40b54f4a181b183a7d4978aaa92c66cc9c79b9f868be82304331349d69c4d6ffea935841739f8eab29e783c323729a3b5fd4f631404645e9133ed27d0e0c986c4bc157a624f446d0aeabab84b069a6293d8c1be0a783d7dc67a8018a7d58367cbf038d278fc6949c813dc3db76028c8b6200aa414f31f52c128f3230a0e126de27f0dceb259b6507a2c365da71a63309a6eb81d7c370aae1035d36764f6d731ad790973e190079f0f3f30b43cefa3a78fe4289276eb9354ef0945c6127630149b17fab087fc20720cc436f554eac9f7eaf24138ea89fcf3d421e96929e7b7428f87e750811bf92fc53ed22dced47b9144f5ecae18563fc6b732d5aae9511b3fdf5f71b056e8a8ff2bf28ff80feeea0ad66504581ee3574c4b963aebac70a763943ad7f4e5ca5f03efaa96cfd05c3a556d6dda88f6dc3b413fc88aa4c00c5e6757ade6cb1ef61ee4d2f1d90076c1345a0a9e32991d54948932a9c5f956b6bb94e966d8d347ed930a34785b9cc75312fe023dc250fc3377e439721c4a4a2155cfa3d695392f8a4caf02bfa84c324d34eb7ed7bbff4f4b5faf202d555d6c062ebf545c4389276c3ab758d6a777ec6ce8677709c4180e968134d5741543329ff94616f1735927d7a41ca7b42a9de5437e03702f7f0c8a0d063c96956c8cc3a3b326bcf01d83c7da422f20ff666dadd488dd660211b540d63cc2d69f653f5abad2882a04b73f1bcd3f53b328e7f97eb96f01ceab7f86b4666dd1d2da00bff7e26d8a4c9f671c8fc821c018fb99e9d0781cd8b5a5b272ca9996bd2d7f20f807a81eb6a770edef5ff87b9d8b1b32633f5245cddd3310f83efe84e43c7cb435c90d0f3c4694c2046d6e88474885e788f5b5d23188692d353615d16c11bcfe52be9dc0715658e9c870afce645bf531462e1fdc61de24b0310f09de796124024ae14cf645b2cea6d49925930cca4aace4e40fa07c3da593048181aa01ad218cf17e5ba3589cf570ac3ec90e4f9d4ba42e0ff3f9a54139ff6548a7756450dd86844e43c914797d279ac926f0010bb8794cca7757763d00f0d1593818451206fa68228bf67f6b09e9cdadae305c5f39bb11bda34125d7736327784d0a8f274bfb18778a2ed2eac51d87942ee26b8b395459dd4d1136f7cd9eb61d228d1d159dfa486a148109f31bc1b20987b56e0b28bc72d9c1622af6fb5c5437221390a3666ca71d3cf1227fc40b38ff57b157be1d61c717083c2c8b321e6110c3f1ddbf2ec79bd0ec514cab9e7b81882d22525d02427b613053968732a5e7577bc2fea513d6c5c509143da8576c6c188b6f171d16e826b46f42bb5652ba5e62a1fdab524e82e03cb384cd3bc0628135d32edcfbca734b46dfe12e54a60c7793f4b2506a723a0765741d325d5a421c966b58aa6edad15c43b92696dc8efab5766e0cfb4596f7097bc6c6f9b981e51fdef60af247add5e72598989c63c4cf50f406e0c63fdc1b1161568127a9ddebede02d5db3332d2e4e0b71d2ea1b2963f44d889b3db247248dede1acf50d8beea4eafc0e3b1ec94d35536f203d3ea6a15a0a62e4fdcdf67225c4331d46b11aecd176e8eaada5b111875223f5391d8c0e44ed5be9bfa87c0de44b3c9fc780bf50b2bb920787d71de860a8e0342e46d351f50611cb8c1aa6dcc198555175c58822c13c9a57581ee0313f331b9c9a7811fad39e417ec01113777c4fe8a45da6540e1f8d6d8a7d46b993a34f5f6800f6850cffde0fe05489e14d9e4820048afc8f1a20462a1eeb8299687f4e20d9dd8fffc94ea53a5d89a2bcdc0f035511e088e9dc0297d37c0c9717fd863ed93cc066fef82496462774772b9363973946c3b30b2c74d059ade1e6799f75c3228f9192fad5948d1179e15e10112fc4f20d123982c056dc732908c68bd335b5b3bc396909eb9fa2c7f11721ebe4979255cc912b1ee666365c1a97a739e4fe43be0933b9d463b83bb7db57bf99a336c3a7889ac7a51b5de4cedc57169a507067a664f916eadbcf191792cdd4912e74b45683244c759c2ffa0be5db31730cff5f31a55a03588485c81f58502e76a7e09f1cf27d7d19cebb7b4d05ad81c9e29fbf4980c406f6b3b42e2734728edb7d1465d90a406b059cc9f79ec6873440291a4d01a54e57419570125727d12d4f779393da907bfa18dda47e6d18ad48cd7def62e02eb5d10cf90536bbb24dece7e3e10320c723e1780977dbaa55a632b2ce10dd8bc0116ad995659ab9b4221be8f7a64b6d8d2db2593c9cd1b14be25c56f783f400cde65a923ce452b6227f7a707c9cd341b1dd289a8db0b3eb8821cb9141d97651199a5512a59a60477b3d65b271fe438adfc4ee6448e87ab9fa04295fe4680973a3c75c83708620e941f8ebd2b88f4071b729e039dd0d74216627dcdbe7e3f8d4744fa083f27feb49f0cb45d66c90d2c786f59d7a4b9e853c75de915c6ade1ad10faeda26e99746acb7a8c85e6f3cc2f1400e370031c0e388283e3810d117661e58eeefd368a99be0e3a8058fd25e9c2c337d1fcbcf27b387c848686ad8a21c4fafe5af955dbe931a07075f0aab40dafbc0817b9f7618650659d63d928d9d3fd91761dd65d212ba7f32090e93ac0f61d1f46600d4bb4fa93e5fa3d21c0b1bef8e77a1e0c331d62791e0044f750673fd0764e08f41eca0b7b72faba2fd323410a5847420c5fa626365a28a478dde4df9366215463ac68d719ac0a3486695f90e37b37c6b748e546772142aa7b99743fc61181b50bc5a7842b32ea4c06028bed001c9b7dc33d5b450f597dbbfe0c3a225750c46834cd676c148867eff377d79d3dc9bff87f44c7811168c3c8ed76a82e1a43bf1b2ec6955a731ce54e9ebe800679624cd860ba8f5de4045d1ba306294875e9fb4415931531e2a61b1acb497ec56c19ffc64bfaed9cf028bd3e60882ed1221710ae875b630d8ebeeda1d691a0e74a7ef9a72b2a5eb752a1bd0917520ad024b04feff2b817b370f5ed990af589c51f3a0a7fad6254d6eec5816333c6f1b6d4a1b66cf1e7661716c8f29fa46239a3ba88b9677b86e29589daae64c93599d6d1ae85bf70a46f27ae2ff3ded2e115e60072d4c78f380440cade3aed1a36ca9e96aef6be14d7278e9f1fbbe1b8d2b1ae7ceeca81d258b87e137281cc6b1560764e6c7201e0a3cd8fff8f4bcaa4ad026a7e3208e99ed94f58030e51811ebce722b23e44b33b92550f7a6fa8c9d8af2394e4f0b5668a610ab53ac8d8c43b25fb79da8b44682c705e4287a703de97c0759d0ab901ebd574fe01f969c12ab1d55cf2957fede25daf4b14a393ae6eaaf452f852fb9fd3ce9abf933df633dc0a6f67634486e25809bbd1507b2b78dba5e717e1957e5e39a2fba98198f14393ff8ec51a0737adc6483d41081516faacf64b5150e49bb3681c2138944bee28542d0446d2ac88f8557eee7ad404cb36c01b8f67343203aaa9cadbdf05009999d150045174fd71ba92374a6946d00a6878c516bcd49a8d9267c09e167b979c34dd6184f85f7ba9aaad5f99eb876e103d16218b068a6ccb76e70186dac2d411f304ece30bcca86cf222c6841e0c57a58430eadde01febdee06a51f0e6db64b85367b95730165f608840adfb49a60526cf53dbab7e67c9bd5eea749c05d3d1dc57e3432512a9f573f3b3ae6bb890fa2bbdfeadcbc51bacfab36d43387f038a01fea946173829b541d9a5f36b61ed3a2221bd38743515aaa5f7fd677b37d76b0284f8f42a3113f52f36d1a72874a296f50ea13e250ffa9c3c68bc8ad8379461c806039a085d331fd685dafb44f83abe0045859d55176b0ea1c2f5326eccfe1360e0e5942b29b78a9cbdd51f0c7bc7551c0f81c54e01e6c9164116a1a28c8a34ac8be2c1285167120285b19a784110253c9fc0da53fca43c3b462a059c3ebf6e882bf397b2818223a044852c2df0daa4294a8f8e43a958f4c017a359b8fa5e89165f853366eb6959911157d622b1423ccf5e205ce8d1c0aa90d2dd633aeb6a283fa3d1a64e64e80eb02c3b19a0ac2dfeba5ac6fe89777b1eb1a85373e597692b3ada05bf7c6a28292cebfbf738a94ca55b1376219e836a7fd698e9a24acb69a03c3bcb4adb4a1007ffeb9d94838e245348f6c09cfb83ede4b8fe0eaa9042c9f7cb2f93cf58ac22ba11cb491188925fcdcf3f520783a4f91e7f2dd9fbf0f5d7cd3f48fbead9ca8be826f08e7dfedc268678a5cbee12714f27118a0461142e3e6990d4375eb3f11479d72c82153cf78520e99eea1d53a1d169cf73bc7329d1682008a4b94af8dca8524ed2a77ef99c5f608326076e5c9afacd2c151a26bd68b1cc635c1efc74c918d5267d01323360815c626c1b9163bc54dff4b91ed37163b7b04a84e3a16d831a854ef082feacb00652d4f129d5638d88b8226a8e0f550ddaedeff3e4be270caca8fc6ad7da9ee0d6ab3b954b306ee929920e2695e2d069316442b71dae793f4631064225080cad6fe804741fbffbe382fb97468f6c2267adc7998e8c07eedb972e61896e3eb603d1b3eea550679e2659444812c0d0aa301302a418cb3f871b3ce92abe946c6938720521dadfe91a2dd44d9b9ec888c043d48d69ff9c69fca8a054fe939b074d7becf6b5ddf10501d8c6afe65bcffe9d112bdc6486128a467f96f26d1424155694d47e45a475ec437dec74d52fb541469e67a7eecd374607a286c7fa81bf7f7cca080637e3eee8300b66ee16eb6f72ead4e52991cb0748eaa6933518baf7473b442f7bc0cd495ccd03e6b2cf27f98ed5439880451d037e930b7b2744f986dcb3d870bb1767cf7a1a2f575da1acaa17c788b42f21cd609739023be370488997ab67422e7eb2d56f61f04c91cd4a8e8916e03073e66dcdfa9221426693df21446190c6e181a7450775c682e860258dcee9b945f13e2cda1a555cf756a2dd363eac813c37f56eacc92458711ded898d13e146eabb2f4d8983f771d6a4f6b7838178e9ae669cbcbc5c66f7dd5b313ff1005906abd898ea1e6ed4f714736f7575b49b7ec79cdc72ecb851e6ee81bf0e590d3407de8daff72fb41eb036fdb631b3ce8b3c5ab14c2bf7e8a2b71d4bb9035133e04213e239e9a7b32387f9341d0d2f55713cc482b73546d73d310a9fa0cf9adf0b39299c139aaa09ccd0f565f9e5c45c9242e171d93ef26fe2ceddad47060b634971f3224fab94accaba251996b1015ae960363e8223b88018955bfa2c4b15d3b3473cf096b518b20a3d1c34aec70809422aa622f17bd0956bbbeee90df9f469ae0e46a7e9c03898cf1f1fe0bc4242fb2f13f50804616db9dbd243299226d932a1b83987974f0399a3c1295f9b21a50b41d3ad0155e324fce74e6a5fc3686ee896ff911ec6f6cdcbfb97dd2faf62b584103d8ce87a26ebec867f3a85550e8097e641849fe8dadde767821adabf8f03731df6705450e1274644b8d67fd37eb56c81278450447468582ce013a6beb43061a2cff8590303d0d19b972e2c2d6c278a2f3a92ba57a6a4708fae1a4377adc312fae0453d01340efb64c20d685d1b37b9a67c4901560bfd630c5205bef35323acc9b40bcf57d41b21bd713236f67dcdec9ec85c392b28483e3d67140753228bf82ef46d9d6a7e6fd6eb3fc28d8185a0a55cfc509e6de7f7261a884bd3dc304213256175e57bd3e5ae41981b0621a3534e2cc68b4621244c154815f2775d856658c2294ec94440f849593f75ca2dbd9fb8c3b524b4bd06709aea249d1aad48bccfa4001c8fe96949f451f0f7259d0bbc84586eddd0a128d86f29f93c666a71e3325798487c151a33f0f1fcf408682036bba1387ce26f8c3f06052358b5e374bb7343eae814b456a36b193e608ec57a21a9fe7927da612756182599c122266b2b0ceebaa547d8535be5c9acdef76fbe563977393a990d735a7afefcedfbf0ee57ad008e7ecc20f09479e9a62aa69f47833630a019eb7e2c7a313e7c6a039d0642605a0c41b730141cad0ef91df5100a10c9815973558dc266c1fb55891273331699d42ce50a646f189ae227329b0130c5b3611ac59a544a9ee6566358f36af0c1812a839a28955056f549ef808b596711afee791176ceca4ea49c6f96202e7c28aa8c1a022ee19f23b015b46d0d5d48232eeb10c6715ff13f5100e0a834a96c5e878c7750d75a76cbe187495848c4c5b06be8dfb7d6e5cea9a41cc0c9a0f6d2c4456e75a3daa2ff6f13947e789cb82175b6de33ee4dde4286a0a54a5011bb5fa8b02e431ac36be257ab7f4e14fdff1dc034382bf21b3bae0dfcf59ed9410f3adac9318403b69d1cdd0d9630f3dc7a69b14587ca9010a921262af597926c41bebc43dc3f8c54e6f43b7d9c7f14b4bb784c62d9effd98d883c3e79658418f654ac121d3de0cd096c78656be979f9b38fe7a7f6b56ea21934b4c7e6b896db949cc50d7ca5fb030902c37419f25edeba49552283551a7fd341af705611d335e806569f6de8f262fd4ff45ae7381a0535a70f36af1f6dd06052ae9d84e85cbff0bd44c0d7e36e64914d9b8271b3e5c702991c14ef399580772504db46e0313d96e33467beac1be8a402f4fdcaac1fd20a0074fe6d155d1f3eca8fb6b0adf66bb3e56e2d30da0fa900eba55b34e83197304d9b08a6c65a1843d490d80c409f28e8d696824cee8f191d4d51a94a2e987cb60e535b6f6832f3cfda2299d9b946817e0acc62bdf2024632d5c93b901b3d9acf045d94f64e4ce0d2d50f89cc5da82fd1bee5dcd6662d8e9f607d03aa72765ec33ed8996a254b2fe1c87a634352356b2be2bdd5bfeb252084bcc0ac4fc336f880b8061d8f53ba9f51f7412a4289c628da4f96c10b971cd8d2a31f5db012b69f4618c94e21aceea4604c22cf238b999147d31f0739f4daaf9fe6db0e512e819f6367f28fd7cc80328b9e4bcaed83103c4d93e3bbeab94e0d7e34f645b58a8565def1b33b3e5b7ebe625bdd44699d27716328d8d44c03ae9d8fe254b05faf3eb6600b9a62f7a9e9765322389db67d746a8d4ffce9c9ce8bbae5b28c8f3fd6c34b9600b091d4e833cf5e4c6dc7ae9d1db8cd2a6c69074ecd127cbd0d4d426d4c0a2cc9fd885b6f8afccb94f774d22f0f473b499217de2694fd4523aee088ff397bd39a26f3e6f22cc89d9a8f6b6a65d9ce583dd6c603a4c85266d0680baf4c822075718c4bcfc03e13737018aeab4a65a70838a87cbd9c7cb4c0ab9c28a4a0241ff809b41e1c88ac7197ca14597473c068ebff9f6db330e69840e40a89f2eabe66500d0db590cee73a4d34a2b94a04832289154fa4c4ec5fc97fc1125a15e51a90e5ac5aad90bbbceea58575bae9838bbd6aaf21af8bc8917e8d5b102962fd7bafdd4a16554463684c8dc7d27eead94c987c396f33a1e721ec931f399e3e5c8481ac3bda47d7b22dd092d554b73b48837efa125f98f9c454f1785154cf0ff1e0c233503d36a8a3db5954504d594f36410fff467876192c9fb41dae4916c94963860273458c3001d5cebb7f2d3998018f3720e25f677bed3dbca4ed0844b39823de2df7ce107b57c01921e498256238d940561106173d35758be95ab76798a792567a6cbff9d727fe2fb373378be836cf63bdd2da08d4e69b89d64bfba11679a864c252a44efc673eaf919fe1c02267e297643c7ebd24d7a351d8d67b14b41bf4eb3471ae39634c07625d677a0b6fae3def71d5ddaec03ac81763f57c22e774da4ad91eb5932cf8f4b60855742ad4c767bbb330e44c81973909db574c51470d7bcddec0289e9c406775cf00e6a7017da139faf1290946a3de99614cdef968752c3d1c3d23be145de9185c6f879f52d3b05bda75540237a11496d7ea0d280786d98727a15190c9151c58932be63b7ae9b479476923f3429d01a0189f724540bb962833c6d62b64a201bbf11c68becc776bb9619018eb98aa4b3a91bc0917cab32c48e0cb2030dca9dec992c3beeabececb1bfacd20a7cb5e776bbc263c42de069fac69ccf7c02aabc391dcc071ca0e18f88feff9287c4adfeb7f2e7e20c44f2b29122383aea7d7b1237330a8b0270f2253e2e50fa804a431176a04eabe6a7872c19ba26d85dbda49c68054fae12eb8ede0ee493e6e8beca8a42df79af71e0f550c75acd40d21d052f32b35bea63fddccb83ee29bef2589342db9437d791f3de485091a4eaacb179f701838a7940bb9aae8eed91f7aa337c661c7fb25adaa14bad701a06e0934539cdf30238054b2fb6c21796500cd5c3e35f5aa260b7e9bfc3823e270a8836ff5597040620c1f4a0fd930ba3c680eda514cfadc7eebf79bdd66f0a9ac67b4cde5c11607cd84b9060cd1c1831fa455474fceaf231d2958631bc9fabd9e3f979be9de1b771a1c6df69dc4432c9a7c527d61ca0b6a709cf718822a0d91654448a7c2fa1ff94af3d6707a4b8f8f35a2a294302dc73aff81a5ac5d1a1b3993eb924b5d9f456da125d6c54b357ef9e0f3baaca534d69b7b2c29b840b6906567cf0c05c572239dc222c24edf289077d59a48daa62df4fc1b990ab8111795a76f431177fdcf7d2940ea7924c35914acce3b705de86cdd30ceb78ef3481eff43f141c7bd9a572c2275566c6f6ebeaac9df8d4d7355bfa524f9b2d3d79ccbb9b39f67b37d065a6dd5eae02330a9f45499859d7228c823adb4f6bc944967c3d1a188d8076dca91b6cef75df44e3931b6da0dbd4969ff4d546e47da1682081fb2750634f5c186bef4b75a66fd438ff7c8063c4a79b257e3861ccff55b822517ee7c82742d7b2230757be80be6202a22081682df5c1e61347b39689b85787a09c1d85450e3a2ce344b4e733ccac58739b6d4eba8c070b0784118b3ff104948a877b450449b6bd9a396473b05e68d319f63b5ae984051d02245c12f4f9700fe33e01e9fb677f2f37e55a6189df6dc79707901075a7f1d657bb33301d292f3e712138c7a0a0ef34299bbf6d8986437f4db40cdb1fc68e6b40154e97f77408087ebc23fff444b311950ec946b9a426742630efad4953d784ba60acaa4782878e14c86764977de489a437f58cb3ab704b4a0ddb2e4e92d3cfe27ed922bc473f604912e9ba9d4b9ecc0977e358f9a35d1bb260db024f82b081f2fff111505c102cf5bc65739b1f5f69fd97db4d098a1a5dfc0d002fe3477cf022f0203671d56e89eb844d72cda24eb900f400c30b6c04f62e4684fdd254def70d6eadf8989aa434223158f7de441ffb95e0b7825a66f0d74059cbe2e1d481063909939f27c4f57c944488cbaec9a23e5e46199149ccc88e5a0d990451ce4f83f156befb0e94e1ce4d7e8688aaeb1082801966447b251bcff0b0f983f4e3f30f65c6120942d9e33586889d22b208d0983a21ad70d602df87a3e1972204bc646619b63270474a5be6ef110d229ed0e616aabe67289c558323ce50f5a88ad543729b771d757c884a5c0196161a91b6dedf528e29193a1cda531e881f85413f8829f5c7e24c6f5ca3d34d53adc686cf5ccd67cd1c8b70c703690b4c3666592997e4f6bf94df9a2b44891f7ff09f7575abfe8b8d7ca3b0a78bae0187fda3a631ceba3a7c422860859598cbd54a58dedbd1f808ea27f76eb1be69c19069ddb38024b884047e45f447546d0b98979a8cf57f0a83db8c889eba443a6fefd73e752c6a784466ef700c623946d152e52fdf251557f52abcdef8dae480df828e4f5b5a6951317ef39a9edbc7e588f5f8d585db2185172a4c1a22cf9da38e97137e3137d1d7260151da42e12d00c5d463c63b492a11f300df1be7f101b8cd5ae8892c5766bbfb969e97b26712fd97c7b4ba38f54629cf9fe4e31e79b0632b5f3277216896e890e8bd77f17145a1768110628d7be34bc9469daad7629cd92c7326bb066313bb53eab5aee57a19553d409fde6c742b5613f8c08752774993d0b6ffc6db1d7e35a42a944c70ba1a7c8d16e2060495eda44506b25b0f791fb169a1daddc4ace171a96688965eb9bed19ce151e9ef5b816717427dbe5e287772f6afc123be42f84670ad43224c8c3a5781d4448eafc94123a1658903cedd76d3cc19316156992036361d7b58918c48a0dff2c0d1df0fe93aac727e33d02a88f2d816feed41b54843e72047cb541c9964a510fbac44974f9b3a1a32b49f3192d6ba11aefa01fc07585e6f5592f459c97acd3019061550c13eb839533fde2759a631f74919898823aa705cb65fa4c75af9d9c506474accd749102449f13c9fbf9f3fd97d2ac3fabd3513d822d03971bc9a9305edad4f17e796365cdfc177b9f2efe47ad0fb68ba97c7b6a95654a554d64f592491c7eb1ca49d6c828c1ceae301dab2b3faa32a11b3e13cfe91029393adf83f6c062b48e1ec98db224562d5215f338ed30b7c3dcb276e6492a1caa22593df84b75f57c0fe7f47498ff6f4e19b9de277d3dd4ab0142c43ac412de0c2690ce6f9713ca1fcc2e3c3f2d0ea47de0c43dddf2c91b74e0647bfdfc617a2a3978672312bf7c13ec0fe81929e9c705a311d8bba928e5b8b75269c6ec46e07f6e73d774b45d2e58a331de92d02a7076fc1cbecdf4d235a06d685d9d44849845c0289781e0b02a31f77f20b15741ca157097fd56e73a592c81e7f876780bdb402145cb35a43d59fff77e759be0d6178c66269197d6a712b679688bf2f9ebad7602798a7c82496205b0059b915311cb69f0337fd84e7c49772b1696e51047fe47c08c61b9152ad3ef56f03b48fd5def00cb371f68d94f6a0894150acdb4af849771ea788e4f2b3ce289ceacade11590422d23f74e77579099edb089904cadc71dc9779c74483958ee9d769f5376513687a62a478210eac74566b669629ac4d99d1512d76f534dacfbfcdf2ed809c343bdc41c36a3f248900e1962c24a7c31028d7f1e346a46db23a6a350fd8f136f8166f44a99664d14a893ff381f5b1f37edc71152d02d8ae20c4b383c440385aab795c929a6b85ea2105db1f56519a50b60572f2ebc07a754747ef2de21105681b199781d08012d9004bfb8a68dd8d5baee220b14a1ae760519b1e65f69476a15de35262c2bdf154a235aa9cfc8bc66217926a93335c7f7c6a434cdfc873e0ba1fef8b3b9bf6766d5e79a7c95fd21bbdf4cd83490b8425b87295b608dfde5b28563a0e7d821e5d2739c15d57fe18a0fa085fe78193d9f7bb69b55dd685e722ce98c40271f0665fdf62d69ceeec0236214ea2ecb7bd1d03e4289a3d6380fec88ddb1b5d3400ecb8e9de7c835ee86be751cb01e89a09ca395dc86ab33389266e4382107e6e89bc5cffb48e650bf64aeb4fa762b9963cf2be9ec0b39b0ff9547d5911e6ad6aa310de9b3c6601c5d206502793093b8a09c110d9172a511dd757bcbe058bdc4b1cd2499f3f6deed85918350bd2af79e14203678c11db5e28e295ee8e006adc840ab0bf34e20d6373e87e0718e41a6d776f4f56f38da3837520b8c6e85bd61e77d8f7834388418317548a8805ff9fc2ec138e9d2da6043508242c420a20a06e726aecb847663f9bbb6ef7b2039a688192edba407634e89336e7b558930058055df4f9439d0b82fd6a34a2a31ebdb120d7a10ee8a20794a2ebc399fbfa132698315a3e58180e4a1c5a8273bb9057263010100c087b04a635e3d1768869836d8dcc077b1a0e104ead304f01227d8d61aea659662d90d7b9425d0e75a2f759dd3c9ad9dc91cc9a45750d13bbd5ddc612b74d9cecad4262248fd2240a1c78b8fd98f45d2eeb4c0cbe6d50561c7dbc7e4eef75667aa27843b4a65f8f9d9aec401aef71b366fe543855f62779fd76e42909e6e7579ce865c84a5f44e86c71f6636b6e957b610009b038e4c4bb4f40d768f5fe0243a6efd6500474af8c9acc2de4529cf170b3b11de247570727d1b7a297c51d7a509a35730fc5559d725fe93b616449cad4e0a229d2e6c8c26a42f7228c1fa2787a4c3767238178fc3e8e7958a11e4c56e335163d7d2ca518da667a7044fb64ae2a2fddaf646690b1f7f4f928c59de82cf638ed7b0df1f150935a87ec441a3cab1771b7c85fa0c75a59a91acf6b43b015c4d27c7feea9d26454e192ebec64fbcc6c4af8503329af81fb852df7278bd2d4ba0d63579f7fd9bcf4fa522286e9e9cfc079c8127636f7f482bc87447cac446f35bcd39b1f06eda58602cef431a72a9016ca875719190b6faa2d0c5fc37cf15c7be5187cd13bdb2c6b55e24308c868d68238411929f9de265dd9d365402d9cc930d20d8c78690ddfe75e09ea25f770012d31892aab20bafa4219f2a78e3e7e876b0a2b24b096856f88c6f39e747fb30653b188ade9c2298480666a8c5bee97f45a759e7a1afc71641bd4883675e047b1bc7d6e00db7678878e766dfb680eb2f2db984fea33540992caab4ece081b6a81c1225f398a6e7bfd43612134e185ddf2435be4a6fe90cf2e447d42573ef89ac8c367f4cddde8600a4f7936ca26fcb6799f56c6b3369e64d52ccd31926d94fe5090c25ea161bf79e83e8ff219ea800942a2d9163a564378b15cfe2e51587245063d495dbc914662c9575e8102aa911ef42806cbd3ca39f7c80365ea5ec8fbd050226dd82652e1a2c5d692229f1846ad14e3b7c1336b651bf1c1dae90eb748fd301e1de2f3091cf0aacf34d101352ab0e6d0e129633eb74d0b3ffd5bd7ffca7e1f42ea43a84579d5ffa1b8791622a4a638557b7c8ea7ffa0bf427b543faf00119ae436e739d83786abb064fceafee5db29602f7e867cc4bc2e77fee88e67ffdf0aa6a6f593ba895aea1512278f32f697d77572a29d8d168687d5b9b27c400a08e6d7850cf615a3b7cd7d15ddd13a09060000e6e9fe29cd92dbe2f8b1bc9d4c8bbbb7b7b355d78c4e16803c9ffe52efadb4d3ceb86f433cb6608f39a388aa57eabe2108ffc1037f5f730dc8916bbcc9ab4e312388212b72f2f72c4aa30d8e951d589a8f3a6b6ccbd5833214299528f831403be7c337b84f8a2395fba6eb88cb1ce510b8c3d7a438cbc6504622d06af44c11c76fddced11e780c42593468f3de55eeb740d68f25a7ff1bfc7f7e63cd70b1a22375dd8c3cafbb55a3055165168412d7e3a9c8526fd471e2d9457dd250ab38f1878f2d40f616eab9bdd4ee936fe9366817b80a2e8c1d8b7d0795145504f58e30446b2eef4b3e7ea1d802819cf97457462d50ab57bd3bd97314eeeb36b85c59d8485bec81514ad2a74e455a385fccd24dbf1baffc18b840d4921b6886c17325a50be0749cd6619edcb67e13e3b940ee21f21261c61d0b37bbfc5b091a3d04063f3a12f4ec16464e795d4247944856ccf8d9a37130a8fecd2723a84240d144de9bf8ea053f53ecba884946182e022c24de63dc775cc30dee3d4723ab0b94f91fef25d02166956f98dfab664aa14bc297cb7259497b844ea374e97ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
