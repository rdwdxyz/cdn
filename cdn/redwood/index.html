<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce764b65072cfa606174313fbe110a26e00149d326d018cf3ebd8ae0279817d3688f455b3061b3f117252c38154d947e49f4564ca79c989ca1db3652cbf07ed1ad46a7e30dbd6b6cf5d685e3c5e4dbba5c25be29b25cbc3b06ca8b67fee84a42ab077da36bb1a584caebd45afce09beb58c3dc5cbc1cbecb97c0ff6f9479586c9360c14ccf29dcf413650077eaf0daf67a5a144155a24f535d3649c237a8f5522aa07b016bcceeaf825f3f8274f25aadde315c3384715e33a39f947c813f6659c495ad4bc9468829e9a63ce43476d6129e7ad72bdcaf683860a5520f4c00d54d1125910d7a5906cb8e7a8e187c5692e2e59f6accc7f80307f0c023718991e9731afee000654addb5e0ac45f19169183ed1fe59b7e9ae89cd8b830e62d53a5e04a1a0a7f28f1d1d15252662000ac98c06d69edf9092de2e1c85979178db30eb83b6e0ab0f389ac5e0891448f4c30d924651a3ff30703fbf02173c2f29c15cd75063e6c78dd349fd004aaa69cac43dc0a286f88edf763c31c0220602255825c2bfb7377fa04e0a2b7d77934509c52b8b54412fd69274bc1b95f35e561ac97dfd7f6fe7cadcfc65e96895e3cab582a8f7cbe1758edf4aefbd8dcbe5448aaf081b548e847c57050f3a525b347e08b8569fd33ffcca7bdc350ff62b42cd4e863b589641d1108e914bba2522a11e8e08d582687714da4a998ba4e69ddae40abf7bda2c90b594d62598f7dbb94127f6ff8332f7b3a72a712026efd48f425fd20d824e4d429646493dccb58f2304405d5255ef40a748314c11bbdedefbf095253b7a4b298ce848c561cad9d86483e1b388beab413ce0f626bdbd3d3535ab321e7ed195029b30f602d2ba813daba2d559729d5d49b61ab08b75820f74c2d19c3735c14e764483ff54b3b5654df709bd94e8fa2f9fbe535263082d77bc9b82951bac6c6dab2f64526253798fa3d90ad98afb0aa3687d32d1366c78ce5d99bc64ef12c39d44064ffd6abb9229b327039661b2d23e53d48771144088f0c6de766c9004595a8cf0ad6fec5c0dabb44363a6c6b0e1d6323e07733168bab16ef6cebfcdba8677ca27f797fbf4692c50618a288168e30a241e2f83e5ce66dee4436eb0ae5aa5d5ef2219e5add9c26d1ed95ce75b7a9be45de37012a32d6b260fa57c0a8870f850f1b58b7b90847c693400c78a2253f475609a31f47e86db4edba9037f32cb61cc9cf92667ebe34184845286f3a2f44026e5e84fde42771d7ae29819e9181837d9bed18e806aff7fdb85a6875f6d4ed0256e8f012950be75439fa31ba9ebc27c1ee0082c01ea590df84b84253871c82e6f395215165c55c87f283ed44311bd2675bde0c89e62afa61159c37fef32c681799dd02dc88b310efbaf0cf864a1e3f5b1fa65aac363fca4ff00bd191eed42a00235f2707fd61255284ce01106f5a4bd4ca300847894eef1247195c8ef9e3a98cab46a61396616ecf96bb918fdd4eb5758a1d75220efd79054ae5121d4d526eb831537731e8c3d50ce9b3a46bfd649b4b635f30798123c1048f96b27d0d594be987f85e86a6cb09289462dd01d0c875c25fc68c7ae537117f1bb98e7534e9d7652820a2d050a91732c2d4efc78498efcde1cb0db506bc1eb76d79f0111bbc392f66ba0a732bf1e441ec9700d529d7f252820ea46359dceb12fe683a7224357cac62de5b4b433f909f46066ecc3907553d1bacb8220c789b5ec82f7425a270dca93f9a6523e0b9294f1be374290b33ee4babece903e53cef1b98abede1da39d3d3f88e682ee2f463d4c139adab90392d487d441c5dcf9b178aad091c7c4edfb8ff514fe35981ffba3d72786c093f1b4003de73d744fc11b59af8c09452c2aa9078427cb9593360ace3147a898c8cc3185f3e2d3058c1fef26bfb83bcfad7438d64a80caf0d9a9fc20283197f25797953e1345b3bea68c3cff6af7a86fd093582ee090b94bb9e50617efb99cfb6f2b396966270115c565a7f03fe6b8956d4ba2e789468056c4a2e619862e1cc3afa7fde724b531b03a61b6fdfda4de041a3ddec114e22e3cb874516a69b9c2468fb056eab484ed747361b37cdfa09720fc8f6676939952446f5feb101a84b3dab9d80bc1363634e83cb3d50e3018e9d3cd50096a78fc4440e34633dd5315794e2181b34bee730437675097f73cb62d2081436b731f231be89a5c92a85a23088e16c46c53a1502b716f519cf0ca09909be76a6f3b50baa8b0bdf51d9dc4eb75a7fbdeadf9a15dfa5f2324efb46fc7508907c9e878696398f3eede777f9c74c2a14146a39424dd8deb688884780261ee2050bb0cbf313759633135afea510c6172e6f0936988c004c1cab98f852674ee5d1b1c355efea0cb36d4cbbce2431c2735b9f66e0467df5074d372f03ca0bd826639439b3587695fe35df32bd7eb96e69c40e6a91dd1cfec5544664a5a0395bb5364db823d9b30eb23e313ad8eff034673ed2f804dd5110f703a981378d9d42af37728a2d8e3ec152a1442e6d7b27076db6497041c8fd7fa4d58e3e7fc1726354ef096887362c902c851a0a5996bb763b4b0febe191c6faeae65283be0de6fd1655d9cd206a744e549d48c19197fbf86183d0be8565dcb61a1a96aff67833fa0162a90e2e0a50b7d99141cef6f5c55d6e3fe6f596e8e6d0d13be24f438895469b0eeea5d6321910636dc488409d3342499fd6b48b998cc079cfe22acabddddb2cb7e46489ba1fd8940dc7f91ef7f5893d55197530df20b95369fadff3558cb002e7f707930120e06cf125b0e9ad47400dc0d1acd874b7eabca190d087f4f5477b250e7504e112a017188bcffdd75640ae5bc6306de3b450de5eedd2a37a7771c6e193c0bdf7787d8ccdddf56ab43844c81876af3ae448c375e6f995d06467b916d88a6339b0c1596e1c1897debb5f18932095611932c46016426fc317c7538943687a43491fa618c4275273623322b251318d7e932219f99e56602f71de69b45b707ec00877715b7d169079a6444d35325e625fb783854a61c68791032a0bb206fc4014628b681c711ffb98bafb20590c88bea3749c308c75e70beba493ce7315e82ec6d140940f6c722b750b901c27ee8f7e92ea2d64f07a29baee9e25645d2fcd91a9ef8d45f06bb1ab18a433a53c3438da762283284a372d357c8d9c8455a4c5c70a7abcd9685a0f327586640f7f438aa1f8d75bbe043a0ef7914d2404ddaa62aa92c38fff65b498b5161831c272157d6621e7ac139a5561f60a03e5dc88cf78424c154882d72bb826f74662e9cb518105ebc274ccda4835b944e4a5047d05e6c01e7c50e052f9d41b1b332eeaa952fac97a3610daccf83591de64dfd7a94d29f172eac84b7b4a5581c639d1b3f986dc99f057a72daad557529d8550a45b24e06f7f5fd47c1ed0d7d2dbd11721bcaf015123e4d12a46bbcb8f3c571688f7f977fc97149681cfa17ea614369c6736e9748d3981c5c6336013bba2c96a57fd4383b38aa65f9e6a7c27c3c2e2f9236fa42d506c496ad8be2dda9ecd42af33f72b2cb19881b123d9fdb47b117ad087ad5dbb8061208f0014ee3e1b5a8706232a79057d4bc727400050fa8a779b39731d586b65958115572969a8f4bab327635b7d1d7ea01033c9472a33eed583012547c3bbd7c01ef48e1a0392ee4d43a321634be843b0b7efb21c80f9feba80c439c3aa42864a2e306d2803fa09e1867445410d623a49095c860fdcb4b9f35653545ea3587c73ee0ed84535ee888d93bcce439f68f93b1dfbb2e2198034499fb1cda6a2618699ce31faf85012061639332323c02fe135ad82de476dbb17c30db63aa211c6699adb84a5722e866c34bc5027e3593f40d3179c25739035774ebda9fb263c414a30b3c8e2d3d14289d418dec3c245887df4c1ea78773668b8d5f16a04259396ee82381b89fa401bf3ddff258409f625b4dcbb934e95169fdbc27630cb76f6bf5bea20bbb0d20b910ea0d8f04365e5a06e7e86a52e2764b7678c00a0b77b0211fec3c1dd2766a2d7039bef2e05d0288ecaed6904ed0e119542b39889bb00084637c9d6425c0d3817c9663dd01115b7a51c5701f84424dbbc30e1cb6591a0f1285a23cd37db4d2503ac1be37b2777886b786e9ff5aaf2c3c8ff996a01ccab62bf4b216ca34b65fa57eedaca6a154ad9e25e3c79bcb3baf828bdce0b593f2103d3b603e73684202676f4367baf35183e21d4b609711572b7b756a9922bbd0a6bf34acf8f7a55330fb883bcd00432310f84dfefd8dba1e4da085bc863110acd98659c1e99ad2b8da710b8d03cd8e53d52f2304388c78e749cdf0b6e0b0d8b79abbc8746d0a75ca16ecf9618ba6b8635debb690f40476a3e650208c584fe814aa8e7b39f3b5de67535791d665aa43e259232378c2117816194cc04903eda88df6a4c3b3e7fb114159e04f865374d9e2a8dc3dd8d9e9ca26d9f6797612c9033a827f7cd30249d0df256fa116e55329285d19bad10ea029ad59e3dbeb80588bcfe81d5fbf15278cabc573d2cb7eedc9cdd60d6d50a57fd3c035b692f37a6d8bc1062abe3bec4934bc2b28521e111e4c3c48f1cfaab5d7b378ade7e3e5cc4120108a66fbf76ed3eb47deca9523ed0b62e243a30a420aefbd7e0037459b5cd788deec194c57bdd4eb069a7f167d7fa6ccc7ac456544d2dbaaef1ef4f9b1daea49a6917ce5bd0ac18d8f2fa8954c09a12013b88d2c59a6ba09e35e7ced45ad0341d78f4509590b3f57a381ae1f49de2f196500c0abb1805e9f163846fa48ff643d8cb43cf0d9ec3e77a6225b52d72ec22018664b0740714b10e66b25f6028a00c77abdab9e470ad9b17340df959e8a37b5aa07e050d766f6bf7d389fced18172c33e076f7cce0227205c787e7f9d34e9154f815533c0150ce924437397e13e90aaec99af6fb82831698b56ea2791599bf866f3c5dd92742e2a29fb9f35e23843f091508b05a46686cc5e88689fd6950d43fd526f17ae6ed35bc05ed74c56c269b34337b7dff942600c257e0ed608e884c8d1b2814791de84292282e4b5f5064f4ebc3992c90c7ff6a117a73f645913f37e04ecde9d9e033a8f5395fd240c4bbcf3e5fbf312527fdca05a1c71977bfb0d8e941702166f9841a58a9fd9537360c225217ee37ac0463df6a6ad6ad52e814b54f52c4a6b8948b7654652fb700eb4feddd38a0b2bd224bbb8f0e6fa8ce369e1d9539a50bf3a465dd71bd70c98bf5f99e504cfe660fcfdc7800f1e6c471e6b95368e0dd857b409db3c8d830daf3af8660bce2d893f4ec67fac026eea882faacc7aa2146056d63f0ac2d9961c337e11776b22fd2bd8ad7a235dead6222aa67b4137dd7d96ecaf7c4bef1f76cf0d83e8d0c223720f07aba275d9b57ae106c70a3bdafbafd6a254af84b8ef192d5dc066924be4f3fa994ae8e1a047091cb4a7c184bd973dec758367044f8ba39f5b69f1d1522dd39045a36e6410ce839047354dd190d43a0b005ab5def05e20381ea09087bec35d5c898b83f094ac586eb3cdbef19f9d36f25eee62285933f0d1d326eb62f9be943f5f966269cc0e4cf2d7b25a86f204aa83a54e9c625674ab8ec5114909c082e4f7a386cc56a9f4e778c14ccd74c70e1f5d3f29f493bd13a219697f006ff56e997576b7833441be30a6af826bd8a899a66b470cfacdaf4fdc5d00049bb8ca2c941732852cc786ce3641ef33c508894682868205a914f3041a74e938998625d4e7596ffd1d016d32498cc44afc2a61aae1d95231dcf324af9adac901a73fb7a0dee1a0743a9d2c6fe44d862ce55c74043f148e2bf7d1dcd8bd4c40215c3ab1c0c88fc0b74ca00109e587fc8ca938e8b1bb307ac05714b84c069ef3ecccad0e525ce21399a0dbb1b4a7e97f02110541cd871dbe62b97be17f6a512671df70f40863155ad6fd89b912298b7784f8822abeb62ba863dc6e933597db6f3b5c6cae21c40e5d6e3a8bc8cc83394551eeec15a0f0124c92783efbebdbaf877b3282f1d5256c4c9987c17f71c8aec4a7e2ed650ecf6a8f030a54ee4c022c6dcde3fccfab8138c4f4352234645e61ac2c9673d660178d6d909ba04980f50737995cab87daab126e9f67d775618ab7074f5b0788f2b3f6e1e6f688c752e23d6743bf54bcae7871ec187300285d84a92d1a20359bf8c31c327ccf6602589bf064426bdb1d8b4352ff039e3d96346118c0820b041f33ed1b4c15f79097710a6a78fe969dbe5c6af2c3a1b4c97e7fc6336e7858083038399995096e2ce038fa00e8fb3202e8d3fcd434b324518cba8c3453df8e4f82d4a623bfd5d2dd3ab480fe3b455bfe890175bbbf4b69cf0212bd674c6e8ca2504c89b5666e7cb264a0fbff0cb55c577a8e79e1e8aa5a92247e5e713197711797bc97b1792018bcfa6c5e904f68095464179347ccf7cae50676a47937ad4bfdebd222ad525e2bb5b02f0ca2179baaf477d7a0ac505574a1f1a3f858c43833d30e9afba16c8ecbf589dbfaca43450771b7d44ce077a254b08e0dd91933478b2eec2611b275cbf8b7b9da898b0a1dbb2d4d15ad326bf878ebdc693d2362a27c82175fc9da90e28e5908fc6df7e46091afc462595825225fa55b8212bde4ae7c32169ac4d2d439a64b390f16118b84ac8ccc85d2ccb9721672f97e0df9aafed7aa450ae6469a44e073b50fbaa1b5953e84c1c51f7e3f51272da735d11ab3d54ff2708b6d2fcdd10c1af4d05b8686a8d62e18e620e4a8e60fb5cec701da858b414f1168e1d763cc9e2c68025db02996c6b86d25b1523db41dd453a53ca96aca14638a798ec838e421ff471ae3e94055c23d75fa65343fa93071fefb081e992d7b78606fead0aaa858ebd816983ef19a87208904fffed4d90ff5389990ce021ece5c8708a6b5af20d5d7985906ec5648ee3c3b6a5d90ecf293845ff5ce922bd2c59cf5956bc60eba5e1b6181ac4b41af0ff9e216e135f20be382204534d55f94af74950d1042601adababa4d07b993f0e9b10f1684e545ace6f79631bd1aa29bd8f3776c87c6e170d0634a1ff7d46dd859ad29a7d40fec01d5fb35dbfd556e9bc25a849a371c612a76f36c2928b6106e3a3e3bd6b1d0b7291349b32a40d27bf8702d8eee1b3eb0419dfe47016f57b94507c8acb95b9151591880d5cca0c5c2ac3b84d1ee1515f3bcb037b170968bfd63dae7952663ab20aaaeb5244469ccb620b26293a92a1aa18e61e5edc06d3af9cfcd3d15d8fccc5d02f0bd39c22a8e3b18a853ca709d4af09f3885106be6a1aadf2593e872745a15308cc1de1356cf36908e0ac3e4ac4425813f3774a16a9b83fc36377dc24c5e6cb359c468498baa90ebabe71fa3c891acf401a805456f33c9754d86f968a83db9576cbb6c0426654eb5259490501f8a54a82fffca66cb994068d50ec8102f92459724447ad98cf86689e1ae277b055c8d0d31040ab66264f2c9d9f21442b14001b2a2a7b1be73cb47a815fbb0567443af61739ed44a9de2314c26a886fed809379f128aa6c2318440a5ee4829d1799daeaa6b10633508561c167bfe0c2c23033f41162cdc3f2d6b11c6751399489b5631c2776eaad648a7e6f92eda65eea2b114cebd02976e51c68772e2ce5db66517856663c363afede77cad05561d6ec461ee1b567f7083c8e3ff2e9d409327473f5524a048b86b6332459ad0c69d9a7fac076a421e2a70cb2e9c634043865a66efa73863364bc461121eba35bf530ff89be463f3843c6d02c9ca57121fc97cf47354e3567e0542548f5b6bdb4fa3f79fc61a4d4cc44e287a46ee87262ede923c3eb8ed3d3578abfcf01a029499482c74a4df7a581f559cbe209f49c82dd3db1debec6da8abae848c39cbb5700969e09542c873c051af85a86fcb1ba180e3204a7a532f1a5061f0dd301e6f8ee255064372727bfcde1fa628fce984aca178c4addcdbac16ed133c6632ce5abe6549726043488e0d149a0b8e5ed1cbc9217abf8a9a54443028fd5ad882750529551dab3afc5fb59b9b1ee121bb71fa6f1dbb29fc2e7768f6b98f759266610731f787802edec1ffa3b1153694b382adc1cc891e0fd445b506cdf80424d5e07ddb1adb5ecf17b9cad6e489d85f2dc8a6e94fa0a17fa489e365ebed33e87b5e3af7eb321e080b7397547e2122ad2a8592851a4fb6c07fce9697e2b697a2618c0236668108bb7dd4ff92229b28566fbfcbb9cd2a23a11c6a21a92ab96936adf6c141e21072f85da7f621fd3ba5bf3f1a0497853a410bcadff04684f0f571310b0f13d60ce7abfd9da0240b170a254a6ec8045dad4e63b97c4ac7f29adc84b1a7a3a4fc5d1391e9da3cc1e6e688582698a01321d50ba7ab33dc268c061ca71a14e03abea49cd75d0bd02bef0ff814d47899118dfa003b33365b7c67449abc0cd1b3ea8873fd218751d6483e4b5d5693da547523d168def3253f0558ab1752e5385abf80a6d9e55b24d29640639e4284a8fac525ab946c28becdcc44a768da68579aec9aa52f00c74a94fcb633cdef5460d5530098b23b5e19d4c8749688dbd2abbee9caa0267c90e307652e99a21277b174d91ffdc0565f6c9f589ab69f2d8e4ffdd44543549eb0ca93ebae48248723031c75f633964245b847d702878c5fb057f632955ed0ceb8c4520c54e123c45ab48b8236f5051d5ad11ab34c2157487fe6a89f973b53f40d0b95d00370c8f71adb21f016937c37c1aeb93addd153df7c6dd6a94ec051255e52bef364643af00cd184895f272f2f83b1571c677149b1f045382984cc705b5735ba7a187db06db0873db644b116e24380b877542a5f9d072db71e6d8612326dc19d5239fa8531b8792eedb4e6d4ae7901c4d18a4dd3279fcf4ff84fd9d6fb12088131e07b6052a650507580aa45ef4812ebd959a6dc8e03f1fae6fdc6447f7f10b4a59a3f8ea91e7dac2e90f968ae0c656a12822f9ea08c4066a3b1a6f844472f0a47a38ddab8c37d5eb75b554944e5bef79e1ee7b3bdfc4d9a58bdbb0876aa6f3c00d5ee4b930232d0b1ccbf7cd0a2e805bd9bc9ba53c46f1d77faa07d23c5ca901a9f199bb6fcd06a3a5e2c67aeb2c63e83afcfd3bbce8ca3dd6eed7816d45d9c51976ef4daa90d15d9a47b7a52df6be833f0257d56888bcd579c3a35718af0d7bc2fc797991690dc37142bf9e2d43c7712fe1317b070d73d7e688917f248dfffb2262bd4cb442d57e03cc67811e46766616da0e876c4c2384f3e29571d37a6fbdef3f96480aa1cab13d65e407df363d857141ba37f76696df76208fe1679a38afdfb77ed33a13a95fed42e3774507ea0f72b9c45853059675d2b5f02267859d7223a44c8aef5af45d3615f78e8538a02cd0345aef67b657a05f73662f788442ed01476e2d43a97e67764db60c8b7709782f16d998987bce877cb7477cfe429f67df312d209e623fe30960fcebdb365fde91dc686c81b30afbf4d4c56516b3d62570df9145d8a0bf207b984af898189a8149c51c2178f1ce58561b46422d568c97c444c75cc977bbd78a9ecc0e2ca7fa8d227c48583b83f7088d68b2c27afe786e9ff88b5a40a69c060652bf6fbf287f95a437560bc65c645eecfa8eacfa7aae08037376287277f03ffdfd818fbf34d4bccc2ea85e5b63cc4595e2ac53130b347d11cfdf0b9a663bbde4ebe75fed658f0b1053cf97b35cb6e7d75c7c20934a1296172203c5dfb684d2a701b2f651e94115b07b11d261e63ff28fff5394a356fca0be4b46f96c1ffa7daacf66e48d490f9f65ed68b7859b4c515c81be94e373f165f97234748f84c95f1122a3a8b69216fc0e5643ff85a0a8019d388414d89eca0d0c845ee8fb70419722b5260f443dc3186c63304879e29c7fc3b7ea71f0099bf1f5df2a5c55c1d546b0468522fa452e9e3240ef7711de65b7862f36d31d3fd45cac7e9ddf011ec397c80407dd2d91c39bf31554920067894aefb4475deef38790ff9d3aafa5433cf733051778f2b6babf401fe97b99c41ed41f9233f079c79666bf20058ede8780e67d53b8889d1b2229565aacdd3d07960823832126f09ce994a64552c8417f140f39fc1116ebafd90a91bd85e5811f337a2deb66bfc0bac538791eae783173a36f9e52ca23452ba411935c29d8dd2dca2c83c8d76c1465cdb3f25272e770351b6c908a1e69a2005883f2df120b8f5ebd69298d83f768c63f0f606fc14e6c5db2c8cde32a7299d6d944455e94515ba85bcbc4a013469f7a19c6dbacd7b19ab67c8f8a31b36abe813f3fc94f6c4228d40e137b883a3ce6ef3b9361634956b79321ba6cbe03c833e0d978bc1c01b5fddd36c50cf1707279249d56d73de9980ac3dd52989ddd67deffc4b709edcbdb939f42df2ebbce1bee0ee4bd415550d8162d69b04741a42e48244a05b711d96ca6e0ba6fea36e90186bb4de12a713ba829996c1ad78750c87551dabdbd492aa737bffcfa441dd483948311d8c115dc6997309751ed4dca03b2f25b6cc42f43c6eafb3930f9cdb8144f519bba71236f7cdddf8454272ce40e8869cc92e73d1069c0d421c21b2c3348a3b7504c54f4c613b067c4c63168fd9c3551161f5b5ee337c80abf6ee3bf3f8fef3c58b26e86c84a327471dd3e5110c13bbe0f37c60b21f22d21db55825a4db03e739a7f6f6b578a25912447578d503673121ea817b9cbec96b4226d282e726e2ba59d4a02bc7daeac923ec366871d3ce4abc500be2a1952b79c44f3d0b024ca0a1c77441062e26669c1e52f510f13190ef9d0f79adb38ee11bcd6ff585cfda24343aa007535c6f39798d10113f872261736cb529a3088349a7f8ffc68f9b1bdb18ce87491514782adf281e83fed7fe393f3138142504f4b78f65f7c12e9a3e922d4aac52e524a0d3da3dbd66472ee3e2c02f8b6cccf4874a3aeea8aa8854032d0cf1e18f2c1703a7f8610153513987986c43386c8aedd16c12e3813e90999e1cfc472df3b591647c5ce5703a149347936f74f84be4fd7dae54cf67577ea16e843e561648b59a315c1dbf6b39c7076c48a41ddecd0ac4511acc5943781fb1bd3a8449bb697540bdef6eedcd2744c830b3d2dde16977766b53a41d1bdad6fb81aad8df7b53d4a40f6bdafa740171d2023d6aaa48384e5342948a5972121ee5d8b10fa1beac3ea6085242885e0bb8e9f4ddbb08beabbe67ecc683bbd7920bfb3edf0d7c0067356e7303f25f353d60054ea792adc6cb623ca15f55fb74ed56abc4dc642fc6fadfaa60fa98aa671a58bf61902e4f316208f720e00bbfa9909371849dd3492f5bc8ec789499bf740a91c666944c00162f7ee060cd42ba007e810bd1c115c51e8105ac86e347711756a580fe6ddc25db5bbe70b6c4d231437a5ce063a5f2a696f0f1a3877195fbbada17b19ca43000aa8c433f2d0b5c950acf9346bde2e6aab014da0564a5b863dea0b43beb7f6997ab7de9a7f514c2893f2bd320dfc6c050df6cc55792f185fa71bd0402745c25b1e84ab6fa36cf0793247fd525af8a2fcce21b1df50828cca47531ed7fa365d77d448583b0735f5bb2073dbe643513c8e19027f44b100854ed15a3d1859aa6f8b645c90d8fed41b3ddfd0e90a8a18fb4f83577cbd58eda3bf17a7c29e4038a76b211c0f9068dafa4e9d5b233de71d2062f1c74e3bfbacecf9035b92a8f866e1896095ccc2955748b365ff197431b0e4c9ca9fa82e1fc77ba5afa2b6719b05f5be990151fc20e5a9f772c5011fa831b40380f610dd5308dff52102318b3193f9b744fd9e974e786808a823279a0f7fcf7116c7d13cd1ab0fe45f37536e7e9e93558f41b27bed937a9c9c41ef5113b1cc27e7f6063bf2b9c97653444e4c585e3468d563ebc59c211eab81986cfa6fd152dc8b262a2a79c2a8d33f1ccee3794a1f9e01e440eeb16db1f55053007e52f09e8e6f4586365f646bb51f2c72415dfcd58ffd51ddf8f53303481d9b89fc4c2c2e794f65f0a7bc077fd5f82626b6f7efe0cc70beb924231fc5a0bec56c82d8e83b52d74fe5df41209e218a519c52ddf1bb5b33edc39e0222e26a3be486d519f6bd60b539643a0efb31ac5af2f27f92147f331d753f8576acc9030d39f8e2c8696e1eb4c8d27ccc3a2c05b4fe8bcadd3ac8fd3b4cf7ca3dd1bbe085e76a2e132003853d3a92fd52316d628ccf0f76e44f931d4ac3ed8899ae56d40be2f1c64c2241dde3da73a1ac58e9d07ac7bb04e4653c691a27b0bcdf74f1b250fc76af72406784e21cf85c89113724c5e4b6d834a236f17cfac4aad912d15165a4b3db9f8e3bc82282406f20325c8b93702f3d2e7ec864d0a3bf524ad0bb59da0b6965f28c2a3b5b8979cd51946457a0bf06dde5af49f67daa514289a3df2b42fdf044194f79af5a6c4da0d198c2c75d6a3900b4f08ef07b3fe1761ea770c342a78dda9accb2f66abfa63c1d7f51dcc2d4d57ce685528a458ba8ac68bbfe6a895a500c569de176cf6e2b035fb0ae45e08ff57f9d336dd1e8bc632776e465b6b182cd6004d55f16c3aa4b1531dfc6231854a8e6f4fe37ddaf3ea3ab31232b34bc432a7f4494cae7e30f155e0af5da11d75eec14f093b3a38e21afd5c5963da1a0f03b43f5b060233f99e4917d4515ff5b46c2c50ef019c7979ec4e8831074828e679cacfc01edead1f6df3465c149eefcacdb9b6cf9472adaa090b82e297a438e8cc17a9fdf45385e711cb58ef123bdf3b75e27c1ad2dce05d80cf45a636be4db6d192dbe345e4103ca686033418bb12bac17d38e8ce27bd7e7684a4285a7f03737242bfa515cf095b4de0520247514dba1159b8e78b36047f1e4683608c8a63282bfe5c2dc64967432e8568905c3373c6596871566cd404f6306552f9d2227b4c4d2bbb0328fe7763f86b5c8f671001d4363268dae842e1d3f47e28bb7a6b76b17c3f147792a805813f6d0f1b252f14da6b253f239285e1c970b09f77967658b69e0b3a91c59abf0dde9ca34af4469e38dbfc3507b64a93111eed14fca159df8834de24d68db81e15ab27bf9477afce9e29f6c64eb013e2765bb65b80a81c9c9f258f81fa5cf680004f966c04df2b4255f770b4bca9fc3c60bd14b539e84521ded70efb0bd780f06396e26a65e693c47d288333f3854df4bd3aead8423f276801cc377e996ec5427b773467f99337fb107b08eb165752a9cd5a820135fca8b1b2f78deeaadbe3010cb9f008f3ddfb69ce2ac71640cc519dc362df3c4bb412ee9871a78edd8b13d1ec72993eaae230616317d3cb212cb9d59e3a8ee81d9babd42527c1abc1bca5739839228e0bedec1cdcac0cbf1c724fd6f532e768ec520078325f9a4d5ce6fc86450bb44e0478cb3db06bc0222e25b27c87ee7b6d87049741cc0f7fad69d07df56c87f5485f9a59a0d0aab532ad29c05ed3ec0fb363724e4a05683e91bbd9afe29659b0062d63a4287ab4b29847721f79a3ae29a295e7ca299f66a101aaec674bf0d5763c9c1a4ac56eda9493ef46955ad31dea9166d4304a47d90f5600826295e22c2c8a408a4b49fe793c2219f8b725346e390db1d27d05cec056a55631c3226d83b1c71e0cfa81ff5a318e66018173b06841eea728815dcfb41d093b6a3f9dcc57fc5e20805486c2eb179f74d88a0c585ffe315c1447bd84a1185eade94d7bcc115b9ca81064d8e350b592e4a228611a45d084e6caf07832e04e43a11cd11d8c15e0fc6f19c9adeb78bec62575929562b7d7082ee6fc4f8300b7d3f05a060ec9490e7da76405d085b441de5d168489fc741d445356dd690e4fcd3b1bacef2d17d7c25f277c5ec1139e9c731c4374384a70ff348ef91eaa0e41f91952a016b4c0fa8c47ff5a737cd161be45171f34d5755d9b04dca54741891cadde16132751b4ad16d8cae2f96e00223c1bb97f0e0adae5a212388f8ee19ca7f2cf075911a18a7fc267fe45c879aee9593306c0906b03e431e068b3264e4a7a980d3eab7627a53f510b1bab0647f7b2fadcac9a3765e58509f9a7004fdad0357698932426790af165ef12a41ca666493b3c1ae07ef330ea0664bd0081e7815768c8bbf958b89ad578b1f6e93cfed48ec60609996a352d0e1ef2fb4cb71ef86700dcca1ddcfab3d44f8d4fc0027bcec738488c5e7bcb2cb684d2035b1698aec879d7754d90253642f186fa82c42d5beb4ce3641a386d98df3749889724a02eb551a06e141f29ebd854599ae5d62c44c454caee95d93a11bff079912f2051543edf642eaf4c7deeb65629c2f141115cbf3c0f5f11382a76b427a96732427308c201ed09377452f9e576f5dadc8af0244e27f59214df04968dbd82f273b339cabc3e85b7600ec2a0f8cfebaa41a4c106c7ba79205b1758bc1d0e204c6219127903d0d2f93cd97e70d8d07af01b1ea1806f0412c75b17390255d32515fa3e387442858a0aa01b2eba396ac0b97ff5657d6e4c3cdb232bf4ec7d1184080d1fe2b941ede67a39590812cbc35b88ce5f18653cc055d4bd300157ce850dc739aece3c333d66dcc67b399e4130fae67fbc0a11b50ca48856f1469aa1982933d704ec62c59140c2a75eea6fefb78e422d23a1581cf1a66b3ed3de3d6c5a3e95e28699cf23039b5587ac690956135f887b75b8f4e75800324dea87c608a3a458635fe22294b9d84e79a4c830f79edc137481defec0465e95024e87cbdcddadaec643eca7c7fcf9ab640a7ba0915d7605dfb44d2414a274a4999273cee43db6e331ff662d146ed74c5473e2e6114a71eaffe8354cf0318d0f2a2e626b19eafd897016a4dad0a6f7468c8f12d24a923737bfb6b5c412668a10e0a9950e36a9c3d3bf15d1faff89ab0335ad3803ab1aa395d4b4df6650e042672d0a7b8ae380f3139fef8119cbb7e6a89d97c2ce622745d686a1fcac936108e5cb027869be44bd4ee31fd744851573519c13a5262cfc1cc6935e6bc9ec22d4b64e6579ff1c56805a3c8a3b9066e7c6592d1cfaa0d22a6cda7728285c0c7338f53c78e5b3370599bb8603ffd97f3f72c5d48587b62c9fb3b25f4c86e40600fc360629d4746585836013d1374d8a848a852a9b39ff36fe43c37793bf69e11c181acf312174dfd8ba526ab086b909e3696aabf2b227d57112a4bc972787733400e8125793e1540b7be92d224be63a2cc11741dfa29279f20c521f90745ae4062deaa0a189dce7549b13f086c15d9a68863a003c3ff92966c44429b8129724472a69ad73601f03942ff2828d9047fcfb7df0177dbbbb679761fa791ac580394ce01a83f6294c19958e5e7bcd883c2de191ac0cbc175e97d8bc2370140612b901f8068339fd8108d3b55a93e47f57cb30c827a98373effcea4d3a0bff65ab3381bea886d8df3690d500b61662e5a0b32de87930453e596ab409d72bc9d96cf728fc2423645354be5fa853c93d1780ec0990f05b1224e41710043911ba27acd824b3740aa4b0b4d018435ccd0286c8475cf7cb5d3472e95dc827ac0c728cfcb5928610d35e018d2964d24d826a42939707763391f8706522eeb62031840869b0c9004bf7601df445ea277eab5def358f08bf0022201cec4ecb8218489d7ab0ed580fd18dea0405500989ebe0bb96bc3a531e573a9cef8f4e6fa1d423e5197b17abec713b9418e292fe3cbd1e164d2fba1e85bf8d3e78154e722faec2a7f5bfe315776c9ca8d7d486ca3b665a156f817395dacd1c4abcd698d728af61dd64169c6019f3ebc8248b22c487fd637c5a318c6613a364bb7916c1d1372e6874fcdd1f0f7542855fcde4c6c8f6a02752c69933e5aeb504443b0dc553a67485671c312e484c225bd8ed989b6755d57d22b5818eef3f99532039bb61b95dd49fecd57cc168c3fd95daba450364386d9da67373d27368f607d8b500ca2e6886401826fa9d0a34b96199a478a5d56739cbd48ca1b140ccd018ba2e0736b24c216de80c394e54461a545d8cf03a8253da85f955206f9ab6adfef76eef570262840052969a4694a2c96bde3e51d5bb5a88e1e4175b125bc0d2b936bfa9d7443a542b839ddd0f974825c9f0a2deddcfd512e565279d0ceb4dc3db1a3a1a8c203b61aafcdc3c65ad5eeb253d783fd46abd845dc63e613e2ed1c2a80ed7170c7d08dfe35cd8684639e951f5e03614612103ecc3762442efbdd1fceafff0886ea504e303e5fbd86c17e2cd7ec49820d6e8b8656a8acb41d8ba3b016bcb543714833f2fbd529afda7508b4d6f173ba8d3de5c1732c009cffbf58013553eee6187d66901393ded804a982c763dc8af8d2ea47d8da503699538ca5d15024c281de6a3943745efc44963599a795888480955b24b48a6bd8bad20b7b1f0e7c824b6a7fba75ebb1bdbde145ef1da9cc3ab6aa5f7b846d6c940401bb33477e8545221551a80cf77852fdb944a1a8f5eaacc954985fe878cccb4f3db97ddf8f74a462e709db649949f61c64ef4f032f395823435cefc447b1f975045b368d28913174e8401e47a42a57c827174d31def540e4d01e274d1bf608bb34fa9c7885fc7d2eaf0357dd661d11c4962f9c116ea1b0458ed17edbbb267f5f55faee3e4e0f71dd8f31b868e03a0fd9bb89279dd04f5968abf4d1c5045a635b5118f992dd817120bc58e147d05797bf463156b5de4ee2d3fc94f1beb9d1698d27b7621f3d192bc3714932e80829b287704b82502fead5792b433f1946050f5283bb130e9f1d3a2d86c152bf5b052baafdb06a26a41156082c6e7be82c286404298efb6608213e24202692c9cec2ac2e2e3a1ad505e9af66de70f3090c2105578a0654c9610a31e06fbea736f8c779c9cfd3bf22045463e5617787188f3686bd524bf12b7073d79d69023e12eed2de27ca87404a05585aacb59390d9461cf6e1e9790a2f443af6e2b2d9dbc077426460221bc8fde03aa1a505b7a63d272e53d06f64412c60ed7254a76379f987b041a6829bef569d0c6861837039601584ca2368632ac115460460fd2e9ecb3fdda2fa44d6e79bc49d321da5ffaab0d2c358c4b11daf4d7f1fc3420968757df5a1bea62a22e5d6688912b1b0fb94bcec9903f16d1340c646e09e53c248807e23d0f49c433c6f663d2ecc299b08fa6c32c862a2ccc54f27f171611e111c388425572cab4ee776ee6d4f1163c7547d4cabe97434a6341fd0f475ebcb3fdd2e1b3e1dde7e0cc0caa3dec1525c24acfb7be96cfa8c87e92690b1cb65e9d9723ef7e03dae190f1ffff2521d9a20ea8a8ba9c61b99e6ca7570f476fd28ecf3d69f021653600698bd97503e9c7984cd363c6ad751ace855aaa45e66f4dfedc54cf8e8d6ec412201a9a8c891b48ae942794a81a1bb39bd47e10c0b4102272b9fbadadb309364bce88833cdad0fba7187567bdd95bf39767fddca71834550c9fa8e9c4ac0e0ec3f0264b17cc3dbc7341488976b7fe34d4907edfaf2156ac3db33e3e827864b4e3495e88ef1a8e1fc8b816821a6d35830adf2c221ff5148697fe7e077a8ae45b2bb608102ce4fe49e773fdf4cb75961277609928346db737c055f579b1c484f005512414098cebef34daa1c7b781a06fbe87090f515bdf3197c89244c97e9788bdb8d5186f936f63460c771f5e9d79587905bdd6eba7c94f37a922e4c258ac933e53ac5fd577e539bc476998ad9e2d80c535081fc85cf22a0e31a10728ad5bd8bc068d4816735aa22476fd3df3eb7b9b62c825b1e73463eb7450fbd94ac65eb771847d1b2793988be22723a917a0461c98ceef8408bb14097e5164f955d840854ee4951498056fc5e035cd46e18cc02274ff08741ab36e7f76dc68a781c267cec72614ff513c420dbff66a6812c477ce791af8793e09dd298d36a9070890447c3d3115e46baf8d067870002049c4e2492847652c942e4b2c51f45f636578be1edb494c63f8eb4212bcea9cb986b7739f06714c06d13b66b46765c37a6a71fa203d3d04d6694fdb25359c1316b626d724ff7898df49ecbb3106bf4e32099d736a4709ccb4f3e908730af9f25fd45cbddc081167b05a3fe1c34ab36b2790d73d9e3473e80472e29440fd11812bbd4d4c87b2d06a5b01ce0ff815dd24e71cfa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
