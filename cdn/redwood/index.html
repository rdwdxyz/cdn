<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d507b802619f595514e3ce0cb8185472eb587d387821dce48b12bb86e874c69a971d8c4db279204c79ccd9ea9aafb28546e9c1e13be484accb2b383e355170b1998a07a3777cb5b7a861459bf27f5b648bc4e4602ee00e026442d1916bef63e57a5d141d703281c583b590c91475c42a66394890bc39139b25ac8fee05d47bf195227129762270aae92eb84ccef357beacfd718582ebbcb01b23d92c004ec84d8a20eab33394dbfb5cde4e71f0582a14e32fb3845e37c6a4526f0863db883c1aa4976ec52aa0677f8ef9c2afe8c1a74f5bbb2732a80a5be9ce0ed3e12ba3e96026ff87b1ecb5da9fce7d9496cc286aa8009bdc38482f99fde4f792a2d48c9b2b3448027be6d75519c342584ae42c134d0f00ca3ee1359f7b40f5963e0363210919eca6830850bc9360c441bd8e3ca0ffcc1ebbc7b7bad793b16263b5bc0ce85c0e86a22782506b811fa1fdb89761d0c7496a5334b9d25f7db27b41e8c4ac206e4d70b9703a3254932b651a1d8d4be75c70fc444298fa91f831b375d9dc7facbac652b5280bf6a3c4f035f02997e20c1dc33afd102b7db45aa1564d0a8ed20031a2e83f529a704bc13be9a9e9747a36a26b3e2949d118a7292c97164c8045b840fcfc4bc418d202a13cb4e2f1c0e83cb16fe29062b5a39f6946587509fbac22793b19afd3d2460a48a5fe19e7990a698d4c266bac55c705be79fd86df450781ff649902efe27ed3fd1b39a5761e7b34f18c2afb0b2e216731fa8f60dc88babd716ad73253ae77429e46824b75a537099fe26a2833cabb92b1dbf678d767769b52e05c78756e92e8433273fc961d3bf07a5720827c20d1c6d4ac8a443c20314d914e4087e314f9d2441722126f506359d31caa6946fce7370ceb7f24df4766fc3ca9e628d8dc3f8b13e46efc0050a111d457ca6aac0fe408c4b3baa46bcfcf8d5c9df83997450537df2788bf41250697112930b9e7687528c741511ed9ed15f115952439f4a86cc40426c35bd030422ccfb37df2fc1bf2fb3c2d1f21cbad460b65b8bead3728a8367475428c5e804d0ee42e66b5664b0f82e7b1da64ee98e65313d59d221373a7e2ac217b7c5fc26c2f39de8849732b18311827c47f50b13390f0e0fd3aea3197331acd4aba2648fd8804e2d8660287f241f415b14780513a25a9c7b24ccceb090381b5747e8e847c8af8294cf27722e6524a2c73e14773744f600cfd42799ffedadde047db766d8cdf4be42db6cde5329d855dbc00746ab5d385c2112ec795ba54eac13ccdfa08e3836cbd25ad27d5ef580b6e01b6dbe0b348fb076830aa38fda97f3b579744f0ccb9144925b5addff3a9be2718be70108b1589eb4a865cd2d9c25d2e29f41511c8a389cbc25d7e7891796112ea18896000c805616dd8bfa11648b28b4d4ac100bfa04a60d2355ce7740b264f92615234f88e8dfde25e66e3c7ec93a8e52bc86280dfe718930d655c1386604ffaa4d042af4cf11390cfb6f45780fcb285db2702de73f7d63e054535329d2c659aa39d9b3abc580acfc01423855b1cc57a335f2fb47a313ee8f185d3318993708a3d2890850dcb8ada4d859cde04540c6aebe36e72d61040b22e9d7028d9df76d73caf698b01a6ba27ec1f4765d09a819d9ca4542355763409e545bce5af11c13480a6d092b12fd1bf9e3250967a38657cd69ba527782574d000c3d1e0c167a6f2b021314ab3f5fbd93523e1ca74a1de1ee6cbd358df5d284840ce2ddfe39295837865f5770ff6c66bbed6b89cda68f08448cdda3fdc9efdc45c733bb241c507036a21ff79e83148eca267a62edb6cf7594e1200f01c9fe6096dfa1bec591729956280595dc18cd6edf400fb166594751402575f2eabc6fc58755762c29dd4098be6afcf5e7b812cff9e8edd0e3f6bcf6956192d60a43d3bd5a831cd5666a4c47416c8a60b193db63e2ddbfcdef4f1cdca7b7f410f0d1662bbf76537617a52cb27944990d06a5fa0b138b665471a1e360e4af0e1357fb9025a0e840df8b331d4a2d9bf4f62b03153a901129d0b1810501fca691067e9c5f6ffbf92683b584a33b8d4f049c48ab054fa6298c6ee4e92181a3a3cf71a54951ed99dbc8940b7593a24b289a64e7ce7108281e863a7bb1ad84eca3ffe00869a3ee4685b3cba027984c292496e4b29bd5abe2210d16f5da155ce3171513b3be98a7058810ca8a610f2d1afaef81e94323b75ccd7db3be1bb55b52718c8d720286310d63bef384fb6c537fc1c475882feaa4a4afbee3cda40c2305d5ed4d9c44f62b68922737809a3a999ec61c10351043b38cf9134410c0db97003469cf1f861945225d91031e9ff4215c6cecd0d897235d7364eb95975c8bb3de4761337f9cde0b600db03761bb7c120f7bcb3bcb11af88b652c24e62e357a541216c4f6bc8b56eb3228416e74d1a1f851a3eee1aa644d6b8186c48ef8c80b9ad5e5282848d139fc54b022b582e5221023700ac47993763b71c40549b06f16e2b73d1a06da1e02e43a3944807aec0f2474b2edb721d1d497fe334393afd853ceb7835a6bbb1d44806a7293d268ac4cdf20ea1cc8a9f95bbdf612c863fd7b1470812bcd9f14d79892ccd0aea4e1a07d55728305a120d8294236d2facd464f6392497ed7781bbaf253f9ce959b7aca85e510e30dbdb3c16e94aeb4653f212bd1f818c3e4aacfe0a8069f102dde730d6882a6cd1dd888faa6e602f8ca15299f857dbbb896cc5e60b4ddac15b5f1d52fa8b11683337663f229818dfc16206e333f4ea883554f38549bce77446486dfd3fd2a603138b4a8ce4d30c41be04ad776b2816a22a712a46d04abb144229c80029ec4f86c6c8d4d0688f38e1d9d754aa4249d41a50244cbfb84b2afe3f441dc1fead94dd1767fec781fa4ca3ecc0fa8aa3c07537f7e3ee74b04609b2cd819be89ba21464f5027e1d1a74a4330b71ed6373a5619aee8e15a1b83a716e65f6ddd8d1830aa6197a1f6d56b8b94877d1276ab3975a090e83253a6ed1e0d02c02f326cffb7e042f4d6f05d26402a2f77474d8b563fdf11873c11269737cf39433797e2256c9cedecd72907afaf69c6010e8d72a171a0d23da8edbf969018c2f987351a8a8adfe0123390a17d719074e16458f66c285d76669b46e354fcabc3f95d4e42440cb475fcd2713e3d2cb15b7ed77a18cb3eb55531280a4a047394ceeeba8a4215c95105f077683b7f4a4f0c0e295e8c8d3c73610d7a0e6182d282201dcb67abc682f64482a85902ad25eb45292f31901f824eb9b74408c9720a9f273d21bd15ac72d6dcfffb36eb3e9ea8171d9708db59f56be2433c392cf6b96f0dc180a7a8b0ccf06747f06ae539213e8cbd8634f1714c52a60562587e88263d57930018e7c276638949075d4dbc550d7b1fdf0b5909c1382deeabe076a4459a828cdcc6913b227b0ddea49f824454742c59bafcd4a5daf536c7419d6cfedbc1e32c0133b5e13a122f06693fdd06fa67d21915c38350582f673248bdc1e9ee8307df62059fa0770159e95f8e2c9311f5e67cb21c37eaf1b1ca06abfb6f82bfc7e78f3c1826144e64d0c8d7c2f79f60c0bb359269209e9909cb7b5496d595309a5f2c51ec4c5cf7311f62885c47249ac6145c084c8e74ce266a6806453bab11e3c36a8d9cff9d7e868a031e6d7411e06522783743b96e957df8d21c6ee44e8b928cfeca503b4f744fb8f37269d5009eafd08e4386c3b3e93ae9ea3766937d303b579b83d999762c0e4be733379f101ea6334ec80f93bbc4c49f34fee25922d961c2419776c8f0110304a2d7bcfad8caeefc9b72ffc9ecaac6f9b3dc4daaed4830f8085f4c3a5ccab54fbd339c20b4c7083369f94243778dcf211986aeb1bdd2f62e8f05d0c8f04ab54b72454085f13193e058645beec078b33ecb5d437bba43b59e6262f20739922044b54b9b32d5e2db5c7d5946532e433333689ef6bfcebe54ddc712f7b6bd49b72c1193d397e10dbd048a24751c6bb4078e18d01cbe3dbc8fd7d7d2395d1c6cda420b67446d7444978c6ab072148d942da6341575321e579d4351d4acf5a92000f802ee79533746d70727d6ee2328baa3e7833e3646b7a7bd800f5e9b2293794f59aedc4b2f6771a5425d3be21ee7260e4ffda92c0cc8653fb8abfadeca7688621743429d527ba19862fa936a033b8d16ae1bc673bded9c9d72f1b369b7cef905c797b9d946e3e1b1c960bbf8afd9c575f80a2da0e460bb5fa75e6035b769ed4935107f120d2505433b0fc0bf994738c1e42213c096fe2bc6aac2ab8a21f41cdf720a62f88ff18afdfb88271c57508b9f88d75d1abf0cf1963e0630bb3b73e8d437909d24c893c586e9ae03cead1b1abbdd4ab035fc83dc7c3b16cc2574c38ff1441a2e0bf4202c3e8ff892a09c33ba08826c37a5b366154a5dda12c5e4211e3628cddc35899128298109ae0629e8ff5a121e694c9601d986168f811eb14b4297bc9a89593c17d0e92ca601bd309628df8c6f98171e05025de1dece9be4db38dfa64bd6286028b16243197c07c76be0a9947cf0ba46ba28ea0988834770a2ed47fc041d1a30964af537335e8588288d14c3a66ae1a9fff1d9f14cbe9ad0d5a56c82a923f728592db84aab3abf220dea9cef2535de81c51c06de0a8e9ad0433cf1c7bc9f4626774e874a89bfdb122687cd8b2238023a4e6f4bf4106a3ffd08895c3118e76149b6cf2cedf57c9635883309cc94642c7e8c5cb676d27381c3d1afdee9ab02899d96e2048d5fa2f8d2f66fe62175f2a0be0b3a2aef54d52180e088e3593eaefc77e097566850be8736a662814ffdc3d9ac6810d993bba4b9f3f2944481934f2719ace8490c402f2a8ae0477cb3c0c1b096025fa39d199950d877f1262ee90500145929fd638e0e018d3253fd34eec68879d4eeac4f73e3be8e01c7cf3d91d6564f2fae6db6655cb6c036bb6b4827be3dbb36aae42ec9d2c521cc802ed6091854ba0506f30b74d8cc9314af6ec3e1e8f4a018d3152b73674428e7174e35040bfaffefff392b9b3b1cbcd1770bbbd0e92a545e78186f37ac3a81ece6ea46946b27bf86de8f08f29eae6bb0b7585dafe9e33e43340097ba858ec6a45148b1e84d5c1b623dc7a1662d043a2f38bd0f419e73755915e1ffe4915176b4a9a61a1181d1332e43b391040072faae9eb1462513b288cc4358065bb1510a310131fc247a7178bc5b7e672207b12dfba9d94b3280b5871aeb93eff818240c97bd04236a2916e1eff263cddc60cc16812bd791812694d4fe4ff7478f0539e109be07707233818627f28d4196551ff84484030c82e518e2d0cea4e8034636cf9e9eb3c1871788d9813a1bad00c9c5eb497d03059f2cd601f9e15b16e4c835aee5c56deaae5aee10144a6e63feb33a8ed323653738f2d72e067558946f24e69eab410aef5723fa79cedb85345911966cc460ff1549b9f7afcde8c526b95798921819b827e50d3638061003e6dc0a5da5f0c720b4182a85056eda8151ed3f508ebe0517d0cfed2a958dd009f5350844a7ea7e6cd418a84a9f051f9631f36ce6c09069ac18b4df25806abba8f6659106792430fdbb7dbc91d54a8bf95fed12115c008d0f3ad622f1102e85221cf0173a87e5155038ccd9fcb85cfe0d6d44e7da862f6c1be75c9e19ef8bcf6fbec814d6ddf0786f0781af4db18a947e5766a61aa82873fa15c02f4960357cd68a4944517ef298b03fcc7a31620c2e93117946339c07e988d585c09938fc1703d241d14d56eefa8ce27fafb56e50a912af409e13d603d15c58e8aaddb3e9bafbe6e21fb070b0d9b15a2f3e3368107ca0625e67480dcd879b5330db8738718ab3158b3016b16d958b75644021f8fbda4785453f1d43ea28b9d0a57a4b621016a80aba7dad3b94161592c56cc8748827bc0f076baa9b7fc35f5b4bd68beaffc977446061cde04372581c360e1b2d22eacfb7dedad5652241b3f59cdcbd1ec1aeae29b5798daf7c75af27c27bb05130c72c74ea30175d50fec16a899cc6c0fedc05f69bee72c3e022331dbbe9cfce0fa8233b5a870703f47b994dad3068173935470763539e183edea59ee63cb80281b62dad2e832f3e80369ac5818f3579fdc6d6dcc50f9e1e37154e00db1d1fafaa6aea7ea5b1ee7f9253229045553f3602d5db3404c5338ec1f9e351aa9d44d1d1ee7d4521c409d3c34cfc22d7a0a619882fd15cfce3470d3b9ae3ff3f40e111d46f337d0a7178f9f5a75aa4017f7170f1b9e914fe774cbdd897e21debd307d79a6f87873500e44508268262d2e09938e94c6afc8cf17287ad5eb54fb93338aed7052277d27a1be3313716248c7b324d0e0c158aa8bb39f41dab206e97d564d604afe58f1f6f6c70961112e2dfc9ca4a2e8ad258a36863826f4a3f75ca5cb4be150584708de1295f2a294417a3cdc70b8e974ed81e8b41820c54ae6db0812027666c446d5f5aa0d1455a73b2d58be718e80a43408805e626e74e4383932eb3048cfa960d2a4417f034f072882aeffaa94529ed0b62a67adf68bd3867d36aac4979561118a292c0cb1a5ee888a5c890dc97381e7625db4a2dd48ffbfe21c511af398b253b0b71ca4b7165d434bf94f5c5bee272a1ea8a0c2b0665b518fb3ab411afa4d05f495a5c43c7d2ba6bcfd38212e10ac4305e615be43bdcfa2efa9be0eaf1b4d9783cd5e9127d3e13a3f83f3116367480d138b3a4e4fd48412254cf475d4ef96c04741e6cd35d700121ec054926e0977b65351e8ca3c6f7f4fb2e520344f84a1d425b7e64f91a14a93bc8ce43e0ccb0d670952af909faa7426f7d7eb373adc921cb4242214c0d77c187cb79e6049803067b9e99e2597172daf38ca6a37cc14b2b01c9a67942556c676e9c63cb6cd066b08ff400933edc72e3eeade8d26798dd597105b9fd87b79a8e30c329fa618587067f3e548fdfc449dd3c1e24b964069e0e807731a2b76ccf51a4e531039d54fb74c676222ee5ca1e1af8b1a2e1620c6a6304de50acb2fe46df34a310d21fdc090fe62df3d4ba2759813d89ac0cec0c533825a12939d0dcea3d6c04b1021bb9d892642d8597d642467de317b5bd66dcf598600c4c91b5564fcc7ad378899bae368ea8ed2df992454affe7efb82a73c86488a4d78a965d14577d5f0edeb5bd2e19dd3f5b42c38b749d5def25810cff4e4567ff24bd96b5aa1bb30e03f1b58e4d80148322ea38b88f876bf955308835fc372ec1e6ad61ddf7fd5b5dc414a34903dd308cef983df79155334348cd7de5066c1015e5f93b99619eedd4ccfe0588dd092c87dbd6d801e84bf70d5ea4dc89c35e95f22cfaf377478f96668f47096c11b4194d140d9ee50da3338435624c9df82316ad6e99c0e61813b1bd6a71660f98f2c5ce5706da378183cd616b7c82ceaf8f9dca8684e8b00e6b05732514910b5732b7dd2fd9869b15313b47e215cb3c6ff4d8a0510c2454a1ed5e5b9af46c496f3f069d11ae3a95d486c141b07b07c127831081a8d47cf36ac805cb72fcff2735141b920cdf628e8bfb9c7f8e5a2b405ca96317243e362811b300801bf21e4646a38e8df17e4fbd9512d8fd191b3485016ca729352c273cc2290c401d107231429a8e5d973e595a7d87d1ed8c82ceae28dc728332ce017b04f8a64e46feaf90b805ac96f32a524abca4c1d10d9203f2d09eaa182ed4021a35f252589bdbe0d3432d4e03cbf3fbc7e854898021d77e4de071620cbebd513a1fa4fd6055890d893f984d7575a3f02552af8147008a25dc971964d28b015146126ba74d6135eeaf05e77a2d24ce5e51a89181b7e44ed6e737d55a96ccd2194f7a47dd6a17dec590511634926f68ffd1ccec8efade113a6de8ae1c47c531e4a013c5c0d74c9747798365b927cfd013b46b385d6f24c5a767a7dca8eccef94d015f3714722983b541bb3ad48f52ef1d723a21f98391cd8fbf185b512cc42c5a109326efb78ce5e4f13805dde99bdf8df214e0de41b6f1c8eeb67eea4231cc485ea684103859cea898eac5532b874962a74d43bef75d39fdc5f6c1e5c97cace8e876dbf66449d2eeed2034cbafc27f98a1bee9c3d2d7edc534eda45a4e904ab988ba006081931128eca45f72312f22dd83fa79a179f5c345590999457decd4fae685c469c94fc309d36e9a5caf3765c389fc791e401cf47fd004bd98c8eef8b908ad8802ae225b23bad61ceddeefb5df3e362842d225e665443633a2eace9805bc16ec2d47b37034063b2665da686a8ea12749f809cd73f723c8a51f9d04964e7ad2230e09fd7fdf041bc9669164e3b9b6fd3d38d7f1d21814fed2927b9e81441e62a14c1b6461fc53cd75d816611952f89ab04987e0af05cb96d32ac0531f994498172b40d0b0a904aef31419f87b1e92b439012a943a99ac9fa64bf647556770ec45214c349b8949139103ea30a335ecb7e9b0210b5511b944b44245caa5c8f2b463d9e9ec2bea9fe39cd19f1d87a3a694a4f404f59c63d2e7dbdb01fabcb784834dc4d22b67e02d59fbdc407d681f2f602fcaa0b3d9fa49520be391539ea80d64122fd503be102c9ac356ac06aebb8bde769781d8cd80810471ed7f90f6958970097f9d94c6e474cbcb623f2f0a32c2d5127f714cbc44a8e274e0b4750ae3e2c24a85948c111e9bfff818ad0850082171b80c5b8d2e2321884e379b29cf7e6e46b85bdded7fddb50ed468da3d23157ed64ece4ef7ecd9407f9fac27b0c82dee6772a5df7ae879da8255503f38f29faf4a4d5a84d29b85113e91a9ffc614e550588f953ae248ac5d43d71e67284df351fa7a308616067c966a9bc47e5949c1ab44d76b24276f4a084f9f4c888952628da2ef8083fe21ef03fe8bdfe09512a932869a834cbc85123fc6dc232a55a45090104a06ac797afe5187568ae0f4cd9abcee46adb31bb8ef231d36141cd770ec1cb879b7e3d4b5a4bce352aa6d206858ac2a2aae64351ea71e79572c157ff9f9bfa890189a4f649983c84ef71f7139a17e82689de7d414701fdf8872e741bd6f90383363b55c9135eb37b5fe5e5ac2911533274bb0458d5bb1cd49ee32d5fb5e317e64a35f9a8e8ec12f9091032f90d36253bdd11616374e87ce50df54c43d4f6574562cd20d7f0cd849287410ca2d9ba26ae1f51e6e0af1cdea23ea6468f7b9bbe43a4e734b25ec4078e94a956ed1a94cfb130761a79bf363bdf1b712c71e4e0f68a67cf212c8296ec74467345d9bbc4562c7662a168b859e6dab5689711d5ef18cdc89a72b83a795d717b946e18d7f1d6905f0954c6af3d4c4713a1c20d4d061cad00b2e80bff4189ec0d849a067954148cba182d3b1bdd45110f1cd5b2bc4b95dcc5c8282fb904f3738849d2b6382246195247d785e2e8bc173ec0e61cc2a3a7a1952554cccb9966d5f8277a021e6f3c6486b9c5d869865371ac1f34e5628678a392574fd3630caaee0e87c3f278078db0732e65267c704d3bc5e5600c1d70be71a919630f1bed57e81c9dbde3a0e0949a81bfcc27d2e87bd82c8b04d3825da05ef378d5011ef24351139267b02cf85374a27e520e2174af9cd010d28c2d0e1c2e2af4e2d684d48fc6779ea20045c90aa2be86ef5d2a8574e8a19dbde5b0f5c4870780abbef63623587059a87742491915267dd0e50dcaf461b19c3826c9aea74183912d1b3299c6f7613c529898bc3ae36c7a90a9c40ff377756e1505ea338e5baf0f86a051607752f191f89b38349f9342d5114536380ab024d02ab2c2bfe01e61645008678884611b3f19ad8ea2466263db1bb920ce1deebe62eb5875f6588061638e2e38603b5c0918a301deecaa4f465d1559ff743ad93af455f6caf8fe1e742e47f6d286c49aa495974406dce331f8e27bf19db0fa565afbf37bedf145e3df55b0c28c3f5a3101faf610b8a52bf1e8c025f99869b871aca6968e1a5c10f158acd09e4020ff330ed0ecb6ae266a4f9bd9b6da60e03e09004ae64f5e8f2cab20fe4bb69dbd29797313adeae0d89434faa3c2329ed5363af8fdca7d1ed79d4aa4753b454c610b67e73e9d59cdaba2717a3385a150611cf77e02ff055a8cc0dcfdf1959d020ae3a4889c20209b6b0952917e639224855a2cb8f38492c6a6b8a1e4901ed37658366150c89866ab56306b6e808d8b4f2470010840cc8a14d29fab28477821ff24cec1b39643c6636fe44afd25e8b115509ccbd5676821f63ad59932eec9770ad40cf7d8920a8c33777cfa4a8d44f6dbcdbdd1aa031a2869db59fabb33a13d6ab75d26ccaf06e8d818dd9004cf732b8e9c7521dcf45e8bd49399f4668a673bf074a3f1f3ede8ace9046bd699f02f0bd877e906141ca9eb298e9557b2d53bfd8ebba8dd4c889820653769f61f1bcfacf334e01e5161e8c0de626161e85db067c25e1ecc07cc2c423a83646ec700b380db5aad0ce30a27795261337d8f147a034857b08fb917b7c61d66f0af744b36120c56a8e2757680668e7196f9688e59b1f2ff2a250968f5eb66551ae5b24cb2fea649d9cac24cf7dab4b60c8f43fa3a233eb0ccda7b4181ddca24988ce6bf004fd2c08124dde93595d1b23bbfddd4382030bc0e3fb24142acb0083540f6d04bf25153c5c12dea0f97b6f2759e3c1966b72777dd9565f1ae3fb77e515cd579eb5f27616ba3509ea4c79e271125f309db6b931455f80e90304664af170521a15c178533ee75ac63d8c1af02bdd24d3dc847e580b074bb535027b9946b62fb2b2622fd7705c1f5f86b7fe157b101c38b67c9eb34aa9b1d8f864c745be9ab971a94ea7a7d25fd9975e8d01b35fd66fd56ed8efbfa6b212a6f5d1524fabcad3c3caf838d5123d67d19f3531134f6eff1f3891b8fcaa7e3a0d11e5814c4f28695e1256c14df2f629b506f073607fb15bff1e9fb803814c0e4891b1a3e3768f3fb4f17a556d477c10a6d7770da264ad3436cb49b41dd9df498eb365b15b0cca93ab88038f461d7bce40d416a4b9293061dec1d964d240ac22143c5464c230475b0f2721068577bd46230636fe43ba6e199512ace5f50b77033f8513161af0276941544384ac6705eb44222a64b53426d5a2d0570f7e2550ee3b03c5b9c7d7537cb6e1528690b0adec29b747e4cfde0dfcadbaecab0981b5f612c15481124c9aeb175828744c902f61f7bc3a391e0f69ce817f903a613fb14f655cf23a683387b8055cfad343115c642723ba46eb6317f6f3de41df7676be7d76beff1480f20854557cb136d0716dbeb798cf886da9e0570b1a65dbe7daed7a1d34e0fddadbecf18769bccc1daf4434f1fcb17d6c0f265fba728c88f343f593b9a6aecd7592f0a002540d111f29733a31e91ed324fbef090115336627b1b46e95aeff9e8b676fbd46ce616a935c5e5377d4afb292552d3d24106aee10803670aacf63426fb023002f7d7276753eb3aa6bded16e8049ca42126de5797c2629b7d84f2b738a152cd4b99946778397afc3ba76a9d3bf4c5dfb488920fab6e7b20fe14cf1a1cfcc7e1f07bc46e807f0afb7f09b93a257d0c1c9d31b78052e739ab3b561d696d4d08ebeaa61a450f0849a84d9cb0e71748ab09ff289703aff65a63039a119c7aef1dffbec1844910c662b61cbf7259737a7ed7808252a763f915eb3e864eed2fdf7ea44856d14b5a3e88d7293ce519d47d5cdbe0690d97982ad957339da26908ced891b8c3c31ea52073387bc2bd6a49747a5402e8d0e5dd93b9e06d8029cbdedc1b3eaed27a121c2783f64bd544f1b2b51c6aeca80787fd79c7c024cfd4a709039219a14a79bba4f9ddb91b68cec16caaa5ce57ec46ae36674c3f573007ccc42b58010130231e39b804def1e5f2ac79f7beeb429f9d3174f0d0ed3596ac9c49ea5e1efc1c7fef66617e898411ee72b7d26f54c1a2b9e4e78357c9a1e5220c66ab8d2a53929715174a302419cdc2be703ae165ccfcfb65c6264e7cfed32c0264719bea65e24c9bcccbc9f31b3c373d915b7b94da38c62a80c5fbf8ee7eb8dc65902afcba6966f2bd8292ea6d75d53e4d7876c484e9ccee5f63e2b2a48e37b7fdc7676e18da6a0ba9c576a6e5ebe66d8c4c31037982617534f1449cb2afae81222431a960c3b217809daf6456f076ef2747ca0a4d6d2a213845e3d7f1c7f5673ec07ff44ed999eb11ce5757d825f3fae5761a11832bdbb4f43937a1288bf13eebfa5c9aa5c701543920c98a400f3753ea5f08938a84c9780093b42bf17934fc174c26d7c11ea5a169358fa476a0e1ca1dc770e8023f2de718642d28e2c817ce07bdcff22fb2d93bb0456277aee741d5f1a08701a32897a76bcfa343a5bc908299a8f6ec7aa9d2a0255e81584355c8b76e2a16b7c7c89f2ee8f10525a0875f55f79d8ac43724fabfc867aed0c925d65b2b4947e6dc513eb685b2dd9020945247ed700037407a3ef1f0927d7e4c2d455d8077ef9799022369c23ad7ed27ea5f301bf36aa2be4e38cb7b39647e9b1dd96c35551e7d756bbbe3452b1a5835d40f8511a550ac7e3675941f86cab29d7bb6cac34fdbf55fe6278980cb94edb84168b827ad94e313d8cc3b921aa36a21fd0bd8021775c889acf374997df371a31885b6425442668774944f94e64cb750844533b9fd6ed992bad633d795daaf238746082fb1d1050102b094ce15eb27ca11d6561a06e1c5ee6ce1211180e2e79de0fd6eea3f94eab003b853f9fcfce327d14e02387269d9824ea7e889e571315892f191e3a6e94585d08931fce6b9a3f99d16bf5959f88660e17ea98d19fc88e64cc7433f9186e938ee778fe4dfce1611348f154cbafe0a17d6be3566acddccb5eeaa916f48c9efdf1078982e9128c4b98dda25e2035f8693db811f24c4e27ff299b79a2c3677365230b6dbc3c53a7c9faa6dc930d0745aed8f78bf489bdab7819213c384806e7c1eb8a57142b49e5f12c263a6cbe8d4cd425ee8036fdefefd6df4db8c1bc3ab577d1983de1b95fc66584f601e5dfcdeae8d3cad5a8c1aa015b6fdc4eb64daf757493127f305fc164b87da81a1dc73bbb0f40c7c0f33ffd01fc5fc7c9d12b7ee2d4fe23920e5b03c6c039bc7dadf71b919bf49837e6f5b4921c734ec31291ca078f761a7e880410981bfefd247aa9372ccd9ac480ca548a7b790dd5d89298d292ea40203c9e05dc1d32784f160e7111f7d819821ce0fab306d4d67aa08566b3e9fdd11233571228ca2ef5c254b2989397c137fd063475223b08cc0cbb8b0b1baee6dc6e85da34c67bad4c95801cfc1b00c38fe648eca17cece09fc61eb51b0f827fca7c47dda9fa73f7adbca031e180532f7562a574fb2ff1a61d01be2150db796489ea0ae74991be95609e0b38bd721f541bc4ec1efb8d383b9c9001a707e31a26a54e46ccec739b9b9df7acc1bb4a3f551467bdc171e363f6103d0d89345485c84bd5bebf734836fdf81d4ca29a4ca141f7f54925040f1e2001d02766d4c013a9418fe8a7f9d44fe181d4050e242096e5a23c9c73c7d69866042ca3e5eabeccb5a63509baec91b9cf700aa97e6f93dfba51a948124bede8e21cbb2c811db4fa33dd733a73e00ed84a29373fd805ebab24950bc660ffabf10e6ecf7abc01c57121fb4c273f1195d661cc5af0d16f31b610c9ad68d252c7870f7a37e7ff6d2985d654b490f75dddfb9fb4ba1a2e10be8a72e5a0ddcc943a0442f7e3e37e4627b5ba7cc6a3d152f6238e3f0efc431a24029d1e377afdad9730698b0124fe7e8ba3e3fc512b7c708068121cf655cf1bcef84c243f492ecbbcace684e8905e91b648c48f7657a4843fe5ea4607c7011091f08d477bec20d5e80c22612488b52d162bda1dd6bdb902f596cc031eb44e9939b6192fec2c1f8301ffdd7a104c915b02ec5437ea6055cc499b9091c78e097eb8f40f93613fb2c22e24ad3a4a290b4576ebcf40513ba8a31207a1c1eae07ec9c6327896b188756b7db164bb3ec9402639672089721391d191ef7c5b76917703647fbb5f5831bc7a6332a0859669f9b88214e4f53e6a8e92083a6699095366f81819c694dbd744617ca4f1d6e4084de2a2eca187bd4a56b548f7b2ad81a02ae30b9c8cd806f7acda9ee1c7d3c50a7b295a6876caf853abb2b9eba39a1d01cf37e3d69fe08d062e4873f6d089a8b60390aad8b9dbaa3192610d7acab0a2c98a167dcd8ef8e33fa6454e23193f9f1432e125b0e0527c7b031dbad95a70ec031a81e9957385628cc30edfc2d119bdb13ee1fa679255c17b82573f11089b5b475dd407ea29b64d7734d01e80b2adc6dfb43a7ee8b65c6a9a292f4115cc37421d5b4667497ef269abe5ba6089a94607338fef93cdabcc21f2f1a50b7c9275b120e99bb4519abd249f7a309f8cd7431122481a560494827a01a09c72200f90622cde2b2cc0cbc2093ef5ec836068e14d4902a79de9d3cdec6f86bb2b984e2b1d4cd5c775130c8c7e842fe232ab20b47b6fa1bfc021b2496102b603e7790a147efe7e32566c0dbf5d868a25f3a90c15018b1afe61ce0b30f32b16070f06dab8b1a9cfbcfb90c94cb25047b1f0bd368385ed649c36e314fc84774fd7942d28ec59e9fa5f21c69406ccaf9cfd642beed5cf7b826bd04345c2941cf89dd6a9b3cea248794a22e3740248bc699050e40fd595f264327401ee864a573d9ab5281596833e01ec6c3acbae6594c07c54ad31050aaafbaa104ba4277850043d88dc62896bd8c629815823a4678360c556f2f952263a62267ac50d03363ef4f649639c411fed0747903f12d281d84c76face295fdf4c33f8b7866febc0e68f2176016f8a76c66e7d8e55c35908c4bddad47588a6bcf58cdb0a39e1c18d96554e94c7b19100ca2ff53711b2d91c28495f9eb4394e87b044592aafba15fe583059539faff27e2242bff4130baaa1aca72205187b65cf0a4333a3f70c77e02f58596372729505af1af64bbfaefd0a4fb897a797c0e298639096ed3763ed10547f624efa2da2447b2bbef55b0cb222345c7c8ec10837d8eea07d130a04a09a7066c604c80d3259ea4f3855b22d80783cac5dc383297ccad205a2a70f3b9566d5da3d666eaf37defcf5f59fee189b5f4f065e56d69c5ea3a53e1a9984980f29708b341eb963cc17fb1c4f39c6be2dc36460334c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
