<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b15127be5927fa07d7b815234c3ff88de9fcbe84dfa4bbcd7641d21b8eeb1b8fa7fd4b65c3e6a3478c1c802245bc2885916cba74562faa6826f1da092a013cb245691aabd8dbe0ebf54a76d20f408268333696af133e58ea1f2933f2d105c8fb926eb20d84156c951b3f99348613a9e948ef56a1fa3829e6a59dfe69d66bc1529c2af8662e51e3526dd2908e657d937455d960764feb05737cf29e53c09e7c1d63d55189239d2f34138a59333f9d5fd41905445115731a3441fb6157b2dac383d6a2baa5d132bf39eb5220779689a4ca6284d850f04c0632d1f756eadab7addff4f3c72fb09793715ff138d8754c1f4e8551838af9575fb234e066d0f9da0c9699d64e546b456427835e4950f276509ec674e33d61333486c82dc596291f207e3bc392d3bdab7009d307d226b9218f8f1a6b25e213880de27aef5cf683f56aa9f13eabaf1f15837cd110950cf6f3ae2df78900b399c0c2c22632d30259e5dc1c11d78c35a01e4a62a19b0d76d23274e34dab6c6a240592aee5092bbc2c5f69f779bf30f5a52e547c37e92ab6268f24754dca9ccd040b0af0ae8363749e1b8486dfd178454fd6618187eef09aa8f763cca50bf4e827bd56454d37f5b35ad075fb17252afd655d190f602702fbc322d40cf2582f77dc0dc7ec65b4f688b1a2b6e44469ee26bd4516174d671fe099b6e400bdb8615ab089a7b0b02d52afbd99441403859a8afb97f901391e6db80420660f67874e9810fb7db309b73f7fcca84684ab44adf21779573771da3a666efe73ec80b2b4a504147df08810bd82a018d04722111e8dd71cfb5f936e4ec068d91663862efa523dd9e518a97c6b83ca3e98d9a997e9d3b1e05edf4c7f283ee067b63854f8a4fa8efb4f3c0ebe60d8aff90b6204facc1bae46d9dfa11850728d910570806cbdcc2d867f7c5ff92d632e82869798fac20c28b158b85129fdc5c12b07f3d38f8d6da04340b2576185be884e5dc6436eb105d3e5168af2ff6e83c8df39d3da76ee2f7cade1e23f64bdb2390623137856ecc0220d703e7825783d90d77cd9930cc72e03d4e93092f1bb0968a6bc1d421700b181dd9b3f49d6b87123cabb2c643ea2e603c897e1d7f02101e236ff406e723772505b613d0821191a29d6799570afea71b2326b1238dc323c0baf1a32d722c1ded2e2faba5a3e25f9a51beaa48f9148217986316dd379358245a62def4e986da3d7014168065d4e2b09395a1b1d70d259be12dbc9754971a1736507b7afe8c7d015ec28aa05719b74afd4568cff5b0115421b1edca8c2fe7d1e1facb8013cb95af4f604eb6863280b4c9e411887299bcbb3c2aae46136eb6b4fe5fdf1c4006a308f270603e0152c2f7c4d760d3c6aa4da3f8e2c9354b8f805d3d1bc3450f0f1e08d5bfb5c8fd698ce2641ce90893125b3b4a9dcb083e820632e4f853b5fc98c78c68339f26d89d2bc99e4498eccb14faa8e48d0a7625777d2cf0b3032d1a36b3b0e9f2cd08c8b7d0f53ad9962bb3ff18cdfce548bc06b4006e07ebc05adf0ea94c33b161df1650f25ed89cc53c64d490b99362f4f0bfbc8f53070fc749d7f8408b92bc8b2d08516c28ff83c1379cef403417e8e0e58ba37241592369c3d717b843654f477dbbc8b9ea2f134a7f3cadd2722ce699970700849eb3aea915915f8708f2b38b5dbf76d8e5b09a2f050e30663d2256038b04e8165c18f46d64800c184f423b742cd5f684412223aebac65d0c286d1c1285720212ea5559e32129e942a9051e974193cc9c0e7bc3ac46841be9f7f7a697836207b0d9817b7373eb21d6f16ed8c33d7c9fab8f6fd5dae9d7ebb4642bb4f41169988e014c7b0ca065b87d26f45613afb93c36d7e238e965811a07c0addb213e025319e9947656ad12492afd2702e78006c9a2275722793625a218026c2606d3e7350b0f4ddd8caffe38f6f20a15a513ed0a8af0479facd3a93a2f3d478c4358ac1c7abf87ca971e1acd6bc46e3fb7295cb07db5f5d80dafd60336a40adb19be4e90cd949743ecb4ed500cea49b6fc2042b4d3bbbae79ed4088f02ea8448a6ca37701775f04eb53949ea99b9939098ebda10ce3d257f871595070a0d14f765f8ff15f4a149bea98ba5e33fbab5c2031bb393a0da8659a26e71934fe5ff5ba674e5bccfa8d300e833690d3cc6cdb5d3804cd74cf9c23b859573242cbfefadd5ab710710ad01920ca7e95df9bf90d294b1280f27a80b8bfc2404e5e222ae2baf8fb22729196e8a24ef874a3ad8edf86745de6db0f07ccf0ad6421305c56c69dad41cfc80777a107e2674fe66fd0c4751bd5c14e38f13d5f4a65ca434a4eab8a9077f0cb52bc44c0ba2d4d6486dd5b215bb81965f1f9a33600b9aacc5475402e125c6d027e9adf3183c4178116ebf4fc2c63cff6e27081180cf2ff27401b56a35281c1d17c87c47bcc78e46664fcd4b2ea2760fda4f8b472d6beb971d9efa104db6c9307ea133199e3513efed55c6bb69a513fba747e44fc45a7c41d357aa383ad9ee8d5a3ddc47600c1c5a52cbd8ff6de98e922416a4842e66f49df0d67f9aa9b21cbeb01e26bb2534bc578d6d0deef5689771580d488d252ac19629e583e8f0f1c3958f80de940fac2ea834d956e9ac7fa30ac7e2bcadd3dda32ebf34e7d1cd704b5172a8042bde41e5cd670fa8ccc13c0c76ffb7a29d1a09302bf115a0e0f64720098fcb1bd93a3dfb7d4fc1dd6af78462a994e83fbae06706797a8f0e30bde1b3b375e9c77391a1fc2234b1c3692f342ebf356042b28081fd1aaac16bbad3ba756a887dbd8e0ccd0ffb5d99fc67325927dcf3c330215052fe8a5f63fdf84ce398afa50b55716ab19c30047adef8ef86e5e9c4e259bcfd3b66c976e50921b53fe74f07bb5ce80640754f1f3563b628825dfc6caa3270826b977c65e0290323a4b35fb51993d9bc87fd35d7107a49ea42508948f38542d8a5796141786f8fbbab7db91ea9def082bbea896348df5d7801e8d342b9f6f2c42f2196ed12f4cff518ec48ae4c03ed6cc243d6ffc7e7f19d5d95b028593cfd14faef484a9add5383cb104697919255bab6db5985ea1ebb93eadbb1b810e09eec9c610ef60b07c3af6cdd6029bd7e7bafb16eae20a3bc02ec16a706697258696b2f9a41fdfc2011b1cab05d97affb09974fd2b6309063ddd2ab878464d0fcbc7c27ae57ac4a2a09da5c3b1f8c4d55953b7928e854b611ffaee21618b77afd28654429540134c57d7a60765fa52056dc20f7aabc00ea021517de431f1099de98fbe284d66fec1691626dfc7c6bf942679edb607fa8691a40f3baf5621d599490214456018901ca1e60d417be9fecdbb70ccb87569197820c1728d787dc11fed1f3e66c3c0f6753b06aaf7213c373cfbde6215d1e88a186f001b71221ed72b7c2b67ce270daca0f2713ab26df7b802d34d67f87e4602f153e5ed4452ea2875cc09e3012cbd7c160a059846c6426f8800ee7fe7e6ca5ffb342f7f7097342be8a61a45bbfe9da3d203f57cf6c714e2bf9010d083a116b7000d2dc3d474c8451c69491714ba8c9c19fe699e0b98da29af4f15593f75068007ec31128668a77755ff6dac06ca13934bf788a5072534832b02f2b6f48eedca9588d384ffac649d68e886d0592eaa5926889607fda24dec7837bcacb6c686a94d361860d89a5cd9dd54be065540d3cee3bf8e30e2748fc304577e5494ca555de9c2b482c06676e57fcc6b5d2ac70ba50650a8a11fdbdd08ee7a9459e07ae5e25c7ed969361c77d3b9162fda54114f9419eb8199071bc9e2fffc3bdf0325156b2cbac1d58ae25d112331c2314dce06b23f5011579b37983fac279e55e8023eda3720a15a99d4ab943a372341c7eb57ee0f0d7fce8e4d758b35eb7837efa042260d5441fa1a69f005ede6dab4c036f3b889bb3a0dc509ef70fc04787565873c044e602d53f954b0d33fdeeb317b80bc01c114092c07878e73970f723248eed97abf4a1d5b39f27040fc33a470929886bcb58a1872e43be287ad972f9ec1caecf15f88a4b675b3b0f3af72cabdc6789ecf00bf6be8c6394bcda56ab314a662022a134d7c793dc9ed00a90ffd45e4fd96b17cac23e8d7519bae93dc0b90c0d7bd5efc5c0197b3d2fcdaa3c6b19ba9ec37a6865080f4fa560820829d230ecc58c1c7bb4008b7c822ed61810145572a4999b2cd5f5ddbee72fd9050d026b30c4c67579ded09b55d1d0bde7288a7acbc99239da8b38fab5e18d34062d620754c642309c3faf1e1a8f820017eb1db60bcdaed433f08be9fe19417d9b0dce76017e78febfb7f8ce31fed899b682acfe8653ecf1a51ca4906a49537d64cf07cc188922ef468878e8e8deebfdc12f13fd068ea46cc094fdc36c96fa17271a1fc3bafaa57807f8c027ff096beb4c7d90010bab1915b9cbeb2fa6a44441482409ccedbec58d275f00691b9621d1f3ec78a23c7b5eaf4b438c727e541df6643fda0742a7ae273727bd6473a117cf6989275c1e4928dcc65bd2df500ac9281dc59cc953218e12a741dbcb12a0870f5ffedec06fc75ecde9df8ea9f329fd3e29f444ce16bf9856e9bf2f9ff59ebd63152e274c087628a245c8608faf23ecfa9bb088d7fca0017dcf5980e10ce6c99b7a5d6b816ebf8731a5f079eb390c0009c84bbabb1c123705ea896cd23003ab5dcbadcbf714d695cdd2b86aa93bb2242c964523d4bf5fc40a705bbfd623168bac1ca15332851ec4f4e227d5a16100460ec443180bd31e6e2d1681022966c645684bf22d3c3becb46a6dad837a7f8be5665e84e50663caa3793b74e776a4de361457e152fb0e0d92b3bd4f041b94c4c3e6641cbbdda42e0a99aed176bc478f6b9fbc36b83d9c04ba2f9bf21313fbbfde023734e643fef2169b1786a0b09cc948c49816b0cd7fc4ab9f062784f99488feb8ed0e425b41d9aa9431315fc7776f03e54672090182749120ee38d09a2a963d7b216d0a366661f8a49c72010684aecce6d87d59538f692344d625bdb697104a6c4ee6ac226edddabbe642abb8764542f0e40be4a6de928e16121ae3a8bcb37a474d5ac7bf99f76cc8cd10dc33d0b8c3ba88db4d6a5902584fd9584fa67d32398dfb8509f58246b1a1bcc8c0dc044680fe21cd8bc1527ef169938a64126de165f545d94b3f288aefcd934a2b4817c06293417d1eefc28e6423947ea48ea9f2b79e40fc09d21702aace8c0cd2883086f408092897b6c095994971a608285a2569bf87001c5d214850f9a8a231a76baa8badaf4ef5a805905427fb4a7e2864dbfabb6db6a9cd86364f741cb7ea6826ff341b87a9c7f915d648172fb45fa1de3bed0d4bfa8db7710ff34ea379d40b785228a0a276aa58d276ac8a239d2b6456b899e06b5634dee041b9126c5739f63ebc5ba7955406ee834d46616f4b3027dc670b64116d91637fd6766e2da7abd0dc2990027b977d6d22d7ccdeefe01fa14b7ac272cde11d6dd9eed78858f120c28bfddbafce29479aeffec717cd0cc7bdd6fb15ee3468183aa567ee86d0eb962867a4eb83dd04e9277b9107bf520895df8dc562cb7585a275196f7a976802356886f4271f6e08675b285a62a5c12788da6a16765897761ae5452bb492646299b212af1fbdcbb9fd0bb2d7eea229a7b17c121cdca639c27d0868d1c818c181b1160148600b487fcac6178b5327a514581589052c1a44fe3724d8f9505abb3075ac4f93919a883d583a040f9a4c22fefc1714ca39d24425ee31e9c0452b8980ff97cce5e54c99df130434f3a7308d0421640f653e64ac330b875d4f4de896c9769890ced696cc9b17f0e94e8cd7d080dccc03286e43bffd62bb81cf9065ac509360bde7227308679dccf54a840249f8c430e8034bc99d5e1125431dfe7f361a784b3b06b85cf6dcdd99dbb95e8fa7ae9999da5599ea2c7239389344b0816687499333294cebe6bb7df14358e1a5beb4c7f3542ff78d3d28eb7ad4a39b8c21a4cedae6fb8b73b1a5b52075986ddd4c5df49dcbade3843014f3eb4197e9f06467fbd4b338abcd0cc0eb2ea44f73f5c5d57604e518fbe310f55622d9016be783ff66b31e0c02b7e3f7da8bc1869fa6b76b32f189be06eeb0cdc35c3b46daacb80a1f20eac46a3530ff3bdc97e8962e65fbcdfc35b5d520123f1e9f38d5d0d2300bc03bc737e9b4cf85c8b61259e85b5536ff525164fef1be8f63f3676434d8c72e42a17c384b644dc62c3d24ba72dc5e71403831097d4e4b2f0e35931436a38762a82eda0261a71118f6220d6e9ca37b558ae4c8f0221019745b298cf8881d51cb9895de30bd46d12592ffed3d054892b8f4158b3a365ddda8e39cd32cb9b68db99e5fc5b5f3600abde9cd6e4b2358d01f1345cde79195f89c4c5366186bdaa79b414680166b0689742f965ccc0b1f428f676d47e27df7f21c2b15658d6ba2a827c5d6c7ffc6eb4f03f652a72958aa5c13a32700a61a63914fb4ac93d73799c4726617fb123cd61d5e12d35b76b3b1ca1befdf60c973279ad436890e598ed818e128487ef2d4d987eb7a5e8abd8f16ab44ea97f5411bb2d524a1c44b755a3d615dbfab5bb556b66a8b8522ee4d42bd3f32dc10b904b98be7f9b064da81a256d0e0313f51313ba47b64f3d0510bd2d69c33c62e0ddb20ac11f37e55a36352c7bc5177f459de726555f0c7c587067134ef044b876c47f1ed4402c811b6a43726934df5c71defbd88afa4865f18502d9702d7b08f92982b170bd80c4fc867bb5c6c091a185192d2ba7e8ba6dad371bb6dca5dbe69bcd519fa23bb8fb187756c3307e30380cc0c71d19c71b41c978f4a699c79b20498a930e6b8cf3bcc8d394061bf48e40ae08b258f2ff025b5cf9a91c206fc4231601e8c6b69dca96b079e6337dfd9d0ba0f1245ec6964c2113943290b13826714b2653a97f18d685cbb380a749f7eec98ca46fc01ce7f23404b66bdf529fc1fd882d62fc357125dfce055545f1c858dd81962275cb500cc7cc29b1d305ed92c9a6ae26071555cf6383ea2cecdb864d4a57296cb4bc9575ced09edac45bfbee5e42defacf0567aad45fe8c40be9fbd587107f7ab510134ee86d7a7ec45fdaf8f86178963a096b0762e53651118c03af530ae3a9d7133c90cb003c2eee3033f8b657d0cea225413a721fb2ed6f148720e2a4b09f42e2179607ccf8d9198f6bf1c171e9ad495714ac201a730ed61ca16c8dff95910e2932552d04406611684a201e9260cafff3ada1c4d22f13f672d8f0aca8f7dc12f09a288896e896c8d17f64980fd2e4e5cb0fd67a9f7646f06c1d8ea6a046ccf1209f64fd8a8a25146889f5022cda718e5bca7762c92017aa61ff4e1a7d19e6c6e4d310601d9225d5b6717c08be2cf4d94b7da2c712fd2e71836b99fe13492984eff9512e78cc5134b9f8514a90a37b2ed19f88a202aa8267283daa448798a29de392a8666992d20844fbc3251d4fbcb82005cb5c4de0ebe3f2bfd85100e88f7520cbc0f2f656f48d4b3e774cadec5c02316c61fd10f36918d720120b1a911c19daea6ab25df4e8665eac3055960628c8689977f1fcafa3387ee49bd43b7e9afd2196ce4b2a577b1787f5f22088163fcb84d0bf7e6cbe20ac8de8725f1184d66aac8643beb30a969b041a0fdc6ad9556f0d1ae4007948a87fb830437769b6d93f21d0d08c084d1fb45f3284066ad84abe67c8bca993e2009400c31b05e144efdef9f1fd990805ee6eae95a417ab483edf43793ecf62968c82b4ee63d4cc3ba528472d50c92a73b9234061141cd6e03c79811425f840dcabef88f800f384e6a8941bca50bd3458f3bbcfc0e71f0e548d9c59bb7a9a36d0aa9b6207c412f1bde50e6224a4100b6a7b1dac9a947c3723bd4493d2d9ac421faefe5f66f72d3734cd44f86cf0809855d0177ed6a8d5c8da3ce0ab82ede4207c1505d9b330ad2a37892694675f6a21cf8414438c0a52dcbddbba483bc014ee988150dfb10fc40118c2ff58871170580b7f5b754d81beaa439a098095aac41105e477b90bff0864115e688c4ecf6612b66a3cc3ea335a26adab2a91257a1792df43d4c0e2767303e496deb58f7b20910feb2bc843cb9b8e8a2914fe24a0e4d08cc298d4da4e0d018fd9f6d25603b60aa39eab2a50ce2c0b086d1d97bd7f512f6a324cd5346d88252c64aea972de6d70cf00504dbc0ac5ee2373f1e392c53064d4b450ca554c4c7f743e2be80fba788f7e072b2034b3693b303c863b336f0f68d8a4f14b0c0066a589622439b3ae57d2106c7ebc73c024b07bdc8825b832cad9f7bd229473e13e150fa7815d022e97863269684e9febe436f12cf35b180ddf3be0ad148fcd488b58eac83479a20ef5cefdd805e3ff4d306aba85c8f20fa613eb89481128cec2d228c6ba029d4ee2a89e02654f20fa19ec94c88bf5e557d4fe9cecb0b2dda58b3f30f38b6a96b411a3dc4291134af9764e7c5959d42ee642004df12dbfa0afba416919145efb145c19cb34917ee75afeba41d5789666105295c3312f7221d8d2ee00a30dcb06a313a8b4f0b0a3228fcc5073a11a3fe5d9011184f6ca340f33b49e6fa6249c2dbc3107d30e35848b7dd993b5d38200f0730cf0b36bf85115addb1ec3bc14cf714151156a7036058852d4486148297a82d1cb816aacc2701a7d4dc9c3603e9e17f516c8a339a69bd2971bb2078869304f9785e3f35dc61e65c96e2021fff4ea2ef9acdec820768a2ba6fb288b8312c68f80b26864e77c85022a2e99501190580a2c2e0384fb1f26ca8cf92913ee500d955e8b8c5a2748bd5a4d3afe9ab30fb21b68277cb4fe5df1c1122ef0ffabab61a98b21059c04cc79668e275cd58d0a003154939cdac375f2af6dd64f6fb65e5effd46d6059b89fc8b02d171da90f3d9d886c02f5c65e57dbca8128d317c4b7d9834d9f3a06b53030f30fd92bee1e94af998ff9e448d7550b206a24c0f4fdbcc8b44ac1c6eac991ae2a0c35893565796dcb0c78db517e06d2e9315d1878dacf8ed1fb1e06e1ab4ce1596b568d366161e208d0b96a7f61a993365da32e72b37ffc8bcebb720acd158c8560e8b16c15c3ff82ea0bb4294024273e32e0fe60983e9b1c79db0c1ea06d4edd4d25f807ddda1f9550f051a4cca86d5ec1e85681c7c2d144642b0f0cd6eaf90c4a93b2429c60062d8c0fcdd521b48b653325f57f01a8b0846281c1256203b98f7e2fc2acd2b3c2b4fb18ba5e5792fa2041df82ba42d310a6925c0416abb2c7177b7386e43933cccece00ec59f544cdad80ac87802c771cc32e4d6b8344137577073b3cfe668c662a3da9b92398ecd1bac28ba437dcac9c7a3d048cd1db550dc8890801ae5b1b4740ea804923c22118ec68c78cfc72420fd3988fcd390e19d5cf633dc459db00d77f1ec0ab808d324c361ab27af003e3a31c25e7ca68918bd990f3d8338804b6ec0eda876efb41d4226dfef3911a3189f62ab28019fe30ef8fd4920e88af4584b58a6a65568b6e530ab3a11410c247a8ba2a4af74a522b59133dae00441101588479cf5909516aec1f2aabe25eb2176f022f7d09674489f01a5fc5cdeb87cde85bf577138b4628733e88a830bfe7c5540a5ceb06754480e3e1f3b17ddad3193c4b03739dc800b06cfa30041dd72c716e0515c02a7af3203f0f5f0ab730b2d93f880e9ef746a571df777a0d4740ec1aae00c4ce2c34ac12521969366956efdb73f6762494a28bdd25addf35f29a803017ca5be61c5fc88c7583eb43b03d41c4847bfc45fb446a326e327ab4fd2b09ae0fb2194dd1ff318087169623a2e27905bf0d27afe862193aed39ef4d9e7e7e8fb1555d3ca3e8f8f1dcd4a3b872bc33edcc9587c72efc2c8557943fd9ccb0346cc2390d39bbcbdfcd844cd6469de16ab02652c29cb36e3d82aba2c1331b5ccfb818989793b79bd813db5d927474a04b21199415f84517fcf36705783fd9cf01a5c2fbe06140dbaff299db1810d6a02ba1470bd9ba4de9514e47ff399a4c6b5cc31323bb6d148ca1a8fe65b6308990c5c233d28dad1bdd02b1c145017d3fc6811b2ca986216feedb4c0687ca20c253852a2bac7dfc76c6491490ab1f5f678c7a898fc529e064e7e7a9e3f4aa1dd1a5ed7b542211d3d61568d448c124e428069d4372f7333e7e2fea22cd58e6758aa13f0cf4417906df28ced2a77a8df11b0267da9bd8d845b115b6aa75aa2913606270e6876bc8f9f65df5c704369a83fae84a072cec1c3b3a74a6a9de9760700d6e191e7c6a92b1e465f6459c85e82024ddac5c0fd098fe306b5add10969d7d5a277035526c054d2daf30ffeddbf54a3ad9e5f552e1c8e6d1d0508b95fc426364a49559e68a1f51d8a55f9ac26e49b9fe30a8264440272347cc70c22687fd454aa183319aabd2a3158b674ba22bc496f95b2ee25c9ccc6020b69694aeb97be1f5ea471147e544185e5e857a696e58b8c6b1c34246b7fd35c9dd1b178366dd6ef4b887665613dac1b6916ac950e14b12b9b25b11f3a1922c423aeea12227e55b373faba9fb8587ebc63c0150ed84119d03fe0877b255422ba605aca35e02a6094c0244b3c50981314454651c61540fb75f1ff0db4ed88ecc8cc92cb0adc2173cfa2eaf1fd0c7ef7ac62e70550e72eb114b60e0f984ce466bcc0dd63769b9bc20ca1a2c0bb2e233e778b5121b9fbdde3a6ba14a308ecf37fb5e589422dcc2702e4dd17b9ff1126f4614f543cca0c96703ad9f605ef197cb564eb321e11f9545b6a292baa126df9ae9ea4387d3216a4f9e0c8dcf83a7bf9a89b45b9f00dba6c4a78fee9b4f32ff64f472c75607ac842624d073dc828c495963a89101e216d0211c0366160d3adcc42d7d1102b17d29ecfb2384be8f112ac57de0f5631242a7481f2aaff522d3ad8c91f3dc85d1b657eda4cf96da51c216d131662ced367d0d5f19fc03ec1ed58f1c884fe48f67bb85544789e1f87f581fd4192a4a169f9b4eeebd759780e523877f77c545af9ae4aab995783bebf1052bc5bcba39b69183018b6b47eab13766b05e29f2a40d2b2019f03b12e2fd975b57e6f50e00a331d7dd1b4460e273a6dd013837fc8531b93d71c106f610fe436e56bc06d8aed39fbcb8a437a89e4283b10b1499f07013762cf59bb440dacc4daa8581dbc494cb57fc30e8716fe738deb9285bd4e1d4dd7f2a420fc4e4c68448a334531276b38a444ed2fb126a3f848c5f771101926c9b43718e9e8442264ded3b2a6a48e33e0128ec22f4283e8555eea079a9fffdb6d8e07d692e81c23afc0450ce3b58bacb5fe5517a52e071ec7b4afd8bcaee6a7791b2acbe4828f86d2939450538a9b024acb40458f0db9cf323d59fe5b7193eb5704b7576ebaaee4701b20b7c3a1fdef6ecee2052e0af6ea220a9e1e6ecedfd163b06556af50b14c0a501ea5747ddcae3cd24556f7fa838a2d283da409d9da0ffbdacfd6b1f9bd84dc2d83c21cd4e1bc42e5dad124d441358afc1aa4aa027821fd756c2cd078f214b5f07e60a4b46d0e1dc2a153b6ce878d7240190224a313b21cdffc146ec4f32374dfa425a13f095e5c29c1af47d88711d507407927b87fc0de5152c897559f780053cb4f3dafdccf36ec00a8b481944d5b5b281462339ddefaae16a93c49cbbe3606e0babfc7852e4bd480792ed218328fb36406a1e53cd1dc3982c584c08135e76342a8755861276721b00390792c153be7aba8c2f92c634d5016464c7405d9cb5bea8b400491a413ecb3d903f45c1f77bbe0c7ce9d464c8ef27f799b9f3592d26466236b82586af095ab631b31b139bcbc80573f15499ca8606d33bd19799abc885a2a85792f9b7d88a11f4384a3a599b6049dda19f3ca2a7953c4d35fd5d6d71debf64c822d40b1eb3cac2491ac8b197eb83f54648d7561dd755bceade4b60396b70798b37607f8552acf58bc8e4b64cf69a251ea760827eb85498b39df5539f872a4090a5f9dcfe27aed8ef4f5621bf6184aa2e8d39be70d2df35ef97647d002c52303d4e9c885c5bc5b2edb93862f9b4f865ddd1411b591c13cbac4ea809d1bff307dde733a48842a915aaed9fb976d3dcd767e66f058bb9f77bcd48ad5c84470c14243a5cbc009d6612757813342498fd1cecaeffd4f4d3f8cfc4260cac6b28bb286777c855a4b9212cf3440685dcbfc84f944a37a597577579f843725f1e772b86c4cb4aa96db97f3db92b512d455a6c35ae8526a71b3a7cad2075e7caae777e13106ec6e691f6a46ea1eadb0afcf4a863b4b78f31d7a4602e0da561393be9bc53db80b6f5c58e95d5bdf110678df5ebae58f36845ab9b14c88500c832914c47a3fe640def95bcbf6118140883658ef22b9f82bd671b2ae53fa51246cc78a1cf050ca86cec1b23266638ba391cc001da32335705d260908fb08bd85b7c96e228a7b53343de4a9174420ab0305248d16c661fd6109dda50b15ac2cf8c18bdca815bd864e3e1d4468845cde059c8853d79dbd540c082ec0905aa84e099632ca04b4b0561e2a300215b27662cd938f96238f5f6872694e68128c4bc754f3a8a38bf4cd85af2311d08c262ea49542f5f3d85bb40c5cb47e5786cb5b8abd3633917c860f05b371c2a0976ac794bd66e901e68c11c5a5901c746ead6375bd5cbd86fbb2812a938d2ec3e13ee31dd916a2a677c2c45530c57cc1cac294ebb132aa01fd4dee67bf6df375312afebd850ecb657f38d11966e1375cc9124bd49b1c767ecf7195278e63b30e6ff6a055ef77792c5be13b02583b82c50435e974f1123a12b3b3c6eaa7e01c25d9547ecf465b495083a4b109abdc705278d739f706cc8c1f786ad773a0b3d595cf8f3064729bad19a1525f9383d1c6dac23a33dc2b3d5a307f4ca4ce7a24d6abcb727b9baa976a1c5a227affb0d77d9e1afb71cf1009fd1aa219ef7c055716ab83adf7f1ba367ef0112d0c6d6a95441349a2fa616c22397f85296e7070f09db7f92e1503e202b8de0bf1213bf9338949afcac1f04f5286eb0916e6073fc2b36af07a6c3a6a0ed62b52e879079d4d3ad39baf333dd90c64320b545baa775a9d779be32c1953533e4e1e2041c3d48803278b362104ba8e670359965bc78aed2353494df2c89fda235f26e23ec5067ae0c3acd45916f39e17e25131052e8c04347d4fe24891f4e96e90933bd16ad1fd58f2e8c4054285a97f8a6eb8cb22cd615a7257ec1b0ee64d54001edf6e491b6390a7eae98cc8eb4fb76fff8f68f19bf5ac0c5107b07bc7860588e3973b8a0720aa568c3358684bb2be14270d763861f0374ec93dbda9dd47ded21bc912febe59d2da59811ce3633588e40b714eee0d3889aebdc227f041dcc274e22e569deab93e986cc71f92858087a3e9a84ecfd94764b4952926e1eeb3f235de275199705910412c5b494c65023d078a48497c52bfed180bab81192e73de07507c445e508c17217b37771b491567ad09ddc5b731e5e5a4e1b63d430610b9957146bd42f68577494f72dbbac0794a980b0ca3b54d6f86a0418906a3afa9619db3d08e21b5c03896dc441ca2c4830f7e58edf7e3cdc14ad4a4d55b0d8a9fb0b720eb5e6546aa753b6b6a89711c132ee1a6415da98c599af5c30ac0be5d3101f59823ba55c4da5c4c558ebadb0f0e2f25f134a458232cdaba4c452f8db04c012c1e3de139432bcb2e91a0b36465794fb7af3b8cbe90606c7fab768435a5dbdc17314ba5e29e0d2f90bc62873f6c17201935b62e644ea4d4b9cf91f43d0095cadcf3ff4fc65d1776c20b0875c5ea5d639c702a9bda0bad526f76a8041d6ec2f1b78fc9a8accf81042e51c0d91e005ebeec35a28309f96b091f4704ffe1181ed67c413970f4d96649346e7172798145ca52868eb36737165bb719b6d983da262d9e23f9fd7f72314206f7fe38849c8fee5368078b847edd49d0813807884f9a9204b871cf81a718a8e9326435df214f5b8fe76e15dda61992c7480cda761746a56a77cf812ab084bf2de393669d7118feaf8d84d6b9319be0f477107875e4f2c8f0053060de0ebde06ccf2c29811462fce3d45d33d3f3dc63e90ded8c979d422a10a6d786aecbda47b2b8696abd8bf0e15cc3c793a5991c3fb1dcae8ef60dc188e7f6e134183956ece2cfa66cb12e6d93e3755cb7e197ebb962339daa5a234e54a46cd19a54af3a8aab9b3cdb4944a243042e671bc9db80c25e6c730185f039217df0252360deb434c00ca9401113a4bfb942e3a51e62b6e1ac4551592a57b1c65b8eac1a1e51facdf403ecf25e304d3a15bc699088d2878c5bd571e64033954c4600c99bd321a2b397b699d12a92e20c71aa8ac6f2e832e8d1b426f3d299c43758204e2465adc7f4c586186f102b73fff393d75487e70d5eb3262916edd4292b60f6d5ea4f0b775344de854e73c76fd1794faa52b30f168a7f1ce4b0b46f8a18b0e20a6b7e90c70b57cc1355a7f2f884dc873dbdf9acc791ff9d804d93a069d56ab3bebaf2b5b7b8b67d1aa4480a44acbe24d6de7b9fc379bd5fb7ff7ef7174ac39d42b9acb09c843c447a9b869428b306e52d1be96f14ffb0af3ec73d8f5c0218fb71a6071471be4c2a84404c3abece0c8f47a2c1e29632f9515b9be92a833e9adb4a0d8b18cf6391b0756657b440decdfdd2146b739b0466e99bd3d24f1abd0a48007b98254ea6f71b61708ae851f550e25bcba03f401e5593b193437521ccf05d90807ff510e8e2c29947d5d4a5ea83c98342f1b83e8cc4ad675f7beefa089e0a56508f78b48355769e5214ce8c3d85c3d5dd78765bddfc0b683c1943b5deaee69a638e02c72481a6f2dd05ec5f38b595fe3fcd6f1a5ebd982333c99d1e8707ae14fbc4f96d2d7553c455ce7ed3df1dfd2d321c210f1205675c308329e187f49a4146db55c853c2ddee12377a22cc4a10efc98c634a4933003f01970e9d9fda894c26ac3e011f05f4905b7490a7f30535a7b892be35d6792d5986b51f0ebff08d177af17bf4f03cdb7971cf6a15537a4a35283c0203b4251a1435af345f2dcc803aa9896303c9f4c210902620e8f7dc5cf8dd74291f0a9297a766356cea0ded5cce69501ad7f1e6b9503ecb35eb1e338ae7dda5d719137d432c8c01c1fe331386ac83fb033431266a0c5bb320006f0a12f942314345d6e6dafe99da6f05f5a1e2b717ef1b9726363df17a01d9378aedce547ba5ef1b57a3c433ddd5ad90206d08e0ec04eefd02fa93d71a8ee90d5f54dc58fd521fcf0293c6e5bcc334312b3fb73b03c833ae479afb0e72cffd5cf6a2fdc6811b6da3ff60a3065d24fcf4b80f9df88052fe20b22285a1e2a3ebd3474373d73ae31c12247c75caa22b22d54c7fe048df11ea5993cf4ff4fe831fab294793b226ddbe48df7683dbcb231a346347733ee1b880bf0d7af5f96e094ffdc3d46e2934cfd09870f7e0dfa94f522741b1fa98e6532ecb1b27aeff880257190795135b4a60334fe37353fd6cb132f90ee7b38e9292fe3c5ef5dc5c00bbe93f9107989f46b647ec6362adbac3aef3f56d02bbea405014122d549460e0ad3d565844e363099b36ac7f19528e4e2015ac2176070d863ee42743b968c6c626c979362002b158136485c82d7f66c1a091505cd490d67c5081bbed394b9eb65a54b6f638c4cc3ea4126099cb8e277c3e48265f4f8def69c46a75af19502758f01aa8effc4d53fcbd9794a7f5ca4659368ecf710da3d24b7d182017f4bb96d1836b025b38f162f3e8eaaaa1f8d48a883870cf6c8af27eacdad76eba96dc91a305835eb9c6c7423d83e93c72d51eeaaf2217d1483ff6de00483e4c2e878f25aef5127634e07b62277a070fd321b9f33d7bb1e059bd4ba88923586dcbd84661af5175a8d1a065096a6b90fc15084aed1fb3b23f514f592751dc590d31dac684f383e5bb1723e7428fa6c0b687dbb4eeffaaa1123e12d56424d8fb6cf81b494ec6e4cc3e69c440f604a21134b30c47f9ede0bc001c3da61994c781ceb0776ec88c6d737898d015d88bdc744550eb20c4440c1f1b954343ba57cc772cb2ecd8cc969dfb776aaec7eaa9226dfcf49460a221f26335432c34de6ba6a787a45f1e92f5e9c0be3c511c2c2d80e91ec6f42075292da03cb01cbcd2bf69e073e2da41dc57f55b88d0e60e70fa154a0ae7282932a1f6566ad8f9ec3864753b71ed3db5fa30ac9e81fab149a371c26d42a976edc1549e589dda9b5ef1d4632dbb8d0d3186709dbeabb05de4e8903ec03fb3f53842253263b27a5f5958dda988baae5c31d4c710ec7a278bab58f2e31c542b6927cfbbb5f6da1cd4c3e5c03b979893321a20587488e1f5ee877c6441b86042bad12b614d862c0e0ff47d36b9a492b09f85c07d5df6e3c1999ecc4866ee1ccfecd60632c3f2e59e341cfc7d083b803d57c8d7aacce2d24b134c4e47da4428ab3688ee65740422ff43db7baf1ecd69079c3f23d98dff357abe9fe87b0e9d3f0aedca5153b5c17b092079c64519ee98826dddce4affaf1f074c7ded566c507f97c7b4418330374f1939a0fcc8a1b7c4cffc0cd295e419b82a73ed739de4c7456d761dd777a20e7d9768760179ab103e65b44b889b3ef1cb03950a01c84c74050ad6c65124885e5e54e0916271ba1637086857ef95da7b697a94334434f2d6d212d43ddb46320f56b5cfdd513b487a6f5848847186a983323e1ad015d06bf89a1a60546e57c06421f76804d542cf76587141aab7ef4081d941f65623913495c5d8ba437a14d653f2692fb6a4907e7bc55096426c74bf4f7d33382a253668fd97d6be4736634b351a9cb4d352e25358c6190e8132b0d83c2610f23b9e1b9d251581a11be2dfeb5e1060f08aa54dbb7553117a51c0527e128305176eefe58a5c6ca79b8461cba54be08831332f0d3a6838703cb700802d9c4ed85d3336a263a1144070abd884c825999f2d83e2f759bac2034d514d4ce42811183b65abca2f27bd11b72cf7b5af288e1e042b374553e102d32a03abe6c2052c1b4e90e00aa54dc65d48db6167ce849caf7cbfbe38e30d99ac75e0fb74efb59c650d0caecb41082141b36b350784ca741f3e7363b50b78af23d51c718fc1feeae7598fff6143389f6491f3c3181dcccb0a20723cb939aaa5a4a777d21b986baac70108e0e89dc727b5a00156c8145e5c2b881c6f9d15d477413a6f58a8b914a11441b89e3167a889621f5a54fe9c9822a2b7028801e3d16b2cc087b43063b1f206c5d0910fdb78bea8f8d0975b5954053d4438dfe502f96b8f4dd67ad3e5aae79edf230e9ef4fd14c038072840b5f86c828e18a99a3011ec02853a9688777133c37e23c8cfc8b5ed3686c7ca76976341e877cdcff1c38bde9cf7cf9ba18f40dde1a6fa8c1001166251b46838fef55b03b93ceb5500c8f6dd3a0965c1351dfa27e9889595f3b0fe3cfb66923a6aafa67b404d6e34c68d666edcb6c0e6b277f75ee0c1e67431808c2babd82b51eb844e2e288636bad7364b3a44cb035391e0e44d7452e58e9782990e451d587a8e47a7f1de2e1c8ba310a5cd9f75076fcccdc4b4ac5156726ecb0810fa9207a368570c0ec64e017f537d71400876d15b02eea2c801befa3fd6e9d99a05e18a0163cceca9a5e5a1cc87fdcb2da14d706273319fcb67e5b69b9902f572a29e695527e08d9a9e9abc2990180b97deac0392561a8a87f8ab57c13cb888cdc47b6b00180ba28fc5a5c8428b66b6836d5e9cdc5e02179c2430fb756c9cdc83551fc45744c075abfb79ac3ea3ae88122904bb66b7a9db0dafae1a803b645eda841b76b68c5aeffbf09232bc6b04c6d04daac2e46d29c2bc889eb7f01a72777ce2e0a701f6688e37907469e6cf4c6f96c856c6c993b03c3ad97429f2db6db2045bcb3b71cafb762c659b47b40e258536e74456a4e9249e401809867c349817f4d6087950c68386f7cc4a3be07032330a1ce1ba74e17e14aa12401eb5736ed9b2fbeb2fe1b8b9ef2ae33396d3930400f26aaedf7bc0bcf9b33a07f1a6d1270dcc2ac414314528d40a4747f1f0d2632fabbee688370236a8eca400cbabea7b0b77385","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
