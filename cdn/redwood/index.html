<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33ba75d80a14142dc6e80b295d811b5edc22a10bf0cb1d1b5f5fc6caebb926366e9cc328d8620c65b49ac963d22e1e5dbf259eddb2d43088000f469c91cae551d3ec50c477389c97a82c7450336ce4536bdf8d9fc590a39c67af96a20f5a9d85d30c123a7da738f1f021f5fdf3b6e0996f365d55736105e7d2cb6259b47a6cf984cf0d3adcfe0ac1ba8a98c12429f7a820dd975be1fef6d3b8f07d3572965b6c6096615e4b000967d454bc34db0549428e3b4525fd761adabf9db275ef822b909820185f530ab56b65483e514b47008e9c1ec2a21484c572c71db06f241e0b3cec98db63df25b5d1d0709fe6ec392937f3f47d59e3dd2a52ba4866f0c65eaff91cd57ac6912bffa8309961011901679859e95e4c4bd005566221a70db65b22cbf767c823af5e46bd34364cccbf4e69fa8481d664d2867c76a083a28960f1811576147a133d012179c6f2b0fc27eec931af7fd176c56e62025993a1c401289999cf6971699f86d9c2683aea1398bc14408da0d8a41748ba2ee8c43bf790fd6531b7a13bf57f597c2cd8b466e0a7c3343c09d42a5dce3e151071b95a1fc50025a0349ed239d3813f9bdd32b062075b4582a64234ece8c2847221c1eba0cb3f38793da121eab6bb138b90fcd0b914d664c1b91a08213026e693573a2df680cc526e35b31a4ee0bedb8d16f35e6e5296af5a7538db609f472b1c47c339509ac47e101d2d2ba6cde98b997189ed9570d54145a9a2238e6f27e3a8fa5eb7df476816e7872839aca0035ba1ba79362477e1b442f717d9ef9900f42347be96ee6e9042b96b0ffee1339bf44e9c76e423818ab60563d01c8ddcfbc3c4d3febf1420d95bc139288017c6d8fcf7a89df23024d81eecb66c8981f53b6af3014592680196ad775dd243a142f06ff293c9542a26eb013f844881548087c7711c874462d55839e00ff44e61f330fd531ce72675204d5b35611c755e1ecc09b135603f9d00c437be128dcf6373b37d61409e5f34836d3561e05b5dfa9a274957efec07c4a24418393ad4cdd83bf90ebda9b7de2b5a87ed69d5b764092fce227263771bff0b10b6cdfd029159db7133536a79392d558a72b3c8b942260c8a9a1f131a3ab313b1f174929e60097254677ff6983373fc5b1827c6bd8bf47f4ba0b759e3916b990f313ad221472d187ffa724dd781240edb0a4d62cb9675d968d196fd5122455f6a2f79445efc220b2d7364e77ba1d66a37fd05fc08c7fa55b12ca86c873c11ad925442d08c8fec5a601f394ecebc3b962f2c6bbc22a1c2bb24538df2d31c6482aa05e075013772b548db33b1fa8416322b557dcacfc93fa2285002d2cb93acb950d2ea29ca1e7ec672613d53043df785ae9e00a45ab934872cd2c41e398fe1360e1453cc8c5bcb59eb92cdb49f5ebdaf92b4142697cf88bd553bb551d70854659b41b8114c0bf915f418039ec0a216d8ca7b6b22a343126ecc269434a4d4506d93e96c858ae11f02650d5f7d9263ddd05f7ff9a4695945b1b14a60df5587e8147de7326e0719d3356b94685e3f013bee02d31ab68014c629261db9940a43163d8ed71d5e48c8813a64e99b11446b9d478489b489c5616ba7133c935cc9d8b1d7359f94aa85dded9ff6aa2f73921f0d681eabad512aac1dd02231e34f09f06b6f4d59d531fe353af62cb460a32c50e7a18a70c085081b1ce281dd6ee339916dc2501f65b5f7f2f73faa4426451e0ad098e589a6b45d377339afa85f27c34ec1cb51aa8ca1d7418457a92c9ab2fd45aeed55e49698e7b4ebd13e21707c0fd2830525d141f185214ca0a8774807e2ed32bb118879b01231d66932e6ce3ab16b21bfa5a87e28a5344caecd7120f722cad0c7c994088847ab689957b0fcfa73a78d46be37e0b768cece5cb774259596ba85bf989a4613ab3e121679eab9207e9740530719c5cdf9dbb54745068ac995b8cd52703751967c7a8369be32e56983cff3515a098c068d576cdd12c5fd6435e25a1dae0201ef518a5e6c72f46bba6b2a3e062728bf984ff4b68e099629394590aaa4ac8f1843b9afd082338897240d2b620398039d60677f0178a8dfb9251d7acc6a1f1fab7f586cc5de4a7f5994d4545eff1c18717ecce348b670ddf4de9da903955a874d54576cd2bbc130fe9e25f6b12acc74679407e896cfbbf802d0673343f24026790d13b673c7a3500e94a751d23d60d20ca2b1728d6de5c43044cd06d37783608e3fcdc1b0c0e46f3fdb5b010856692e57e99a15ff7497e020b192f7039de5ff0b17c6e1d9d8acd43e7a79289fcac157a95fcc6a079ddc2b7c8a05ad9258f9a78caec1125a4aee2aac86cd268ee4bab937a80732eb09d5b734a0c6a17ee15ff301222c1caa7f5b60536cd020c243efb1d40ec7e57f32f026a31d25a0c421e36170fddc3ef3daf9688bee2d4693a6a29d5a068cb0d261ef34e3140dd37be66da5ddc1871f1d2573322f156f34f94e44b8b763f9476169f2d3bde916427b3a8a5670889cd04581b82b60e1eff6c0c40eaecc5a94b3b41183500eaaa58e95097e8eafb438769270030b5e79284f8375e5d12728f34d8519d9b879f8650f105e688fd74fd215826594bc5ff72f207edf37181adf36f13fd2e1d061249de496be389e1b17dabc5a57738b3d6e36da70511751507e1d67a75c83d86473e7b31fda1a0b43890d7110fd781f6bb3e42da7e35428544799b672e67a089e881877a0bba153bb4e05e29095c0fcbcbed1f5f7b432d7c23ab3b6ab4b1873145c0fbe8a0173f834a5b9da2c60955c3830599508eab809cae35d42539c286d1b90aaf76286ccedd9cf7532b9fb622517d23eb90262d097129506a263af46f604ae3c38c2a0f613d2731a908ecbce7e06f36dd6cc8e4cc182c90716f544fdb57d3c64285919f937a724c6a0bd5f844e6141e3bf255de3cc65e9f9a3420ca444458add9fae114941cc24763d5b349bd6b608291e67bb3f1c8351e150a49ae4600eca813dd39fa1150a7c9268b661d1c16257622b66bc9e5dccfabb2aa02cccda5d135f1403308bb1dabe2fabd512a2d74f8a08298ada9022b80dd3d588bf46ae8ddcc69ec9cc1966a3649a8dbd9419175621d7546610145f9564a56165153d0d853cd1a8fa7014b298bf57b857448d8fd44aedc209925457a4466cfaa1217c7f6c401f8c6f096439bc8c0d507deb4bb66b22390752dddc2030839b00a366715495387257da6ffc2d8bb58fd9e4eeba8f7e0779103d9c789386443d052a3e29846973bf85866cbbc9751041b776ea84ab2353d88e3f2305366da8b94db4ca4fc5d67fd1b37cfd5acc140f5a426cdc234ac9b815dd66405c9881e0187b42b515dc2b20bb1472659409ae7684db3e42fc8b1686317f9eaed1432be93ec871fc63fc26a75892086d0746a01cb73f177b782178b72700dceda841dc31be971f751bce089fdf145828350bd83c72eddfb91155e015f3b89b59483f630a894acb451f0f035fce372cdb67adf63a713fcbbad646ab4f92c243e2b07be07e0dd4bc41a77ddd18c5aea5499e2f00c7740d37c61e4fecccac5c05c31609efa0ee937475da8deadd4c2418e3650267b3b028a302ad8e5c50cef557ec55a628c622e2d45616fd714de18fb942b7aa3a2dd75780d51919639d7a51d32b45683caabae171e7cece61ab9cf04aca8af19290149745206bb2d30dbbb64400b7741a3be54f1510e6ecdf0bafaf0914319f33fb591592b1f17da207cd0e5367b91d11a7481d72347db9439ff095a5ae306a8aba6663b8940de511bbd9d866006c09bf9a095cc9d53437aff195d880e0ba84c9173e0fcd01a059c447a8cdb0bb6feb70e523402006422074de572d31c778ddaa8ec4f9b1748c5fc26f9c041cffdbfe0db02c7dcbc4e991a7b09c7c87de3c0fe87aec58f5909d4fb48ebfb771d7a6d265f7d008944d9526d6c0f5391e830efc6bf454c86d549395d5ff7edae979af8a2c97a02f41ff9cea4cbe72c4d4f764247b1c04b174b1eb1d0ee317138e1ca05547b349155ed6eef1fd9a955c1a2d62061d8311356e8f1569ba129e0fbd619569f1ae82cd490547cd989bdd33ca61de8b04eb0725185ea253d1fd5624bbb0374946a9371bd5a7a6198735e9d49356b85f589c30fee700ccc752bea98c42c3f57f84bd4d573f279ac178cbf60a66193828a40da2f5ec28d7f7ece7410ef45bb2b9633fd622b50a53cb3ac40c49a75bfb08fe471b579c69ba380d07b0eec69ad959b7bbb3f2ccf7ab63c9b2fbb132978a7a766f893da153715b35eacba8b1fc82451ddd6151fd87489ebf75b754384db24f075a9563263988d873cf12f413e677330f0e7cc50f879ecd741adac3a0d0da9878921fc1e32a38f6330570930f1c8690de36da8ab6c35dc63b5c3d827aca551b2667a3a96d79e72fb22a87913a0c20298b8b7f6255d994fe99e02647933a879fe888bc322db261bf9b642bae742679ba8aec82df77b389e3dbd4c249414c0547828bc98021b9f1cefd530fb06084cdb0cd8466611ceb1e55f078025174cd20a0d29d35209d239c5d61ea41425554cab7490f06c387accc9c7aad4d2da369d60fe26d0b0894844a9a447e74d97afcfa14a8d08ee76e98258785544ec75c233d438a717176c5b331959f62236c2aacfe3fa98826cb1d9db048d0d2e7b1893a5ff5e582e12e83f5284154cf4029b374fbd798b69c406dd05da8fafe1a4222c8b61efcc01e5c5aa4990cf5f5c451643ccea35228ac26ba94e8914ba5454518985adfb563578a9de21c93e4f52f71138a879cc9cd80443b542f056afd2b93ea8f797ad473c8f68e05748a32ca7c9424434e1a6e02f3782e0a1d95aae0586c76c7714fcfd6117bdc011198cfe1ea41d8a2081cdfcd946154909578daaa3754cec52c2ae674aef80a969c699a9585e1c1d8e47a75ada37ce6173810556a4984f1627fbd54f0522d54a8360a8ab4d4dd2ad4ef012bccb709cc37161db732acd2ef7fa490e4d1b472036c6b4ca889af600fdb5361838642733de10357021a9a6990de3b7012c0a85fa2bedde192112bf2a0ceb4dcd930654aac309309dee5ef943580f9527a734da7b0d6f5fea7681bc37758f74ee20cd4cf497728fd4d5a62fceef00e3c22a1febcc70406db9ea19162d9522cee1225ce6922ab9aabf58c6ed7c0539fa85dc3f8d33b21889e1b04377f7e6e0115e602fcf634a54477b13ee4373e50af801a40a343ef75a401fd1a4e867f10838475b054fdc4adc4a7be491a53425dd5a8becb80c39a5ab8fd0f4cfc7c95357e4270393bac60e98d05b468d99f1c96b2583d3972897f2621cd601c95345ec441adad0dcef3d980239fdd819ed70e3ca8ea4920f05e9060740483606fcb1e7f3e4b2f6b72359ba85f83d9210c4f5fb17d17e2e551b072ffe85cca38a64cc47b0b040d5e91908ae000a19192af2859f03e833ca36c011c3c27c06cf8e00c9351e988635694f80c15c40d56972efd6d821159239d143d2cf34cc48a65fa578a8fb42713e6e203a1718390eea7fd6a99c0e231a0869e1003f9345b3182d7a1e24fbd452505e4be2bc476fce6bed73da5eceff81c91a1dc5eae69cb2b86cb8e5a40ebadff21608d5d6f640368d6cd79851b0eb5b4462b7864c1f3e8c0329da2dccf600fe55695057dfff184c7bd02a35c3daa53e3b4b36f927d3e366792a376d99a2235c9628225d6ad9d50b4ef30e26d111c957355e017e5cfb39aaba5b06418f6ede8c0dfcd66fdebefadc78766cc5128c920c7157dc26f0850be39acf2bc33dcb47f207e599d924e28fbe33c9d1251939f8a430401e86d1e8a18c966967b82cc4d16b0e1d13abcf41ef8f0975b03ebbc0b1e0040e489220394e012a8ca0823ba9fc6c243b76302ee5701a15a1d6a5a839f774af0fedde0ccc6145461f910e85018cda6dd5de11d590ca14c9467dab58cbe4b2c09d85de5c131cbba6426f194a5a4a2fb7a9dc9e8f15e3f018452634f72c37575ef079ed5a3b3edef519b96ab84f384c2f2f0867cdc718544edf00e307097dc8cf84be130b272383505c94528b60c7622ec8611df10b98d048c6d39e009c6ca07c0ca25d92ef53cf38fa0c332781a35694fb2cbf7ad9f2e1433628cdf610afb6d79df2cda69cead96a27ac951e5d9f966ba568db91b25daf8fb91bc5b7dbf381d8d66d3a0b711e035212f3542ecdd29572d36e0ed50f10767dd40d729b5c2932aa70e39f97f11b0485d6aaf151a3a97b5c87e28ae8694c7960c37ac99aa0f5359331b9ad0d8a51759ee244e15c0e2416e23783c4e1916817c073fae438354e3de036cfbb9b625249202d331dfbba41633fa928d77211d118f5d99e7685ca98f4921eb67ad2a8f24263d6eb798c34cb6801ad0bd652aaa6d1fbcb4647321b1de36fb179d64323f29982aff90889c94cdedda25f191f6c838cf62bb8b7f43f5d8fbced57fb6cf85b54fa08606e1c6b75de4f3ee4eb34818111e8d8603c136220bfa92a758647b2e49f47642d639f29b198f417bc3aa2af6cd68cce7c810ad396b77a87a55e7bccceefdfdf22287b0d17113bbf2668cb11c44a6c8c07aaec086a79c3d26ebb0e44bcd8c43a843dd3ddb90d459bb095e387f47eec797a5b3f1c91343e4ce60a37080adad1bbb85aa1c4e29f3c297b473b7809c5eca9520098c44822575a9342bade9b57ed79468c66a5ef2f667fdbf58604125be683938eca54ace6a1ec983c19754d376f38fccb96f2e5a9ced57697223e8a295020721f7ace221d8aaf31caf9876665eba2c0f741a57e3a71927b5de81593f90d982b26ad0e0d090fd0b6322708e84368e24ee247a6c68b72fc95e545f316b6e15988338e2abaec47aa415c17f6e0e60438e505e2073786c6febf2072d1a3313497ef0accc54762c2b0643a6fe71718eacadec9e25fb157ead087cccbbca1d05290c68ca20dcdce5466ffd4d0035e965d189a57a0c8d1d7760cbb2d843fa856656cb24bef455ecf79898e284731acec221f98e92486eeb9aff436dc2e69767d4a39a29ade3d6938ecbfc842d85236d52b4bcf5c056ac583429537443d6309b40c3de4a6cd61cdac67ddbf3e8f2424519c908bd85a3b47e7a03bbf55f3f8114e30a01b6789a4a9c9d124425ae9f612faa781ba998920a9066af561d3bcc1e3e5714f3d9274a2fbeeb78eb492bb7a941358c3b6693fbd56e148ddbe0979bd82a8ee3fb7657ff7ca63fde4c28e397fe2132539564285785e779b6d2f88ce530cd08f721af2f0b93f39d6e6fcdec0c2cb36d26110474761a68acfe0fa36544f226ab90f209443fd490c9c324c99e6fac3dc83cefa54c409e948f34597d3b866827ebc1c514eadef8ecf9cbe01cf8830c1a0b676165ad3e8f85aaf5635c6ce06fe9e60390e7f9a657c9593f5adae5dfc14bd9eef466728f361d3cb0b82315beeeadf45fda6c797124c363ee9c31c182c351fc3ccd063b199fe552de4a41d384f04cfffdd90381752dc4ff652393468e6e2d4e2bd7795478256b24bc65399300f1fb3489739af5dabe9474e9fd06d9cbabf428a1dd2627b7ad1f526b21b495dee9a460058cf9e021236e757b93bf8b364d46106ae0d0fde3dea0b18507b13cdc3541bdefb726d2f21883a9538bfd055cbc2864cef22fcf89e2d35d3b4298855d9d284bda3311f2dde15bc2ba2913ec615faafbbc8cdfd4b2c0d4430b3c83061b8c5c81259a41b46ec49ae16c1d68462941d2743961f479c394f06158766e2b70a424ca3261ce2b48d2375dde9f1fafca3320683d38f0b94a6bbb4eb16e89bdb0414ee65dcc721b0165c01fb0334abffaa0d3353decbdc840651aaed5cfffe61afb270802194e82fe9335c82f2abd31f54b8135f3f5cae471201a7c7e97c448ab72092e2419ee23f93cbd32ad9c57a8aabd6942c4b8f12fbdc58dd83e3de611e713241c82e493d29bb83fd3f665ab04e3583aab0e5e837931fbbcbaea47add0a1e5104fa0fa7f853738b8eea175e23a4b100ab25dcc27934d236a9131d327c58752b1efc89047f5fd7196cce5e504652313b2424dacc7aac6a1bd20cd60bff4e4fb612796be007fdc36ada3bbe8b3a6b0f7db1a717190e0d166204bd4a1557b26b0ff0fe8c87f9a221b143c6cfa6ccdefd7c41351d2a725d3148953de9c0ba36dac0cf4a4770363cb6d9bac84f005f4a194c8c9cd904f400d5d4281a0fc635ef9774bc8b778daf6bd5c986da86be6633f8d5bdcecb178b4a6c2178c86797e96f0595aac943affd7900fee73d0e28fcafe104e02b7468e1f92e8981b908532251b4f72488ee211fc26a9856b94c9f038cd7ba7ea7a918cb5dafc5688c72ab5c8344a45c1d324620eabfd1572de8a89f8155d8628041c5797b762c9920fc9375b6dfd6f7a62837b5ff2f764a6bccd4a32a5afe73648578165ecd43c9e675e83ed533f8cfeb3dece77c9ca80f6015bf7f6178b5d914d8d807544cda91f1f00889dcf6f2dca837725cc2736e89a1081540a8e23d823407b36f1d2c1c1e7bd39b9ba33c7de2988e8236430d376496307065f626453ddf1b34e6082c9ec8fdaf026a20cee976fc4908a9ddb3b425fbac86c2ec6277097afdbdd3e47d4aa2e2f17a1f04b180098389a8dd4303bfb25673bb45198c310627738caf81047e9a2967bba49db273c226b1b977bcd678980d46c84a7755e7b4ad3234c9e0502a2e58607a3dbc384ef330912ef4797505d2a73e69ad983207f5b2a8eac5d3fb0ef2d4bb3791d082bd01ed58973a7820e2328a4b181e285b8cfca80e2f5a5051303f845003b4a38ffd8de2c33fde8c10013765e2119e0043daee9bb0e3217ee907cd29b1266faab83d9dfc144740d9ebbde87977baa8437cc6b89853f88842fc17fd64d5182bf23099ff6659bab7fb038a75bb48ed3d97c8079c82b7b56d013eb4f097e51cd61d24e4069935685114ca30cf7a57c01dc5c1dcf760b45c6af0fcf741b2ad16bbd024c3adbdfd984947b9e34c70ccac48f589abd28884fe8e86099ad1ac4878d95c5ea7b06a7b6938bed8dda44447a513207ae32737a7e2f6210db92e17cd24f41cfaf097b805b970531a0e2dff48f19b1d3258417a080948984cbc83d97447ca3f87091f6539b59d610f945d1aab0324c70599cc2d5b79dae5b9e5e08000bf8a7dd8a9d796092a8b262ed86d6d22b87aae870dd7654a58f8f45d65af54677ff6706d8110bb2b065bf9a5767b035d3cb9ebccc7df5c9573e998f774f3db4d88a9696bb043ddc63250c74f2bd139021c196130dd44bdee9c0f5f79e7cb91db187614a04cc18c3987c572f2dee07045bfa3bbb216ababfb005d16f9fc5cefab5354d71bc589412a05e071d0832b44bbefa08ac7a6f386c5335b1f2e14039f3abe2951380478de3d1291bba63a87f06e6af65eb0ce20d2bd2ca04e67761b6a9b81ebaf8753cb90cd1ab8ba02636084778d5d96c449d452e38b911cc9cace37d18ec5839c2b5e55b35fd2f252b874576c23b57ad1fa6ea0a8cbe01506d8fad053248d802ef220ccc7e88d914da1a477a4859513f5a2d5403d707c93a48a8169f04224e9f9bfb074a41c94dbeaa9f4d2cb57ee5655361ed84b40bac8ebeddc0699d807f5e8c7331399b521922d48b497b414298262d0d4dabdb4604e4aeddc3ccb818eb4a3f259381181ce494a061c49a4eb25be5b1b68abc201664e2b1a1e834d7d8777b6dc9007ba5fa932a4429c796764397813b68673b115aacfcab52460050c7c67b93015b2bd10787f1f428dbbb51c4fdbb7d1e35ceb9b56c655c7b12cb40730baeaed9be9e04f9a4fdbb437fb00495dd76d89f95f06b7f43e4526e4cb571283bb59f406ab56b09a5e18bb9c67f2dbf31889d99bf3a58c9df06bd9c730dc906f1b08b6e1c765666b13b55233b409be701db50e227b07700a4f802eeb769d11cd86ccf27eb80959d47a725c6a7e9a50f784feb0869b8e9d882ec2fe05d6b26d9e9f31ea69e97eb4cf68b589d56072844f166cae56117d87f4c97f832d2c1e051d004f56994977ba897308ecfa1070d2dcb179c238772bfba94de56309fdf8b11bede9b8cc68fcd74e3be425d9aad1009153c84da68c7d70adc206a136598167054b1b3d67e05a6d1be7435bf1d7a63b667489e6557e7aa3513c4a02fa77846edb8d02728426bc7835b067fdbaf629abaa63c4d1c8f81a2dce70f07b74cb2123fd6a8a957c935a814824457b93840e833680ae67652f66d673e059291228ebf7ccbea2914891815210c76b1b3d354f8f20d8bb5504b48ae4b464528de87aafd04e9d33b48b04fb4267400bb615e605442a1059f652c8b08aae6c14254327e11cd30d798be1cbef30f738d9dcf76df94b7dce1f442b3119e9e0a29b705dbbab2a009b83ea726bbfeb0b9f2f4890caa8d7f8be886d8fb4c10f45959d358a8904956341f8cfd677215cf2f3a913585c6e4c313d63868e3b2ab8ff7c4703132b46f86f5a90fbb8086557088f0802ad521d9f3b05c274fdb4e683e1c5b714b5c5af7b5d68b719b763fdade09530244bf351f0dd4897a6b3806ea63c846d78c39e28d325e93e62fc18fa02c73da3e3f0a916cb241b39b0aa299ce23d2888507fdc2b126e57d82e88f135a80f402779ea0f5547bfe4be6f2da009e5fe14dc2343c03cfc01f6e8f5a91a33bf0cb737feaee0244ef54d24f1bac9b546c1cda16ded8db32972c5c8b89fc761ff4237f8ccbc895e554896bfae47f6cef44487e8fc38854012628e8fdaf69fe3935eb20f5acfcf22e2c2698f64358d340e55aaa46f044d01e8cccd9b09705e2c880e13a83c16d2838c0ff3298d727ae07000366b452684a9632c5cb1c2a3e96246520657125ac40c39705f6ee6ed19fc0fed0556652537dfa72600bb15244e52f5bb7750158a0ed85c1ede8c1b3197ae162c3a769655fb2eef07fa706ea81f73109c6db0e4e5b8b21213578bf724a9f263ffc15edf521633ab4ccf3166357b15da875783d2e721ae0dcd5128f94aeb2f70efb8c9d67563c3acc41b9fb13731fef66f516676ad5589056a00fc42457a6f7dae491e42d6b40d8280c37ad8bf32f09571d7556e7cbbfef6c4b2436961219aa2b1d97bb691f8c258d675721c642942db619e4957014807040c870d3a145516d60211600d24bfc4b473c6b6c9e08db4d3c43de082139611810eba0b1ac9dce46b8edef1009953ef25453237a81f79e67aaad4114fde4390ba1f352c003f4afd05ba8fc5ada9e82f9f2ae1974bdad4885a253d8eb2a87a44d16361c96ab16a63e2ebf2343588cc1192b9f1f7a371b51399ed4bd29e79ca07f2cd5e1e0c49675f1e27b11ad8dd87f63a1133c8b4ace664540443828a4f8f6158d19ba9d32f3c31fa30b667586d139bbdb5bee4882e1bc6cd1c80c3ad3951d75c3eab21340cfaa248dfb6526e0890f83fb84246f301431167ef5ff1066528dd00ecb73469858e34b02fa56ad21815530196ced1179aa8acd35f81e5826233a90a03a0c32a2461ce48defbd8b9f0b4338dae71a9fbde0da7a6b4d78b74ff57081e05315aed254edeb74b3f37250035bdded913ea1088d32ccf30dd5302113e48e2eab2016189b9e3a447fddb1060c6e55d9af86c6805b1fd039db9f68addc950dfa69fa6aad72371a2087b6721b5abb723974c0acbac007854a3b57564de9a437bc615303a907fa2da343d3f70b7fd199f71563aca846dd25d1179246a0a4a6abb47778511eb50df63d1d017ec9874a3ba778fb8677f869da2d7253b08d4fd0a83ddc05f3cb221e80e77ac9566924d1a38a9a865710b0d02ecd8c8641c4b9fd3ba2c1caad2c9b3f945d1691c77b806a8639267cc04fbd967a8d096d25e310a6d63de4173af8f476c7977197e3d12e8723cc58e26f4faaef597994d75a344fda026fd49dbc57c840f3adebb93798e4884f307487ae7d435d8c31ceb5e66221b66f474c2bc3879d152cd92f13e11dd450ea1774ccc0fac852d32168363affc90e1f539d645328358728e7dac14259416d2de3bb01d1dc5575ed2e52507d5549e439400731b30ffb5df926474cd0f7cd82b938310b189e748601ed10daf0eeedd6bde680158ab9c10ab5f24f458a68e7caa7e947e211da8061f85291007a7b8a3b0c94112fb933d35182feaa46b5764ff675c6abe09ee3f581aa491b874235a2f3e112074696a2a8be7fb91aaf33238737351d94b74a29fbadf8975f2fc1f13c0c37207cd60d518d2d7b8c3b1bf27826fb0960bc5c752975c8ed470e1980a0c7b31fee36b98d29b65c03fb8ca311d09cf30e535944ec6e6f466b459a909cc2311c371663da4c4f43cbc7c7a3ea9a9028b748eebdb3da1a7761a5b5e195f1f4ed33a75b96d0606941a2111496814f7fa182c307661f3427a7dab8c6036aeae8b2bfdaff2aeb0df5585301d10b3d3d99026d8697ed03cc59dc824e5a4925824d0b892e154ba1237f4b696d25abfd136ca1a15d8e26343c78e7fd9bf125436aa17c334bb1ce9e54b9e217425d7c1f7f588a1a221940b6668f7bc40b3978358715815ce7bbc45030039a4394e1140d587aec6761e198dccfa2b58b6293b569b6c4751de9b970579cf79ca7eb6f1ed7ef6c2176d0f7dc16acb04b877f8cf3bb5225c3a03eb35f76e715d97e9a5a31dd0c4999444b82e6d5500c28a296d6e790326052b21d53e470243d3382d11220a5e7ef8b4806f3f234a6e0d5ad1e0d9f8773b05961ffb938d0dc9c6684ab7541e89bf865a6972e2cf8e042989ce68588ae907c303d59a3f457fd5acb1576f348301cde008de7a52b25bf1eecd13247251504579b00f83e814cdddf0a78a2e4d61cdbad3c24b9c7f1a6428519bbdda18fde21bfa2389e30a1bcbb3012a8eff86c9c30cd41d72bf2794151b78e626f55b88ed07938caa6448d712d7dc1fcb256c8c0aeb5a216394d94bc8d606fe5378403c75c3cd4e8c501dc4ed60d38b921a1e1e4c28a2c66d5fd2797311ddf60fc362dc55425441099f6bbc3fe2ec0eda346f9aff366ee9b8dd281515519b5ccda035a7bd6e82b872306a506e9ebb1e1df84697b2e51f3031dac58a8c340f837cff1fb25fc43ad885f805e19e6f2285c8caa2cbfc797ea307a8012d86d78ec7027873d9dbc43d81b5dc00ff420384a5e7339bfb163ea58f6337525f2a86d50b3616ca3b7bafd332e3bf8f17a516496dc65031b82b133a3e832b10b99a6c2aff9832f1fe2431081500bdfc0ceb6961e597987fb63f532c3d1dc5ffd5c8609d015a74c5a0e4caae8abe974d60aa0df6f2002e2bdb98c1e4026ff3a77215779ec9eb60156838362a960058920e09e2d7ec8be4a4aa32e9a5571a22e4612f5f57e16a1a53b18bac7541408bb18b47c544cbbac8fb17b73b8ac0d9b1cf1da71cde8997ae14fffb9d4610e0dba1f3e689c957b37c7499004fcb94190514974c31025a2c386d0ff3944c21ada976add2f022be727473a307befdec2824acfd2d141402aa0ee51c3afafb5521160b17d08ed3ada8b2da6f7fcd91a5ca0820683016e1e28dc0c50f75f292b6c9c54d2d606f22230782c918cb8278c9b3b98a5fd6a45b7fbdb0b73054866da6fd496faf55a00a20b2f305bb24a56516ebbbeec8eb65d1dca99763b366331cf9d4b9d8ad13caff51d3c271d02a14ff5b91863878000456a8e64982325c9bc5032fabec6dbd01e29eeec52a64343073604df9b4077a51cb621220bf071378980c3e2ad50d634c861f43267f9f68ab8ab26c15f2cb2be2f140340186601736ecb7a0a6e828d346e0cbe0b9cd3a19fad0fe9866fbdace7f19e1238531e3684cc467189c5b7eefcedcb1f6809c13e164c6fab1272ccab14c4f11d7926e8f67f4afc78cf6c94f45f3ed2bb8e66e9ceabd37ea256b6885578708539ddb78480d14bfa1b1236b41a94c1c0c4696bfaeefd07a7705cad198f662e600b81111cf6ddcb0dc30d240856112ddbe7642c3dc77d92309756cb2324c16e9b2ea59c47d266261f94429d4b96882f056f88c9c6dab831f6af75b3ae13370081e5f0cd825579f418a2959779b5cbfa096acb3e8a699fb8fe11c685bc3961cfc791c85174622a73a9af07ec9728cd0e174292081baaa8883b7bcc6137df4e2ec0b4606c6395efd73de5ec22299f8329684801a19a7d3b59df92e0f520c9e1b03536516253bb45d3b5b168a1c9f01360411450f9be4074ecc30b29caace511648de3d7c22b9579d0147a1f74de73348b91380e96b99196f545c83d00bb9cf46becbf7520e47c75770112e23798409302339dd8e2ab7f94929bc6c6ae38c735be54cf9fe7eeb77798e22cc71358a6825816c2730b3d4af26c04dfee620153e20816ee1413e623bc3c5e99f96bf844110726076b06e06846429967fc90fed66eb47309e6129639df8f00c3a57ba4c976e3181e633053137dd1e2435f784cc2b59492b404b3e086c3db36862f90c2f7e716843a7b4bd5928a8cffb7f340f54de94ddf54053a10f5409fe2b603a66faf1a1c36de83e15557e66a55757e384ece9a937405a4a9d646e67beff007bbd8136a12cdb0dcff0fe22e3db464e917ae32e3b5bd66282f74390add14ba5f64845f796498ecfe76e7f85ec2545420a0743cadd2b6f7893f387576060f74a2e41d5f824a858dfeabea0159cf4c817e048bd52dd61443697549106e7a39d0eb23492f2eb78791a60ce5dff035b90019615814f0c5aea87eed8e19b1bd61eea6ac6c03ccf7c3dd45c0495a71f5c7c475593180a3470880920af7ff6c897c7a842eb31b973edb526210f815e850979e523a36ee00054f1364c895b7fad81891a967eef392c48fb6c20a6dcabf90fc82023ffc28ac9626020c201805f40b9026d80d7a592b9342eef97b5e5569b81aa1a3d679360ab694909eaa7b997b2e90465bb6c973940ff4a8570ffa09af7199457eb4f698d66a540c9d0592907b9d4c7027ff31b734c0e3c94195a5216148c2f8af18671fa6538736878e36118f5524467281e2e49ab4115c2df6f444cf4b17974bf56280071726c64d8baab190f1f3df336d88aef7618bcc83202c9a7f9bdd7396fd7ac9087f1f4571742b307d30c0f5ddbfa8a93a30b2d99c43f7ee67814a06af6a9ad750bffbff3b548b5b13ca1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
