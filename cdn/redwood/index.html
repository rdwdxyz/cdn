<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d6d1b8ff84cfad0a8eb5405c6bd3a09b5d4fe5c4a8536a973990236e27c2d642cfc70253aee36844dcf100455993189b441157e73f3137b98fdd0e0a206260488bd5f281de8bfa13bf9d3234be128d92e26b7cb2edf3d6f95a9f37df37dbb4acc5d554a434d9260aa25b253305521cac1d0e7ec2e379ff811bf8e4978a7ff1045ebf234302ac37214ad073e3ce6203fb7d6cb03b772303c10f074cfa799df7465c1619fd0400f55e70f07fcbe03c2c4534e4263be6b7e788cbc4515481871fe6a7073cf7aaa1287217c36225554ac97b5505606b5167e3a506aee557b961d36c3d3eb832fefd30d7cd279b140b44a42561a9c1ee0d1808317fd199cfa599d312e56963fa570b25b26984ccb83dc774fab3efb44c35b17d7572df6bde05ac44a85f3a89efe4391d1179ab64c1184e6d253d93bf71ae9926a95ccb78ffbf3be53a1614d45c69cca6e09eb1eee2312fda6505ed204f6e84a96e969cb5260aead094bafdacc80f429d172b54aa76a823baacc31eddf3177f9a3edd89143eb72792ccda55b09f95af771153d04c8113fba18993672fb1f931cf91a90686411ff049c7392ab974268772844331b2d0921a4001eed6bed35f19f97bfd9092fc8e34726b45b30ed91ce86fed5b33a13b824447611832b8ac6be13a2587428151e4797afa78740b242485fb0214fc3fdcc2c7e1af8a286efdb461d2b0b8a1711a91760a82d3118ced9a729b09fa106cd3fee7d0c5f71d92204bc5e01ae4ed02edf2797e42f5d7d3cb745039da62ea6442ade8a4a6f147cbd6a1bc6b39db5109cdeb4020db902dc3a83353798fc38c83c3ef2d453be7955660ae13fd6c695db4dfd4dfb9c6fb4a3fd6955feed1a64f0812706228d9f2be29c950cc2bb629ef88c3233f86fe57dbb90a81d703b39c726d6a4aa94979014385ccb55862ab66b5613e85624cd47d20e73cd6e0c954c81fd590c298ceb86e0daac0762bbca4992cd1e33103186fd6bc84f6650c2b7683a0374d8d1cd12b21a573a7e41c769082791746c5208ec3007f3cc94888b2eec1dbfe590d8978de4663364fbe74c28ce3f40df7497deb310414518c6d973a8328bd53cef472dac033e64af4ae4f2f0f8dfb19f18fa8522b085b9b42f755085e65e5ee9852bff5d456a36cff93875c03276cee004828a6fa5b55ae64dff0c519b401af50ab0954dca4b588f50a573626ad85a1aa7ca5723191fc23fd1ef7580c2a2e8b00ded8ce270cdeb21febcfa5422280068342808dad428f94f69875da9b12db87a4a1474e73bddcd8d049f5275d71a7530a04e74b6b90dd2fb8d7a94e6a19ea697e3f21d88ea7e786604e8b801051b771201bae0fff09b68e181cfcff2f761e5f25bcde2f012a8d2e0980792120cc625af5dff9a97ea1a2346802850604bbc64f2b70d08a8ff5f2a44467f9c873a28dea6e0178b4bf1d0202408706afac5fa071ec80db1acd5d90b1d84f0bc8f4cc91cd980f2b4fa91e601bfd71a229d4388b4ad60e2c9d7156be95661a9ec69f43bae60b421473ab36333430638a994bef040511634ee25502381fe3273338e193b24ca7066d06ab573aa3d2042f1ba4d31436946a1f42807bd2f8681094964fe41d87db54edb1584ef3bc767bec4f68090054a15b4455b5a6222c96fb62c3c0348b1fcb10450a46ab4c03a35ea3845ae61586bb73df680cfcb8a84ce94c72a01e2a244e5f411e7cddf4bcbd351126e99b321666483cf396dc10b58f6566d8a31971387697e6627e184483ef05812c573d969dd8950a51da8dc233270faf009e48960b1ba1ddb084d250abf85a1010c48503cfbd5afb03c30477c8b34862517bc2898b0bfe37a8ab5c490c6956ec57082e955a18aff4e7fb1b8980ac8427989561555589738ad84d7c10d73e943b34b116b0c206182e2ab7170b7afdbb73e023b41ba3ae7da6e5c300095ebabadde5e3f7d56a5f0a3b5f8725e2c1763344d41458df10e729d7e48b429f28e22c9ed7ff859b94537436ff465d734ef61810d9ea0da0d369597761e3e681da6ef910751909691a2b1133356f3ecebc23aed8128fdd15b0482f7fc5ca1f731727129b9243ff55236c4f407d65e75eb4deb3a0e1a88e8316801502bc3f4eb7c8106d752efde80fa1c541888e01d98ba119c39a7bde49fc2cb97960822899df8e0b9242b372d6e54a83a2e2abff091852bb725afbdc72c43471a8e82d68093e27a5874f2bb4bc93c0261d4029a1a725861dd7e0c4e08af4fea89777ebc40e1f92fd1af2cf86c542c57f33a9549f9cdcb3e33741f908c3f7aed2d500e1e6534cb2c5b6ec0e100e751bda93c6584e7748731c99215e74380e9478cdf7ac98c61f73a729ca44dd97162edaf2f6bf24fb0ca9422ea539b7461a15a57f4d79a61157512ebfba927d72fe7f25562f623ee58310f8b3364845bd0593484470d15019cdfc0f4a1efd6d1ac03c08994a49e93e0258a80fe9d8e1e4114a6c98a4bb60779d433db61191ffe46dcd8d218f866b0abc61cbda282f640b27b931da4747dd9ca36868c93b13a0b586dbb2c73c87cca731d52c4d777794c6ee099dc946064c1a3bfbe2ebc4775c15ba04993094fc208fcfaa353760c3c0823aaee1377a6496a72de22bbf96bc44c4e8bdb1bbecfb55143f693c30210221225fca717d1cda89d90ab37ab5e8b6c522cca0fa2da61988834f2ca4da2edcc5635662498e3978c22073ded7293a0298de6f3c2c15c67441076617a3f9aabb116d43e931eea4155f487bfea3743d3efd34756f93df1df0b463be63fa05eb4e8ea89a5a13e7a6aaf7b6dba6b0835e4b521f10e390a4c5d386370d50f30e39a50737faa1c1ff9ca1242efdc8c15ce08d156792eed19eff6f6a3520914eb57614b3a4d95c686087d3fe1a73b50659c095a01cac9f224a73547970337d38f7fd468c5d825b3f53c49af453b4486b2fedc2287c039e03eced7dcaaeaa12eab8ccd8df2751f744c1aa0ec954bc6ffa9ab2371edf8243c4ef016cefc83341dc34a81dd772c314d76fb4cded70a63e9720cab5b1eb5fe0f5af1766a96bdb4598b76c0100ec53359974e49e291a57697590bbf0bd9d549e0a169b4046be1bd03166b1ceefd7796104d69980547ed37f4d9a8d2dd683ba0cd5a3a7373067cafd09bddbd88f7ace30bdeeb26334f0b29fdb644d5997a48b3bb8d3c0501e60fb18a928e536476e469b69bb6b622978c0a9a9e7fc9e64b38da7282bb8ae6d509871d9d50caf5cf1252b0832dc4fd63d5a66b127dcfba92ff3204417e915017e1151c86d50f1060e58e8e82d209ce51ef2d407d812603f650daf3309cd67e2d02b4ade4dcb84c1ca2b37a3d5030e6438d3495fc64360ef4478b066d58051da30c8d66e69cb4679aedb4187e176cf490be8fc237a37a5fd84eff28e057b3b32663e58b6e5a86020174a011649fd615307b82ac17e17a2b8763565c707206b34491ce2ebcf469cedec72727998b47b0e1b5e9d0a4340f68112f74ca00d748cdf8c60236086c7eae067221f7da62c4497a421a3089a4a1c594469a0c7d7fdcf99c0abe0157a395539e36c03d02f422983efe5e4b32cdf1608e0902ed3b1432ba4e984de760e74b3d09ca5ffef08221f106b98cb701181b7df83f521d6448807e63b8f94e3b8f176edf7c68eaf0e59e67a364838d259eac47403b772fb7068590007484ad0c2cc48508a4f789f17e8df825c7730c7f8c2aaacd1e4f888244ec9a4500cd562a8779e0f5e1bbd6ae2d6a4a6507e83be82bacca4f506aca6f0817f9a27eddfbf494d384ccb8f1f63cfd4050ee94461afa8ca6070ec41dcd869fcc607d451b9d5c97ec63f8fb049a2f3fb30eff5d771bc660e12403c8dda565bfd353a68a8dccfb16b1d6fee294b9611129932b7b1b14307a66a4cb09ea01f69cb2451464cfce73e7481534286b7fccbc9216fefbed3da717ce8ab73261a3e18c7e164aef103901c9cfee864b6ba1471791660ca0204297d254f0bb014f20f66717cf9b810858046fd83c0202020cea7e170060fe1c37d8b17767765127821b9aab2f939780955d5354525bd1ede532374ceb942b1382779e67ef050f61533f02c8b2ac6415aa507dd11411101b7c385aad3abb2d7bd9cde5a04b8ffd0fc3a44ea955cd95216e05efe258616067cb79b3f90ee1291bd600dca82265fc016f20386beedc42fa5b9bbcb106f8a5caff56a31e8b9b3469a79362630020da231c7ed1bbb709634ced43c4afaca9b05dd104a79d96a4f4a853350f813f41dd5156ac14e75cae57b77548e8ed5fa97bfb779cc7dd0bcb0e7572124e1f3a2867bb81e2d894c01c1ca121bac5991002980d30ebb3d928f9c47d8ab1c80afb1fba1d7033139e7e2f3b646284c84eedb0748bbb2272205703b16a300dd5fe12b3850c6c30a40530b59e12941fd5acc48413b7b6090622627dd2aab3cc8c8056c5290cc66c5e6de33c671da5e4bc0ee1650dde72a9255c4ee76cc5db5953c3dcb3ef140715327efe98b12b913c5c2a549c39d78aba2312b114550079351aceef420922f6955a66cc5a3b2361bc780ba347b1c056b24e3149340c962f1174e85359e41aea4074df76068b0be03766d1f566c49301c5742a0a808e5f091f37c0024f47893b88fc0774a603974ce8bdaa1973984a156c5f6381abca9b7e44e4b27b3c908695bab9e026d589f18d8f3c1bd96ce1d752178d550f4cc71c3fe07da6814c056187d7c87e47e8f2e96a5da7bb18b02493a24fff2922dc38766082ecad5120fa08024b3fc7922daf305a9d7c4a6fe1d0ee9b3af506346cc966b0297af3fd60af1e4657aa1494da56c772e5adf82c7bc682da04825c1e3540f6c8306e0d2d4905429d41117f19a412175782fdf848973fd913fdfed809f8bfd07e4d70d9871f29049b440ae5c5e93baec5684b995a946abda4f34c1c06f73ed62a3b20ec1d78da6f78faa8e3f6132f8f061d2c5a6542ae7193ed1b4c7ab2774e46718240f5f78c9d41aad4009e0e2b0a4afe9074b0564b274884d0faa07501740ac2eae3d49cd555697e4564fff6b0df02c5f0ebc823057b3ce884269d0e26153c53aa65459493ed7487d8129a7097cd7437b47cbf53fd7c3896931590127c2850e23d9775bf97ad2980b63067dcc68fab2d9cb6064e8fc7103840eeb8530cbed09130cf76efedeacf6eb8e4948624f7284851e2080cd7fdeb704f1f043525cbe721150dca30b1751e136b2a0492edd8e2cbeade635eff908d051906932e3222e437803ddd90264ae0ccf130f25a6d5c6dd8f80dd08c11beaa7f8472c0a600b9f516030230868d3f327c88c9a81f0ed551fd9265dbd3bfdd701c3f8dafed4312df51bfeb026295768d3e3983738c235fd9c46ce8eaab86879ed026bd19ef1dfb5546c3d3046d396095bd633affd94b6feaf610f08a00c48da5fde19b7499281470678d3f7dc994bc52d4d846ab2680bb7e387eae6fa0e6eb0d94f0ad947cf07721ccca5f73bb48815a33b5851ed9e84845426488b9b8b589f4af1bcc23eacd796d1198771325ded0ffe1aead7d7a9e880a855b80d8445efb0faec3ed196189fbec1590af81ef805921bae9daeb8e0f3a4c38adbc4e292d9f442e04faa3e9059029d50b43bbfbe683e24fb8dc1b4336924ea5eb2ca5c9dce61879fa0498362a24ccd2656b3f73b3223ab3d561a807c7346b10bf44a1fcf8d414b17c4036fd44ec6f1e5f0586ed59025bb784bb625511e8338ba7f41edb9980ba031f6f35176c034a577b6a9a780a27138ec5c755ea87fce0fbd4a2f9abd9437b97d7b86d8dfc2ae8040fb9a59aa263b96a0363cf2f5fdc1fd184e10dba91821ab36945f9f7938af355d4eec38a95d8963259fd35aaf847594ad956ccf1f71c95bc3d6526141f40887bd975d1447d8d53e383dc0fc5de8c493239c4757c7d21afec2da261a1490ae4da696e486f0004906c4b2ca21b1677bd3ac5b1a492559b551322b11dafc9a70ad2ae7eabddbea82375d756662c97d4db365babb410b3319a9726d83361e84615c90faa65006876cad978bd481e1172df7edda2726b1a18eb78aa32826655ebd56d116f311413dac8003248b4d166f1fa53e6b3a217b19f8445ac31fd9c58a332d4e35096d312d141b10e795dad7cd76c2d3bccf63222253400ab84f54427f2d527cf5b197e1f9cc81cb5a6c100b68f670ecab7271837e101f944a554d98521d89a88f944c801c6e53218fa2427495a5faeb5a4b1da30cb4c5d540b3ece2ce1ed24193bcbde59668b5b523fd727aedb7bbdb6adab7bc01cab21443d26bdc4e6d7895fbb96daf0fa708d661ac04c7cd0369a343465f11988e331b0682d29e99915a4727a128540d61d0d44a6f406213d9c9509237bc7b0ee3e116fb6fb1584e8b4a66d28039e497fa659f876ed8eed57d344aa1d7252b9f40c932979dd99baa1cee702cfe492ae7e239dda917acea3478daabd0e5d57d4dd7d1a0ea85980f94d747fbf8c01b8888f9dd51026b2147dabf3a5823da3a094ed1feee47de64f2b2e00bc1a0a4793b35a5de811c0f95c5db812ff27a5e816cd5093767d89704e8d2e492875802484806fda71601ea84c517caa001418f7dfa068f2c8ae6f520fc9e795d0d956f07468427db646155e4f3503241490341b48ee2b34f75798b4d25b0870264ddb4388ddfbc69fd12463e4b533447da835d61f5c250e65a31034b063344498a05f8ffa4f39552eb4e81e35127cb3e69ec8572f391b6047ceac48f87b8d90efc16828e5638e46ac737884cccb5b712ec13ff390a6d12c3a5ff6e7bb589f5df98349abe699b5c2dd180292e523d7e91e1eb1ed1342b10c3ea5793bb03119d6b2787a15be2ed761d693238fbc59b995a037df2bcd56313e13c580e5d370a793bbb04d29ee1fd050b404a9d48f6982fb43cfe61486bf5d772179c548868bd36f9a4f277cdb0741897f2db7197489534c6978a96153e25cff6f16774af748b01ceab5ca276e33a3f265137712f599b943ef61ced4e289cc23f38287f4ad5c64d9ad37aa38b4281f5f93242a4bcb3343f60b1caec237f04f31aa75dc1403ce663f79babe53775c2ab7acac8cc5e94db8ca015279075571ab8dcc2d94b80b8397a634c3b341b9a2f4aa8e31f1d1e7dc17e4976d0374496b7eeb5775ed2f8f8796a6a841e91145684f3e9ca8c66148c3bdb9ecd95e38a3c69883f4b9e4c047d253d56a8043fe037fbf0dea1abfe266d41cbddaa2c6fea1f3e154261239ce7b81a8d837ff9ce13fc6c0d248a85f13ed20a114ef4533d1bf7152127c66ee138dbe611a96c5c81b0c796f0d78371286e18b77e89e4a1366e879fa41b6c6191ec4cf0da4d3e42cad4771d6fb966bdd809c308f4541e1aca650b58118c1f673f942d5d95bc395c14a8bfe770e53d27927c16f783b3f029a5a648bba7ef8fabd96add56a0c45a49266b6e2620c8770b6d6cb08ebcdf3c49e78a39f535f1461474a2b8148d26175717e6009bdbf3d8cc406d0c5ac49ae7263f7f179d83fcdf0e1e484690061cee9b3c8fe10badfc492d2594259e9abef4485ee37b65e374ab4786d7a28495fb5bf8fda6610315c6899d90511af49b9f906562bc25980ff91331da8cf7c90a8243dad550533a951114bc4454b058c93276310d622581194de5e2292c125c6818d6ee05058bbd8d98323b6b0b5dd3683bf67b8cfc46b4089f5b47a7bb5fe66ac685dfcacdff20b76da2a5fe5aead03e222caf525641f702c3d260de3293db1119824eda784c6bf390757ce425bcdafcf4147265ae28a75229aadfae7bdb38f83462059901c13ac3427eaba96878b869a9e2ba1a9ffc890b08197f4887e1398517afcffb5284b5bccdb1835e3e2d9c5396c85a71bd04d5cc59e77a2fa55abc03f9f3f55a69d41403d895b0b67cad7e1c0c841115076b92d4877ea62340fad16df860ee2c2cf6e713f6432e8b590c608f8d9873dca5788bb4293a1f5005707ad2e13ca08f262d72a8a8fa647efee488a45d724f9aaa0ee72dc5075ec23ef757b6d1836960fbbce41f4c12ea9e6069908c926baa49b17ec20a58f6a8249e84b928aac09b9cd9abcee7cc03c4b494a2b16e8ed8c3f7c6988127187c1f13381a9cf74fa5e5e0de31c845ca177df3028eb5854854b3f697ffff6a259e898ec7a50a96a83885f6a456ddd7839ddd890d04f08635f386eff7ead7e3ace9fdc5fba35d27d63784dff9714e99eae9acc9c19829f571bf5fceb136690aa5fee2db387568ba8af15a70c27887f48bbbf11a781b2cd673336a8588f6356412006b85db738f2c086d20dcb014a6dcd7089888a32c002047d71cb50e9f3b1b76c7a2efe4d12b12f5c1f7a8b0db2c490b124ae8474a2d7193d254f856d459ae620ad6af3a4df2d1b8fe8876f91b464d445f688534db28c4536ea2e3a5d8a8157fab0e6ebb6e3c289cae368eb4515495bfa12bbb371cb67e8c92256d573a847b7cc12069922ea435e321a4ebabbb8bfa9fba0d233c8e9b5f1a57f09f09707ca70a8356341e51cb722c4ab2d640f0feb35e7829f72e09690f6e5fa69dc212d8d0c5e66247db749b3a3b64079079abff71e77d6d5d283a0fd2ddb2dce6b063332b507f5337230b9453786509503f85273380213ed74a05a2103bf7fe80595ba01ebce9a296305bc50f4c7335561c8027b98c53348107feceb939aa8b2d74b5ed870827446b09c9c5280b293c79d044577fac3875aad3ca33bc9d0b2258b4c4889fd82991fa7f655f0e667297bdd478de4b5ff5da3f085e62bfc0caea5bbc3a1451719f9fc62cccf92d7cff238021559a168b8ff43e00ad278fdcda8afaf7e63f4c0225f321c9f2d233f8b38d4525353a1807454ab8ac6c56dc9d15d4ebcd977001b7e610b604b394dfba33267fa70c1502ad61d1b05b5fb48b26d9fa53ccda51d147ebb13b5dcb537eec9eb435f7870a772a92d8a5270002504fd93e995bdf8074c93a94d10e99c0177e43890c2f13fb9bcefedf2d18681644b5e08e94c174827c13949356ebb9529a0714fd1c631b10282cb0afa46c8a0ff497adc0f799fb1b08c1b17a70b68e75bfee409371f5e8f4b146052c48c96b37dce1ed8ee1c308d913bb8874b4abd0c59a7bbd4e488f0e30e80cfa059c9ad2a311198090d1799521e4746ffad3b033d944f1678243afa544d1a5f3d4573de66bacff1691eba51dc728b26175cfa205de9699f21d1379f466c1e6676748628b75c27e11c8e466f1231e387a3a0e039c452df4117f275892b748c9abae41b6814a5056d9915b5752d5b37c09b3feb8bfc5e0ac32cdee90c54201773abe319db1fe049a7277249ec942047a4b8a33c717b005497e85ab99dfe472ec63d0c939ea28890e22ac3dd8911ab2fd2bb221f6e4f10e59580c430eb28b5e0cc5db93c80e8d8faf15d73d8444ae6b4911163ef0877f23f46f3a19ce08ddd0097cb21412af433bc411c03d50b541f1d9cec2c169425651a593b3c35f6b8d7c0ba9f8a2e77be7ce82ce11cc360fb2391b5d69003c07c2a19582aa6d82f0f0700cecd58ada1c326f9880111f7118bcf0714bb3228f93f04a4f03bb1ad7f9736ad69c4b8fc52328f23e916c01949df8c3570ad6ca27ad7eb268dee6d82d0165ce592d22ee315be3518d4ccd9920a87c7b0d6a9aa1c8ccb6bfe2fccf606e4aa38ebbdcbe1cb0d80ea1883be8b05e95fae60c14ae8b1299e1b5e69ff2a059855e57a769b289437c62fbd810855518842150317f22f5960308992c0bef5c8e572364bcd264c44446c61c96347d73cb793900d2c8ad1d592cf09569a7cf2a8538385b7f2a257bafe678eaff08b37f15404c75272226456f00556957e6fa814d34be0682663fced9c202052ec80096c89c31f8126fd1d908b8b0ffd0443317be1d1630213c643fa185b34b8bb23e243dfd4922b098b40042d3d9debe6870cd47aefad20c55f7fd3021dd0515f512df39335d20d34541920d6d2c0782546530295f1d783c8a198c03812dbeafd490bd8066dd940b89b40db79991700e12b3edcdc529dd811195366ed5f5e7fa2dd1d0b0935f64348fdad0ae5fc0c57e7fb16aad382bcc8ba8144f3e3a9c15d6202ac15ebcaad294243d91782fc7b7597072079f720d30a1243561a5535f992589d97ec661ef4e2e8e170e17a7fb2c0b1f770e2f67174b6bfd6f41d5ca270de2515affbaaf4674f4946408b953476daa8da560a897af588221d22b73cb3edb4d689442d27ca15db4f49650bd009ab9c8df209b506da184f7c2608703371968cc7ed96e7e986c313c112170abad34787a8396d1585342ba05c650f167cfe972e1cfda9ecacd04b498496766a696421939d73153bff507589fc47ec16a946325f601c3f5fbd880ea49aeb73f3e4bb439ae9d94c06256d1edf46a88ca5e74ec5f6cd3018a3f3972261b3de8017065913c8f4bedc3ed695a783ac2cc1546003c4bc32f9253c8beec8f75266d75e1ddea65a733223f773053eafd01cc313f1aede5d22e6aae01d4b15a37b5918d15c8d3c6cc64bb5f08798702126b5bb5ab65535f0b87c55219dec7f0b312463b53267be304bd561ccc2511fa83969dcde218dce77167f1bcbd78d002ca6b4f8b6b8fec80efbbcab99ec71c4fbb4c18da95e1a25b42e39b1eb79cb72aeea493c34c9f7a4f8d166a2924407e861691304155fd060c8bd9c720a895057c2967ed8ab9b79cddade921cd57e1decb2f3408e832899d0d8c276b7bd0332ae4344aea500d097b839a821a20b5e2db70aac85ae4c8eb6d4ec8847e156d72b569eab2c2639cffa12ecc2daf7d5ee05098b4b1addabee8fba340d5669e8e87b7168431a06ca9e001acd876b4d630c96113bb6683bacb012e806e682e08d31671960d7f586057caa5c88d315b18fc51c86c0984a99262e6b114f7efeaabbc63ea9c3b4145367d48a2b8123dab7d3a5d67de5d089ed3b84a1ba4350b0f2338b24ca585944c82b74e5ebce8462ebf6ad2effc878634561f8503e9d529fd55cbaa495561a266df3c3055e05c4f462348afd9c3eb80bada6f873654989911b5a82130a58aa8babb834d023dc749db9323d3eecf4472643b4cd521f85828f3c8cc177f24cdd6f72f0a9854c231402c0d4f19b14f887d1b6c59d154d26f9d31768bcfd76d4eb411c265ea4d9a8239f848d40db92ed148d0e93958fc77ace80689b44d7427dd197548054a75e44d35f6fe54fb803a71471d34174972e72eb71ae4dc3783fa8cef7d7deafd59d09ee6202aeb475126eeec51eb451fef9929d6768cf8385cf71b4e9a28cdd28aa6f2c41d7c434559cd8447443ebcad58a97ce21a3223a7b16e4fbd500837d247782573799c4823a1716e1dac936aa1cdf1f47a4eb2df6fdf8ac09fd26926b895600220c1cb5ff1005ef95966402b03a8cf149b240b897cd4076797b18f7cd8381ceb20f4c663f097775f062d8ca62b803c257f9e5c822ca64cd9fc2b145c9585338bd7c3fe399d37e9a54ba19d13b612362a0a00024c6ae1bbb6e9567412a20442ea502c92223cfc82db8a5b0a1b89a7ac6b875824711a2eb61239fa06ba045a1f13a726d381db61e09ca432049138dc82cdfcee04d0330abb3587c109b021bb42339560a3b716417677ca7e9d085cfc647e3bece4e431b57c53a0a6c5fc15544cd4516b99f2a39799ade5267de49dd360c5a3ea5805692137c9c7aee6f7ef53b5708e95d0b3b616d1637d859873258aab302dbca7432d1f7a1775515c3ab8c0e404ea429224a98020fc09e29762d983b8446ddce2e814ee6e0f3d6e0b3ce96b500bf0795f0a0bc85680c124dd19d259566b4e641dfd2f2d7823399d7d6801f9a31a7f11409d5049c2e7888451d78a08a41c02c6a991c54fbc746e57f41147e46521891fd5b4c48a1d1b2b85c6937bd252e056a39b995c8b654bd709504d8f1108cbdeb4ebb37c3952f5964650331ba72d9207d86ce434023cd16f2cd65e1197ac76ec775ccc8b84d707b0717d48467e274d2a335a11b50d2dc35cc224a16b016d08f640c6c8cca28c4ea612d004e79bcde3d8a5edb92fb5fa3d0fb9872e72682df9d53cb2706f4ff566a2eb7738180e31ecd8615318aea534ac018dfee407e329f92c9760f6c84435bcdff7f4319ead232615569694ceee1b4de71cd03d711a78b973f1cb64f35834acc6869b1be6f2d53202d4cae3b652ee9b30ed70c749bd25f97147dc449032bf36c12b12bee6b6fc2ade4a62d17734f25ac7a1461cc5690ad2474c89cf7c94876339613e3ca29ef44b57a85b8b8b6360514925276a0968daf60ea3105a2bc805716381cc205eb8d2e31d0c5e7fa9f1758cc3047b805d713658da05fa5618ae92933dc01c4b15d3eda81d1d3fd76a6ab45b0f55b8335ecf7155ee1e4c4cbdc366fa44d89cfdab0b5553687130d810456e5cd25ac7b40427528ce49b960e4118857904657b565876f77e4c2486b9963cbbf369299a7eb6e3ac8a5bec484185036044e6aa8155b435a6d9a750b57dc9be667f4f23a5c2d33d7e9c0f29a6e4a0cd072b7437c6258309aa823acd0c55aade686233f12417ab78615b904e0b21973e2a1f13d689cb7f27900d5e08f008a495c89b694a18d9d0f132f005b902a553b369f9bc1497166448acc5cddbd5f0b2d67f8f8175f5fba462ab36111850b2c5a9ac2d70b9838f065b66844327ccec48a30a2080f0164bb2be2a169e3d09e7d12769d174260cc986b86407155defa60c92c617dca29edccfac6215700e5edf559e8690de265a08626cf9e045c28b86a1c5e96c1ab734092a3a0799231c27bdc94a9bd496efa367ddc2e2786ca3170c049bcd33d3cf83f651b669d8dbe274821bbcaf1971666b873dbcd91b58e07460276b53de9c892e80fa3eb38ba7639729f91240778786d8cb63626272bf598d2c8cd5eb241d5427cdd2085634f1ebe9c68778c9aef74f2778b4bd9ad6bd6b102af48a45004d5e014e2e7de94e7d993cb9a632e7c5932e285d00948f7760c414e828c886e7e008fd865bcdaf2353a5fda99d15b4de56356eef5a86cc847ebb833129f05bca8ba92bea745e1f70d8ecd39c0b402e0ba91dfb4ba4a0c3c31c7462cdf78094d8e92ce0cf51e66b5907d43eacda9714070d0e0a893a6bc45eda2f079d4ee4e13d103d46b5d45770cc42a73fe652934852c81c2193884f07ee123115ce96757e5bd6672705b44b872e13318d31b999300e7447918adca18c1df5474c55722e42b98ca096febecdf59bdac4f08ce9eacf91b2851a05be63c73fe47cf376e70e2b88af707e81faa6ad49e54e8b3d41d6fca789580abd451e806d9f5890c96fa784a11d573d208620b344f2c0181f98ea0e032c709e6550c30fb0049f09394cbaee330d6bac0e96c648e0850a3be7b95bfe5737b27b9912e639d24a62f82951560c7069cf3de56229c2f6ad2ffe7bce2b7e75ea7562b4b4fe7041fe108782557d70b4dab4641ebf2ec43f05d4e3b152e793c2b6097459f77678c9b062f8e74426334363879dd0c43c8fda3080e4589e6d9e27641c7409fa61d8a68370dcd9b75bbd9769e15faa85e07102c71ea93c3f1d3b28899708637e6434a827a2f1a753cbff7c550c506eb2e337542869ac56cfdf2ee4b33a89be94229355aa991f94d0b6bd277464233db6019def1026967067ff0b661a40a56d475183bbffd3de6f397a5f5b46d84e827b0f00119f9f46c8bacbc3e3bd15278860c82c769dcd9daff88031a321a5f5c0ed7d42dae939a74b713e60d1fdce826c8df2e20256c9ec7cdf38c3c68183c8137af49084e8e28bb476b023e2d9f9bb2d63dc1e28774e8d5026f14da6d20c43d28c3c509795c94f9f69f4060262e7bc432aa2dcad1ade05a533f13efcbe26d7a889a908d0251e838e26c36343b8026c2d90ff4c2505cc25b7196edbae99119f3cbdfb97d2e10e936359beb72990d085d7459ea25922ff661ac7dcdd4eec4504c42b328f5a87d041eada2cb6221248031f1b0515a728d31ab1461f928ecd212aab99ee1e05bc79a54b783ece53916e679d12b3afb7bc1db95d5c3c9fc9b40837896d816173947384e9d8c0c92224d761115a891f589f421d15abf2e60cab3c27181dabaf7b256899d8a0c315a6ddb64bf06ffec047862c55d2e3ef180b66bfaf9b7f84ccbb76e18d8d262e9fc3e0344e9b01337ff19981c73a0fcc9733972179795289f934ed8baa74bfb9dd441355ad38dfd4a62e32fcda469994675d91c440e23c5de8bbcbb8aa8205fe6f3b0e739f416001fe41b650a975d6916f56b7340a2ebd8b4901a990ca73aa914c9705805554627e0623374d50a73badedc85a0a376e86ca7de2192ded29b97c641690de64e0085f9977b2e8250fe0503ace9336ffef87a34ae35191ad36adb251cde24a58796ccdb3b23ab0ba188a208da7b2adde413043b4a945a2745efeb4ce0f2d3dd7c7a6dd22fb8eb7416822f850dba13055311835fae61f7f21978ec1a98d1a7994c70b48c024f437665fbe36e0c308995a990515a200e875e856eabdef641bb1c41cc5ae5771c27243b83631bdcee9e40866a58d1d1a991fd530afd90ceda3d2f5152b919721d1151d1ce91865cd2ae338528f1d25a50cd1d5b5aed4c5270c3c41353471a3fb531a9f416610785cf742b2c29aa1cfcbf3df04323c375472d8405f938a770145822b8137d43ebde268375551c247c7a4ddcd33e6da7e72146aaf9e4b65e2f2ee2774526827cf064f709be62fbc1367e3d456b028c8ee8135a739d161eea58ba9d459b3cbce9b8233fba6563bfdc9ba6ac5ac93f45cd66becaeec3da5ff76b9dd0dc084fd09c4485696798294b3c03b6629088480c11bb14531e3495258afb5cbce638927f9b374fbdc95fc22a18a922dcafeb05992b1a74e71b3866214728efee3a58ed6eee1819c77066ba1baabe2e3a855af3b1da53758509a19b3c121db84f5b29836e74932e922f92a8e7fc88fb7fac20df54d516c6b50d4b8026db11cc33fc37b6dff8bab9d869231745c8b2eb47127cf82c5d10798fec218e600393043114f539dacc898fc25a780a0342756cd229bfb15fe07910d3eb8c527ff078974c3773e8dcbe52a2bda3531a5c99c70c4366d031ef299e36fdec1d28","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
