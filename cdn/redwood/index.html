<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb1abff4f5c3f9f167ec85acd5592c66238be09393dc6912e8bb5d44a443d8412bbc6f115a8c0ddf6901dab305437363b794539e81b499d13c8299085d34f8ace7eba7f1d8db8677ff402a3100e56b932c00ef4b196b69d9cce89116557b8e58bb9776d280cd42b25b43fd7f735aa983fd1d0c7922da0a5079de911a5521ebe6459f51c636929f159fcfb7cbc82c378ee06a25e68f5a1982aa345f05ccf61bf047de5bc0ba61ba5658522cde6b43907a3b286e0ec2f219ad4680cc9d34ec3be4a64fb5f1930f28ab5d9b84695f9b04558c79541cde63aeb5e19c5ee38d31719a6090f666d1f36953db11bade0d779ad83d212978816139dd2c287260fa791f9d074c29957e104c6da182c086fc36a1ecc46d5ad86950b9e579010a9230b33d9d01dadc6687b0ceee0bec7a854705eb6496c63ab7c1b5668e4ae511fcdfcc6789f068b62e8d0f364edb2b47714d02ef7c78a327f2e231259194966a33a11dc7e921037dd2d03986827ee3ad0e498f5c1f3081887e782fdb02516a460f0db473cd60b38b82b2f823e3bb59accd6afe438cf80b0f59cd5b75752830b1e175e325676a417ef0ba0607cac346b25ace8042b0ef696cd31cb67ac74123f79fd111ec7d978aaf52a43bc4639c4b98f323e680019af50490a28dc55222e0b91af2e698571394d7978c2c8fa803deaae529d4759cca3448292c325c0c8306b7aec36662660c0cedbaad8d010b935f386fef33f97cfc023b9d3af0e65d42f291720b90df91f2383d6a29c44a7e359631423182df8aa8d5091e880e9dd7228b3b5539ab818ed6125a1d662c483ad1c260e6c40b735b2115a1fd56dc25de1ce8e87800f391c93a8c6c2669ca1235c61ead1b34ad4ae7d9c3aa6b9abdb2c43e8a5d9ca6ce700801737107fa36af589acbff510d4512bbfe9f7670f0b9b6ff575e50575c785750eacaa34da67df66056f414f4f8a87547c11b47561d86ae69047573fc4c13b26f72f5320905e5f8bfab45ac088062667f6905ef63bb8c4b2845f4bc28716ab8038155b802823c710e80079c4bfaa765c158bcb7369ec0985114ba987ebd0bc96df9e2fc3b9153338022dad35a0243d6f066ccb21a6695c94499462eaffc63b8c78815640e88da2d79e7fa31e7ff82f68e22fd925fa06b7bb048e2945738f64022e6f9a503e018c2cde97c772cc9ffaee558ff11d0e0578fbeacb9efa370306b2e208a16df380f33f1cb49f944348962a77384a376789ee2f17a926f9e06770b02e3ebba086759f7afde24ff61fb0bd2d7338c123f98f99f2465e7694973ae8980b0d6bb3146803253d2468926301de1c23927d3b266b9590cdb94c59acc92330595cd0930dfd5dbbd741f5ba9720301834e54576ea4749fd84f14a86ba29ff69cdf686a3c4e172b55c141e9f276d98cc09fffe2ac73d324b4b428176d8cc14a7e9ad15a163be866d2cbe3feda3f6cbb626afd42ff87b0e6523fd88c21e3d16503c88c9c8d28f1af720dc423e85b86c306200877fe80b1dcd198306fd72a710d03c86d7c973096e234ee3923f4c43ffa0fa68cb7fa243f179da11fee524aa775cb69ac1a7b41fe0ad8564786f10a2deddbf3f7801290aa22404ca5dee986aae64dd67ba08c168b718a2730cce71dc10913cb6ea690f339d0e861b8929be57eedabeb676fd55a10c414f7708d58dd3fd4dfc94506ff42ef4129621dfe7725b1043e850edc3959c633636f45a3ec93aa7443323ea80c35f84c6ba7b3e0bd6aa4595ddaf30ef0357f16722184a6fbeeec84d479a2a2d931762a4ced1dd37bcefc384a57fa2c539c1299eb979e01b000eae86999d12879497ab3137ebfc942d7384837e464e780d13e32f30f5deb18b16c3ce65202041e826f9bc1098d2225e8c9c58fefe7a9e268545e8cfc888b8f35bd013d1f63f8c51d9724bc4fd8b428e29c2b9bd14bb3265c757d7d0041593290202c6abce9c040f098eee966809a4afd352dcc945eb50c84340993ff1678123c2d667af98bc920d8f856fe8f42c3311495abae105d6427c4a7429043cee6d1fdacbad5a1264da4449b1257e2fe194e176f3d356c4aced9ac8cec04d8410e27b7584c3c9a9f5aff41a51fc9883b71ac518562a2650a8737425b0527cf3045f8493772551316a0b9851ed87bc3f3a2bf2d942175dd60e48735e1186e328a052bd4675945083f95d2d4318e169e2b89e7fa92b656a15cdc54c470976b75304a1f51db04baa4b10034eb19d024811f35a8d3d7e473688d2c22522175bb795a01f1fdec93bb2d477e62a3f575992dd9804ed56f015c7d4d3fc9fe66f18da049c93957778cdecb5393b779ef6201a566f2f267424977bf7580f7225dffe4d8faf32f13d5cf799c13aa481691a88f1b69cf052c35a095b54832ea9d9370146edffab8cb14d0ff1ed34af871a1c7662d831883d9bb118537ef4d09fced95ce0071c0e188c6e56d2c66729c1805652b17da575ce22aecc59aaef06d1c60cfc7d94a29aa89ea09caf70277a722ed994386ffe3d66ed028594ee1001392291d15264c5cd5fe7500211bcdbc24c04f3494739db0ad68d27cc2d9b5d6e57a88ba037e275321fd08dfd02bd0e673e38e334bae6df5ce989d6988ef7768f12dae01a44c0e7574005693012f43097a13f4bc4b7bfb066121d3b38f7912983afb3fc5d9b9de067c8ac0480eac0625140bcde9d26203100f7988490d0f2a89e6d0d4eb339ce82ce037e08a4be0db9affc289b420a31a03682a3d5148d6b81d726ba17af74bd6a9353abea249bfc9421617a9ff1e81a02c001650e59f841af22734b95cd95e3c879dae69f5d6ea3926460b5b415ec8a1f67818d85af3028a49029293fd909288936481bbc9f041fa39087b929a28d53c8ba186bbf8220cff46c3d6faba7f2bdb348c7d02b19e14b564765074a4cbf7ef5c2d889d4dd24d4a61b65ba7b8ba7836c817387f00130e856961c1eb780d3ac16c8513af4dfa3f84e27f26c2dce8b2180516ff7ccbae8e14a4232cbc26a6caa47469aba3fe1cd1e0157e7bc9c90ed91db9f6cba6ea59340432b7cc9f436984966309502820817a7f8265269edcf51c0a5d6225cacf44a7a4180a24966eadcc599271acd73594d3148aadc8f1f8a4cbfe26b3fc70a0a039663610007d3aa7bb5aface5f58f6995caab74592729f149fe6172abf53d07e4d6e7bfeb947afd5c450ad32c2d245eb76045fdff02f5e9437377d5ae24201c2fc309448249ae6aa1ca86360cf6467439e979adec624c8d353088a38a1e885ee6623b25d66b509940ff318b7bf54e6f9febb8a041c0cfcb51352c7405809c6a8f9c6abeecc11f3b72f2232cf1411d014db466300e07152191d983bfc1e35cb5b0d91095663ae54fa3f980b9ac0255a5c40a3e7a29a946846663aa11086a689f1cff8d9dfa382186c7253404fc612e5f7e5ed45d2ae7285a15a43ce00a91ce88a4e484bc07ff09539cf3a3a81700d638b9ddcd0b060cc13ecc88e9059c8e8a2db7958dd47b2c816c76aebe6d98b375e5e69e3b2366144f38f7c915316053cb3a3237b283034c9697c266503d913a0aa42178174062c76054ca52999a9ca8ff2938cb61d627f11ad8e1ab1902b51ffb908a309cd65f2efe84b4da0c3ad91ffb49da91fe8e12035f97bc592fb1e068c17803a3c05dbaba647cabfe71929e0e298b1f12e88dbb97789827a6485dfebf72ebfa55fefa0474369a1ee07f663a2e3dfce34af67ffa0fd0789f74b0eb75a7c2a8d1f792e76b50f3aa3f821a2367a50733d7c1e73482f7a36b0d1f6b4931b8928da0542e04f6aed2923dbb87530180aa31818c616198761adbd939512e014d9eec28b01fb0bd1665b6904e1aab16a3802616d6814cbf7a41b3d2d27b1411dd50dddfea4989d04a316e32ac970707307c811f2b3af8fb8919129db5560105fd4798a935049215b0b3db7d8694e1dd50cea51805116df63a709dafb10e2caff46cebfd94e3dba8b7fa08e636b3f5d3aaeaf632b8102afc3187dce2ba1387320a0480cc8119f5678e1e7523d4b4457d809151548e117bf3c6121aeeacf81e907a2cc8464a7227f6d003c898586ff438f853ce258d24fe5295c2849f5e9703828327105b117f54f383e1c13a381d4b0de8aa536d49b130021e90b7e9068e20d21e20231b7396491b7007a2d54298c7da61744bfb9ccd281df5fdfbde3baab26e2f2272816b80191ef171f1b0dc7ca575745c2463866a6fe210e2a21cd0dc4445c741a46cd8c02cf875a69b2108039f692fe5c2fc82765d273e2b91869575b0008902cb57f83f7318055de39f6acb5a04bcfd2b5de4ca356058025caa89e46d108062e19c0a26afe5899ba2f2d2d8a774059f119d8fa1b168de1f314172b5a4de237d37d103c5824b86ec617d72cfba85623fdbfb347225694c6ca940817feeed65b95c77b47526ec5feb36bf96fbbc2444ec0177fd2119956b39a4417cf55c3638c4eb12afbe5b8272bae2f308822233c9bb986ab643e46e23c9648bd795238508345d6b1ae3b11e2bd2cd51844d80f4108b22d6853c204ee32777a035814937aeead88d08cdf45ff7e0d99334561b5f6bc3e3ec3d012ecdda7bb56aaa18cc2615cab1b644796b1dd177b9cf18107b55f22953ef9534ef57bdf76e6a5defd024f7a7b853d8400cce91fec5c90be7178da72041966a12f3d77645c111dd6090df8d2b49a87c0dec8501430fe32db2256fe007937ede1797173d2629a55826177de8f632653ffff6646f1ec598aee356d39028b425bac3ee95a639dad5129c8c5357f80795e7d14b73455695119b87e6dd618e1bb2831a6859b72c08b093b501248fb487609f8e4abda158eb7c273ef11dcba0bfa8b3313167a1068759464a7bb89bbea6c248258e4fb2328f02be283ba76502bbcd02c56d9d4c157f16d973583bbd40704eacd40f2ed7eba843cf3e6a7ea90154d47b5ecd41c1c8d403f3e8aa6c308b5a29066db06c60a198270b15f24de80b0630344fc64f9fad4d2765053dad5318b76027aaad0c01187d65b7c553f1681fc8ff1c5371ea24f9ac572a62552718d3612cd9dc4d572ffc3a1ad599579cced15595cdd3359640736eca75990e8129f62ed625ca034ef30a99cade509cb3f152641fa86a04ca702f7e945e7277d868d9dbd1c2f9a195fc227bb72ec31b40ee77b65ea0108e1107050dfb5dc9118d92fd77e18c84c2c99027d9527ed125814d9f2be28d98b574d20e498afdac3a9f50a7557695f15c10626978d746c4a51ce45562bbe5ebe02c0232ab6c4a59c048311135e2b4910188b1ca7c992f13948b6832e0a0707ae551e39384706eea7b0098586fc6e156479f3dcf114b70b3f473b0177a9ab87992d805cc1ac2b548b152778356a42207ac0245e038a59e6832f1346fa18e02cc99ddf21a5724c56c0201cec91c2b06ac81531bcb84e5e2da16253a6f870da757040104572f6437ba9f1eee459c157eaecd0aea737f7f74cff1b48edff3f75e6d48fb956e7c718db07a70935a3fc8576efecde622c78dd95e574c626baa1279afbea43205f4b0fc61c7ab48c1e8f51cd825f4edbd54f4e8f10d4a8017e26cfeaf931f98145f14690c3b8c929b2f9253bdce1b7575824dfdd135a47059bf98454b47e15b7ff3e5f0dfde582be01aad518ee06ec5ea2a3eb4fa33ff066340aea10c7a5c5b66909bdaae49d539b1185a36ad7216c45b161c9bfd388fbc96a67d393bbbf4288334c4702fc0ba71fc2ee2f3bfc6e466754c408d1fa901d17445b9d1d2090ee191bf459b7c6d7f50d0ee8e8cbae39d6f9feb859609eb8f78fa73a0773575d90a8e13c7122d14e2c96cc66292c14f2849fcaaf4dbebdd1251eeea3ae1527b66de6f1d093fa1789e77f95f3eb1ecc52bba8b40efc56a1e787e4044b2a77c233302a854879e9abffff890f2cb9946752839603da878484879f48802dea08ee4ff2cc40afb20895be3ac7ca05f87de137fe049566421a7ad0a78c6437278f3720a12ea72cf1074b55be360bcec3e7b008d27b6789f0e1101db880bee354a8f8142e38a966c43e222a4eeaba2377733ff3bf05ac4414dce4daa20f2e1b3f3b25759650c9a80a904fb4547cd5cb9cdbefd14365b138a1f9c3b311468b80d241a8d95a80baa2d67db50a015b9ba40cc59fc77ec66ae961ced05c4d284dd92fbf2214b85c4575b91f45479ab20d2ffee68c15f1708dc8bf176d6b76319ad30759b58461b0e69af093694c822eebdde71831f16a4e45916125a6319c187dd7792b0b5738556a85421db7ccf30d401bf1cdbc02afba6b1cc428fdf8420c3d5c57488befa7a3cfc4cd26ae7ea5c45810e470e8289cf9dd2bac2240d337f9494e717c311c9e835284ac883bb86d08d151a018415e2ee702fcc1742ccc2c513d9944b8f8292309ae554f478c60747763f13807774d2cddd0296efe0348aa67c3f574e5f61347c69996afde63128a107e27daeac242506a82e47f4bc3aab0c61cf2e270c42ce1af829a9018e3c9d69b3bd3fec02154b4a5bae342fe7a6ed759a731c1fb259134b494b2b128b1599e75951877783b4a8425fc26bdd015ac665f5de4ab463e952a86f265007e1308d9c6c605c2219b718a989e7764241f913eb09abaf134b6519f4e81928f1982f5d46a7fff57d11c63b89a01dc12e6838ae5b8bd6d8c6026d8e22a84bc475b294b53443e1893b38e13ab893b123d093b7a76041e91b4c6e492c74d183a4ee1fa197b99b8cc1402766eb377f0dda0ab494328d7121112b2f9aa3dff698eaa12bfe497951a5703775ba99307f5155df7ffcfa3e1f5d704f312e70d03354d48ede71bad5342b681f28afa99ed68dcdd2a04e10085fa57493c7e6b8d9f978728507969d922b2630349799334bb1c15229ad6988431b37eb4a3eb848c2c196f3615ee714e5fda2772b8be9be7b9b7bdb9ca22e18ad1da91a958bf91a7a1cd2630aee3dbc4dda074f06846a27bea8a23e3e5ff0142d1615b68957512cfc4ccb64a252878931ac9d7d1f432f998545b31a06e315204bc6a567e6a6c787936699f697e75cfa7df8d584114d21a1ba9321908af40dcf5526a0e3cb92979c957c1285d70ffaf28d6324b7db920e5472d3d0fc88a456ec841add4dc7be3eda75eec87492b0ebc0adab8a7ecae92c5288e4f364f6a964b85778154b2bcffda138d6efe9fb06b062e007ec684b6078f449828ab913884d0eaf98fcd26add6b4a552cff5f7d89594ed6830cdec006d0d1cdc2e075e8cf83d45352222ac43831cf08d5889efc26319d6f2f49def500f72c218022d8f9f5687c9808dc4eacd03e048a7153d4ea88da9a10b43e866529f1cab0aedfe5b131c793ee330e8fae179a18981930ff94468d1f7dfcd3230374b6fd51eb4ad3dfb946d4848e72138a93dcc09fb57bcb5336c016499709eb33caa926595c6b7128bebef3e7d113ad1d230940710672f2cceefa914157d2a1aa795361a47139522f0c8df38d7ba115892a61304a7d481a2f5ebe0ca8b91fec5b35d7c02f4357cdda60d4fa498c17e5c7a74e97a2fe24cec15f1a4f426b1976ef4a8abc3345ace169079b818e63e5e4b80d7c684a1249406c7bad70cf821645a635cfc490e4d413adf0b54b29fcf80e0297344df9fc80469f1747a6b7f2a56e0bae3ebd69769722fdcdf7d028cf4832fccee9690648608d5ec2498e7b9e27df1480b90dbf9a19c76e6edc1c0ab67307b2c0b7c24cf98bbfcef752e1f16e581c8ef30d1ca8dae2f8dbc3ea3f611df05f3c6315c7b7f808eb6acc7fdb51d60ac173fa378d50943d1bf185afff5fc0e0b73c1187be561bd8ada779efe75e118d42937288463236fb87b64abc1e708e9c156eb0a578657d2ffadb98b2c041929f417a64570866c069790eb214511ae0c01823e3282e498aaebea0e10d3e35f020ae2055296a9c68ef82f6fa4a74972c5ef30db939408b2c30839be56a186982e8f81e5058428e321d18c310fc401e260ee1cc2869cad72694d6bf78ebec511720c63f48628e1ca9ca3285048132dd2cc03c89b318787a8ac04c720668e5e8382b39d139424a71444f4947c5d433e811040a1bb9ce0778835c9706ee0ae01299cbb05acf00de250f837743ae40e160ffa4e8ca1148932ce00b38245b8eb10a617347dc5c82864feb47bf5db65ad78f683a0286812e4846ae6ff0888d0f9afc758b1fc8414b5497cdf85d8825bad32e17fb170dcb62bf9e82392ccc4d80cd9d7f440e9a8b05359aa33c10ef29cea36b2e95341dcc47a5d86e44e6c3f1561fa93aa54a981da2506399557a91e995b1218abbf3da85ceee06bc45d3256e177d6ff6b04429c970a321ca97cb56b1c4c4ecc6650cf4e47dba8faf85b763a417efef43e7a9e4d2b737615bc81277f7ca0934b4cfef099b60e5dda9a6d0fd655bfddf95fb61368d0fc6a401f1c95645071160db9a3d549d17e59e167095532bb8e17deaf56a7bafc298e8b3a83bb61c969d94de03edb5bcabb4f0eef62111f822b4ed10c9db3d9809b767065ec1744c32ffa508f3f0b64a1e1448c395224b2e49e8222e2f6e51e602890b60d338b2c380937aef8caa9ddd7bd9b43a3a08b3b7207c0abfd86584fc4534451a4629eb21aa9f6f661918f5a809e787362746111d9cfd78d43c5cd58b98e8ecafcbbc606244e8c9d805bee3e9528caa2ce26fa79c10a9d7be94103e1c70e5a260da3a8fab96bcac7f6530e44a112fa522381f8d993b72095d7720a235f60d0cdecc79fecf681acd272aa5a5a69f40a794f6201b74297a042071538b04d75eaf3f434a92a3bb60af294c5bbd1fc1ef37464c563b7b1f6ac3c5f217cc30a9aa303e78c3707aaa9d5b37a222baf728acc5e0d03431d1b0dba970a2ecb3a23978eecaa74d1d10e59b0875bcae9b21f082db215576a03aa30ae1d9fee85446cec6c3bbba7347177076bd39f1f8af36e2e5abff7088ba7d9fae2fcf4b3f0462b2ee95343cb29946637408f7ad1fa34552d619af8704f2023b11a0744e6346fb3bccd59ec47b356a97e07887c42bde77510511b6516bb299142243a96c0ce10b753724502fb1fcd353144c35c416992f04451926d72fe327f280ff42b498c4c879ce3cd17aa17170ec8c78a2d01ff9f044d73cdf9bf5db2571104a9768f9359d0e426c542f09cb77d2f61c7cced0b6ab2eeaf8feb32bce0a171d2f808e4ad7a88d60a1bfd0afa8c220ce670fa9bc6b09d39509ebd92f23e0098c4d136a28df6be362f1b1b47d54cefe7f810fe70227d58d5500017db56e6c65cb7bf606498a872f156501344376cf4991a7dae2e41a3fc84e53ae8933d573a6c04f951b2b566148a08f10d9503a808e6bc9519e1309f1c4405431937c5379142d4168ccc574a6e99b498048a040eb4f2b08ee73ab2214c76cd25c9877329c5f610f8d5e0978aa63706e465ae751eb275de9a81dd8a5f7723dcf2ffaaf381ae36398da467669a7c11651caad2fe18e10b6ac5f22eeda8c681ddf5be6db617f7d14b0ab6e681b1558b85c8c2a259391c91f6108df09c2adef5f2cfb33f1b1e73190706269eee2c876b549876670e189bda87ebe32623e755b354800b47ae0f13361a999f7bb3709da3d4dfd188a0eea78fccf606024cfed8fc8a638f1441a18d46abca33e902bf3e5dd11b1f55f51a344112baa710270cd03e3464735fdaaf0e09e4db12d9778aaf78615192c219a3740ced2cae22c2e6a337bc7c1e46f37499e5556b828e9540d899b4f82bc4a39bc802fc7d7d14e8491a84d71285aeef192338a75af454f9080be56a33a327dae710fb81814ae7e418493a73428442bbbaa0210ac1d95f18e96f8f9b85d74c32f5bee9d67d3ba6f41b1daec85639e52fc4fef0c5af0b83b8d9ef0b2042fb438597f1e0bfdcda64e9f0988409f50c848e068e24d3849ba9e415f29461a68c6341a4592d503dfcb7375d3a618bec5d386e62a28657d6755a1cc3c677fdd3a08d5bc5879163362b8f54bdd57770fc0e30d5d07075b4a49701afc89717e9a413004dbe138771480d7e6df8da4cc65fe7be3a233933b24256b7b6f8cae25236d86ff11941462f987ec135e0272ecb6b8dd9117d6c94c178b8dae070f2d42d2ae1f00274bd1bd425e936ecb55596665e9d10c8ffd1086e3d1e1eaf7bfe5f2724a505b35ac2177330a1abeea3bc0832583cccbb0a314403f5374a462f14a512103d400c17ff7018f93a7e54f940071a2c08f1561bcedc9d2c693286b1922d7b7882cf32544ea506afb14ae00a90c1a1cc1e58ead3e652943ed779f851cdffa5cce9415cab6bbf43b0a41cab439c1f0a931d971837e87cd436337f55275661ae2d2962ba45b225a630ff6b52b10f0d8247202d01856ad1a02248938f7cafd5631c39a0fed4e5c991bcefd805875b2d3e2029687d69528dc65d5fc33bb3c915d6bdc8ac029d12d5d47b7ffe2324facc688420dbbe85346f703df775650fbc34a31cef1257660674764ea840119b8f1d3babd50c381594e66cd0c8dd5fedf4f06e9e33060fa7dc9dc35ae8332a93568ef721ee33568aec99d7cd683f2b92c74c56c02597287eeb4763117bc7b61ae139d3151c16ce08fd078a6019e33a1ee38ccf01ef804337a9ee5fd2cf3d3b70ffec52b56dee1779e7df1c34377506012addcd9f6537a0201971b6410015a9d29e152ae54eae4150929ab8f7980df8505c84adf0ac5ab979b9d8c677182371d6a183e1d85681d1d5096dc881ec9a041869fa3fc7fdfdc383b7d12450ff6b5f93cd19dc3d5e297f5718b94f5ee0ac81b19a3cd8ce7d10012d6626ce955a78229bfeeed0cf5333c3a0a0483a23f0bb66d5208d849ff4329e368381093b25c8c04e7358287987472c8ec09cece916bff9f08993fd89a6157d0e6a0d7add04b0e5428371c4aa33e1d74fa1ee9571f66c1fea8861b46a2f9bdc27e9b9bd610655ec68fb921a9ed132883902a641cae9a1f8bb2c055baa793713d757be82aeba4564cb30f458c17386b727aedd1ad62c5670b1f4fd376cb28d1b0079028ef07b531455900c75805ff3d82cecd6f0aa7c5415a26492057ac68d91e7ae8486c8ffc22210d95799e29fe0b83db2b971f8c1721a2ea7e7ae310d837fb2b1ea1af26b31729d0115db2f2ad3897a022e79dbb4eaa849f23965fd4081e2abeba1c2fc7e9ebb9f45c85fe6fc5365d9e53bc0ef638d4a71d78f4e76188880921698cfe4dd5f791ef053d0dcafcb68cb355166e36698c2c78352b99b77f731b3624da2aded0174a009c2fe06d377432a7132745aa3a6f1c61e842fa39b7c992e99766988c4c512907c0e0d747b154287d9badcefe70f98954a73c3bbf17b05af30a460a7497ec3b89adbcff28d8637d08667cc6a66713c60ec2882031d8ccaacb8ff50be30f25d11d433bc4d9d15d9d28560003a75ee032f136f500fb9140b8e923a6c64c118fdae121205b43fdd2c06d38ad2dcbd53433938dd8c148318ae99005a8921de3fca4ea32a84cebf71cd5d8ed8232d8a8f984d2c2be074e849c87551a02c8e8555b985de934f5ac188d1119e47f31a6e5ce5a4958de3f28e6d8dce2d1c7818926059c687fc214181b01f308ae4bfc77ec276d92948b81af39e0044efa8ad2e93da6b8d631e9b4034ea4d5642ae30dab573c3244184c32942c63bdd6e916018ef7e53c0f4d16cd613c018aa7f830ccf39bec8438e31016efaa05a31813d735cf56c130aafc3361450dd28ba9457422055aa5ace464e59abf4b0a14c4f7c67a6e5701e206835260ff9f3f09197a91affe28d8e2178fdcf8234b23e67b8ed995fe13c6c4ef5de555eb1c2db9e67f2794dbed86b20698d3f462444b56bc46ff3bdb235bd9239e3ce753b8659386b3973feead7c8c04925f502bb9e35159a06c6733439a3bcedb490e716e5baa3f4fad38bef1a108aca49753f781b1e6afbd3ebcc76c2862fc59732dd467c9c3d77e95d3d4f6591664b8b3355b33cfec013c9387d5370248a56d3c063d4c2fab54cda2ba0178f53b7c35b0e0d681b2750601cf5028276176bdbc66402b9e92dcb951125db774df9c09313c4528ba396c6b057f7db4ae6207322a3eff43eb7984a99127ae6ff6509d6cd3700d35ac4d491b4dd6faa68512e26c2cea9fb367ea142c9af9db70a5448da34131bb1d06224e4b37b504bb3b8a53eefae7e5eb94f2d80c100a7547815cd3e353e5eafbf12ad84d256d60017d691741713d59929a511d7ee286901aed382cdd27b1e6f6a8dad6e63cb51945e91232a25a8eaa292d786ef117fb2168d7ed0103d953855a68485615ae68ba947ab11bf05c3b3f17df19914bd77b9aded2c67d160f0e5f2c8cf94504711d2c4d09ec3a1ef62e53b272d8d2c244d07aa0a37487d5560f68fd48b4d170e1c4db5e078562a2efbad98257304e1db195d607d2dee435e2c64ecbf365d00f33b30bbd761006b3230bab1138bc9254cb7ca3b163fc34bb844154dfd4496c810065c8d7e363675130ebf910b9714a6e0dfb2d9e254fc8c34cc2c03c9994f3cb2c1cbb7809ac569ad869554adeb4d08c20915c7cb3a77ddf40c833c4d54c2c0e170de98f5a4b3d9c5db632b685903c9c374d60c48b5bdb5402a120dd2ced9b39b7ee2985829aa1bfa7444d804850cfbb4527f8dddb967fd27378fb10f67c93fa3c5d37fa1e4b6ae03e3c49b2077469636d78b3bf9ec5272f73e1211c222739b2529c7ff771601da146fd63bde7c5c78884aa43ea9e6fecbd1e9f2b3c3a336d0a7ad68affe95d593492411ab2fddac9dfb050f2b76a4c79c37e499378be59b6286e31f3a9340746cc05caccb521c41b93c01e1a194f36ad343d80828a5f776e5de4ca17b9d3d08269f1e4e901feab4d92efcd2728180da0e2aefb2408593e2d44d23cb12aec143df7b820ba29a3149e5dc72d77f4b74975d902d808a231fee1483f40433de76e4006e7e516aca37c7fab10f7addacf5c1c6d78727c21ad40c9a07bbac6ed3ffca6392ad523e2e19a7479a7d7938d2f5b71ae19dd98022b1142dffe73e99b67d9efeeec16aeb1dec435d5aa6150e040791c876364b27faa70a33a4a8c425d52d3c64bc3ac6a156724109fd2aa2875a38aacfdfa30dee5cbb071251ff3137627a07996e10315d3adc72b0eb05a193bd95c39e062a4a529141116e6ca8b08fb226ce56497bcf11b6f3555ff7caea2483c18e5865f37b430360e4e7febcc8879ca8160925c8917ad285b735a0aad82c546d46b0c7528f895a039286fc87143ee54bf1d62f3c44e586d80b629edc23ec58432f4b8bebd65ad98bfc556b439534a0b357e425c3f3f5f73ef7e15a08b6f58bdb58ad14bfc90dae0ae0df01f2706688c7fdd199d8743bc83948f6e18f107fc8eedd3e2cd6c032a821ece2199a4b7a0523de64ed0cb9f2d9fa4e4ab2aad0fe6c94d374fa3fb2fd790b9345f11816149ae024f86325715931fbea3c36ceed229741396f6c11356add64006c67e1df5ed5aece9df609247a93163fcab58c7e44b86596e958fe362f966e38076c12eea95506439bed20b419575927aa7e540eb4d5073238e3ed8b3d648b5b8fd74a9a771298b243dc79f484b6440240709d42990239538993c8d75a4669e383b6a3ab32de05aac1f6ff702e978e52da593e07c204cb2e52759310fb703752a54f8e77b4004edd2e50168a09216356f3e2a213b232ce1c1ac959508aaa8eebc959566666fbf222fc0c104a95381c04910478f80d94357a74d3caf9f833e6c73032e921675137c469bfcc8c34ba6ba33614568fe7ddc8323b676ab5c587ce82a466fe44f91e4245cd582e2b69fe29da1e8d2e7ee2eb8eb6e1ade0cbaa81b96a8e5a4002b3a1790c3944dc09868a990b39e008a607f808a3bfe006b3b2878f96854b594ea878d3cc1aa3482beba78437f98ae59084d9364009f98ca1b7fe765578ed7c35e1198b5dd9ade8276089037ed936372d9c0e9f33c5894a22511e763cf2ebbb7cd054a00481cf194446dde69aca2d0b44a454f0d8603665d2fbaf9a2f59e6e52931c8eaa4cd1ca59a88901cf231b178a20e65edb734cc767b30bb9f87dc8e9ce83b427a5666299dbaa95f8f761228b6429e0a61ef37a257c77124480f852580d83df8814e80c70e78c9bf0a3e85ff69c38b5f8f116b626eb71b43419b56a0bc90cdf6f3a300c42441e98795ee7075f71a2bb62b020d8527c5a6cbf592cb8bc7649d5c8f248be0c6b6d4054b6c40c0e8f59c7c522d49020a7fb3c0d8319ee3e65e020cfc0f1a6963a562462649859724be3a0acc33876a22a0b81230174ecb2cfae9e7e903a97ea5c9a99f2bebf39b0462b77037bb9c33200fe271c1b43142f9becb07b306792c20121d47eebfba4dcc401fe97cb3a7e0565289dc134490919d50ef3124cba6c0ed636f2a9565fa58358fbdc01a1a9e183f797c2b30e9d898eb913bf5b40f8ce453b39bad0e179a38e35652b59964e55eefcf2d375fb919eb8291b75cd49ef0fc8493e0d9c32ae92467c8316c6bacb3af67eefd4899a4646acfa5af415d9915d78b7cca8c78c702e2fa4da532d89f436de36b882910de514b3ecfa9e9694d5c88dd98d4170c7bce2394852fb006dcb1988249ef6efc92f540e89b83a94e5eb3864553af451bce4395a1ae21394a580c686a4429b4c175fc9dd2058a6c69536a6ed324794c912dd38522a66341177a40f99c19234b83cf29789a8ad127cfbb28a64a1651f9bc24ac735ca9950ad7ffc94f1da292b8fe816adbce1ac1a9b414fe398d4420f680500e234e5f8a4294b0497942414c472a69d6171f9ed2549893cb702881df4ec9ce26e9247e7b11831c8ef109b1eff87ae0b9b85e53cca0e9ebbdb1dab3ca2e6056742a35950105a68865c493a2fcc6702d78f429f7f9482949c98ae9e711aa9b1635780a1cd3c8663a92e462b25b4e3b86a4c4b3bcbfa3fd29743b20fbb460e9dee9c4e57caf8ea53e92c0fa70deca8de0b07748bbbd59cd4a09a47d0b308334849f547db300f66b6d3a2cda91e06ec353ea3057597a6be81c3d485d5bb028da3c488cf675190c9f270b8188f39863ac615f5311ff9060ef37a021bb5c86672b4cee228a4c1d9fb5dd767921b2e63d05e8f97e8c4bc87d8a11cdcdaa4e1b04d2562c963329d6e08f20afd450cb79946367f3a807dc36f8278205d89abbed6efae114e8d192dc6c156bfdb486fcaabf1db331aaea4a97a02136f4fba0211c0c52cca8e379c426e2c28c89ec5a1af6b55d874bab77e09a8982a24b7667b6145ac9990105a733ff2e50dff4f963f56b6388c2d93be1da6533248905ae29ddda9092db874c3e97c6640d5a476d18701f28315ab4123ac8b1ce60c833589fdd05e47f6bed7ae340e8c52bf48d619590f3c252690d8a258cf07ff41b89d7b706f6edf4713def69af793bc73c3abd16cf6bcd05760887d942a33590e7d1e2652d7c47c38db9d97cb2898f1f6638916cfa2797f5a89166404911e3e49ca1444f7343363fbc5971fb957df65ebe2b0fc2b2a7954469d7e2548202a64b7a4af8c97dbbed947dca0bcd3a8c85b0c1df93a51d44a8c6ba84d1db0d67f35bc097b30767a1704b6df9ef6117410ad6c0f42a83c3ab5fd87bf57f1946bceee7b0e29691b6342c0b182c80fba6656b63a4c68f3d9fc8c36a5b7e1fd87fb9071a835ab249339e1d56cec5b490ed15e9f5659bc87e6d70275f8611b2c9da20dcf92b80c0167f49a69a64f455678e0b1a913a3bc1e51ee7090c9ce7457aaf6c6c76e9660d0a02785532830d16cd869ac3ec628a1e0778825b65aaea0f434a17b90b758107913d48642640743c9239d582eb42f87caf014733d0f66344652c2e61cd6a2778a57cbe8a2cadbbb1110c1fb26bdfd5b83fc1413e5fefaec2bdcf9a194de5bbc857ac202328889993256f2c163decc2afdf9199d66bddf1481f3c57999b0476c4d3737d9f378ff4d69efc75385e54edd1521c2d1f43ba6e9b275019e206f050b9fa65c5881b30e8099f5e8a3d8c33efc37d263bbd85e936ba3a9b79fb8c7b7eda47f539cc60f64088cf5c386a1ad38500fd5ff6af6a45b89f481ce1af7c1b6fefe4f568d1147546f863e98a5e5250430568025ea7d4e9372459c5b52641c775bc98e3fc6e40f92119e4722ab526bc1fda89b2713a092ebd5710592d957e95d488fa1614b4b38485bba8f3fea315210e0bae3b95f19db9c2f1a81dbbbff9ec67e3010e514ca74b45f10445fdf4900f296c380e379988247a2b95dafe5c5706a57330805ff931b7acfc711efcf7ded4854b3432fc87ba28683394eeaaa3d9e0a1afe6703cbe14c791eea22eb7907dca258f6228c6edd160928977ef507506daa10696624d26755e37c233555e4b591264a4c27d005e1b6cf9c7fff7ffaad19f468a8becc753504faaf46abea9c365253f4eca77e585826fdeb8a0006e37eb547d99c04e4cc02b3d840daadb719f888188b30e8db8c25a680836813214fdd61aa46a52b03d384591b7f78072db8e2bc0d860d4aed0b156c316ddd144604e1d42354280a86f66674ec1901a63ac37ef92ecece757f6f32ccdde4c47a8c3ec138d905158a7aa3733cf161a510cfc45f2c07644766d444a29a156744072cd94ec5a7f1a6907ab68f443e8ad21ac45972ea5a9dcaefc30fe555f7e928f2cac331174d5a8e0896f8e2bc5c1487399538fb36725fb0f3e9ab13c1bfaa5ebade5ddca2a88fd9dd72f768d023c27ca154b760744270802d95e09268661ad58dccda1f9a2ba7ae8494739992b82a257b3089d5d29cf85753a1a2f07551f2944963b89ead03b04350fadcab6420068e6b13d61b9ac9936ab57242c591cae44e75974115e801753d1e643d67da152a048f12d0838df85afd45b95826f4628ed83ae2105e4f05f8e91c3f21de259e4d8f187710a382bf0d30372bf1cb28454e2491db70b8fe5fff8b7192915ea2046a37d6a3b43bce845b41afb63fe23278d7496d4b5e7a6241be55136623ec229b5aa9392cfab6d4a3a223375403e4b3b951cc75ad185ed0b43aff77ae383ca5a31d0fee8dbc450cdb90739a8badfe08f8f1a2673c45536a3e75fea3c6e4b0e84efef69f150ae5d001e24f10e142882307d68c89c57bf415a5da0b7b95d529711834ba42d4436e8023e16ccf20e604017409cfbefbea8e81b75af822d9a1ad52b7954f5341ddd14a934ef0f397156ea13daa0c02c29599db322131f33a3bd72f66c00b45511b0fab547e7fc94cdecc93fb73715ccddd761ed6d4c173ccd76dd72bf7bf6a49a3a5f7a03180d1fb09b6e62f77dd48077b62556b07aff97602bc6e668b49e5ff151ad02e921060f0836333a7c49affaeaa21aa0345e7d0fb4dc9004eeb398ed2da44492b431d8f692d9264ec9188790654ce475d8fde2e2417c1ab676c3a423b51437c04c64c3f95885290558cd2b3e02122341ec8f17f197a07df2476cad00ddad7f6f7b70f625a3a3f372f2caa3461b2b009ad0100ddf3f7845f8555acac9289910cb9ec23c5d71d16ed77750f3694dcbaf2fd805b4cd41ec4cb998793db1c04db37f20666e0c40556bee0947ed828a9ebf7850850807ec8ebf4770e0346a8c02bfd56859caac0019b809988c34c961cefa474ec53eff76e93573fc74763dc854113bcc2b87aa5463e44e766c624e6640b823c66cf6bff298fca7d99c90c38ae9138a9469e3d4e7353b2b6b2906cd9d493f8fcdc0ca7ccee2be53ab8ecd7497d1d1827f639903a59efbe07a234fd3ac6066f7c65796a1d171f55edbbda5db1942c549d41f9bd2a639a6474903e7f0ce929e15cf4440b1f8e4226473cc0d6f6be54d045f53612f5c2022b3ff9e4e5627ca24b634b4154402865e7e7eeb1c4b32f82ccad46be19369d2735fac3fe6a3ea27d0b3a99bd8ed624ad0e2bc837a03b4b532c7deb2d0f31b8e1d6d9a5b1a30c3dd016f63a32543ff9224ff732fcfef803c8d2f302a560775dff66d99a37ebc75054b1165d4ba4746a9abf00fc66e44f049a949edd28b04a701b20ab7db8b4ce61864079d38fa04a674b127eb37fa6d950c82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
