<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e010a55e00f7ae445ce2725fdad81f555a593153620d3e0b8a4beecacb253dccabd43ef305daa5ea3cf76226867026e462a75c4b36e5f931927147c23a78343f6f4b7694c88bbd6ae5c2c68024af94b7012148c5f5e1bb882ea5ca8342cf45daaff2339c5ff47e218a2b412d92d42f166ba61cec7a2d8af8f61b4acc78b41cb8dba10fc16909487c47addeb4bb2ea7dd650de43df076d443bf553b8c333553be47e5e7bfb79c5eb5ecfdfcaa9970a71363e7a92cb6ac7e9768e53e3e94c53fbfc73e4c18f25296e74316530428ad6f02a8cd0cc3d019c2b2970ed1423c7d39db864e2697fc32a004aef08db355f1672eba05bf3cc2e74510e209f67dd09e1a15632ebcbe174d07d6db732b07b66ed05c29cfc8bb9e742b53a04e48d78c9b991b27c49d3b25db526779c8e298fa77f2e8c9e97325e603e4bd3fb5fbd45c4a92d500233a9bc42edc8e568f1ba058e896d2378481e8d68f07b121a6e4e73f1444b28ddf8a11d0785fc34444b08baa88c7307c18f7bf4f821dc81f50e1f7237f11d5e80fba657d8c0d84b858415c6e8eec016d7504ea62dd6c26ac420f9b2ab6f94aab7c32afba9695b395085632119c2adaf8b47c22a48ae18ccdf6b77033bef1e18f088b9fcd0578ca5154d6b90fbe609867a9223e38f333fb606a0dd2b9937213e944aebdf7882740ac7006bee90c7369049d6c12a449446140eff588a155367eb3e5c5c04a7fab3ca054f17668ed1d424e80990bf0472dd3fd5efddf2d706440e87956a6964387963db8c0876bad1ad3daaecf60fd55dfc71b13caa62f6a2629d7cbe0b71cfe7bc3752595c952fa6bff224b5af59c41cf785a1f59ceea55c37620a61d17abec9599e7c53a64b579b740bf5d81bc9a38e4fd14f654d98ee892ef4cb09f5f4a16bf39a664ade1e9489a3d94a34f751980944ea556e14e9a5ec008a201407408585ceca4990109aca7e9decff89a03d9373ebbeeee5e1df0db4c299c32c97efe0674556dab9700af0b7b45f93e55c095a3cbb86a19857fab75fe5a9c33e2d626bf72538983470aea676943c6ac4d7c295ace3a39ee5da2fda04c83c581491fea3b04dabee05f13d196d446d493d3376f741d6193dc7abcf87873e28f8b9666ce173ac162615cecb4fb6f34e21d851675aec53a8a6c7f52b4048b22c51686d5d268f93b0eb6c491018b1a3372c1b20d402a899a52a6b8cb1733ed073b502e903a120c2810127d069c41b7aa681fd863f4f22becf2d3b5e989e893e0e3d53f9af6862fae20a435816ebe0ce53c0e6a124a60634eb1ce7c4869a75d889c3f30268c9e12e97bb05b4e99b26d4a64b3c2c533c32cef33f6e0456cb408effc494cc243f3d8bf28f7c8108ab03faeae97fcd21052339dfd685325a49daeebea7daba83d82d5b70fc4dc8945a8d06442fdf2c577f3fbc0fa345a909f19114ee978063137f5ac3675faa9d59a3dab7b0a53ae860a96a589f8f5b1ad29a976d5e3eceb0243f8c06a37dcf580669889223647f1dd03cfe37be05cd0d3e317126d826eefd4bad537449211cf09c77edc7d4e6bb4242e425a2cf9ae3f10089b69efd928e5bbbc23c519a5fc4541b33fc43836cc9b25efb8478e162bf388f519db154d8488477de3fb2ce6933f075cf36072e4d33c181657ee2c0399943dc18d927deb9e4a254450ea123525624ff07eb3953595d654eb6936b5ec7658cd341200087bbadc2070eb429adb2289e2faa2c31fd5d6785bd390df01bae2d23de2fee3629581415d39d450410cecae4f3ee7a1804603a66b6753420b0b9e267e94d9299c061b53820af54fc4bd5483f4de4fc2747bb470d23b61adab2499a9bcd6689c66e2a6da65ef8df951222a853eddc4cc7d81b6145c05ce3a0c72a2a539291d0944abb58fa986dcc1f1622fa0d4f9df6d89703053e8902e932f971f8bf8b41cb10de670cdc1358d8ca55f4d6c8c5a782f52aed2a67678c2fb260784954d29021c570acf6a2c3e28e178d9ff9cf85c338f308768f6f5637c2fd69106a8f644d3099b61baff254259f15c84d949e9fc055bd3f55cf52ffd8fcf7088186af89872d39ecb9786d48400f9fff24b30f35116dac5569c3f2ea551f23e9168380fba0134801376ab0fcf04116e135bf7667755440a122472bea65ac5d88c29a7a1c2472d550f1b46062e8633bdb0f60da4fcdaa141bb5d3126cdaed6fbf34567f267a14efba71819de3a5b5d9dff62419d9df1bd1ada9bc21b55832322b289ca1b21a9ea7987a502e127542b652d98bfa735e97fb2004c5e425851d8953f23c2aa46409b888ffa4084ecba5b1ddf2d42a9430137c61204e53b8360f5e013aab24314948d333d53ee7d5b85559778e77d60b792f9471a57276ec275e46e927f48a2a4a5e22b95b70ba9eba4183a4ab76cc6fec423a3ed14c2bb635439b060a1a2d5d9f8b97859f68ae7bfd507c05e6e9a2ba749485185b953db70da3d70ceda99ae34d1db486de9df788e00991178238777509d19aea8bce904e2066377d8fc4404d545d88ee6b420e091f89f1e2728f35c46aa187a26f65a35db5237c2fe6c6cc8cd3da2d27b503f25695eeb244d6c5d7b73daa8fe709d67f38e239afd86078e06b1be5f518216f6845322825c5fed044214bbea73b2f433e94914dac777361f2149e53b4b20ba6c0b68c42804b7f19d34de27f9c84777ef4a573e4ff5bc1c7a21761e49aa7acde2b9e7844f3b1f8a062cfcda17f44ad6ff48895d39a726ce5f7b996c69b9722dae2281cbc129c7d397a553cb8e907c6927b132513ace31d16be1e6f9cd3a0e798df1f39994da4c8118f8ca74d62831b6379a3413df0ea0cbda4a9bca9b9674ff86d5459948d3f6d9b11228c0b0b2872d5454bb43b5124dbe3bc93ddc3f352176576394e657877c1ef5c3f532eacb1aacab5ca2577cbd67cd5cf94524410f6d81792bf312df15b31e4d4bca2402e33823b1c90797de8de8495d018350dd584819801abe96e7eaa788c01bf63b5a09122a1c0ddb3b6506efa767570a09895b13c2fe323891d4794bfd1e25da5c09bcd26d5c538fed445a6e799eb4c5b2514c81df0381dafea87e954713cdbfd39a23b471abc6f649cad853562cbf142d177fea33e469111b7a9f2c8001c78dd58539fc6acb1fa8c10c05353fde723025608bf69d50e7a67d8074a5beab83f7fc50fd3b93d169cf31e20dd7c440a366f4921685d9d2299469aa03ee15f956fd77aa7efca5cce7450e46ef3452c2299908b7bdf05f1e616bfcb942272a0b230ce30db20cdadd94d54e94d9f1a08c7f654bf8fd1b884927f2de8c7755569e85430a2b1eada2f90da319673dc75f47a7ad053c88e0a3c362331051714bba30a178c033b4cea47928354bb8219658ef9529812ebf2031959e78cbfee6a6394d89366994a8eceb9929f451cdc8af0c66657d774081c7824341ee0d8d6ca0dff063653c9ff75a1692da979f4a89502f63281d63690445a1c55ebbd68deef976d2d58d0eb003f4a309816c30466e2a8860689980241401941b4933dcec9c2b97b739b05b321a1ee2312bce839f3671d010ca52ffe7abf641b0acc958c670d8516ff3e9854ff40f20cc6e7403455a545f2109935edc16726e1c63c0f038b1fbb42196da16be9398031f83c0762fd3ddcaeb1b20ba8118d5ba9a9f18fc2b8e2f3132ee017c6e658dd737885783db262c7292ee39c8a90b755ff386a6aed6ebfb35406b70028fcc68456e6ed28b4b34c9ca2e817da1e755570c415a2bb5b220f59f19fce3decf356a6387e06a26198fd60ad20bb365c89effac38d034ed3fae1feebf6e9179b1df291c16a4d36744a984aaeb686b8a48d9e03863a68989dcc8b9b24bad5ab72a5d39b2b4a54535fd553de71135b354931501558fd3e969efecff99a30f974ebab4f2223bf92bbfe6ebe1697b6bc7ab40f7b5d5e9f0e1479419df8de178b95d19c662b3881f9844165567d02cfb133f7a0cf501e8dd5f4e5e1b6287df187183ce817ee45d4101f1895d472c4c626d3d0d390ac3b8be65134fc40f9f04d76b95031028c651183b1b642a9f985e893a93f1aaec8ed20f2cae1c1b144466a36678190bf7d92bf95cddbccf296250fa240bc0eaceed3feb5d1493bcbc4d7d32ab454c147d09b18102a6549d19c2071c99a355e00181679fc959731123e53f8b1b7fd301ca0d27eb1d3aabae16526b47cf94c6338d91a6fd8e65e72db17e57a91f3c153bb3a6bdb3addeb466d18cb07f04dfaa74af4dcd944ed7c522dc25493ec0bb620d53ec164b7e9a61a3f78490b68fb61791601bbd3ff3df2fc53c6444f69af5d7ed6c2b0ba1b2283dacbd735845ea8b03c80eb829e9dd9c8a686b0c3bb6e8a7f47f4c9b6476e608373a1f0eeeb801d57e88582b34a78cc9eeef4ba256ae2a8e154ecbdc73fe376dcb8c661c4a219d9c10e02761b535c4130a497e5b2cb5d654717bf39aed108944fb7930490559d92818d9199b2c55b5fc483abb936b3c91173ca841d967dd75a051d0e0fb2a44878493d7e973492ac5945e8afe60031e46d998137a17b0b95413c5d28a49b0219244522db3449dcd1bfdce34030f219fe6b4a78a462dbee6b891d4b2e9c94e79ec8d893db5e2a2d2651101b614219ea4028ba086be3b844b067720bc0d478045721fbc0f1e2fcca5419de82c16d17e38aeca62cdb6aefac5d983fd732dc1b2a86a3052523416a3d8af9314c656e05efbe93c38cc5877fc8fbaffc76b368e1847089777a958a84c0d830abe527824e8900c3259c537ee8bc8105531854d8095c9e0853d95b78de726a99e7c54a94b00e3d0428cb7e2a33b525a1d1f7fdfef93d03617d8f8057862a53ff58a9d6dfe0e5af98baa7a808ca0787e1dc710392fd4ed62bf5dbe9a2a1d99e683b0911b75f967602f737b01ae1df4427bb521d8696997ce9d13c0748ad33ddc5d9452075cd83f6f384d35475a2bfa0bfba217508a08ff5331918cf59afd2cc244d4f3098f332e36d7d0afe05a01b80c215efadf5068f20e3cb1fca5c28415eca0a7334fc36b521c415b556e57ba78f53f4feab29fc39d89adb220c50c80f7bb50a913992398261b293509ccc368b4bd1145b4a3a4da821fa3984089ac4177cc89c1db678a190ea85e521e6f61561598844f395d7ddb3c3a7dafa18b3858188d3a708db0de7e865359901ebc4c20a0f87844685ecc7e51c17b2520820aa18c172bb355560b3734d090d32a6764c5c1d240a6d4cfce79d13281e84d2f87b73b2c2a34d372829dd331bf645f2015dfe0d7fd79246a8ef348d3518e33e08bbe98d2bc622b5332e26235325fef805efc3d86a25917aa510a2277169749ec751e9db317516f9aefff1939fe13d97a08b9c27ac9547c03ef0d4596bef4ec64273d80832b00ccf67825628756196455a3ad0113a010cfc65402ca3e63b965496a3f9e792bd9c82df64fee9b7d4a12841534fb43885db67cbfdd0b135001cf09fac850788083190e7465d7541c94dc1d0c51394214b595b90ea6b65c378bd966539bccf870eccf479aecda35f518ae1091e21b1804530fef55bc9a0df0989859c4ce2af8a501a2fb92e11e2f2f44296c8fd358fa5723c95ca3bfc19ed3ef7c3d402892ac6857da7686e6f9ea45f7502da898fc0a3ec7c95de33c77ffc30db3e1e5c546ab324647000fbfe599ca990b1ff6c41b786a6331b142f8f0f083e21255cf3703fb4619be8c7a45981fdfff04f5942aa7fad5349c9f563e09ff5788e65574bf47dbf12c9e11e5bbe275c48d04ea23d3363678edc4753cf929724bce839e0fbbe09f7a303dfec54953547a2426a7d7dd2585e9653b76d179474fd5ba8a2df61285c7a75991c258ea9cd02a5b6bac55a072bfe6819825b334c9d55f01cbf605f540f5269109868bfb5d49e5b9c0cf042778f8460f309e618546440c1febfd70f19c1d7921beeb54927aa566bc03d0431312111d187fe16753068c2cb7cf6329ca218cd595dad836defcb20810077e9044edf969d580864888c4cefbad2f3d8db2ff511f907cb44f41d32854ba82b125baddcd130331a14be94f979a5459fe2aa9b1323c37ce81319d7bb4af91224a9c679d8ae222ead17274d0a5471d23299b5c96eaac96f254269336913476650749736212494191ac74180c1eb37d39988c6e0517955695880aa078b75f1ad4075697a8d240d4d7c955889ab7facfa1c815692d043d3c9ce4fbf60d6d12c298a29f1aa429dc9c796b8ed833e475c84d8b732a12678d2ed946c62677f51d8fbfc78b1e893251577c55c60d3fba6a6728e88e09be4d69375f7798ce8f54c5d86d7a65f78246afd3eb9f48bcff07acc0366be0457b8ef6e67f380d87c59e0a7cfc3079b939702ca3978a96b162fb7f378520cc59f4dd87912c0a1e9b8f616d846a9309c247b258b7cc213481c6a276c07063e6b341c85266281e8d47ea38ff777db3c94898496d1e106569f5812211f403e16fec34f60e638d4fc33995709efb5ec39f26d4d4cb088bf1327d00564311645536b7beb739ea55d7625c8e061249de3e952c7b7ce977fcc6ca9f74a9848f0d8515604dfdcf0632b18a8910ae269a43351f7ddb389c6b008e73e94567a20fa89735786900cacdf690985e167926b4ec6541b3e86448d890632273db20394519ca8c3c28144ec28d58f36e78de94e5b68b4be10c09d3bb857c61ee4eae9822a867d9bdd663e50ac49e4de929956322d48681751493a026a2943be0d2dcf5a9caae5401739c81822aa023a705fbe051ad4e9901f2298de4a1f8e43a447ddeca1ba31164bdd9b4728f1373f900462a357a9f6d6b005a0b62fb690a2c1f9f3ae8cdcff6b9185cf91f7779725780b29228bb0706a733b6eb89d8ba555323801c21d5c27a97081ccfea713cee839d1893f32b5dd0f1002d3e5940442f19a993053fbd62ee5811565610d54710f494e5facb795983605dfd3c6aa4b2f9e4787d307c956b8f42153874c502904a7ab5d7691fce2153c01821b4eec035cca4d5234487605b055bdc22367bce57832802c8af931492335d83b7e449b109401b2896adf34c86144697f294ea3445bd2ddccab85f2dba3b852feba33e5351bccd536a6f143d43ce4b70ea6f62e33c062b19cc3e9668a4dff97857d0937f8c4f164ff75186bfdc8e1d092eaf30dfbfd923bcfe53bccc7a71f6ff04b2c72d0b3b881bdc5404a5604a0bc9c5ce5a452824a719303c4233b6e28702e89348b80e7cd6098fe04199694d0346231506eb57a52da403ee75f2272d9508fc253fe1edb69eb4d1dd645614274b49e5b5d0fda0df57dd38b3d8d484f22fd9b05b4cdbc6cd12c5c9f1cb3b64b304ae0993e455cfea349ac3a299ee438d9a8d4f9b2a58709a9a8ccee257608d379b6efc7e7671fe7d43a49db32b6f19841c473bca13ee60b1572a34c2cdd19fd05b037f57d1958c163789d506c92d2548c41496592ebca6c8b6c397bffcddc4ea910328a9909727b4c3d86b76ba95a0578bd6d721703520fe63b0cbfda8f2907f3745b3072859ade1b73a1eef67273c4852540e33f4962a793382426cc0a7b8554d5357d7ffa6ed90b08c5ca156df6ec9450e670e7c3e6324a5575b4ef01ea1f850192fc8674482190a288f4badddfbeab1e09131b3a44c13ce50932e24af0c41581d48d57751155844ae1ba5d0d3ccdd42666b1291f4811bd29b2430b8d2eeec59ce7bda3234c62efa15cdb52bc95010c455cebcf1405c55b772e4082d3f85cc93e0d33a72a68a9d6d3114a61f6a2c71111d69f02c25ae54a298b2c584abed43cbac8dcdcf713943cc2ed0dc143ffe23551ffc8251451806cb7a23279cc002f8ad892f049876cf7e98a4dc663e90d68c8e5a21673914133704a94b82e5a2b31fa3ee99db792124cc987bc3d29469a20acf1abf5e51a068c357a4f93e9e86a392cd6ef4c243b5f233b27d4a4649f3bc1f8f984f5e6811d007225da506da254d4e3611bd9bf4108cc568f82f377069d76879cc3773f7398012f0cdf97a8080af43d7f663da22d21899b3ca61f6014c4ca047d64041005a23833a0fe3c3b507fd9978cf0cf15e02690bc2c54cbebd82f909f140eea35b02ce5488d51ae30b002a182ac87f490b8de54836df5bad912fa7245f06642ae65e49faf13cb777c3500dde6272a3cd5714d4b9d83864a6bd2fc0c5fd57552adba35984cc255bcdf818ed06683289aef70f0e6fae0b56ec3661c1a34fd9a26ec5c0b252f2510ffd5ffaf5041f51ee8a52c81c5d1e5b5f77c18afcf57811bd8fcb7370b5faecef24a39b3a3e1bdbc1f2549e1e7b89ab2fa66bc710b5626cbdde6a12ea23a05e80bd776dc0eaff2f0891792806135e8ae39201d276b4623df7bc4c846f1a5aabd5010240ab28a7332c7f621fa928391dc9cca30a5a1c650789fd0549e578eac0a24544821a6f153604e1cd1ae767a2f13c1f6e811f1a04f68c73cb1e3ff9ca31030cf3f8240e1a4d3e6490e54ecfc67bec606d02e040e085d97ac604189eac37e5735ee021ca325234ed1bf627b6ad1d33f269273945b1bc8f5139e833f28c6c9681cdb3e0d84d8b88482ae4024b6a72447c4ca31a34b0c57e50001c8e8acfd148694f3019d7556c69b5c8c7e58afc0536081d17c6d6bb5ba37d0a05351efebf2e14058ad50e97e5d9d37a6d58c9ca9f5f86497efd9026b469f0f0f05d7927ff8e1d5a6abcd8ef36458340dffed59628768104073b13372e91aa0e39ed0fec0ea3b10016464f3cf664dec158fa5ee1c4090a465802b675d5c3bbb792dc52a68d3ff5d92c66cf2a7c24bde174d2e07c62350c11aaa987dd987f33afed68484ff505c6fa498aa9e8f6baeb4d4cb04d04708be38c35bd5a80df091b75ae2877fa57c12209050424ee5b6bd2245187d30d2a03cd01bd673f3f97f797bfc3f72d47356b652bd1c7f329af466970db10342f80580ea2059e86c62676736fcdd293906fabe2c3ef35d4a64adabd786c1ff681ab986a37a2aafba3f18655b8697e33d7cec17217d5edc2f739101064dbb739617def7a4ea34cf92181836279a1e4e165e6074be229f7fec939a145fb5f62f6ba289aa08b0355646dcbf6798b5d220e04272d1fba56d1f2e8397628239d44ac6a5dc786bc100db9ccd56e82ed7522be5ab4588c002fa2802f78be9572433380fa3e0b373cc6c8dc6c1849cd6795d6a29535621d66b9f82a4d03e939d6ceefd21f8b0f8c2dbb6c0bbca0f6f6b5ecaa7dacf7785263c5999fdbf7bf5f6afef97e5e3b172f1a64fe6a34856fe350b8d1487b30527b6f5560051c189506dab89b5847fcd71acd43d4b87fe2effd92350d3bab13bdf4800a867e5248eddc45cfbd564ca53039d48ebefe514c67a4d2f1d58d484da4d18c77a11f6da4e3a61bb808339b24af0cb29b1543b9db2a9359e69776bf16c9b33f633c4294f14b05376ba139534794cbdb65e8cea919c7fde9015b35a233573f25370d778089d49570c3660c8f2cdfd3fe39c008538d9c96ec700be6b43f9fff616629a6a002be99f56fab3fce6529d53dfc046d0913fdffc5db6d0d9a06144fe8f25dcf7b4d66bf359776875676bad139e2d872b53dbee1cd749f4774e8574eac484f107b24b333b7e96b506a32f4568951f785ffcec05ea4b473faf8f86d836baa7ce322974a42cc6bb7f190418e98062667ce13139588ad2ce1f27facc8a7d9cbb98ba93b66d4692276837f3ecea9639b2cd1779414c9b6974ba7612db711fc7bb2fe718c35fc940e441f5ed06eb7ce53764313c8feee8848c3b088c60823a72106b253c2606751a0e40c3b922404d460a7c0490536fed21d253b20b466a942fd2eda665af5b21d32dc8cc60b91b7420e4c127c2e89ff7e61b5b70ea24df1a9940ce7a56b037d82a75f5d83fb7f51de989d0c9a3c223e52ebd4fd245a14a29bb1d1203db1418081393bbe6a860fbc954f4f4146ff965b1e05c7b4270eb26a2a3d9eaff55c19e5743bde95d29866806fa122729307c13092952c6d598f6ac8931413dfa07d68752413cba80be7e335d36e4a12bd7edc73583ab0045d7d76ecb0a74dcbcd15636d0b765e4425e9fc9ce3bd30d0ed0cff175c60905e60f92f8097c954929be39dffddefb52cb03347648bebd79be15c77f8f5ef817259f7f808a4a2b7665e1887a12bae548b17fa62233d8c20705bc8e17fac9480d226d377e31b7521e0a6b9f1c12596cf36aff9f8d95cf8b284855e9cf5a9adf88a9b378e625d1dca41a6e4adbd42883883efdb4cc24e91f8b3a09e906e55bccfe7d573840e754e6c30981396a490aeb07fe8bf4b33c718f6084cea6374b8c9ab5f61d53168e02f82ec256259ceb252e2dc6e35914331f889cd0fb27697d1058e83348c0579b9a045e2c295cdc92ce8af972b686cde84bd49a6ef44d5c379d4646edaadd936856289ea820fe21ae11236e2e4663a3b50bb74cfdb8eddd113638aca1547191de09b61f6fab701406f06aac6835c08eefb44abb01c7ed56cb2d5825d75d957445ea6947de60724beb0f818962426cad093a26ad9d32ebd955d65c8f39dccc9757bc277a2772fa22ed2841b7f1f51c4b4d01ec543f8ba9d7c6e2ffd9b9d3efdbdd2d53943ab6cb7e21d1f7215ebe73344641fc8f8b6043faaa14c0301d343126b36df2e230747b608d69a4d475a8878dcc2c61e32b31fabd3482d68e94ff23c0e78fb96a28de01a5a728fcc762e36422a47221f093d67e2c817c25ebc196baca860bb16f97efec181b50b2c359557ec0b3ce8ae4da4316320730ee3545c7d65a67f8ba1231a362a6f04fd930ed9dfa2f229a35257b0bc1989f1a474e2fd26ac8bc19ca084abbbeecaf582071e698cb360880b5d326f71f2a118f406ab749e30af73f5fe9500d31f437ad02c95ee3e24ec23a48cf2148eccc4a6dc1ac810f82cde1da0b3d2e02570f9013f586ab07e2bb79b3cac64d067a4b799fa231f2e53f427603253a406c87c2896e47c5259b616c1ac31b3ce4cfbf30ceba8b6b787425947b638a58f124d4daa46b20efa882d676270aeae05358346dd80bfa167cbe0ed915c4e7211f502d44345329cd86ae3d1e0132c1ed9b30c8e69c3a3eb30424997349476b1da11a93bb3684b2a7b2ebd66375de345f757199e154d3836f0d136c50314d026be7816701ca1581bddf196a0dea28c7e589d2d97bef70be47665d376a5453d3f9b995622a11f8537446f60735f9c4de8fcca7400fe59ddbe6a12cfbb62bf1d82c116e89cb123b5163f095d859b831787f6da58809a335f9aa592d43773baf81d700acc71ecff01b621a5432223b89b8831785deb10540b415823ace5953a9e31a01762e0b2d4bf22c2c8c66f3d8567e014035005debe6c66de81f39071df545474dd797c8d72c3e76e70cff71b4439afbb4e2594d32e759d09c6db7880f3fb744f5c71270d889446ccff56255235c008f6f0323d7317835e221ed9e620823a7010d03fe1f6c3ec10f9c56843d99425fd9053135cb08017a44944339b6e2ac8d9a192a6e15bb144871a9fee1ab2011f9193899515e7323e43e40b7501d31bb52b3b941776d62aeeae3b9c67c0c9771505bbf51dca0b291aae125ccacea259e49d92427535ea0b4d04aa6cf08509c90a7403029acf3bdeef09961ad74f56b8b7f6e3a529788f648e078cd4cf5a4afddd3a5bedb9fec9b50824d7e18ae7b14b6cd3a12a346fb0e3ceb0332e4e5d503817f10bf64b121395f21e164962126b1b8d00fc356309559e805858b8496f4795b0f0af14de52c3d00c0907f647de03d6fad398fa91fab9a68b644a91922350d6cb861ad2430fa62a2cf8acbc9a3a7883b9490cdb7bcbcb78b25e2e99b703d5f767b4dc2ebc01f9ff28877b72ee96d59fa96c525ecfec359151c200ed0ab63c3082be2ce40cf295109cd23774725bcd0e1935e0ea6d9e0a9a9171df304f99440581738df0b72c0c555d88ea481bc93d05b3614b96e7898c2d6471a3d37484b38bcb3357e1def3e912907db1c20dd5c897013f8fd7c871d8ee9f7c634ffb452f252507767aa83f5dd40d469cbb8779597521d9a5d0a22eb2af0d6ff82d27c2978cc5429db61ce09b60d003b50a54e895dc7d2703d6d87d4e17dda40c931c603441a2c691e56542e2a4e8aa13eaab20ca10f75ea5b3200d9cea6d25aca13133c8dfc7f42c67605cf31f72ba6fc226b61ff1e8ae398de2882446b06411200e422ea729f533c7850cf64e0be239858957969da4ae9a2cc049c6d87587c704475ace8e214e63d7723ba9228e0df8022c9a3c5c6868f765e68c3d5f90b333c95fb3ef460792a1488b19627318e741fad84deec3e980a23c31aff9da278e7a04b00e6fa69b225c88aa7771c0e3225989948da7316b600159547fde80c6996554ed58a504d7c11b9ad7dddd40b7a57ce65803e6be6b697ba94022f57b4b939231032c5817f1c567d1bfeab770590941176a6e5e6386ad3c1cf0468093ea561cd988b0d9ef9de024c94bc7528d32284e8036b2ddf7c8ff4332a7fa91d467d468ffc183ad172406040a2af8725e3f6a14b11078caba904b85d61a3efb8e78ceb55a2df18dc04788104b9b97ff13c79d9ba3e76dae4a3b884d8fc2a3acf185cdacbc0eb026885480bfabcdfc0a659bea2e934d18995c40e281696dcce64e66b2794cf90cf0b48351027c3ec81ad24ab357f9e6fa093cacc9e9fb8225ded7abd98efb0c1b70d2445af5fe5f782198356d62f88ed146429d16e9f3d59f792a13898656c16fdeb36bb732593eea3e26bf3b19f1be60eaab3b9648cd3cb3278145f5554f65d3c2c9817376d830f2aae32121379ac679f41537634f2e5ed3e169d4a35d084e4f940c5544274fe55268c4fcba831985229f9157e760a0ac81540eb173a07686dfe1044bdea96458f76e75c3a81c90f3ea26bef9974f0e3d4051a0f40f8db37d9291c37e67a652392c3b749ccde0ea3ecf0a10db1b699e30ef18a0849e29eec9bd7c41d60670c4cce9cb56fad468a07c6ceb51f479600b42f262ed6675579d61ffb2f976f85d2e7508692715c06886f914ed8024f4367c9fc91a9e26eeec8dbecab6f79e8516c59ea64a63f07fb692d433da0403ce198558ef1057ade7a996b7ef0e03a850f6be47bfc94f31beb5869d2161f472e9b8a2daba59cb8f0e3de54b7db7d512fc23ce0250278dda724f336b9373c9450681080c67c678fbccd756f23d1d7870cc095b7c1dd108f20ea9274daec79e4a564e67bfe660351a1bd97dfbf8fc660bf231e8d6abf7a53720508aaaafc4217b6f0fa344b4fdb603b244f77e52bd5c542d5a031b76f8975e6057ef27085d9f20e43aff66bd055fbe295ad3dc6b81cea715d548c0d3ee9d53b5547f354a57be482432d822a3c7556bff52f477c8bcdd4250b32b211e07122ae08644c0b0ac40e176392e47eae3219c7d6c7f7b4881b47eb9486e2b0aad2f4c2322fc43d4eb6564ccfa5782d3c138c1f70c109981b4a77508109eebd8d257913f6c552de1243abce63b8e453564a201af1f4f5c94f8a367d57e0b9a8d52a80b8c4260ac2d0afd469164e101652b207774b033325db850d9431f6fdfa7abafe29fec961ef1d7c33ac29b8b7592cbc0fdaeab384ca4b4398f160043f9150aad5c4a1485d5e55d8b73601e5d74d4c2a4fbe47de1f58e7950f1e87595d4e23d706e92c6cd55c2f1ad93d5d9c797ce5078c4e9cc8ff0394136544707f1600ba3d9d0986d0bf05e45714d87c70cc3620b47b7a12526e03f75c20c8fef751d729af8e4de6db2d453aba2e78d741cbc172a53aff7bfc1c079540503a2be2fbd7aba9c01a7ae11006d641aa9a5bd0aa280f956bed26ab6e1d40932194d536d7308fd7645e5b3b66fa7692e164520288d11602c9bbcc5b9000bb2c92d79556d16f64e52b73b02dee3be1c2cbf78fd2cf14d332da7792b03eaf65d687fe35020d7ef1d25310fbfb31a581fc9ebc38f21bafc5b9494bb2df95af914a5d82468f55b63eb2cb0fe768563975bdfd902a6a1c93dfa07dbdc92c2bcf5f58a6756899959a98d94095a0ca4598a072a6efc028450019539cc54866882b2077109d75049b7e77b4ac1ff27295f1a6f3520e2428475a064a0e7d02d6bc682fde11ece173bd905bcc535b867f792bf285ea7289890ebfd98aee1c42ad2cb0ee910894f750fe751a344dda31286a521f900208891dfc95ef65eb2a3fc90b2e2570a409e7f60185180c36df4b8ab1d8a16b6dd0ebd6578fc08d67da2b2f1d75bc8d9e6e486efee51a0653e9a743984c261bbd8f863fd1f22f65cf04e86dd75be2b913d8efe4393d555a25cbdad8f90150d056526ac7f5f1d78313d7cbb567d5e081a498ed7fd6e5365504277682678e930c049b71db56259d79b58d5857f39a2c4dc840eb981b82697029e2a43d7a769650195672766e0adca0e8e223a99e9c3c6246ee499a60d15536f1ae978fb45786896c466a9430f3acd13515e30198af584766e99a4da9f15782353435ad58b8bc081d7bec7fb2e08af36cded396b765c76ba6df0ff60b12a76578b0510d843661e264849dcf7ad98999ca535ba13141233c2adf92399389435dd426461410ef4b8c48aea7858459408e67cb042df1eaca0865659e6d499a9cbd40333c7060283bdfbff55d6172d8a478c01741b7291d634989413ccc14f12ab5eb6def9fe6525da03cbffd6d86150856d44c2c4aa497e9c7befe28ac6503975a502847669d23d5b2154151740790de4e7352afc9caa63ad1b51600285134b38483c7e8c5ef22b169593d7348763f9511eae85d4a542fc92b3d03710c8d8c2b93b58880288996c7c37ce28d06b34abea0d0d786ca36581105f5a7237d54c31c6b01d195850c0ce980dd551a74334d1f97c8c2af6534a0512114c4a1b6041ef66ce19be8565bb9c40a7389621a6f356b1dfc2fbd239c2d4376a12342b8d49e5fb3f4c144b11062077367bdda6eb7367aca95abf9a52a3d5a628f832329dd67463916e0029ec806d4319082bdf008c11ecb3db130ad3c67f477a93c3d45ff68939fdc28f22b1e1fb9d51403b48292001188d3b84e5925a4c626b3c0ff05809a27b44bc2ed2fb965a92c5cbd1d2782553755d8d0ac1cea362d5f81fe0fb8f7f23c41c4d23fbada14a39dec6b9973b019e051709d27fd865ef70f4ebeb830a14dd539acc6dfaa41da07e77bd236f140d448f7f72b9914d11d9694f9593c1fb444cea19eb0654b774fdeb15f1c4d70411450ded33b479567bb3cb1e272e4f88e78941011a9bb36d0df0641f4f7f2b51819e232b1008de38b926f9b4c133e55b3cb82c496e140f45958ed51dda5bbd5dc908d84d76e5e37f7d706759f50cff986b8a54c0c1ae9feaaaf837a9ee7e202c99839d8c1b7b82f43d1dfeb3b92e5285309aa4c1d4ff3852c2586e1ae1ec6f05e5f0a806b9fd0521474363074923c36203737f1ef31b416ce12f54e9d6ca2eaa72206f4bbb7515a5e45821f45fce89b080fc40429a69218e14cfe8c4d1694c6a9704d86bd4c8182f5533dced1142b8842f4696832a03c9662c691a48c6b1b66f4c46a077b55c0f13b652446e3b72e33e13e13bae65267f9804d3a64843b2cfdd4a9c88c282fa9a28c78b795d047af0422dbf4d40ca792c5e23244e9e326c4cb6ed241a475b330100caebf5113c7100c07787dd189dea2896006b6ab993c1792e03d63551c01e4427db3ee3442006742d0f7fa21aabb66f4e7ff618fba482941a6b200c4966c770a06a9793078b679b02e558233084daf0e15bf425a848708bf3f1bb331988c20ce9c5462c6b2d4a36c8ec4a597a092eae99e9d369037fe2d81e13f15c8df8a454efc2006b8339e5cd6544cd130472905cc752d4fd038f6a3606ed74df19eb74cb3f15d219f37ff81d36ea7ac1184faee4b537e015e428598204ce4cb5641634b31e2fdbe29f86716fa310a9443082bbdfe3be50661beadabe2edec637122a2835d57e145690b113ae3f9a964424cde3de117bf97701f570b7f80688e9c7a1a5802106978a71c24ade99559a42b7daddcd6e38c9953a2a21a03a14069605ede7c9573633ebd56a1861702b8091f49d6683dd1d0ff3da823d0fe0ac1fda952c9c8e61ff0dc2145d14615081dc320d1c5ebad7c5786b32a9481a437ba940095f5de108ac8e4a432b68a9a469f69bc633fd8ec1558c2c6449404b3790b549fc8f3094b00901bbdd52a127353ccf9b9446d9abc59d9294595c869f961f43b74adc1f51066837b9e5b299abcbaaef94f02b4902736c64a20319ede22d7dc6c29e9fd47eaa11453e41f97659c3bff187ceb02a5fe7d27f5a7fdf2f181988302002b9ea63e8fd6f3ffd9508126f6309f6770be3de0821796e5f7d7f59fcee224b63a89976cbce22d38d2157822a354ef3f4644b2fdafee2f663fafd0159cae2b452024d911225ad13cdddd862582ffa9000ad3687058bc5b2905293257c09b9e50d7e14fe68426ae80cf6a90b5441046242e37495543eca8fd0d25a1be74a58aa6b51d6c96615e3989e4d89d4c697f480cbf3434737becf57d1b506bfce935a2d209159b1fe173053b69087ce76be32267551d1a966616f7134d539b357b8e261f0bf01bc40e551e13a161959f18f9b642f40283d1d5450de357abb06f3a04e74fddb68a2a974f048330e072e1d0c04d597963e10a683ff595faa4e867b858f3d523e34d1813cc3ac4a7a89475db5fe986cc91d8e1c4d0578bbbb3de3bd0f284e41d67b188221cdd6a33504cd854c93c3b1e3b4981da616be999b7d7dfd2d5443269470fe2fa061672a06bc9c9a82b1518f108e888850769608d66f4291f6a147f2f85e030950d40d178ececd7075a9168b3fe6fcc654ccf2f7a99a3d07cf44f746d30ef3ad2724361b6b8d196d0a2de0a99b173c928cacbc79b01655803a54cb352fea34441f7209778660519734c7dc486e826beda1d9e643fd04d87e9057f972cff3198b1a4258a0db88f95cceaa88b705f683d189e8da1c4f6de6f66641539fd4e4a9f0c0b8b45e63456363ab835b26df8da4bcb08640c6877462a6215f7e5eb163ffdbc9947c0d5b56ff0c7cceff0a7d1966363e8767e8e7ef0c57e6b0cedef0f1239fc5ebf882dd5301e3537562e5210080d35e52f8afbb72ca3de949fa47afbfe9cded2e9d8832844da65594b29d49dcb30fa02be1dc1a9374edfa3a5d8cafb5277c98baa22552cd8bd066a4115e4e9218c9e6aecc2d6d27b57e1a2b89c4995f5bf6f84bd697959cb452ea4860462a740eea74c627fa25012ef20d9d2856a8cdcf171eb75fca314f79dcbc02595e58e104913ae9a67f831c52df8ab9b065ef086725fb61d01f52d96650154ee0046d435fdaf9c3a132511f9f5ca3c2a31179d89adf2f455a7830c6341e88beeb811fa2daac32ce53d95004803931438deac6769b78693a577524249beb8cb46a75a86fcc409b9e9981c8fce949f3e581d96725ed0870db5a853293227ea5f2da353c867863f356d0dc593c9f348944a3cd4995a6b19faddf909b6168e44cea18d2dc9276cc293022a0d6ac4deff197a843d64d4cbce1dc780399c431efc1575273756e9f87b9f09069c40aa238dfc59583d40f86da13ca95a71a05a68c4b05e170a069d68158efc3b2867ca9fb97bd7d3eba82cf105cd016f91851fa0aa773650d5182f31e152112f3e4471096fb279d4ab4cfa3db5971e6a9c1abaa486af7f88c0c7be785467fa63cdd3c979d23b96d9ba130d7e3e3db0f36c9e7e0f62fdaea207fafe037a5c849d32b3a9a7636959e9b6641f4ff0296c4ef38c90ae3c84416971310b2981906a6beb5520e18f603e4c952e9588a7731418793b6f2ff6697903b18488866da125b2b82301a725dfa08ef868719b81ba564201cda94f52bcfd752c38a93d59dbca2f1bf500b8cfe7b8de480e593c48c6f7ee99b562f65b7b4e0af302a56bc9f2b2dd3a41c8814a8b372a9c62939353b0be772c1acbd443cf2ed9033e6208a2596484826c4bc2924d8b5dc7a25a16795046e70f4b0f89092e72ae31b7b5bced09253d9c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
