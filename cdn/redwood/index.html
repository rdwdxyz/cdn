<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd1dff1ebf39f1c865a1dc89f594556aecadc184e25277e7eae3a88bde1b60534795ec98aadfa1a418ba8e346c1172b2305c6f1706584bc04362d6a7063fd0e365256604238548b853205159fc595c7c7cb8d34372aad7f24b60aebc1f049724eb098a8f6f5cca1676639ee54978bd6693c194279d668a7218a787f24abf1b0d8efc9626b4bd9fa9c464e6b3642fe98b258c36a57cc289ae022b072b19b077578205c7f276271383bd173216230660faed5c51b2e219b67659b8ea39e60a4840ade4f0142f0d305e480d55569b99b71baf5229cda8a6a500bda0ef3193795c2ea72dc821beee4d5070b3504e4af43900001da4572e22ce201d67e37348bd4006631772ca1fcfb64d50f7626570c324bea9d923548d3d7210d332c50d77a7ab93b3e5bf388cb726cbea40f7ad2e027904f52cee1d7b6868578d77e9944b8a5bac2fbab00276425175f13e932b152882e3b071b36c1f8506fd0a010bb3c7947f3da3b3d53940f6afe7bca08955a958bb0afaf8858e7e3af30904717a1beb6f9ae942e5f39b19df12fae4d6be9312c8a3ddfd2780f1871f59dce8a4fe8653e239cf263c317027b02139892759ffaf7cf5c777928e993f0991164dc6f4bf238e3d158373366cb7401de9b2a6439631e99bd4cedfeb6f9380040d752d4b10a5d5b4cf3a90b605d4f78db437466e80a969d80ff16914948c6f335dce09bd6e0771c1586f4fe9dd1e70e5391573e030c5a214cab4a3f74f7f7ff024f1127af28bd2d3c5672c29344040b31f3d7417760ebff6155ad1d82b54a8b6e189316d0f226c88cec7ae9b7ddd7fbdef115ea85dbfc0af09b66cb222ce06b251d9bc4f965bf303994f0084681a95ed0b74be9af878a5e3d41ae2bf7187aa27bb4de277ee2d3245867e9249d35d8222fcd05fbb64c7b68b13077794707febfc2d31091701a59fbf91783132eedadd47b87ec0e086b80330eab2a6eca691430b0c2d40c036abfcc6cde7088e617d584f5adbdde84e382a05fea26fa575ed41f64b5adf5f87b6fc568e4c2c8997d90e26950e9cd16cc198269014030768f0ced1e7fae3e449c859adcee1ca208b69e1f9f4e552017d8dad243dd14d95b2ba6881c65efc84afe226bf115f03feb9442d2c121604aab5fcb9c861f87d309b2fddbce47fd4009f269bf2968dabeb2c17e1dd318ff0769cb28afa95a52cb9cfdb8c12be01decd4f6f095fcf7128acbcbf54bb46222666563626bb6b9b34468858e99db1980b653208b565a6a9be9511e233e87b98e70cf4c147309a3de7f541016a5c8ce0ed2b653dc33992f13567f4f6b5cd130fb2cd84c43fdbcd5be4c31ef88ce124c1e9b24d73edfd6b46dce77abaaabf373de6c5c5f9d362573173047e33c9b8c76b0c6ad5afead64d98cfae37f98393f3e7b9905fd975c38abc080b0a447dcdd6cdd3d0df833a0ad4f22bbd5ab88cc36526f4379642742fa7b94079ea3dd6971f64a92332bd60eb34e632e3ff04f35f5f485a53d1b7df2f53c3422de13323a540135d368ae295f9a1686a8b30c8c07df0f74626beeb6cb38dfcdf4ced61b6f9449f755c96d54ae3ffb3478c2beece496f374b0c27c10fb424ed71b0305de75831d228c5091c21abd4eab3edf12684717ea90e876b7c4aef2ca2d63fe9c2a93463e58906dee7972f3acf41d2e1fd3f7809c8f089f3d5882feb4627d1bcb6e918e017d9e7462808ccc980b743de3196f2f153a9e73a97c49a58c930d16f02f4edc13ff38ad088e3ef78fd9d04c51270def2e43237f4400865106602a05499898c078c711560a11d9e2010c677dfa271eda4623f42267223e2472b9b560e56ceb96609acf9ce9ab10ca4ef688b220a7ccb193c2d0d4721911c4d84e59d2696007991519715682e445b2a0da91c37b8b20cbc87d3b6958306411bb4298bca3c64ade841aabb13899ea981fda413b40fe1d3e9984e0abbac63d3469d58fc9503226663e860c69a4a594da3b6a3d75a91d6579b006da13304a9fc60776e1737db260d385c57fe80c522676e7786c84c65bdb9018df4c62627ecd44003fc7da2fe75945224bf129fc196a96bb042383c14754c39a4b25a91288538c471f3c3e9bc769b28bc0752f69aeb2a7be94e904fc9db460d3e9ab10ab6ab1b89518c83ab07078893078867590075376f2e802983b618b8e089594ffab8542084836f72bcf151ad575ab05c04231fe95e64a81d99fa88bdfefbb9e9f1fbe6cde5e5702f0d8ada1fc668a6620d1c06b76d64b9748ed0d6e01c6198775215d652593bb90463b293e6b135b96b3386df5c3e877c89b2768ab16f9709dc1c93330cfcb7afd3ca6842c6c31fa8ec525b74ea4387dafbc4a52597aa5db2b87699b4b59e44486c51fdc4693ad5e1b810091d0ad500135cde9f53179c9124b8ee4fe16ccbb1bf9dbde0d1321467654a2fc5af46475880f9495d3bcb4b3b68e6c6648bdb6c7ebde91b9aab02025e41bebae97d2aa02ed71b3d82001df54cc48c55377687de806d2d033655a0002d7c43b8ebf50953218e846f1f4ccb194100db09177a63b3b3a0670ba201bad159aace8cec90e66feb67dc6dd2a3e59ace763c53f74bf4cbfa03b40a8fb6f72de80949d50799f009654dd15b19242b77ed31ebf3b0d301c238cb9ef6f9a614b74539c6b4edc0289ded517d333fc15b38dd690eb6e7beab668ba0fe03432d5c75aca3c3d955b85d97c1bc1bfeb507288215579c84dee2ef60e904963e0023cb9578752a4e06cc172d94f8e5c86821995271c5c0fdd0212c9d9ac194f29cfa4c1e24372e81570e3a5e5309f9e8708453064cb9bb97a95394112bcde905edc9c1524a349fa368168f24fe73d4edc02052e5283f1c05a22243f4cc66cbf7d908ba58c3b95bc41dd27aea5f01244b22b80e3386cd95e711c988e802b171240077476d9609ad1dc0ad181011f330f12dbdfec15afb2ad17de3f0afb7051032f610088fbba05f0a8a83aa038bf8ea821463132387584ff8bca741019a6f4622fed3b878594a6b20a060195458f4632fb9dad81fca688ef0451d134f2bb7ff21b59158cb74ac7b3542dbb5d6c2134466576b7cd7cef70c6a8bb75af1b5c6cfd7d04b77917983a32d6b9340a4c1b3d2be7ba8cfe9c4d0c73b69cf42400ccfb491211a0d73c289f322ea4192f870c8b9427e5e841d7f11db1588dffaf0b56bc9bfad49445db523d5d3569ed357caf9f6b8486fad874f594a6085ef6381c3ed4827227401d677c469f3c0e3c52ed72ae8f22487679df2d11e79014a1eb26da9f69afbee17e2e196478999e469715832175b4813a22e92377306fe2c781dfa22443c7409048a910bf1911f333f1a411c83ebc0c48c2e9991d527e371957c075bf31bcb5a827d247551f6cd920a889259626cf773fb1d1c022580bf0c79a45db2028d0fde17821ec0830d0a801f36d5e38ecfe724225aa151761b37ad3eecf1a13a43e4751b37905fd9d2f9ec2527d4ef841e321ef060c2b3c9239c59a522887f511200b42de9931aaf733f47ca1a48d8b6c4d9e966d24f5e2a468af6289db0969da98d6afab6d757fc80519a2270b489f383c183cbf91e63d15bcd8fd72512a9b4f5d60ab9f5554ec95bd331ac214d53d29e0aa4f0c62ff06e3b86e420d2e743b07576177280afe8a68db52db0e14e75fe304bda345f42c8896ec19d46e20e8adf78430bdd8a8edd22100bdb82e0badda10846fc5456711a89a846053e1d2968cae867075ee92b1ac86964582110098b746fbaf2dba1218cf779d73c68016bb5bfbee5b45773e63223d8db82904f7bc672969bafb6d80ea3417641d1e1466b217f540fb99d328a97d84105274c5660010f8ece994a0a4afd23b3a3d5a3eae809c819f12400128d912d52e3f307b4021e72ed654ebf151e7616efee6fcddf3a41c1a1109b616ae052a9754591b71f860ac62f5d534850efcecf264373ea6731f2a5eb7bfd164377aca59886f93d8d3916d658b64082d7c0d01d2f04c7283b7f4d68b51519c9459dad256f20a2d32deb6c5f6626fa7f825a4e5eb17631d8dd19bd160f47c7ab01e316b92864a2300b8de42e7f889f7912059a25e18db71d9ca9c13b27e1fb29551cf61b5f38d8e9bbe5dece179ed63c0f2f4825abe0dd11cd4f0ea41a7ed66e175cf1b4a72828d665649485e7b4f0f3035e003854ff0b201e8a3871b4f918714d00f8e8e1ea622aba041ec7b418d5c49691323d95be4c892c78da49735f5c5cecb60f6d350409bf069244fe35cdb535b0fd2fa02c2e4811ae694dd9cf2b5783c8b34356cce658e87575052c54a8ce6275d6d0399307a13a09b8b694f52ae28fc147851739f303c37dc4fd56129bacbfabc1505ee8cc109544ad06e37685a1b7dd9ce9c158797a126644213539f14ea288fc3984f43559f0f34c24689654d0b8d0df1c393d90cf5ed32f0e1c2114b765cb2e2b81f29cd2d9c20b047264f67a5be765e33f829c009b9fa2251afe5d74f519a51eafd46e4ca7e3cbd518db3f5b30b129362bf488836ab6fe728d517fda4e2160846a1129a1d45039f7a9dc797f40bda0c1e4ef9b78ff290e38be269ca99e708d3e2a7583030131423fe078372cbfeb40bba6b710da5bea44d87a35885aaafcc23e1f28cf7a86857c0c077025e82106441ee7570c6ea4db0431000ea8d54dbb6e4de35a49ffee72394d70d207b6fc74121a086772d3a1caea2e23df98b73cee341fc95afa1a62f9c3ad6a78db563af696d20a06348ffe1a7a6fd016323116954b9157e21157c8e76aa996361a0245a749de19851c00d7c8477d52c2e2ea3e1dddf67fcc0247539626178cf42b68be02ae2dbe1351bc486b5d8ffca96c933246e9209bf9351223af20d71021cb4be0f10cb92703a2bb2f18689eabff2e965113dab9624b1ef0fb865486887217c87330e12d64b838ba2b73358a9e545bdccab990db917e0f84b16ef15c3500d1b05f3b64cfc9728c45195572bb48b71d2f9270f63704b10e7a21ac9358461413747a78e196a510768d51b02fb4d72266c3959450eafd2d3ddefda0ca17c0ef1941ff7323c3cc95493f34cd13d62bf6966891f24067925c05c81c4f75c9c4fa9dfdd0bbb3bc9b42f605cc9935ebc11e5c30525dfc573d7845c818895a00f4afbfe34ac5a7bbba2d38e2aa94ecf65e2c2445bd3a3769ff0fc25a27c78c265d75a488ce30a23cab6518ed8f2248bae640c0bcbdb1278331de51384533847b19a86c8030d47404c1681b8277fa229a2ce30487ba550dbfc10ffbe16682d7a106af7979fb395339b70781eb8632fe25e1bddef1c184cea1eaa4e4563f2166e5af0dc3f7fee795388909797e94fc174f355ffe99eb587b2052a83ce65ed4d804dcead36f0c62c8733b59fbdd7422703836a2dc241a9e15cd9100c6836ecb9db5e9c0dcda0a861473ee43f96e4b3fb62998a0423e99d4e7aab43e4f5b192bf3b2df5e93f269625b347523c1d4a008bfbda21182958fa976c4e04a0dd39a4af8735ebcdbd165b411294df973963a1a8c294e6053dab972b723ad6618f0e1e36ea981f56fcde4c767f3b0256c188d0f630cb68b997bf1f45e27e7f402879d465e57707c3fcf1d4bc737999feb03a09586d0251b86301a540bdf98f41fb370085b0b1cdd608a237eeb3907c7e25d0073173fcd8dc9b021d5e1aa37515053ba71698b3445097e93ff41f147f956f6cb544dba00978c7308b7e0654730856503335ebe3c7ff9e789d1ec613008e3393d75fe1eb7ce362c00edc6c653d53b26fe643eeeb66717bd39bd7ec74e49a5cc921b6f0c2321cdcd3bfc182f37977cb6a7a35f398ef740262b6e51855dc5e4fa8d886be5b18651528a0f89878d10970186f78eb78c27a2b71c3fdcf43dd3c1bc73e5068a17dc94817989b8f166260c7e1396817dc5943f3f06da8c60dae3a8951855de3c368b20f3b52a4c04c8c3169f5d30193965ca297011e1f1da36423345712aac00f1fe58a6765c2ff3c7f2f94e1bfdd6d5a27974e655b3030902450a33792d88c54643e7ef4f99c99667db5a697ec92e318af02659fb936f7d4b3851741c30709c78b11191f705165d47cc49277402e8957f6ae2ffb4df867cba5492efe04fa0586c77acbf05143299b94231887e761c30da61dd1114cba2cae94c54d8944da4bb89927291b5faf7716a09bfd583495726fbf2daa3e0c2deb34b5f4d4ff83b8d16f8c333d7c674540273420f1dca39c87c3e1e82f5489eac1cf06b264307afa82dff2193f8932a425326bf4a67bf0d575cb164620f8d7050dd412d2535a4a323c9d00cc06add0d8e2b5a3f23055fb5355c6a9c807dcbb2e47caccba6f70aea8ff2091b7cb73d2d096df999d88662f8cfe6ba6bd11c4bddbc0665ebdd8fd06536cff62d113f7074d8953b34ea5d3effd72bf2242b728c897ac6b63c7008feedc6eef9dfd647dfd84520896a3aaebd46c61a155871642704fbbf64d3c0b4183ffc98f8c31387d195931a57017988546af541ca1f741fd4f870f3debc26ddf68c688fbd3123e11baacb49c9a37fd7c1a187c522986d8ea059531a4311eb541c14bf2f5ae1f24c9ce1cc99d93d0a9f72ba38c29f80b4adc789d219ed5d2b67440e3d4631b9fc629bdc4b72cf7579850fbf9649d4b585b53cc291a9c14c84ad5523618ff411bdcc5b20c8d7f659811829c1d3036a250c57b9c17772331a4a147237c6c338c27d47d0cbb4b7894671abfd7bc4da236292945a73b7011cea0949f8f326dc36db15f00877a62d26e435030b3a50e54ccd611e0f0288778ca4b30e17ab3fd864e0883fc4a3f09e867d40da38c2696968f0142cb164ea92c399f7824b3a03b3efc0ee4d762836613ec618a84fb5a8f9dc5e6c9124b2299f731b4bf4c8fcd79b1b90dbd8f983263b65ebe8522c1db560c9aa8d9f8587644d2501ec4fae4685fa729b7298972ca5b20f8f2a2c3f54b5b7db046e5b91e87faf278c33bbfd8e3d7b7645b644629e345700e1669b7b05e52c9b2fbee5f2c7b142a8e719aea62c04dd8c9ef97cc0ebd431a79a9cff384437b110ef37a5f8ec5d54f522c34948b5f3614a3c941e23a6bd9c56103c96e506226d57df605dcd268526b740289a0603d4f5d6c1655159ae9c663ed2d5be68811de9c528f821721f3ebf086a079aef178fda2d8890592119d6a7dbb586b9ebd854bd6789399f028682488a7ec75e0dae3ad72ce68beb919ad0c1ecaa53ca8614489fd14cc3b1df9fffef0e5880afd3d3a0135fe05839279919a976dc8eb14ea626773e9e7d4c7d1319a6f3c67c39faa04374001668c8c9aea6f264929f173857c81c223d0ff34ccf1426ac990644d35d0ccba9a32223201ff9664feb7dec6620a06442fec5987e65bc7eaa192d06af8c0f4fb087781c9aa92c41366b0ff32711db7095a1fe4c34bdc3080ac5bdf69a7d8aede0f23b97cdee914a5262c1da094c578fc7e15a89dfc71f766ed33936c7d993d57c82054c4405120c5cf8a2404a79056f4c1432de37b5e6fb2a64931d8e6b9810e4a79f2dde1492a7f4acd29ec5e3b72cb479b33c693aa7cffcf1f485c2b65a3735e4d32e0d0cfcd9063a7ff64b64fa1e34d1d089240abe0a914a797fc15406bb57aa116db4f8919b3231649d500e891c5d8ee33b4ea2a8af240c29e6d7aab5c59827209feb89a7db2d216480db6968ba8f9a6fb09e0ddfc5ba43e6abaeb8ecaad88b0e82f90074700d04ab6e5f2de6aa58cac53ac4632e08e464bf451959e2a8dfc8a9d01fa682dfc7dcc52f6a69715ac19d0f4c60fe274d57323c28370a06720d5d05c98f786a7f54e2afd211d229534b530134bd51e55a4339ed2e67c62de6362a6e969f6cccf7a449b5c5205741ce76de1cf32f9356c69013b9ee55c270ae1bad00f8f106d7cf6eaab0a71164dcba2a506e6c86d8c245421a65e53d90b21a62e7305ed9152a977927ba8af0cda79d97d4d5ca4fa8c9fc7e74212a5445aac93bcb238fb8acb24e4cdbd4f82bc715ea05b1067518ef0697a7c1de0b2fb129e0b2e7cc846e0ecf03b78f54ccce11bc8eb15a9ce03ae459b16d6b21768c12c02ba4da587c07a1be005b87d83fef5cbac85479595cfebab6e89a5afd8ee660d639b84b123e01b3edc89f1a439e229874630d1f00b78ed6715b34c34cf739f8f93a910496ee96265528c294fc7dffd02a3cc1a0fec1e4fcbcf9402a695fa9fdf5d49aa3ff1c754acbb9cd7c4049f6f3c2ef2b91b6d8b612963ce1ec94e87c1debf1baa0395cd072bf0d79b1496ce4da0fc9a78f81f805a78521575e41cd3e3917c84c7869998ed09724c9d2cca235bebd4c8f98da28120349ec23a981df93c5ff06e2295fc81170bafd3a643f1a86535417cb781e1cc4b96035f6188523e5e31628bc651fbd08152d055418e3adb58fc596ea1f150b5ba60f91f106cb95bd282dbc826e2b7e790101a7ed49f86568373d7418550bbbb9b2c628f5acaa1039f2e5298b35358c9d237ef12903639daa6c1752e842a8bacd47cae8902d83a054f58b1b0dc8d57fbd1d369cf5feb379c817ba8d8fc5b17239b54aa4becf6d88eefce03d8575619f34c3a118631c2a7da2502b9e19c22e9e99f7b6a6217264af11dc5fc25290bda1e896bac214bda69d892acd6c0887c8d9e4371f0bad5426e50735db97e6046fb1a992551504746a87881a2f64267be20e602cacbca0ac529c2ca49fd83b174da67d31bde142f659cea73af9d99c7aa19587ba8f7909da9058a815b0c17fafcb063956aa55eeb70db42061636a80f06a48bdc587e60e5db451a44e32547c018411181311809cd8563b2752752e0b83a89ef8bcde3a43012a03bef6c7fddfa26a4366ac1f0cb3f1532bc2aa98e524bc9fbe64f640620b2a2934a9117d5062c46845000c30245d936d7df4129c59d48aed8f89421d0b548c6e02b8a85e9befa53c57b6581d06f485a72539ef1d85c319a4559ef57259191daffd6d62949f737d7be12d20c28e1b25a6d7042104d518eab13a950c28fccb1a6b038047d31f59416fa66e187f8b7ebd7bea9d4a62515daa001f4d0e919a404fa0d30bdea935b9ad3f6e70249c43ea48a2f6cf5819dab81cdaedd0e5bde36f6f29048ad0757b645216be1873fd35f3be631d2f821eb0e0b766387611bf3fc52810c4ccc91d2f12951a114ed1a8cca2b2e701ddaa142e66d6b4c009ad8bbca9530ba86e71149f6a4ac938c1fc6066380aaf704f29c83f87f3be3ed5e79fb682e2dd8ea215edcb6a3158755e2e1b2b2ba3185ec7e809a52a56df4f1cbe764a25006949f2219fd05f8ef072c12281ad3b6f4e56df143c2d753225621eea0f3c194ca428be54a1eddabba8f46f844976e99093ccf5b70cd58901b34c432cfc0f9812a6ffad99ae889e99ac299ca49f882a14a52a0e3ea7283cc6168dace307e0aac57ea451ffa79eec4441a4fc8f51801287f8c47721f068edac1d95231595da2088f83b1a30c64075d28c94fda1de75ddd071f6dec26f25732b4b1dfc9c8c987ffa2bce1259c32d89abd6d7ee919aaa2469b485fbb03cfa83a118dc5d0c3f759559922a243631c8d17a38989e0a2d0b5dbb557ce8f890607d5867dd2be2b657b12cda8cf416a01d322cb27ef99c0f437a93859566afaa0e4b574c242b00aa68fb7525920e38a48886b6d6a33f93fcbca068460c8cea80805a559c87f2284112dbeb7eba0d6fe0b61824a2b567231dde7384a607067d4bbee56d00025f9c345ac30a071d6543dbc78d12798a8ce4f3d9e9c6a127932161ddd90678613fd9c6f4898c53ff0a7ae13bcb403dc85b6a8bcfb2f5d31c9527395bfb447f271ab9cde62b11d4e4d283702548233e96f0a90011e1ad24a018f77d5479ed741b7934bc5bb557c7123b1c0972ae013ea4388606b84801022bf7490ae4f387ddb6aadbf756e4d686dbf319619099c04f234a72cebe2d5c5e6e16f00e6e200eecc2375ccecc0450e71e3f08dad58f7da93d3c2162bd5160de76269cfc20914ed950172aeed7649ff236abd88e63a0da5b216c6e2b6d8de0e1863f5af47d11a6bdc37f4ff156f78fbe62176efb301e335df63215343862c1f98716febf925d3d33d8f0788aedd3bcab5f06e85448b606331dea096288765717e437f09c35e68799bf2f666d0e0a7218c5d986125c618f9228ed43893eb7f0ee02e644081d49b4bc69b466dc9c0a4029b33b64b45c642570e640f3db000635c108b3418a3f2001929771038bf04cb4efb652b275941f40506c2ab5bb45f783805581fabb1ffcde27e587969db2b3f2fa70407ed1aead324f679ab21d5c5d2b63a877b11996ce27bc9029794b4cb1413d991cf1cf620829391dec88a7ed91ae0338df873b818bea17a07af7b050a535822f76452707714c6393ee65b741ecc830463011d990a8ecdab5089df35b9783b96d71a046c92c6dd01efb74a2ae63acf6caaac1f6bbf2c4f72d17dde082352f98693b39687ff0260bbfd3a5904ab0ab336223718b0304e23f169cb882a315e7b5a85dd89ffa623df07d7359666638d7da93f69933516f9fc0df5170dfaa9889cff050b7d8ed2768781cbe9594a17cb7b43160ab8e07246274831def88b7999032f45e76650068fc2feae8154d4acbcc9c582603e3a952271f4e37d3ddf638bcb0c205cebf782f1bd575691d672c4be39b8b342164aaeb08ad62264b6da5caeb525a8dd252d9eaec62fa2ac824bf46ac663f815f7b0350f2840d17c45c97a813d3098df0fe88ad9445b6e37386bc3f01c324a5650cc861d9191dbfa860f6f2e4bd33f2579b84c432cf1e3523a02ed8890bf33822874a4d85e01b4d9d6f6dd79584b70f4736d23d826f5995cb19df6612602d493007056e56d23a29033b514cdd4ef43b405ed8677275fbed175eee6120d947e672f32fdc9b7c7730f6d6036da9d712fc5c97f2f346dcfb061d222c53cd47e29a5f659fc4fd30175788f59e4b820476d53e0c9e9aac56848d80d5272b806468f05c7fd417b13f8055e1cb17444a7d281c16db30c5082d4a265ec6e96f85067066211e60330d7c2dc51d65c7b3800c1b3988e72eb3e02858a0d1401c2995487d24b32c70e77976ee3e3770ba0fc93ba65ada669a49ef92f0840636097ee3821304d552a79d9067e4db8092e5d9e4f0395aec773e2722e2b2a7a0bf6fc7e76856d3ff6736fd56df995908cb39354be3467add858a67dd8092433e47eebb9e86c89b6540d1d32579a1c9cb6f2dd4375e2937c2dc7fd994ef4be6e70049504ecbb88a734f24cdfa10dd470064e8d5109857f4160c7b6b8ad324558d23b016a9bef8ed78078056e6f5c288c8c828fb1e6ef973c3018de26fa7305134efc24217c767fdff0f4663144cc85eb3d63facf9236a352f286b883bddfafe3e4fd9c86506eb420085b4323f34497fe90855475a49dabc81dafacdabd8e9d4c58403c5a9d47f268bb8e57e4c10ce0ca0975042ac862b8c5c20d31d994fb11ac402d9a65d092d0c99fddfdf61608cac4056ba28707f3640da7fd39bdaad4168b780fd4f4acf63e33d14847f0dc361861862562b4f5eb97f412813305717f047b04d6f48c7257affa3186f367370020994a63d19eabb6031fbfdbaadc1f0dae7b444872b989e441220516793d895048c2f18612c9302a869f4638c204aca0f2643dc1982c88defb253138df7d12e3b156e5dbb4b58818289ac12be5d9d36dcfc9eb9bbbbde4a2cb8963abb29d8042cd3cac3f37686e559a794c3a792bed5f475234e39c2c4f7f964035a3ac50f1594db19e33dcd4dec00c18abedb43816f247b5b58952478f2c4267d94b3a51189f8a71d6fc7e201bacce3e55c66ce4e469cbeaad4a3351b7c1276b9161a20818966fc8ce2df7834e938656b2015ee16e57860cca059e72dc8b1b5574545dce514afbdf3c9197838d15ad11a80b9909ccaedca5aa9c436e0bc1dd4ee1792c34b6e57945590e497066ada9484d9240a26b0506574bf165c48103c1ba0891b18dc37a148911c9aad25f44e983d274d2e94e8b5d240189e2a973b5568c89557f187d02186c3deaf63a77048bc95de543f03d57ce85a2ee843f1454eb77b322893553bab435061845d76f366a783bbd6f1cb29286dc04615afd64fc0afc8044b5f4245f3089770121ff2496341b3740633f0079211e2ad28ae33637eb1be59f123b83c2864f99550304185dfb66b049a3443f7e0c23ba496cce61fd89a11b4a5b5c98c3d68f572ac687edef5d11a8401930564174b22c29401deac070d77db2ff0ace3b61612858973a8f6ec11e04eb6582b3352bae5f4aca7faef0561251d31fb8444f41858dacb876a987e18dd6284e74534b16f469b38b069fd310542aed74932d9a78ade0e9060fbe84da677a6e37675583b1f690239ac70b358133634180ca0e0eb0150bf4ec487a08c71e9bdce78636899ff0f29402357ace50ec1e4d0cf327b267d163ab8298a2b90b2283db07940c7a149aa375c51797e4906856cd3b34604998b8fbba33d50117c04026198b293bcad023ceca1a71979b041145ca43326e97830c417211c1205d959dc474dcc16aaba82f2985c93fe20d9cc597ae7cad66897d4550e5743a69ffc0460b0b398d1469848406270383a10e5c4b807de21daa9288d1ebb73b5d223f2c433d286863569a488cc26f668f7afb77179a3866a6049c87a0210ae51a55226bb193e463cbc47ef3927328d077d9a52b75642dfc168d6edbbb31676d85891652e79ba5372343cdb80e49b7b475fde79502598b845eb9099a78d62219df8f004606843583ef4fed0d3d7c9bd74f8def5000e9b72851c05e3aee7bac592c39a483ae8c3a52de0d4dd1a70b94ebddb02f80ea50c65ac92e4da59d2a5ee8b99c8d47e394c1ef68251652c56d197ca83847745417eef353a3e08f0bed935157e6d88947a6022dc36dfdbf4d2698ee914e0977fcd6709f9ea2e1e41343d6ea80edd817d9786d947e8d3460a3b243eca4a72a23e958120af07fdfdeacfaf3451e88cae48c8e02ce17b122f4bda1f274f253ef0a4b690f2509f8524dec91a6c31cd06e5af80c1c3a4f2abcff2e02c1e40779270c83b9bdc298359197b15c054ee057b5561c53c9f8aabf7b76da135e8dedf28a9a1075bef26fdb3a011814fa5f205c2fb3065d29d38d6857d53d90f938532ce0d67c672a3da5da81ff2f4cec0468f6f75412ed9be856af37fd2cd6df8ed522ba89abe9e25fde72e031a594865d97f40963b6978c2b621d82d97bb7eaeb46955ea56f64ed219e4b40fc981ba9fab75e4b2da0f01b085012fe010709b938e75b3b8691fd60c63374563f4479cdd36d0e6b77fb72a53ef240467c40d0afbe3fc537a75a556d11c867894497c422ec8fe1e25aca4ec1d6a46135ccac0e34159d9a9a6f338fd5861bd70fa6b3eda106f531798fb5340f98e1667e12d2910f1ecc88fe2fb7ab4558e4bda863c96e79df6b10dc5ca3407d2fc0951e8bfe71d808b35911251cd3138f0a4a96f8a621a64f4fd0c0cf45f35983e2c085d97a637c0d67da6a9c1e5e4e6527117d6e1e4619da95c9eedc3e147e31d093ca0ce32db2e2e1d1fdb8e9d0c8a06da24d4ccc0e990173431117600dfeffabb2b6d6695da81141fda119220e8471236a691512bd2966dd524fb53c59d75bd2efb21258a90a600169cd15ae631f2f22eedd965f5a3f1b079f6197938d4ff7a5f18f54d93114bec486bfca731ffe81f9f3741b082f7974f6cff65cd7b43ea78e394077ff9d27243d60c6d5a11714a6cd9f891752d8c2a2e23cdc4ee207e74020c90a2bad9bab378aeb0b524c251b1e5df82d2f8023913442d0f8c537cc69d04e4815fcd1dbdc0d9ede90e7aa64241f4f22c07949205a16356d0205ec6a249625a1a41fc738a9effebba55032b5d6a119b171e9e05ef6d669e85d696eccb7ea3ce0943e3472cc32b858040dbed6f65be13a0435f80a9cd1f86f19b68cbd3779c2025dd2e956c529f2906d5ff9ffb42e536a50dc6e218de894103803c7fa4459a12167a62888c20a9e3353bb7247c16bbc5f2d32f46832d50cc5ba931884024546e717184a5e1107906c9aa73367bcd74f85ec74ba8ff75ca0959d4ba0e1131d163274d9352c8750603c92dd27066b5ab2474aef14c81e74600e9afe644459152b951385e75a9553b51e724124934f50bba26c383f607a57d5c99090ce397b6f9a9d4e63c9d08c9181d3e62ddccace206405ab0a4cd4631055d6d17d3bb147f38178b33af9d038ee8c1507419a14cb22996aa924c9786d49e1ebecae122491cfd0c4516dd95df2897042524332a2c150c46968f5994690661aba58d36b95edc56dd2d3d37638b2be499e836e4c525f04cf4453b542128d9dfe12dd49e7fcba3d712e9375407e27d7f740b0d7223dfa51d00aa99446bce1bb58ffcdb5db22ab552fce90601e703dfbe4b3ee70c9b620af299d7019dc57d406229bbb092fda97321676d43a68549992db047807102df042ef59e88a4b2e9663272eff704429969b9ad7adfcc7493f37d741c372448692d4a793f223e14ffbb63cf8fb58400253744ee8a0e4eaf494fa22dd51eaf3468a0360a5f37b6ef5ba4dcf07e49ee08cb869f1745e0f11b316a8792d2db26ea1b18770ee59ff007270178f528557759bb3d6d98f7660773e73260c5843835aecf58e9c29d7eb3158385be6163ec998226700959710558e7d6e5f7201d458543b3e83c6a4a86595d4a0b18e60498307f3a63f366d18ae8d201d0e9d080173a746ce701738789b4899c3f713947eaa2876408909eabf276f19698c72d6cdbe34e64e845060230b93d62348dfa44ecd5c4879899dde23d06ae12e8d835b0fe7b176b276e8d4a77e2881a33de6c2083d250b1c37d1e673c6ffd149c7e11a19702dfcc0003c7008c891f3085c88a5222ae2d7b3bbc8853936ed346129aa0b176f145b68bb7d68117bf83332bc5237b4eb4c6d674a8200bcb9463396359934eafafbd825056797376bf824673cb12ed6d03f2120126db7c4d9f31ead5e41873f7b9221bd157a9e9d821c7046197c019d985023247dabbb423da677ddb12496385416e05bc85edae2a1df793d55d07e0e4138731989ba8919b6c9a3a2a90ea59e59d70","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
