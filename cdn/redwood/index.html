<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5594fba45762d0975dd35c3ffd06734cb37878a0f4666407596c3962f437709e5307c8083ba2b80b09a0b3e4cff31408a087921ab20ed7e4d1254c61bf3930fdde177d659a973e346db2e3099d8ca6084be2fe77687c96c425d3f7252be56bb81d602d15d66d7fc100850f7c0177f77ace776b664f17069cc27c2531df1a26e94867b46d60573e0b9747402f41b373842c5d865bd1170c505d9e3ac7f4aa084742f53fc0b3d1c068ef3daa1fe1e3a585c298435f6535f5d3bff6971ec678400a89ec6250458bd98e504100cd03e4479cc49c07249e1727a2cfa490c36d2abb1b7d93ca576b798a432d134e66ce060ac1ade2f172884ec965ea166baacabd67249df265dbc0285e8c86ca4ddf24a20053a4d839cd66d3ec0501f3e618d18afa9b9b7d41d7c8e07108e867f88a7b720ed5b5b1c4bdb893c8c29bb4bc960594f3eaa2886a2e8fc9b90799acfb82727ee580bb0f21b84da9fe27d5299fbf7390b85b2e180e732dfc0a032998ac30b60fed7a8b4350e40c3dcdded25682e7a7588207576644d1016ed818d8e81c327fbbb0aff49c2a1658327578b2d9e837fbc826aa1654ce2c617f24e8fa52a252750d08fcc2226442286e2e29235632ca0a283c973b9d2fc97890aa967352675b7405094ba19981564adf7a2437684e87cdabf43cdd033f702d492fa678545bfb0796259b64fc1367c02ac03437b6ba2dbb4b1c7186eb6e705eeb39f5c52bc57a45ea9f75c6a098f50bfeebdaf42df4633d42a94cf3d68f26f8e5fd7e7777ef5c127cd8c64a224843be9cd1d3c9a6b6a99c0c529c7a20026e3ff0333e443e595d2cb9d771c205b79fd373d63fc0b7a007f090b81535751845d7b316a0b15d5f5db1e90de3c3178be9fad0cfbc3c56e2ef4a9c6a8aa29e924480688ec4923d2e459e7ae06e46e8a9240e31a3a9b869df87d404cb332373c8bbf865ef6051b3fdf44102af2bc1fbe36c9712348abd82cab820fc931dbb536095462c79558b1594ad20e0b4bcb2f7bbc7fece53812c0a812cc862b265db0798039e33e413fa77493726d114af9a10b830d6585d0a397ce7c582b0602fc1669e5ddd2bd445d14d26c7691db1c1fdbd61aee2d50997da4d97d7e9c47c376b7b14ad6663ea98cea86b823c0a039f14306594cc2f62d7a1c80e157efb4e0c3002b5ec62a859b2722748372275969472441e64067040112f7d53b9c73272116b12a3ce08f7e979356f60840e2ae2436d935cc8a6ed684b75d42e35c722aec50b12227bc2aacee17bd64c2a8a5088362a9a052aafd91fe04b7d2cc3a26453e0e0475ed464d0833d45bd289525933a3b19b737251f43a0e7c18dab4939b7fb1ab78f3fcfab9bcfd57f34a2ef1f7678c692147abd91e7524b278f97c420ab19d8e8d5a30d5a19e1ef1e615b3b917695bddeb23c5666df20f45e19639a4a9b97971b8975d4afdba35cce7f5a996ef9323629583c2318b33b46541d91a701c17623575d8ae30c5161c1c5473b1feedb93ad8d9076c5697ac80e879531680bda0ea8eb2e01c89c337f7fc9a4df24b180e51450c59649836c48c98b3d32bbe0a1cfb4444010ba3e5bef31d7428762b7c4a091eca384157f6969f81bc9437b9f550940b7654edb2bb9574f12965fe01f2cf9ce1c9339a604a5e2cec93524272f107157334b20c15e6528c4b316d8fbf58f1fd60f220371ddc21bfad2687eb96c5b0306331d2f12bb5e51a5b461b23e36416f9abfa34ad9c44459d911df1e79933bac230cf806460517d9279eb2dd65e7c5d837d89143c0a870cae00c4c318b83b9f3a3402a6836a0557c106d4be66016870c1274254fce98cc0595873a957a8c2738e4fe39f2b845bc89ba7e67a32e9b005db3d84708abc5d129b8cd127e48f3415f8ae01c263500fc3087b04f15de8be9a6fd523287ecef60f2c5c119b1970b8ed594aa200dba8292ff18548e8996aa570456d91acd2469e1d749f5d288b720aadb6bb31541df23bca4fc96e550417bef9133ffdeb96819aa91e52caec22b4bbe400a4c2255ff6d54fed58abbab6a68154fafc2239925bf55bf75c457f2dbed58489d3a378744503cde0ef5667432938ee3822fd226882a202d4b8685f9cba45bca0d5a7f0e9916db72dbe93d3b9fe62dc1552fcd60fcd5c03ae8df1f856d4a577c3c6dfd640a21a1650ad99b1ff2f8e110e9fa0456e8ff39dfb2cb19cc7e6bfb4330c40f2c7dd68b3f872f18300382c3a50cd51be510256f5bd59e4bcad413b7c86b6ca7698393ba876146a07fdacadd168a180dbc3f8eee1736005d612d5812d00d43bb808a172fb20efbe9c5056d6449434984f1e99cef10f8bce030548ac4d602ef37c758fe06ddf39baeaac8d429f9804eab4b32a7f78b1d1724893278b0c858edca491cde5ab24713a57ef26c49c2865db4aa2c858f105be3a675a924ebcbbbe819a13ce82bb0d3076fce6423a3d8196a8f89bb2ae760a47c8c8365d49ad017aece9759449a61f5eb5748069e7bab54d5fe59593ca94115876d1edc65a62919fbfaca2f72e8fe08c5091fdcc0189e95b49f5c57ad1caff7be1ad4344a565f02d5502738e8eb0db096563ed5f430553cd5aa20a1c723fbd8ae4b2337df0de0caa8bb258eb3f9bf957be9ebc0167d30c0ea38cb6ad1fc6ba8cb3bab97c209a2705722756e8e65c529cffdfe311fe7f9986dcb163db778c60f19d640628eed571a1eec254cfd48c76d8a1db5296bdf40e3d357aeac97087866bce53fe3a10d4e4b3999d9b2d6a81b270b72d910fd5725ab48f718f1a18c7d7e1867516803a7755a5f7a1681537b3a3f898a9fd1544df0e61e25caeb1057696fd9bce2114ed47e682e363f26c000afef479d6475a8cffd501774226b26d44bc01826f6243446d5562b050be0ca8d131020748c7390b8c717d73764ad37f626443e78db564e572f2097b843545e70fb19062a424192ea6530e661810ef3bada0289e3eb9a461b3beb0ef53897bbe9387a1a55916752e0fdf1b440a67347c26c4cc5a4b06214fe52dd66d76eb664448519d72c43cbf07dba11d5182307efd61cd9723f36def9221fc708871bfccdbdeb51be42fbb468eb9cb7e99f12928cc6c82a3fff0c6b220f4bc081ff100ddd4412b01e42049fde1f08c7f2dba13b4c0ab7f918fdf87008414a5a03550cd4f624446c762627b8617390a1a286b93a64ea91aaea698e065a7dd30c56bb7f17e7b0d1f619d91a0c49abe0244bc4e104aa50b26e1f30421c934ea550da0a6aa8927bba3e7d338318b38be9e4a9b5ca5abe69e48f60a8034e3ea3c6d3c04dbc130ce207bff41812f1b41162c7ac9e0a8a4c68e1222600087f40588a301a5dc32e78b45af51d3f4d50d80986864bf0e77310792e51e4b34f16dc4f1385a7e69157ec127000eff84a3e57ce2dd6f40985fb7ba5af4710fde4e6963b2de99e43d320e2c63a08c342302ec9e0de7e6768bac0dc5b2d4e1fbda50623e6013c2540f20a57d2b55ce454a673fa97c2f157b914b82197e976206896b6b3ac6d2bc9ddb43f1cb1639a855fab1eea65d868db2c13d2f221c4e5514337b01948178eff3ef8db59b568ae9cc9500c89ee301a5642a7ddda2afb93d9ca4be7acc6591251189e675da2c12cf94fd2e3331701ff9e657641cd7c3df699d9fd06de5d6073c4f41a85244406156061f109c8d145282b6f4e4b8259252a66817a66485731a0a8a5bade01741db4e5f2637f73e5dec63814308849df64ef931ad8211218895a56e409376ac1e289b94036b22428b605ab75cde47dfdfc1551866e4fbc4092e5354f00ca24532da806dfbc7f2d183e401c925ff70e73adc4fd95e12c8c96348695a8170e2058fdbe1619f4943aa47981ca4b229c36c28864cc92ab9a18c6c706e08304976f01349354b02c3726bcd688de0c1a7838cf636155ecea78e88dbd0ebf07195f132c0b3235996f9ba2918c2ae382203639b3007c014e01658d3600c0d6f41945a08d268ba82b05c55a5ccbdb751682333de67471a21a69e93e9dc2e878f0348b4e8c0456e485b08fc6502afd1c7d6a5ad685abdf4f5ec967af47af228ec435af470a5cc2590cbe118521b25da4e6a53f741953a84b92c54fc59d215c573fb45e29c3eeca9f930fdff12e19a89deda51872c3d400dc2795cf2b217d45449d9f645c967ab97cd656194bdfb4b79c5feedb8212a6d6b719175c495c7bee0e1de219d370e14a7f7fe36171227ff7e2d400f6ba2ad1de9bb1049934434b290a7c1407859e8554bfc3d4bfa697ca742b506080d75d3946cfe47d5d910692569be8a70fa33c4e7a74818c9455c22399a9258d563c323c26dd5918d26847068f3531b3bd640d2efced88937cddc93832a00fc71453dc708cb8281c2c7d755d909b34878076e1df71ea096347963fa89ba6de1314f7286ddc6bbe2b664ba2c6c1e5d6299f4f796cd78b06843dd07561c75b3cd2b6f0a913ee5355a83d0911aafbcd99bca8857eab9e5f4635200cce7e62cd22cdd53f375152da4d6ce074b15655111871c1109d964552584b4b276a64b39b8654f7046f4a4235be068008f8eb02c423d128a91c4f6b0b681cc91fff09ca76faab72221f7ab388628176c744a87106a02979f091205b1823c9226f55534bf685e6a56cfaacd5437e964df09b5d19cfbfe0d5bd14e3550cd56eb64a513768fc4b28fd2c1c6e9c3ac5866cd482e5a1552ce319e0d350415dd29f5eca63432a3863355c7da69d3364afa47c952f0e14889f0a8f000d9dcf5cf7ed2b534268b7ad53bbadbfec615d439a9f2a079cb1e31302ca66c338551fef0527fa65014bf8ac84142cbcc2d78a88fec9b5b469b7afacaa05709db853ae3b7b29b19530c6f15c17de3dd453d933c94a3b55c8e4c909d981eb62aeb023cb85e07d037616a602d97f49fb1c210d8305c30cdf66f1cd8e7e5a50bdc526dd290d79bc9a5283e74c496aa6999ceac2054b09b17854ff1acf86ef63de1e8dae80f4ea9a38c8a3a8386e0a9250452c481cb0482d4d4ab3620e1e3fabb013758e402817650b60aee60bfa0a75e29b584afe4f284aae1919025d4154422ab4da221f6506d4e49b5445975ebbfa60f335f9f7c0798431a7bf100ffe5d7af04f75c43851204b77c9fc36007e3152ae3f74e03abcc11cad90903fc91c1bbda2b52e1a17ddc270a3a3b6e69c5ae6fffce1fee961f5899118fba101e026f807680877f396e359e430f3b398c44c0c1e3606f12b88735f3f6768edfb8e0fe166c52554327058f871bc3c95f10d0a785a64700ecbdf6325ca304b363bc24fe40c63513993501c4a79ad950a3da37b4bcdff1a99887f0fd1aec013f592b13d4551b6f3e7ccbe459b3b915c4c7b13b80253b4ef13626905de1b7aada80341306f2049af6afa511f525ba4936ce2eebe03d68cae4758b719ccce4f64d7e99839d5babb35db0ee6851ae65629e166ee136c30f05eff1fadd069ac5fb02b3157746c8f0c306305b3c5313736dc891af7f3c8a9d53f24e177e15803b5d4c5b3868b873ad67038616f171b342b767368fdd2ab1eca66dcf80812ad6d1c90bacc0c4feca0a58e00fb4f7009ec8df275b02468292f7379e962464b2a4cdf04b5af5eb4051894963079590b80ee15a1b2ca89e92ce8fbc0909ceb9da18c5c706b229a3bdd4c48e8a2c87ee6bf04d21b3a106569155e4cb332b1fa1977cb34d31fbcc661fa363cd9370448731cfe337d5d1aa0a1cd73c3b1ba468beafec1af5bb2e5a0c5b75cf176d826fc395f3f8184378ae8fb7df3ff7b29b1f216e5f3af49a37116e9f6e5bbf9137633de51b0a3d9005c9c3db825c69af43ab4604b19e59fe825e737c788e1d42d9fe01966e71bae8bdd4b1897e41d90438a2556b86a68302f9b7745d83811f4f3b54a34e2f7c6628adfe493c6f739d67dac773b48c2e045726214a9775f9cea577619a6b792a4707eb603c2cadb5cbfbaebfa6235bde88b645af5584dc4466832f31f853c645941703cb1aa15163542f98c1afb9c10e263fb7cf1b9773177e934db960b4f5c872b2a303bffb403a55ba1fe58d8980269978507a723087a0f1bdd6dcee7fc423fd5d8781342f4c7322f88eb15457f3a78397de204c6db40737a885d2feb996695132c05a54760fd0517b105105381769f73f7643cf85704cbd19520d9aa1ad83eaf5691370d18de234b72d6931c1b758f64dfac476fd2c20f1bf8edaa4dfe0bbdde3d647945aa460a27446f3084a5957f4814d65afb179d19e61ec28c00a970ced9c8b7dcf0e1b5fa95a34158de24149f48236258182772bd7b836fc570c2bb44fd48959662c07f19e6fddcf897902b9a35e8da56223ca6d9ce3595998eb20b9a33d6785c4a2ad2ded4483b75b71c177e0826ff5ab6440f6d23fdfb9d933dc1cffc62839a856a5560be288006bab1ab6ad4a8899fb54f81db68cf72795bd84188496a273b978efc66c45ab55bf1b88f3b2a0f74234e3a05cd074491a2a491029f630180dc55fa4a1800f973c4872387854b72bad639ad63ca1746c1e98dc5ceb970187eeecbdae85883e32125bf67e8c9079ca703e55915f628a6ac68a5e91f97bcf8ff85b09d360f414c082acfca02adbc8a9389a5541f4cfadcde71344c54b8c8aa3aa87739f1d49c85163e99bf5eaafdd1954349720c9df642648981788d2ccdd6a8c856586c9352d685e4478c1f722b61fe4543111e36d638c476e23f4039eefb38adab6c31fb86de4bc09c6fcc631f613f2ad35d2eb1985f07e03116098936a3ec46206202976ab6aed1f7b88675bec55e66bd54a9893c84bf982e02c76315648da12fc28e392fa65779dbc43a6ccbd1947dc3241bd05df88777442a7bf0d86e0937ac6c2cce4083585c0ebe15eadeef5fb5034b0196ff501c11206afccffee042d8b0c7db0abba296866a713a3499c49bec73591ebd1d26f76e7ca264cc5f1547960a2a96053bff6def48a423b8ef807ae6f8dbf54bcc736f524c294dd438a0d2a26e714b910ffa66058dcea3dda979c7c76414133d37e59deecf4d80e21fb04d02a4f1d5ab95bcb6f00002e0a379b079eebb934dacc5b5de2d64ebf76c70bb9b4de8f4154bd0b805a8c872ab1e5dca1157e3fa4af90468cc173b48d997cd240a548dd3838330794b36a3dfa8980d94256d5ec52bb8de8acd58cd87642e8da63cb592962633be89a877530992405ef10526a9a2e7279cd7b47f81d9060c751648b6cc719c0ecb4f6425722222705fa92e199d976500d30e4b39ac2ec51c103091907c3f464777f22355096c46feb97ee623a010d48fef275c429722b2196756abe034f04b5f7b6b80935df1a53070e41bcd3417f5498d96932e231de76c02adad7e3132a926084abca8012be5363249d77f28bb3c99cf9bd210d810a93e93460bbbea0ab60024b2c3768acbb565f8d9e2765804219d8640c3f151f9420b8c75725ac4eddf17f45499ee81a5c539f8af6e46028c7f29244901da51b61675d691a9c72a65de59f6b7f3d1acb2b0f738b8ce8a593a37ca881fc007570ad53bc22c687fb18af213d7f99fbba9f1e2876405435f69d4ef755f57e3f0c012088bb08ebc27e6b9c991fc7c05b6ebc1851c87b7464aade13639ee1c99b945954a74487d04d8e6174fbd254c1668907dc50a74f4ca3d29e13ae8eec8205898498799cf3aba53fca76589721ed244807b70e27cc5ba2eb7352e7dcfb115cf43c5d8a916c59c2ae8d3012aa00789904fc47b826c70aca353fe065f546392b80de3ea2c8c1a3e6d802d57ab71d8d5afe40bf56d4c4ffe087b6cc2814e1070e3c6142e1320a9dbfd4adb842c4f1a62c398a01103262a78006459336724288f23fddccc691f75e2933901992cad61e51102c38e370716deb2d4394bd90098ed1502b148e3ab2220af19511b9e2f06d823c433c633d5aa5b3eda4e88ef1db3ed72a3ae8f29f35b7d3beee66a4baa22d879ea0fc54de5857e8640d8a41fead25e95410c9d3f91b713b281d6fa9f9ea25073234b811699102f0748d6891018d556fc0ba5dbd7672b9e9a4eea82d23ada85227384bf6dc20d567b8d935d0163fc5e69357310906fab54e32fd4ade146a3db1da8fc8d45b13cf79e666e07515dcc1eefe4ac376b3fd459bee47356b40d3cedccedfdb175beb9ce2d96c39d9c6052eb5eb3a152ff49a7c2b6cb150371c03100e47f30b4a42a35db3761763df7dab7f9085540e2eb231f59181888ddccfae5e60e8c02ddf512a7bebdbccbe9a05d991f0e2a557b077ef19c94cb2737f635d15a8e499b5dedbfbf02cc2f5dffc4a51f9d22983e02f566d77758153840f2afa45202f3294aeebe66aac4f0f0315106a1d75f84f70de377137c1638299f3993bbb99c23475e9aa9d37d98711226681f8f221f863dacf65b4c1c3fb72aeb2ff7c0ff1bac2964113bf7e2eb469590aa4b2c0215013f03f704484348d3e6548d6b5816213b63e4e96ff7d98aaf7d25c7b63e28f1928e8dd8d25de039f947cebda9ac10559408fc3f38bb6b7d8a918c217dc5e5e96e16b9ce2237f404c0d53121326548ac746c1bf0fcc10605483042c5d0105f1ac8cfa5d6c6c763ae749db86b96dad613516d76ece5f63ef5971bf045c7e8847cce34d77995ec8561e97c220124b318bcf56b19e57df17292daf7b319ebab6a4c1a305029828465fde1464e408bedab670d79606c26d95cafb51998e9356948dd62562434454c8c6cd4549598187fcbfdab18642501075ae30ba2e00a58a2acfda02d42c59bc0196ff3bc4026d40e94a5913f230d8590d4fd0a670503ac25d178a733cee46974f52773270b920de6f1d7a6b2fa45e5f622b9e1210db23bdb13cb1150fbe05b461882f1211b6cc3a2e26f15a6430aae567f7388ea67e06e6cb26cef1fd6cf4fe3cc02f1b0a093e0d44cbcc99f8e115156cc08f6fb6dccb1efad3eb9d968d42385706b16ccd8e1e3913a61cfaa714fd5fe3281cfa75415049851c3daf04b67120c704bddf66b47bdef523bd1f23561449607e369db325fe4f63c63bacce5a8caf5abb6eff7cafc95f62ad0f83d37d5d40ce91f8c50f84b38f283b2b8a12f254b3bfb57b49894a05c695c8b931973160148a843c731b9a3f02c1daeca8663e72b6f5c01f275d63f4c0b0577a8ecc953a0573c9a14a1f1a27a8bc24f100692ffef92a0c41fd36f54b9f7fb8e1b1110905e748bb8cfaa1cc1ab177225c3f876c2a999668a6a5020a42a132fbe8dd9b19cde23b52bed7e4af7f94c654efddc42fa022d7c37502ef3de206719ae2a2265660f461226614f1585a6f23acdb9d3be2fe6f6c1b7d0825782a329d6a98904e01d8fb2bd63587a32b1a369c89b19983b2d728cdaf6ae43707c2bf0ae7c1706254a941370e97a58039a125189baa55766301f094e5cffb10039759285e532ebbb92c8714ec9da12a04054a1d69be17ba12a63015f373fa66d440e722aefb6d34c8d07a0fb6e510cdfb3e3f8f10434760845b1a8de83c0c86c87b6bd72eb0a5e703d54b12884e2fb58468a9760e2b99e1b7d10ad182c37b56cb82dfa2ef163345f058d798aa0c385410d68424f11f60482c0fddc5d14edc2c56b092c3030141537c39e74ac6fefb5659904de46afcac4021b3ec79da0b67f4ff90133cfe40bf79a729e4befd9b9323d4085345e35e706764d37b26ff3f2fccf2373716c6f19e321f4a387c02b210503c49b8dff36433b48742042cbd205e35400db5f34246ccb2dee81fce57312e83fed9bee5eaf1748055ff66f0758ea6875c45a879291552f627d0d72ad7d25d17c87d225b75536d0e70358110b245b8b7ab71c338ee8fad455bc226d41c3108ed0a8c79a704764288616de958e6f629996828803fe634ccbbc2c90924b0b9414d20b38b1c0e4cf156b5f43de384675d4fff6131796e5109cd8d78f1c2f7925467e45e20c92e73cc931909ccad5b23fe170312b360d978e2cbcb88f9ffc401f21c155833a340e74708404834bf154734d3c8334122665068135584ed85f6f727f1dc5c79619f27f9c189aa71f38366dcb0635ba02b471f7f52e9a69a1633f2062d5161707bb51fcff819623b08a9073577e488f50b8255fa27b7a6f31563006debb0eeadd6847ccfb0278535b46ea37aeb9897f76e428d93c633c1b60dbbc504051c62db6e2c18c08ec1507207517245588e64465dfe6c3fe51192246d2fccc2f66abbd22a10c1f7f226d1bdf5de3bd49d82efb3867ef486bdbcf3a906d5354b12b81828d4356676e671eecd1988a9f541d365524218703b6430ab8db4426c2c9677776e94c30dfda93cfc102f5db894c86cfb46a0dbcfb6aacbd4323634bba58920179450328eb8d05f4b976fe9676a32f434f4cc9b7ba8440ac2bd481592d96f0b94a5e7a6744ebbdf48afab52b29497699bb11483eb8158afeb5fe3c02ed5650484e57f24fa75759f0831ed1dd83f3f7ff7758723d9127de393ba27a234ca81d1e274f62bb0a2b311a7678651cb9d953a1df3a8bd3b8e409d22ab82c61d72df3dbc5baf989d6f36376e715457e926b3b8802d432305291c7346cd2dc331e38d2633ee6f1288641430844fb7ae2754f0e5b7a28be05f773f8703fab563f876324064d6735c2f861b3b0e97f2eddc014fb9c6513c1d34fd6e4dfb2c2408d69dca403c6efb06869d35e426a9d7594292eafd679071e2f5187c0fd8f4384cb244d61d00f1bd936ae3e770b16b41b68622202c4174cac33253fe2df0771d7b5cccde2474938f7b666665939778be92f277e8153f44db0c53ea249c518541a7e9c650b373b2938f61aa0c1fa2fa7a05602c72793cb1f5c289f29100dfa38843cd926749603d231623ca17d70facd3a54fe5c6bc785b3f3c508dd948ff83f46e8ebd7ac2df253644ba8dd8dd5b5da9f7b27b41a14e4188f43ac560d8ac6c50518884c5abdbbe11cc5c3fc9a301053ef1b45865ba3dd509d36865ba9bc7b7a61d47c2cb8cff8c89737ecfa9e2aab2a476a6a45d903f72fd471371d2fc16ad930e87fbb876e7ac0ae305fe68eb8cfb21aa93e1996867bb645ad926ffe774d43add69e0b1cfcf16d0be72dec6ed4f9e8aeba30fe27704031b4a84a53262b79669883d78c73bf405d45053e9bed44cc44d2fc51c69180f6d77eab8422b19d6ff8f51679363846ef0a3c1dc9e41f38276fd7d3c659d3a08294f69a8fa5b772a3d122b305bc3df588f8f2583d576525d5bd4724358c3ec02d2aa536704d8de85064efe639b8a0acb86eae5b92e7d0524b4382eafdbb222e61d6a2e42fc56eed2b1eef12445d8340c87bd86a02ccb51c9c7328a96662331d0de865eb0587ae1cacdd4b3ddf0d73df5b5836c0404e7fdb4f360a72d732c140e254e9dc43c8b2f038c98cef2ebf7da7f9bb75b4f992c09529d50650fa6998d417f0c4935910dca9b6b8e05462b80ddf887a153b60d1211aeece8018fc288fdbefa42151be810f4b117cac8177976c136e1599afc025a79339d31e1f40a565f066f5a663bf815cf458fdcb203383c7e3464b8a3095b37f777123f975dc069d4862a6e077d1ea643eebacad5e8abd888276a4d0453e43ccd368dc55711726280331afcebce2df8a79d2cee95d177abc0aac4e033f7e72fd0a323ef0d5bdf2f78647bb1a2fa92f371426735dc6cabaa46ef37647d0baa03d2a9e00581e98817e6ce2fb2756bb4492ba6c91c7be69591172c9a9768269677627d8e17e9e378bb3451830b6e10023cac973e3889f93a8105da5fb9ce3abd87c3d5872cec1ed96c8ae8fa931b023b345bb2d4e40ec85772725e96599b65a3ac161caab2f531d37541238999c808ba71e6a29eed17e1fe87f4449476ed9744df74f3b48609b6809adde78df129a4909bb1645006095cb594120ef181d659903790cc6941d34fc3d4a49f393ad6732c0f90977bce95d01638646207ac023c7acbd2eccb030a837aedde9d4b700becf6838fc12a969ff64954eae64a18ac33348dc9adcd941421d9d88e5d3f288e3db58ab261ec7158ecf7825bceb1c9b4d84139442f3ca2947f21c4546f8dadee9041c079b1b3d79920931798edba007cb9083f15a8bce02635cabcbe339316b8633a38aa9a8a2aa7bf0535b65a5eb6ee9cbcf788012af6b81c2a2f94b769f808aac45253b5a1b59837e0c64565028022c8321cec64f6822ea079dab4ccd1390ba292b2238d5ed2abd2ee5644d81a0ae13c354e28b78f9b44d0b2b98141b401e63bf71f9302bfdb7d39d2b16e7edfae5c6d9b268edfc1995c59680670206e4d92a2f6a49b3da43df7fde77cbeabfa5fb1d78f98e57ab5e80122f164b7fcedc14131e665cb4c42539e8f57155339906b153004d5cfa59af4e17d23ae6d3daed334e0aee3e6c2ad2016786988f6c95e2622de3c1bd316577ea75a86be2a8a4aba7e7f16f40f27d8048a47b529899c4030914316b7253ab26e61e86b1fb52a24d3f6d0636e3b6fd13622dc01ba0936c800540bb847742b0d9c7ecab2b51e50ce9de2b374cf7f32f0437800693d50f4898d379992c665c54a7df4214ab8efa0579c04bc359d57d63cb25db0b6b9e5738bf1edf9cab647fc850d5944d379b6ef37aa3cc6945137ea765e898bb1db026c94edb0ff1969beffd421725423c4cc399d89a2926b56fe15e79f35a6b9173154f3b642111549e8a4c95385bc46a027baa46b113117905bf842032d1b9f8286a00ac29f5e8ad5730c85300c99603f9009700728519d54da09ce20d5a16a1500e784b9da49db660f11e65c51f001e1bb053d941d8e2eac4ecacb80d06c55fa80cde0936e51e5cae74ab2cfa5a70da0c239f03b682befccbb1adb04393f9f04dab3e468f5a9823dc7db8edbb7db4c0eef759cf9ff857ffb46832cd3ec7275bd36de676e2247bcc32b7304314ff7692e7b4f96cc9c8ace82e40c71a23a1560e425427e1c6c83e70e5dad027c034038f5bea1a49d771e580bb2f2cdd482dd64b4edfe7a620edf190c08b0e5a0ea9e65c19a530b7ab8204aae8c3b12b5a2f03b6388188b84f19e50199e193af18d1964564dafc04c70cade269e810fee798f42f6af3a0020ab725bcb3cc11d15423de3101682287b3962fc644458f0d3548c84dd107c6ac7f32ac7d6459d2b1766807fee45b7955918de5eba221e68a31c88b9b9787341cb6016a9218136c20cf1e2bcd609ae14a07dbc498a17986f3064a59f9fc93e207ce83154cc14516ba265916e20f031a16470e77f681b1728fcce103b12a8bb163714f3477ff71b088b2116021f549f6dffb290ce59a1ab99e9e4089b84f72ef6269a8a8e56b5848c52864ad99c241ed2017172e59da2e2cc50fef9b130cc1f5f8cf12efcd823cf9f2e6287f34d3b6580b5e9767962916a5748c31562ee3e95b32850d530418284bd7c964faa64b810b17b83dc77946030d9e1665559d472d7f4dd5a311d0c8174229de30985ee697fa9790a285614cdfadc34df3c65814560fa41ec94f9695b02f9f0b6aa81acf6aee75bcfacb03c3abebbdb0e73019acfc3bb55d1152e9b18b1762d34a5132481e24f9f52da605abecadfbd566524bad6b491d2fcd81eb14af86b8c6b963beb80d3ca46baa700bc049596a359786dfd4c65709070b664a6b8a4cdd4cf9b0bacadaad15476ac1bf342ec31633735c292c55a9f82c948659a6c4da757984e9f3aad1a94030f8283a953c03c3175cfe7bd89d3df4d5a37587f1461e4977fd0d133737205bd7de4b5ce6b2e32737042679e9ac90653491a9d517d0cdd40855ca3673748c0012234477eb0c7bd4dd2fc5f8386c11787ecf6613bf9cda1477b429c6809efc2125bd56ca693c76c42bd0ec988e9b5affac3ec51db780aa987708ba13ec2d524caf32c67850210b2d80cbf107f8b452551cf05094282a1bdc18f0c0a5686b7ccfba212bf431c5a1f62799bc0dde1d4611b38b982b095f05717124739c22c5f9413d37435c6d39f7f20519ed0897064eccf3c59c29ec86f005876dec53e6d8dbcecd1720bf711f0dff0f265b96a2f57ea3e1d315cc6c83bb1796095425318a1e324cd878832b61844469910a576c08953544b12cd1fe4797ba6a4eca229f6cb62ef27038ef9a59041e5471b328ba51c4b0243152bbce205f1e29187c8e8f044fa19b86975cc871a2138873dd4052709f5eac57e08bacd399e51ce24338bea958af6f89ee2f4daf921ef3df84c08dd34c72983f74ef1e4264a5bf0c24990bb44a4e18ee503ee7ec055c7f2494a6385998dd9208a27a83a0a5bbcaafb4903cd03b53423eaf5871180a0134aaad017343a64e371bf80efa231faab549e78a1a9157b1a04c957ff62132d113f96a1685430fb62126308a2f442be9140a896c6823ff56b0511ba1fecb0c65efa372c8d8ce8578c2d5271ac4ab161bb6607430a3520a9f118e23cae79f58aa53ffdc4311b33b23bbd3b488ce999c546ce9ebff95521e34f01866e59b56f2da67dd62c8414cf4669a90a1f50dbd9eb5c99e20b3d3753afbf8322be1bb647fc1da0f4e167525e438735610e8cbcb3a693a8aec3a4524f259fb8bb048b0de67cdf9e786e17292b1bd0992d8637bfb74a6eed8a1829becf4bb55033e382d2235a6d83b06d23d3a5854308f9cb259230d9af339e1056dac9ef60fcba101bde1ec31ceaa2ae009bd5d6a680f72c975c91a9696f47b2e193c7bb4ea56148884dcb919732f5e9223864a63e5da1370eb7c82280f04ef8ac9d07f54cdfd35cd974c1e3fc7a1cf6d9902a3a6698faec72742eda50436d81ed2ecc51af02e308f5ff3405d74cd2c8f62ed58c79e8cd27b3ebbd1c037cbabf341b5432fbe9b7f761d93ae63b334dab08853363bad3dbb25608bfd736f75d75b24caf46076c9528d22ed5374065a062f20539eb8a5de02781877a688c72631e73424a02bb6732a92836f826643952f5bc5bd8b5575bb4f7ba9e351535a8ec1bb8c4446f7e9b77e6a09232a00aa68e1aeb3040a252bc06bbb0fb7713cd71aab0735e948e95b97dec3b3c74eb1dd7cebf57b151c26975857ab60c4f066938fb072057d59997899564fb940e13440da170bbd8457c6749440b1883d109d7fa4902f5fd3776a360664ba3767e7e2d092ddd63d08bf2469f1ec5377caa5f27df3b0ef5053061937953a98ff3b8cc3bdbaca27734f8d875790a06ef8f519d05e3839c25a632483e78036980422833c8256f57fa199c888e95750a511405d0b326d5608e0d7594a221bf063be4af25b08669bdfb90775f00e01fcee8ee5b94a3998a4deb684eb9e2b5ca799d2695627c9dac9c65478ad9711049cb833ce670441d0024af4358a171b5067b3e5bcc193fae4cc74ebe4bce4186a1127e1b8c453da0aacdd1be1b9c054587ee8ad1298b7491562d66e7d20ba2958655561fa61c8e38323d9a84bae427f06c38c01bb938e625eb10e97b55c5ec75670ec0bfc4cbbbe34f9129d4d67d300eb2f6f4159e03fb2c093529cc6465ac38b5219df42f8031a33dfaf3fa82234461159fe047dcf8c3c214b03fa1796ef2919043c9bf2466f2b1e22b12705692e970cf865af2f0bb2efe5ef9263ed3ac449241e0035cc1177bb5a583c53b89769fdd3d03d475454ad8c67e86f2d8b220391774759b49f807b50c019a8d8b0f5161a7349ef8fe681b9d214546d94d7201211d4f9ea3f2792120a5ba883183a15659c5c93718fbef4f078afe146110aee1deeecee4c7ccbb67e6820ef1d87b3bc89e0bb28db291ff98e382e90d1658af3fc57c408056b00142ceebfbd0209818be64adabdf87bce37e7c0a29b34962b7536ab084431bcf4cc57f5a4f3328502eaedbc2a44c02a149dd7e28ed6558fd8cbaee1fdda8ee0a83672b36f16eadb825cc7d511d7e312f86774f7da9b8673bb6ef36a379470c06b70502169d4ae6295a137e9997792fb0738ee5457a03962bb0f3952dc37bee0724b6aa0a635fef1778a0413b71d90a0a05502be3086068b8bfdbdf72b6bc3dd37f75e1efa1f0e18df9b15c440146a9f996e0bf13856633d1f4504649c19b860be16ee2456e5c55409b40e4e245835513dd9f8b6a4d8f55d970ee0144aa3a9c5ff4190a23f2e1722652388f4c8caaf9d3dbb0c225e8c57a9e51f8123e4fbfdc487534a6b3ac7fb6072a018fb74412b7b02d8ea3279ea8b2c594af1580095b2a3f69cea81c3623ce31f44196adf478640266b7994b2419a2707c6dd56f9895ea69a591a293fdc15e3ec4a95afe84126d6a2edda5a6468be94556dfdc7cd0484561a31dc3b6bb0e59189f602222b30f942e94a52af9dd6654724bf03fbd214a843ac743ecfae40332a7edb1a9fbe4eaab912f7b5add1217c13059d3c2f0fe6a86c0e60ac552f812db0b53aca665b8b688d15766d9dd005d99022efce2e5f6477106bb70b17fbb0d06ed77425585f8d84adcdf76bf3e1e805b38346c8a5ce519f0f564f59fb805345d3c72a635f0d6941fb5a3ed8f15a77bc339c46fc289db674f8c280677d74b6d154b96e340a13f22954964cfaee78fdcca399bf7df6e49f60594b4afef462eb289cd783f6189f22dc5134e3e8f3615a7847b2791c73cc851a9ad4c061b495f1108b6186009d7e3a2f60bef868d823adba4a8dc3c3c0ef609eecb6feaf6d2eb11c6588b657f66691d44316627e53413efbfdc6bcf14ac23fe0b619e8df025ed75f98ed17ac9927f2e2cae0a9417738661ed7e74d418302694e2a7037534eef2e70bd72c884de0f7b9b10ce8acec1b84a1669d653911115053784da4155d3a5b74fb9f7f804ecd9f3c42c88fc6bceb5b242008820c63feca1c0bcea5ca5836bebd100691a9fba0075903e296e6762c16335e81da6bc57af06f84fac8db44264493b1adde86b15df13d27a78af67f44ef0cb62b401ccb51bc80d2eeba82baac07fdd99992a22b49ef0ebf48280c5615c853e89b115556b1bee3951bb6192afed4382bbd0571646b1d10eed8f94929c86825da53dd1c38ead99b73cb4078ed0aaca11ad61961160ed370d608f494c1abe0cd739fecb966eca40a7a56d0407c10b6ef0c12c437a80d77e61e0b57c5c0833864191fb296a72f82ab95b04411f1c26f3c0bc7b4f0fc87ee4c1d37fe4d27836ecbb388e25135f93ccc785c2fd71e811b4b36b093823990c9995d87fd6f823a7b2e9111f8fa38af0cff4a9e407decbc6fd06e60afe9b4f9ac97339c2a245b7c93efe25702e5bfa3ec35a8b9d22f96ded934538d39685bb1941d704907bb3ea99908734672d5eaf5bbf9155dc57e9e419ef112f9a74940049904ab68f83e098747e486e181b453a5738a5172e1fb34fe034383133784e861f38bf3ea61d37d3e8170238986c93ab798d0f287ba8dcdc78fbd77b26edd161e3999b204291b3af54c65f81fc5c968acb70aa77c18cc53d3c8e98c79edc8fb2304650929364c100bb0df999c7edfabdc7a5d949f38656264181d4c763b6d08fee506d3a56de53f0da541075dcd9675d0d156c8b4ed8e1e7ed0808e0c09bbec23fc9a4038ec7f2ca4a1bb65d2cfe07784e7bcca478037b124c2ac3ff4b18513658ec6f61de8b80b01c6bdf63af5f40d76029f4a2380aba202e172897fcab0ce5309095882418b2ef7a3a78008a0f47f8e96696d1eec76caa98e7371c3e39190a03eaadaa21ff77eb50dd6bb25ced125bcb89449c27a113b655dd038a4e80f2174dabc61490dbb2ee5277cb10d7102aa78f830a5b7278f3b43964665af5db581efae790701675ab5089b4dcec26adfb66e8aebc5c15fbb0b0b87f2f29860be3183bfc5305c73f70c6e4b30ba8700316057b1269a2ee25dcd4e64504a4d59db571399489b63832779f08fc266478607de2062d6f5f94f556016d77d93011b872618fd80222b6f084ac04aa480fc909b81508fa72b188529af610120de8110bacad84845a8e8bfbfc1cc777af1025697beece336f54fa2429f10c2b9718e21b06fb5e30da4e611c49401240d4a1515f29e55de0b41cb4e996c9bb66b0fcf46e7b09518f9a9569eda7ea6585cc7bb919f34119b55bddc070895003cfc2dabcabdf8a8621bd447d48ea0fa7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
