<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3929876f32e42724a82965bc588b626f68fb933178c16fa993ddf855c25ce403d799208ca2521885509ff96650660d1a93097a4f44f399db8bea703d2f334c1daa67abe09a5fdbed4bfcf8fe85d9a7bbf74dccb1d3c76a61436bbf01e8dcb11a550bfc1d91cd7437af55399aa537d57da3f94625cfc3a3641f99444c35bd1049aa886f51f970e89931e8fbbc9c5b14f784129a32ca4df3387d5bd06a3ad48d157ca7dee51088abf3d00142395c2ec70fc8d72f6e7c9c10a6da630b9c7796da723bccaaa18ea82f98f9a2855372faf59037d172946603a44b57695737657864c599695f0daaa1a432fe9fac1145522392ea4eb723decc070ba1dd0236b270cda13e0ba4c96250d1b443efd03bfaf467d0a308c714a312814a156623170cb597815f2ef208a990c039186f4d402888ed7f62f7a829b30b80e2e1ba5d8fa8942f84f8eee41ffa84f0d744a95a423b2fd58c2aec6faf9598c723aa51e5ad5cd2c3de6e4a1ce79cdaf6396783e6ba20e4d81c77802c090aeebfc6d874efbe5eb33fa951965a767bd3bd17ec166680536b9fcb12b867f052570a3b245ec429998b443cbecf5d3607c2976ad20d9a6d5a84675953735d4661ff6fab15630c8ea126f6842e33e45043ddc1bb64a115122a8aac862397c45739ec3c674fa94c0aef7c2931acd8c7f0a2861127af899aead02e5119bcf6c95c3af4688355a81d795213a89741c737d2103371ae42aa7c42c4d492e65e34d146460bdd7e8fa1cb69d741495d48c31f06c7d1c3a85c015dfe6b4683eb2428662462b30a5ff2f54901b760f9d1ddfa745602b2baa0913ae33e146c00b5c571c243ff10f0c6eb3e74c2702b47cf3d9d6531632b284eef768c82124989f9726eb5ad02b38139d0c17d9d4572a9a4f6fe599298bdbeb586a7e314b70e0ed0d87dd05252d054bfa13ba5ad1210134254494f8a916f46c285e3897b153ea0b9d3b728ee2097f472cc290eda9a596d2fc3671def1f25d8a7f9646f94159cddf9482990de332be7079cff0e75ead598607566f57a49ae43a697aaff744568edcd7c6298237338c5583bb9f089c6685333a43ec4c42973c4e4ac56782c665e8787dc3b16cb7188d3628aa96bd8ccb691ab5c6c5c7f2967c0ec3156c54113080b3c5523cb81e37877bea8c25bdedf03c192b84af75ab9cc77d752d800cd3748f0ba9feb02dc519ebfb9d73c7b9190d1b5730be54ac9dbd77af35631831007180488e2c3d3f8057cc9b39094e295a601a962f3a6c4312ff174f8feb452174ae989de65db2dc9d36c10399a486a60bcfdf9ef13a808ce1c5036f0453caaaa9ff4b729eb3740f3d33fbe7ef87b237cb97bfcc8dd51b21812559f93c02d22bf3763c89f2e45ce32a1777021ea3819f14c5031c530ad87af3817033f0f840ba9cc99bbe0f1745657554d94722145a3e150ad66681e0a05e4c0f99f8e057a9970a71d4627fd5df067f243a95eefd1f118a5881e21f7d0feaf58d8c75e8dc47b0540e8ed33ca740e98b268b87a66d6a8a0e54d62b03fa62180fd9adca4aef766f9d61a283ca619e2ca4d590f14fdfedae907f46d183aef64eb1bc931a4464387dec858b90184898b3cd1e023337c27208d7ed31b23737169a25e4ec93f6d73a4c789f0f3a089baf1f9a550ad549776b401a8804a51b71e6e25f792d13a82164ee4abeb0e3d5a47cb2c5e8d52702724c6257081f8b9204193c486bf428d69d0581b95c858ce928be0a8395f62c839c70a4f06e368c62eb1c8adb296000b93a0f2c51c32a941fb3771a7637f7f94f758b1b39141a2393dfd8619cd9bef4f015a3b85918cef98a2ed0491bbb9cb13b07f10f8bc7d00acb9ed9101d87efa0742addc48af637a054227e7495f6818eb1e5db4ebedaec702a3b5948fcb8adb11c89a6b5943ac168f3c62fd1325cce79e4665317569a9d8ee0953eeb45a6ecc3948e1dc7265717cd1a6dd0fb09e10b47e16c048758de300c528711938f6e9b5915ef6b30c699def2a0abcd7b3da2d5cb26846de7c338576050e88b4cef62e7ddb1f786a64645e73792cff76923e2700ef14e6717b805cfd2cd07f35298bbad4fc4bf1b1256a797e43bbc677cf56962c161990ef9f84f78cd839c8ea9d5414925950831410c4b51cd4c87bbeaa7156519487439eb008309b79243ec212fbf6aa731165d5b8345a9be34a4e1af14049cd88de263ae809ea1704b3a4fc81271133aa7f2663a32058a94f05684dbe201c027da6d199c81fc12448c16c2a31c7fc28efa8697fdd509f3e619d72d06bd42a97c6049bb8050a58292f894dec87c0e9bbb28a783d1ed5328edee681c45678048cc62e58d42c03a1b0e735acb9967334a0d18e7651f369480547eb0005edf11707797ac37f0c25220cc92f57794005539939e8122286fa081afc6869b6fc537260c8c0d8a705129ced5e8ecd808ffd9c3cb2ee675fa9a803d49bf4ed1e14f53d08bc0b99644221d99ac73b1336f7184208b43b8d9f3afb5d0fb44946388919a06e742b7f3ba5beb8bbac4ac29a964d57b1299deea68ac30e952b096dbebadcce4ad3a2eee118e35ebca1c967fa6b10c6593155620675c72319b7d8de6c81d79f1e1e6d32bbbaa044e5ed677a259b244425451ee403314d54411e9d769e7600e9b78c6cc3c828d0a6735b47ccec37c26da8beceb95dc491c97d7c6a162c64bf9baa4436ee75cdfb350953cde58dc7f39b2d694fcf452cc3eabceed23171b2d8d39412eb63f3e24626e83f2af248c64d2c25b1414c6291de83e6c738bf204bd717a767b9b791328e24900f36ecb29e84dc6a52daab226f714a24ed70cedfca4ce5cfda110cc3196ee7fa14a9792d5c6d708c11c1ced224840a989a00bb47aae0d4a9775e9dd5cde9ed1752171af550e04a8a2b38ade3d2e1b691307201d7cb53269c115875f327bb846fa07f6d83b70b308b2eec550f19671d0ba4dc35b226a204cc323f3105308447638eb7e7b5ac96aabd1c057033bf65b9921f6547aed080544ddf523a35aa62c34ca5404269707cca5f082f40df80a6ae1e11df2fc60740ef937a94eb9b5d7e263cfb937110379b0e46bb96041516d5caa7b1db62874ab2d07ee30d727fa6424721432b2f19ff6d78be22ca4aa61509d6687da72d3c7329ec2398178fd042f9d23bab3b976d150203ca3eadf5cfc9deb397eefaf904583f3af87911f78ac92147154b668f73718465dd67c8c9d31932676e00027a9e20d034eba648e10c635b038ffefb84b5c2ff6500293b7c203acaa14672e8f7f17db5debda4013897efc1f4fb7537689e0453aa49f296b7d59eb1f2e0999fbc12a9aa66fa98599d050e9e5c1c313e523e65295bd58e12a26f8af65d3d1933b2992728a04a8af1cf6f3e1bf479bec680d62eb826ac67a1ee66fb4107bc180320a51fe193cfb83ccc8286ce623109f0ecc4710ef6c23bf89d057b81b61d28830143b625127227115e61d54de4b74c79acd6269e81bcb9cb89980a07090ea1048185078aa63b56c285d37a4619b8e561b99edacd20fc549c32d056c998a3f8345381c65ca477026ae5cdf07a53c6278246dc4bb5104e1bd3b0a0049bd6008db17b6658e0f639c56865843498f42dd762915d1e2f9416c879320ae48bc50f933b45ff02e727671131ce953e4b729c527b3062c78c3e7b29a84fd1d570306635e92c4f7c9c9bfcd6eb6bf0a5aa60d6a968dba2004a6244daaa58781927496696530566f3e8bd3d3550b100e661ac625e52e9115a03580130948946aebde435e6cea701b395e1a7aca631d5c48ebbf74f11d06378b0734a418f3095016493ac198a5f1108e52dda77b90ca341b9e82fd723e5e9c32a9c31a6419f07264d7fff50e219eed08151ee48c5c33cf68f7120c40e8ae6dd40d80ee31c9f2451a9e96598f1c90221e7d3b85d11d2a41e04166f66bb061eae89d550f4349e2eda50064a20812764729127213680b07ed6f6f700fc877ca3a6095abc23ba17488caca8fc6f587b21eeb86194d780054060225815ff0a0b78cdac263205584db87a3acfba911eaf0af472bce09da562157d708036f5e5ac84a4109f12d392bf5b4dae6d896a8f13a3cc8d18d5e21c4173a28951fd845cd6594879ca5369fd2a1390647c06c4fac74fefb22738a6029ec2be1634728c63a2340a888b579cbb934edf10680e9b698649a96533ab9bc3b1825e7d7b0f0f15114ea57fb40e7c25215f495f57c9e8f870f795a2e7eb618ced01331f324fe1a190a2a11bb901658e34fba4fff851744f0a029841f8c9df9cc49ae354592d6b1342bcdc953a7f81b63b16af907b36d4c83b276f9dd2ddce52c38e180f32c790185916311fcf611b492adfe843dddd7a09d77b4f873b7411184128c18d3c449f3ff6bae7c61968c2de04765f85f89144314831f21d77d113139507873bb11a74d2ea6093ef5da4e4caeca765b7647e040bd463be0cb7e286ec7297d5ed22d86af6e93f805555561bac49785fd5552bc932cb504a664dcee0211168974948fd56bab8359e52d720110cde43967b0b8e584197dd058215d4e2a48431330b69682ce9253ab73f09a6035c802e33f28f9b8e34e2378fa6e1f4284190e619909bbf556ecfb6c8d792228e6e91ef196a1a4fb5049cd33b09c544e5f8589d69e18c4270efe75f340a028b1a272f7ef1e874280689fc00e9b45bdca574b5de5955abbd190ba251e95108b0b2db72d341a5cdc46f5b86e9aac5a13406f437c320a56df97248579bc3a04574caf7e620afa08c4740f181c585ac1ee6dd23c14636fcbe0800f8e82caeeb7ad61648ae529499e2b92ca069223c4aa662f0e37ed132458c40e5a0d33c5dc4cf637100f530e61ba3ed8f22e243819f97688fcbceb626d913d41892b55280049cf3d8d21a12831a9178d6fb43e57c02dda274f5dec54547d910da8d4f3e3f012504ea83e0ec0b4f77bb6ef7b929b5aa3c619e0e9551d065a7a0a3e69fb276bd5a4a1cf2d8c4c1eddafb907af52f8fc93b9a214d0fff20aecd8ef35377d819099783671a7d95013b85551e4265c3fdfa5654f4ea4c857b208aa755e2749ba326538927a519d66e4d5b62a93980e71006b4b8bb1c20c65ba4c4142b41e55d9cbfc77d9822a28aa25d162357ba98351fd008a9a7b979210c3822a96e9d9a871899f4140286fecb7283cfdde2a83c6443da813a2c9628ee9b8fe64e89f78bdef5b67463b7ba8edde248cf83358bb2c3e794ab362383ce8853c9a899b2a9d67e132f6bad67d163fb612325358541c6877354b6d7015e02b0fc21a5491176f17a316a2b62099349243fdb9d8f55ecb337cfa4bd073c23b780b7b75ac17941910ed57d465ad5d64e90520b0576e564c68e42e862452a0a7a0f8d50d3a7261f17d883430a25b5ca66945d67995ac0792d2640cae2d662d46da9aa1bc33ff4445803943531aa5d6a718f2295b4c8961b64d3b3251b8af7a760d262ca55b55dd83bd3c58a821bfcd56b3abb0dc1016ef375adfedd6c0f00d0f926f18f91f48029daa83e2578eae20a9c5560335bc1a7cf818c45faf894da6e6d5df56c6e85f74650aa9dced09f4252b27a442bae5324e6f3c015dd254696cbdb7757c13d33014182c475c313a88715dd66f0b55875877475a61d84f62d6d67a737c48dffcf2024e4dc742dcc45d5288906e01d3c948f08efb5601236d3dbe8b7eac2e43870518578b5158d3270268fdd4cdcb0f9b81f9353421cf8fa54b66a7f5ee9df6e410e817de4e26c35e5ec9865764416379ad07ab7407ea52c8567752ec21b954ada60a86df9460fbb5d6d8ee5016156461edba480a92ae9b7a4047061eaffa771af064df5cf103f1a0a7acd7ed195141684cf23404dd48a61efa38238d2af390acfe6e6690a70bf952bd8f2dd288c3e9370a5c9810737e552098842da6ab8b405e50dfc31061f2bacab99520e6a7437ad8d72f3290e64da9f479d862532970d30bde35e25c5148835396ac58c1432f0b47f99f92aac1a08aab349f13bcd6308e35e0cdee5ef915cd686d396e28838cedbab64a14aff1c49e6f2bcc288c89dd1ddef7ff71b7dadc62bf8cb524d3c410b269a8ba62a3cf586556785fd8a8d50cca0a1688fe9cdf085c31a4c22b1573d9f0ce5428a179359c8bd2c7548ed163a831de76d39d23a652e39cd94671a124fcb402095d98aab631b9bc6aad3cd047716fac557c067d09ba025e8f85a4831f65f013c962cd061a7d4f75d01bdd5b7c90b990906aa05a30f1459b6daedb8fce5332928bfe8c0500dba26b35887384c6a6082403749ce5b164c55c084f73d11bca3c225f8234346a81d563627e3d43be54301320bc5c583f79d66d04d22e4809ef26bf3e5aed82b950c89bba46d08f1c925a4381a1266b842adbbceaeefa40a3dea9156db22175ed3e9420e8c443f0f25127046bed5617701d4503ea9f3054e9bd7c1595c3be3f419649c212026dc668044d56c1a95647bfc00dcc3df093a487072fdc4b73c86dcd2dff988c14d1dcc7b59536099dd161041053c4c2d5928864479a87bf78ff2af2c94f08055eb938e72bd93080842fa3f45be2642623628fe2b8b173da7df2de5cacb0d2dc756513bb8b8b01d82517bde55cce7f031173d302629f7dcfc49dac323d53a494011b023f12cada2ff54b94dcaa856e3fb3875f65d027b72cb2ebc8ece6ff78870d4ce05f7278f23d7b40dbb723a97fb79fdbaf359ee3d069e6223f9fc15e79eb51298c114d29cea1d38080c4659c4805c12fe0bae1ad0f1726b39606954f82f4f9ef810ccea4d23a014c0721ed05938771ec39442411110615884417b8c0fe3a0e8b358f8f81b3952cccf93c46b4bfbd86a75d35ddbe4af6c3cce93be1f1800af101917ad3e930f402b77ac82805e1ba9c1aee89e72dcd65bea99bc446da27d0b0f4b2d7fcfc55ff5131222cf94c6acadbd160722ebdc66dcbe7c908c3c4afe54d4c89a12006f6c3066d57372059083ae3a10a980e4d5beb989e04bfafa00fdab7402782f0121b6d7c4f0f0a269e274058c359dbe556711a31c5c382d10d36b9474ce75de001d8568fefa9f324bdef42304f906f71bfbd6ca36ced2e1426ce20f36a835dd218a893f130dddf6c6efed8b8f9e1dd8ee35d3ef37e63f79fa8a026cbbe04cda6f28be8042bdf066778dfb2c9c7cbf1ad44b6bdf25f49ec58f16ca795512e0a72f07967f2adf7e2c7fa3aa804ce2c0bef4c50920d908b9f85716a3a9d4038850e4f721c65680e2faeb9d7e87ea49fcb7106a058d4fc825ede617244584a36dc8c308454f81e54db95be7e9597dc95aa0581791b24efae61c164d336045618626acb0a399dc891e4be4c7e1969a109403da29ae3c98c06259b08efd7a657033e6278239b48cf00c7435667d83bb9bb9da1741e5d31eebaa2fd0db81126a39bfe6f8bcc6c6dbe4448e237f825ca9de22dfd45b1e60e1da29b9025a759ba75fed9edfe1570f2602b856f10ec832fe3f4fe817bff0b0d64435bb16bee22f2a98fe020c33ada7edd31384fb19144a11545828a757f116fc1648fc6810ef4923ef28d256a979db4ca96cbd073c58a31a30de0b707b02198a5991ee4624cc876383f17c387ba92cb41b5286985e8971c0379a602637d294c8a413a4573937d2dbdfb9627ed5ef84670626ba554b441ab27edb3ad6771c857a1f24d6ce50b5ba6adb7cda16a2932c759526b37c338e98983396bed6ba3e2f7a6c1593a134bee8a032907a20b32d81bb69801f8208e94576ec07e9d010f7ab27157cf482b9e576416ee28bfc6d7470ffab3cdfd8ad5c4ecbc17f5f7ad71f74cb05f85d411f6303fbed690fd2ca15f91c5856875e56a3a66149c9573d0aa2510297b406434ab16e15c2d20660d9bf96d3d8367d65290c18e7c3c4d0b73847b3cae4682218e3edc66e9b3de7728a704b7e129192423d57dbb6e5dd870c9418bd890d0ba525b6106142cdf355800adebec51834ddda3acf62aad1210005fdb074d6e4e7b9a8d20a3bf51888d14a0f5690ec7e86ee0de950e0fa3e7f3cbf97a9703229fa67d07f215e6cb162c71dca83398754b4f38bbf80361d57571fac72f7903ba17f4f8d7bfa9681872a6aedd69e6c55e7678e3da7d2daa6095f90647feeec6e7ba0be2951b110ad872879c24edd9ab0399b0f4a68f1d1509b5cd84fdb955a76988caf33b74a6458217994a3f04d39d0cf889bfe55debd50bee333d5205a5ed76a7d2f8b2d85693dea204bb313bf2d0dc30c172206474be284ceabd8c7b99f446e3d5e9c632b56c5d1a7a59ee6dfb3f70b6b78a2f65e2d29c154dc731b8cd047ea30d96f388993f51adb8ef639e5cb2872d1db380fd664cb45e570cad3c578f32d0f769d4a78cd36822791241c1f8572df7bec68815940edf1939a149884ade5cb073317a0507f7cbdd846088e100aa174a98a004c82294053621ef4a19d74fa3e19c834f18ffdf689c653cc4dfbabfe19142edd14a3a80c685a6fdef5211a0982d2396fc27f445664893e83cd23658c941ca3adca8ae9f19d1815bfe499efb481d29754229389b437ca7de3acdcea114224f3c21aeb5f75d6df3959d54988492ac42b68569f919e38fb23b8bf0b7fca4ad4d4fe584e3db7197c046e763a225dab673b52b06a2065c580976dfa6ce765ade5161502d8c2c123b0c2c0ada37876fad5b2f35ba1aee6474bf9dd05429a5c34b0e332854c484b69fb5373a5d043af9011c5e007b077f30444544a31ca18d54ca4230919955a7582e36e58c4f67a72c6ad695e54fb3e8c44dc7fd294bf58d483398926573ca6d4b5962173b1b1e51e6aac671bd9491e783fa4a3a04602d03dfc925c67de97d9243e6c5102ee857299fd3fb8b243c0bb1d1b915ca4e8985fe9554da67811cbc9e00d3c3b5cec9b4f120805caeec0ab6b8d5d52b4c4a3cbf37d23258175ae707db3bcb9ef68f7244ff7584a16b642c44cf28cdd5851be4ba901c0dc7115772c06daf9ec429abd0c22482c6d60baa7512e68b0ef5da33a496f26852582804f68dd3a10fc4b08e46919bfaa002c274dc3e93c41ce729b52d706d1f5f10e82118dcfb9a88f6bc7186ddec9c2a70d905d2351e81ed21bd50d3b0fb61d5897357c1b6f6b6cfbfd43dc00591a4330ad3af252865c9c2a859113f65126d23adba2dd20043b4524ff72f64051ac3ef68e6e58891ee2caf9c8c010f7da388866c1333b2ca43e35e16f72cf22c741633387421bd2628be30d5b560060de468b40002c9c85fe019c07e6bdd5e0101eceea8fc103dc489fce65a887a4661ea50515bc0123728a4f6d33b53edd7d062a1d78c6237120e8a7439a7d23f88190d456aa306a9567d3b8455a42f8032d5e20a052489e64be575e1853dd09ca87e79e8ade26b4d271c3ed4d0ff4ff7b4ba407db03f522c4528dab0facd7d7fee2b81dbdefb1d12820de5d9014309c19cb9e6d1494f49409385ace4b49436c1ed53ec3d7a7e74ed2bf2d19823cf07a5e5365ab2b6c7f7b47618026a76da60f7567df633f08f41632b2c04fa2c959db86b2401fa563b7be4565c45c45400ca42b49aa68975ed6cea424fa27f26aa765d3e7354da213d66dbf349e84a3aca78355b6a544fa0d0f9a8b034637603d9c4b37a49958fe0846436442a795e78ae9218ee9931de54db28e94937bd944537cc4e15fb05407a94d14056b6ee0085e229bb92d8fbbde8823cfbc220c3b177345b34adacb94350a6a377fdc1acaaba79abc9eb6a9935416af959b80746d5cab90fd649c19ccbea8ad08137e4f065dc6f1ea0b83657ec3efbea4d99c1859f7412a564a14341e0d141fc086be956976a8a9ea8ee73d5e621c834b67b6df480b5bf110875f14827717426fe24dfbf5f898ea177a1fc499c4facaaf679e764b2dca503b3d0c80a432dc809190fec5b78a1d8e823782f174ab8c1c4d6ac6ceaeabdf55707cf5a96dd3fe055d0921b4f8cd978c4ecd5637e68b84a3473cfb2b3595520f59afae8f2eb8231d8b94b58f8db81d5342370b3346a2f24a28f7bfa71210b72de0efb6fb97c20913a115c57bc668522e227660111c5d48d39e9398cce222880577ce1f78d8408abdc771cbf5958360b9c226f747df653b92bc0184d8f121810d467c05e76d51322d4e401c981085c1d1c8d436865f8a0b5d301da6ce64e34c17422d1600f1b82618a19d731a9b01cfd7fdab5b585c76ea754d78b3b868fe84820c539c18a33b57f8da3037c44dc9acd3172b899be3e27ad7acb648088d7690360ba1f742870fff115de78bd8875c72ac1c3954a46f39761f46e6893c3515affa43056607ff7d345357d1ff94f957cdbb464bf25961f230972a76bf9c5d9b7293fe501c3a0dbe9fc73ba73285053abd2ccf17847acd5dc3c6820cfcc21ec86024fb83b3602191c4d5cf6fe86e86e68cf5b5ceaf40d9fbb551c789600c6d72a0bf57d11d4b2f4be136bcf7567bd137a0d2c26ce2dafc0c1eb29bde646c1cef6db5d2b390f27952886eb1eb8528a5d543fac74b7e327d90f2e78c706192150a09656ed6244bd69100961b275ef5e0a0cdbe91e927d68392a2ba188b2021e3b87e33740e03121b1f9b0bdfe912999deba728845dae609560d0e7f24a1fd6deb24d6d98e6857bc9a519dea854440ff8d33adec64f5eec6020bcb88b42e0789742355376a3a4034c6fe0b210dc6fc68ac5fb51228b718342e74ee91e583367ef8af307b03fec1a1739f57dc1148e75c070709c3493d5f3b3aeebe89efb10221b203a5433bdc94b09da35ccfcc1c7551d1b86bde1e38982ef7159634f79a9efd4c84da6f7e56e67ae78bf887cb9e550a0f045358bced0ad8a8d775a8626b6a9bf9a4fe1824514f58e6aa7d621a0361849fba4b89c807e669daa0b85c4c2e884cf91073f4e11cdda2c05dca20ff5d9d1a5a859990b4fc82dbb8415a25f49c6aab3cefb424902403843454fccca5d7de5457206fdd04938478f0e317293122329c7d8db9f1815712888c562bdb79aedccac963de07dababf0a7551f9f8f0c354afb9bfb31e11d355f87ea03f73c1a45349799bb6769ef46d4010e987692f9c232e103c9533441224b4ca79d759bba85c1a37e115e6abb29ed00ffc38f6e645b830f83a9212f43c5b1445f579bb3da4eb737c74d9f0d5fa2b38a455005aae665e2bfd0cfe88618c4654fb7e8b37b76b066413f7d02ccca898d4d434da42e0ab5ea2e76b72256fccd3bb360a63c469d536bc24a1d285c6ab6b279f6c57a3b0ff6a5a4d1f50f0f110b3d6365648ddf8456d5803dfafa74c9644a0528826bf7ab40245a5568a57c866fd8cc8d1bca365a907adc7494c54fdc38ba1f4c8bb789edb8c2f2f7e56751af62ee742585625b19954bf3275bf409e2675012776233b085c37f2b884e2c1c2cc9e22e99dad9bfdaa3b429b077d9cbf8a9f5f27c3b387df8f8e2f435871fcd371839db9b075aa443d0d1e05f2698a4d606012f66bd06e3e8d6554511b5c37ebb85eabb9fcaf3e93873a443284ac84f4369f2762d3089d34a01d0978ae8dc66d3ca85235eae729822c90b7f79298f0f6eedd7b658cecf4564893c711a77080c7e3d521bd039e0a7f69c28cda2bf469d42ac52b6460a0e2e7ee436df483cbd511f4ae49c2223a8e9f88f7598b9cafcc45086575de49904a6193e17765615c0bab17ce40626385d19d22a8be3431c06066ee24a45debd7559bbbed9a79c642d9e25370b7d85f1ed1d8a238fcb047cde2f18fca1afd79580e39a94610ad91cef2de779cc7164c2e2b8f40b37973e4dcc26a322e5de0f754376261db41c3560c54d19dcb4b8b044b9c6ade828422611dee1ee4508f199de72e0b22bafc0c05da9dfcd67d266d046c4d5752d6adb5f92218004a26da94eaece7c920dd7bf6ba4430699c98d1d59e7c532c622aec521243e85a6017ba7b63872a2fee43a96f1a0bc0dc1f08620f27dfe2905de8b6b7aa60620c33f10de6a3cf1a67381055b19f47e828e010ea1c756e135dc6097628b512ea5eb4e73f7c82500a4a349ac487beb9cec87be8d7df69298bf7254a963ad88c6ab55668848e70309976205f34ddf06c60547abc5e3dfd59fab1a9fbbe3cb2ef77bd0b1999ff74d3952f120f30fd932ee5326c1ec0530b194f899a8335790964650262be3ab53ed19f1f9ec4e7044c7af82b69157c17faf32b4cad1325d4c3c2f6576410f70f398af584a6dc019e4f483c21ca529768d0df7666b0897acad497a79ceff74b1e63d341914f5ecf42c19abf31a6301567888bf14bebdf661bf7517da8463a29e63a6e562e3f0cc88234b7a0457b96ec9807a4d7b50b5bd33b40462c9d2a4625f54e6b1b8610735ab7653c2440537f10b10226d4e6ab57fa47db03df6f7af60eb4db12a455426489abe1efc3d6c54e82114ade99589e4d45b531f508ab7948fed09d6a930de776085aef360da55e8e12eb4fa2228da42f0297904b662a15e09763322415a5b2ca6690168f1904d5e8d0883d1e065dde39f97053d5b323dd8f36dfa94f7209be9030b2d8563a5cfc1e1df22c18ee49a1c185936f4eeb2eccf74ad277489c379b00a70bd8f92c1740e19a0ee6f6d1f28d058643e50130293ea7ca42f3153e9c38bd7e44661bd70938204e64813adcce90d9729f8e39afef50eba1146132da6454525c0b955940d1c168072bfaddee9d3027bbd9160eae9b3eab55f19712e895df15b275ad6e4881a2fe9a694521f6e16d2bd18b2bab10017808b0d0b140119bdd0b4faaec0db25f38143b8d33df9f6ccb4bec6588b203c07ef44c1ba3c079bb1a5a4d8074627e64222cde983473281b7a978ea033cac12ca845bbca1f5cecd406674b884d23fca8cd4a01f35957c19dcbe345363483f7787f0110190d922c8a25b36555cf1d6c85059659ca7a9dacda13631e469b52515cd548b6042097419f2b0ada64bff4d8080030c2dd505554e38912fd891403f6d321c7267f909818e9e8cb869f597f87e6f51b09f85b4b426c955a51103a92ae2187ee77d54eb0565a84fddcac89da89283dbea17b7e7cecb7680d6280736344d759fc3214572782c2158d1771fc4d3402a1c9dc33559de4322dd33a5121c7a49cdd2d631bbc27c7446cc848cfe2be5d83cef0277285110f3c5ef02d976bb89e1c60d799aea1ee704a94befb008053a1b52bc9426bb93d39efed5bb8e47444b946f604809ae157e380ebc1db4a36944c34fe70d012f4d1e6655ccfe6b283828d94e236eb7e28341a4dd6735f805c7c9f75dba9265d406bfe89614fd3c61d32f6b0d03ff3327892f45261da48012b1e33910057b62f762996ce9d333b89767c4817cdd475ce86d4a8d025dc1fbf34b08e446902a45ea20f15b8e0605f5be307b06780fdb71b4dc6d295fc5bc6513e9ac52860e4bdc946d8cbb436b1a9a0d91740c1e376c137e620666143f2ee3f0df0a4a5edd3c2ac88d27dc3ba192aca247a1fc068f554fc3aab62dd852a99fb4bc911f40a909d068a8234187dff6107f09890661f7ef1ca6054ab75f807d216758c3fd5b113aabc9c64963287cb2a093c83efae65bab140f0aa296f4792f2bd6b848040fcc0a656d9662b171bad5ffa9fe7d9d23402d4bd9b524d824cb9b58a3b7e3ac7bc3b4bd82d8d90cdb198f1c7123590bdcf0d503bd958652927c6bea876556539475a72544b417e56a74327017a006f7129354d8dc498201578ab485ae4d10dab161264a70c21b3823813c73afec2b1fb9465caf0df94435f61d5c301c64ea414c3568923a8d2e28e646d8cbb63b04b9f4a5b724a1c560d5706dc7f0020c17916bad273fdf90640a84ce9e2a86817c4b301d91242b9fb6cf116fb5580128a72e5ce5ca5f73538393522f3886a912892e57c563a71b0554a970b3c3b1b2f1a8573b1d43d332ff2e52c303f20b3e73f2b9001ff6af9c5a48b4c4a916e2bf5ff32be879241af8678bea25022044899fad7b497f39917fbde073ad67674a4f334f3b8c33d249cb64f682b0c9ea561e67eca9931b7de392c536bf8a3973e4cd413f130e357d6203892ec72b4e175fe9876f56e3b36673b6a0f4e115864620f9dd2b6dccd7f0a1c2433e5ccf139a25a422d01a583e93d10dbb14aad15f14e9e1163e9fe4936762588eb2161fe830c244f17d8e712f63d40b0c966e71516a3620995c9fd77d8b61bc589a3a4651387e5f988b60da58c85be5bef894d1a1001b9229ac60f56d628be777678c94123ae858026d9e258a477cadfdfe8e55890f7777f2f7d6a30f915fadddbe5f3b69a22a4ebfc0b45bd030e9c5ea9a9774750b88d0bae834217b4b875463bc61bdac84e16cd3acb73eea2092335d2dcd0e9d7534f9bbbd28bcf29e2c8226316e2a4ae2e9a862aa302b962037b0feb812e178889397929e3ccc410535990bcc0c8252de92933612191d9361add1ee99b3afe345216b93eb7ae4bafe2d3b661d107d4ad6306e0167660daa8f37c691c5f9af2fe751e265d026dafa7715d1d2b984f7824f3e647a9cd55df72c9b865f366dfb896cf753e050beb3a879b513606a52ce6f03c387478b77d945d5f8272d4223c1ad0863e74b4986c2987194c53c97ff84686bf857dfc474e7921e706c6b5042f6eb49f79c48d8fc7845f9feb81c57732043b670b9e6544695f3c07f54bf889a304635df480220664eac2f8c349226adfbe6e5b0a91921db2faa96d6e2fdb913b895ababe00165a7089b4885a0320648afdbda82c6532fa2a8c2e08cedc0881b71643b093ecce467ab2c20a16007211d744282113bc91c8e041fe6e23f785b43d06d451f108193c6ff87c18805ed1d1370f5b93b289f7c1cd61a929e1ba3aa03ae1d54079f44f6a4a08484c84d4b2731e0255beb8972b9d97914aad96321abd24867a846b9f1609c72951e085aa868fd9d52df9a730c1df3b676ab9af361e8425bbfa531dec961ba5c59dcfb13e97086eac7ffa81035d49ee797e5429e3f0fee6911fb598fae4e778320b7ad21e346a5e3f74fe6b1f460b33335a0e67fa9320e02f7abfa7229c64dca6744637034c285958ef101c64f79fa7696ee3819a2b2e53cbb191b0b65adf0a3be9f8ac791da01469245fb336f5aa0a7eb21cc7d24dd294b503466d83172a1b50a59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
