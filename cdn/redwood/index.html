<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c62645329488cde1b4a6bf57757e5977f3c735ef4aed8cffc27df3aed95e6fac6a01c482dd9557921380e070c7a3b7eed01d7763e9bb5da5dfd3b63f8ea0f98ab5e77d738add69c9e167c4077d386d3df2fe4bfc627ed1b96dd3b44df53f1a9f45b61245346ae6ef0033eebe516710423173de3648898f0c0b3052780c1263aa49715cf2a06382b70611ea7f30d1ae43fd58dc47b85c4008b4a984aabacddc06d38713ee99712ec64f8d8c152055f8056e6b2f689bb44af210b1baf75924e2acc8a5782a52fd44ce04f3d34838ec25569a3a65d7125eb6583c7503dda1afd91b866b0c7aa39fd8b172535bb217ba90c9b2601bca233174cc4a7deae1f8f0127030b60b36705872547746114ed3f8e78341dc1b4761431fe384deb0ef1e2f0fa06e855b3fed48e678badd9ab9bc26efb8585c9d7f98397cca11b4dd826610d0275c3e8afeb7c4d1ae96483d0390eec646ebcebd67d168902cbe6756545bcac741b155d7caf44d93edfece293b311b96bc4723988995393075ac13ff61e0e8845593ef1b18631e4e85d3830aa090ff6016a7b403738e4771395a71e470d6e8cf3cca4f61bd49b9463842ddd70e066c5a6de104678eb28a0794c3fe22a806a43af9b38c575d6003fe74e380dff1092d1c06a93a081025d4d9efe280b5ce9bcf6149a909658adf6dfbd12f80d0e6ef3004a7cfdca7a72e307656d4b576d0772e02341d17312cc57df08aeeaf71ddea8fb9c18d95e22ea0c5f91728c797303da53f72128de1b0c42c826461c7f8dcac7738760100fac26dd8973640208dc4f2c7ffb647fb7e2c9d766e7090f26a4acb1e56a2be60fd532ed97e525adf942129c56fe6bc2c248260e4bd54398e4e8ba9530649118eacb2a1caeb14099043a2caf29d479a580ba54bcb2cd9c5274aeb2757663b696252702ced15a35984184b8727153db6e9a0b7f27d7ef94615805cc62768766d4a67783801addd1e6febd8d266720d1ba46e719c3fc9617f0c48a047d2805e7a4945536fd28ec50213724b5e570f3cac2c7c6b622c430b3026c480e2aa8c227c42b6a47a3860f597da57d763517a31077d5a37354e2590c787348bf264ef9ef0a73ffaa8f0f84e714026ed7c176bd7095b4ec2f83bd1a97e37f48d52eba861133e1802aaefcd24f67cd09f6bd9ab71e09a962136bd9bc19bbb63a624357e11c49f6f1bcd1545c0a83c8a622e2851bc430726804470a96e8cd40dda9964b701ff7a4b321e703df41d8705555d67fcc99d9dbe1cb5ee11b3a393826ce052568e7bdc1d6f2080044462fb157054704eb24fc724f762cf520f2feab2840830021f657594f1d35e15ed9b3106678e71a012a9fa894954436d5278278224935238c4d0e51abbd950b099da62e155706ef8264314887f0958bec8af38e40f67c531c4ada1e1d3315a0ebcc07270eff4e1a236ae27d4877456598aae4d4c61935d6cc8a378ac412a948303bee117f6f2f94c2c055e3d5b8f73412360a5f6032d23ea1496b927426215bad84c946b33e633e5214987228703a88cf407275ac3dea3e6369ecf05f06f5526cb2c1ca8f1bd77a46271db41b6ff7aa1d0ed695d70ed15801c1f9c9f0c2b14297e0e992ec230b789317f60c623f012de501c3c1611ab75a3fe94749c76deabaf9cc2aebb0a49cf21c798cf638c095ce6c9549472b7a12872dde4f1ba7fb491a62be470a4a33e1aa684ecdac5ba8a7a2a42a97ae558aa53fc4ef0edb8afe3449ebd66a5d9f8bcad6392f27ccd7248ea9f10baa1b97239cfc24997b01f05fedf7499fd2688c5b57f3f93e8ed8fe1ea83ec08c4848595ba13125ff6c810e28c83dd0b67bbb3303de2cb24d0a0f95de8224f69763ac942da232cfe7a934d4c8240aaf43e3bb6b0c03ba7052c0d915ad800cc8a3386c6a083b3e3978be55b420ddcf3269888c5a440ceaefcd27f02f80066f8a97c468b1cca42cf57fda5febf73ebc1f6ea0f54ddc6fb14687deee1f41de6b7f57f39c15d223e1a6a02b9c3a0ec08f24ca07693532924455b0c1680f857eeafd4a8586c2313d3876e3f5e2de0c17526fd738875117259a2871a67b2f5a7e2a4e784a2bcc1e257ec1e7d63249c1e8a90ca46ba0e6e26ca1a61f541b3fb3de05f929ccf1bbda9386a1b1eceb47d3ff010bcf1b571b4ebb8e1a873245bc167aa9ba99b484f81f63b4ed4e290cc7cd9f0a95970921edc8e0e117340c71fe9e7fb068ae7b88f54b7348209ce8939b7451af8b8b70f0350fc548a73fe4d846ba634265f6f4b12fd2ed240f970454f3b7fc513c2fff5a1a815f6f5fee6e8ba9757e2e5ad382bbbd1284bbc6b4f4cab2e97853a3581b5c9b574f15d78249ab4e5312aed413b8137c684f81f0796dfbe209a80e25094af3c614658e7b1ff07d04d6b171ebef5dde68b7966b1f1237f00f70c7f92960fbf6f73ee4fda83f97ccafeaf4e7a3b284eb1f1277faef6b7e33dedc68124869f0ad3771b737908cc2caaed16cd3ccb7dda96a8d8194809ac4019e184117377bde7ced4e1d59a9b04ac53368066038628dfe659e7b6e65e5e698c7bc4ed4b1ece1846fe289d6c543a07a4ebda4d3dccaa0d37f392adaea5d20f167ce2b024c4244eb879e6eb9f424a2a93b354c44c816e13f24cc770345cfc497c689bb02f264cda1ce033c96d2f794161d99cbebb3a52648eab0479f387d70948755793c3fa929a6de48ac35410aa503ef85d5b6272325d0d66d19ca1ec7e713e723d39bfdc00af9dc419764ae2cce918c03054c4b7d8d24da73fc5664dba03482ea7c02dc7cc4c90143c3fb5f090620cce5c20e2f7f67ddbfbd1c5377cace27de085b3b046ac29c2b50d5ffd095440481b2af51228be0c3a3ef7258e3243f0aba93f2203cda9cd4abc8d5a7614847c0e902565ca4f46c97fb89867da9de749b9a61f92c8c7fc610ffd2786f6f2e58c9ba32c8e894f896823d22f620b0583869d109cdf1313346a2ae80d35d4002464547280057aad332ff81f9c22aff959b10cf942a63739ef8e493553ded00b22ac81531e6fa76fa029025bd613da2ba477cbbc8db38bff91686fd40b77960e3009ae6e6eb6cdbb7e5ec244e3ba9c994c87752ef771f36eca14a5832ed0737e76d58da20a99ad1cf1d14a1ddbf813effe9fd1d8dbb6944f6abb75328845931c7328b539c8b1172c1362248fdfce7a9243bfcb0d9a74d4947999f4344b131864c58b9e2b9e590134d8932ca5da7a8b7e811234b7d21a6b56ad5e22bf736b8585bb15562ce90ca77e5e91f98597dae45e32c87f3663025ec771116d2e5dd014301dd44f1dc2edacc15e43defca06c2a597ca1a83ed2dfd94a7fe537f6442e4945ee6d015bd2680581977e1dd86a28ad0a38ee328d016b8fd791c8beabdaaae745d4f186daee80501f9adf66c94fce85d8ec4dc84df3dce88f38f28e8e453a31994987720e265002af5548bc947c0d45894a394be297d0f7141b2c6ba4ade416c8e893baee8dbd3acd84407d3abe9666923ea5f7ab09e1f7395734470d1441f7c85ceb79dd5fb42dfdbbd20b5b9249f5076de83ccbd0f3b1c74bf003c0a03a825fbe4b7ad853f93d500783a23b8531c2294aa186ab70fca01a485e2ece3e71c8478470c7f5f329f01f527a9a0f6410d4ce6698f6bfdf688063880cf3ce7be523f5659c19594f0f5d76804a67ce4047bb125d903ceb0384f87e4d7656e9002c3cf3b7d4f52a54d8857076f1d43840664cd8b42111386f5a645dd4cbb42b7a648a58aa9e69a8528321eafe26259cf12ee17a7377625c4af434e4d9a0f997df14b92e9f56bf06c9b3d67d9f8cc43694e356f80cbbbd60fd48795dd41905886b518dc6eae5e2b587bce8124042549a9a75fe3affae0304553242c1cfaf2f2a3971715e8a58a2924c8f05b5161988ae21f5ecf1383afc7d80775fe3d67fec126cdbbd83421453bb045a066cb10448a9d22da02e717c7475ed49118cd563afad3624b418d13924ad7412699e8bca306bb270b92126fa57bad23f4a0341819391f70b6a17b0f2cda66eb50068ae2ada498aa4b28e94c23e10180b0321a0ae8d02269fa6618f1205573a3e015dc1575742ccd810320b5cd198ea4615702a3a78ed03e7f4d71777de761b5ede95f5c7a312fd161edafe007126be143e449503be9004601a0f9da2ec0c1c68e6a1c25b24a3fca30b4c1ed1a3755bf67995f56683a30209af5fbd9c28994badb7e8154c41da4bcc4ed7d2d4206a41d1815841d7e82b84671d7e6b54fb36dd4fbf1c70ca06e2786954399dbb16723ac98214eff676f46671d33a2eb213cc99526180a52cb741daed7d4c923ef189ab98a899ea1c8db623cc8ffb7be17ee99630e231a7c6e41ada0e9c65ea40033fc3f2078598b8ccceb7981bc534e7b2f0575293bb4ae6c88c8ed2989a570821514068842bf67fd8ebb0d44b23ea73865ce1f56af9f059a2be9beee33032048b3a52fa4e7a36b5b857a06c01e55d8ca2e4a01db6d643e7ca6d75aa0ff77b4520e57970b6f9c3107aa8bbefe1c0f23d1e75330538f142934f81a8edf0c0fb6078b814a8bb86321ab07b65bb702a25553e1fce40a1b3fbe405d97fe80f2215a8833e61199e34cf14c44f162db9a8b99966da04a2c73dbae26209bcfead80ce3c29971312ebcb10997b753e936c24db3f1fbddae392ffbbfa7bec700770e8d0515ec8b0d70327000d060c0991fbc1991426e10b045dfb1def110ec3f71839681064c50f4c00aa2369702c460b01b9c69b7c20971f44a8fe5ff80e54711de4a99429b49005e91e8d46a39a3e21b7b541a91f3417cce053e65c3ec1843011e4e558b6e5dc2f12abc7d090b13776970212defc485b5059480f3fd9ad4109c7490fab1c46cf22b02fdbec3fa5d41607975223ce02a33cbca0c0f162186b697e4ca8ff31fae58271c15af09eefd80dd2eed66fbd1bf6bb68e751205ba7d9f515dd2aaf924aadc3da83bda27e62445b03c3145b4e862a11e2dd246fc7a1c7e4a969bfdb73c7355fa671f1a05af4a8c01e35392b87006ceff3eb583e4750323a6724c1be8f09e1a515c97cfc6e4258653867c23946cdd721ae2d872368939e83b67fef7a23e0421263a4958faa58d8b740f3a42b0957c96fa082f911126c4ab6c324342cdf369cb8ffb42868bb855d6c343df31d1daf19b654e29076b28bdf7cabc57f0df5c28d295d782a8a1845d7ef0a43bb4ebbc9422dada72d5eb7bc8893e364d3925ec8510ec6d88a7e9b172c73945903ee254cd29a85f5e982c431a28343ee13da5488be899e0169a1263c33cf7812caa720ae2c208770f8c80763bd6665912bca19c312428d2cad3ab108e5bfee65db82f7fb20d169043c86a13e75bbe426c8292ff0f05cc3a8034158cab4377c13c6d56f0398f3a28048111263e8477555e6e4e6e20a07de9eee2ebd850aeb3e0a209b53cd81a87b3ee4452c20bd6b11d8dbf9c2b09a0177af046c9e3ee3576318bc72d893f60ca34ee16029a26520c0c6ff2b35f8d68a2ab387a4c24bbecce886cb88a7d495b51bbfce3e571f4674b1cc1d2d6323671cd13308d5069098c7a6925a7df2d1be8f24a6a1c2fcb898b462dfa67a72383751ff9d33c78135671179f69f24171c4cd8ea3741ab2787c56be486abef719ad62c09aeddd9a2cef4d1390a3435a754245bd8d7c65f9834dd3505d4a1263bc803f31dd596e161659238efa86d36e1910a5016cb645b9af96d4ee2d5e9cbddf935d7fb21999ad8e20bafd4f044ae919d9b3af9219bdd183f0ee88745df827cfb35837d561c6d3398f3327230ed5f0c021358379543388c710a24071f7a30ee2ae14b2325ef3ff621a79a49cf791c0849ba2ad95b4d2a994f74578df8b852dc8aee3fcf85f68b93e8bec1fd98143db170fcd6c6aafe3fe5bd1f60bb8e0c60371d71d26c4f542f9805708363d63d16fd83ba294d3d44a23eb6aa5e5357cf0262c7edd2bb48335a6029bcc18e774ce89b26d2da668ecad1c1be21c2e3964e655f073c4b10439fc626846d9342859ede4f0ad71eae8135f3299305422b6da8003354d70f87cdeea05f61f885077f0f6f7262c2f5b0b316e0035c530412970ac5b26ee7617f7241834e513014d3f6711c28bfd4f1b58e0572e3190d2f9a3ea79140479bc7076d0c93b452806e40709a6872c17232f896c4b0a82c1ca4a56a43ef56da9b7fd528955990a1c378168bcb5e8032d3edaf2d61a4fe84ebd433d5902e6289e28ef0e63b799e55b37b235c711846f6687ad3f6a141752a4de67872b9026cac97ae40822d6e6a3c457ea3c101756e5357a19776726ee82e530898b1409c27bc15dcfd624c25e670eed51a2d33f42b815e33e8df1f05437694c4508db5f5a92879fe661297f23acf2fac6e934391f2ebf000a003ffa459fbf8afb3819c83e6417c22f47abf7fcff63bfe15dcc98a2ffd86d6b48f3e76cf95b62b8a66e7f0fd561d85e009049083f5940d51913ed2e08a518e27469f4d0a4d64f52ca71d6a164d053576a1f8b4a885a669a3761eeeac1325af1b96683a987023c177ce1d7f427668718fd5d5e99390862dd603a1075f81708473d497d851b798707dd167b6b0f9dfc7830b417017d8767cdd8aaf89d59eb3441743a13ce8eb5b7082e6d1654f36e1529f312d9ae5d6f6b21e92130a40aaa841e82f87d41948d193453ec0ea56fb4d6ef927222fb557a90a612cad25d0c43ae12680ce546c4a8f83b021b8224aac85373481bc5f589f153cfeb3d503f00740052430ceabe47d446bdb80b4c82b0c812a9a9db296e5933371432362179b6452cdb3bd8aabd013403d44a6c2bdea7f6dc828d1cd6b4630528d90efe953f23f85593897351485f36f30bfe10718d9546eaed3f4ed8a08de7e2681d4251b4df9ccf2cd731de8e554dfc8124d1c137ca7020ab27e274e7ee101d13a668ec76f7435c6c0e5ef153da9d8fac0502864bf0d58638736a68b61cf5aff09997b64c6d74e59058a1de65d2321c6c75acc2a9340191c232585b85992d2130afbf717db5ca9a3c13ef82e6302360ede5180b884f1f0a904dccc1893aa5200a80bee8e348c17b4dab9ac44406ffc529dadb99a88e051395c9549626a6f85fb010a3eb076a446459d25d61d1df756013615269c0971349b930dffeff8a1491b6b2e0a6cd834a356e3e30d18be444680bfdd78934c4a7643aed97564f78839cc6e3f2247c095132b999cfca250bb2ee6a6a018faadf572e0de57076dce10acbad1951ae09fbfb7599d0a4717e43b39355feb57ef5c386b1d97c26ef8cbc162c9788a966365cac39794830b23fc520b7fae67dc41e7405bb8f855bb17e2959fd29d55da1074291658f5d95b782573cd1d8e4f3351c5394e01f4abdbe615692c1980412ea20c1be750d45cf6e5f8d83dc5efafbdaf68d0708a275f596d97ed33157246576e798df1fa17ba277fe0bbf8eb1bdcdacbf95fa53494d6f5de6dbb0bc959942e6f08f34a3398fb7978cc79dce6a442f389872ecde8ac7e034ad3ed8e6623ea2e71105baab8eda227ba8ef0d2f219684438b810de9067013c4adc3b4a5f530ea9aa65c489057bd483f384d7f0d613ee2c741fa1f4cf09dcc2fb2df24125bcee0c0a160be925f6e5a0aec2b558a2d4c4e72a8fdb2c9d39839fddfab155df2cd656a6496f66200f0f98c89280bcc79ba0d2811344842bf1101cc2245bd18075b6ab8c679ce146c4a7e048cde4ebdda7d71d2d47b3745245ef5e0a258d5013a8e7eb7855d1b81e4579f8c062392635d363f4bcf79518ac07f2e931d364cc3da0892fa7dbffdc6b9d585e9d6fc4d48359f3dd22309d0788d8f9fb7bdd407628f3707cfd3855306d315e35b93bfb4c9debccfc3dc79477f978b4c042528f3299fac4ffe84f6e63b737df462536bc77d6869426c7d5e5d9a6e26c82a645c411a376793dc8ef56c6d6920285640fe9f9c10cd3390f5136650066f9402e13c109f54fbf05286b86865f8521ddfa32a882ed79a270ce728370a179850350af48a689d4867ef2d35dcb4862c0e8ee7d109f8981110f32b50912344f7932cf69478fc5c221940465c7835bdab26575cd33ed57800900ceb27860959ae821975fd89450764cc2b6a645cf095a3d6a92df62899b90fcbff646d7fa52812d40fff335435d7f6e04c997c874e808c764265b2762baeaabc161c4b870103678407ec92df011c76067ebfcc13799e553fbab5942d87c8e43fed5a6a323f9b24c4bd1d8a1471d5fe69b8429f4294c4ca3f03c3d938b81dc989bdce18ac2d88a3267e7a5b1b180b728e736421b72076dc72844e075f042410f5ca2f0db88022b2df08706a7318065e788c7888a267c6b4bf88c45cc9eb91d12dd4de7b6f813dadfc7292d603eb40e4c5f76bcba2e88b80a7ae5d96d1e7952af43a52f7e30d973991e7a2b51c29efff480fd106d5295207a6084480299b991e1b09fd951961da3c545c836420e8b4252a2c30684a98fb7c32b003cf68ae713409465f5273cd81f4dad85b6c0f22e22d0526d2f92bd63209543fd7f07de888aa37a75ed380f2df003cf85f2f37df72dd4e292eb24a410e26ecf1e4f186dce2a1daae7646529c25cd3b160dca20d1307448e045ce95b17e251d1935ef1fd32338c15bb049b6c7cf0466e8c637e2933ee069d1e0e8012356cd024dc48dd3f6b57f23b90e9b56eaf92a910891652b4c0f061e4bbc03d89668890481080bb55c8d2a18a5233279a6f6421bdefbe4553f7144f4c16a7504f03c8cb9767c5f22c4454ebe807983283951265fa97739f3be30c3a5e7f887b74dc1507be483c04bbd3ddc7ea73f332381cfab2dd8cdc7e150e7bcada94eb2c52da2e37cb9e1e08548eb10f07843ff60db07e6528fe5910bb12aec771f88b3584c8778178e0faca8d7fa49c9c516d38fb2f7b751d0f07f33f5d7b34aa9921e142b3dc7ae9ffe9e0e12f602835b5439a62782e5a1d16ce225c76cad8ea9fc39d52788a6b271fc58edaee4f75d7c27173bfdabbef8d26b60f26f538526416ef4e5c8215d0eb4e5f93085ca3b189954659d31000c4d4b76b77754389bf4c4ab563e0b501e961464bba6fb064d52e841ada0e5ac8bd7c6193abfcff668a3a064f75fd14fe409d2e91813ab5ff63b2b772780d6d5c37325ea800f2bb8d00ebe07b8f41feec2c9d7c4ff2e86ff4b6554ea6e5179a2a6421d68f914db1ccbe20ec4a5093ff9065bbae702f864842c7316dbbb10116d271ccd758d231a15df7133ccebe67697a6ba1a3f4624cdfaf60687a1a022b82b86c9b7399d28de3ad4af27e10a9fe08a2267e4dd69bde23c310b0c4d414778ed2f6213a4f58af92a3a9e8516a5ef1afadb55d37c5727d961251049e0259e8d0817f980acc3bb80483202bbd0ee0369c4fb8820d01214d0dca93e8f38a7ff27cf384f15f62da92612307f8d6b4ea1c45e4ea06a06839d3f8ad8b3d2747b804744ca59e1205340abd78f44f2c9d50eb3a533a4358f91b8ed08407feab0b600661b72df59e4b358969f3e694409d53ee80b5cc8ea036a6880a524d0c0b82660575371832e3dcd87c60b27ae5d6afe2fffae898f08206309c38c972522bd658210d14ea86fd072bb1f6515bff9fb2f129dab4df8c711b6e091fdb9138c3fe69b41476fc75e3676e883e6c08db5066da58e525d063a49824b087995a1c329e338a7d8588fc42a54235018b4e1397c9487665888a086245d931ed3e6e75b780ae552e8224fb9340b8c5700e3db9af3544c6b113db21e47e7af9ee18e3472a234c03ff32f073a08e0eb8a6eb6cb187b7095c18c4362ce8106230d60f5083b791f26334e6af85870fa6595d5940c9c4b1427075f6ed38535cfe84d2a89b19625b381f966d4cc9ece48c8df17e8f4f0d328d85342d404a996db694dc5be1c27a75dad7e0256ac5aaa2537c238174d5b78758a5001334c230a70a3570d1e9503a0b37316e18efef4670bcf3c078396dd7a0a5ede29b5d846a1be5fa575330a79c0960b9cce58c3d61fdc91b6e4e29ea6a9c6d35bd4519fe9876e0f0a90f407c365dc932439a372ec0837de71096a0bb69f41d444b79b198a98d395c215c45b9facf1ac42acf0b3cf69a4b3ee45053624994c253916941d7107e235674e251dbc195eb904e2d9eac0eeec16032bab90ea8c3a421a06c26153853bb4e898342d79f1478c824eecc2e73562b5449c0e6ffab2cd3f8e553b709ba2007f9e1685294a3c7b6a4f17e64aea049e4a15d2f8ab0ee16c00df72481e0c81925f259df4c1747b75c4007d68183273c798cf9554ee5a7b1d5b6b8bfd9767f98b7e91da45fff66d8a2259c98d65fd8cd3692e69ee04cef3f1988e58c0a630af8e2d22ed7beb0130440df33f5ce770634e74799d808c0c40148d39367b810e3cfa0fb0e6eb34402410c07ccda1d9386b9fd689db02b9eca0bb3926356a42dfe1f6d8c3ffdce28da33c6492759ce3bd6f3045883aca2e65f63d48c3bed032518109f2e3d0966e11a5e18b04e0a0d479b76b0b6bf71ebb6cb7bcec249cd02b4e12fd7497437b8ef4a85d0fee9fdaa7164bdd15f534fbeb1b9ecc71101bee2a94cee0f3ab2f88494583c83fc0de774e3e067bdda38a42ad18494452ecce7a8e857b15d6f44f4b0d37f80946668e352580bf27627b27546f3a327404d1b513f3e4bffcee1f7b4b6a420b4714eb0f2e878f00143fe2df889cbd8db3c655a668c88165f0064b10e12c0a283c94df42dd6cb8d9b6334138e37479e7972b0a3058554fcddbd9cd4d0719515bea045fdd97941ecf4b50f0d9b3fe4c1f407fdb23a749b15747e24b1aaa243801541be35846bb2330cee365a2837dc65e9bc1be2eb168f3ce40399749f95537e648156441e160935517c33645b80339618db741369846f743b6ffa2f9451f12d0dff342b69a5e5840a1e581f163562fc11150230322670d906b8631b8395b6c3cf1e7f6b4dbabe7ff86b486b7e64af0c40c72838575caea0e41853b3a742b8c4fe7495b2b9c2f693924741b424b806e693ced2b8c7ce2efe977a088d9db58554ef42bd404413b807582a1a34353405eef65e2230f7b60941445f2c4e069bd676c7fbd925937f73c2c703bab1373f6c22620f893834e181ec107fd527ca5e4afd5bd5a2027c063fe51eb419728e731b6831465f31e71016116e40abc11e45235890e7364906782804aaeb35d2bf92c512a96ea7da94b76ed5ff03c731eea651156242dfd4866efbff24f4f1bc40de09c24e7060bdacc8e815998176d4da858cad1730cf9f84870e49ae8284c9944d6b8b356a199a6528048c4923fcc60ae122d1bba8f29ec83b07d3c2072126a2c14473c8577ada67e8afc40cd82b4055619002511509f9c3c7acaf93ce7689d642eeea0a781ad3c6d7471ebce4a73ba0889a6a34a738fbbb527998561bf98e05205ff190cb81c17948dd6fe6fc3ea40bae63b208fbaec57082b65d6c424be79357a8cdfd481cebef1dcedb6c7327d2d48f3c289f4944a1744398d2967cb91be36998c0c0ced5c6e657f4dab3fb754aa4cfb30e9fe27c7f463ab7b1a1e83fe871acdfb959dc6882beea2ba798581e41f105097f5e9562eac65093e8faf1de243784ddc2245467a9fb12b5622faccd12e987898b4981e4635c90f129612e7cbfc271b8c82dce148a073147ff48bb67f6abf5f8b650f38fceb3398146a77be576ed9f7a69ba3658bd8b47e66115d9764f8e2e29069832b15a1b43b6a974ac46c049c6e8731a4d37bef549de6ca1ebd145830c5fcc6e282eaa62fea75d2158d05dbd638bddaf806d0a5f3f6676fece9e2a941b6dd381d6e0a6dfef6be6eb0c66cb3627a8d2b6c6b0eec16e8208bc9b9097bf1589a8348255c9093f9bed7a66630bfb6dfab742e36e321ee98d70ffd5cc071926235c68242e0c878409c19913e0f1458e9068789f2313b48f7543f23f8fb25974bb9e1cf36cfc2f2d42a9c105a377a4e7bc04363c6a44a56515cfa2039850b22ae3e16fa4e66a7df30fe35ca6f4783bee66545055757a5ddd4940629c7a459e6de678b26af8fa859090d0acff866ac414985c94e0365bf10314e5eddaa0f6b119e83820e5a8d46df78ec0d365754b995609eedf96964bce86b26061e33d2ef3aced5bee12b6dfa762c30c1bd58eff6975cba5742b1e6146e7bc6193245eaabd3f5e62d51174852a8eb33660651dbc5693470659c6036a07fa36cf08d272261741c54bc34b8be734025f550243461d1c69be492d25e8a06d3fc482dc03e380912121b7ced0f08fc2002fea9a26cb2826d5334e68e0e8283d0f9918ea20c35617248d1e0da40c8073ecc6679cf944c02a55a6a13fb28d820f77b7488d06b6fb06bf5be38b4ba005f6006504e43c09476e4dbc68dc6738e365a0cacc4d2ab5ec8153266efb67f82a3be65fc0f666033d7fc09461b2182436f54051acfe193e31609b83501fad4af080f4533bd94c052b12e8fea293cc38f999dbbcda9c1a185a873018e69b063718a13e1f01bde6c7941b323c71f4d41652c36fe64c6cf3ad7d047384da558a31596fce7adc601f82f964a9ab1b808755166e51bab77901a11e4b51185bf4eb16a3b2dd2284b45fdfcb7cafb5cdcf16394166b8efae302ac17d2bed0d133cc6ca82b12d82a3d9555cd9112be91d7fe448a5aa8e14e5dcef1bc8e56883359c41055fb93fd832412aea0081565ec9fa5a67dd8b33b56db15d14335873ad9bee223f8d74572069163a9897c1cdafa4f90ba21221f08cf83c5f347f966ea7b6fe54a9858189c0b0a23847c7275e003b31ec757288ab2f0b194ec5ce7bbd19d434fd993f9764be1113d078c490afdf40fccac6038b78e8eafb4b18b2f14ecf84a599ee53a758d482a2325ed200a135c3971c0f97251c8d331b671f002fd09bb0ab20bec9d4b50608d87fc781cbd55a0b839ab9103d3f89170bf0068047e3201216e0f3234fe3bc9d80fde2410dde6e8677c062f0ad20e6a3a7bb3074e7ed5ed842394c197e9101d08ce6e26d1f4a334eb5ffd1b932bde9a88b0e891a5e4981ea7bad09d9abf494faba78232eabe6dd371452faaebf6276413cf20da8ed6f5d4f4fb9fd239312357c3490929a97ff46d35af01779ab75d5326b5795de60be23428cd08362fbf81d66c62f5bc789a9b2c7735b6347a03c51256e69c414c3e3a9a293d70c8733c2c09322c815c5140dc8d59b1a23af9de2996e1ad4760948c952c441a82542d891cc2f25268b9043760c8dd59601ad9dd4659ae21fed2e14d237df46acd2a6589f5e11a43e04cf1e07563204f6baacd2a9411e59533ee26453139e60cddbd60098d6171c7f259f292d16b4c2d349395db66e2e52c27934e2c3226c7aa1e899be11a4079ca68a497b222baaf0c45d374bd1e6ff0abbfe040c4d7095520aead3d19b251355d85ba6c7898293ba40ceb146f21580e279c87fcb6779b92874601235f7525cb1ee877ca0876f89e7d23eb90f2edda8b7482777ab89dcb1496a38f0cc95606f0999919e16bcce8a161ffef82d8d446cf419f71c0ee90f0c1211e2f5874cf1ba35062f51fe01c363b3e30a0977ef7bd8b346be7aeb76d273724a855b32deb57ad5f19129132a3f9f1076575e9db382669a22a5938637c417b1c3c1d5398824e15c96817d8293ceedfe8ae06c59b91c3947ddb573e701936f7148a3aea5e26333818a1b4371e2ac8c07b1f3b4afaeedd16ec0b8c8c1d701a00024fa86e6bc8aba7d48c4041f32feff6bb30cebfe4749176b632d2ab76f65ad24498d19807417ef02fed419ca0c0cc697acef1ffe50b5f795a6628f0b4de748b754e48f90bb55e4fed45419d2307ebd9e63ae31dd8d81fa8ed7d1961a4f255f5249401c0cae6d9f0c7833fa0605dc2b88606a791d3da6fa270e1f6640717bf66b25912edc48b8e5121545b794e8e60121f43bc3adc817edabbaf84a2c34705e4f3e8994c07900d8acca54c792e9e24258f15db26cbbad4dc1ca9c4a1b31bd8eef5104001cfec1ce7a38815ac04700260cc2b404e5f7b7fe2da670fe8b2578192210893b5e405d01e350af4ca3be6bdf56957d7e4dd2822bb0f787c99ec34922732c1e377ce5529ea715b3b738df58bf70d9850ff64c207159e72b9d155f37cc0c598e01eb29dcabe25c1e20865fef0eceeec7389be44dc1410eb85d4366ec5824c97479d484c4783e47dfc8c65fbc150d736f2edb689f2c01b370e3bd223fc1d7f9f5652e3499313308158ad64efe5e22b837a5a8cc5b56a8e182108518150f1df32deaefd81653b4839f7c38292440520633f64b1cf2dd40f56f291db550d40b7bfa606b9a8754b935b84bc6311787f6c798cb4bc799d12469292f5e6d8864275ef17078a2f6bfefbfdb9fe011fac09a657e956702b3e52ab876e2c44ff4389cedad7d696c326dca3b7a2dcdf34590d6358b3e5692f08400b514e7c184e8b3fe88d20a234a8dc9a44c36ed52f26a5d39460a798beac04557df7ddd6308ca119b4b7ae834b79de150696cc3665c610fb7d6d21b060b59965e37f0c518ed314d4644e484787459c5cb7493d39d14224f83773108ef43232faf10966c4de4784a78aad9149a02ff48d1e61a8cb12c365f7eb5944aa1f6971bf11bf8494879485510b2428f1394e75837732fea00e589a024b530c4d4429c11b456a1df7cfcbc24a7151184de9a5bb25026844cb247ad4422719d5c7d5c2aadae1aea0c5d5eb163890c766f91d7096afe12745480ab36e5adb5c093555ebab0d76fff05e21d1ab2a4ca0e8333b87e290012e8a0e7395b2d10959de74853b52383f7c8495086ceb46df82160a758d26ed2a76133c5bd4b24007cb334d5eb40c885d6e24f08d1485b83d1a49a60af7a6f2f29946916b4a4b77a9c40a02dbdb6d7c6a90dc5a54d5744e74cfb025b5c8c9c9c0b5de1cd22be52b7ec1627c410800676073f84198607107498af93844d0a50b8dc4dfe17b350630c662654423f2981b77d3e0ba2c406a601d8a9f6b384d11165a9865592563f0fccf352553ab1a08e3f43d5d6388cec5ac5b4aee02eb759fde9e21092fdfb8c51147743d7c3b9aaffa8ba8425f4d3f517fe69bba8ee5527daf74596faee83345a54312c1ff3169812b0dad3af935e13c9e5f96e198a10ec4609cf9ec527bb85279f2ba54cab8f3a3fb4f40190d39f17ca8504932a1b59d5e67d10c476987d71421de88b24271a703d3d6344c71dd8a81c544c27d76dfb4c0e607d79609f4e30b3d103c7a81835218354821f3a9f6c415dfdc909d38421c548c1f6a9af7f957b15d4356777289a02bbe8aa7ab8b2681b677b7d22327bf0a322f544248e9583aa58f554bf670a731407a33e695a7e73ff059dfab27a24b6fcabb7d55d43e5bebe99c14ea366eb689838adb883021f4dbcb434a32c5bde93e90c7da93358c5d7d2323f9d30b59203d381e6c0864a994d4ee0e0669da3f0df82ed2b4c71759b72ec9e8f65d5c1236d2de446e12133153b93facfd881119b7c14217e1efe496a0a29e20bd62d7b1a1c389939c833dd85a7b7d9b94233ed794f26c512beda3bc4dce065eae5a453786a7346bfdae1f7a62cbcca7a77323a9b409dddd4a4306617ddc929df1703a4a05c6d622fc520a8786e36ea2b45571c5b690f3d830393f438ba1751742a523e73ce4d24809c55435c488d702e0e25266deb8873e5300950e6bb12e730b0ef576431557d208a246bf28b2ee8d808e5de0b1d64d76be6a88708809c60b564bc3c3a0e30572308a952053550d5b4f56e945edc593639cd4014d36181ba47077a8875b61e24ac770ba79478727cbf46304af047ab2926ca18bd46e0205e90c0816f5395c0179f7ab7f71a418c64965a0fb172c9a2ab24d1c480a22a6e63c99db3686cb87bf369a048c3f5e43eb53e67973dbbdce10d8863165c8349eef444762f7219ed501625d43084c9b4764e32b8a60f42e6f1ed6dd712ccfed0713fbdf6d12b4ee1b9fe2a55d6aad6cc9f92f0009e78e04df8323717fb6f7e4c74fce12181d311a32371f36bbbd546af50179b059da09e2d20c2d8b2b156cdbb56eedd587683129e06f978c9f05520280a71d23ffb5f8a27b16c11aaa216fdd3f8255fc0c1f485042ad97880932df4f6ae1f9d00a3c2acdbf4cc62cdc22b5d20995098b5c90a3f7cc17ed8a3d591e23e1dcd99637558421e80441876da814e81ff2a35baefe6ffb41b29e7a5b5f895343a56d2f7bf280bc925914b8654708123910e5062a9cdd7ed09d88bec1f69c89ceb7868670f6ab85a3d87773483a96ef57623b98c7d6653aa6f4474ad954de22666f7a747a37a5714fcdf0c7055653b9aab36a22cafc593de2177ffcbef48a21eeff737000dd17f15f427913b859bf6895d8d1c430584c50bbccaa426eae3bb1c6e94665e7a2b9aac7c0f9a910aa146462717336df7e6a9d9d657b2dd3693427d7188ef1e753b3a04e048f29f37df124dba0cce757322599dd8d6fbdcac400efd23ba81e6ca444291cc19850d81bef95103cfd84c13568280b872555c781aef744b811e0ea9aad988d04e209b10b4ec3e27988ce419746b3346abef05f5a545b4a8734fbc7f88a2dbbde3aebff946e740ad74983a084ec33c2f279eb82b5be0dbe78927dc6a0a7b26edb5ece7aaf780cf4058fa652abe80be0d40e6daf384dfcf3b36789f85cc9b397fffa82ffd3f56f8fdf6638e7db38a6793a277811d4610616126e875724e17219c467bff5080420ac8f7e608892d145fc8911d39ca4be2618ff39e1a3d86d4ff1a25319c42b8c2f23939ecd417a653da77d03b5f0318221f8d13f9951d92870a48dbc2071de727bca99fc0c4abd0e444f9d8722a3c43fc235f454053a0e8e88efc539677aeb8580bead728e625cbc5c511380510602fac289a87e21b105b65d17ab684cb02573e096b3047e925c5928172579071f1b5e2e34772f79e4e2e2bc99855896f9360a53fb7c66e1a55571af9b82ff7dbfe7dec35ee37f82a74a0fe06e2a7e06c9cba4d2d793125914d3fa3e85e020256702df572ffd664186b3fdd72aab2300dd3209a00f683484bb4cb6b04aa387fcbfdb1469083a52ed65277dcde3f7dad4918e65d7a2aef18e23f15b543b2eab32db6efecaecaf7d0596988f50562042a5082a451cd5c021d269e9ea7533ef26a700001e3ad02053bc70e500bdac744dfb0cffb675ddc1a38d6db248daf0d7f2196307ca49bc7f46678142b9544b6f7959a7578ec5a61e4a07765d460e4ddb2adcd78d274a46a9f78ad9eee1d1e66104f869dc19f91f0acfb006aa6265fbcbb11e7191f1926f970201220a1195d29edeecda8e0dad350051badcf271b7b93932d4d7c1def97dc749c954193113e4340944a0244603d48ff346fb5d4d9b938a0594f56db83afcd29c8ccd9bb68a82ea6f48b926a13955c8adf261615aa8217fb5301ee6ff16a09260add2bd77d8509159f24df52d991269f9aa07d19317d9191191c8079cea193711e8e79c235eeb5f0fff6e672b4c162f37e0013c993566884b20f1b1a50ad2664cb4d84cc0d86860eb11e1af2ddba7f67a387126da0b44d7c887be0588326672f6513501a77b3017bc2540befb8ce202d5e721b44e8ff9e773a4eaeb5f5ee926673920a96479a3f1245b56cc0092471a125b01d8e16e76ef2497da5d4fdb740b48102d4877731822a8b9101768d9ef85584df28a359e5983f654e471b0ba2d7ae497644e050456436414ba9c734c539908e471634b1168d928326842a580a0e6108c225ad9555c58c44a3ec2ec41554d110699b2cb96f1c0b77814c9422bec374058cf3ec0ecef8f0207fc0fe848a261e293dd3aa98740cf4cb7a5e6b438cfbe0f4887a2aba4007ae44ab84269ea97dd4db4f06eac01317c3693113a3983e6a72c325997ac68de39a660b744dec78c61f6a741d5d2d7c4319fafa12fc920ec25c05e4ab80158c69af35c68ba5518932e3f6ebafd24eb687ea2ab4601093013530b5e6de26bd96b6af83860511b4985dc3710c298a85947d9d2c4e9ca76bdcbe79fdc1a9e3c5f3d4f2bdb088806970","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
