<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7d06c41b8d7e409df33320414bc67545a2aa61457409802068b7c8d9a4046b2601badb62a60fd81cb2fc104a76146de01ca53a9d7ad8c4bf54a0dbcee199407e0d8873221d2084c7d9725e3ed9c3fb202c9dae12a737f046c0f6d07c265cdb67a9bebe2c6b41ba8662ecfa5f1283ebbb373bb036349559961304224c34c4d5e14a02d74be9347699bb8c9af567d1e0a08590442e42c94fb1cebc90503fb4b7158dd79d326773a90ba98511844c1e3849875e86a7ade8c5849d7ce06c132b33cbf8e3cc74aecf5314f0a3b4695c8c0c286048ec85c0edfd27e3e1a72a5bd1c4dcfc74cf0b64fe15c7a59b70e1a5ae1c9eb49592c248c750cf4d06b5f3ecb2f2d122afda4b64a9c98a44439971502a821d77a74472dc8ea799a41751e222ac7fec261f3104aa394f5492ff835d19a8a0c5ca0c982f21bc22f337f152be808f897a0c64d6d2e1c67a676225bec7f7f5894bcee063b392414c6f0e63282540b3c9dd3fdd8497655357981bea07e10660555ce5ed661e52e3dc8d3c7cb97f02dfa4cf60132e1d2939508e1fe1e6fe47f6a5efb6bff99d0fbf2a1a2a074cddbdb9c557c695e0386897cd188869f132205cce5db690faa334d6f7314c550ff6bc264fc756ef7d6d23ed4c7e7e84ba860da7434d4ea034084b4d2606d6a5aa0954be31ae21e9b0dfc2c76cc5800984d2b8eab4369f2db151f83321e99c0e2f3ef7d72cc53463a1b8b3e638a123a27593e8ad26b9de53173bc133a0044d35a6eb8bb6de47dd449f38d4e7fe7b678e894badeaa7257e373f55b38c142aeaa02799658603de327c0cf4d22af1940ad7fc1c768e11d9c9be2aa69eab8628ecd264ce1373a26d5d18ff390097c4607de174f5743d355bc4ee50ee4d2b62ca16f13a4e61c58a99217bcf5f7277bad029a5f53894c758a0e20d6db423c872ed6c5341ccc248d88aad69082e04d20ad672aee7ffcf914c9328e73dc2db58a89e07d75902b6299a002362b650589b6626e3ea90e1d5c22fcd7be663b0cc71f03fd107cb869206a62bd2640afec8c1375459ac8383ad30470694908878ca4d9d6126f69fffa69baa923af13b3cead00f7d5903d18c9e74eeeacd048eb583f634c633d88029f04f302b3d67e00cc1538701872eaa1265943521f6cda7260d874d4e2ec668c87166619fc11e0e5425359727318b46a1a3c90fb0a07ea000948a9aecdcf8e2e27db8b4402cf8ff433d5f7e4610551122fce9e8ad18bf9512a5bea79e2db8e6707af2cc8df320a9350719bd0a7d7c566290f9419603e7c951eb17e7b1e643f6edb717b8a474692e1713ccee3c4be9ce08a044c96e66824acef8ec778119b4958b86f8034da476478faa9c88bc26b5669ff942bb70ff29f81072252da3f55a471b7764b1302233a9e3a5496e45cfc0f438a61c265e300b55347559ffcb3678c2286c884e85dd43f9f9e01c618005d02fc29ae12a15c88abe30d88151f0788c53cd8adfe59702d77a581d057a330c8aaf2d0c1871bc4bd7cb3dec57e0d9adfd4b8740bc01d3b477c916324e1552c3160b597902c5c6a19b5d6ebe7ab7e031c77189f1d7f162aa2582e521e5a63e10673fe01dd616803109bc0c7263efdf7132e44e9b2b8cf0ab44f93984b420b7c3888e27ff431c3f6cccdebbbea1546a6e8a3c2dc46ada56095dd001d8f03067f10d2fb2ed4ce9679c557450a8cbe797cf59768e0c9ae6662e337950d02526508523e80032999a76e264fb0fc56b5d5d3bd3355eac1652993dc3a26299f14a2ac40b63c5ad13ee2fa657a7c4be63e27c45e559cb483e9245f4f6eabf2d9588413e4a59fb2b11116f52cc1f93309fe91d4c96b28567d2bae675bc9199c0b58f7ee236d5a80990ceb677df876453d228eeb05122f253054df0f7cedcc26640b7601d223a4bee889b3bb8c030eefd923969b29e3525591274c5cd3bdf2a701e53ad59a6ec2eebef369bbd3cd3004600c55822dc766fe493b13948e4f5bd342f1e07505266fdbf02e0305024fdd53d6755ad757108ae92a0b7e90ad2502b31b97048c531c86703ed9736775943101c1ae4d4b9f5a0cf44dc6816ac79099718c62007edc6fbf775c74c49c8b69f0ff0ed6600901b17fcaef80a4cd1b3304c0974089672087e2d66fda346a72f37e65e924f6e2a299814a02ec5b325b12df434729d72bd061ea8b50e73e225db0ee7fc34d68655fbe9e2edda3c75f44128f17346ccb3780417b7e5bf92618c4aee4246df3c008cc7c787b1c6a306830dbfc54f816089dd8384394476a0cb8c55a407ae1cd295ba95ba6ddf55ff02e53e33c8c1e86e820fad56a6026ac407472f93c4a2de7f26cf7a492f8911e534c121ab4ea390785a9058730db625f0a78217f886f546e1ec542ca3ee6f8ddf461103793529ca4020c2823dcb4b78ffdb8b1d926a9dede6fcc1dbd2bf961da41a37807ca864c01366366128e58ab278bd4b280c590cc97bf45b0496c243f810e552dd6f35d17ff1054be7f4a9eea856630522d6f96d3d66314fb04db14e56b42af9909a9b25aa26d6c3ee764aa43207fa9d72a765ce138c437424fface87d3ea9689a98e16e2652a3a24f88dc20784be91d7635c9f2f7d9392625d1aa23d6daad894f7742c7744de84c4cd68499337cec95e62be810edb13aaa82596769436972961c0da0ac862bd586edb117cc11655ca7b86b2192243e2b85586f277604bb03b89c3411e7314251383f1b29796b79a91487baf73636bcff4ad826d9ffa6e7e05800aadd22322c5a25b8e3fd471bd016e722b70ca5b448d949c8a3bae6d7a409bcb17bfda17f9e9d1a4ef1e601970a62fbe647759d070b459a8a24a1f60bb0d44ec71ece527238393992182036aca92b75d6ae99301aee8d0805fdd4c24da54505718073c50914483383867ea6da218a8594edd1600a44788514539283ce41ba4fb566067d82e17a4d9fc080de6566c13d1a8d55637bb6c6cc8ba22aa90b97e5b0af5b291ad9932ab5ea16b6ba604cd96aed9c6910afd7d8bde6bfcefb732a4b51ccce9f3bca90f09549c44b9c5748fad7083105d6d888b4b70604c360680ef6842583dde591bc692aa298d562f8e6d160c5c80dff870bd585831251b548c76d168ce92f835b5b8c290d81a25ea98e419d786c29159d26445fdbad3ce35e13a1f3357cb0c23449dfa15f17e3ed33300486a341facaa7481a599c79dfe40225ee6c2fae33f0e074280b4bf3e4c756e25a40ceb6812c30f7600af6b7ebdea2070949aa1766c3310d06b0302b9022de904bbc02e8170157abadeb75ef6c2313d3ed355c291f1e6492788155d4ad3a4f30bdb9b7efe0332457dc6fcecb4444209827dcfc027d2c3c2da6d5919970fd8f9b932558aabc653e273af9797161c1d7cab73167996337e5c7500808fe98e42b2b4d174b270dd8d88ba6964c4cf03269c6d2a168cbcb00b10a951209b10a1225233b143171bfa9819bdb0a0bfc748ce67db1fdf86abc68a7b14fa8cb9d22eca46d12f96808c169a37f99a371b3a081db35a4bca46e92c2de39a16e8bc9b4a3e546e5a8bfab94fe777f9805026f5b17c58e1724beb0e44034ad47de12d1528afaf372f3cbdec01b28e6549bb03a2d5f780f67987c1cbf47d04c00a26c112d8d011dfda0be2e2ae463fd588f753ee7aab5d62ebe8483fa848dcfac012d3672b59c68c31af5d7d8a7bdc6679a6def0817d51ec561cc9e5d4f088a660a59f5c72290ca8cbbe1127f250aa197b0b8d9488a8da464e118017ecbf0afb0903ba89770d65c3855b3bb1e4a40007082cae1d844c4b5d0735b2c044a46620f8c32b528b6c9dc5fe032fda1b9a3c19b29880da232411642b22443654e7ca05979e862a45a9daf4f59317ad4be6def22a495b13bb8b7765159f338065ae957fbd2b4e8b46b6e515860904a7a9a61a0d14d0e28aa536af77d5270922a002cfdf3e99c2c78a0fed1543e87d46caeafda8209833073d8e8f66e0963fcbf1ec0875e757a64c38ab243faf68b6da023a57c41e7233f3faac78a048c47115c71b427fe0a44b0a0d08df296f274135f783590d96e0bb55ea04b5d0f1cdaf2a47b30ed028e5e2a33c86687a1eb376a536c3948e5c0ea5f2b4e758fa1c45ccea2c773718ed3bedfd629f7464ff08a9bdf0f34c1adde8b6a2fb3e955c18d533dbaeb2f092794228407a029419330863bdd1c4d877a4d43d92082b726426d5a72c7175ae61f600961a369a6c60dd2b96d2f381ef4ec08f0279766096d96062b4f729178667e736c7b4433d656c00ba58d7ddf1c9edb471b8fbe95197cd577919760f6aabe06c861bc4db674955c4486734a6954890fc4fafcbd9ed28090eea2c2031b4525100233e5602082609d0ae7247a2b45e76916674da1f867ade020553cd13309040fac84bd21d2046a1212d2034b2d595766c37478f3b857c47e3cc9d267e68a4a28a89b20cb577342473adfdc0036dd5cf533c186a208b64fbcbb612c3602e0e2903b95cd6a18d0a1d3a6e22ca6e6c989e573cd5d42674a677109768edfd204675a89defcc93afdce632fc2177b4f42cbe9496aabb95f3c18f46d89c27314d9287dc18af036f24ef8a06f2a333e343f51b28de1617f0bb19cb677fc33f13890e46fec90fb59f882ae8f2483e6738737c145b0c1a60fb821656374a5f02348da0e4f10c08c9db0a2372ab5d484d4ec72eb82c7617dcf7d880de8b05d7848f37398f0efe8afefeaa6fc3e0dc9f43f18c1e5024ad4b14ced3d4fc9ceaaa08aeaacafe04273711c94f74ddb9b18c618f0265e2571a53ab8f300f7a544ff41e590a63f822fc3bfe3e4478e1034bb53248052e8f933d1bcc84fe630c48bd71d79bc8d745b22c90274cf9e488718dce8488e760998ed55f6a09147f2a5dfb30c0a9eb78c51a882210a44a65dd7827b2b6e1a64f38396af173edb3044904880b9a8332c8d657058e9d07c4fe5a5ff068980cd81a8b920f2893a8177dd26549369232fc421fce42aecb4b4a305913f4ac76df0cc19d810890ce35fad59c33e102f04417f2476b89dc42c3d5e2ec51447a68e05b0cffb0f9e4948987e5679a85d0c4d31f1690bcf4c7a7d47e8a06c9fe350f39b90f116685de6722455839fc778fd356fc670ec035ca0cb7ce27f0c28b2d4d56b93edc529b82d613a355014290db3ac272c30784ceba36b7835e3abd0c4ea51dabfb4652ed240973c5f4ce06a82fa4c2f93e71a258742e57269e0b5c8e398b185ec233802353d235c3d834f088cfa1766c4f12098f8c4c4a1c485372af04471ff67bb7e37a716000f42e6ea4098016f06e8ba51004a1594af32f9e00415b6dba7a7653f913a995f82b73ffbcf1d6de58f25dc32030950fa98a650e9c79131bcb2366ecef8c904f00a4ce454ab74eb4c0e5b225ea07d8b089236de4406d75bd9ba94323473a7ae03e4f10bfec1444fa85f570abba448517f205a44c0c04082a5f3befe6deb895fc40a6432489268fea322d90c22fd5e43cbe3a076e3d0bfa0e2e114cf5372ea6beafab34f4230a983e7cbdf24a939b908cf29e9f898180862d51b08de24af72ce2fa2e050d2c5d1fa3f9bc953b05cc33de90462ee31e2d8ff0bf8a1c3feb58dd0f6275151807a2ad82b79069929ca6661de5eebb0073e75ca3f9032f7acc264799815344b0599adaba1f7cdb2dd79bd6a22dbf0a130f9ba53ecac3c1d5683f5aa7074ba431322ac6c35bdcb234e0f1ee522d3a1d7c9b196575b45883f19af8dda225f947eff37a2324c3abe57db3e59fe6f3b881718fa18a82b24b8c72d25208631ce278a92d62503b695ffbb7353287a7329b3a7ee9b0d07a59f3bea9307fc186cf6534168cfd47acaf90740dad78b592ad7fd93b7bb7f939965d051f6b95cb8cfc796f03c90db8189c730906e53c435a70c3e805c954ce3927ef079476c60beea155d6424438cffed7be2c3df855320a5931ffaa1ae473836918833d239478479deb528b40870f1da90121d7b9db10b1890db6cb6768e0fe774f835c022d8a12fbd57a0a88d20477882215eb9ed36609f0f5d889f3a142e728b4f22159a1afa728ee5de7af4fd67cfe462a161d1287864050928836a1343bf8490e9ae17b5867bcadcf67010c1b6b4eef261076cdc0bfe40a90f2704f1eb7ec82a2ae5ef7e46ace8a60cbb2dc2a49a8f9004ec7d5938521f32fd35ccf9c94039e82300f39494deb0c843b368133cbdc330aebfdbc995b2d11c7565042eacbfa7272f11c21286a1f02398301a5fe23b3657c29126bc0067924a442a68b891cc516fd230b5e321dbbd52f5cc797af7944450299c0d8af88eaf6a371e4c991567754df6b0b1d1643b891bd10eca9883e235f575fa1ffb2155d16713da93c0e3968b4790e9af085944cf637b0dd6b90ddc9d6e6d53e28410c939973d65499c11700f587c86b990eb8e32152265d7dcbd4df128266d934345fb5f9799bc9d25fdb25bc0854d07ff9452b2fc24b8c0e07f3f2cb1e51456179352707f24ebb462b8f59a159ecb5a6e8698c231c8c73afa29310ed2eb92db33e9d5e76aaf0833e6c3149d45e5c4d8bf3ea6125aa905e627f2f253b283cd5c25a19b76b37bd7acd77733874bac309461c851f1f2181f86257cfe47fc7930b8b1b4f9d7baa0af4044e82b042fb8025bbab1a9009c8a206fff9b7b15602a3a551e27b50d949ff53cced52ff96fbc9c0a7af6e9e7d887925d8e9cd73f6cabe3730a37ecf37f14226a3fb1fd970c2ce46396f5e5cc4b675357e6d23306a9c347eaacbb0fb6dc0d522769646a461ee9b7cb96ca74a4e54870a7b6010ee429cb42290fc746b5ef9d72dd270fb413a1185006312031681c43e09fc57f1cff8c3ba5c1e90896b734265b94a022dda3797fa9d5205ab653082199fc711df1933e61a26e8059e706aac18d8eee87496d971861d90c98abd50418f449120111dc3bbf965cdad79bd5e6baf4454a99b03a8740e11e413a2e86469b5de043c3cf91d466892692991036f9886a75a0df6e45477261193845093e0fd44ffbb6dee2f02fb721bf0a5301ac81d1cc11487325ba4e820a469f68a4a20a80b5bddb3ba776dffaf892eb22edd197eb2cfeecc4e4e256674336af049005b71a2243b4f265bd432f539214b8ed183786c0cacd4a0b174f1a996828bbe1930f055204f3cb5c9faf23310d80560e2d0d931bce5daecb8110d59c07331ec072cd1cbc0b755c15b77a6a12700ef75e5a52ae92dc557d5889e52fa18eba725cce92bbd0d321e49f8880b5807b9303b9721f668d4e3e52f0c3201c22086a3a49ecc5656070857a6618a0c80663f73a9e7d783029c3a5dd31c5aadc904e1fadda82e9ca6bf7701961070b1ca88fe731433cbe81ad728a3d6e7f238bcdaa9606f51e2b587090aadcb54975a72c13a40bcd83434d529e57d816b7cb3a28cf2ac898164fdda457f188cbd4968b6b21005de068041e1b8fca54e790e65b54db5ebe8a7b559656bb2b531b6901a3c50e6b6d9fe096a58ea1eedbbd59cb3e22cbf915e09dc713bb483fe6fb46927bb47fac4bc203b3ecb85cb624853995025a32dbfab8d7bac3c656505c0bdc0b607ff443c0db4a28b4c04f2b30eb88e5745eeeef158178b156c1f72e75e6cfe87d000ec78336d9753ecd136e99868fd76280f3623e0cee4cde8d1bf9bbaf41e0e3abb01959d56fd9e21bb38e49014eb40b1aa0d9e0849ac6f4b754f1d9f2560409c7b0f0663c8f87c9da4a848cb61009f3391cc6278e246e52abfaad8bd4c0cad472ab52daec7a01c3f1b3b0cb728f48ba0bfc5a3f96b07355fa8da0adb296c3ef3c28726588ddbf320531d407d5429614f95f4143dbb349b01e6e8039fe68bce6fe57969a5548eba896a9a337962cb42fff06088eb47f042efc66933e34c885c74669f6fd8156e130dd48fc66b8854dda2e4b613b8ad1d6e98ff193611028065e31b2f0f00e220da1d035a85123acb1ed6fe118e1a20ab2831e015771693fb02cca77d593e1fdfc235ebf415223d628b442654bd580319299acebf910a31ab7783b967cb988e47f5c552893392cf343d935180662a8c53d8706e2512b2b44694d2eaa950b3cb037316e6376d304dfc5cf80f646daf9bc9d178ca52712da2c7dcb05bcc48338715f88ee95ffe194a6e61cf3757c015ba3bfb5034bfcb949161dced477c5a6045d8aedc6419a3aad549598761aa406a13d33b5b60bd707db457ed68a4c2c6d03783b47c90e61e07bbb0a309079c081cfcd4275187a827260d227d4515cb62a9dfea7e1399b4046d174ffec05a353903b2427c0cf3960c9fbc5b71f772351fb72fec6e81ce72ade1e5d822bef6a0e0149a06c83e8e8219b91c68494e55e4c7a5e6ff81f7665732d8427308c512e953253d41f67e495d32674f911d6a8723d49d520b6989ec5a5d25a01b0f243a4d4abb97dd63e8f8cc32e40d5d7eb3a47c80c39b2aa5d2241e97127410c7e5f89cc7e293bf3663e7a80388295246c7d5d8894098158837cf64342e37478cf56639a3b2ad738ae920580df2bf0824e6f6f9ce5c0919d167bb654b8ac2a29bc7d068af79a5fc728b6d5de06a487d8fbf00d08ab23c559a8e8f6f25224217f75e0bed00551a92376a39b95f53ed801d2803d43e0d5b3fc52f042740da5f5890065dc4a1eaac4f5928c707dcf1f2946d459106424fcb87b7bf01a6cf15697a9e48977bbbd794b800c05296f232dcb252b060c71c32b903d13f0998635f98e7f56f79a27fb44e125652033e106c5001a28a4ac543dc266970c6f1da0871d8616e7ca7eafe636038c8e8c85916456ce70787108039399d35c8cd82e00fb570c9d6b2a8ce8368b0f3ef1adab94c1b1347e4f21b585400791be4ff8bf937b8e9eacc312a19ed08a8c4475cdbbb43a44a7bae7e7496dd5622de67426182b6b8bfbbebbd2541424fb19c8a42fb6231accd37706f84889a3c1670e68eb69ced10df7554c6ad0d33529956bee59d0117f29a9d2d3c8aa5696fcc65ad345b2f6606ba624204a662cbc7421ccff312925a211abf71a6264fa90e5c3f44e3b3178e4462edfa734f972370e9407b29476ab658c6b6d4092ae633047ec5f97bc59f5dab6fa41958a85f85461549c1ab16efb9ee8feb376f5de1684500d7fa7fac5b99430a50fe9c4b8e0f359d3dcc2ed8a864822e9593b7a490bf65fd00ad6d858b28652f4ea4864ea6aba2dffdf75b23dfad37d95f0d5d205b4ac2831a6254baf5782e25df3a3c50633ecda769ca0c8fd3a62cbd33cceefc601314f37f1d986d98dfe1aa7ea201fd340f3ad24efb06c68f94830d634a377da4110ff5a800e62380ab0bfbaf6221172103ede6fde44b31de366eb682a2936d7c656623be07a8f3cb3a8d97288c23ae29dc50604e1c6cc2142bc6bc3487d6d23537bde047fd4300724188f3b8724328316cd671cacefcb053d68c4f0636ae2fb3ffd2d583ad9e2f1f488f3c47a3c90439487bf975ae8374379648b7eafe6e619912e4914edf63331edc1eec8cc6f0dc23285c09acfd923b7bfc120dc4ee360cb7f6f21c5153c853375a7416eb4604510008986963016b5f1091f22fef8e857631c964169a8f10513be31cbc3b4e28fae43e3e8bda7e3e7b3bd0c5ead23c24ec5bf9038f9198ca158c5a50bb0273a14293a89b1c5d1876413b9892d21db4e7cea4d3d3c44d7e2183c251aefe8bb5decda8d8528e2b58e7b0c9ac6289bd0ca7a5989c4358e1ec393f084924f0d9a396331ab0bdeb862b6f3564b4636e74c374e9dfc9fed23301ff84e8cf990bbb94368c6dc7cd231e6bd3335b4fd4099b63a335ca07b85ee754785ee50603cb8d56c0a3d9443648388fc0b68c6561c0f3cd87a5b83bc687ee7e44522073f6a1cd0097879da58f71235ef87183c8d5bcfcc30a13d097c2285d85fa2ef510a307903ef078cc90334fc33eff69381049cf4d6d31eefdc10b7eeff910eeb67e2f41f8df2e51a154a47414869c6c4e793d010075db71b9fb8ebe4d5f2da14735fbe0cf104a27393fd771cc094681544864c94943c2cac288bbe4b29d72da291b9c08641679f1ea05dc8a2b67f69b1fe71103dc740bbc7f207ceb16e1843b4deeeb3b4c8febc5ae8cfbc1ac15e78f351a14eed6e1676f55c5adcfd480f46658187e1e5b024e9e77cdd34673ae8bd317f0eb52c7ad79f2e71025b1dd443ef1874ff28efdfd9237c79d934381d293eedbaf94bf7dabbe67f59d58299881a2b3e3cbae9ae2c853ef03a8eaed74b2906191bc6b57fa19f15da627c140eeda4c7ef54b3362b4def7815e6a62edef70a13c029a847b4fb8d8ab8141f1a315cf155d6a22580f7ac4a31d964d75a6c8ec427400f187dbbba43ff88ea6606b08ac5beffd1e5fc19d8e401ea1467160a2afc6a9b162a61149e37644e71650406ccd4f10ef8b1d41c75e0edb17e56fdb8f1bed87b682800d8c58722ec40867ac9c552bd7fee5ad38688aa8e22fee023b2bf12d0ef6a8f93b9b75add4fc00080c2360c8247eb5a42e3e0788d506e2887f2ea6b8144f604d0d9adc0c95d8d67b12fdc5183103f6853823d2b8ca354b38fdc954fcd547d9a5df5fcfbea541b05a044c9683adc93505134a9716a15309fb17d751f3a8336622ad782c03c29dce40473b150646bb81167a650a2792dbd9e0e848988a1a65ba3419afada04e2c2ed1ed070e1690eca8476cd3000f8c3459ce2c7fe6370da94dcdad0a8c43e62128e01f822ad73fcea8128811f97502c100a836d9a3b2484263c5aad3b909d11d07735d5ac4a889136e2efb0ff27c1ee2f5992818dea92f303acba33b30a32e1b3036e52f6dfd3ae86b762f0314869d3a271c8e120c4aa7cbef715556d52f0111a09afca7dcd079a0002a11f5e8016acc03a4ce0320b323d2c1ab9e3b5ec51ac62ff2c566713a701e1613bfdd84c659ade0e5cd58ab8e191cb850afb6723053f0645ebd6c0148bf8722bcaf311e768e705448e7abc5d1bd43a2c4d4b8f5a130f172bbb2c8af0a9ff11fc52533242a3644edf147c2a44c6352853ab75d0442a316dc53794f48d4319c3fbf40cb7e482372cd2122e3e24c6c73eab5df9fac3561b816a6c5160a77798588b35513bbef545e7fa667bb61924ac6e3991dec372fc4489ea49ca913e619231fd5457715dc1a47f6859157aedcb8d74c160d72e494eaa4dad4f287f3fad0b333eab7d5d1a855e930acc1904c0a6b41d061c9478a8dcf6631872341dc50bd98193db220fa4ef8357e5b1d8d3e8de66ca82062259ec54cbac78aee86c62315fc9d68e1a2bc0a0667fae227875b60db8005fd180ed9378edb70896309c201debd1b372947516e3382a737520498f35d35a6bd91f4035bc3bb1e6eecafb817691e724c720474382890378e24ba2bbc802e7250065d4948ff26565a632aeefcc5d1c71309cd15bcaab046607cdadeded1d2b08121f260168dc262983d2e6cd96a05da8499d742668f66b320f768de300f57076753fc18faeffd6b4083c74a5e5ceee3486a879255f04914057461395c44dc42ffd6e27920751eeb4ff3743ace3aedfa29316478f5e91d745be16241d49a5317cc7cede53e2bf6f9e5ce7b73e6c31827de350cd4226a88bdd772ae9bbd6def76d6601362015c628f6c346cb3a8cbe2c5b173d32cd3294230fd5f23b395f54bd7cdda8a56c8dc3c127af3c184ab372ed5c578fa7547bcca72f04dbba1d395388a0329a4b9ba519e9fd68bb8b5cb245c31dceebcbc3dbbb45ad02446320c7a532de9ad4cee163aa538a3e9700203a17ac4bf6e82505c7e170d4a21ac6ce766971d6025bcba834dbe27520b59c8afd240cd3516f74f61891dcc2a0bf3035680f12a3339bd52754d1acf5c5c5345dda8c715414f3bcbff12e561c6fc9599630f7a221f5dbd5d800fbe7c53ded7378005d2a7dd2fa2f4f587ecdde4cbd8ee4ad13a197bd1a8a0537e740e330b7921b71d6e518de2570548c0afa35a4debb5da70c41cbf647efdb91fb896a24012b3fa6a8e9e05c580d0efdc240127f1310ba7e5d8cb3d41e9d490ea0e6d3223bfdbc01447dcaccea340d70876a47b16eedff129d85a274e9023c4d9d98b4fab36a59b13054c78bff2daeaaa0a1378da3f33371421d9a38123e68b88f32d5d3a55a980c887547b12197bc8f853b27589393833d9a11966feaac75628333449bb547e87d2431e8df628acfccdfe157ce76e8a14c3459a45d07e0dfc08445723f1e5412a5faaed044ea2665aa62675cd27609ee8fa9496f308220abf04914f8655fd58e8ce005edf8be84e7938faa1f431e2c3bc1d6879fda1c29ea3325c3a2e855eece6bdd911cc18c10b802d464e02e54a5f87d465d3865c47d0d5dc2af79b29e5eeda80eaea33e28cd25f155a92d4f081789cecaed6d9603723100805c806e0911e7357c03fc9ae5803d453dc26f5d1f8a39a6e4c4d97e46b599a78431ce80c125287f98f81a2d7224dddd0806d33630b2214d84cfeb50163b7861a03c4b8565285db6522fc4d4a94853d680bfa9bc392f3b1ed2e13ed668ce2bd74cbf29d3f46589aeaeffaffe307e4f7f64a9c4eea3897c1ad6d78e3318d333a3874080ee95494626f13e985d1e4c0277685dabda58468781dbb8d8a4089718ddf6d76f46331678245af1608730bd49005bddd1ead6e8a02107fce73c6700621f00d6e66c26ab5a51f931ac75a31f4b2f6b0bcf681854c2bf755f3e560b999e0bbec73ad3fd3c01bac53683d53324eb326170fb45412a8102c8366852ce7960b1ae87e9c9a4787a2aef1c7f91c40950455b6e975fcd05de7469072252309aafe157dc190f7d1a8f292b4902654f1371bb7378ede0c059b18e513a8ff339bc4518be183146b3c310f44658f583a03a463d3070edb85dbbdf3945a6bd308f268400d4fc46b6a332e9d36334b308cc16dbca85274a34c4aac69ae2c4bdd291313909eb199e407d51a4bebfcaa51a9543a836b6555d4a8fb2ea6d43a72e6c76f2d4a22d7baee4dcc143240fd23f839acc2c45d3a82ddc14222c6adee90d42a440e658c30fbcbd35541ec1075ecec5d9f78ca1a7736aff08778c746e5d78f16e719b76946c20a6dc1b9d8c1f9951d3a14b8b7fab4c69c3c336fe38d1aee16c5429249bf8b3144bcfbbfba4a69db69c7b9a81ea8283fe02873c1bb99d87fa495c9fd7100a4f25def31c0430cad5b4270d8c48d1891a20ff53f032ae9029ed762f015f0f502dc1335f251f328d190c204cd3dc8d1659114de102e52c99858ba28b1812891632e446869be9a0afe45f7b2fe0af36df08542780308e3a10b4f7c88fbb91e2118667425a22169d62b1ca0d133730ac0a1885ebfaabb31ccb7be20806c3db2452311737e300552aff158674e907eb208e43dcb75f0459f9aa8f570d4bccbe063245147f7b2fb0943a6873b6170dad60c6686cd824c83b8935a6d5b3b56fb61ea6f49403e38922917a03af213a63431e35184ce2f631e839e0576b7c1d276bb4145070da81560fdf6a7dcde198d1ba9109a14f7e3ce88361675363f2c6112b0c04fecb2fc6b4d1e56c86fe60eced0472eb7d53faea2e8ab375c98f55f358b30db4976a3e8eafe93f6b9f14a992926a3bed08fc53ab188ff86292199282576458b080c93536d22ff1f01556588e23666bbbd9cf9c68b7633238a1d9b09c58caec822025eeace0aa94870329e5fd99df1eef747392a976560893cada76c197d141119b01dd701a61776dc0b7eb085811dadad3971af5430ca4f43dbe5f1a3f04c4b7f60dcaa19df0a11fff08b46abda11f06db434635b760a004d7dfc36398e0cc8e59969e1ce823bac7664a2b187fb4847ef1878f11dbeea9c01cd8128744a54ee1e413125994a74804cea127003451191377a4ce0a21948fb5bf21d81d72a8fa1d61098398f1eae5bd5ac50e011cac9ba2a27db284cc26d3d15eee4e975a6d7e5b6b63af1cd904b2c1d806ba115120c4f5045c8c61620bb9ec90532895228ad3dca39e89188daed332b4faf24da82ba8ad1598c399053df64d6821bdff9454c7c57d843b21109bc4f66d59ef5319144b0dfbbaf5a2ad21545a666679edc2a326447da9df9866021d18492dbaf1c08e864bf1135aea5c65886e7d366d907cc02a680a5070cadd3c826e6aff0cb0c319b3d23182590fda560983f233c5d9622700d192724a55e62fe6622e08fc4cf3396e7eb990a522bb77ff2a2d222f0f67e2fb5660f4c9aff8a36ba1ff9e9a4317844e9905fd2fe5e47a919c881b384c06274074c434f4338ee161679c5a0dde6c9e4595d498e254036470234e3ab9b41912c259b18034cd2fbbaf577bc926ebbd9c74ad7cf5d1212fe024f44a02cd4000fe710ea38c53a0a2f09fdf41be1fc0d1e12a44069351cc862a9123a2fdbc0f52912d0ec8fb2930b5e0e80541654ee9d05f4ea25cb55417006742a999d82412e25babcc21478423c9871c50cf25352c8fd0c35ba329e06d6c5b7ec463c354ef5f63e20687ce3539f71a5e8c9b244a26c34dd1d32d31bfee920ba41b244e0806a5fe70de8c38726d6654bb83b6947e7f84f54a7db2ef2e08a9c8aab87213e37e0ee01129c75194dc86311ee27d920942ecdfdf8e5e3a869f1ec2aa1a8654680f55b7090d3b17a82f1f399e527c50ab612d77c5704e2b42afafeab747b632035c3c1ac0f55c21c3de1e5caa1eaae8ef418ca8e20adc1bd062a06b6bf46d6519aa23831e2635306069f43fa5a02654273f76e0f68de219da70bb33ee8ef978a2716132f66c040619468e1de48b563feb7613ebc7195b11c4eb62066f2e838fa23138e2a4dc926d89958d9ca8f36539ed5837d52fae67e0e6022f6046477d4af2556fc1b4fc79d990dea4218316a52f662a6a68bc00b4ba944a23782777de01624c908a40f127396572b9ce57d25e3a92fda9d7202146ed23acac6b3f30558b975221b80e10b2d29b1ac7cc61ca96290e169fc0fac02c77e0f0399b19ad4d5c70551eeb2bea79b332929533fc5d935179ea391839b9ef86b5bd7ad397e03d5544728e32ccba77125908217c47048a11e21d9fe697989a0b05b913f6caa20b25acb459d406fefc07511b45b2cfa5813be74e63d943de8a2171fd81349d0e66e991bbe8ab95b1331e627398f5aeb77d455841c8c08951d0d8f5cd74224dfe4e5eaf9914402f00b09a7a3da928751ee80fa324868541354b4b6aa34ddc56ad1a202c2791d7751d0c3d87bc58c8b5fade20bf27fd33c728f215c9e482e91fdc377f74a009c757737c4accdc2bff1d96b9b84b56490f6dc27ed80c61d842d009f380003b8e6b48125ac8a1a0d05ee862379cb5769b510273cef9b4b61c1fc689156a5d15fdbc9ed64c76cda417ecc9290cc798ceefb939423dc62749b277ffc875edf3d0b488d458f56d2dd4c61a0b6724749713ac33576742d4ee2da44ddfd1656f76c52b022592163a8d8e4381d1bf2115228f7571398de5ad53675a01011ac5cd863a550302e516bccb468165199cf2e3f443e1e38538feea1798a3ce24a7b7ced5047fab7cd202fba5008bb6b6bbd4c4139a5ad3ef337189c918478b2bcd47ebe077346be9670bfffb270ed36bfff726ffae98095ec76e27891ce43c9874ab2f751494085ac2c447d603e11080d685c419c7fe743c067c0d3195d10c310ffb0c7c8e9d8721db9d8285afbc8b564520ef003d072fdd8add5422c0a2d6cae111efb803717e8355858a9a531d71bf06e42a91a78360ce1be741bf06cf8a0c75239c8f656f7abe050d045f07e2b54cc83b59806401dd52ccce7d94f516d33910caef8d5feec9f561b659a4d3f16904bac1c7814a751f2d558fc5e74deede7cd698c8f625193eb0118166a478868d9a933097fafb8604dfcba46d0d45d866808371cdd287c2e0fee447f0ff60308098b536f062c99420dec94d429a38bf6c4f6e0b0763a39525389f87df28f90bb3f7bb59ace6b9a9bc76773f763c90fdb7936aecc98ea4eccdadeea9b80cd98f4a3d3c6d9e76fba810c05f0e078692d1b3de4db658c313052345fb125dedf7b45acaccb17ee2c454de534a543e74de77fd25ff6ba084f573399dfa4b169f638a7ca8329e512619146d115b58fe512fe3c63a556ca229b273429654ef46868b859891379885d9490fa9db479ff6d15f9108b052d977c7e532819e716adf809b91df45df42d1f25f7b7834b0b23b5ae0aef2135555005d4704e6e33a11cc04fa354d0ff6663d49711d9745f33bcab311f9aa899bb99d2fb8e1a171175a13eac23d01194ca3e06315bbdfc24493234dee4f97087e3ca0e9f4d5c7fa7589c583f31aeb0641f05480eda1b79e1815749708bae711c9ee8ba93af993116df61b2def0c8706acc182bb572f6d96ada61e5b30b8947b8986e90a35963be10d11602cf0d22e09d1421512399c492598cc09df504ed06ee00b4c22303f89befd641557140dbd250b51fb69dff558e9dbcb6b35e758301274da80730ed3c6c513ef33e2da98b140c446c86ade6c180b38776d5f227e527c330c6dc8fe8de3800a320d5ebdb9d3fe258faf98a78f94079aae28026efb8b45e6b446fee627832e106cceed5daa2922826306693b9fa90241fc7017c48fbd84206fe1b7faa68748717beb321d3e7c2f41c96a424236208ef006e82975a1ae780f21a34de3be4be9a343a73adbeaa143b78dac0dc568fc7fbf7d7674953360b8d474b5724d5ac33de0477be9bac1242743af34b4eaf707b6ac735136a70852e5a7e390f57468d45ce41699faaac21c8a03f5d0c05a199342cc26423e1061eaf60b6d2008cd6096d71b5b5bf477c620209505bc6ddded13e26bc16e6f196c0cca60c41ca3171030f7b6e243b4068e48bd74330b9de430f7b2b729e83a0a50f9d7b454ec27ab42d4f0210f6be2f75d8abd373b04a8ce448dbd047f8a105a714ca2dd843d4f25c78b573f8f7f7ed8e56bac085ab46fa190adc41b6d43cce62d69e78116b3a716d35cac8a6ba91d24969ae3a3a0df1627868f162f4143dc6add43cdc4d5ccfbce5efd8045333f536bfa60aa6b6ab62a38d6e241fa69f0de1a6860b8640984c015e68d4fe0910acd55082fb83c73fbe75f325629d911e9ba5704fd6157cb91a17f7a20e80b8286ace91f93e2e71d331c5ee6df07e4537bab3cdc377e92eadbc0c907af93d642de9be60c483cd5ceddfb053a4db6b978ee0c2176aa031bb1d584090823c4e73295232b0ed69fc4baab38bae6088e39ccf546157d89257a76dbcf1ff5e98c13f034c1a328433e6a458d25d20e95fe9858a37e95e5789c73b2120d72640755a3bd25342b7fa88af0f11712f1b19bfa5166464c19ccdda03383848954e0a4d6f8399b2a927de27641e55659f9407d233db80e636de03cb805720ca26efb5a7fa962fa182ff698faebad911604e59f807257946956961338c22e73f1c3ac21c7709b1108f2aabdb09b67dbcf3fd71e8f8f1c69b9274ef98f46d4a4b689d42e9fa60977a01967e6a0954964c3593d6b747e616611acd46dde3556a10d160989e550cde999e95800f4e10451f3fb9a311db1a859028b3e05e588a1f66e1ae3a5e26272c6303aed6755233cdf4743b93f95a4dc84dee8d69b3ede00c4915b8e4c42a46f8666fc16990055ed5528813cf9c4442d21ee05f6e0fdde130afd2367d83a3640427e02e0f74f899d183486e1049a3d4e7f64e6772291ccd984830995405b8de0a7f54496f361e00b9eb1a5aa36d90a1fefa61ab0db508f6f906bebc9952d952d412a9e9ef0ecc0b6aa339f3c115cff584f07e854650c6e2b2284c4ad4338f8768a0ec1d8e69eb6dc7ff2711f4994b4d65b62e8d448830994f043e1a96e424f35e0263c9581f034d92061f349224a2278f70c8d5d28be2985e98baa322176104b1d905b4c53b565e35be7af26085ad8dd1972983d249d6fec4b68ba39f5e3f6f23725850a697606bd6b8a2a32e4dae1d9cce503c762da5b0597ffc88cab871cc959e33252433b4e348437990efcfaa22be68fc4a13895288de505eb436586db655281ebbafc78923582c8925adb0947e610bb7955516","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
