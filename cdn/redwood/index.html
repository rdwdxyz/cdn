<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c917f09902c309ba1d0245c13b8b9028e0fb0d3b65ade1a6dc272f58cfdff17b61b4943d0532a8886670ae6b08a60b9e91d070306425bb65a3d7c7ea831add23c3b9135c3e15ce5157b73b827f00c61486d0c4a1c0a860427e90f2981634b28cc313edf50f50ae31331550c812c8f3888c5959b198a752baa481d686c14fa7d1de57b85d87ad1e641fe1aa50d3522069072b1d8f840f83ae394102989b4e9c32b1f488633385656a8e065068876b9583ff25758d6ec4e21ab630fb970d249760fef68d1c5d49cc80f60df70f1ba4e90289937f62cae2fc8175a23c914572ac9a8f39e82c39a375b383d38639be18741b95d8ababfe552d280f4a51a8b9a97e550dcc4cda0f60d85fe6c254df7e9bc5255ede31bc34de5ddd25ff883e6d23683e63f827ed923b3e21924f6a376c00a527e85c8f0aa1db3d81f9ebbfcf2d296bf68ce843b6cd68481ec693946786d377e6fbda027f37937fe46e929cc696cffe1895a6c2d76f53557a2a5d5a62dd04e501da2b73f8bcb27916f5582dee6a8acfd8b0d9d4ef49a440ded51f5a3f9f7f04df91e1fcf3cf9277e639932141fd6260408227f421625dcb9d289916dc7470a536ddbd409fdcc44fac8db0acfea03c3651cb4cbb399629d0ddc338232f88c380a317efc36f51757b44c7175167b900e0e0cb5c365e3f7b71e23bcbc01f18706267417495519b81fccdc7ffc4b2c78be0f696c1fe86516d0f5794047b11205ef2a112f54c9d7b26e1270e0b5f51f69e9594e96dc9297d784104e60ae54c4e085b6352d7a801535714567fcf4f2b84183f840142d50822d00ee92617b780cd43e650c97969ab5717ce85d63f6e6d564090cce432ca21dcca41d8af0d2a5bdfed737e1beace5bceb0db37a93adcdcbf3beff0cc773add0d121ba555139f50eff359c45ccd13ff188d92933e14e1951392ebfbd130a9de6a3c8999777bfd7efab691bdcfe2eac515848f8f5051650a640cdf597c99861c1f56403c50fc229dc624888ef584fc6975bafcb5e1b276d312c04ee0e73bdd4c962222fad3aef21be0e0f26c3130ff7629deebe758b69069df9af48c73426a2b8034f814a76d92c7a58a00784d8789a2fd12bd7b8ab9e27d6dd0c5b67d2e975fc481d29effba265f06ab985962d187cfa90975db5e0a2c13e4ec7a0c345d8d9a9e8518a6471855cc6ff948c74ccd30e065918cbad438862843c8ffdfc218da110e40a9c6b30d77444cc798c7a3330fb42b097373ec94d82dc5e7394c5c68a69f97d4ac790ce45337190bb1d5e5d6ce41e4365d22e11c2c72d42c73c31c6ac73375369f2abe439a532dace1a48069834547b52e86e0010297bdabbf2152dfcf157595314361ede11a8f791f65f9fd878a4af2b39b72f2dc92d1bc8cc3ac6799331f11bcc0bc0ebcc2a4bc08b6d73ce264ab8f1b4857120f3bd1a7ab7818ae83771e8b58c0d4eb5f4dade617392b191332dbc896ccfad4d6262ccd1ae25dc9a4599e25f140fea043f922539ff4b0f73154b9097a815fd5d4e51e6fc56300b8c26b81f6dfa6d8e18e17cecd8ef93e1c164855a5796e92610e403f4d5b2f3f1b3ab5192a48de5cdd728cfe268cf6b9b2fbfb105530e4003368f3bc7e6bb238825d1b9434f77bd9eb8ca467091171625db365a73a0138b51cd9ec2d83590cb1173715ad6dbcaa3ebb2e8d5fbca069f042e44ca5f958d74272533b1dce7e9ac59e08adbbf9a1e46841de521067e7e3b880ce70d1a7a373222f4ce9b50d163d731f308f830caf847b6ff0a05de3797a9d6b81c843542561a6c530ea4dd418005671e3476a4730d6c1d7841d232580abd718350f6cf9f8f1a12bbce6e60d7034ae995e233852fed353990afe7223de31f5d7011dcddf8f25b6b4ca08dc6f7a831bee0fa804ed39b64278eb68a06ccb6683c57e7eeb2010fdfbf6a81664f49a71bc8f5a8e3adb90bdce7836681133e11c65aae0d7790b76bc528247f0f8b25471f58c58ccf2f901b5747f5a7cb3e52b1b0c32659b89f95880c6e67a68c4461877860a639cd46c28007086c867a4707ee7637ec14eec494c5374e9a8f007e82191ed7fc661768661c563fb265a7b9a59d1334ada2d78a51455e848106a7b97fc908a686333c8f9ab9866fa0ad70feec9465dc2327541d01c3bb7210f138ae84cbbd79ae6119ad6a6b717a08af56c125e19f4669b85f74bc9a9eb66b6381b0c63e789e22acb53d4dede1f008051adbb951982477ec22ba8d685cdc7fe0bda3fbe84560aca0bb86ec8dddf955a14d9d7a2634eab8edda9d878cbe87b892ad5c53fb77cb130ac79e6ea7a621359cd6bf7cdeb34de4ad6698272757f2c6e242c77c840929b0922ca065fde8eb761474bc9c095a2f2af5c29b57c5e3781bd8e15681a38935d4bdea88da2410448ae2ad56ba5422c1535d4fac5e4b981034abbb771c84e335d38c4b3db0f864bf2258df60db12b6783855b35710e1388e0f15732603389c6ef707082d808ab272bf8c518b250ba5b077bef2a02db8a88314fc0c5513573612ce50b80de9b7bc69b8a7df813d92622c13369bece409b99260e2c30c0d3c38e78f5e46cfb64274a2b067c2b6086fdc1f938d3258bff29b6b15dd0dcfd570667c9b9501d6de70b2d364fa08500a3ab38ba359b84461365d438709b2d94e89749e63971839ad6c3a8d689de848b1d18f06df393083b7e5e6b76953fbcce35352106518c1f7ded83f47786ec6da5d544384bdf019287a65a26836e253f34da30b80259cf88f3c8c006bfdcc5a1237cfef393142b564954e4af599764793483d4d35002ae569913bd072ec25945e8363ab0584a5849bed5621bc0015f5986332c8fe191e4d85ccb848c009f15cad57c625b322f4a22cebc21e05f3ba1d7e9caa97752067ba37e41b2c7d73a21db3c1ef9d94553919b1f40b9b97778697f5d8aba26821a868760adf5113c8f53280db08c77173893cdcbfe7c0a519f143581d76c58534e7cdf5a77cd6ec81be1479f13d47bb040b67292c7a2b771d7c86d1085d04b3f749ee0b6cbad787a5a0da879b4530773d2740633d3a0ebb0c4369a2431aae172785426100f476ada4df02f5a640353992301d6d24a8b753466001e0ba11dd52d0a2326a90bf5a495b96c837e2fbea804b6f07c9210ca153eed13e95ab5230ac6b87edc9b49a5b38270a7b6689227c980ad5e2a68f9005a2af759400b74a555f9bf352bd09827437d8337ad0cf5ece91a31c638382fc2873dc1587e6071fdff611aa306cd3e69bf3b031c66fea87ae9900f897783345a0eecab3833113a2aed441e44380699fd91a21942589e9477842544c7155feddc7d88a1819d434ab2a14459d6dcb38622474d85231f519085b5f62f936bb276e173dae109c1c031a4f0a2944cc73675f097321ff61fcd1e7727c89ce8f75f52667d097c4773dfe6f2e1e173950be9e575b145194b6d241f91c7b4f3de19e7ce166dd28efdcbe054b1a3275c21f7f7114beed4e9a7d6974e1d240760118c9084d82af3e3dfbe1dde58207138d8df5eacc0129c086d53cf8f53ef4977ae2c3ad1c9a19d2d841f0fae1536580cbb593d489b6dc92cd366d3845d3974cfb6530d6624ba4820751bce7b6b347ee42f2c3e49d24290faa0f3854c45eddb903f33be0c81eb459d9d9800398a9f776f337a42335fac013cfde63173c38a0594909c6a98b1066b8c13fc6d43c04edec957fe902251d24ce43e1e475441ffe5db3ac8b47271d62720995a511fd585080762c730ac58da2ed3bf99b1cb962ebadbb12260e65db8f9bf6928198582d67e6eef0918ed0bb5cbe63fcc0ebd92405b2b18a197e604d11ed5d4b1196e4529096943655abf6298e4b77f6e007c8d39cb434779809ff7ff95a0fc33b5336131324aede403bc147cea63cef67c32c00d845fee90a73e1ae040deaeabf34282a10dd3dd85f1cf13791ce85a5fe3f0f244f91562a3545e8d37bdac3e085ad7db571bccd8a590c636702786186ffe1ff0187480a1db4a25d4213f0a2bd896f6df3d0c47ff41aa2d953feb24a3219ddee618777702b3caa15b95d71abb96374e7e1e8458c2ab25b324635a8cfbd4889eee7c4abfbb410c0b8c7f0ad9c339412d5267761a45279b6d12d24a7b17fea8552e82e4b2fd6fb34bdd9d13ae699ec062560ee30bd3005f1046f4f8f78e413039cf561e6aabd8edb3d6bd3657fdc34b22d757fc4b9a2b5d71eef90cbf060b16e70440dbcc946cbcadd43d400697225fbc670afc72bd6dce7157529d839d5c0f9e5198b31c94a76c0fe6eab65f6e13694c8d0160b0737ac10b155201c71aaea9ec8cc1e6f26ee17c47a9cd97489264d49a13db61e3ec0ade30e18d60e905041ec03e0305b1f1b93c9d3cdce9f4989c746bd4d597d87d2828bec2a27c526c48917594095f382cbf003ef7354d954d08367d7137c8fc8f8605d6ff2e0a6c02779567a3ff10660119da0e4bf1139aeacb655a9184367031d6d17abe1e60e0fffbf92db7381ad783bc8779b0c86bc60d4bb00799e5b44df86227dbc686d2c3dd62896815f2f8a0ea0006a599c22523950c87257b39f9511f9425fbf51047046f2afb51f1633112bfb6471219a6307ca1af51f31152a0107b53eca0e35bc2b0a4ea9c65e579fc352030a42e08d4f8e8c4163580690656b766ba4aa604d4509f7d716d407569d7bd357d8103d2ef3a4be3eec3b0563a3822774b18f411b43f837ce708cec4a1adaf7ce9ccefca2d158e244a33195944b09c4e70cd2137cc6568b5d46f8ca4bc1d387711016870d446b3d603086c4d082d42fb4e72e7f3dc2646f836026f0f5804bfa3b94ec48616828dbf4830fbf332468b7571405adc7fc35fd07774f107a17659c45f1a97385c23c5dcb5bab1880317c10b211aa80a5e7db79b8bff07ecf90ae15d64691065be5b97340c42d80bafe9cfb5ac4c6cd8f9b1c6dd26a12e5496fdcaa92f0ea40c7ed96bab269f41651e31608405d982fab0dc52ef12ac2f5adb5d581d75e122ce0cdd84d47aa336e798fb460e343179d54f7231de9878065c2d98ff44ab1daa00730bb7546bb3053c413c46a46047a80f38aa82bb38d94e4176c7ba45c1873969f1a71337236fd1b4ace9c94750f6655985fc7bfde75ef0b7045e89335f0380e5f7ffa92bfa7f56585d9908385b8a5b75a53f56e595f070af703b9b33c5c2e9b9c5f97fc80247725cad0b9c6d177e2f82060723362e2d5ba5f2fe3c62be654c56b6f13e5dd0f22880424e0a28d1a14c5d79efa12d16c31227e67c2f6e7994c7995b077779e9a95c315f08f7cc62095e8a0553ccd7ad72c8d318e2dfd7c95bf1ea0d6ab41144758122a4d0224112e35312b9721b38d25bc7292d9d179f9d2d17fecf11678e23c9e1d66f7cc31cefb27ce36418147573844584b3e050a5359b1b9a6f3d7242f03d297ce7a8ea276a666b3059c551b068f00387b5083beb0d42692a3131c8ba7a86b8c6d5692a208d6f76a8bd7eed378d8d601334eb2fd9c16140a32e1d6f87f734dcb2300892b3aefa3550d52e0772556a4da7ebca6ebe91baeae4a5d5fe1685fd3fc893128e3b203c23e31c94fce4e965b7a6c36bad893a5338c423810f9a331b7c8ce57721514240f3617a67cf03c0f1ff1d893e7c9265d0595a861fffc119d949d568d852a0f2953ed8858568cfdaeccaf362de2bf241204b10403261208d3d607c1a7d953fd8cf6518495ab1c965bd2cf61a6191c0789172d97042ec6351f670587d9d6b4aab8df2fac66feee0d37c5312e01069f637e8f0d1d346892f4a209371bcdd1841c898e08365d2d051c4a674a35695ca6198bd704922adbd5d2153db80729367fdc163b3e92af00bc94368272ee978db22511a430858c2d469470bf2e05ae60ee4f93d97b227c9219e64991a39cdfed8273a7d00d2afeae0dac72f942117dfddc9e74457096791a71d0a5029e04a7bb57fd94a3ec217342b5a5953836e2e926463ed5f2186fbfb95307ee865dc6a47d1182b5e66b5156e33ed2ae388a6aeb2dd1148c9fea3aa5142ca869e20089a54163496a25ccd3f593960aa44c2d386556b77b144a3a4dad633fd160b7a8f433ddd0304f7441a99dacd37565dee6d7b99cdf52307777d98d8d9714be034beeaedd2919246b02cba9f57adc8bd354819a36e7934235567579fd8a033e307a650be0e7d76b32533ba8e1bbf81fb2d08833db2aab698dbe288ba0106c916e1cf2e64ed764e4ee91f5b4e770c744f0f5c4b90ff1bc0d97c28670ff6d993acead5f10d68a214d76ce5903d99ced1fdb9638a33b21f3f59f50889e2bfd57e5556529b6a5e76aeebf00ad586d3ae919d431c18643d198b766ce58fbbad6d24a9ba9fb77d5b5702757784fe7cf592c4fd9c4a1ac3afcdcdd30bacabe99048d52b24588351b9bbb4eb8442a2f92ee1a5e686a7f80394f191a491e336e962d6aff565862583d48e27c7278c218a3ded19d6aba4775437cef538dfc84a8d9395fbf8bcb9e653cbf3534897b10e63300ed6bf77f4d18580e5b9f46996c755ae33e61c00041b3f02fa25de5426c217c32563a1487450982e8f15974c664cbc87c0bab0d444821f7e8da1f2cc2d27d93b15383026008487f07a4126b858d3c6adbbd7534a7054471ab5a7afb8179012eda0cfb8f7b303e1fa7b392b37f0f8574fb6812f04bf97c678bc738a16925e3412ca1a5f6b5188b836cced4a5c44b6309a97e46b73913b6179311c262c10033970c56b63688991bcc0423f3c535da3ff307b42c9bd604ad3990ece85f53d69008dddba2c6fe5cc3bd87e4fd7c891956e74994ca17edab0f2da61bb184997b4d13b5c940d675d24fc9f66146344bd420a642f643cd852e0dd4ada7bf7bd45e3614ad60b409a196ae847fae472d91e3cc6b4dc45a98483dcb7095c8cbe9c57e542e808b28d870470d0b6affc82542ec4a3017da65bce144f5d8491f3a41e22406cfd65647a73be083989d9e1c061d94253b24777d8cad030b40b7108c15618e4d3b07499c6a7fe0626c23123b22baa2bf7c130b41894456727c7dacdd05434c1e3d734c85e14f78b4add17a95165b9ebaa1ecdf850aa8ba533e13ee9e5b07799f685898f4e11927f7a8fe2ad0c9ebe2e645ec0e0b845a429b90a51ad2bc3c5be01de77b1ea5eb28c81d1310535ae22275696fbadeb560ebfec327564ccd3f2c16a3c93cd566537ad30a8d608f5fe0377b583c12a97a11aff4290ac54c2a64262d746a92c9b671e14390ed9709655036d232f282a0db1280d2682fe06892dd9ec2387f237dd6af3377621ee155f6bbd1b687c4df78a948caf32e888e8d740af8557111bc6cc8472bddb7fbffbc5bf1004df17ce27c6dab76a0f05edc929f38316bdb051f8690996bc47de27eb6c092d506f24766c80582d4232476af6294f129ebe7210006ed8fb4056aa0892fdaff019eb69895ccdd32aef5d8d2c585bea4fb069cea73a560b88d7feb19c6eee5ed22f45165d6d2611b67cb8a3cf688717b20e88b39b760f2e58af2cc307d0ca2e87782e975eadc66f473b9033fef6a9f168a1b754ef3c90987941c865574f055f27ac33d7a5de6a992f4d6d554017730763f3c213ba24ab71d30feb0f899d42bb8bf5440d5e9ac72125018dd986428a95262067745f15e14a014a10804a54a104645388924f0d2962b1cb7715217f46f4093730a26acf980b1056f5c8b9251f48f3204ae6ff801d3c85d6c5b4512fbc51cad6b7bf2c18a29681dfac61e0de34b49437fba2e8bf578f10078fcc4401894601ce3ef9f8f9056676acc499ee82af5a8c0e881e41e13fc5d0acb116c298fe3c587bc33bcb6e74f563bde687063bf044c8e33526882b2dc52df57e661d0ada89b3a36085b275e0f0b16d694d7c406e33ac4d43c60a8f67c219e9cc097aab11436b2ee1853ca7957a3fb2a6a235ef35d32c649e8d8279561ae960687019cfc69896a553fdd7605eab1b9bf987634948e60e051448ebe921b1eb624080d659e1d1283ab78ff06defef7a9649dd2481117117b739166c0b20175beabecb45eca9ba574e92cd9699be5659f9693fff7da58507f7f54185da1e585b5ca0dd7784f228829ad666cf23681aecefa44d71a17c487cb33d6909aecb3cd5f84ec742b1eec62571e2572bc192a6761fbfb9c82e78d1f1eeb16e3111ee2406f47576aad57ff072d0097993e4ba909146ad1664a4a433be8f00db5714c326ecf193254832ab36491299a28ce020b35fbfc1979c23bbd5186f05897af3521ad98758500a85ec930b03980218019d932cab1d945b24fb829590bff5f35073b947d5f3d6ac339f58269e4c22700d690c6b09115a69295840ab5f4af48613442d166f53dff063a48c0e61d3b2acc9015b0cf6c25f7c47d3ba08574671fc0dab7046e492fde1bc38e7e2173a8ba21ca5ef90eb8d447c4e177323f0587bca86a7104412393256f6b10d65e92570d6a627cfe52bbba1dc7a5b6405490943d0c48f938bf6b3b69851722defc407dfb36099271824817eb0334a4bc2f466ae0da72df3a16c3b2470556ad5f9d312e91f63b5c870a585c61e3a430702cab30a38df20e6b0593f22fe37000d0c77dff235f98b7e6f402b3c4919e783ad2e6d7ee6b006b72d085bd8c6fdd22edc5be602f6e6f962413d4fb7f73730b81abbd4ffa897b7b62a1dbc397e51171abf23fedbb4dc091454915cc5d09d150ed5009e2a6a77d66581d9c390939fdc8b538dcecb7f5dbd4db1e2b7aa4e346bfaf29542467eee2935f2dc14a7425e655e49437ef2ddaecfb1f2b5345e6d86e7f4dbe0fe1b820a5d7d11b72b058d6a34826e5a7fa96f131854035d444ba6a91f73203fcc301f54af57c808f4e69fb6558d45c46a6da7c18ddc8361f1783bfd247827f68d9d17509b560ebbc6c09f086355f21c480665c9aa2ced17362f6f7a3b397fdf546e393a479d27168ee038edcdcddcb0b58043d88fdaee278730e3869f831c429e127c6e3fe9f944768790f061957a6dabc7eab236fe5255e663c37a2846139c87a39c9d3171847bf430654e89166e2edf0659319dcff7ddd6eb7e3329c89466da83eb839f1cb7004f1b377a18351fc9799e63eb4850e9f822b9b9510a5fa512f08132faadfe7f1d5c04bb7dd899bb1261844e8eae19dcd2ddb5c6ab781f4322c2a50be08ae27b28b1eb871a037b878bbd1dd5f16a16327227f92c9b33e7c2ab561e242b49215feaad0e9909122864eabd255cac240203c0396c00d5b9b77c037a5da475206bed0ed7d672917c5030ad185f7670091dacb3ea434b24227e99dafe8b668247597aa784c47c575f98c02a43eddb690f9be92b35abc47b0dc96d66fd082942faa36b281a27c099bac80540c52d82ce0b5731c28bb7ac9182b18bede84f5e321ab728d9ed5b3fe4db6f568dfb43ecbab1c028d6be51239bcbd6b0df06ba975fce171d4f527278cd59735e03f6023c22257798025c0cd7597b7e19da51b9351610e60838eb800c23a11044ab1967d6d728f878a9df98ac57083e0b38d1ffd5671f8f08f5a0b94738d9ffc25f48e658557f13d81df350b4a1bbdf56998a16b542b208418dd683a6d863df7d611258dfd37db36c53104a844cc5153a00cfc369206a1ce04c4f921cbe9c7c455e5a95231902079994cebdf703d4f330bd1e8002a7d88f4920069ec467eef3e338f275be387850e7c7024e38ae1ff8090f44f9e5a04e97cec0594f3711723ea80b6c9eba7d9ac30e27bc5d1090ad79813490fdaf6f461a356beab3f002547a5032d99585ffee8fdc87f78c1c5f443e5a29c2347c66ae09e6d8faae196157b175bd541e12deedaf571039f72b0da4179cd244441c406e3db801d02fe133aae3d602e84f1ee7e36d3d4445851f3d8826af45fdb4cdc21f14c13f5987e0dd293bcd1b49744c20a5f5df8053896195905b371c64028f37e147f25e1da6a93c3ac12ba72a18e52a62cd398a6ea889ad695e2b3ce8d3fa852ffc13175cccf5974c57cd08f3b9e9074d4f2f59e0c112e7ebf5ccb79ea7b3927c38c7e4ba4e1eeed734d46ad5c3b1bc6465ea6826a0352a2d2c1567e6024fa2a70f73680d64fbd9b3fee3a0e727ad7c1f38d96274d2dae891a947dc6e9241c3021a0931ec9045dcaacc9c8c6b6a8836a57c6706e47f204ccc129c0cbeb768c009bac58318e0caaabcf7be4bc80b6152ed338584987cf0902e30fcca3709b1701c78293a689b88a7a29d572e3c195e424b5cdbd15fa52cc2857fe82a0f760d9268fb4b00ad95b4c7686e468a9875238ab6f155b39d04e42ab0ae6c0d77b6e240a04e424fb48d9b3d0e767d4359075b0f7391915ab141be958965cbf0521f20ca0a8f931f9d6e43cfab7cb232b0f8bd8078f1a1f055b476da22e09244c506281c4d87ca68bf8cad2cb80c8c73bfcc543213a46ba309c0bcb3415439a8e9c886eb95a93498be5d229241876d46854f03eb82d67b7352497234c06101766625b838e40a2b64668332c39cbf9d77b45eba6f4a64b1e3450f63c94016fee12f0b09452fabbf3af87c1a57fa6cf0747b47c4ee5a3ee3bf01d4ba66b8d6b55e63450a86f4a200e517366681966f954e17b749a89ce3699202614973554ae38ad6c2f6db4def9cbf420b1afbd698bac6481af033f8df167b1c4e1dde9b81de4f1f9ec5ce349d45af9a5f735326677d39d7343b74096f79e51a771cf95d8f54f23b8fe8b1e35873e15be4f8e56bf9eafc7d4683e346a11b225e4144988cadf21ecc9cb569e99b20fab3823efa1ee5a6d1e22787d3aa145fcefdf709626f8e98e4f03c3488c8457b634972613e3c628afff627dadbec53937775c9222b9f74d26c1543550b7cfd9af8f2cd8aaa4b20ef70753f9473cf96201d7e25e0dbc52a85c789fa2c598b5b7307ebb377ec650dadec57aeadf2fa0e496b009b134dc2df7df4a98597d1eb27ef49e3726777c93e51e19ebed5f3c315c87a328d06ae5808779a11b2765decf7d19b1bb3596d79c65b2a04c3ceae2335c1e762385187208be3ca914efa3210598e2ee86391834f72e5a0f0f8158e6eee3b69bb5f1df7ad05bacc538d762785eee4e932a8f8506e2a6ebab4d5156f138c72acdc981134a74bb35dc2c355d4c69cf2e4cc5a885abc5c2be0c83509acf16fea144c98e5ba6c40937e4f87ceb5371342b059ee0287a5d50d92727f909a865717224ae0d2f139be39fec212d9c236ec53a668cd9474d13bd10a167649baa8f2dd0b72ae8d2213e8cbef72f9371077e729d75e8d03e97bf10a3f53edad912fe0aa65c62da4dc5e1bd161d4b013c736b74c442f3e348894c81599e70b9db853f0de2d6b102a7bc50157529ce6393019f8df53bc34f168438c83e6a16592b96fff6b47fcf9b3c065f0727b1b29effe9a7ddb34e048115f405ef9d6dca0d90421d3d31da7c1a6de683a4229ad4cb31fbff80735ec52aea32d440b1c28568589edc2862cca378029b5de3b449de2449f96b83aac777710a2219c26f685187545727cc9332c0b764ddd96a02c98157958da8af8300a5e549a1d12d1e3955ad49ad3562a99fc0c051b733da254f6d9870d909e78a1b697494ebee25d90928a1fbadc120ae96cf3bd1509d5ace13ae98959f2d73a84e2ddf2557697062515df4cecd86a50a0d3a0c8068e5407bf791f6e9d51cb30394688dfa086b460fc57341aeb09088c695cc5640b3033d2522ee8a30529a2bd79dfd0245124c6e9a4db9dfb3d4f80165fa3909d23a55e48c52eb653d11df8bde2273f0bc2f41cefa9c597643ddc503845b88e6c0e02ec3bdd2e1decc03c4839d36e3cabb1a594e81cf016afc9cea0cffdb67ead6c00270566e5f139cf52487b73b567af27cb7dad03ef0d356eb15c65fb684d1c843e3d7f15ffef273d8352d33376477206219762350c9cb2dba0bfcc33f12229a1e88d8345d46d6c33d0c92d2d89efaaef43bfd4e1d91ff512fb298c930e7979e895daadf727d2cbfc89b25f594b003823a9d901530b509c945abf95939ff2e425d2d7395fadf7867faac67837f5e227fffbb8820936572b8f7b66a7e4ddfb274043991b4631bd319dabc6de7c6c0fbcedcfd473adc78dc676735b1305ce0019bc55b621f7c850ed47cb701a73e605720fa09439c8dfbf057b0a09bc46760a181ac89dadb89dd659ac0e343631c3dffc0861145cf69e2bdcb7c1b9cf07c486e8ea3b7f0871d5994f7ec52188761e05647ff9d20abc33864f342e4a4a6e59f79d9f15a8d06fdb7a0501173f92ed1585af4278361106e56ff91b3168fde2cd7c75ed7a37f09579f588c9a27da9870c406c4d4e40e7019b769b90a489b6f02a766faad27e7e6e22d69c782aea77c718d131601d1d8d0edf1c86b0ea5c74383b801942e68caf1108e1010604edfcaa0147534a5c5cb58375f80b349f15b44387f379e682acd8c83fa4fc0be66c57aba94a938f8a88ff455b6edc9414a43bb19a808a39dbdcb6ac5b56149f51ecea5986618ab11527e41b9654bb9d442ca2016952d711963aacf1963ba68457224f6aa37111e8343b31e6ad5179e1e47bb9619892633277f82e8cd4d3773154788ca2a67856518b80652be421f06f97d56893ab0e8aed6925701da51ef13d91430f4211f5af856691a17d8c56c48f39dd0fde7c95af2df3e8ccd8ac55367c61d9dd9a7ebf28326577d63b9066c831a41ab460eecc26c7d5912b53e198c44e3bd593ffda4185dd45a0d926abb4c302922e7fcad1c20b8af53b5392cc9542b064d42ddb2dc9f10e9cdf7910557ff96dd8af79b7242e770558ecff76aeb1edee577879364081e2c0d8be0102710458c0b6fbd6937074981301ae9b55a617fb9d3ba40a64ed2226397e4aafcd4652d81f1beec00bc44eeb079b3eef11cf2503ba54fc7f6a08862d6e38c1f6a0cb500761447c1c08f1ee98546cf4dd4d850a2649d863e83b0cd0d5ef32e33b73fb8bdf2fc8023d222113ab584f3efc83d053f6580f5d0bdb210ec4caac1be0ad109189a61746cc2f7d9243f3b46e2f509c52df89729b06ab4a29ac66f8d83b756eaf054e6867c57a46f86ca28b2253e9c3ce6cd0abe8ed01c4334e7756d72fb14c10154cc7d79d612f5137f5d9568529f75b61338217bc38eb834667d8a29a30d5882b3c22cb7d5aa9aea9eb00eb86de0f7dd02a428129f3bd166365c200184ca05c677f47a00add2479db2cc9f8ee8313b002eb0a38d13a88d8598336b2e34a349affe64f5b843027c6f2546fd3c7b3bed60aee2dbd9552c36613d8ca811f8abdb57f24b9fea1c16d58f28ec74539a3efbae5b0ad72fbd813c68ae00ca9431e1f88db50e48d405f784d63e251965911bcfcf59434483ccb1118e7b79d0a94dea7246e79ac0c690cf571e227c914c3c88468c8a511ad4c2c19fd1e5a0598fd003b919973bbd6e1a4a2b86e274065eeff5ff7f2c43e0005f38cca896752463cdc307b0da9de08d450cb76f16d190023b5b5af70edafc160e35058abcd94d7b120ff68e4e43f17db580b5c08fdc317ea6878045f47c559f1be74d6ec079034d7e40504a9bbcbbbeb18d5d6ee277c1a6adfd61d9eb66c2845591525134817de3c03ada62992fbe76314aa6cbe448310fe3b0b4f699ff76118be457af52105f9d559b46a26a3fc2279dbaa5c74cd14328d6ff411a55e1fb1e31e64b913d3f485054b5126bda352a9f20eff197a65cf0bece63300c15e83355f31f8b8c9f25f7cd6bafeb6de45d27d22d3a60b00f2ed392a16b97e4a414511d584283c49b8d47a5683f888923ac12837d349607743ad07e951f6e022d4805f690c97bf627082ef620080f3aaa01537d5afe7e3da85f62ae11555fe1feb0ef940586e7915e3c57fbb87663f1574cfef498d1a94f693a9760055e9f9274ffc05c995ee7c93b10644d75c251487c9c911c951ae5f93fbcf362c4a3819d3831bb9a55cd4a2d04982b089237a163bee593842fd62c01f16b73fb44a7d3fd2da16f7da5aa13204f5c7f5977d89b19e01585f7819ead7400312c27b1d39247e9b6410cff44ef98dac2b6443bd0c073b213d38c1f1334c99baba941cb18b99bbcc13f39b9f8ef81bbdb29efa39d6bc5c5b7fee8e874e68238e48b7eaca28e4eb108db056542eedf7f916d656d4468921481e7552a02a9754f61071ee07482a728b113cf22790a362524b179bf08a5f7e149f34a1910689a2825faf87f16e34dd49d23c4471acfdfa7518cf7753962434e93761d3e1b69d0e1ee22304b3fab6b4f490e9cc787d38c353f34c039104899e0c4e33ebabf150d6002358e1739e3dba91319a424b62e24e28a7fcdb74a69ad147cb07b7d30b7a34d73ffb30bdc47b4f003a53a91341c07c79e42ec583e938e4b3ed5999a668e6c211641bae6f5f4eb27c5622967320c8f4bed6c8766fb398a8e1344a0c53c33a5d28639c1b714931df1b8f15797ddf9697d10320fb96a12ff4f990437834381aa488e1ff0f3e1e9486b4fd1a5bc33dfc07665287b8aa535403b9fd70a2571545889bbca5d10aefa46646f0283601bf86bb77506b464838cd417db3a84e2b9c2cbb471b51e6fed9751dba495b0bce9ffd8c42188ba6b6783d93360465ec4f2d591842a9ab7230a37550fc92e9224e25625dafd5f9f536438fcb9ce7aa1dc269a72f43ce010472b4d111f805f44e7b4c14074326d4e7df2f24f799676c357c9bae639961b824bd608b8c983d548d32408ce625e017d0f46354c816a73c1b698fd4d96f1422634b69092e70ca40cc70381276552ead3126137757ba614996cc767a026eac81e9756b553987c8761869562c73043f4e27e205c3f9483575635dc2482d31fec7f8769c8117a8e3c2aa1c4a3cadfab50dc30897117e4a017c3383cc056cc3d2b58f982bdbf08c58e7d92700b966c244fabe13e3889d3ea438fabc3a4ceccfe5a67019ee470b1dfe8af0736909f74ca6522f67bee2ea58a69e34f543d2295b26528b4f312cc1f2467b1960fe8e07568359c510597184d5a3d9a6243c1f98a1e45e715b0576c1edd3c6e2a26f99cdf79d08f9ed6b14b1496cb5833122fb5ae2419667bb6862efc646630ea96f14391245e0b41070aa65b3dca896b7b9150cf41565d80553c0e7c4308d864bd726704843777e5271e50b2377df9fcdff0f61430a185db128b0d1f22a5664785ce4733ab7ec29d97989c54313d9e89db30d02cae6fcafa4c48dda0d28b0c099fe49551c6271edc4a2f87aac95091be6eef2be7eab6925ff79eb58889c0a77589dc67ee82fbdef8df6c127a3323842cf98e3196530d489303ead5dee66d503e0c0028eb6c612c22deb4d96a605b7031a40c89a5dcc0257d2ea0bc3ffd6d0bc57c3dfbd2a7d1d69871ff34d7e0b96455760723c56226a7c3e912da4326e7bfa4682007e51eb2933a4a05a1b52c283589bafa9f923acbdc0192b48e68931d47c5bbfd73b9bbd4054f4eed0bdbbcbf89d56ec8c8996181813a95bd42a597f7087f5bc7489a42bd9f45bb6e0dd91d17b5f70d15fd09969c187948292d1d7265203261793acb0ecb4db26472bacfcd8bae8f36086280ed63ef7d93cdcd09212b37a342c3c24fe98bc3d73c56cf8f707640fac0be6d1580d1f8f6b5fc2bcfe8e34672565c610fc7e4dac3ec379c933859ae5c9392dc7ee6dbec02f127f386833e19e85f6fc736121461420e3b5aa68b98d13f64720142ddfbc984d4e5d56ad664f557db54cba6a9879a609c8d7e781108c80462f162da89e4e69b5680ec40ebbcee394699517d1a06cf868cc1fba222bb112e17ebb5a1dfacda9b48b8c19b583ebdba3e0e78982b042fb6c9e798a94c2138d8a233f2bc3f049affe3563f135291311deb66beab07e1f8bc5d26e0d5c5b58fedec8374cd9b0eec9e64d6e7398a2850b3ce8aef6e6c8d0761fafaa02024d7bc21e5c08cf35347c8a673cf18639818e4e15564d6e662bac1a62f2b2277c515471d9c893e8004be856e4b1810d22397b000671bb095eee5e3fd96f4f7357c9fea16a71ef4c467e167918fec09145196c47ad33c40ff323c146cdf6c901e18c19127736db66ad96da61e459f5ffbec890dcbca139b7820166720b1ea12240f59463d5fa87309ee173491598276755f75014e1db547adc0c72da77a3e34c3221c4dd619d584f9a80c8b113b9b108bce8a2a09fb4ad36adf8f387e6149b7ebfe0aa66268eff92cf4a7f99c92b636622bf0a15642a5cd7997fc33a9b11757f13d70d3c85a378e8862f0c38d172e5a92ae416a0095b04453960f3e219430cb3d47c3b779f08c476eb7556bcb6919289e93164c6cc7d162fc965847a4b21ce4bf8d11e64b49740a03d6b5e0b354e890ed51f74bcf2e26d92bcc0c15cdbee9a0067d869bc9d0bdcea09c1f9f4bfb86a732dac6dc2598fd15f643dbe0f95d0d3c391440d9b753051ca1353704bbdc06e0cb7f8553e272c51fda750b45a5d6a4267c03fe0de8399a7a67949619200e24d3bce92c78679d01c34126c57b07f9eebd8cd2da519931149aab4fd549d32daad63623a0205f812de5cd0fa2155d8aaba08ec75ed12a250368aa4579850aaf489ae08cfc013fd44a3116267c38e82803b3401f08dba10e0636dc373e5f5c21ef7a3c299a9ad56be2bf55d566acc24e696219834655f4ccf34715e95b5c1cdfca9e402ce6f6f40618a079b5a4fcae9f56990d604ccc6d901cb7a77abda994abe8bf810be3698e31bb6afed7d9b5abf9e432ae3e57cba7930a864f77a08cac27c98c4dd8d6500a3f41c31820a1816654d9c94fcce307190418d51f7707dd202ab115e15f229c1218ef486f99370295a9b2b09c7246b209643fa4f3b2d2e363d1c5ad730e62b6544ff14cacb4b532832b34cd6ff5c0db6034684a5b01743c466220c1874d688029a7126e68d7f72738ca97b8b169dafbf2f83d0e93ace6bcd37a1635cb81d31b276e804cddd330a9856891fe302e6e98036f117db6a603087c092729a690e6afbf4dcd7cf78e98d2670f1d2615109bf166ab1911b7836342d1dff8cdeda27b08c05508d6ce9338554f1d2f2a13b36ae1f70144e64001fa22c054b25447aa13868a318035a17e259e744ede43ba56d59beba6e272cd3786b0f1553d84428d9ccab2a9d89164b5faeaf9438a7f5d0df15767f4cd234e2cd8ad416d2f39786bbf1f7a7218c558584f0f2898791e3c5bb52baa9c9bce4f72beca6d88a4eb2ec2f4c7e73c7db45da4d884dfccd0abfbfe9437b7ed52603b7392df183e5770de154d815103ed1fd958640ac171d1d9f91a349610d403bb37777e57436c07cdfcab5b64140b55ec92c783452627e4b707081b1d02736ae99b50ef0cb2a2b2d2a5c0c56e0586c85314f0779f93760f3a9cfbfd57f35850d0f3c8ca35f8cebfc75b353b955b9c9c4dc9d3f05023f3713b940dca0226ba49e8dbf03ea544671baed204a36b0b308ff983923249d28fd64e6d465146a2f07424be0718658568fbac3954fa1e98aaa33c99ebbe36148047267aeaa1447fb40ecc6ab67ff057aabf2fa72d1ba97c1fd90955e42b5c2b14d9a3b38f135a335b11bcf38e3f877fc8cad58fde21f418595e35ac7575a4f752d2005b00b01259340c631f80ce160dbf790fae46e73d93f5c88e4830d2b0b34298946b1e64a042bac11323254d70615bbe6676654decf22aa6aa4624128780f347602aeb28ee2ea0b5290b23380f231bba4ce18fb6e4b418794ce9a1c0e6397a27eb809596f5e45e5a0112d1d66ce93de7bf418d87a4a2d7c20562d8dfd487b8edece7a6a08805c032e818820cda22638ef075163a4a6fd3c12acaa3ac7af0d3ae5da5f25f4ba45d49ef547ac2df73455436d4a206c75e5e9a82a485dbc74646fc30b4dd9b28d9b1e908b4b3093b19da72a285f0f304dee33439de44cc317925ea5b83467721d5e4b10c35a5b8d7b8085c5132dcbaa9bdd7c65bb11de3c85bd0cc001418e8067cbc94bf1251b89c988bdf75db61591040803113190b74b8c0bb7dc4d5ae01e3a57036abe4bea2f88ef8e81d66f737d672b1c78335410a225b2700bb7de6d109","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
