<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6b4d94b1bf03f67d9672082d439932194e0d942d0a7d5cebfa6cbd8cd42ed99ced3cf41be86f261070fcf3dbddd94a7964ea8e2f9b86974fc8e2368303ff4e95a10cd3f720e10d0b56a2511f17317c00f6ebea1983928760f5755a73d10ce930b886cc1332b975493bfb626baba8b393781f301ba0f6499e5575dff0ec2e5591b956b3255089bb39261ecd57b6963fbd726f65cd633a13046791feb1f98fd66321f44c7550bbc02e8fa5a15dc73e893542fd31acf62878db324457ab8e91004fc41d315904b6bbcd8147684426ca742be380670b3014e6e1129faf14d75b353ec11f3032e1506beb3aab3284b8b3c27251ddbe08ee953dc28ba85ae3b9d71b65bde294a70b9f575745a4099755e652e9cc93a35bef3677fb6fe106f509c04cdcea7da49bc33f241c6b2c23612513a3df164148d9c7223970d44350acc88094b792181d7e094dbf69acbce814c7e5191f634ee64b70cc9bfc6d045fe9afccb93bd9eda40644fa2d0e42390408a9d03ffc00834570eeeca825a114152b96b00aa619559d5e227db4596eabd5eadd7291f5ded471363e22bae4538ae5e70311df172b3308916a71394dad2e13fa615b951290ab13234e69a9b7a04e85a99f62bb471e9b3682c2fc902fe0d249b6937a9aa0d8c6a2eadb6999ffca9921caf3f68378b180e3fb56448156b93d145db183db70a11096b129a6dfd8eef7e10cd64e89086402927c5854fe2500ef0ace2e175ecf0f14394c5238d018446e36bcf4ddcc01328f58d4a2ff89170cb5e90a21eb7de213f7eab66fc53ae1ceef6c389c74520d638ff446ac4523a39ff8a9a4247bdceb8195eda4785fdcee7537738b20d1a20aff31e6c4f5d8e0675e80d9afe5a094260ce5ac427ff9e5a17db6c0e9df94b949081490b19fbfb26115214d68b28fceffb00117b34636f8362049a74f0f515e179818eee6a9173e58eff20afee2b39c71a5e7c1a2e8570e84bae8b85e97c52fd1f22da2ab2863a9cdfcc940abcbcfadce25f03517b4d3f46d85c1aabc90cb04c9beada3ffa3c2ea83889ddf25cf930daac737c043fc8246788a99472d3bf2bcefc88d1bfcbe3c526f945d7952effef93fed416f030739ecb60ac17acd6ad7ef4bc3f8aaa0fbba86ebe6d9eab92f9932af2f97bba5333505764794e5ca289d0cfebd2a3f8394436fb392e22ae89a1c6fd272c9187bf2eca5691a5927eed4aff23fbce9b820357cda0a7d0054e7ba13dcd7e838662706dc401767d9b3662f84325201933a5d1ae1add757591c6215bb9ea311f422fc02382522c87855312db135c69d2a6d9dc5508913cc5cc3a6124eb6dfe9182d0feb03c48fbc929c80274828d7b6e2965e3e7f40b3652bc1056a0d6fecdc28f694a05cb75bdf1767ffb992711df20fca0f9979fd62fb8e1a0aee96601707c638d434799ecdc241e6a79365956582ee5f00b8df1309b1492f5aef94e1ed5bb8ab92e7fb1236339fff995ecb25f9710b3887da427d2ecf54e60e5c4e3b48bbb5970635f5e5d32e2db082f2ccf17a0be76a9ae8a5b2f20bf227b5bb1e1472568a40b7130f5bd73667bef963695115be08a1f76ad69acbade7a0b0f9c1ce0038252e0be4058af67d66f98e80dd2565cb8e117300976e27b90b1a7c9888fd57566c78d7b25bd2069c15539c76e931fbf38a368d49d118297c78d982ee9377fa7dca3780d7876075f4f744a5538be382d3a499d6502045d6ae992a8940f0c5fec74f17c9d1b3f1872aa6ac8aa16c42a7316af2e5980a47e35ec0f024897e3c7c3565265485fc2edec7960ee4a7858a9280b4c7a81b0c5477a77b27150261ee4d18def8d85599a30c87c1f85b908ad2f98ca2294e06105766d8de01e39c893e0678fa53ad50c5a662b1aa69a864b9cdb62d77616d8709644b9cb3fce99a23a18585028896728df743f0dfd38412da4ba99546065e4fa27bd13dbc44e9846624c48a10d6b0e81c48c80f910bcda058107a0bd3e5129f582318493c600fd3ac3e9ac11ff87bbcd87fddc9aa4c5b9db42a200916439b7d74cd86e45299ba112d8e1588a575b871271eae888ca518e541c87831276f2d2bf897c1bf6d6fb0761cc6fe4927769886cb0adecd3850b826de5de408998b4aaced65b5ba2cd1cf29a3724572a35a3eccfcd1ed6cbfba300d71f914b20b580f89c2bd551b7dd34532615f066dee09c257fc35c213e1027188f1a8a2185c8a182f06e8eeab5a55980f07ba18b8f51722b20417334e072ab74531658fdb535aa127f72450899acb0175cf480a4e703347dabf820346b11c6080850ad5044700f6877ef88f8c516a48a2747bad70f017fe3db6e8a9fb737e68efb4cd20658dc252b18e7d3d35eef619b7accbef66675958b7d05ec328c8e7a371ee13635668789da7dc9b4c93f1c2b8d5837bde188152bd5b9107e93b725ec9da67925b60d2cf60e631dd0eb4df791a9fe40a222968c939b1f576b5d9c84b9001df04ffdfbe60c36c3d7e2bd4fdb0e6d2f53650a8e3829ac1abf1e029e5d0df24ee258ea1a762079d43d61999fc2de1b51769ed25cad47883cc2565439dda01b1e9b1ef9a4766968ac3b97a185a7dada60abe602f90c56067b7ac41dce467c2f38130e8bb13a01f8e9423d7ba7f8ac30a41015ba37dd155e9236828670a678d20d5d6e18bb1841ca61f5a09d4618e367c85e4668b517edd5a0fad79a10f30dc4c417765e6aaf91e1f68662f44c36e079c0dcddaaaed2678de3f0e28c9f9eae59056d77d4fe9a203cf4665566a8ad080edb1244bf73f5ceed9a474439e8bc6b97797a0d00c3cb408207c07003657e6427a60b27992054ea7af448172852739826580a1ad3d89d0899240d7881939df52fe9bacbcfdb4c82268c56f56df5efb00265ca313cfb35cada423ba663ba679c3474d086cdd525f390e07989775906245ce1b9bf15a2c23515a61dbc34cdb56bda1dac7713277651325e10d251196c17a9e0f1ff38695aefb4687402988c91f33803c59e1993d8a5cedb67052c59ea6e93f1cf974af596dc860ce540a4bf72b58e2c7a815f6e6345df7c7f8c436653c97b0f325fb43b45a0fb3400d68780cc0299778938a3f49327dcc691c837e3f6caa02f9f22e7495d0080f08b16d37dd0a719d6cf43f4d88716b40871136401bd364c45c7ad6947505b6859d341051e8afc02c07d814cdae853f0e8ca7cd5d05f609f535caf0e9ffecbfdfe0a2b2b26afa05127ac641956810aece10f19a0e0f708536ddd6ba093123a1e8fccc610736cd3b562de2459e9f00bf19aebd0422b0d29739de494b57dbd6c1ce2bf6d8b946ddec804863c0960446dab2ed6b32e858e574a909e6467bc763f6047407f2ed60342c624eddc2f3fd5ed9efa30850669f1ba3f4c83220d35670da7f7cf5decec093e90a6a08f9b3ee0c1bf13af16e63bc8443707924ece044c850839d613bc7618ff2a75b847ff67ddc875cd5d6dc2eb7ade74d897618e5b360f86adf98115f2b400ebb799e04ae97b07f89456e3b0206e642f1c5e2b034f81e89fa46e130091d6a878fbf67dda1978fdd496242efe5344199b480e93f8df3441dd354bb9aa9265982807bac7d733b33bcc648e08455ee70fd8696fcc0dab7ac028f60969f08309f70e8dc3d34711602d225ab13c63b687a45c04164d1e4765dad2746efdc335e7bae5a349f308bdf0db418174fcc658878f4e7ec6819bc072b46e8afb3d94b743c8d7a7adbd1e0dfc079a4cb689bdc503a5b7988af9d7febed7ac3bb71174b2b2487c421a9b5f976244363889b1c3bd697ad1e784cbda939d97e45cba8308ef1585d527b5c4e0aa8ab41bd7d316863d9538a948aecf4d4baa0f2b1e4eb38125f1cbe584a1132a96c091567ad4bea762a88c7ece8be3e784d566751842111897107063ff8ea4105f2d4e327d66f5f0fa7c3efed5313d798c204418a1b84b1c31b4cd9301e395b89178a44fcc0347016b99322fb380a1394e467103ba48c96f07ceb4a0e7273b6541f496805e28bf9a9b5c4749e89805309f8a74d762f57d1eb2fc388e4715f6a4b0d9e78a3b80621bdd3f9e3e3bd26db0369f588304381dbdb9a647372775bb528a535bad14a4ad8879bdcb5bfe47911a4022493bb15ea9bc77e83577162696b8b28c7c4931413f547375c31f3acb64f4da93c22ac3410da744120f371c0c7142ab26acfc5940b1d38644e05efacf21d5a33aabfe14706252762c4ed8cb694456fa65b75992ea2bdc3f7d838150e2033aad3b1f16a44830de09f269a920ed75a18e2a3275ea75f4a4cc625f6e044946ebfba86bc721135ddce82e292ef52eb743db99c5e68f6b33f5dad6d6c28b8c1515be3db3d59ff8eb788e272bb6852e22e4ccfef02a7dbd12443f7b44cbd00e6a01aae5ee8691a2ec4527da6496dee9b6dcad6b45c7522535791ce60c8b224c01a003851c106084aeba562b47c8f020ecd541cb9d3000e5fdaa54cf0e538bb29cf2fe3e864b98b582f6468d4d9a14fe65e7c3d368725c30d0f9b8f41b1153cba090e256a43118fae21ecb485f22568461dbc59d6863d21a40cafb56864bfc7333a538752e8998be9e1ad4df1f0ced5509469c33db72f7128b558e1e5a2791d9c9b5b6fdbb5f9180f8f3970bf1569cb499bdab225521ed44805e82950dfba6b31df20e524b550848b91378cd5b0a54aa0d311ab7e80806c41047473c296793c5758f02ae42dfc0be245740f3e2829e9fd109c7b451dd4a138298594630665915f225f6b566b2dc50917df83ed20b40fc221f06f68a7907054cafbf37c82793902a238ace251d92534666a3ea6c7745197ed6a10ba5a4437d7989f5f4a4e0dba347c9e2d8e9450ed4be8756c7a8e5b1871c2acca868f76efb6dea99d65cba076ce5573e7cd55d97913fd432f28c623ddad21ce1515366710594fa790031b0c88207a59a5767ffa264887d49e9b59866570ac1f777fd8d235f7326612a78785ee8591e5ea5ba25e21512c99baa0dac1cffbc9e5a4ca8d8fd02bbe634acf2bb51402781809e9af3cbf1cb26852af7a4eb74ebe0c638a049aec6f46b41d537f9ecfad905c1622dc5385aebe4f0589df11f0dfdf03ace7a88fd7c118d0a44b2ed4520cd31fe8d4167a0da9b0c06ba8a5de2182166b9084c82e6fa3004519c7ab9547c7a6fce80fcd8e4646622c6a68fb3d2ea6085e4f58f928a1a1ea9c33b5a4ad2d4f2219ea5593103213dfe296a3cb82ab3e3256505a824e4f62ef96864d7eb7234125b6d973cf0c9f20f158a48d87ae5d0fb0b7eab91ab36107fec46f34c026f7df6c9d843dc2d3f5dde2427503eff1e96939ecc5f03e49c8e23a5f01671df5a4d90a47219f3d71e871b4269c51dae1863c9b66859b283ce581e5df6870c3ffe0114359c35f517cdca91ea873d09cf30647b95d89ee4b381d1accacfa86f833c207519def4b81cbee977a29d9f6e13de1b391dc629ec57e0e70824266c4f891811fe39d58db78e26331cf3d10bbd48b96c9aa9fda290d3629252ac3fd5f4de020fd929f011ef8f4ca4451da61c7eb39193ae8dd4c9f467d2b2b9d03f284dfa1bda3834354c5e15e4cda6584356155cd2f909216b083fe98f813bc7d3381cac8f2fadcb61a6adca2d8946d770cc98724206238502ecc071b13eab92e5d1c9484a9f18bd5f7e64660b7da764879bc99a98637b3f132dfdf46ced7ec3de4b70e9db7b8d484c162aca8705d2f36750df4e43af661a600ac6ad12007709dfb996ebf8242656206edc021ef71957314d74af5f9f16fafdb3fb6378d746b6b5dcc078b1d8a822df7855ab5006a3ad4f90fa888edc9133617a44adf47b5d0689c7f2cca6c2abd79472150f05a5aadc1fdd7ea8247b6716e4b0fb9b6a540b4c6c7835e4bf6845c9facbc21792090cf88b490f1f0e20dab9345868604ee31addfaf9df8ab5b6e10c3196059acd0b0894036105ecc03e793284ae1ad7363ec8ad4a7c689c277dff023432acaebd1b589e147928121f100ceda8fd31cd3bb29d7fa3288d0323cc3ae12912de4e54fd471c0c98cf1c4b774e49a0fafd3ef356fd10468328b76a186aa8989d99b8a44d9fa481e264745000d5f3ed28abc18f343bac353092210f9d7a7bbac20eca7c65822e0612cf0fdd7d8fd159c42d1fe91c22cf5cd08449bdeed6aebaf7cdb2c6ca7d35b5a34ce949952e6acdad937b5bfae2507df6d887e387737f159ef4210d936a8403894f8407191d48ca03c457c93936fb4af5aaa43f7e34d6a8335585a073191394c86900737402fb16d6075c7134fce6479b657246f9056aef4e1e5fbdcd36e3f0732e34f1b85475a5dbd55c11d909671df10a488526d0f65bb404f27d5d66cc7efa3ad33c3e28ea98fd07d1a81b76ef9de2d6e0c9ece6bcb1f5cb124adfd4477db1893003db7c020dca527bba73e8e6a635a163556eb64cf18db3b7943918c5d74d45b8fe35fb6cdb7169fb1e7e7d85c7f33697508448389a140231180709487979c1b01a5278e5ad86becd5319b5f429749fb15769c5db3f72feec80d3f3741971312ae0a3e1d95a2cebf1ac6dcce8b16f4bd3a1fa1086b2717fb966ac08f63a3238d3aad9927b4fb00ce71cf61bc37d63869f0fe978e151b7e89a453697d3c30c7bf6530cb7269bf36f3bfa6528921482d1411891dcdc024ff1c4aa853313dea6f22af45b6180d45ca1d485c372ffe959520b7981169814d90ffc144e337a88e2ab1fdbf64a82b8b0c560f303b4a5e71aa39a9ebfa33c314b53ec7dd6e04776ac5a8cb080266f7ca277e6c0826ea9498f9bdad5d78599807918a790b6110d5ab6f07fc231ca201bec376024a2a76bdeca84839b5beadcb0b881464d2d1adbc670bca75035123866639370f194a7f515d34bc83e2fc055198c07ffc0c0bbbee4226df777fbebe7181f2eb7a0f25639bb5195ad8757b23706821c4ebdc4608c1c7feb70da02b3f9bd446c25c00ab9996d8a78602bc91ed1ac06da22315d7475d812a99a04b01dad74f6fe2053079427329fba29043a1cfec1276688b966e0564e07cd441c76bd7fc782eef431a125ef7acf58a153016efad96dba91093c0db0524170a7f3b81f6f5d6243fe25ac4dcec3893c4c3544fbe87f7084cf2d2b4a3f36c187f78d9594059b2371e8245a45f096f72b477ff42e696651a4a0cdb03baeddcd46ce1a1ca40acbbf9ff6c9231a7621a26f380cf0d6f6b42bf52d5f81a311869eb261677bafcb474df8face90408fbd0bac2b94b292f5c709c69374dc8ea91fb74e7e552eb97bce0dec10e0c80ba65d1107cf476c9f4b827e6b51d6e5451d12128fd9593d009da9f22e80b818bcea6d9853c12656b70e23c057f3a503c431cbeacf1cd0bcd13d550f340bd440a1b0986089d05979f760d4667df1122cac7668bbe430630756a7876941316547891acc62e99507248b6c5d00f5793c47e7e1b54e2cf89212ef79895e36d584a6497948c9a3ff79fa731809ea0b862982d4be103e8e519270f5a2b985c48d54f881a1c368072f81bc505435bde572e02e062333084de2351ebafe8c1f243138e1b6782e9803320d6cfeb9155a084cc0e46c91f1357c97548d428d0526aae5db3f44657cda3380f78dd6c520e25d3b0bdbcf78a741145a3fa4b33b17083e86bcaec5adb4935b63aceb6d638db1ba2d59f2b17a62c9fcdccc7502d1e6b25cd4a56a61c0ecd23fc4579ac13b57133d64d3ec4fdd4da38335e59cc837525bcba8aab3ddcf8c81cbde755755526f82c28799db078edefc65601249926469c9bfa3a473880eef3b2798b664db05c14cc77987e78d4187859289b9d4e221aae11f7fc60c5853e7cfd6f1c19b608d48747be0593ce91a387b4c8b46b0efa3bd4bbb91d738cfa44ce1fb0c3620bd7a73b159f293efb1ffc386bdb45cf2db2ce52defeded516eb9ba62059d5a3af90a4c030df077a855a9c9cccef2de6642519d2aac13657476d75f3f8e4118214a4ccf3c953d524a92701a401d5633c802ce0dcaeebe0afa3236a51c8fc5c2bf9a53242ce1560354c520fc8c2b38ba6958a3c17cd4029966122079c134d7d2ab5a69d7f434ebaf25d96ddf3beb81e9ea044083cc1499ef74e7493d1c0c272de6bd67f12535acb23ec9d6391588991562cff42486f374651199aa42fef2a0d8f5f80a8e5a2cae273ce4509b32cb7a8d0d186c0ecb271634a0a1e06d2d6f6757003ffb339aabd75f8a9cb41fa313f9bd97a64c6f42fd2c0d3935c96568810d6010b4c6abfdf665e58a6ffab7e9eb152097654464f0bd74b64545bb05409887cf2eca210a7608fb8b04b58e646d91f3e96fc31a6143dcc21f47a95aef11fae7d4363e1e22bbbd31e3c0243bebf081359517af2372d9d9902da0c9d16c80c9f547882ad4fa9086f209947bee7e3aeb8317bd998e6626bd3a71be9a2e042a1e1b1425ecdcd5088a33cbfc1371abfdd272ae1d4ffe70e503c45128b67f92557beb2ef873a155a0f5823052e1e9b51867f0c4c5b759b64948f3e1c07b543acb87f95babfadfeed4f9d3b31661936f1f3ae78744d4a2741bc822b92b4ae636bd38de84222b555a73900357c10ff983a453c3a1b8d920f95b2a8fce6a4bb0a626ee70708bdfb6c7ba05b0663c70e5f2de22cb8b570ea2846a576961ae95cee5145ca43d3c6952049ee4d0ab071e44fc34994776d8a2d924bca57178f66e382ff148894e9ed84b43d25ed435a4266546c46ca9af2c3f4fda5cb399a85ccf077d5fdab54e358e0ee8cb55d29c1ad44acb050d7099500b88d30496b427c7a29428010abfc3e8c83b25af4f842e0a38260dc632b63d030d103ac94f32e9fe9a5747097a5558a8946d15ff27115aa5be026bd4417ba4eb485233cf5e1740287608bd4c6de141c7c2d27bb2ec73ef90e5e498c05e8291109ee20d41cf6af3e9e9c2810d72bf14d8ff29a1b3bdc97d822d0cd891b8f724402438b415b5cf68a38acb72b0922cf710dcdd2a907edef896ce950ab1f31a0e14020848fedbbfa0cf13f0659b3686fc94c970e31a31fdaa673c8ba2adcd8f432262ff5ff144452f657c8fe93233788a9ca4b83edcf7ed9eed1af90a6e6597b4f0b936f8ae90db0bea6e9ca65d47acd75b387709572641d8a732d34dcc36f9b0383b4a07515a01cd844d534ca98c8360061c718cb164eb2f518b32e9bf142ba7b0e84a7cabcdbd5fc97fe4eb7b66f17727e47f5f9764fc93a5d88a92966a12c7ab30ec2a92d1c8cfabf621f679d6d9f02a12d10d382151bb613ce976b6ec2f8b6579f6c4815a8e306e24cfc6dd0b738be956fb51472c282dab92aa85ec1817cf457d8b9fa832c3f054a36280319ec30bf1f8f81629571f532f4ee32403bc11f23c84241dfde1538c06e766f684facb502e3ae644a835558bdb4487c35ed04471f15fefae98b78231d1657a8d9a5269c8562b7e541389eb738931ece0a05d20f1bcf7e2331d0b2df74de2aafd29e93af7f035151fb429758268c7250be616bd6002e85cd880b177740c45a73a19e227163d091b7516b92f427742fb9df7ec163cf4620c26e0e5f8f477b4a5ccadfedb7dd66322ea23721074ce08f3c15f78d9fc3a39bab27125aeef33248120f29ecbf010ae9ac10ee7aa17dfba17bd8278e8cafdc49045c96773366528cca9d28c261e5fd0e58a0d3b0b7bafa0166b8445c15b2d976dda6589f52e0c4ccfc0d29d38d0f50ea30fcd232aca219428f13acf8c9721390742a70beda9a9b41d0b030db1456e03080672d77c6e2299600ca2cf9e9d92831d1fdbb0188ed59fda8ea99a086d88075e8a7dc0a29c930a1fb26af32f29dc488d6bb92fe4958f963033e9524673901d362a655a448b15bdb3f53a32683bf4d22b07626c6d4769e55a8d4ade8ce3e64a82f5026d55952bb583b91152825e9dec4f226ae7a78d29d8adefe2dbe7d6dc5306afc28dfb635ed57220755295279c97226c8083222c8c1837c8e26549e6d50c1d0ec3e193402af98583e6f0d00d0142b676be8dee2bb5d306d3ca9abf6fb75fe9e77f75808e95908d423a059539e81bcb27ae81aa8ed5205dd2be977f80e2352f20f479769c65970b53d6006a22d5d258451c392bc875cc1781292010569970d99961cd245a4f770c960432d399099682b14db0fa2f52e23118e26501a17b93240b32af15e1c16223a6c1a3a96cac71455cf43c94f75eec1f0e8b3c07464aca8bd7692a0c7439c8991d171a2d9c152983a8b70a177c3ae4efd1cf5963e9d204aac1c6fb54507192a3bdbc77c918325e592aecfc06a664be3837db0aa2e8a709c94b313cb08b2225598a40e223e666516fb7dff77df3cd5c729ff9e47687a1fd963103cbd5fad17d71d5e08c2a7518d6c17df6e91ca86879244ac8b6bda8fde54611e9656359b03d04f20547e4d9f50f4955bf987f3245c8c694a4c935821ae94d02aa2c447a6f85e2a28671b06bb6f73ea4bba49b222a184da6914820c6a302d5fab59eed1046cc0a780426880a4b120b40abfa974343f5b43f04e8afdf142ba5c10d079dc43a431064f25cd6b464b348efa6bb1f04c913d354eec15612f2c5257a443f00c09a75dc79aace616f68298dab63901676f8bd4f6d464c27e787bfc3f9164d13c31e236b1c2e3bb796f37de649b400b1a1c018aaad576456db6ab3f0cb86bf25ade578465f8eab190940cffecff5c8900f39f95d1b513e60a3631a6893594be8841ca5809f0823f7ce0e65c5102aeb53bd2f9553d9ef08f6ef2887d46da83113a9dd7f5cf59aa05a2ad93972a6b83b5541f80363c5593aced23247227aeb32159bff91cbccfc051180c54bcbc7457f149ef7507c149d515cb552d74588a86f50b06be2ab2f579304dd6933530f5696d7a749e38fb9c8955bb8a885a24355d9bd9154dd241507c4077b81061332f18ef94de234451f58e03544352e0716172aceb2e74c56ac07f5ec78c85864f966e9fc5bfc0f02057b4aa9a971fa444e20b324fe4e6bb817015cc9e9867af39e88bfcbeb447bdafdf7e9d48c77defa0aa30aabda458f168b35e3b2344e0c39d7033f658b4711f6c5f4064f370f45f0b5c607c8792b4db04fb9cb793b233281c7547367c5a408a874aea2467f3c4af33fba5faf726cffca2565e52d865c61f4d1570161546bc594b596ac1bec401994dcb0f1b9847f74c5743b6b52c4c5cf56ceb86e3182caffaa2b9384cdafa0d4aa559ef21a2a7ae8ca0eb43a50ae0208741223bedf33e0cbf491cb7170679fdcf277852d668dc7760e87ca96b2501c0b142ee222638dd2be52916af661dbc65d3c9c647458d69dcea7533376270abe4ef4fd76cbf12f47e06bb8300699881309d6b50ce4f23054058e88d467ea4988a97c8dbc88414cf4df0bf7ed9c69255c5caf12cad1fbc72833b0159333d305d69a57ff1060856dbe29a2471decb15c7cd7c6fe2c7309f41539eaf7930dc27e8089ab3800e76bbd7ddc2c222a6ce16ce1a953efde998e277188010fbe2f3abcc076b41eee88facda9739f66a2301dd7c5ac973f7140c026a829a167295e66280894573381368d3f822d6272d57c2adb4bf3e9fbc81454c731e871d8ab98ef7a8670a72b2ce1d8f5fdb839f7a085f05daa0b66b56d32c3f9f87e3152649059a34356fea649bfd1eaa1439195b1655e671cd536ba5dbbea905efe4ba963ec4e92288c1a9c386acd617e0f01d89a04309c30bfb7c1026cb909699d0838aa861860885e8dad854737bdc634653ac4a70b4becdb29a37a4d6ae14c72ec5d12f9367678c6bb21a711731dc2a0753a913155875fbbf099d8508d58199ffbc8cf73f155ddec02408daebc7a6a0e4ada5ceca678956942a69de979ae6b7b11aff77027c866ab1cc7c05214f898f9aa71c868b8d913e3707adca23a0c47345fc826298f9b43b91104af040db2dcc98e92a6251eb54c8c20a83297fcafaaddda5bc855a011cdbb2ad41b09a0e79983733b9e654d1b80d2840ec8e75c6cdb3c424440a7550836fbc2b6c07f5c518b3b5787665d7e31e7d4b972ffffdc7c51452cc3ae1d54b89a71343f10a7fa99652ee4b608dc67a68bfbf625ea701415b685dc65c7fb5722bd7c4e1d7b3d6844b5f161a0664d405b7e47971deae48017abbc50e29c392b35eef5a86a36d162606bcdc3bdcf39c3060a7e84601b33e20927ac855d79211dfe569ca771e7b0028594bc08bd516683a4f4d32552906ae2846e5f4d0d473e75555f3b720dedaa6610322fb872ca3b9c600d2d8faff7185deb641a172afabcc16191312ec7c20d3394613f80839147190dba8f5930cb434d32a3c2d847eb9793a963fccdd27f4c42264e3598760575ff810c0c94d109ad4620ed1ba1cbbdb881f211de813053b5ab16abac4b3ea8f0a007a75f72ce2c9b067fee630d6d71e18499dc299a26dac558754655d9afbf654abd2ba36ef78f2548f04d3794ac56e67c41fc08d0912051f76c5e25ce9d119e9635586f9cc7167ad795dcc0c4fcc64c709a0f04a948655b6955220951c8186ff61e3bf1b287282e9f7b72e85906954072d31777ec85141d79235d972cdd08f93683cd56303dd771aea98722c55252236e61582a26b457c786f484e0e42e98d1b3213f9a8c6b97ddc52d60d13a9497e3bd235dee28233f19139b144405119debe17bdfc59d80b9eeeaa45ffa02e330a3c5e63445c1550d4add1840742621fb618895bcf927ccba4f63da65cc84c59b29bb6cc9045c69016a3da2357e734b6f393c4c3d66faf15b7befb3c8d0373efd35d7aaebe1410d011f78a098df2c55d351ad4b53acc5eaddaa3eadc1da15b70ada5464a0446f54c1e350a693120073cb76f60142891b96acccaf27647510d5d466d2c645d3a0a3449e095bd88c01c1d83e2da91d80bf9939e9eb7974d15e952a843cc4b63d98ce68b6ee67c24c802fad98db1f1ae17f739418560f2bc185b78231bbcbbc8dc6c01e99e8e3e734363dbf546da0676e18dd1f20c0bc479e4353e8a85f1c60ddf9521cda478772cfc41c8d4a11f70b79ddfb88178b65e18ce976f36e28755b9a3be5db2066327ebc4d1c9e8b5cdfad79e77f4c11f70470a79057051aa2e4b2e95f714e8e4d1ecf4193a52107d55040a59c2a0dbf6106a5cd8f845eac6eeb9f9246236c692944c413b36a01ccfd243193d92eee8121e1dbc270588356fec6bae431ab647ab060302f566a947f88102f4870ff5c214cd02316747d7a11a8ec5db287b1a64cccd2d7049d7549dca6e3581b47f23c8f902d55f1d887e0997f82c6b3316930dabf04a19f5c7ed65ecce25069d3df572dab5f82094f75a8c04211142f1bd4c8b666158568610cacf6775cb342e0b9032ab283e95f0ff39dfd6febbc55826b4e619fde9b17828c4020bcf3fc4cf8613136670699095d2ea84d476939c99bafeb5515c07cfc92e87476670efc416e7fb6ffcb23b6273768ef77eedb72bd48a598b2c1bd853628a38306209b26eafff658ac452b2f1c519de04958427b47b7bfdc38c49e3e45d091c964e81f84a8751165a6f5ec4afed49dfc9cd64d52d41b76231d90a5d55539ca6b5fa23b501c22e03337d2c0fecc1b51b4db845d9018b1fde5874bafa29b86a3fe1206b785d677efefff710578289f586eb0cd809fa1b6c99e57f73fb0597a38e794ec6a6e25bcd9ced20e40f3c039517bf3fca5b586b30e7148f560abe2ced5e9e4d990ee7714c3a568640cd8d1c9f0116c7131dc9e20d483ebb52ec8b17723efe0cb232a9708c375be67272210e11ac0ba88adc0866a893044fc95c95fa7d0ec1a3b1fa7f3243d1749e5438c72cbccb4ff41f31b17e307c2fed4089f857aac17a5cfeb7044d496efd2f88c6d97a234f0b35fe8b3b1ff6aada5e93a421c46363ad46f323879f20c00b058c03eae0399876472e886fe2061bd71715f90c7a4bc3cdc0b2b410475e9e10435c4cb7742494a4344c432ac001aff8745d511612acd576c5e28145710679faf32fbdf7dbe77533460e92f694974c40b8130de8bfb2f6fa40f10b9ef7cb2a13c80b59e5aae0df2577a018634af86178bef53465530f9678df79d06c07a4e18efb3d49826e0a8ce7765e06a37b6bd185046eb5031448a8c70d5293e8074d29a7333eff4b4fb6cb72a141603ae8aa41667ee788fdd515cc5c7fea1611c12cb5eb09699d5ddfa140d69d7744c006346939815c9bfb81735433a7d7478457c05d6b22c99e3e0b879e9b7a467fcc27d011afaa03bc63f29870d2eecdf2c1a824242b56eddfdd062ecca2282e3b0e0c3aa36ef6169915dc77ea72a0cde4b3208cec9cc49f4fee09dfd85954c2e156dab5b6d751bdfdc3a7c98be4c17fc363d1de76fbc4240402bf21e6ad2b04fe241165150c7a52d0fd8cf8a272e6d3588bfd5e7cc120a933aba2abc5f7a984f5a8aa84b143fae5f728365b86ee3e9881a0118d8c54e7ecfc8a380143a0737d481421e3dce19163580aaa8eaf4689919983321b8953c6e8925e7c34decbfff03da033ecdd7b154aa756c30461c5b2b2f756853bfdaf3132463fcce5493d57c32e953a1dca5f91b34d47572b6c089dab85bb1cfad3ea49e8d9547e2ee04b1217e2adf90d2f3daf736a7a3dfc85d2df00aed6d20fc528027ee5f9e00c54ac3539e48aecc03a9ef6cafbe54cbddd29dbe74e1a4ba7a2f417ce8a9f90e2bce15c4f4163542e7ad85283d491ebf7a7eb07ec6bdcad37b1eec684cc50e058872b8594f293d9847227995cd4e9b9dd686d89bb86891da503f04a04e05d19cd0783548cbb9bf8368496a7f4b97814dd5bf393c6a4d97cbfeca9ab8a240eee9763c29098ba3c8aeacbd479c974b7eca7955f0a0c82194fa3aceb1855b4c1dff77272c953250d1d823b7be161cdf08668654f9c02ae5dc33200f93ed0995cc5bd2ad64bb838497df3ded0f118835aa94942c8af79cef048bdbe02eecdaeb668c3bfa7f5633c990b455a75d14c507768b5e2739910bcf855041bfe876d81e64edf4baa75ed87841683e3c083af851cf616da35686a367910483b24e4521b8ab26c4ccaf2af5d4a17a4771d8e12a1f0ebcf0f68deef8c984b3677e79a161b2aef3eba83b66dd5b96a3d24fb0b8d05d491c6df1b412435553a5fdf54af9b90e1a3bf1e2004a2edc616c93f8803d3ec36a008cfdca9764eec0fac2c7dd570eae1a5039f17e523a48180a9300a64855bf57355d4714d0dd31b3052be9f2f8b931b56af575002c63c4c92cfbebd54bc00cebe5bd83a7976eafda0aad6f964a072f481598d816e0b9fd7f2bef16aecd64394b6c765e14eb38010e3364fe3d4d5dd564333e1bdcaf4349d520e003c33e43d5cc8e710d3920abe2eef18ade674f5b135feffb33f03bd683970eb56b2063d583e2ad7d8973c99fa5d22aa780b615fa33325e78ba82a9f8d4125b9dad9e5a415ca858f1a2917ad12faa6cca731fc53d0d0702ca6b84ba7d1dc7ef47eb7d78de8cbd54cd7aa461146750e143bdbfc204368a9a136f1a5ebd46103d11a3f2d4124199eecd278cd4395681281cc4883b0cf9e5a7edec458eb38378f5a364b4650247ce711a9b9a2bc560430793b21f3e70f2075890477b7c80e07b11ea2f433c4bb2d39078539381d6f8047d3bb5b70e37d059186192f797f766a4052bc8a4628e205a2058bb8e20378211757dec570d3445b8b1ef7a96c1029617fd1f421c6e51cbc2f0b4977ab917cce1e3aa7b52f72b1229c3a96b80b1ab9deea07bf0784a17c8421ff727a6034e293a92995cb3743584ba4bd7e4768b6fe6312a5c5e9ea2eaf5ca7ca41e1812853cd810869c5084a0723c2bd51e4a705eb911dfc4f9e967e841d5f9136fb6027538090cbd166ab5c341d8a40558fb97899baa9f6d03bf7fa64dcc4048d11315d5251826ce3eb60ea8cabe30951c1b05db7c39197ad91b7206f939e2cd64dbc9b80f8898fd92d8352a27c6e6724b462fb7542576c0f7733dd8b8ed0cfa5798b1da33aa353e76b898a381af3a705a1056c234de31bf2182d169744a985156cc3977cce06307122932fc8bde3c52e333333699e760140607d24e9674a9c2727a2d2ec72624e425b442c797af1e5624b445180472f81ad7cbe52642abcc8ed5f43991a2da999653b5716f89e2bc3c719eb97126a7e26811bde65a22602b16b10c6f2edd7b9b55c13fbf05e2890144c3d23875b2c1209ba2fe66a4e63bc8c8a9fe86d0779be72eece105a3f11d548d331162c7e8a10b3485be40c80c75b93de466cb3bb2e6ad14bb4606204a699066b493a38f17f795c0db8c816f3aea13f362381e428f30667d5138ce933f15edba17fc5370565893ba5029414f7ac0fd4b3f8c2ef22cdf776cb25985590bb08c16e618ceecc814fd96af19c9e8c536824eb087a70f239a12585c86916c1f1b740af81c92c0bed43d451d26f67b4bec11dd88ba10d5826b21c5e9a9653b72a5dfb76409a8d2d9e0ac3253405be26ea50a586b1568a7a1c8c5b577b32f1491e48d51d758c6f9b8adfb52537222f09bfce78c5f6763faf06e6876f735bd834796698c39e52c7f0831c33808ff4115f271fd1cc2269a88bccf83bf32c8e536dc73ac4c1113cbd2a310af89186a0488b82ac1d3f2551d1e743c088b625890a35888a347c6a847a20a6bc1ca403f2679889501f3024e52281bffebc1698ed148db051a625aa368ea53a6bed9611be15fce7f6b82941957fe1cea009de4e387d7de7f5687f3685b6c7225d9e53b0f4630f8b5480b6329fdf7918cd2103e8b834377c3c9f9375c53728ecf02b1464803c089a95ac56b8d1b5c6cf09800b006ff655acd2703065746dddc640ae373c71461c0da62c0bb6ef465b4e611aca3824cab0b6c1ca3aff770cbbb186a0524cd48e2606bb11eca0313870e0eef1df783e3d06f3222ea8a448e5327494b51f262d0aaef85ce2e7de11e9794c9c7f89406f0001208ca63faf98ffdbb8dfdba2741295dea6e87896497df2caf0a9344bcb506c6e9d7cf071a5f9e04f69572f26bc6821d493c7382b49219b04a43ec5cfd997cc93eda758f84ab11422b9719d93e3de217a3dd4d8a73d5c5d7666aca98b8d0753a7b5781ae03e9b27284714201d542de8eb60485c97d405a7dcd42bb9a3aa7d3dffe89698cc86fbf53e05b33d866b1105ccf8fc5f77deca3d825acd8d0db7053ec2359b4e34d9f861d161fb569a0465999aa79243b5294f558aacc14dddc287522d96994f42d48997a4932cead247c9cd4b9055cf7b10ebefe41f29143941f13d870e2791778b0874c3f62fc5e1bdae0de915c1e884ec8b881e904f78548d2203fe5db69f70e55ffaac8d9c058bad8b97b13ecba7a19a214cd310122c3f199d6e558348c63f4ad81bc4e691b047cbd73d2d79859eefb63c1fdeb64d3dcc43772a96424f8aaf1934b87697ec5994a3d16a2451864031b877231f07e47d0ce0d3f23238871bfeabf0297b2b66a86de06649adc3b15c924bf93589f1d35529aeee77f129136c387cee9c669f4648547e6353c7bc2ec9276bb03c92467fee8d97ead17e51fe627cd0b73f384244e1f4924e53ca05fa00b6cc731c4d012ba3a3d5ac51eaacb0be6f3576bbc4791f2243e9b6aae35e09b20ce6a52f27d10a0d821e84c70ef8809a2e45d4000ff78a014fac9fbffa9088f246cbe0385c254dcf2730c90c0550ac36365bc1807e312c435a3e06b4f729b06b2ef1aed9164b825eb13589502fc897012db912d42fca43c17593e4fcefd3b5821089cc65db5fc52d73abdc764707fa9c41c5d4ef77778e186856fc3eb2534540e6b7f68d9a41079756454e63a0918283de7bca4cab93a2a62729afdc43bca391e7e637c39ae47067bc510f90efc8413c0742bdfb62d32e056f364b142f4f90da10082c9a38a6de85387c7410c59fbc75d4484cc28f2b6956f306cc6315c63dc92571a7b136a6336501a42967340f291583cccf1a4e879bde3c5ee8e396f0a3287969de0fb9c2c8be841fbfeb1135539681d2cf8cdc0badb84f8aae99e558f5d03881c4cbbe2cfc29b1a9c90e883e96555009347aa1c4a8d51f6575207e6847ce4aad85ceb4597","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
