<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da0c492e95ad991936866b70f02dd426faa35781bcd44db9610d12de258fa3391447f910a67e24c8463180c5bb3bd1909096603830caab8c3c71b79278431360529550e8f2a953eaa5c44285e4df34ac8d79fd14c4252cf5141bd6e8c15d8ba36cc374c822ab943885fd53f8d051c20f9cf71e1fa248e40622d7a50cb61cbd2af903dae2e4859961353c0ec2d46d67c003d24899d4c456010de9bfa4a10f536f429d0e18b5595f54243fad77b917e42e0a4e6350b78cd1373b3ffb567e6ddf53a3a3de7e8e849c98aa266c5b24eaac5fcce84e7254e96ed5cf8cf7cf1187100d309e36a6cab83f62911def70ee6ccc24a7b3d45e03c720756792f906de2ceacc8e52b60acfdbabf54831a51a6582f9a485839edcc7e88cf6eab5ece1b3e2e9f22ce271800cde28e5f39c5235a081aceec05f91dcf94f43d42f6569049ca3409ee1dec3abca0310d2321d75db6a830454da45cadee13f805084d3b9a773b8cf7eb376463cac4aa886abaa2da53a5737e592adfd9ec17858c594ee934972b47ab3162e8b6babfd6d01397073b63ffdabd615a631c2b3b6b3bcc8acba213a53b7b9391168c4cb58be717baca307e889db97626f540abcd35c51c27e78d21c00a24cf930c2cf658f7da467c60cde62bc2e30501b2705669d46411658540ba8e894010a239ea866b1940878f13068772306c1d8ae1a1dcda58f61f278f22792115160bf95991029116120cebdf1a554e45ad61ed3eb953b34d851c642ba1ac6be96bbf573da28ab5b527aba59f6cafb543d3d9bf2ddbc6522d78fed9808a673596914ff7e0609efea8ebb2a7af5ea0429cc87cf46edb7cf9056dc94f4884c15eb6a10c606c1d08124e3426b53b60792b92b12cb6772d16d14c3d773ba0d883ddfd18fa2dcedd2de6edd8cfa6481d8d09c88741fd11979c1a88b55334c36a355bbd57b0c914570f4309a4fc4081c733557f11491b9c23196b42944172c09feb02ab3dc52624b070c609fbe8eb62008a4a61698085b8e5b7ad72b9130751589c77ab0204617681ec0478d268c63c556c5721ab9f0c8aeea3f8072162ff2e041a0e0b2d3690966cd8fb2397dba5b762c1ad2407846e9cd07a8c7879fc7ac95c98f675843d591b85c1f589b8dd2bd812566377cc60752160e5924ce718bfdb4283edd6686c6a79ead3c4bc0db60236a5f74c5e82722da31147c6ba18d78a0f0d2838d4bab6d12f827edd1985720c7bb2d643dad484a2182a572d871851c8f799aec98f4315b86e14caaad3321b729b558da09f2f558ff7ca97b6bbaa2c71721f8494b7351385466e6b68cab1c441c500727add9980a4d2a854c388823860a7ca62370d52f5234e70e50b91e62d0829b9662c9f5fa7d0198daf1349a8b57ce687937fdf93e9f56fc32fd80a5d292bea1364845f9f4601c902bc3065f2c20f1b10fe6bbfb378bdbb5d9bf70d6d63cf29196f9c2e6693bec4c2325c1ac2e1c9606b4164e48d6fb644ed87b6a7384860ebf85bd3bb8c39112d325f5b2c9b681015ab4f7542479f7cede337e5444d7b8fcffb96c8407925d840cf553500465f265c2fe2d52fc58f0e98f97b51735110ed92c8aba2a6968a092a5eb2a360f7a0d03fc6c94bee51aa3fc35cfd2b39f46a5d0a0f675e10e8c2ba0aa4e68375860ecbee7c8a79473eed96e62b7493af9b0f35c4d9979f98f9bf632a76cbe183f51a0e59df76e69585a9d1423a36072be5888d5bc90719803f563e642ed72897d3e9ad2a7d43d5843aed47cd446d950727cb1b28a0071b3fc957ba2ea92293bff11ed234d0e56a01f4d51d78caba98d2418f52822708725085f682c244d77eb3a591656de1ff8860ce024d315aa30f3bd11436c48e2d3e1e9ea1001f0d0bd51379ead444e9587816861449140b60d84198ac580274d7f02048d2df0f4e380308cd37e226a10e3ed46489dbc4a5e668f0e1e84023ca88136de6fcfe8ae17e3def561b21db6e3f0febd11e3f779c2743246fdee4b67291f6fbb296231152262f775a4fd6d4599fd7099c9b757f7d6c38b1544e77eca633862d94f236a99d00313f38ea8bea7b57157ed8500c120cef14148e7a44b21411e66882e67e7ee76a4813232474a5106c4b7471aae75f473656f50bdfad94e0c65c281997e70903d19cab4e555ca71c7237e37ad51e488eb78b8e926a52f5128e4a8e80c936f4fb4b4e8d542a8dc7b5312a208069c955645fdf64a509044c4d7cafb329658647d7ccfb4bfe2c67293d4f980cf8447ceab08f506631e15ca199baa7b03e52c5325c0ec7b01a06a954a5fdddbfdc296886fcd5583e06dd44d8b25860112431c87c7670973695c22431ddda6fbcd0575bf59bfc21a8f14c6c3633d88a6972f6b7fc49820ec360abb22f5d4521384a2dca800a33dec1d798fdc6f1280dd4513629adfcaa7907b5fd208f31124dfc287629821d1112d95e0c87ebb6ecdea717f0dcbee0679144a1865e06f671a29b60d7281d929d1e4f298c9af2bd93e01bcedf2e5ed51ef6587e4a73c20c8135e381c1b73e82a266309aa217d9e64399eaa2599fcede8f05c19157083edf58cbd73c8d02a106170b57ec1bc4719bf75c38e796987824325a967937bccb440897429eeb55f19526401a67b4d1fdf84e4e99d9017861a4a57583a925497efed9dab079499f7d9acf0cc658edda330c46e623eab624df63cba905bdb01d91503eb90b01286dcdb36176dbb316ba251072ff1b64fcf265a5f9be0548e64825934c769a3ba57864047fa2b7fd8b957dd42ce979affdd1309f119a3e23e61f86f83e84ae7426a2eef82783259dc7f55cb89c6795f91790b5ab1cdcb0c545b925d60fea0fbc3988a4affd950bdd8dba29f05a77b5de57687012e2777d59f427288ab22d548054c49ebc0e5a15b6943768cb23f6d3cf29649277deac1ddec6275ae833de5a58a962b3850d45f847edb25a91c6f611ca5f08f34991c01cee3aaa306d9e0133ae7ed2ed1477c587ff76aaffc83a180e257899038403b410740d10f9b7b1b47bd7cf791ec78f297990d1be0eebaa0ea78234dad6a2871d821796bc7690a8c7e6a7c53f946b9c6f13eec0d3bc578ebf524a65ec261aea2986e497f0cbc1cf3517659f490bbb91b6872d72dcec952d61d598f0302839b1d036dc8f8f208306247e8f1f5cf3576d05d0c4f7709565f63e64e249fabd7ef927349b3f2c409e1aa2b496846e6381867d6a1a7eb59b0fb698ab7ca9a3ce49dec381a57482858ab29ec13bec107a11bc106a564ed22e54278923e03a1f52976e2d6bca68fe2244af7f1ae81403f9cb12e266989c514a222952aed6bc9fe9bc09a60754884ce08cd05a39a09002d5fd25952ec5abe5bdb2b4daa556b2f8f5948f38324750ea5a02b3d2f54f4c2885f0c1228455a1e77eac5e18acec07eedf0d79570bf4daf59d749e9c6c445970e293992714852af387c46881b9f86a1304d94545e1eeab00484e83ff7a99815da4b931f8dc7b0dc77a8910a74c1e6a0093817f6167a1f7467de4d97108197144424271c55f1272fb09da00d559ac04cbf71689aa3317600907a76b6a54d1ec317a09caa1f05a193b4d4c44a2ae82ae3192848c919006f881c48c03a3de9e26df6f6488d8db6c5c25cace8eb741f6badbeacb087390318f7853566be7cda68a96a69ce8a9eb68a331462c7a83dbac200e0bb3e3197dc5fa8fb8881466505cec80c2c88bf61346eadcb10a14b1498bfba3e6c436cdc0bb416ac95ba7e96acf8b933e42566dc422c060d8a66121fe9c3c53b6a58ef9a509d6f5179de86858729b1499dc4a9bddf1e1a420e8f03d611863ad60f912f790306ffe40018993a6c9c5708d464fe7fa0c10fb1b70c74983ae72187b5c5d0eb9e2ac550549ed7fee455be245e143f49724ef5ad95fb82a6cb7d37810018e217141c91f022f5f9d08768915d51515f007d2e73a67625abdfc33a2d86ab146c48a85bcc731531d31309fa9c5a0baad2a480bbc7d15259be0c1ef04f40d726af2eb5a80f9e2f889e52ff1b042f20567fc30c5665cd374bca9d40c842c39e0bd52de2b1ad73f1159c0240bbfa63060a3a6fcd8936a57280162c7767066467b36f8bb6cf2cd5aeda74e5a03be4aa4067bf5394b78a353eb369c7249f72c0dac4bdb10c789696888a0686ffa11f2904c66c158d0ab9779d771b2848cb643890b5815883b83627e507c44e88a97ef2ed8c6e61e1f198aa55760e5305c41e89488bbe12d6206a08a00006c7af3dd12799ee27d031a64d605a1007817bebbfc4095219c73ab03a2063fdca28f59ac2d63341f7d816c9e3dbb446e67664e9121c377f18dbaaea6ea7f4b20064b2abe77b562af0dca1c2005c382d084cfe492128dfd8381f44b7db8c2b5dedaae217efecb9b0f229323afda03cdbf8613a1ed10c4f9a48b77f2c7660d89c8c977652e4ef4c08939d40d1b09bf860e227163548ca73bd62ad13d5c904f40ef5485330923e47d0ed10f35854ed2211d737ee584f32f623d3b78c6d883b28e52b55cc0832a1aebd2fbb63859e2c579b131b4d85a0532c69652f4c06d94977fe5d3fb50da91e3b4dfb7e1d203e5f874cb85fe656691ab90aafffec6a69eb49343e66b2580414cfd7d0a816486eb261b319bd5a60bffd2661fb14a469a66a12327f43aeefdddea5bab39e53986f836e158c85286d02a059170377df363efbd9ffae4f81e6690efae88c9aca3b4ebc4ec73da457b3e6fcb3f69d5a75da64b8ba6bc91f380fbe85f0117e9591cc3eaa4f1146a431f4c4aa26cb7d650f5eb6c688adc0c6c0642541eef97757ef0af8e86302cafc4fadfaeadd5dae76e5fdd5914b7341fcbe777bb17c64105aeb151cda7dd1cb918c3c7d81785cb894c106ebc670a0b4070397224421ab8ab13b6516f7bcef1b07b261721904542da73211bdee1e6961d92a6bcb0317e1dbf162fc8028f0f674ddf8500ff7a8202ddacc14f3ab6dc4613eed2fa95f13f4582cbcd958958ba1157281fabfc98a378cfe56b3566392090e61361cd2517de175753533fa4c3f54cef42dae3b9376c76e1fbf30a68cbc115696bb5d41a2500b99bb01182d35e27c49b7951bf9b6348b5db16c5e99da9f183eb5bbcece3cff83053ec9d3249ef1f2b1415f59924e3f26bcfd455a5c8730b582951d66563079206dab3dba013f1815d2287c4acf7fe6ce1a49e8c0f8eb8a5444f0636f2c47b7d208128e1525396965a04361d7369f6e207ad6aa2719d6ba3b68f7442475e66390f0575bf04bbf23cd91462ad8fac4aca69b50669f5b43a76592de4d628e2010257ac194af8e2927ff2d5362a2d402a8be3fbcefc880d1e5c437aa39921c1fe9b0e08c906a11b505018adaa034a0af02715d4ac9bf973c3eb8daca72ed372195543eae133bce60fc804e75e816bb448feffb18b590680009a1a1a0eb54856faf8decb8ffa3d74898fc91ef77b10d394cab6412fbc638293376e368ffc578135137b723d383e7301d6c62ed9db2e538dd16f784622900fa4e14dec17fc4f01d8593ddf0fc207fa56a826d1ac15e62a64da551f3f380ea4d5c21e87bd48e94b673be86c13818b35299ed8c7ebb6ab2228d70225a754fec3a55f78374486493fb3d17f9aa6f9588e97d7b23f1494ed459546d9a2d9971870dea4eb714ee20e69f088c09361cb27e70076beb4e4735b7a9537aadf50293ec2dadfd3555664745043fe7e54768b875515db8e5d77249ed72883da59b76e8192d50c60911c2081bf7d55694a54a108abbbe87287561ec430c0167c04f48226442bbe740b1a59b0d8f1ce3935cb1e9946c1bbb8f4d1265fed52b829c41cc23c16cac93d7e12f5a2f68ec920df08f5327b9990c44800ec4d6280e0fb31ab472ee3543aad0ae8aecfd59ced33e387c29aee5173199fc41bcec1cee8304390bf4f3d80b6d4d5e5d1994435ae5993421d69afa9147c28682015dd3fddda324ef88340b1cdb651acf6beab031756c8772c418c64981683c7a3c6350552d43df5eebd5257c745adc7c7bc5552e1b587947db5e43797887e5de93b91d7f5cc601673bce64de94f4e246f7c5417ee6a70572a41235f3e6ac199513df2ac7120386b2a6b492b365bf28c1acfa64fbdf82096639542b83b21f7c082ac4e67054b943bb55dae77b4d73a2fc7dee255d041fc3ab8120cc44f070197fb8670a1e686bf1fcd43198548350b1c527adc02e08f9817eecac17ae400fe5d9caf30452802730018b2ff25bc291dc5278fed998709bd8258819f1663df2a33d3938b907793e67feca7c4f6d191d3ffef2a90869cfe04093c1896ff3fa09e7399e06726b5cb26a289315d015ac8a438d60535fbde778870a24982a3efdfa1e2ac089b27241ef2d42a43529791a69a686e953fec4592698cbc2e9b2e4a230d1c56486443b359da9405bf50b3f9502da6344e604e295570d0db6308b04afdd24fd801ea9fa440a6ea6a1d126813d4ddfb66671ec2e7216c109684e6ffc5f05de5ff53483e3f130139c6aedcf4cde2b3144651ceeca47269820bd7e4b7f82b8e24e4cd5ea927558e9e3d12d353a54b36b59337e260738fb569315f9713c045301102bb7d0c2e0a6c1064c9829421e7ffad4b2f0225d5158f6487341cf9cfb7a33f4c2df998cc1499b123fb98f21920d457faf7a993c7691570a44cf46de985ce2c9309b3fbc666bd413415f7ff5b5dfb82ab8f9e85fd1e62eab5ae8f1514f735203af2929a66d7683396a24e94cc14648ec819a9cab34012b8aac9c08fa6a6ef18e741a40cd0cf273c2115f41edfd7605968b9733d7817c42cdf728a178fe7cfc5fbff521316731eed3d8c4b4a9c8a552b99c3ccfab8713129736a66184335f5f00386dd7812ddd84dd75aab587d434fc50cc8dfda6509fc9ea212fd154c285e35800523e7f8cc335a3c5c9cce712799941d9a7e0c07a612881601803d5ac33c36bacd7d73e89ba5d0bd74d7db7528cbe61e362eca8ca5b3b450897227fe20b017ee38b75a026a35604f21d3f33cdfd8ecc7e9caf820023b4e23af9e150506297eafbfd45e4eaa45bce54d015d5c15c0923ba7953869c03860fe30bb6712bec766e9b1693f49f62db84d175fe05cb47e09519845c2eb261fef399b24aa870a3a3e2b8e596250da7528be4488be9a927276d19428f0997f6ce08b72e2e1160f1b0da25bbb0a0026c5e2c65e495efcfb76f904764f6e73d2d350531125b6df8fb54fca40895cc80d35b5bfe3bff98157b17bc2b6a01298c5fd8b127821007f86ffc32fd54e547ac96a371cb0c704b419176c102711a6b9731034f5dec37323b162bb84a4b24b6dd0202f7ada7f2943275804ea16f0f99a3385430df3380695630b58fd2fc036fb01afad261c7d1da47ca563041611b8b2f3c47010faade9c0e75e6519b0f6f9ee55501f0d8013daeefdaec26aaffb4951e01403992f8043ba519ae3d35006797bb5dd167fe354b39014790e1e63b2dc0c614be837fe29121c6e22ab4dd20dcc4c5998181be53eebf07bf1a66752a10abe28d92acf36b77f5665196c11166dad3518f3973af5b75af055409bacdccd29a070cb2a3cabad6de5722067d7495dcb18af18b17b62d49f9fe8910d1a5f9e3be0816cc107e46155fb521e8cfd9b318de5d1ffee092c5fe779fc0cba27b714e877305fa8bcdef848e8cad90e450119127d9db5d1ad7a77f659567ab7291ce9745fa4c888bbc17a2b7e38054ef7b8d78e361388a92a2d3712a617c6c1583b69ef2c4f46987200c4456b7e8aab278a000d69e1ba06b0c46fa600e74bdedd1e42ef1b7fa2b7ee740c0fe7b357ab2cb0f7bce5564800d6cfb728149909e94d3531dc5da4d2b3515aa56a7e0de3b728e14e9ada0ac8e19caba0bcbb06d8e437a109f7789906a5ca49410384a4fab14d879a521dfffad5ca3e0f4ca43bc2c5512d121295ea6b24540f3cf0147f0a07018ffa5795131d7b587e59e064c19b06f7f14577219f59e9960711639d9f4558ee380d23975908d3e4f451df297ba8cabbc3e8fe7ff6ae13ad2b9a81ccb462505a662693fa239eee2bedfda5e2c224072dd7fc66276f428164a5ed0df2d06019a4b108f3fdd4d9d228f14aff2865d4e114937673c1b094b255c7ee488e21bdd314990e738ef04c13c3e0d39bb9608996ae895761387a3ed443a14efd25aec449305d03b0aeaf39194873befba0efe5cb1dd679f225ccd48a7b229882346d0dc7869a82b8c4abd536476cff457518c851f8336d7fb50d5f0defbf26bb4396ae2e0750422a1e1f182f7d81861fbba3f59275172dfd4f2d11e94a0cebb4386b577384245021abe4133d31e7aebde8be537e8104732622beaed4795b4afcb0e4f64bc6f137307ea13e915cd9bb7f62d5ac5206588c8d814a42a18f2b707064ffb2642846a6968784a9d205649fe4aed94c57875951e89f61985565836d1fceac7b657eeab35a0cc28e60cb7440987e1b2c6cae4c57ba98c9694f0846e2dd154d35c94325ba6d87b74a0d026bb2adcf833ed1328d3ca6f056c198456810e8802ce6f792287458052d0a414480775a7aca6ef68481a6237494b0707e9520c5d2399a0df54532e6d583b6b4f9e01d329b92dfb20ed07a719c5d228e85dd62f8d4cbbc8ab1fd75cabfe9b0ca1c7acc3c7923343543c67e4b1571fc24a74b91bcabe4963b37fc5e6d0dcf8500aaa76c07a913d8ff4dd2120cd7325513694985ab68718411d24e4c0d2db4a324bacbfa3e2bfe1d3637ade815a13312d785da64e72e82f58790d701324f1ef28ddb265a836284fec83a4022baa280c675c811a7ca8cf4e45f65b01227b5ba764520ddf5f24e1737e7c26e54c943bf2215360cd73302263c8c46dcfca8d9aea01b39cf59854b1027222a3975f26e9e9841060b321407948d6fa895dd82b2dd0919a8fea04a2c80a322c09a5046b569b19cfd8f20fa3535edb5e39616fea4c5319d8453b3b581513af4eb99c517bbcf9e467cd02b6c376376bba12ca322549a2a6921a7c2fd40810a5dfd7cf77e945696fdd74bbd679652975a322eddbdfcb987ff258496fe65f1302b192d9ff066699aca52fc87b391dd7997e49c8c0a245cd7b653567dc1c6159efeeb1f7a4f471201867287e04deb6967292162e46649955b42c44e913870caac141b675f3ca9c7e1e0a15f8b71951379dcc068c837052b21dcbdad51e26f2dd6e551fa71861d62ae4a9eb6d259e2646315df39270b425274998fedbf5d44642162b379c0f4aad40a5b2adafe94c6173e5a6e33a561c2cf75ca2fd0abcb5f2bb867e90ef9fb7b14fda633ee5e9504b74082103f32caa753b0d95ec02e5834474636411eb41a308beac5226b8fa05572f62260abdf38538d35e7b5c1e7c11487a457e14b8a6b7cb3234b407817dd202a47f51f01d2ebaa61bd865505a2cc78e5a82ed9cccc368e293c4534f141fbb18ab5d8a1bd0f179e7be0788b4364a92cc312669ef1561aa0dc042a895566d07dc670eaf81ed063cd9b99a5d5cb57d12423c3be817bda26af702aafae14ae7e6de9a70381e95e0633b836a4bb1372e2b7b47279f7e17b8457a196e6606ddf8f6fa1764b72a881428c8fed3e1b92c44ab18e8985b84f87324878e62608afbf02ec791cb6cb36c1054269af2f43318f80568663ce33eb7c33215cf2acad64dd7db4594f935e0a2c6633babdfed07a372ad2c2ee6fbdc679d2225c29a8ab49c3eeef4508dc11d21c0e855a83a8803056451f07e30c3e6e327e1bbc041f9d06078105718ca19235d49e3e2b3a17b103d8c7c718d6ce62c2c0704fa17d92ea83bfa301645fc0bc0620a3931ef9f5a3009cd157cf05d91f1a4cca42ecb52a988a0b72a19fac3f1431d23e00ca10ddf909a52369b978e41fca293ad6731a9b69f7dfb1cf1fc4187c0c419eedde92f63743f0a85627c11fc0f358e40d831bde46682b62cfb68c5a2cfc9f954a2490e231741621378949747c6e3011b5221b3a0ed26bbd0d034a7b7ffdb774ac6c7a271edd9057d73838ceb5619c501b8ef715178544ad5b5672608d91b04185a81472bea7215c264917107b280d257b0bef278279fce87786da4375885eef130d8f7b1472fdb0f89f61c596f66c2a1958f660933977363722797ee8cc4a5a4ccdd197c79300c6b8b248ceb150c8eab253daf4014078cbe4886dd007959678d41ee90075fcf7d8d2cefd68f6f2e7e5d82b4ceccd91cee4365b9ff686295d53bd16582a41598f596a3725fa9695a88b15e1e8bd2de868433833e23b358e7d8a9c8241a0cb12cc62ff0b3feb313a502dba73af0f3ad9e971af71f86bcf9ef378d184b01b19fa1654a60f968fbad6d76190b528350d3c2b2c1277ea5c78a2f768aed1ea63d849c7b2cfe00d54a1a0ac58fdfddd93bb3613a04623d04eff350ebda842bd1d59e0ebd1e44e75e73b0e987250d26d72de33cf7e3c2d3de8c7a16d9209259d013eb943f02f57966f3af0d065c265508d74ec53034903447c9a8b24a69ed62c35f941c923cd4e3f8ac2fc61bfbfcb9e9b2b9a20c0e9ebbfd0c7d8f63323f7f67d5e66bf89a808d00b6eca08ebb3ff8fbbd391e93ea4977419e9a5250cb5a8ee67e83e7082964d9a575c9bc50053ee5ed619fd9e2f515a41be08b509d7dd9505f450d7b3a65a9d546a6d3d8faebe51be19bae49b92a967bacb56cbc93f7a2e82decf587c7a807600dbce93d997207bbb15c6d2e77ebc2d6fb758b474a1d455f65cc8a8d7afa01a8738dd8f9c53381950fffe8b59c64f35c9cc46ef3cd1673eaeb1077e2221dae91e0bf65523a2fe37d8d8125d4b4b8b5711dafff45fdedbb6443ae4f5c3bd626c8eb3dfdda0c2df4428961f8021a611b1845c26c9559c173c2ab0eeefa2daeef1c77787fcb5a29d69d18b4d8fbdea2f9133252a1a5a810f6e7e49311e38d308ead6c2272f7bef765f17a4b0edacb921379905f3be13f9f5acaff723b2ceb9c0231386340bbd534ab838e235b0129a4a5956761053e57471d46f01ffd2cc93bb1032bfdf5628027d7fef6a00803be84d4b6c18569a36d046d70cb9ab6cce62587531fdfb6b51b47f0bda98f0fe92b1357ae757d40ec0a0550f76e28c872cf4ecfa7df6c17a82a708109840f3efdfb3b5f68e34aaff6911d94146179dc44c0196c7a35908783650cbe689c47907181a7382ef088df5a7265151f172e5b86fabcce2d7b82091b55316448d3d7b6454d6616396f787d0d3228399b17731d6f4f30fa9299566ebe122d8ed93ffc151eabcf6c96a4fa7e10d2273d48ee84edfe83022956353a97c820b552d9ca2b39adcb386e63ac04113b5bfee11bce2f40ab0d16c0a54abb6407193a7250481be3b6c3de1e580729dd838fb72b0bfd20372bb3dec8200f4c7a863df1f2b657e57505813113115852b178e950aa00dc5fe3ecfaa1fe3394ad0b7742eb344d3a4faeb586c8e81883403310e66612292b713f53bd6e07938c7655c8c875e304adcbc8b448952f6a86d7a9c2b3c280530940400479e5c5113aa1ed31b35b1bbddf809c263c37e814c1b8c762eb9d2959196dad06992cb9ddefd8fecd9f269ddd3107f8f4e883c7a68102e316ace16641b291d19b9b834d44cdcbbbeb0441fced1b4d7c530ae1ce0240e6687230e5559c696f62c02804fd2935c33427fe23a47c6e6ccaa5544d2a71ac5b8855f284f9eff4a4ba1553e6f74b574ac7314f1cc4af0263da5cdf405f4772d019d6d39f07b80ecdd01003777ddd5b89d4ec9dba57dbf2058964ab1eeccbe2eae9f57b0e664b8d7e28393fd2bddf932da0a3f6efa8908d9949d93ef6b9d561067d0795548ee2d0a7364e07be1396a42de096205cf3ce4bec7ce54a753ca5d46fcd9f2799532cd97cecfc930722fe8906571a0cee8518a67fd20ffef261b21904260e4c8d6134f51881b0a1b8022ba35f433f8d2c97706bf1ec7d806686df36dceaaeb98b643ebf9e6dea8cd4e6e4c6da020353e56b9ef4d12a8666a3642e082f8eaacadbf0e1e208789eb7b201e5e2c36b0965d268a4190b1770d0a2006619ce5ccb04f8daf8d6ecc10556c00969842c5368ed7eadc7f664843746a99dff33110726e665ac411ec7cd992ee359db094f15c46099f0cf18e3574f0ae3081f0efaafaea83e794d2b12d31933ac4426a88ef8ecc9452f7e1af6e78b6750441c69247419af616f4f5bed1385d7dfcbcbc1f2380d348c68b8e6eab67ca41e2ce305cdf08a4c5efd3decd15d7334301e7d4f34630026ac75aef89e784be5c084ecaa347d2ed791c4dd37173e0b128604f7f5ccea4ae3c4878ede479fa7df6d7c6dae6bd9f13714a9978e355e65060c9342a6a4ee7c41cf99371212d10d3e521f3d5738b6b9fce14ad216fa7fed223d649722c93b913932cbfa8f35269c4fc513c04924263d85414b1115ee49013fef91bea1eb55fae780e91260778815be45a2cfd8926444ae9bf17a1daeed76caf2165dfd82ef18c76daffdccc2d787edc42ece1d85177afaf194932a5d1bd4ad86ce4c034f38f36669f861244f7e5acd7118a4b84dc54910739afdfec4bc9879dfc791b7ae38a5699e44fccbcc489ff0700f08f6786ff2996f07d18531803beb9d0311bd8c5465daa29605b29b2f0ca9c0e7ca7e60887ae421d62db78a3edb3350a518a263fd1dd9e2c4a455d8fe68c018d466ea5ef133b8a78f1d2f32170f78048db588bcedebab51e6f4e9a4c28300ade84d80157064d6dcac4e924672e32fd39582f9a838ce8103071a7b1c0725779158de7f723164ba91c69b05aacd2d4183c232063e80f2ad8a6763250b12ca48876263dcd7d3ebbdaee1d12a1392698ec801ada451f3bbd1dd61e1329e6998f1cc2502a320ed453ba057e38f76ba8d21cd038f66272dc5d799e3996adc3f5d540edb7f47211b4bb0c3c7ab0d12e2f9c672b96e8dcc08b2e2a6971d0cfea8d91c29d7ff48d92965c9beccbd9e50f1ff3cf6f02bed7958e219357dc3a24aba8f09b05c0ee8fa9e2605eff8d7409c027bc33e22e0536f99345a0e4fabaf6350a07248e8ad4f8eb323a16ca862668a1d8acd324492ccff33d8cf15f4a163aabc17ad5173a5cc7f9576df5b5ec08eb66f066e83522a4520e6bf24bff3ce70833ba21472f2075f39eed8a51cb177577eca54738b427035425e1696dea8bec99d9818acfb7fdab7cda1f558e54a802bb86975c8fc88c506b65831c52a376ea89dbd6a66e7215cc791194887503e72522add0b2409a1c02ac455fbc72c48f6ce1df2ccaf0204f9cea648fbe3efe50feff8f804d882d45f92603a51686386604dd945ba29c199f76bc9acb9999b2f080ad2985e346713d190b30356508e192e1547508cd4a584c77b305ecdfb84149f6857a2915560d16264ba0e6f88427aa18d9515ec77a61633aef66c9ff53330716594565469c245d3bb58d81d62e09931610682c6a08ca240b57d464187bb05a122a494114ee5dab03be0af44e3377051a94020474090022aadb3a8280508237ee657f73b84481d8ff3a5f429c4d5aec12dcb42336864643634f130222eb8a5b50aba0f3eb493d23ba6e728ee9fe59af0d4c2b3e8bfc960abae187dcca1367a1744c799606e0f0215f35edbe295878ee57d871dc46132c896ead1a1dd128a5fc2ae4f47f752e195982df6b2065bc42fc46e3b2b66eddd5a01cee4b7d7f4aedba8e2769e6fe66f75fb6bcc966d81057524199463117c1b30856b41fd7a0aedee522f48ab39062a965210af8c1f627e9e8858864490a7adf2441748f3a68748af7027b79efdd9a4f62d31285ca6dded64009980062aaad61a976166d80be5cc1bf1f542edb8dd1210a3114e078960183cf7f119563e71f5023444d7dbf5d7a3dd054d885e3ce91f69fe3dd876d53a31a2d61aa443ad4664fbba9830661b0dc897e2228a4ec6e125bb4fb95237396bf1473893768b9d0eea1d61539f86c800d4183da60a4a0fc7145be8a5c53b46df73e336d0e48166b348f1d65c855846cab3bc9e31f6fe6baf2cd87472a998d2698933865b810813e8b4fdadb9316d20ff1a0e77f17faa351d6793b1d10dc9be77b120250a6dc9c645db68fa7721409c3a4faa6075d4b4a789298ad0e279b15bb537cb8303bae1c42c796a43e1c4e1f4fac1163c7e166fb40fca0fc426f6bae32080a0e338b57a55a131eb5c3923e4779039842ab63f366b80ab34f149ba652404b8fcf841b3b2fae7623964f9a1cc11f10ccd89306d40e11a9383f61b4b0e5fddaf5e382e82c3e97fd4c106f3e83f49b4b631927ace3506a0ec1975acb206f1d972d5118b354601ed8e1da28e13de8b53bd57ed2f88a1c5a7ddc31622fde7ebd16b4e98c0ce8e6a6c7a9a736dbf92011fe5743ea1292cc726ad0f102e4b730dc9f47c86492cb54289608ab1c7d27629a7760d0ca542c2e8862fa74dd0c39e94d2fa03c44d9f114060e48843eaa44224798cdb368a4d8eb4df84f91025a62febbfdd66c89a9aff4f5c29bc02da07855feec06b295c9e4696942680c675b59f13334c2ec7a439bab144d6dc41e35a6327ceac0292b00f8b6a6d11e0147cd0fe5ba37e7e5bed5d76f6ddb14694a8d12da2bae9e6555d0e65287cdc8e0ac0189f870177ec692dccfc9c0049d7de39c49fd73578c1381bb2d2ad8c62b415626fc78fb0a46b8ead87ccddc2fbde3c79161d9ef275eb3dc33a023991c61a38662d37484ca5a54e036b7f46a534358247ea1a1626fbdf972d207d0a289d31c28a00d7eea15e556e5248bc76c5e4b9da02262debf30ffb2c028026150fc42d5375f212d7a903bedb910ace87ef52cc537a3181c432f5161ebec6637e8bcc87c33285820ee53b42bd3de49e7284e65872bce24dc70a4022bb3507876ff3c82dc52842a6986a4ed8306c444099f784eaa81c0e9bb00bac74ffc0aa30707d3e35c77c13beb41783da8be3b7596af4966cb76c059dfa4b6c8ecf7eadc68771e663fc96535b87ccaff5ba6818f4bfb3540898ddb7a36bacc877836c26a65f38d9ca4775c18170d221ac6b6c0a2b6cad16f0f633ef2a8bb7683010d1b482ccc3e6d06bda25fca45e3c076ec1f5669e183ec53b2ef35f8e5491cc73f98a1170c545bce6c33e24a6e2e433798c9c59de7b72049f0d06315813e722a827af94f39d5d31a091eb87205532594d56e5ae0910a576cddd8bafba743e6262f325aa08b0094c7dc1ea750816d7b809712b67d1c9e1ae14d8141ff64da92bc0d33f34010ef7fcfe2409922b72b663f934b17e9ccb5fd154236a9c8ea6890de798aa333a94b59efc3eb8043974c8d1a6e5cd0bf3c382c8a0d051b806e73a1454d92b827ff570d4d3a9acff9e9d456a8e101c60ed5aa8eaafa4e16cbc03e0f022e5f29177fc2ebd72bc9894b6966204c73720e3b0e90110769fe86d711eb8eee13ba94c92ff88354ce7bf11c31b611bca41a08707f58d8bd3352ae6e79c9f7a9a59c4242f121f03b2689cc8f3e1dfb1da54394cf4a94c75a9b17cb407875a1c4f5b24776d28d6a297bfd97807681de022ee9f1c666516f3951c9849c0447146bed5285a1811555006b41a3e3305b8da98738871226e2375bc04c9692e5bfb0022330a2cad68c49d9152339bf7b4f52684107cdd4b2de923ad18e64f1d456767a6cfef015114e0720871e24a653c4a97bf4856dde86575df746edc5f73715598e55e99da4d3b905463c835f278958c3511206134e4fb3f36eecd07397c1a4d68d444e3198b41118d511748d14db8c34a0bf51d9e4bb28380863a3a6505886da20dd8db29ec4977bf435d7de9c93d8dc0af9ae0b6e9d8555b3960930c5c257e9db97299ed11d63328a175de1f4dba29869a48ce4cb8be641d0fa3c657cab8c3997ffd54db7755d40f2c9aee7b98ac41cfc48a1b5e512516a16c0d8a51a72408f93185888c5280aa465269bf661528c4f9acaf4660dd433babfb867e8eca2e4665eaa61d2da2ce080a9ac4a7d593e3b3cfb06f3c31c93829bfbff8ade562abf8ddc3463a95a1e4085c7a343ee6bd33b75e72db85f326369f4a84285b5e705c5979d4456ca581f06bc67b53ce79e770bd78494ead5676820c98ae2009a0978ef14a98a16d49ebfccb896c18508e259736cada393f261209b8fd27c0970f13d7723312e8d0b42b10437aad00a61861ba5040a22a64e306850f86aa2021478efe59a46b8b2834a1dc932e24f5ef0f5d28115bb0ed747a3dc3c705bb2a18fa74382a73fb13aca68f0e4a2c825ad07ed34a13127db47931b87c047b12fbd945cfc89add8e22bc3822ebad27ce5af6058ae3e6c36b621a86cf2adede286b58e518582576a3a651cb4c8c4884e989d335305e27701ddda9b6470a6e85244ba160b52d70518d9e74eb9bb753cd9fd3e24fc6b75f0be7c631a0e4e81dce5f860400aed370b8f4e989cea30a43e6bb4c349318001e03aa593f96123b03dd7aa73405e61ad1b3f1c33486733b20bcf1cb8cc6e576a75f11a64f7924fd76f7304899b6053c12edd4f93ada457b63c1ad0177a4ba0aa384ec6c0c73eab6f97ae0422265e99c230c3116e20195b7c7311988aa74eccf65c7777f0f6d35d2ecbed7bb840402aa93bbc539f67abe9e94a5d53c7926f71d6f086adf52f070861b74fe0e7fd37a2c838460389b5bfe1e918b69172930b865045ee4bc39a16b2875d2498bacdf3576a4dca8ed92433f298b7c4c83d4810516c3137abd5d6a62c446b7eb3d7fe22ef4346fd08126b90349e94393fef43ad701492dbf8d77fca8f8bf12b14d5e9c00bfb4be85c5f96765ad2d618ebac88f032331f5dfeb81e04f98e8243c237a951af8b1ba973c75a296ed04df1fd4ac55b5fd2db4b1a66c568fd1efc5e83a815ea213a8e37e5a86364a4389f70c536a9be04d3a1a4f072dd22bcab6d6e0f3d30142c9fc8dac0a77890e172a1e2e55d470b79aa4fe78bc9f710ffd6da96ce6a5530f63a3e9762ff37d07172b8a2b99599db64f38286b5a9e691f998081020a6be940b35fec263bf44f5a09dd14075489bf847d82e388c4fcc4733f44a239b75f3965ef7f5c8c7e92d107074e94c5e1826a8c98a2ff7b42c52f6f33f1fa06cb6b95fc9bea176b92f2286535d904678c331d3ad617dd16f946dda7cc300a75dae48c756b1c875d5366d7b0672ed782401391f2ce0027cf4f087d8761d6f1998700083e008e7b4b0cc03f252ce428bcbebb27b1991b2bebc87bb8d799fb5d4edbd3878724dfff9a1eac7fb8d0ad2219392b29bff9a1dc95726d24698b4e8149efb8194a8aec8e8c40a3f17bde3c2181ce92d27bdf962504ca52db75a515721cc889f8e06948553d29c52e21c8c797b045e6ef6673eecabce7784efa5738cb3d1e77e7052ca3d7fb6e04a3ebb37f19b4eb37e9de41f25e5eaac334913ee9ad9cc8a3e295ea7b78417ff91531c600d624541d4a5c7a26d2e741e95e0a0f2224b9800599496f707ff2219a4f424719e0ae5de2268954a19c96d0d5141122f9e0e96c8a57c725de87b153da1f9b707f6f030bd49bc7a0049f35daab277ed19d63a2cadf617b1bfbf13525fcf420d28eab1b669f940464269ed5db16ccda87cae2d4175da3fb1eb8842609780aed85b80efec02fed9ab952dddcfc678a137b9f3de379884cd5bbbfe9a02b0b755fd6b14842a4bf6a977671fab5ddbbdf19e5b7fc3fae9db3bb05a1b6f5ef01acf5acf757aed747a3832c89308596bddd570a257f7156fa556947a29afba0bb9a86161f99f278c3065626081d3990324bd8ea5750ec0879f46335922c21284e1da6e15171021f3210590827d6e3d31b9941a5061181031d306cc66b69f78305bee2233b9beade3e4f01ccb7e88d5efdd8834bf75c132ce2f07a2c73d55109bcdfd0ea17e90a9cc6d0e6e404919a9799403d2794153f9974f1add240b5304684e260b6ad35ec8f090271be2eb7332ed1f7cecd47e4e0c3417103e67d7c9ebfb954a0945ade95266746218623937b1c458b2328c3fe44b26dd9773e864c3e20ffc3f877d6fa2f85a1d16d4afdf8258083b98f9015eda5df43cb798b7923a3e4e068ad9c5e59b2507a64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
