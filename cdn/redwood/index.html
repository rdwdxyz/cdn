<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"338cb30f5202532ad9756a708f6c7b72acad6b41ddb31908ef81410cc41af4baf81150344c74cc54e2df82ae9042378f99ba0b8b2128e2603c9883354fff1ff9a514e70aa43b0d388bd62ff4b7baa3884d6e3bacfb0c37a28780162e0e067a80ee7760e8bf34d92b3fa6d972f9005569f89e04e8fd1d63f9d1ad5cb5155b59806ac8e998b9b027d52c6c37a2a305cd386592637aa90e27a8d5847e2dcf55f0d330ce3fc041bdab1fd5ce1bfa2b5c1dc179a802e60658f2e21108092fc70486c504e6a259b8d7aa9a77947aecac7697e6b1ac3b92c58739c997e92be1225bae592e859a5b3a4a9f0a285937087041cffca664082661469d7a2c4637fda5cc2b7e84d6e39e14661fc3e5ec75b35ca75e1d20cbcab02a8263e1eae2b5993abe19e9aa1585246569764eed64ae674b0c9293609295661f162ad1fcb8b96d0daeda941824631e922f716152223a6a87a50b3dea9b9722951b0b32c577ec5458573af8a9ea52af46a1fd5072dd97a9a5f62cf359e686e5a60e5f549f4c28e0371479da63d6659f5c76bc33e38afa3322c4fbc16d74015e7193b947d70f8e94bf3d444d7191e7050a58c32bf49c14dd84eb948bb3f7199cb71a636611aaaa554c574700b060d333040e6e8aa4daa002fedd94723a56db4fd444ce6b7758e494ba07212d27079640ce35874673de3f529a2b11217ef272c80b61093643ea8e7e7c2f60e3a8d9fd0545adc854e1524556c06415e87cf8e14132fa3db61d81dda0e6b5d00e351ef68255bc4438c99e8b89e89731b0238a3c74cd8f422e76799959d0bf0a61b941a0e491c78cbcb7590a47d3ccad9c4e0d34c60c4125071664543c20d4f523c774257ad23680cc730580c34ce9cc3671a9677637e1de6eb5338ed55b95631c9b2a2ce116e596a6e68829e6b0efc0669a4a2b521e7997ce62a405529ec26717ba2aeafe16e364448c8ecb2d17f65f15df512bd0ae30e4657ae206b463fd7b7190875c947ac8600436236be7d6a070c36db7de757e111960b1fa1230aa0d926195babeb0ee4f005ee46f412a578fb4184be3e5c259fb78550d2de7cc3955a86803ced945f22b4dcdc7772aa8596c9ef41188222f0292b25495bead80167256cfded2f6387e9a70a74b7127adf6f39891f9b960b1b3e792bf2355dae0823e106a0a69bbc7da765b1c7fbfd2359d5739a8f09684a1a7fab0dc4b6bf03c4687f483078fb0f89f95fc8746e10c5e4b20eec3f208ef08a490ff9b54401e2dc293d3d5a5716d77266b4a0e37c53d8567983ca0eae073fe73a0f5c8678ace0d86d4e8b0b12ed218e5c3a50a4233e319e7450fc15effcb14635cf8d54b6ad78e695665e9f5cc6aaacf8f74b4221e0da0ec96c6c720566b3737c3c0e8e560d173a3fb6cec148f2c7000f11c45856a3fac0217d3e02c32b3f811380d113e357a34baca2a5c865f18860a90962273e34204a67f8e611ce9873dce13647f6c93cf4fd30e4fc7e62e29cce478b5a1cad57fbafe274141748a2dc0d9c30f6f60aedd816aff1a2f7530dc8bd8248d24ce0c13348b822964110acaeccd4ecb69c31aea317f3e9f1859a16c7e2fef571409d9841aa2783a6b55dce906f8880284a3f270285d6a5af39444a8266992e0b48c7c93c936300b4f9ffec8cf57629d88796260d2d9d81f220f1e518f9db79ecdd49afe198d60dae80ae6674ee2d11f43719a30ceb20d11d188b4e8bb0565ad06780e02e98f18df8e9b0cac2b9e4903f6f4bc8a57a54845415ec10b95e87498e0153a83e8f248e4a915bcd2ae1d6504905b3029cab6c31276cab19c9331617a069342540fe6e818593b8c0eb1c1b166f502e127eba9651790501541180382625decca5ee249919562854db225a9a8813631ec9e4514183dd73a6133f132940f664eb3596ee97bbce609a816460980629ea68588674457b4c863ffb1db90465b582cbab248efecd7f269595054004d4ba3b05b6eafcdd8d72c2b5b5664eb84faf3b8d1c0bb24371882499d95bf8a418a60b8f71535ce58dfb4dbd29f8071797f69f554c9e3277db5b4340bd126a2daa7551f3151e320b9423d3bca187a3c8e5a4380f07c55fde3537494771e82dd083f1b5e23e988634d4708a24a07ed52eb49fb3b3da4d17f4809887894fee5e7011c63efa4d2b76830315d9b0b805ccd29d12c57f951935a4e2c0e7ee88efcf5abb8f79fbc4f0da86bababed3b96ae9b0f1cd4cd7194c2a39d6d337fa58c0363de1261ebaf2db8869afa838ca10b3f4338eac0c44a3fe8ecb663ca24788981c2a89de6a718ced83207517e909e1d46916d30c8fe94b3c0c0f39435f18ec3c07af6e70a40664b9755ce97dc72682a1acbb6513bdae426302121682ac66d58b79b166b99f19655a4162d4b7afa18adb28236082e8fe87128420fa7412decdfc3ddf23b4c5af6b3dfda67d30045ee0fa23d9ed25b540e7abefec781f6ddc4103f6c99c8442477c06c68cb74c54c32c2cea5dafdd1ee7563b0cc5367fd044dfdf042cd9c4928ae3e0a557fd21eeb1413b3237f5a00ed254cfe3dc2d3b54e4d5158ee6f68012f3101d6947766ea4f40f79fbd819f5362c19cf057bfec378f9f6dcc53ceaafa6f1133f9ddf766c29fa3425fb4be6d5355c3a88ee86cb6aab3e7ea8103108b1e7f928b1d508bebfc19b05973825d14fe6667412d2be0766d0ec0f39951785dc79c95f6be789d9d65b68a253ac5012e5d4b29d59a9d483625928441f7f792fd957da4e48b71b392d545d2bf50a7af85d1a6ba76b278d2733532d7543c9300e18a7dd61f779b6f6b600b8c8c23ce45af578829b1726a13da155bf16a08d0dd00cf22ecb6bc4e27668be086d88fcf10dbed938d89da1111b0c48e17c421e5d0a97b0b1574e9ca070656af7f80366a3e5949a53b834cad7d9c27741f4316a56ef496b010bc58658b2a491fdd4db992ab704dbeef8ad5042006635cc9f6b66dbdc174d79015ea750dd9a5b9fdc685c0b80714edfa1e65d20635a2ccd9a7d86a319e7ab125d4862887fbde235b4fb0827b501a9a64978e8a2e86c67e6029e7bf347b034e1b1958582323c5c8e8b0d012ec37d17475552000abc6f42b55689a4e9b4e0219efdb55c94758e1aa9807963df27d998759b1487e05291ef371e3235cfa70a54f60b12c576a0f501cd8c62ab420d2a6f8650d26851da7ab6a164fda7f77a32cef94dc49516208031621eb9679314df35f1130ac7d0b24d79562d3ae1649a39160eae24525be5dc04e7ed74b62675cf70a82210bc63f6d0e3245ec6765796360e1baad3dcdf014ca39bff88e60493d87b5b6409bfd99b41674ae808ec40d6c7f5bdfefa889936538645d39eb0d9c853d25fc7d4f710257611ae64f279232dc8a8e33640211e1300f9731a9074dffffbc8b20b377cec6e6681da5539779694f47f2ebe823c1ceb95cb5f159d10eb5827e26a1337df650952223ad522eb30f3baef24864375289a671b1f99c0d549244e86852e4a752d479834e998dc6ab4d9716297e24c771d144498c44242fe17f6ea69871cb30709d224bcd6120615c2771c659a20f76f0a680fcc92fe8fb78ce3ad7055a6238235bf12d6a42ad944b4bdf5c8bd2f6ccada93365222c191f767d12b3330acd302ce2185a6187afea59e76ecbea7208a02e1e10ccbea890fa6b45e2a5d497143776df3b86ac041b41dc81a13f15a645a63cced0b4130e9541ee3705bfc394fdd4f0db948a80f1095c3dd409cd67e15961958bc1ffdf9b3afdaff2203aaf3b0c54069b97072351cd10187c07dc3666e698f51d1ee2c6389078753982d9aa63554bb25193444b570728e13e4e34e7fff7e6074d896ef1c5f82ea7aa716775fe341c847e286fbf30fbefc6612ddeb90c5db49e490dd9a47ce0bd55a06913f3ccc994db47f71af5db7890ada5d465a18879e50783a7a0640d969d3a45112ceab5ad4a9491995ecdfa2316275c04fdc19e9b5b123273a0e56700b3e2933fd4bd9a34e7b827afe0bec13097d79aad994119d951582a591ee3f3e33e6f6f0831b4ebbcfe64e876e12e67d7543e19884ffefb3f6ebe144bb091a3fcc9104c2c1796221bbec8ff71d58cc5c355e1bbc4083a137410ec2b80c06e6e73a0a7b02dc59e2ab98d2cfe6ec54c1aecacd6f78a97fb455a328ef9166becbc9a510aa96454cd9bf87a624cc3fa2e734b01b1e14ae2e9edef04190f2d99c299c287081bd0ecafb0fc703e7f330b62043b8eebf5381f1e0605090ce6efe15f47c51cbdb618079dfaf29eac0e8ba425dd61a89e017b7f5dce0056b42c53b4da0a6071ed5d74c6ef64770d43de6d7c33148a089fb99086c5034506c265c8640434236438268a2d6f6d58c2ea0d170adcf870d43985c3b8010a0522279b5fb059f19d76542d2bdf0c29f3dd009a467d55b2f0fd33c70826744f0c2c490bf2df8283e1f7237534d1fc12889e8781466108965f96c0fe53f2377854ac489e2559a07db08b8cb8d1f0e9e1e5a19270d35d376f8a6932fbd67f8f5e73d475d698128bd7014a25028be071c119e547aebd3b1b72f9680df3460c0e24a4f4c4fe7ff51d1be0f952132fa90158820c8d73b95d30f2718db28e09a49a090a19c4d7bf3e8df9345c7defe25ff29b4a076f9b2bb5c4d127132ee0945cdc7c8a622cb1bf867c24420d573aa130fb83012f85a73e132a41cc6c7644be553361119c4c30d7507388912fe1a84506bd7eb3297e312ab4d89d72f20d1cb173163d4d4db539e0f8d79a1da99a7121fff02525f3c47e40ec7c5a7bd2ec3e78005d56789435852a1dcc93b2c0cdf02402624f29979732eb7363e8914d49448b665f0feb6c619792bc29ffbcc94d8169fce29f2421e6c1868810625939c6543f997c249b14ed0b147efca9bcc1c1e80b7572a9c0c9089bc918f46fb28a2a96bdd8a2aa1e9d47d8b1f2bb45d17282240fa461d3754df5ea28c58c03fbb4218f04a955fd9ec5f92f50947abf0bed547c64d70290c3a6de1cc50480baa73a989ca36e5e0a905d1f6ba520c4405b2ea6c57bae9e72e34dae5e7108360693627a95a996c87c19d250b4243069870ca502a43f88d73bff811e8cfb610e50c2bd7ad2bbdfdc724c21d966201ea5e4b6e7786f9e141ff69f080c447b3269bdb0a3cfdf7f80198c296aff90bacfe038ae87ab00cb3e557d40428779fade258dad6f87c6f88e1b6d97b0308cd6093014a983a6d9f9568273ab397e79a06a830fccd9711c2603cc53c73bf047932f736c01c9ed9324a6ce25386b02ac91659cfc0c1289108e0cebe50f64e0f716381b7ef2396de0598e55bcad10d04472bf51141c288f4c25628a88421fb8e7db2203dff37cb73531f562084e53446f4263f306c37af026156362ec448acd64366084de85f768f10fd470bc28e8b2d419cb216b59e854a2ea6c86aed6ca1cc9668ee10a1b8008313739bb5cc9fbf33a588729907c0911dff3b884a97945e8d14bfdd04f31953aaf9cf2901667f31571fe21ce09cb683aba95549f8762d2fa6ec8fbd8b3814b15fbe49212e00b12ba1bb6b154dc374d7b6867472149e8d98e14a95801308a3d259bee505598a8f415b5d934989c58a8c3a2bb336ff5f0a00498681fe446740ce6def27110dbfd31ec78186215bd1f4594257a0321cb795b1ee43f697ec4f8697ba56cf0e181835aaa8851a942c865a0e4aeb3cc913b3c1370bcb496938963a560581390d42a435ae5f9b4e15697873079f00ca607a801d7b5ceeea88aa27d9a1761e35cebca642b74c84430793404594a9d8c5804d59919ad24ef177b89c1d777cd0022721e52dba79de7bfab4968f90a58992b19d0474abb90da6f59b801e2ee8c33f9ba785032c5969bb4e4a12b0704d48b0a45fec1743a3f39da2d2b83cd62f1411d831f4de6017d89cc23ec8bdc29cc42f4bb10e6d415efe0dfadfb8bc3a8d7dd7faaadd640665a428fe73437e3bed4f8225f32e4e82f8994c90b010f06e94488023c74bc823fa4701a6365ae28613bed0420b195ba5f6758379836b2a0d9f6db80de3f0406e1b772cd1fa6732daf7cf8423246c23d9899d647f2a98c9fa31fb1a8da3197e52cb36356c3ad54cda38995a6468e896178330a75cfb11e450c09b2ac1c85000110756de01468a5f8efcdee684a5e72bce1d854fe51b04443eaa5d4f5082f5e5d3ad9f315d528d7ecc76d7f43e609359023d847586ed56615dea7035b279429379639b012b8f9df2800f4be55c2ad4631325ebe8556916d2be68643fd7d6fad4b92ae4b2acde41eb8ed7984a7006d9800e1efb5d64a36ad901e25b06e343a008eb6251cf298527c9f86df90d4342f4f4965fad910b59ca63801139f1f5cfb6600dc8187007bd96c8a09329647b23ac9bd428ade7b3980c12684e3596ac7f6f8d2d0e902d4d91e57946ba30eb499e569c72fc0fe85496d9fabce7a9930d29891fe4de2474d5964fd330f7539bc59ed1bdab1791b2028b4d3e1c0b9a4c33365a433c5d37c97b426e9b10b30a4f046351be640bb103e646670550b08fd9072b96ccae4c18a1676b0aa942d8583aaf1bbdf9f4866803187bb63a7faf70ee1770c25e1381f867679ba94ff4a06bd6e87ebe43613d854595f34f47b5428fa34f797a1f948521e8a2e27ff15f1c3debc80dbe76cbd68279a1a71428b06920de4cfbef4e5e3af0da2b750c6bba926924f8f609ecc12d616f8fb5befd1bf74e2145654a7b3b8e993f5f36117ef74456a4f9c46ed9c91351a2424752d57f03adb267c56be3163d4591530f028cc5d7b32368f3b2c63c7bc93507cda57a0917cde9e6860b2902d594fe154ca0e1c442f07829677a30b9b6db99394ee36647856fb58979080c29005fb58cda4aa9027d38af7c0345d4355a6177f11fd8080fa956c086eb1266180079978b62f86dfaf8a80803f4cb06ab8da5eb155ebd35e1288d632cb00e33714d48e023deea41891b73706f124a113048772802bda292982767669cdfd0d32cb6b2f7474e99d477b741cd6459cafb5047966d81fa60099c076b87a25ef8389b99db24f56cbb6efc4de03b12d4e317f2917b96e030a2e517cd14f0e26edac1bbb9d707d1fb46a1ed8d52a00d1d8285441233e232628264534790aac63c0f2114cca777dfc9f6ae8b0051afce63c1a07cdf7e6d9b903ac2379fd114c0b74aeb8b0269c7135f6e02e9b4c87e61ebf87bf3241ef65ba3f75ef708cfd2ddd5ec8d44554716f5c2c55485d1c17de293189628cfd5229acd2385dd7faf1f29d6a89539dc4c975af225cbb73b939d75005b0623655fd5e6b769fb494c79bee79ecf990d7f755f7a6f17d1ccb347ac8cd9ea5772ceaedff050de1e5a137fb58fa681b0114ef5ac1e9d2606234a849c018b2e17e2735e3ceab52b6399352f1f8fa6d480cbb614cbcf1dd512375434ca11eea7852b5fca8d4eb86cbf92da9f9957cc1a6d1680c03cbf0b0b96b91c699f66999c371d3fc6e4c734a0d20820b191a6e6b961c2d8b49ba3f6874bd66c934ec6ff95731a81224fbbf23a7dcd166a9ff6e64367d8737a4a8521ebd03167b2a35fd565bd43181782844752f48415cf354ba0e352773d10b953936ee1b67ab6e46803dc882b420dad5d111e33fd0239f43959f9289aa3d58aa5e180eeec3bf10329669cbc0450656528c84198a893d8c62acfc6f4959b4b84ee3092b5b3ec183dd9e79331f8b6e4c8acbe46eddf64d71b1ff49351b428865c76b44d6ec62d90981e0a937115418236c2b91b552dbe351dd6ada6b8ad7e0f023d12b951f5601aa684cc50619040638b34de1dfd5b08fa27cc5591d5885a6994e44caa0013aa75837b6a0c34214fdd439b929a4db71c183fb3cbead02d4fd0797e19c6679a264908c267568d846906b24d02c2de18af7a03401b93705c7f88606b4edef23fc28c1605bf08e36de6192989966ab98eeba8cc7acf43c9bb248270bba5a04a227c780084ec01ca415ff823c79bce7385644b82b52e13bded35c3ff75d794a2d4183e50e20dffda1b9ec5f54178a403e2136faf1dd51aca4f5b44d8ba26458e32dc1859b838ea204f51c500110678cd01133ca9f262c7be66af50f1bd9525c7703770a325a38b8fa7ecbeb927f2ef92d05910e252be11c31c5b2a2a069c7f84e7200fa9774f1b28be5e14f3c60f2d35c850c34b22a4c3677a0914075cee9bfbeb6abe8a5e2d20ad783ce33600c9e3930c9a64ae36d67c633879dd2cbd5b026704ff41a4c041974873cad463abbda2fe74e1b3f2b55fb8ac6a867d0b9934748cc7a664aa333e82a6024bf40437d93f883203499ed3158dc2a55aed4873e29148b83189405535b55d9f76ea9420a443e55137eeade27fc676aaf572c7631b22659fc22bde32b2c1fc7db17b15689c1a063a988e8f8bbce5d911c797fde7b64e90210df4e6ff5722c4281b8ecf00fb97a5ca00a9bfa0fd3a4df32e0438a9a453a3137940d2de921dc6306978d93a8cec155b4f7689025e921dd926fd804bc61f2c7d728d3bd9187c5e2902b0110923a8e40e5b96ac75e055034cb6e8e0e933f3ace2618eb0a3e8b0cf10f75736fd9f860ecc7e0ae85063135bab2e4825a0fd6890a52fd3a9d7fab2463b896bcf8e22cd1630969271bd510f033f0deb7314599da0835f99ac81247bd3e62afe5e9997ffea952a3c7245acf0f187621900fdcad53763d65264dc179ef0c21b2839ddf320f51068f2b62ed006c8e1cb56ed8d02dd98cff2abce99f49bed203d4abe382b269981537f975154b91c3c2ccde6b6b929d165f5a8f9fed835013672d69ef858b152cdf540fa0b24a100c492de48cf7e146061bb06250ebd5ca7136d9cac73b161f838eba4eaadb33eddd1f7b4ceb18c8de0cbda5333c5f1c6bcca5178a6d70cb43042a89f5b769a92c23bb4a7c8cc979a8b19955eff88848584c012a4387a21e2ae058ab50ab28a335fe2f5af1702905567f2ff2f2cdeb44d7ba04ae1c21624949e42579f6d05b495d8596eac61a64d0abddc86374591053f27ca3c8eff059b60c99d7b1441c21ab96c4ab9d3876aac047783e18d3f18f82d2a683886c4b1e2378876c8ebb536852f1e7cb779f1112446bd36fa6758fb1c96416fca4b673fbdc134df0bdb487866c462e19a058f2a382fd3df589afe22d53a02615351cf6d5d0ebd6b57b6dde6cf68abc17d67063c63739b459faadd50f3f58314a642f44752d4e3338d415fa89745c16efbfb5e8a31a49b730fc6e00861cb7d8561a49f8f27154c389bc15fc221a131f3f0302ec51f403e3dcdc89669a42f59d8182094e0f2df38850b8269522a29fba89a9011b89288e498a05c096c273f9b1e4e584d414878ca1e4fd308815b4bfcd5039d13746238573eb078b60698c421461f92e709e09db0bb2032b53334ca6ef1374041f284e05669274a17fbadcbf2f0b0f47aababa2e0c38e23f5bb17cda3d17bc45c261cf36f05c84106ffa9d1a2361bf10828d4e04d720ac028febfbb977b7670e56909f23e0c0a61d9f781adf5a745a739d14929f7df29a4caf802f5f24ab28864211e2b0f799679e00b990d8de633148ce2b694448ff3fd66e27a6be73a44a91cc08c69c2abff1adda7416ed0ada1ff04e29d0b356b96cbd616b21a930ec2ab01e9c56fbeb19167e8c0798e9ba095d0f81663ddc8c5aff240823cb5b326a9cd093f95015842070b14db87ddf357054f30bf063727bcf04a13a0f8187793ae4ed2b97547452878df68b2dd265e1304a3dc49cda8e249c6d2e748116b1587f09b487e56b11119d2a702fdf022e36a0323246b4b606eca8c330f7d7ad97804a77c86552383f46c14136a608744c6294f3a5f6d996c5784de6ca1d3b13b252cc1cea4055e8349088e133f759dc4d90980252d2eea5ccb5b61631f34451cf3af97aa642515d04446fdc18507e71f691fd02094dc1c0119f841b558eb0ffb70055c059e31b54749d1e8f8a3aa17c9e09520efe66ab4f2b94ca2a8c22272a8cddd3efffd79eb30e67073c36c2ed290a50cc401f6d0dd1d5f2d8864a51346439aadf0168de14425b456a0d72250f0bace2e2a68f658e9f940fb3253799e4a11d65fbd8cc99a96b9af80210ecd789324bec93c5e003c62c431251dd73bfde5799681f76b660ab61592fd99f3614f2b244fc44854f27057131a11711275d3ea511323c67fbca142bc9bd842d8524a94cb4619aab0e6cec512b7cc72e5e46b48f1c15dbe1150b6501e2e7ecd095b521419b64dc1074c4fda1d83b24a553b46b02a1c2ec2cb15edb90b82c6e9b277211ff166bbbecb7b08631c0ae7c2a0518cc698e1da25cf58b7e32fc0e04946260753fb68e7dca27691a44718e062427b42b627955366b5f88a7e6e05e12ca2f80cedade243f50a530","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
