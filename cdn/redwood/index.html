<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e1ed30c817989baaeba51d60ea97f06b18658592a223c40621d35851168ad786176b939b3086e2ff5c96959f56d5f53cd248ad7b2b4d79e57ca98d321faad904e93934c8d3a951fd8f1c17c7f4ebd6a2fc2f147a67532526be215c65bfd8c3925eae0170c9a8bc83ed9ee90033529864b6dc100eb7d711cd999afb6572cf0c9f034d4c3b506ebeebf52b18ce9336f196413d468de55ce37f6e8acd6a4a8aca9fb07480cff07c87c76eadad35ad874c594eb482bc2896520c5d15732eb379413f64687befc2b32fab81d43f9329e41981f8a5479e04170046786fd802f1b824acb8507216811d193326c469074f80c0b5080b48248bdae7737fac31e1d2f8695b18a2cb36124d2df1566097fd8f422d1845031ac52dd31d1e7340ff32db9699f7eb55f37202ce86fcc1b99fdcb2517614595cb37f7ee66471680be6d9886c0f02eb5ef76ab456255983c28faecd4b4445177fd045f2b4773ad38338a62a4e1d90344fd699f7efe540cc95710f20a3f9c09610966abeca8944f2192a46c45cd3621b2b0e983295256ae3277eea669c3bcce79aae08336de66bf1fbc36cf3cf85e67cbfecedcb40d2016964eddffec6bb00f3bca37e366dbf244d19d0e20d62c4414e5c0af857bb0e26242800738b4c8cec6f8e9d11088049ce66a0efdeac206bc28d63148666fbd81fa6ad94f448c53cdc00d975af219652ae6f78f8dfca3ecbbcce307969c4faf23cb869f6e38f0e6261c0630788735acc8574a3749253697f94c05a59bfd09bc92f7e93e906d7753976368ea293e8711ba339a3691cc2b8f102cc6935e43b5f0117252c4d00c43c6288e64bb652be581ec7de9a27b4d2a95eaec58bc94b0ed4a897dce4c1ebc2376d5bf7b9916e7b5c6c6286dca1750ad5c18c730788516785cddabc22ca37d60bdb4ef759ac2122642778e14a001db269ea6477ac83f167114b11932ee57ec68dbeedd83e75e879879991b225df983eca55292b1a627e3ad0dfd08ffcc8f755512dd35281979e3cb49a51c6213126a04b05749746afba7083912f4fb601261b3fb47bc7f9ddc2c863c832ec3dbf5c0abca7cf3fabf46d0a103b5f0bf70d8a58bdbf215740327d753512fc5343654646398072271abe156e306ed826835585e2d1bb6468a88d56f26ebfa4a6514088c24cd4b8fc16df1fc5eb298dddef5e482b0bd91c79203abe4f2316d0fb07eed44f3b3eedf19f68254bdbc8f658ea162f3bf2aa16e8dda51b1e70eba0cf148a3d49c06555c884ea003c07dffb9947000f9e6511a4ed3f39e6edbd04f9f53ee7cea260041f19763c0337e2ba47529ffd3a2c206e53aec384bc5314f2fc622227387115bacf82fbafcb2b8126e4a6480e7711b1b608437aab7d937bd7e4a2932fec6b02c97cacadeb18f7d7679af26d848407e84e020c713fba8bc7e55a629c1a5d6f6de4fd95f252676150c93b6f55423a8a6a4921cc793795163a9ba34ef2c04d142ba73a211f51e802094ad3fa2e3c7c1d67d212fc1830054c542101c2dfab5679904a6a498f76d5de01ad77806285e526ec48c53425bb940061734fe3d89828a5a8bbf8c0a2d98643dc2945e418b8eba45a922f9aea10585733fe34bee5404e2aae811c2374d9247b7b099e45700959fcb2a085001fe395d57e38bef781bde119f1cab5c652d1e68ed0cd932596056ef074a8ba9a1046373c2eddc6869a1f09320419227456bce837bb4ed16053583812ff78f998b1879bb8d09aabc5cd543e632c7508f6e4cff9294f5ac1a73616cc6ff313a3c4412300ff8ce6866f88cfc6d49a67977c7c01895e2a432324a1f871ca2deac43eb688dbffcdd41b77efad040be24ad63b8e55fd7055942f1fbfd77e3da8b907111e5657be250953fe75a0c4b5fb14bce7e985cbe2d7cf03bf84823f4b0485a26df8af55898b7ecda8fb1c6ac73993fb4cbaf352f37fbb51463773351b51a270336a87deeaf899ef474fc00a2a3a0c6498e890a0b661ed21ad8d0ebd77015abf7d0e52669781db6a411673d6107edf8b20c1cbf7e3bbb522e02b5c8566219870f71a6f7f979410ba7fe541209cee4b72b87b0aaaeb51aab4e2cad1b18f5809f628e8ae98bf0d9c176fb3f60735524dedb86754528229439519348b7cdb0e2d022cf73c4468b6f2f48444b4645cddb84d757726ca243510e80d7853a8f84005f7f808b64a9f162631cba15ca885ac78625b23a566a80cec48f6bfa3b98e2f0c9a458701f1c51fe08b67724fc67a099f02096ea1ea2fd6a2ee6f4ce59792e0a747e5586fa8d1d0f4c0cead64eb680e790daebb0900419ade8bcdccb788a0837c294e566c024191e9c1525fc29aaeef69a5f8d03df423f63fd4c245d870bdb1017472b541e765f4e24c9679477d6b9225cd952d83952e45906b1b3287181c6876e9acdc3d604c28aeac300c8068899d5df2eabe75406aa7b974b9ad5781b4d9c4eebd95c0482f28379bcb6c6442564581c8e3457cb094152a5fdd2466bedba8b810f2884db016b9d2d37e14e75cd5334243b0445e8d3a828bff7e4634164ac2dc0f480969642b6bfd0cc33710acf7cdd8f0b61f2240dc4882f6684d6ff933a6be90c35a56fdbc71bac3b4f4b7349693e94a8e2af7f1b73aadc49dc864b5c34493974d35b7de74a27f5205489bcf6c897176eae183103b0a41bfa4aeb8ba927a6b5d2d297cf38e34778c8367c9f0ff1306cff1c84de335a5642b75d390099ffeb754fdf24f5553597c47d201c9cb0f1735dc7c89ca98a82a1eae81b884e3da4839572d1f991da7f8294decc3f001771391c72365d3f792a217191dcaf8da81d79f5a06ab8be11138f7431c74de3dacafaf34996b97b5dba4fefb7f045b75d65841ada775e9916b335794348e785fb479b44b5abe8b5bbc57ee38f5e23a923b056ee803a980d52fe04222ffee057f8b04b04e8bec930767759ad45a25c71e4396d0d235c536d81437735266f57d67973dd382e5d5a8938177625c0b6b14872035f0c70063ebae4f04d971a16f58bd9839bc57ca03b3bfeab24aaac95302dda63d53653534a77d559d4ff91ee0d9f7dae5ee8ab747201feb9386802de0896822dcb0352e831bbb59f411c28fc78e8830e6b2f65c0a9da7e1581ccc8735e67c02a88bcb6961aad8cb85defadb7c1413f98f5ac296a96d7b643f2c953140ebbe9f234d8da6ae095c90424ac4998a7d07d8b32218109d33a2316a220f4f051225c34c3f34160eb02aa0df259ee597783c5fe6782a2ca48c8ee8eb71a121731641fe8fd09baafee6ccafb15da9a4231722e6142985c0153c5493fe9fee3a945c86a39ade85c176839f661652398a3bde763e6f27cf1a9e4caa8bc2916e88d13fdc25816d6e254060e1faf8a647e2e281161dded5693ca5d9cd62e72d3695407ee6b6c1c6d6c800d07f1d539f702422268ac5d907c9b019bc11064edab9ab770144b42af0528a1b68e5a82407a6b5a53c369842e53bfd4f2c216902bdd6986ac93837d693b843ef553318fe91cebc2702d25560b671596e3da0eaa14b0166c51bbfbb5d83e6d14d333621e6770fe02baf78572de05353f854f6792533ccfd7b3649868a24ad5f26bf51a66c8d6c188348feba35f4abe33a20149e6f7a3caa2e74c742fcf1634a30130b3e0e2fa643fbc771cb50bccef0fd7c90a4317affb4b61ec762e1553c11a109e01f7dcf77d6cf205adbac893c3177a1387de5fb515400414a5766c1cb41b95ca1edf3d9f933ba062401d83b93d5b441569e946015557856d9bcbe9454857544fcf8c880276032f61cdde75c0427b41e7a17891c3add2905a09aaf1289a560a73b93d96305cc1db0fc74a735a10e6c62e5c6491b2b84b00ba60d86c0130792a750295f07bf15f15643b31b28ce0be56479604f358ab757541a4b037519dce420e849f964f0bcbd7a691b70b4b2fabe271c0d8b87923325dceb1e13875c1e62e82e8a6f2fa6481d1bc3ffafbb443f72ec84868829a7adb79df3a4322653648892ca36cf94a013dc76360077824d18e17680799cd0bfa44f0ff4460c5a3a58e7dc32661d8904b130e86d411f6e1650de2c2d71163145fc7ce5fc72e4412e03dea9a6ddf25b0d28225d90a42ce981450d443af4f380d4cde63bb89c4a62d057d1046f9ce98a52c4a03efa23975b5a3b8a9d51bb1c6941dc2cf02233ddb91c0f833202efc87e9f6f68275403541bb11d0ef451549f555459680d803e8c0423c85790f226e710e67e04cf4d4c2f9b0d0d7f56f0f6c5d8604976b119fce1d91c55686e75e6e746e01150ca6299f212f5cac8c7c58d011c68c345ddbb1d583ff5f3ef0f4451535cdaefc28c4a3078f275a025475218adbe04655173e32987f0675d1d7dcdb17e5e1f1464889b6369d9258eb72e38109d67e520467f9fb9e40e7b7f5978c7fc0f2d7cb58c8cec281ed48d720b10c1940f94d7d416d8fb7f3d958220a340190646a20cc79de716b4783c04998fcd1ab7f7c70846743a399c31eb19fbe4f13788497b64c2bd08cee3456a26ef57a6fc1e56fbc02201572527d779af7a7e0f5648f0a0bb37a218132c38406b65d2abd6561154b3f18f3c8e737f60822064add5288095ede4b3941547680057cef8affd117f01c4cdc358ad370f0d8f4b9dd0d7aa587de8a27e7bffa502712b85fce27bc0ca552887b211f2c993b9ad585cf778ae8019220cf836ca5061cae5e2be85a2620483fa60bcb39e0619eea4e2c35a12c3053bdefd9d87eeb7114d45332efb9918fa2f5e6130627c445462252b9e30509645307a5797751175db827fce867b2305cfc3fd29831be9acc2ec7de832f20eda4936c1827f75cc6dc99f6a0f16aa1e7966298b1bde4030d9671b9c146dab69c4b5020bf002d4d508f6be87eb57a08693a8f78f2ea3cf32ce5e72ff335a36e4e966775e95d6cae264d70e7a3ae27c03a2ceb79db4c3f82232c8a4a531340abc791dd15fc6b397513e4ccd298b4707ea7390823e56900fb431f5dec8c6153949c568cbbc7c14df8aa25f78ec67988758c4c26e6d95c2a5cf3e36395ceec374e73d5e752d91a43fc3dcb6c2e45ffd046c800d6c4e154b342fbbbd8de72be9d3dc916a19eaa1791444f3d45f8e44e8b396ae1c939959040b1d14ba0a327c3c0f414bdfeb3dcddacccb153e6e1158a5518fbacbf468a044d44810bbd9d67af4971dcb3628bdc44f4bda2b4e2fcd271a280daeb34148188d651285e21565cc479a43104dc82ddba1a6c30046bd5c8753b24f18f0161dae46ca1223d134706e385a338a4ee0e61d3c2469bbc2b4b6ead2485129cc40ef8392159ccc6d372ad61bab2e57e27945efe5f6a656f1f8261b7f58da383d40eb6f5fac7e97d660aa32bb370fbc1e860adaed9f42b8a1fc99e8405ff241c9dcb7009c169a3afaa870f5bd348800c1ce2fd025aea6940feddb5b309c0262e799d52054c83e0dcd181c0e6513ca7ff9b1c5f73357d6f4f61648fc0fb9623bdf92cf15401100c60695540771f84b96501affc8b9eea45ea5aadd29c069f02595cb4a521498a88cf1805f813015bd22a17dabdde9bdc34b1aa208836a37c546d472dab616e8a1092fad865774e966a63762f4aea8c6cb1cc95ee1b0e796b9e36005300c792292a186b097851490f36f850d938a1aa16f54068dd9756a83719b97cb6f1bb1d723098882aee8bd2597e042c213bc5f3d04b4a2cfe69a04dd0b9f7a9cf1e7d498083241a693aeab05ceb722f931267a1a521607bb2c800dc628f3a4d2c327b569fcf42d56ff12fdbe148d16c821e3b4365f2d67f4609331f00c18c572f6513b861a5cd5b24b3ebf889d7407b066e2b75fd5ea579bed27b287cbbfcd1d2783a04ac7d63aca237c4bf35807ecf78968e8b028a81aafa3969760cbc73cfd71c29e17d533fec1b2c3864e379b25c5e70c1a3c719706724bd68f34ea897e8488a57a069ff6873feb16122b269ab01a9a315bf3be8062df5d49610d1af10f73ec23b6d7e1377e9647cc026005a301c42bdf2a83d60259947b2788c739e7bb803e9c338653e817f8f425090205e7b6902dcf0a72864ffa422034f51f98bfbea525ca0138c7b5524a22df27ab388c35c20ac6011a234c59c40a995d89ccd7d5292d8ed232031faca47afc74c5bd0db5d99df4f1683f3e285d703b4efbb495b49715d4b4dd83396811324f55faadf514b289daa2c25c43800fb0e69fe3c9cf2b3cc99038486269502545fa41204814968d062bf5377b972a47ead5077f006ddea25170160e41640d1a3920ec73c508f5bcad1eb8ed2cd7a9df1e5f681b74048c59566a75cc8e2b29f2b3082de86d97808cfc2a9f7beef9adb3770a3cd9a287ca760848f8e36bdd4a57524fe1b350ab5b64ec7a7738b8a481fa134d2a48c4a26372808e4ae1314818ea10f758ee80a734122feea27d7b82255b2495641358dde20e8f300c8e071df95a68c6685b5310670647b4870cc96be3f61e9b0506d01b33723b899255357a0c9ba62ec2ef399fe8f7064efc94364aba1b8b919e28b4a8781acbc4b2187bbbb579d747c426b7cb7e7f22573996d4bc79a0da678edb2957c57d0fda1831f50c1370a6e168e0ca4edddfd803f5587fcbb60f05fa67de21d6939a1e54129070a4f84123b1715100abd93ed9280892ad2c36afee934c04096916fc75a70516ffc5e52ae7135f500bc665fc736c547f0827c1171ef4cdddd1f4d7eaf0d6113663e1e5cafb5b4f31f7491d27c0d25c3d1b079ed231db5ece6b41c724eed921678d6b198f47dcaeb92f08d9eedbf00625357cb1387cb1fe756c6d4090b1daad4c4692c31640831456c7e51a560de0f824934a5c5f47d0d79b0b7c515e2b4c5ed19023b38b4ab66ccae4790e5b164fff5bce332da17aeb24eec811aa834f804822dc7d92dac9f9a515712ae7c59fe72ae2e35a0e1ad28194328ed74327a2cf6fc21d5ea461a4bdf86d6a3a9cf56a682e7aa96a2aa8b5b627bad49da2330fbc8752598f0be78a5c0fab013dc8b37d7d43f187d441e077230ac87d6fa58df7588278da5b54a7f05a8fed2d0ae0d7e9db2af9c2f6b60908ce447882bc9fee7efa56e5f254317c06f2f777c438a7e092e1ec8c53d827882931daa8285f8cb535c88e603828a9cfcc5db1bea33d848747d0ba01f961e478836f7223891776e2a3254039212a08e5e8b1fc099b8c113d8ae2cfec3bc933cb247bdc2b5c66870a1adee0223922ac02f9b42cdd05206f55dd34eb188bd476b75217e7b32078f6abf1ddc0d3e9e594894cf432025dd099c340a1165ab3b9916de464fb6d0007c2736475efa3c5e6736237eb5abeda5262993782eb5b21573116e70cbb825ca8e0e7ca380cf7da81170a4dccfef21b058d71a657fde65589dbc8fec02df84de9ca78783c31ccd035accc6110bb9a63a84f07ef4fc31a7433f98718b34cd11afb0aaf071e7df1a8d56e61a94c043441622369626ded04d8ba9b9797398bc7614b7e37ecddc5e27a151acf8636ce337fe9bef4247caef7f0b90569e3203d6fa0e283f96f7b132b32774c9c64e5ad5e42d1b8c1fc496cba7d649e2e86fe339ad6ed3ac8da1f83cd0be3f2ad19723c6e7b23d4cde168a402a2dc1f763203cbca45747694eeeb21de6150347b05e31f10e350223a1c45ee8a0c11df29e4ca2c35a00b51efc9a8165e3454d8f52c7d46b98539a15b69c44db6664cf55147d8fb2af723c3d66775f1c704e7f650c75602a0b5b3187664580b20f09ecebef238722c7d5dfd7d0343a01e814cb8a7f78bef7d3d36a82f25e18d2db117610ae96a961418cf5fa72c618546862d3e04af7d49c66b7a6d621ff31b9ef530f14cdcd86c2f94f63d77cb6b2892a4fe9d36cdc84c73a0832bcadcf573807e138ef31d3408a33f9c51c4bfe28b7fff9a471f66d1cc7b8fd08c1a1bc4b09cf3d23650070894d501726281bd0c1a825381d42980b9ae9e7e38280c5213ef4eb79c064b808147716d5eebd3f3abfd346f341234db8bcce9bf8b4a0864305167e433cf2b9b2aa024512cce606edf5b7d23c2c7e283fb766aa1b1bc84c5caac420eb46e820b20facc52b33f9f5d1dfb675b13966a4995545481f3de9bee6be41ad849c6b5101794574e67148f93e98bc1cada293cd2b0ad3a0c38b565a930ed639f009429298415902d55a2125de5c446d701576b7e21186d0ae5c2cde5c1e56a8bf66f893b30eb81654e16e34786413cbbaf5441d818bf33c53fdc971a8fa60466de84b56ce17b6e791ac938b328d6f74ab84c91fafc06b4113c4cc7365057bf6a2be8519a0e24d44e3de6246c62968588872e4ba00c6f3b3dd6007b4189e97d849b365c3a15144ace4eff39fcea896a36439fc899e44f6501970afb660491e7189ac900a6745a6a1e2b7451b37f02439ab90fbfbc90d45f6a3310f004bdc5d23eda2e1f55da64e84cb4d2993cbe3bdf529674f76504634011c965fd4db2f27ee22d6203bce4e26a99b825e996b2b08948f521692e0e18727b1dd573991281c534a57f1b213fba86f471c130ad641f940837c3aee2c3392eb1b789b21249568ba1e78ddfa12c60922b9772e57d2c0480633d4de309b44bc2747340862c1c03a107b585fd106dc76e7ff8d3d8772fdbaa1031cc284b10c879668cba830b83dec1957ab7f0c6463911c23c2f4d2e00d4e48bd2848e422938f8817d91403b48ba61cbecbac5ebdd5175e82202c8d8dc90adda1f730d14ea21dc87630647785a39e6950d0dca62701b179064fd440dbeeca8f061ad1e84bbcb020e7349b97095e1a3ef7edf237a00266ecc0f51088aa7194ab9c9827c8e993cdd5c695b0efc998c05b62bc25fdc8c6edba10e41e5c663ea30807fe22b4a8e1f540ae761bfb520d90c5f355455d2646f86c625b2e926a7f6e36e4547b0f4c7a81b8274db906dcd806c47132c82aa4fe1b212c226915e5b11649c09a69694c90fbbcfd6ba287cd7f9b5a93e35b957211da5d1f7eb324bf1e6d8280932167a0ceda73c47df238f71fd4470c6e20e4a84f7df4ae5a4467bafc324b55a69a043f0eae14adf788487ff551e188db1476b07e8beb947a6856f6284b46aec28dbb0fa44843c2ccab55efadcb9a960366e3db14256c516a0f5ddcc0b6cfeabe71ab6ae62d95631a02473786cdd069679acd0745ad16a69fe53eda53907700f4432b7aa7d7654c23159b54a08d7b3a9dee616f1fe68ccf745ce95a8e2588a30055c17e1e330f556ae6c318dbce7eb701cf9379556ee4e9a14ba8e8f5f60356c4e075a2cbe5da5df9676166f9628378644cc7d9dec2361d53c529131b8a7c03efe4bc32dc03091124db897219db712f8cb742ccd2ac3552e7b3054413cdbb8f2bb6d1dab52e125552bbb30a3df5467f62f1c3ae9aa60e825849c493b3bdc679e1e2f2b744a4d85e92ecc870d41cff9acd1f33f5871c670d1880c25cb9dcaea58fbc65b6b002df57a7b41792b61994867cffc1730457fd9c8ac52c27f4a3ea4de864413eec2668a8e75cfe4937a3746ac9e51f1efc4adfc4554cc669cf9e7bc3a938eb32024f0834ff974b15ca3fd0f4abd13695a128e30488d7aa36cfa6755405494b7fb32ad3a104eeba0105eb91ad7692a47e855e002c812d69cf159a41addb5cb62ee18b098e0fb101fcb2cdba6a363494feef84654fc494cb3c2f7bcc3e7aba41fd4a190005fb605c9f8301580350c05f8acd40b3c1867a0e712f7af01abcbcaf940b852300fa8dc6a19566d64b21de726c55387f23b64aa6593439961e6cb6884bbafa4ce7cc9b604bc27b20b6c2ab1a1c3d8f45dd7e3895bb197113ddb8bf0a874099c83e280bd0a52482069a02054408edf0a8a53b649f1d2ed6ae0d9ae7c524b5bf01cd7d7de603930796dd72b2973e21363e986584b6044f08acde10bb29982bd32c481e512c4454464eeac3967ea9630b613834bb4318d0c11d9098d3991b5c8241996eb60e33d8d61a3f3489101e0386b412ca18af73a17effa60f24fafb58965f768648c3a24ce102bb7187ffdb815451c44c1a6658f55e88a36c3d0ed4bbc826c05cd6981e7929050bae38ecd436e355fafde6328a392f4882bbc37c9700c1c48c63ce7d7225085580b69eb7834855d0569841cb3b27c2a7a2e1a49cddda02833b70e1c5dcd2989b23c7342cbf9d7b5591079d09df2d4a3c057beef59411d16e87610077b1e7976f06e815f89000eb1602289d5bc1d1f21c2ebbeaa5967a668104c56ba28039944cf185c1e6a4e75992a5b0faff174ca7b6037eebe7610b9e85ea46096b84d544e0e09cae10c533addd74923ed5cb3b6fd871b256b91242e74b581db154b3b07334b11ea4b6dfad3c86c7f10f9b914225cb1d877746f403e432000ab6b3899ace99d70b7ce640ff593988f4e0fdae014cf76136b3767fedf0a9ca5549321233ab0e8912e13579ee167f15407838e055aec40af4afbecd50157b5da3c7ca6d61f07e89d7c664b597a5097722ff4d0e9b5e24bcf9a3d168228e0c0eff3f30d9e187a6f25341cf25e52334bf277398f72d2b218ad949fb53973a330ca2818a8d31ae3bc0bf419c0d8b829d1e8e22a7daf0ec678e7b9bccec75ea9cd311ac100ae3a189ae99a8cd22c6494d4b18bb2829dbe913d4a7946690db0d4abea318b7cfafcd8ab2079f9fc13056c5c95e193cdf6c0bdcd26db41605fa539a84da054a643713debf1c36f32fddc1ca28e07bd67d598c9796e6390bab5948042290a84b3497a317265f190a26a84875b9996454c0d6d809630c09a62e723b17f38b7f3105b233f5f720aed23508c026a379e58175c7f0f8220d9a32595c2c12869e154fa7953bd0ede3c68a4ce2f44378445aee147934dcd22ab41b71f2510466b776f9aaecc76be5600b109415970b84c659a8d4e901009a2ae8f436245e04c5d53bb78e408b13dd374f0f697310a98034d2257ec485462b23d8879b57f43ebdb28848913f953f032886c2d42894710e75e7b3f9cdae4be028940f6ce02e6b2ab5b1035e41d60311987b63b6aa2a6a4be009159b7a4cf32dc508ec41d75c041c081ab014db05bd9e643d8b5f583c0b7138841e290fb2e4766772036cfdcee45dcce67a74f3f2391dbfdda10c7967cc111815fdc08bc340cce344280cc749ca2e8f46e3bf254b9752de6c5c8baa526f4c29f1819759f10ce30828abd12f71c993b458de12c41cb2d0dc0f7508dcb4daea0d783ee9b5818047212094246e72f9611b189f4ccecb89ec1238e70f3bc686c986e0abf46fdcb98e13218efd320c9cbef81004a9702f042c6eb137f85833013d47c349e2d79a8d72805e0cd4bcf976540e04ea613d8bdd26dedf0706e2f4c35b92ad771f9967ddfd60d81476a7100afe967b167ef28cf0319f50a9ce28f378f1740b33f91371a2dd2eb313c19b4992fbd52ed742a0421b8d141d17ee6eb3c235956198621e5e2ca407da3ccacff95ebcf8295612f8d4654eef0945cc8a68359b4ce71e2bd195413922a36d5a209d5cfb7b7706b3660bde16aa50aa2426c6874449a35cd8d6b9c6a90f53fa1ca4cf494c3f793b16583f831ad95d4288d98ed662b9fdde0de03c0b958fc19a66202aa0aeaa443135b318a263d050febab964a0baa7ef3ef1235fd68ff29907e01b91e086b525c1dbbfb4d7aeb619dd1d9ed487d634568a7e0d51fe571c0ac63ce04231017441887a195fd1c8b8699a6e4d77437c64436f5a8ed7b428b884c176bdda36d468ffd5e159ad7cbb18013ea950e5b9b01ac235ddc2198b008c2e77d53a5b309e1c5f842729e4c5d5c4784ecfbb1cc11f2f01759112e77841da9c42a2185d03939e13b8cfaa32b1919657bbca26d6672311c4a84f34138d4b9034e060c6232b3a84dbac87597d3cd53b99d2b142cc1cc73800624797919088f0bd2433ada82ae47f961b5a911c71e658c486a782934966333c928a358fdfdc98e1a3128b4ed3fb8d9f8a788d9c4a099aa6216d625515a8d9e092a4566d24fc5f20d2f5aa7d15115d6569fcf7a4224b3e3a53299ae594d0909757768691075a0707cbe463740857fcd20fa5cce09ea7d5b2e7849496e69a3a8e4a423c33ebd1e02926c656cf87337dfa3d7ec03e45898f42a54f6653a266b9b5087f2560fb7acba75aba784476b3e083867aefab14b95a0edd29ca6fc0256eaf7bedec9dfa9f9020d4aa1138f58b8c65be803f679c78d1170ae4c3b14c9ff2132619a3bb3bc551d8ba058a16b92095408dba5b2297ab85bc2fdd622e7cc2c73991b020a3b601097369be15a80fda37153020a1e7607d39d18affafb5226cdb1487d5dcd1d07bb2dc0ab7e0a857980704284d608cf42a218e02814fac934d273a25c5a013e3382f2a44e5058299bf03ad4b9ed2fab2d6969e65e1d00d0d31ffbc8dd448dab303c7d48133788af4f4dcfd390d829591d24e135d676865b63979db367c366fa2ab81dd59521ce5be86f0db7fce08a8dfac40c5d3490496e772ea47655282c20b071cc1d019e9beb73558e848f454a6fb058fe262f74d06e629070f76cee03b5bd324fd3b196df5101bc16e65705ded1c259ad8ddc78ba5fee6392387f888b1ccd5a3f91f7f7359c6bedcc2b5842b4b710a63c69f3cfa04a712b65778cef713b89662a457d7e77162ba81247876b115bbd4e4aa48fef31f716456df3cc46a4d1c97fbd749286f61d82fc481dab244e898b2e1b4c82828337b331a7a4bb3720bd35832b2820d7eb54d94814f3e01e3f32e074dc4c3608ec6a5a3d643c9ed8c51b7de0086c12424ae5f3710da975d293bec46d258c2239e9b078340803dd3d163d5dfa7c889bd4ad719f4e89ec61dcb7c846b808c9d078063df08c6aaf11f976e302786cd052fa3990b4fdbdd666dc583d0c0dd7fa83aeffc6e4fba37602820965d82c14639330364bf8210dc6f21e1500fb9b55c50b84fc45956c8c721f78fb6e7353d4e770b1ad8a659a70a8d63ec26280460b489af30bc340e866aeb600e1d21b5dc9583c0e631565f0e5f3ecb2ac6f60b265a927af5c4f8a042a8ea0a8f4dc512c3725291d6bc0f4f67bb7fe73dda0d4975b329637293970b1ab915705984c7a0c1b13de2928641ee2dcb3a04f6ddc4a1a4cc3bc39111e8d624b86130e02aa709440fc96084dda877ddaec8e8a7d2db1cc8d6b458e5ed6305a004866d9b883777e8b87ecd09bd621cf8c24d9da6553e3bf8d3490751e5863eefd7026eb342038deb0f54c5418ae3670bc9de33c65f323c617a053e9e54f3210f09ce95c7a6c4e24f24fff4177b4c82033ff3c8f8046ea271a8980f0c52e06cfd8227de58378b6b502ac910359ba13e7acdfa36b1118a4a1491cd0d8ed94ae5ae103f1276888abffe46061f3647a1284c9bae0efb4108529812a5f569891ed1c2d89bd896e9de468b5b05d004c248a52117691c0e2e59846463c724719a18de2d009712d1f043671101273eb7a767e0a5bc1532dcd946d11760f79023288579be380f4cbc8fbf69273db6e69bffc8fa50f75d56f74b4f8599a9389686972893ac5a3193a52365d673adef36916392e4d0815ae5b9d12d7cf4b8a8cd1ec7affb967dcdf4a5027de2197153e3b265937c46ffdca7832c795e9ecb5adcd2df32a5387e7b6364f504ca8ab276a92ade352392ff7173e8d5973b6ceec23ffd074b7c2ad27ee0cc7b0b6a64113f6e1e9a28c3eaabf44800a52534e9ab37bdc90a6e5923074b5e3ee2013dcc43896d7980d3806e8c5747cc2910265c0a45997d972a13d3c35a0484eccf2e9a62792aaebb054e08f19a76d983b0af3ef1f43c9c34281a41c95df532006164de3b291cc2510bd890090a545e2a6919b7aee6def0d06f0d250fdf26e40aecdc0a87fb2aa823fd3540f2107b7f7b8dfa0cb8d7ef08d634d1a4d0af284b9107350d8778a66a0b782c0e3cce389d799580c0e8e72c6b160a765fd4eb8139bf5f21195e7ad4e6073bad602857f2ec69c5dd8431a58ee72b3b9a7f465a40d036d24c4f0e3197d1031f926e6ecb7779b98609389b9e0a96b2f4d229da039ae6b2d6e56304ce8dfea0f9928b7b31e8eb6801b247870d7dc46ac77a5e41ec7214e75acdfd68c9ec0bf2575169ac3d2334c739954be38c0efe4a1f513d831e26adae3c3372fd18a703d236e86d094549a4ddf6bfae458e40c95f3f54d4653c8bbcddf1beb78dd220c32b540287d45889a369baa066f8c435c56de34966ea3f685bc7c6863ef1627cb2391338e2ace06ab3a91047270c5c4df9df14e8a7a6ef42d188c48ed0d0c2f2572455d180bb303e47ec87a4eb9e91266a76b57eb2efc87f61cd4921eddf64b82c4daa63b1390818097133ca45934d34d9d5c144e9ca80821ea72c24fea9d77e7e79c5d54be3fa04674ed2597210520bd92b4403bf65944325ed81ce0910a88b62d64a3bbfc42259b3135fba8700414f76fa127def7fbab0c7f890da7a79e9ad12e30f9e06557a83db8b4aeaecae1509ad7461a237dab71850a9c65b280660835843792217d07d0cf1ed68e19ba557ba8816a15ce51f4a63dae8b18d54e6b0937ff9c28ff2de9c69eb68ab9710c6dc5513152334978b205cb3d50233d3c4d5f7f3101336cf47ee0f47ac6c546ecd1931147ebb3041efd2293fb0004f49724b90f557babbdd34148d5f2614414453ec2c4f151cfc6c3944bda55297af049f965523e174b5134cdda8f521b4e8ff79f1072bdb6596d90ee5a5dd03cba76b9736a4aa0ee05d55ed1785d82af35630f8c92be79c2deca7c3f6a22b81120f9c207cf72a3307bd09c31140b57d844ea7e61eabb1928a418682144762c2c9d3eafc66132f1e3daebb4b477dbbf016211c89d5610003011d454426f29330536653a09273f33137ccf37c7f9a8c59996fbf4f1c5bea220ac0b7141bf5fbfc4fb11bf087afb3314eda443638a0d2b3d54310aa6b48a655903aac4b0ab693ca5dca2e0f351ec63a2f3a29e7845db48a2d7cd7cc050f83cea1a43fe8145af0171cf10ebe4b0460f98e863744c2a327e6ff8b62b7f73160771c65d9f8a860dd83c2f31fc5c52875ade2ab24a1f574f243b4a3c5bd508694cc66df60cb3eefb63865804e5b8a50333c7a8c063c4e955610b18665b9e64ff84d7a77187cac1bf414b9c2e7f4cba132831effe25ef206e62bee8d52a152363a275d5f85a046aebd437f65f008b33ef97edca361a60b604f67439c0d13480ab53810d5af583ea9f379d1c185f316acbc820efde5c6f24e9c0979bdf6f052fbd31051c5b7e5babbd677ce4119a7922f706001dffabf311d6aa0c16223c249cf28d97a933de00707cf186837929c77c183354e832b9f0ad938acc11700c021db7a9fd3e49fed031fe818f4b8fc112adbc7a91f095e030d138070ce04670c17f9e4934f074da777eda5293ef41ffe565821438af5335b6df682074f10a1188fcedf0303ed04270f1945a46d1e2d2f9042e4e288bbcc3c4f636ce65dfddf14c08b2c52021e0ee6c814ffd2e8cb93e4e6c5d929a0983d036b6b6376b6d9469f08730ec87e9ea546ba2a6ab0a8f860eb2cc0396e3a40d2be0c5b3562d1676fb34696ee1d3885186bc213185143f90ab485fd766522246a624d11aec52aac6e6232ca692c013f5eefacd116d647e2b88e8965d6a0733578084006e63433f80c673b512c4b6b9b8cd455a93e403b68e03060587f072296790b5553074e14840ec8cdc11d3727b70565468ae547aefeaba3646269b88f788b816e1c8a5c3cda8e6cf35c4b74e4c86a2787f60529800c900445a2e81478528a3f9df81c750c1bdec9a3ad48ce7b4e56a8b1fd9fc9cdffd5844beb4d4c3c5b842f42580a967261b0af26fc5e52886e6cc4b4ba90e877c0302e041c3ad0854fd312ce5fe86184f0a28a7077c8f67e81f2adeeb07588fea15945fa4a2a50003cbfc828118345ffde9f2967382e8c56274e3103af4d4d410494e2f8155524aed7d084f0779470c4f4edabbe3eb5ceb70d14fe2660d8c039ae74d46f7cc9c5efdfd7e465b69148aad26ce3a9615491f03b1df4feaf1579f19e648d76eedadb31560d40a300e273798f5a56c55828b2c33aec5e5bdd0ab9dc8250d452ee3333d34141b348730cfe97c7f15c1529c2804585cf1bb9911f4dbca617ff43edb29c40a23d6ed81cb3509b0929024b60c6f9313b6ab294f8001d6828f22bcec7c249774f38b75aa6352c0d43acc1e73db169e94019d8ed95c43c1e1e15aefd3d421fcb6351fcf67642def82015daf27554e6c41a1764babdf9870ece9ef7a3a2aaf96f6cb36d7c66a0eaaf5eda6ca4ddd3c147186d7236e09904c18413d51e74e182a3b239f99ee77e8c31a63688b20a52e3dbe236cc3cacdecc77dbcbfae117e41dd31e36de53a801021db483afde1befc6f331a771b96d841c2ef98da1815ece9334c7a5d49beece11edbe232cbbdb1066a203113315aaf3eb5dab4e1e2fad99fed0bfbbd5fff411973758c0f3996cef5fb5e29881051a961f5a342a78dd846e0e178f2d074a055003a05d4e7c360363d246df67adbf61338b1178eb669c5acc9cf186e7e4cc488f567fbe1d6cfcdfd9062c2e931967cbca4d657a4d8d2d4d204b3becf63b4190ea76343af2e297357652198869c7af1f5a518274e07e28cc8e1ab48b216e4974ce72d51ce7a31cfa0e30d8c1b56d7812edf9ff840ce8d711d8f46d437cb28b3aa502a65b583a0d4d5f34576f7ebf90dd416fcbc3731952f7225e7ef1e325bcd4f2bcb9c3732f9f2bee880a0acce87394c1cee9099473fcd1338d858fe55522cbe7ed89796ee788c742eed8089b8367f791ee5153012e5c9ae85325e02341cd9239e9d3f7d851dc08a2073565c73eddfc84d85809095b7029eabc58cf59d8f6d5c0ab22cfef9a1dac9a3c9688ac5f69a4350f2edb2cea3f45a36a823869d0fa4ead485bbac7fef85b10c35bc5c65f4ad523bcc027bf1b3b11055d75b09909b7fae1def38edeb6ced5adc4537ffdc47b6192bf4ad2e87f349a9b48f791a5650e887d3083b3fdda017fca5f0f24014070ce350f841d0e7e7fafc2928096b819a6adaffb682646257b91eb607cc6eaca3a41e26dde578c27b713b23be96979db9ef43599eb37cb21aff310716ca3cd690a974a2a58d63b224eb315c11434f37a316864bf0ddea4de009609a71cc729b62d523032b33a3d504158e0a9d7910068cee17a5c513c756d87f37ababb236b044e4704c4b26f4a90af36f8af0e3d862a69ef35b369a268c72f84572917823f680a0f9e0b23b86bf7ad20614054bab413b2bbcfa6d2313cc66bbe17ff7637e20812b7ec0b4b7a5c98a2c5e033327e2bd27697024f41615b235e88cdff5b521db635bb22b23386726f0bfd4c893094237d97f8b18533716737c171214ff0dc4b89a8e8b90cff3345a0690ad6d86539a659675aeac0f450d2daac2d674598d4200cc1a69346d374cd8792ad44244069387d35f68c5ea0e2d90e572b4223efc88ea04d8c117c9f7cf62574116c45e439bd45e5cefbe01cb93677f115ae39d14925516747321f4ac9c8b5b5483e7009112ed3c30f81a3e3cb486f5edae23d2e3bffc8964dec77c576befc922148927f7b220d142eeadae353d51c9358e459773a73d2c2ca2b5f23be6fd34dec58b35504da22d9f4bdb7f0bb477601a5a7a85d388c1adfaec79d01275eb17aaa5f84e425c35839d4814e03cf290c086a2ad97d9ac207a862d56311a648d29d88cfd306966916face81e699ffebc0aa967da85712590cdf7f7a994d31831fbd2b1dbbc23d42a5f153ed1f110d8d39272fabe16cd634b52f5a3a1f4f7da822e672354939b7c1254ba6423af992f6e81ff57ca4b6636c04af6fc5caa34ad80f7abc7feb833d9be65a97f6320663abde957c01c1b9ea8a2bd3b325001a5caec29f0f825e7b06965171582a1f3c7473ea3d616ca4c18753e76eaa274265553ef8e165a1abdc8529dfdfad2cbef1d40d7b99bfd2986103db1a8dab66e3a5b160501413d59830e82c0f7e6f73675f7c8f1bb1449815e2c24bcb0485adba1a59720eb09477ccc6a0e87241c649c5de4d1f43970","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
