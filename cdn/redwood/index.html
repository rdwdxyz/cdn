<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9071a81789d0fdc11364e72f13fa92f42409c9ca089f9d7e42cfd0ce684527f1c726d6c53779b77e7b7c74e1358ac1c1cae650af5f9ffcf0b2526f35a454172dfe4d2e58bbdc083b9c13888eb83942ffa841c52aa4cb34b6302ca1e57fceff56eb9f14fae053bae9d9cddb414f8347664a7056e6d4b067ac22f6f6c98140c67683e09c907f99680e367b6f5dc0ad7871bcb3020b21c441468d120c820fb5d39017d745e65271d8d39762a3e9fe641195909ae8c8fc331a9f04f8fa079109a612c47dbb1430570ac489763019f64bf8558937ae3a617d7e4dd8dfca4bab7fe76bf4ab6b0f3df25c766d11429ecddc367aa69355b5c9121aea6cb79ac9e95bf225c5fec4332d7145aa19c74b3b7d2fbcbbec13235b72e6cf6b68e6341367014c32465a252e7f7c34df187ba43ba6944e86302137b68c8030cfd99cd9630d0d6eecea4b05b2ce5850a9b8c295fc4737e4bf5c3fe1df143f2ed22817ed943c40ef215df6e4967181c4001dda2f4b848630b7ef8ad07a32e8117c2d10557054eeed7b3f3fc9d7585af60dbbe2978e6d1c98c843fe52d3ce886dc071411a8f404b653eaf911dc263b10b9d9c2f6e2cf9c4900f87f46b2fe2a5fbd3de1dc96b5d2d8b2d03d859519cced7ce3810e1e21f3c4e75de07dbc26576e16196d6ced588f67a3f0e0c669bcd032046e2f3d1d64b1b2cc96c2c0be627295bd76ff40d284d787c3387de7e1597a68f229669528eb8203e6507912df813c192970c6ffab4be36cf7b6f587197c350ab4f3ff8b80f8e0671ae7d2413f995466afbe52d01aa9f9c70ceb953b7d1e982a6d84a028f004dcfbfcec43f5b0be10388bc2b956abfebc66722ad38318098594e2dae63676cffba06252b4053895afda1b2ec399a53fa8694c794c551b61aafcf8e8c71dc8c59994dd7eade79fd061820ea83c2e2e2e4abf81a392e995e1e5b3391ed9b18cf3dffe85d2b1d11e819099e91307378e76dea4ea4ebc70966d2e9af107ecfe917e8d5231e05cdcb61b5d689889bc712da04b4f1a6c4550675caf0a60addbdcd701a47b061c54f940066eb3e51cf7cb612f7c3fd3105fd816c8df3b8cab582eead8eab944f648705a219c7d07cd90630c903baded21f90f5f9e09683a1cc948da3fc2319476eb797a378693101e34f2043df718cfd71ab5302dc9638ab9bb923d79cd1dbb216868d6b400d9241911e35ccaf2d4b66e5691f815992c6b7d72dea270c6912466d03224efdfa1d3fa68304d16a0c6d9ad444a9775df99207d2bf6c023c8717425f652d80340fbababfe003fa3939d85b2f996f4464ef450b820fa01533b06da767054da476183847cf98f52b388af8435e11acfda82474f8ab48cc785e6313406e0cfaa07b801b9c7bc295c5e6021e765d3da497566e863f2e2ebab9e93a8322aebe902d89772ee82f3786c7dbd01b714f40e97a425ecff265ef50447faba9247051920ff7c56c120448e636f9bc62c42d9e0781cad5a3875dff2fe84e527b49b1caf7cb6c5a526a10a70fed29aad4e436b3f8815ec67ef640e2973f6ecb738ea0fcb969880344881ab2df98f00e764c6d0a42adce88f2b81a3354b1e04e634f245a8c3f9a487cae4879b17f2eeec0f39aaf4f7f89730078805530fd67490f5458551fd9b43c903f66161f6372d8ab7d53800477725f72a353b7b43aeacbeca8b244211b45e9dc535fbc37d366298419e18a9aa62c091efc4b2ea8ab405689427e14e721aa8d8678de980e78f7eb156ea3733f78d15d6233cc4a5d5fb2e6cf18ec87e4476b90f7945956415b2fbce3f723f0cc9d8b9b78d61dfbe4a349f5b7594bbe88b6007ad03e2637ee4a5ea4486415afd86048c280e9f80823d5c38a470599f4d3cc6e5f158cf40cc97a50859cdb10391f7b2856e457b66e4e4baaba99db215fa6966a3e532eb5073029c10f2518ef893cc297aca0e09e52d04722c2e86dee42f696a72d4892ae054b27c96273ca1675a33fb07cdac619fe41a5ba5a7b0fdcfa57959117bf5c802d6dd7903e6cba977fbb8a2ed193f53effaeb52ac108ee749fbe9c1b7b0b156a763c06805247776917e5814048fa6b29ef782cfd11c19bfccbdfe0d0d4d42ede0e2dac4e5bf77177f5d1b97224761c55b5bd00465aaeabf39a40a213f1bea0ee69db471c8e5d1464f2729e1812e7a21514a59805ee5e19c9f9644bf2b4157458e5978ea39c57817a60c39b5dcde94181cbef1dcff1f98a79fa900066f5da20efce02ea198f5eb35e2a601eda3c890bca0278ef413d112961e69529e1b024957ba2f1cf4ade0f3518c643ab833a3f8680205cbea8b6697a53f75dd6fb89d57e99fd5ba3f55b656de69408d62f59b9f223699db62370351f1c879c048d20d23861839ecf3bd0ca6f2b9a4649e37c0e17d50ad4376e75965b9d970f8943f0d88450bf462bcc0dce5c9ea0c54bd3b00edc76d2695141b946b98e977987fb696a2a2529c95fb79a0d755771e3fc2d9fd84639ceecba9b2e37d10c49fbbca56ffb38a568183b47c21376806265962460c9da621ba142cf69d9a35c580d2a7cb99d479cb4f2ac5910c82bcccd107800fe2c7f9eb8c7fbf8f4b7844ad87977458d1d50831635757329b197d327918acfebf1918565ea3920006534626b9e9d3055523c6d819cc7782d8243753b62b27bb51c7c39f7c65dbabf2ed6cc9b3606e5ff7f2905a525ec063e2033a7dda074b04721a6eb109e7a2a1e15ad01d761677bc8d3975347200125857cff4d975d0665f8d95558aa6002dd6deec2bc1bdefe81580a7c2ae47c6c0b0df93a944c57cc5bdfde20af3e923f2e56b1128292971202bc9901f96fb7dfcd89e468e8898fbd633b7a5dc2b23fba412eb73270e6ea791cfcf7ffa22a893e7ab030a2d35bce3e11194aec3e5f2e8912806528493d10db24b8bc10fad178767c981b87033bc7448eedad4acb8a79d5e6d1e5130ace16fceb45c2bd72798e2a3cea598276c54aa25c2c4a881ea06aa1df0b79fd7f30c1171e770fdc226cd0f0af92d577cb99993c56248ba42915b395ba565faf86b3d75703bfe3db2cb62a7c30828723f1bf65c5245f8cb8d10b061608fa94cbaaf813588895b1d7ba26b0d73ecdf902b0b91d79544646efefccf7c45368f4d8c8648b1020f4f66717c738ff69664a8a2a12ea319569683d0c52de483cf4e90cc2b74ab0393a67845b6199bd150dff5c193f80dcf513f7438f69a8560c96d6e97c42d547ac9ea292ede2dc33602d58a8096c4c0ec6216f805722ba052388e9b3f7c26a66afe9119e884eea68fe913d7a4afb2e3cc79610aa09a4d03c265af0a8002936f523b17a4addfe0605d865eaa8aa6d90c8fed14b8b1efd8620bf34a7591af6341fc1149be9d694a194cfb98fa6b11243a6e8afe216f6151ec2c65684367f916a028e2344a52c0173e82e3ae4c3c37ffa34aa60683660a2266fc9231a07540ab5a0a4d69c976254724fdb9d76d908ed2583f2a152f0d9a42ca3e54a2714eb7c7b2e18f3f23841bc22404d55be233210e6a55eedbadb8c8d7bfbebe81ac68b8a23825a6722029c9bafb722d3fbc993496e41d4880a4bc78fc68c02f1cb61beb21af966bcf8b3b41385ef15824d397d345e1c9f4dbc1e68f28c0e60d224592419f21a19fb06b34bc39b87dae6c4a8d89426c6fb520bf03c6d36549baff3f458053a96e4e31bd461744cf264d509e2d8d39db8c5707c0c94a61317c68d68eb9001236dac36a7fb50d925559b04455f5b74245c4195b398c881c5903df2b1db9dc13254fd0c34264086b705e014172f99c528e247e26adf00279bead9d3c6d19c0b39f1e62cb28458cb450b0e6d41ab9c7159a0c08295901e558494db03c9e8f76b3457b1d5c005474a9f1d882d593c9c49b4b736c1d19978a5339ec740aa5a4347cb5400e361bd8337cd8acff227da4487145354f62565a3ceee7d2aa27817ad2799094df1981638b62a292deb218ae73d1c80a0716d86cc01a9ac3fe7e7ba7c352375c10860c811628badde5b2bf4dfd974208355878b0c711666edc7203e32816208d8725b2f97baa6184e3115cc29515f19b4fed2d0fc75684e674f1698352623d3efdf97a309674d395efe5e61a089f17adf539e6311fdd65af79d57b463e66315d44809d1a8c0cb08a282467a1fdc258cf9a2004752752bfd4b3bca56179fbac2fd78f8a785b2ee7393770269c37abbd29ac9dd34c5f104d5113c10c33c610eb1a496fc5af7e1624263174ccea455e6069732478c24fe44ee0071bd90957c0980ad6b906ac111dc211259cba2501e9478f31f3026bb15e1a8453a1d3689719403cb8264dc1b9e4643581eb871b80decfa26c19430f625fba47ef9cbf75fc3238ef93eb6f6b3b5700cc0e41859ac559e1d1ae8ecd0a89037e328bc16bde49ec2288ef3476d5e7a5c31b0c67e6089071f2a9958d759415c1fc9a1caa8a72b8aa8da11856a7a9c00e2163d41fbf13120b2147cbb409591fd32dbb78bb36773e400521047c9218a623eb0ad497423183096848090b8f2bc37386a5780abbad79f43f665c2b96d993b0a655c8e7c5dff9ae106f1c65db200e7ff6d69f1d19cf6277683719c54a87cb26a0f7f16a149af68a252bfd8c78b8819df02c3bea050dc8520ea38887307bbafd0aabf97fc210550f17bbd17df80662c008b1eeb77c98aa6cf5415d65083a207378032cfeee252c95b322188d0c4ca887874d6e7d708bf92584c0ffa7c94747ca20d091465753e82a01c69a14581275b23c1d0564c1bb03be8ada9d348f19310ba1025dfbe01aa5612ee059a979b315bebcf56f86b3b16f1fa7fbd2b8a5afcbd806f1391a67063210a655ca0c64c472d5503e668d9505fe0a8076eda7bf3ea9046772f9718afaa25081aaeb01e32a61906f5d7df2c875c8989d93041f59a474eaad0c32eca7a5e6de0ef37c1e03ca8fd75a5e3b158909a182912fed58fcb5d3b18b9f668198a0ca2688b8a095483643054ec4261098dcbe78e7858b2e2bbe2f83fbfe3b41717e52fb276edf0e5b639f4495e1f27dc6a9191ada1eb9088e16e66a5dbcb3d50a57ec99f9495f1ca261de64a008a7d2a367012ac52cbee30a2349f07ee484c3da01a2a14682328ddf86736b0719a5e26bc1cf34d517490169f45a81aeef5c16eff0696eab4cd653de2b0ae26b2602821e75d5156b1f7b7fdaf074500d16ebbc6dbba3986e2c8ece6ee531e72786984369bb07b43d41b019696bbcde1b5ebaacdcdb31d4fd21bde722bf2cc2cf3eb43fca6b64cc95c257fdf4e2dc6e247785498d6a4fe64a9745a2f098d392b4dc1ad2ffad9cfb875a2822854bd00bc124372b6bd4fae8ada373036602cb34be8a35431d2f214b493287da8964ee0e5632f1029d59db8dcd86f1bf7b44942e2e4d851fbbbc08a05e9e5def426ce9bf2228ee5af27280e40eff4bc487429e2307c8ab5f725991c792af040acd239a7cc231ecacf3db148d2c761a8c71fa926bed15006ba2c147d750860f2af92e637d9c6d0e8fb05a5b96bcf27147c39959496e98220cacdb9c42de204c087ad57aa20ba05577b2de9ce532b82475f8d61327397388aa84ecc796c079a9320f5e25f4be624daf9720c95fe6bac237697fd611f69f649512b835fa26ea31c7fa058560d0a92a37b02ebaa4fae44a2e5f5882a9958c555f4a61f1e020823034f6f68e28a230739d4a63a35c07bbbb3a6ddf70cabd45dcf1c56482b9cded8aca5e5ed87e62a15753498b9ee2a5b1e5640f51d700b292600d66effe06f08787c01bfb6d0af380089a222595e5097dfb50869e961dd2d48b94799c5a7379a742c770d3fd329d4a4e677774d12574deff8409c6e86778901cb0ddcfec59e2c778f654757f859d7e57d6f7540cbaad113adf315eb4278b9b4e3c5c2dd1048177c0bdc370cd4da6d210729d13db2ec0c3c5073a17ce74eed4213f5a3385d09862b00cbaaf66032c1234947f10cd4a76d45f8089d8ad07f1f8447ef45e5f04f1bc538763ab5afae7022bf2075b2f5a898962fea4b468bb162130167ed32c0e04225729ec6ad84ce14d5a1dc7c2c9f77426746c071f4f339d5a89304be7beb188bc6855769d5571094c88ec7d7b9f3684c04f3de9b8987e271a34cc52a3cde893fa8456d9807d4dc83f8bf8087ab005888b8672cb50cab6ac5a220a13ae3fd9211bf833aec5624e0b03809f625717ac63eca60913f3d1c1eb13ee4e248da88054d3bb785584cbe22d6792af2f479a1214ee70fe6bcd3d0bc20b60b7d39724e5c0156e8604298733819e7e6525e8a06e27ad78243c355ec502331c5eba71c5403b65f0bf9c1e7c6d103fb4cb5dda44d3e7c070a8b4f165c6329c502278805b2f649a17a6b002c7690f66f358e0df47da2620aff17ac7189793047830f7119ffbdf746c3991734f3f3252c14d952c792e40ec2ef8dc0f39a832811a42a32f88a1b9e68678ac91de9a5f2e9c670edc53b3cb969fdc42c830ae6c6f925fdadba6c4eb489af262a193eb7367ec4b131b13974f72966ba70085ad0a87259a7ab83c1311ff4e07564f0366466f288c9d1fa5067c33bafb0938d090e1d6b504ccab3a7d66c6b2d07c2d09b0d749b9c321605e20202ca90e89f025dcedbcc84b29663d7b1d1b4a9b0faded57eba1c71187c69a1e24d3c4907c688c824f8df02f66975b974e5e27c82651e17254550d6c93fa626b87f1157e36ee0a8a2114762be01d64a0395fcb2d1beae59542631154dae21e138db117373df846f3166b03706e64609724abb85ae23b21b28217af13cd9cad9a31efefc63240d5c9ef2d3052b2f130e7916e6efbd7eebab795c7863c081613570818906aec836bca59a47cc8312954c01ee4a97371749fede9225dfbb83ba753745c444b56bf09da0fa7b2149734e5d8d7fd3f68c0a46d01152fe7170b01def620def240cd273a3a39c138a4e96f80bb450809b80c2f6d7ee427ab4c51d21a02a45bac48653c16846fe90990a1ebedd2de419ee1b46007490a9aaadede59136b9eefe46fc72c6b079817775942733389496ed1e132e3fa1ce90318ba46603f3729130a1064b7f37f7f374013b3781109db807d14fe72d4e6c96eba397693123d99bc207ae2e6b6e74b46cc0b8084414735f15a545695bb2d46ec5e7a3dd3f5069f31fcb4b2702c750472170b0275e2ca1417eee8fbfca554d85ef44c83b3b9a334fd7a3fa98137d3629476107f05b4cd132fc8e9cc071e13f5e12c79af4f6784421e7f2e7bcd411b2088c575f7fe1f3a8ad13043c9a8c4d47d8c0d28b727dd3aeec480f1f7dd26717f36e85438e5b8b1345753d91f064777265eec71f7e5aac7f20f3e761c859f50db85116bbfacae4f1d99febb25895c5934474f171e19c8cf4cbf1a5239d5b17b95e53cce335cd58bda9b656de70920cf082d24854e7010bf60a94d203388c369b78289ed3cd640caa06c0226bd6fa29ef444b0736b2fd54410193f7472db646c15a11e6afe4971a38687d91ae03c399347f727a6bf1b16f151e02504c7df178c79dd66d59716f86c97d9f51ce9371f5eadf206b1d35781c1258bb3cfe31db86bc2451fd5c0e5692e9ff83db91f376c1912b870793bd53e0afbcf3f27a586db8941ba8628a28e401ecbc31368f5abbad78f024756d3f7abe80090b6342120ba6cf28981f6912beb39eb57dc7ef9f2857323fb345d8572096ffec1c131f5b3bb388f859f9ac4095c65e1e0a38cc68b2d4ffa5a2cb1978d0df646ba4a03ffb7b770d211e869776be78babf38927d22cd5d1327e0f697be07ad6e4ae872f9758ad954bef27ed9242908aa9871b7809785cf7c56c713c7388961052b141d71a99eb37fc667aa135958146645d8d95057df1e7983ea2a3bad4891751f2cb91d87db5a517fedf2ca2ef3b81307b66ce1f57bd568839d9c16527b448a3b190ce43987b1268afafd7e9905bc9ad3d2c36a26803e560aea3f4a85fbd234fbb7cf5fa7e657a234c1bb5b774221b8546a00e96898320071b502a74d5b5e4c3e0a86827147f6e7cd64206f3881480ec3be5636c824e725dc944effb125e3798b73b3764ff2849f506d1f7f72e2c4e63419cca2281ee666562482e74f14c506d51ddbea2da18562679286e88438a33243e8d785e4274921eed854923f091e1cd3673b9d803e1e2ad973b1f37eda755f776ae3ddc69aee8ce2859063d39fcf65b4452499457b16a66412471655a069a16c1885345dfc9d5e61e78893cbbdadafcff96bc4fb42b31151882e92865359b6297b59ad0467466bc36897ad1306ffb0558e62cf95f1ce28b452364bcdd6d38cd53b806317e6fcdd937103455194390eabd37104b8e1bc14b51207e31778e6d1f33383dc74bb26458940b4f116d3ef341e765b3c500d9cb031bf3ad75d3508c97b1e475647b9743d86ea710dd4c672186a50c8802d6160e6a4b9a3ac7b074e2b09e9a335cd5268e9bf75517e2c41c62016d7a050cd30d1315ea3a0e963a8b94c613c456adabb889fe0c43199e147e654a42504396e255235b1b56e658e67ec7fe5938fe119e15909c5c27b3e08c95b478fb6931cff63b520c73d462c178bf8ea79c8b57dcddc309f006f50fdc241563af74141e1cb91665b00d1108305978fbfbd9dd9694b37ccb550619b56d9ff45d28dda089157b8ecac5002c89ba9a80c62f6a89d20c0795badecd498827ee3f48337326037453d187092c8cde74806fe2f39bd95d6600b7130c2e71fae5c32e71ec72a98105cdf4172a8db4f15ff96591d32f02acd4e7f8a66eeeded204129e46a01600a3c2cd1b8b963184d6746befb8c68f4dc8174d2fd63bb0b6fc7e40ec1e30d68f662f7fa37a098ed9ddf580cebaf388e6161d4ed00a6af494d9acbfd371cc748521c63e18f2530353d1560d2539a31bbb14b013ade6ff88d1d4bccb9eaab01018168240dfaaf61dcd017d611c993136196330facfa133a2d5a63217e7bb465ffec50feac41caec09809ff0f6afa20532184fb50b39ce4b2aec78ac4065f2ebd248ce6049a0c05369d474766c2aeb188a1620a6ff416faef7e15b2d292e3768e63deab82cb266720c93cdf112bd6789edae43c1481d3fd072543f7041435dd5a2ff7002584149f5489a6dcbcfac612297577f2e111bf91a90eb66349a43388beaab985f5c97b6e93603ca00a3d61e218ea4076d131a65673a8dbb7d4a28775a9484a3b2b2aab1e32b3d50bb2ecc3a4c6d91b0f176a3da4502c6468dccaf5521b6ecb5df8e37a5d193df6ddf2006fea76dc2591149c2df4120c82a6b57038af296e6c5f6b7cb3e1043f964234a013507a26b0d8255243dfafb8cd797839465b5815fc6b707a6c1d32009c04e4d05d781813faf27460d0de81e9cf747e6a949c0e5080fd4e3fd8c5300b846103e8959b211a8c02965a800052209a7aea368e748dbabea50761eba9c3c55a8d9ea9bf69bd144e2a8b353c15f353014bac28fb27a9e186b30680a6d8eca3038e983d6b0af8d96922cb46385f0d11f1cab786a8b804e66387a15409768588c326ec2f7fa0760ee1770ef278cc58b28777f33ed4c9dec64e3009ea5982f09a7cc23719ee79b646cc8d711f1ae4dd102655fdd1066b7e088646a2e6b256f399bbe8437e3303117aeb0c028207eeff44e964cd0689568ed405490772eaf2f53c1575fd300f16958d93a6878c4f2109c3d2888feedd8cb4c0b4b3c56627bafdeb431592b0e49bd4391e29e7568763a98e84415b2a806c5ab2042e281bd8011d2a1fd3ff6d2fb93875671434f12f9e89a3e7aec4ebbf40da0653d022367c39e53b7fc7e446346da278f35bc4603a538d4dfd6150dd726dfb17bc2c5533a4c7c116934f083e0ff2b19b63ff4f8651b2bd3b2459cf57f96d5924d24047255630694ba6bd2c940f75f34b22693a8fd5d928fdc0fc203ea5596f7f2b0ebe6724cb12992bee35c68ebbd334c596b9339cb790f2d0f272da7c4f923bd5a0feedc260bdea334d7e5ada964a1c7c1497f4a1d583ac048458431c3fb7bdff6c20736631b3d4f65fdd023f2201f2c67647b1ed15bc731b21764ef8f6844c278660fb9b733152d67f0cd483ff0f00c9c8a2689b1b30631a42b089b4551c2d5b3b9ac9db28de4c2437ee2e5b8dac6c536a65fe92281d8e8dadf1b0629f6127e6df2861f77b3b30466266a5e733a5cab96650b728489d590b2ac299d1f4c857731e83e12b50ca0118432011a936465c028accbe20071be8b8c71e3bd06cb8e5ae977565fd5f35189061352feb2de4c5ddf8e0e830f7d5bc0399a42a21a61dc5c16b90f73721a6bffe767809f2e88986705c5b154459c6da6991a52248159f23611afef21cb42b3a957d6ec5002bf39f8c5fcf4599f674b1e487e46378e2619b3f81d8be3edb0b37648dfaf7934bba875d10fa322780ff75fbaee321ac0e133cb17749b1e8ce9388e724d23982d4d26c282a37a2a9d70baf17f5505b1f9d19779bf373dae16c1c435ac1258b5efee1f52e699d28a7ad2cb244a595d5fd53ba67706d1f704579d7af77618beaab63ebc55cd7a6b8fd3097cd2ba5affc4fe9adef243922a5f7f939c9eca4d9bfed34dd1dd1b6e7c34b4405f289f455056817c7fa72018ab8a823825d2ed67ccee9f0041c96904be31642104498660ce9f0c6cb3c411e47c97d2dd964159ec605dae2572b0ec9b050de8cc4e95bd35619747d803e93e542e77876ea79bd3ab38879c00742733af06365e88887a558a9c6040d9cd861fb05e67d76cf1d25a9ec246e33dc7c999ec4746a052291c30ce2def463a88d64012c800bdb3ab548df991abf861e49bddcda0ffc56c7580d58b61177e1192bd83e7678e0fe3350706b784dff59498919b8c17429dfe5b2ca3193b1ffb3eb9bc83af3d9a74d8d17b904e39a65202f69b8354d6038a83207a120448c58a284f27c87fbc5c1f3c9583bf8e7ce09c5fec615d7ef95f295a34c027f7ce1256716d740bd67247ab96993692d067622f128a22e2120c26c26658256a72ea0f842f567a73d78e1f2e31e553186cb33f2bd88c98840e16ae480e913f3759d76c03d8d9822742d174c1e1859540126351294bd8c9b1da51cbf69b8c172965786fe26b1fb33a086891f0cf561323dde91c2f474f1efa35a3f8656a3e8ced4cdfb5f88c78d4bf289310e58a537c254373c0a92b1bc9cbf7614a144da9f64691c537d7692b8099824094acb0dfc1dbf9540fd369f0044b6d697bb4ef331900bf78f558d2fcca156f66de591fcd7ce838333d8054412780caae618aff2ad21573be347b012e3ad4953ad3ee5cbf5cddc68f9ae810ce1aa02be79925e6bcd10f3bf6daaa0745efa89e35aa88756f4fc5091cc8085af2c198cc1a6efde432114397070fe9ff4e71003f3fea541a975613a1db9830d2e47a0dc0852ba2ecfaad558748c8599b2e7304fe7323b1340a61ef22e48bc1445275acd966504b2d99a038e63a25453dae53ba9fcd2efc4e41e96ee4318c92f73a3319f992592bb3a8c048cc10dd24bae17092b4cc9d601156e5d41d2b7453662835bd5414277e79d53af64a7b2efeca8f73f864b20bb2b3b4bb2a2f599c44446e05ac0f09484961a14ff870278d9b3e92621b0fdaaef1fa7d34758345e598264c86a19b694a677d6ea3daa9d3e7bed9758c97361a7a7dc4736168fb98d945b0ee434b1aeb5515510f93c8ca9f3b0f219aac537b7e0e840cf1944523df1e5a059333ec2c723969fb32c3510f69f60108c3746ad36de7d7c2a6d80e3ff179cbc40c3800ddd3574cafdd486b836e3fd2e3a420987a21fa912c045c9f305d8ab31eb1066afb493396b992dbfd2285f8bd9320d074366f332563742814b644ca7e899f8c3987e0bf14532999684657176d841f21cad1b51bb07170c76192798fdef9f686d21da67f32549455a23fc134bcb9159ff11a2626600f1a25591502f99b947410f1f0265523d3daec7bdca5ec0db32f45a1d63991e1eb23eaf755a2770d7ec4ef9cc8a91eefe12d427d7daa0cdbb96221cb8b62bd19e7fee3bd1b43c2ee053f783ef4ba9363988dcc04453bde72c04bd9611788b5b351ead7869c7a56d5760e2b67a92100162ee0a37d99b6280c192e6104217515bee3d506c00a5c101044ce0189c43be9de5bfb80a56c6f2416f2461ae04c6eb161a45d2b7b7b825845e4cfc4172f271e7610cfd243d172241814f707aa4c6cf38f990628ff2f533603d17f00753cfd00020985f1fe0e03ecea0e4e52206a2e7842c8da2b186abf28611c1ff5b88391e5dbfc62b4115dff8bdc1df620aa6ba08a1ac056f7602208ea62fa21aaff26ef1e3b2c0025964c93946630636e7a19c20a29cd75913374e2a187eca7e3dce4585ce93d19d2ef6520873732fb72fdd24968636f01c3cda5a94e5ed111b4467f7c2d0d0bc74b9ebe1f85e96e0a86acefbb24fd974b24cfa477c4b8184a5daca6e72508ea106af34dd329af0c787e6068086a962cd773e8f9de5f036dfa9b0e7ba97c3f861540be65d7b9e6033991b7b15cdc7ff5eaf8d0d8e1e1e367013d171c48494e665ef26b2ab1c87d73dc54cd3e3c077576c78c607783afd26c4221010c8a54f0ad50848e19e130550db780e344311d845dd01be69c9101917fb1c62045761cb46063759445b6077b4f4d16786b6ab59e0d32dc167b4733b2379b9747c8f930c25c267f1a40865d3e9d81496228d5b474b919446333b935e6f2576acd76cf13cdf4b513b1b9adab0a93b9025374a08ec964b49df2969ab6de25e164ffaab4ee3dad193cf8f36fe6d0c00c6463bb3b6cd7ba58bf70e3edc57c4497b5a608b6bfd906029cb65aa96b77e5c371eb0749c9edac6c2cfadc3583a86fea347496e6024b56cb045ea862c5d2064a0c733c93dd70979c9fa534abe68b553b83489512c393a8d84fba072dcdd3898b38f0fe04264199551987903d38d190061d7e11aff79fec340efcb8d83bfa50d81c39aa16bf695fd9bc1935d639a548d3d51e0b658eec31f658f882ee80e924acec1fe73afd5b19374c210839f3299a3a90b0d30fd287b59ec62276604e0a7a08a1422b9f0d59f450364478c71785301c7926cb14358b2a04319d97e8c64d774b364acab6bc215ffc80837ee44d4eccd14c61730fdce0543e7d66e59e67d07729d5239ce0aed91d0b148140c79c7343eee36d64b07e7670ffc75b43cef89c535e1b46c06829ea333069bac54a5e509fd6262fbd728e44b6cb33d0f47e870f50faed95b8028a53fc2ec1750bf0de309ccc9971a7b2f60f1e234631879d70ed4e766abafe70faf49e1a12914632fe33e0cd4e768808d472aee1175f22808f3e6ff996621b2ac7f46dd4e1dc806896163796a8f4d06e96eb33600ca4cac283bd1661e6d0d8a68067032a2b6d3fb06c1b847f9af9ee5b0fb67d29b69ba0a365edb330faa66c64182231cb536782c00af9180cc22b9b05eab3f67e0beeca24c8c901f249b84caa2fe3f0988ac2a75b2cae0e926f310182f3853bb0e400288200e88387a7ae3762b1da44423bdd5c75179c0abb1cabbb2059f1ae6bbcdfd45fda2daf555d5bd3c6ce77c0bcb089f02b0cf25ebbd5fe65d11b7d72e070ffe560b420d6962b2816f4b11c40a8270a3bd9ccec6f51e4781fac3c1ca68362340ebc346bf862febd66799ed406e782c6da5f4b9e858a125d07ee7f3d4e4cde3c90706d026ef739b89e113ef284e042f4ec8b9f40fa3b6aaced3017de395699cce7ce261de402a875beb9c57f866d2f916cfb06e094c58d9ae5fe2a5199eb4c11e6d569c067adc946f338ae159e4a2f75ca80f77890a3685ed514ad1a6fa36c8cb31e8b9b613021b8d9d278b80fdcc92f98af41e9361eade5e81a76bcb5d49433f80a588596cab95d72ab9c093ab37a6bc727e1cecac7d50580cabeb7607aafc00e18c72766b57ba0b1662e3d01a0fc22f4ddd417eb822869c4616b8a9ec066e7680c6f7e2a0ba0668470125e2fcd1a31a680424504b57adf633d8a3ba69cd0edaf6c5815efa4c92dd217fe92bf85947a66bf9998dcf4b5d383f9a5cb3f18851a3bb5673d8336ce1243b973631de33157609e13c8a544bfa45c16acf1bbad75cf12a957aa522331ab93ccf2d9953bdd63498824bc3fbc273db8799e4f87ee2703945eef49fb9e2a442a6cd0843b7328a20d380ec6f2edd3468cd5eb46bb99cb808f652393465c2c4edc6087d30f55f1296e30005cb3f8c0d0773bbfa717e3b45437ae5f361b69be7047418196e745b8c14e4d13d693d404a6ceed342be3e0901321c74e08b29ac90af8b6ef6333274fc0d70d7ab54b1e81face07b3d3f3e1eff7b104842842dcf90dc8e06099c470606a6332e1ed46a02412a88fdab746835bd5f991c741b6c40f9a78f1c8f389cb1ffc351240b5e9d3a7265d075432e6bd49c8c8553e4cbce5a29e0af7c518d834262bbe96fd0a92bef71d2661cb3fba93fef754eb32eadd1d94a5b9bc026ad4e48603241a17e24fe11203424669adf5c9e9e7112f1259b4f0bb40eac7263ed341bf1979fbf03dc8669258fc501e5fe1cc4f97f4ff5bec74fa1009d7e0f8b27e69e7088281998dd1fc60d07ee38e8d26836ac67f8cdffcac940564a84bfeb49c335386b9993025c27d7d1305b660b81648816d75495ffab63da16334b40941af56ee6b71ccee9c23a8c7d18f1991df3049ab5b660082b6197c78f2e49bd19d4b62982851aeb712a2f31f560c4a39ca2bf350d86466b0734d8d6a593e11c1337866c3df968a5018bc3778576ec3d76c8ce212a102574fe8b776c389e6aba865fe23ead645b9d24e7e1ffc86b9e97d8d518b1b6613152fe25e12ceea6481c9b02dfc8346c62c0878b802e5456ab44249f904692c1cb8a6dd1b0d7f16ab934531946ffee6bfb596b824aaa28c03ca80e6cf3752e99dd0fecc1221dd152317b6055803fa54be55e1b3505bd616999b2a24e9c4064cef9444af0c5a459cf17686c54629052938b1f14d2d8b9e2e6de4fba5949adb34b42d6f71a37181535fa831927246c3d5a09a0bfacd0ef02966f087d8e718663d6a21bf3460bfcfaa2df09586fa1cb883b4e5a32ed91512ca3a2646c464879798d0824bb5a7595ca49eb74de5c67c3e5e25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
