<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea55626cd47bfff95de2457d4968fb0e6f6ec492ceec28e2ab300045a616d99c1cf3ef64622fa0355a9f7ff0c09a62ef9a67520a3bf24cb77066a24940579f9cd817f98166c071be0cc6fe77476516f360e46246e8626acac02f65a34f7475e514df5ac40b657ad992feca56e6167e2ce789ee6614180a20fbafecaed181c9e59d7480da971156c093507aca9417d50b54f2ee4e737343b0a5256339d411b6f99ab03490baf02a4d6627f72ad0f6b826a43adeb8bf726767cea28437627623f6a4ef058cee5ae102f38fddcf0f4e2f5b77e22386d4245aed39a5959e748299827c55b29e4b70cefa095de5b198fca5fddce4a45517d166f129423cdfbf2a80ae5a145789afa06e5d156277edcee376ad2d050bdbfc1b818d043338cee108cb628e854e23231b5ded2ba8469aa276ac048c76ddcf375a0b51b555cc745eaddf91b8bbede7c0d20f9cf80d64897362271d220f37013bfd12001c34d27e96ab04bd88f26bd229761aa2e2df8c2ff6cd15a5fe3a9c30e2e4313c8a71831edc3a653b6a8b75c855a0aea8e5100915c897bfd84944f9283c604cbdf89313aee734d24a4a2e970963af05fe8cd0f35f7e9d0c6b475c67f4531878a8dc5bf7deae788a6678f890d5597064ab0633d1a24d51320cf688ab1d4c9aa8f43fe9c6ab34905446fbf642c302e4c11964be9df13b0664bdee131ffca0a233cd1202a706b574682060bf1ed9b490ff11557a88a51ef96106d87492b69e294a5c9565446ec225e61a44ce89c5b4f92e39dfc9875b9cae1daab3540bff59c899d2ed0a972dd2c2664bd27819c65a70e5f9e3684da4dab8b4631c39504accf413869251af1e22bab1fe1bad42ad21e7956367a795c553e67884de936a96587b810e8c629f6416c52fd7e88609a90b618ecd7d6e1f8d61b3ab1f4e27679ecd56fba3e65db65033a3434cbb29b95d1e42d70ba298d23999a67470e447926dd73ca1c43964c33aa6c062197791178fffda43d29050d7340947680f6edbe6d87094065671918fa31afcd7ba59309aea0e683444ae82a94eb71737b462c39691e08fba153b4f94241c6ef08266617588b8f0826a4269466310d103679fb6c07ec4ff0b1c568879b910c90aafa468aae8f07f1d186541ec1dde8943768573ced6ee02f7d2c8d620358391b72879e1f8fde2c93d2e98c8a6ac8968026f9c7d4001ddb95b713ffe53ca103e52d1a54081dac5ebc4aad334e0fd73851d4f68cb9f378d030ad4c5e6db09d2871232ce7f0c8f3afdc979a86d78d516ba47667d6800a0a5b0557efe75ef2a3fa4e435555cc7ae0d3a08da62e3993748f8f4d6872a61ffe9e14d74a1df5f3982c020d399299855b951a2e35efa21a1614086a093539843eb27e83dff18684b974c1bf39b6a74e2b34e45ec32d49cd842e30486599b10b9515ce5475049eea3f32e7e80b6969eb5c141d567a5f1764ef3649456839bd86d2306fe756b68810ad76f8392a2ab949c94557be9fa05e5589ed66232cce4d75a4405cae87a12932b260108ffdef5734c44d7e8c5ce1e1678f3d79afbc426bc2421d6f260950f33b3fa0972d01e94fb71b3f8d1866430c3a9ee6888472a7a20bcab0715f5c5df4509ded131c9fbf6316d725807b465ff6a154587ca15db434b4d9e8d5f1037d1e57c4d564256fb06e1c1b2cd5326047da07a9107e5198e84e56ae07914dca87e046b64f08867209ec768c875aaae60c5eab6cc8a289eaf5cf1bd6db6d4b3da65f9b51ee1dc03f6756f0712fdbdb9240c14c55376c0b1117e45b041167c6e70c3092fe54b0e013366b4a3372f63d706812c3a3cc74f035ab837534ad2cdaf96a29856386d8c81fa0a2f74f04157520da06ce866c90f797b7f61485a4f4a54967c9c5f745648ddbefc54c5bdc275fab554d8b307f3654c7b48b99f93c4d118996f9a3c6343e11d51d76481e25391276304cba5de72c385054c5a50d999a0b0e36051f39c40e9b27311142d69196278c517b47af9728888ec9301a616e92c91da8bfac1d92c84a28ebfaf9d08f52b014f5e8906c4616ed0a4ea0c66a619202a78294314f608805c5df1b1e0ef5f5cbab6c8efc58ec39451ce875406eb31535278bc5ec78b577b520a7197f4aba2fbe66f6977869b8b77b604e719190c2b693988d2f474a09ce01625b1a557c6522fdbca0a3f3756f3e5eec0dbf1ec85810afe09b3386f232b5bdb0a439fe0ffd9bff62b0012a33d7014b5ae335768c9c60753713cb83baa8f41ffa4d61408d23bc1f280d395bb28ab1c8f97c77d554f359c95b5a30517f75b9781a21f92d7aa724ae0caf26c83208ec22225e6bee6cbb755c10b4faf3031026ac492ead423f7a388d9d3a7c0908ce2b9a6eba6fd6ef0db5295dad5f5161393ce1b8870e5a392afcf473219a723d1da4c3a738839f30ab35b4cacca10551e01869cd0a1f73efa32e34b72072c55cf9c4e942195776dda10bef11ebef976026503b4cd2a66c16017db8947bfd33416f39c14e8c22f494718b4c6904ca4192d3ddfea8f66c92b150031099a6cbe2cf28984c9fc7b1d98303e356cdbb1f09a1487dde70da8f8ec1d8cf1abf99af7a29a63e6e86567ef00a75ec4d5f4d2c26b32a149130ffdbc36bf8bdde3fab9ec907161252956438f4d76998dcc3c90f8b7749daab27b599ace0781f2ec9e5cdc5239e6388e827140eb275936a8b8418df1ca8f389a0cf91384e05adf454b76571025e96929048345dbc2c739c35ac8e93fff25026637276b076d1d731bf794b932cd4422c1a4a4bf4f430cea0db4e3fb1e08a3d4684a5dbb279dffda89821e2431521ee80bc7c3a72b67f9ddd05879c30a247999427101db40da398beb9c9df96607bb76e411d32c5630fa8544ceab5d3af92d6ad19d2cdcf36099b689ab50eb2a6f796daaa6d8489dcd1a80f6c054d812182e16fedc9cf3d4781abbc48e119ce654175de5026dc68252f0c4bda97945fdd574c4bafd21e9d2e97526f07be152d29b4a2ee63a8952878bbec3fdad79eed4e63598e02aab01b4bc7736d5b4c93e796bcf5e75b979cb20dcfdeebd39baa02033835e4d9029ac2e33ce9e699bcc2706fc2f4bbfd5ce5f996898c7caa9aa0a0733cdb2fc622c7ecc60fa7346e63e1f8397e19548f300caaaa279cff11aec7a27f750bce16a705acb2aff6ff16f1b1ce180c12fa6c85508ad90d146de0c9490b947edc9018162c4320d28d8adffcf1bbdd8b825c17a2d9a7fd7e2722d00800d28cdabe7a05a47961649467a80a3136835836bc12e497d61589fafc1cda36ab3d490b6441c315314ea41765f3472dd2a0492edcdc3340fb1a1bc8db176c437a808d97813e2e1b63c5050de2031da8ad60b8b0050ca75bfabac3f44a17b19b68646b8d52c831834e1f2520615b09e1c473fac7a5fdda269b02b4f4c7ffb3819499fe8321852dd88bdfb99931556b4bf3f85b7f59e0951474187ed552d0c027081715d17fc44b2fe9dc7eda68276b7570639301c6fc90544c4ec693120dfbafff732cf27dcb7847b0b510b83f0c6bfd85d3018bb0cec3cde6a250fd656bd2d9c332f0fce8dda6baedc9d419cce3bb0250e896f24d14ce334f0f6035f8c7a6a6f379f66c982781c8352fd7f140b714aaacc44ec44df7229d9dad5044e94921fa473d89b7ffc0949ed607a5768f49c5951d4f6266be703a822736be17fa93aec9e3df1b97e26a601a1d8244dbc0bd85374a0ff10618baa94fc559d4176830674215bc4cef5fab3ea58bbb990f6e414adc53e768a9fa2daacc24adac483f458368db906b07789520fa19a4fdec8b2d71724c01a96d478603d9b5bfcd0f9825a58c7da5676df6e6cea81dc32d44f0e9f250e8626d87d071e30ae850afe591f4e251460495aab427be593716ad189fd9f5ce737fce68e7e35380f1c2ba8a1389323a7e4166816337dd0babdad6471e8a3cb95e15968769e2e6cc47517cc9203769acac22088e9a7ce582029109d2a249251902a8699ac912dba3d37627603c6318b06bc5115cbf74c96cb79345c83165bad28e65a20033829ac36443578957fc2d0f0730cb0e849c345339125f83ca6c6c9a51c20e5b1fe04e3074475b3566a988c7645f172e1807da3c28a2bdfcde52612f2f3f7be496a9ce285aca33bcd92b783edd839a40b491c1daa47d13019f4a9c2d47e35009f6b687dd9b33101df6a6c743e652272f0ae190dbc774fc423b669b50578cb681949214514ccc492516405f707be85e7cbd1fdc509f980e99fe1f2569b6e804267c9d29d56bc57604d1e62873df02107d3784612746b2bdc67ef0cda2a4b3cadc51da26daf17d05e9f548153b4f776b11fb1147560acd5fd50105d1f1da7b2fb5a9f500ab8baf6ab7bb6856f3fabbf5c427016e69b832a7812616e88dc702254c451cf29de5632af7c855d163808c224f7ff75a3a300594821ba89e4be5bbcc75e74eee7de4a1d605719941238c918b7aad85c0dac35ed6b8bdb18785fed46ce9ec294c67d43e741a6582d722ccebf3c1df22b67ac523bbf0a05c7241d337946e6ae189749f02988639af4962c1d95926c5bf70bea97d97c73cb04f897f621ef824059904a6fd4c53815492b09a6443793aabbd632c0f390d2b97a8efd34d1c57c88625a67e14b2ce121f092734b51d762454040801e70b97b7c0b1f2b10c642e9fcf2576da928cf8d776488424ecbba443abe0e3f2b1e93fa482c23e1d46e7822e8fc375da1a79b775cd7bd36c162219c361f688a549e7679389a7cfe1ea8c4df7029baaa05c0e23fe3367e9585ffe2349c0a2843eb68d4e202f21080084fe6df14f0b2b5cd3c84afa613f01ff6f9fc6222770023cfc450f9b708c808e6177627bef9cb95f6151ee50f409480263421b0984b367377d13b133d1eacd775282de02a9c334d6f338ce6af37eb8365235690d420de4b45b2dd0f5e32e2bf2545ede372cd122ad6f257b68c1866bfa4368da6e45f60a6d015237e80d82694ff23d4577705e68776e38c5ef2f3e7be0338dd6cc88801a4c596e44c9d56f49e0f2291a711e348a70b221b546470c9e1f782129dac5c33706a800e82467a3c3ddf2436a774eb7f736d2778228a3749f6d76f1b8aa9d4db5a9616ddfda12f4f1ce0e151160c42579f7c87807b5f45daf8498c428ceb53539b77726a0e3bd08ed52e08544a620a924f5171a98f8a320a615843ee90983a66f46e9dd38a7f87726157d213e98568db872b8f3e06ed62b40eb349ce38713c457dab039cb4e958d8904fc3f26069154d05b5c98501d2570cfb2e3352fba1c752d65d76cc86844705b19b59c2e27e7393524470409da7c8c3fdc4a4935ab41c368edabf77aefaa44b62bb2b9cee333ac2fe571872bd7059fa828a6a35c088c28e2e3780b005c62cb06daa848972537c2ec19872197f6aa36306f9305fdc9f66504c29b609d40fb141632837c7768f66f51f6b5c9acd96ac1fcedffb53ad0d2f6d7f2ea8d553c415603d16dd047d8e7e90b29e7d96be70c9b008a4baad4fad02551e51184fc49cb3379a82a71d68994791ac983cb946281e1f0eccd3fac4edbf1d7082339e45af01fb07a741352e11fcc104824044405ce188c0d512baa223c2cc9159c4c08f6b1d14991b9791b3c3efbd369f20158aaa0aa8c75b7a99c59967a154f77254f300ef8b322997355a81961b55cf1220a0c93d068e3e06c94579016a05c36948e996b2a3f804f66f69b08deb1a2ce6fc7d8e424a43952d74aa922956fbbcdc841479013ccf9ef0dd424bf06101b5b7dc73d025d3c3102499879a5ee33e506b33610025a7d77cbdb209979a58de91a0414baf2e35c965b5c9d8f4f9f0dbfff5447441c275a23cc63edbde129b7ee652d98eb6c6664bc88cc404f01507f1726ff7f50e6a40cb348396aa652dc5cad95ec4a0c6b186e7060cae98de3b25e38391f74fd9e5032339d839f2b608bfebd9e8a38b89393ae1fd8c52debd100fe6dec4a01bb209b73f83fd960bbaab1eed776ff5be52f58dc970ede701ee78e86bc985e65b5ef2b4dfabc2f8802ee2d16d0842248b3ef03705a513ed4c8b1ace7701a4fcbca7a609aa3efac651cd5f9e87bb06287240315ae7774ba77f4270552879d99026f1a719bbb481ff4a5a7af5c7067b5d18746b62f33083adcb422586bed3050dca40edd344be4e051300518b5bc4894e089c31acf2ceaadd35c0957847c936a0ddf78270e87b5022b7144ae636be20dbcf7feaf5dfccf2e9afdb003e1fbed12652938c4155918680d9928e7a97fcb4048a6cfaa7bdf2c2266e0a85b4fe86e44fa1e4fdc744d96afa2cdad2c5b29d447c834faa9a6f26cd03a899830e205bc8f8e2b39da80453d6062a43e5fdc1816e0301d1ff1a16e1293a58b4207fb42b5896902df272add80128375f3ea97a87ea0db7ef4f3cacb29039923350c7651303f929b797f91baa1269e223ae317c956e96a7f8e46e675eaaaeec7c3cd543e85bc393b43a75d7dc10cf90114c70a23799d38159f4859e4057dad1c4a53a923a6b978f02b7cb718280793785c58186adef2bc9bad3b93a5a598dd474775d837366b80621a049761f308917957c76ecb6732680f4d2f2edc80b11de240d4d63c6e72fd5ca2c41c3f18a843d188d23a2bfe8ad5306ac60067b25693c8f25b4f650106f4da98968aa3d8abee55039877663a9fda4941e30ad1a30ae7d27e9e072fa34dd1a5d0f7028ae926490d6ffe400249e2c311c92499c184b8a3d687edddb52887513afebcc4cb0ce21fccc22977fe4da3feccc81d0a5821a3c71576e76709dd9df620ab700fa02cbc0bd347b066a115f6fabba796d0d23cf6091a37e48da1bbb5d1ae7e810a92bbe49006aff721bf9d469929c33b4c50bdfa73489c16865e9e8b0851a9c08f508510771a322635d0857634b8211393b6293be0464a10bc050afbbabeb5f52b9fd10e7b99c3ad83ded91d148292a95c7335b6df1f7499802fc5daf7731112baa0a232f16fc5f7fa7e4c824b0cbaaaea596f42d811b20f104eca546ca87f8e2fabdd45af7b4b53be2fafa7e0adf9c114b920975e6887f136481c343478ef50344d230cb35138edd8834098943cc16068b22bd4ac02893854a30e3c78b31bdf713d43c8054107bee3d90e2e0772af1c6f81cee69621680f3d3e94db7ca222cd875e87beb836db6d6928ce015d9c8b063c2382409decce6a24bbc9d3fe481258e49865e4d12c6496c84ace14e8b0056b3e251e2b0ca2e081f71977a88cd95afae9ebe2996d803e942535bcc1e89fdb5879e4ed5207a81770036e720f2fd9425a1253b32291aa2d2327b1790d3a86216907a63dac1a2691065a113ad460dcfdbaf590ea66dd4de3f783febafe2e276d26e80fc02eb6e809d63fc9f900b295a6b2aabb4e8438241a0823b8c09b0325f05ca2fd16ce42f5c52a4a0490596da02ce92b427f9ca0e43494bde6d682b4bcab9214b3a2383af76304215d48a0705dd9239069eca29cf3d34dd72aa1bcb4a52433aaa3f5a91d28b3255b0208e3cddd5e3d13d8ce4540f5de4995aee80ca1e9862982e1e7556f828ffb312520b9a5af4f49dd0665f6e8ae4d3bb87585c3e86fd6efdeedcf40be74acbbbb0daa013c3947fa5eb950229584249c5ee8f657c56d4a375ea79a38ebd6f6e2b3216773801ab65ca5612883800762fb3d800bc8ca55cb9161ee107d2842f4b5d41def4d8d3cc26341cb885691412441682254b38fa118332cf8ead926ff62b179299488fa18636aa74911379d4d9ac3955d9e9c1e6cfd6637f45ca155a4a19752cf2aa591da712d624bd6654cd9e78db6bdf2d33157dfebdd8dff22c7d974be687cc141b8f8e0c5e05797488d9d84232f0fe25debdc8726ddf7803f8b9d75187d9438dbe07c457a6bbadd40f936951a365ef35c1c2b0d727e1812b5d3d006296e8bde86486db136c4ff4a699feb426f54b030aa393ad420b0b6a657a91aacbcb97c1ea1ea32407e0e04b44c559746b373809f2d607d71f18939dd0760b4a1808b5fbdb4c3b8f6e667b55cd3f8fa61e64f9c9c2aca5623e95956432de3f2ac74701072941bcc164e31ca9d241879c062c8c74b183be696fec00151276f6b319dec36475108165b1d25c6f81c70b7af5aa94afd216cba616d3444e82d60cb81cac97feda1be022ef417884cb252955cbc1ebdb0d5f2653876b9f43c1f0855a14727647636fed2735e44a2ac0cf0f53d2881c2b5f2087e4001da80c47f9a516b44836773f2a1ec68aba5ba4d8adc39a07dc9047386c3137f2e266db74bf575a7e7478cfbe2e46a4b8f0e61facc029e062e96e67cbfda4d28fe976285e893cd58f962753657b3d09737be8af3658304818112c77f6cc02e95db8fcd7cd82c8f98d973a81507c828728143bfc2e54599403bed5f55479abfc5d41ca82e5c78aae0078926ebb210614ff4c322d0768107e7d6f5c7aa8e981520314321fff56da22d92f5435b683c4bbc5c3b4e0799f989a40156bba1507d3e1a47787ec83a0477032b40d9e8c814ae9ec19b395dcf3fab2e9450aaef1c7919c2619c9081092514f53a37544ea29ef18bb61fcc835e3ac05aeab5da4c20eac0192c40a3ed8a802f5e0776840381a19706181e60b8f7189196c8df2d819e8deaef08e19b7cb7932a5642f19a540b5f4148ba23de7e9c50cb67bb98dd5f229664427adc08367975d49195746f54f1c1bf83d3eed68bd74335875fffa1b3be9c1906023ad6908c2b6539fdc92f7690d5c4b5b8209085714024fe516c99cabeabb35051dfc64b64d022b2546b9d2d609ce187f29e96f2c0347113a6e3c66119fafcd116c9591040d9e3270dcf51991f6192f782a28fda9a3056c37f7ac07b46456eff030e1f3aaf7af0ad83935d8b12b2ae09b8df992580cb39ecdfd992c7d6b594c3cfb1a49fff6559a20d10162c7b47d5200e239771bd9862800354630e7a164ff0d8c19c88672ae8ae47ca92e58c726752a80b7dfc64d34f8f587d4533ffc807722272c802fb962b2e2691f43322647fe85cc1f43ad7fd8bd7afbe75242868aae6dbb4eb94a6e2eab24f159837434e564beb2e1e421966226d22479aea152f1182fbea75b628e53d61375432e31649142ddb2cb71af2fc014dc4644bb80389f26727f167779e199ed1efd711935c5f239875bcc75e52443d8fe130a6fb128f0202f2ce26eb393bee6de88b7f3ca1bf1386bf0e70b90d8378f0961d5382ebab95b9983fe30185c8c24ebad36f74d24a307ac94582cdc8328d7d37866ea1c1a8a612dca9f3a0dc9a8d5e357a5da14757473c8e3300bbf6e14597860c3086edf9722f637b1ad8c5cf34cf4c8a2e13250eb6f3b8a76740f1704c1425d53075db806ecc46928f60659c507c35fb73600310f42f6f6a09babb4ad4ed0e76320accadfdeddfe403b01a1afe00489a8daaa458e56ca0f28d3b1b5e99246b674e3a299430c0132fd0d67703417056c84d31b80edec0aa35925fa584cdcb946984559b50beae6977a2261948cc402e195e723eca0a066871365d4af0a8f842a5bb653b3e7bab79a0ccc27a1b715fd51ae7677b441142a9471b986a25845e4bd9dea8a97cec0346096bcdaea5dbbffbbf4c8da29fc8047eb7cba5b35c818fa006bcf4c96b6be092e12e6726322c159321499842aa25240e53e66599e5e2d1513f5e1a506fd028c69d4a77f2dfde5401ddf0daa30891a88097eb618d9cfea7519966abcd211e854b8e2d14436501ca0d9ad852f1e6ec506b7a2e47efbb99944af2765dfd49636b51826c03a7aa1ac41bf3b86b98beb9a5b10297eb52fb1e35c498d468a2894224b1586bcd9ce92855931c070bc0d3b030cc978ae529dc2cea3ba419857a949f8160c3dff7b78ab6bfa4f124056e3f53a6f485734566f6d2136ccc72a7fe6725009400192fb042df7ebeba51266b5978958cfd99372c27b4c4fe481891fefb6884ac1d3c4a7d8879cb33024fffe8f3e079a12f8eb1ce39450af7e41a4d56fff783cbfd9757ee9d3403ef431d044821dd787011cee9c85e43d2c945c1f53711e0bc2d36dff18b9b65b7b057f6d14b2e92398e96e42763f1966c6a89c251a67f4e4f2f566e3d359e2b0dfc44d8cbe7d778b536af2c26e47343cd5baebb80a507fa89010b5ca5cc9f374c0ac47d5f33b88cc1ffe290126b030607ecba0e1ddd653655253b318d815d5a277ed4109a9cf61b44bc9fceec6a943af6163a6a53f8ea8c99a334c7e496cac9f2ea10dba03fa9bfb5270f539ecd16766c17290b22ca9443a8326d04a30c92fd5e9d3a94dc5aaf8dd0418318d8356c6f4f6527ff2ccf4d2ff0e652465722cb21eb313ea8c8544b8f7a7134a7c11bcb08150d3b42808d18ccd422d2609dc34e44b86095d0f5f0842c3de4b452913351c2aa1544e4a17f38de2aa7fbcb105c08e33bb5f09cf02f56c922cadd1e9e9b48e4d856ec5aea7a37183e86641721708e63a67264241128ea64b99faddf407354becdf7af539f6ada4a024ad44aea9c66d1a6216660edb2d77a6d293f0e0436bde8ec041997fb1063e0dcaba1736ea16ce3bff5e18cd21f62654a2856a8dfc1bf86df5cdc7cd154a1b7c117fd5cca9315f72816ac50ffc593fadf7616420537fcc58b0e1f8781a687b4e3adb0fbfe596a9e1fa149802208cc7e8ede96b884995efccf233c52f96d87453b8f35ebf066eaf6aa1cbb7babe85353592777c3dc31e9196fbb3790eb14384ddc5bd52c9167a48ad5397b2c159f0c42da64daaa19c48d763d2ec93ace25389c7112b37248c916600c407533fab3e827b4307a9db0ec68b5514bf18e48dd0938b2f64230a9eceb77d63c6635e13874896b1fb4653e9ef55582baf7e16446e2144bcfe767c647bf7d921bdcc0afbc322a2fb82b8d9c3e308a1c8283793c7c1eca5a892e736e16a9557193be8a3d50e6182ea6b7d0e0ec985e621d3f06ee7aae9374c0327a3f9668decdba4dff2df2f1a328b756f8119b2f7d74890328700ff477986399f37b068067cef7750aad584c77002731eb6dd8eb3513c9a3018d1bad382c22a7425484effe59c32d58dfe168de1ba29077fc833b30b5a13426120db195c6e440d130f01151f8e2e76191ebd28d128c0352598573e9fb244061d4f4a1e488880ce705cd16f70148c80bbd5547e1034797cbd0e529dccb30f754eec7b0f1ecc0e84ca182f00a582ceed7b48f40d5c207e7b0de7fc17d4844756ecf64b757eb477155ac23c7e9febc0b166595c2731dce10e51d7bb93cc83ca0919347f66d56b91d1760577cdf926a2eca419586c07a4f46ddca24aae02589e23b0cc9ebc352c30282f327e38addc1da80382f3777c3764fc2b2a8f9f00132f4c05ef8998835d5b11d0d57e2778c99b5f3a98f886ace6f0e5ddb24ce05e4ff82b0cf5a322e42551348186e911bbb6f7083bf9aef3121f711385f05c88526a2e35aab9d464cf2fb4cb7030cd27a8e1158cd9e68ff3ef907d05b6e6d2db6c64d216a1bea9ea1fd39a90587a214421cc7c4e26f1a4215f45ecc530d8aa92e83e61de0821a11b51f2c14a26dc15891fce11f0f31cee65ace03a51ca8727188faece7a6c6c2a43e586183544fb6bedbda90ab8cbe00fbba074e2d44ff2f30c133a1abb186aa20a95c4e4b009d8abaef35d6946376c43625895d5d90fa653d840e08903a9b2648cd76b10dd598f7522cae53aead432f3e95d3411e0388e6bff4b4bf49c8cb7b048abae619b86701d7207574dc0924ec01d4ef483f8757df024fdda5e9907a8a1183475690be1dd3c456f03f0191f71ece35bbf4e86b4f7445c3557fa8449c769a4d30b6a1b4449a8c19863294b301c495b00f22f6756201a746e0ad8d78527b428ecdda09565fe0a9bc83623b301d9d598bd770d92169be318c2861e46d83fe8aaec0224136b8b8047a66552bb201efe8b9f3c02c15b10922ca8b0fc45015599d5e3a14e8f4860ab982d920f56b7a0806d085410336363dd1f86e3b32c10759fbf52660809993c88536089ccfa21f7c569654b6836b7086fb3487cc2c852148a695665e8ec7eb0c730de07950901e298642d4601e383f0e921177b27450827936dad221ab876d95061e7a1324b2eeb9971e3a4e0797db1ba18ac3950d3bf3b9992a558ee5a643a7fd8e8651a9230b2b8661fbc251858011fa0619c362e8d48d1c0d6bd6ae43871aa42611bb1b21e9d2fcdbf94d52c58883db7634704beccafe90a2788d7dc136feccf3447f59c6c1a60aa9ff535cab47f27a6441dd49d8fea763a6198a69cf5a5cf76dae56ea52a6f65485c813023aecca67a28b99cc153239404f753e4606e01a50e3fc44e5440d0f27345b6a19be75b8938ae4b771b79d95ec8461637be716e81d963cd7b9622ee43f662cf1e2e114a5f6f7a16c32c39d0f5c07d4da6029a59017d22c3544fdbf582ea2d1dc50a04f01a61182334bfc5d4fc02aab0e7d5b23ead520bc0975b312f42923219cf3d3291ed2b7d7182ff75590620c6ceebd062cab49f36bab557e00c3a44b51158e5c4d71672cffa4ba7068e903ebf740812b6734791ac7ce1a56fd5525c153aa28dddfcfc3a28af5d9c2ffd6c3ac8341837c93407c588177702f2af3c263ace4b0cdd24c0846587883b04d8053db49f857a487d4bc08942d5533fccd73b720c2f469f9a4e0c154d65aab87d52c3e426366503b298f1c0240e6ef61b2d1a0b36e344b1b2a64dbb7c722dd236689fd83bb460d088a83ffaa35e3f053fbcad6653d0532e1bb77adf780813331893e1354c57437eaa994ed4de64d456e6d449b905a462c2182cf8ece6169fb156d8efc1bce27d0cc573a99eeb0cf0a3bd36d263786659cb6c6f62aafde6900453c106187d5ebdb26325821811898f37ec27fc3bea9cd4a2f44e79c87c604c291957f03678a1ad31b1bdae7aafbe56cf6c6a1583f266f19730c2c11e92561ca786bb6b0c6d2b1abd2516e825045d596b2e02085d5bf5f351a996b43fe7bf799752964f3abcd94c752b8e4633a6e9f64345154f6ac05131e6fbccf2bceaf8de056d9348e5fddb4532834c6be977050d1e5118509e9b745d27a1bf0e88773b38708a728e6ce80cfae917d49366995f2a15fdd6aa67c930afad1a864d0a6e17f16c7a1c5c14ac7d4e3dbfac7ac6fff4b6de6b5ded011f4cc3ab67f1380e5f0fb922b04ebeaa9a4637092fb2875fbdf1ae57ca9d96a98710b935027a2585255010a657b7ebda7f4593a290ac1113d9fde846ced10be00fe3a52728b7d1cc059cd9d31db46fe516354d451ab82fad2772455c4ee0ce2035ac71b9b46e9dade7b4503e2419ea81b71f4b62428bdd3fa2630a4bbc0207636f5afa6d8a1cdb8db5144ee7fd4c55c619a5413861daa647e17daefd20a12749e52ba1aec160fbacf2821272f0d6324b68fb53db6a4e63b9e2b4b637110a15fc305360d37303518b1050062db7d81c41b48fe7f3cb2b424ca4e19d19c9b5747ed1119659af9e93ad8a24f44781a6e9a0b854e783010ec0d9c42aaa3a137a164e902b43336f136d1df8b8a9f6497ffb89e8b5b0679543c7904ca4c60da0a981d5d74fe24df93993834f8b48d8954a5932d15ceb8717b4c90281c2c76bb84f95b37361d601bb021292896d24b061c171ae5a230e9a0c1c4368c71e3ec678896767cf1079afacdd3773a733336f174de28a45e1eb1c5ac01ee51300ff35fdda99795aebd59b26d643cedb4e51420e2a8bbe6be3cfef0e05e8b3cd5c37c5068b0a11f87fa8d41e0912add43e717831a27c1c23fb24e90024ebc3022ac1e63566fa23204df3deded84283373c8f0e0cee711d05a447ff144d6ade5694da992b7cb5ab6df5db5cfc56cceb8a8b5ae8cb6fb321872b7d7998bf8205bd11e67ba57cddd6505efe3ec4a871f1d9316d9132066d2c51a82b664213bf8639e6ddb9f925d8af3af19651cd45f1e8104b0d06b8029c7a736912059ba9feb626603c7b8c670d10f00625d6734d1068519e7ac0cb1d02001e5d00782cb4eee6167547ce0160acfbe377600b25dce34e85df996ce3d10dacb10fc0145db84227e85569ebf6c4faf718754ee157f918951a1ed07d672668210acf8ccee19d8176ee51e6acfec664d04fc27317a3d99d58fa9241024f046221d03eafb988414485a8c423fe1eb7d6b1be62840cdfb3e56e50803800c08720acee905a8b551ae1076176954ff5705f2687a43aa5d78e3ff569ca234e486b663c4013db50a4b530dddaa381a3d9dd6db243b817696a091cdd81edbd1aa5bb6ff5eab5c346b0eccb15ca2935b8080c4400d3da251dbee0c03acaa879ecc4624bc519f4d9143ff184fac4a0db9257bd16e539bcebc8ec466174218002c34f776c59d9771330b641af8fa9fab19704cd096155cb864e1b8938fbdcc42c656255b86629a59e0e0cc86f542370dac5cc13e33685158acadde8247c9835d4d59fd70606ea6edee5a530c3ef0b87661e2d66c5f22a900bf59a9f17a88254c23f7763ae5e9fd528d6761f1380286135aa805b78cb6e478d563c452bf32cc4382d1c2535edaf1ca0111e8c61a9f3742c519c5b0c0bbb0b7f9f418694e52a8659912d85cf07af7dc26a1128d436164f1d01f5422b60d00b138866f64cf17209804760404cfb0466dcbdb290d58d75339032c7a17c32d5c6f2f8604ee60836aa0fb83dcc695b6f5a09354bdcd4cf464065a1ab5953ac9366feea6789e168d2709a6f974c19a9078d27b7a9657d5d81a40433ee33a315e5b69758bc2c37bd17e060ba66dbeb7d60f5c2a0fca1b584494a0143716a2e95ace52ce6aca30839b8889e205ebab174e499ccd14151f9fb5522a85eed85e4d647ce6514f5b416ce4fa364d3b6268e96c0070be07ee71bfbcbfd77f5e46c33a0febe17bf9ff64eb806f9f917af8bc420901411c7857c2d79c6dbd412539dc36b2851b1ddbf4030f24a69ee3a0a90024e2081a50544dd2ae36f4e926f944e40d7ab9ec997891e372dde92c1725ae5ea4953ffd0495cea713f0eea5e401033cc2bc9aad87bb5066a1b6a268f23f33783d5b5ecfdac326bce02e1d3610e8f5ba50531cfd9b6b1227a63cf07b96f4ea46b5caeedfbe0dc406e0b517fd810374a177f56e2f3b639d0b97222070a5f823e4c4fdab855482456a357cb4022cc43caff501a79f016a6c6117e02128d5f9307841d152ffe892bef970088c5d96991b2a817203e147f5f2d1c849b1ddcf186158b081bab710fea4c5ac14b02e1cdfdf5c8cb19c78aa386c2629eaf42001ba1608f76c3342ec141e0fb0cae42b70383c73ea3ed7a14dd8e509fdba423a57b8fd06c52216390a65952055b79eccb94f07d5938699d6c09a76525b5757f89e718a97cff295aabefbbbab4ef6811bbc8371c872e9bd4fa51aa5731322dd972dad2d0ebe9545701e71a8e4cbdc9a1b056ec8f4c845c4db78f4e3b7baaedd957330ba587961f992c102181379055c15f661514d37960d1507a435fdfe3caf2cddc409ea508ec8ac171b5d80fc9e2f966cc2333a6115f9137dd714e97a10a27d5d01e42c0b23ecccdbd0ca43fc40d6b6d3ee49993f47f376f654e15b52c3240dda61e99cc67fd835be1a8217ceaf8bf1457342759b74d8036971f4db9d824873a01c968e62dd96c4846a6aae64e52709926e1a9fe21dddadeafa0e5b4487c687c689f7bf2c40912a883fcd0bbd58cd9c39bf60d2fb2b25b654b7fb560a2069637acb2571a2c0ca914f2a4b76e90058d8d1ae3e4798a38a200d4c4aa5ceb7d018921d123bbb26f68045a822a4471700fdf553c023b5038eb4b6260adc64a979a62e32df35d33bf186ce69cb175aabdfde2e7e08b94fdb762e3622565c2a63d7be4d2ebe1df9624c09a87c4e29ca514461343e7f1d7026d5cec1294a4bea5ab2a57e83223fa480738e4225c4f87b3fe93af3581d005d47134c2fd2b967b74d33085aefd7ffcb3d3ae19df7d7a58871196f8f2b406de765818905816d2fca591e2dbb2dee7951901e1b1e8bd1738552fb86df14ebdf1d64c32909ec8d7fac5d3ab869c65cd6eb805d27f4dcd98c57c5efe2052751bd12d60e54b1cfe5c577ff231e47760a29fd8d02814d43869973c2e23461749d2c12dbaff280222dff94cf5f433abf744daa368949e076e6c2950f8110aa22a7449d612da82a7fa92370ffa821768d41d8e0136035314dce59d05a2e189b1d21006b66bb6a1ea887fd5cc303bb1c2a08e81028b424c5c12567ad0d8e3cb4c5b34eb30b6ad1709f68a2526c46f875ee807040e5ed18ed6813faabe8188e3df10ab0b77dafd337edd94b054d04d2d62908998e018b97d319de7fe60e1f3a7f51cc263aa9c8eac047de7554be5fbd4e531749e6a756b9a2e436d76b30b1187fffb7c6992e9f40cb4f4b5a77565dbd643cdf97a91183f0e1430555352d431d514d670faceb3b964ef4d3b728d36b8dd7306d1a705e46a7b6c85a2818d9baef374089a2eabb8bb0633d48f3117fe18598aba48e9b645aeb19c57a3434018ae19f5d4c8e7accbc58e34eb78ee39a8a733f1e831deb75f80bd014d2559dd62430c0c8c6b59012674cb3d01a8833ce07241dd171afebdeb9bc1b3c1d9e00ad4483d319ed6eb6723b68dbd9745ae2b162502adc6881b5fc2fcee91dd6522af86765845381d408d8ea994a2761a89021527a7a94eba7f8d4a1a3ed644cfb55a0efd88351e21cb372ec1e33e0b53d158171998256d11b2c420d8c38bbf18394d82ed353791267b5c159b3cab870be8c830d90642ca58a86f9f9ad0269f40680eb999584a36bc4e50f7c574f36ebbd70f6a087203cdb366b171c931e227c1043e7a137ba78ac6aaca080107fe5639e0a87b7f167856ee189648df3c7506f3a6077e8ef9ed2f0b6eace49cebc80347e533b6b5a7d692aa311c5a70ff64c9a8cf85bb04b678b0ef3f6cad1121959d3f4a9e2abbfc29f3ada6c2ee65591ae493fb719b2f496773021888d8b74cb3d15de8da2c19d6bc194b9cbe836f404e03598bf368447c04d3c9de80520d77d87c5a02bf20ffc31092dae40f01fc2896d209dd53da3b9ded9c52af89608e89dd2511abcdde6af2f80e9806faad5a414ea8d89af426c2ebcca4ec3c3f43fba766cc3aa94617e2f9d7dae7b7a2c21843652abd73de02fc542fd41fad5e7abff9638b69a41f8e787933b96a6749a89112ff7d80131acd78e66b3199c9fce99fabc582479f1d8f4407061dca6a01a8ef64ce37a29ec61d27a4935c37885ef18e9b663ff011ea1c6a12a64f12ea631d5b0f207bdef39bed74b62ada6004f273015b578909de865a0adaeaf9039e93105f4514bebf86f3c2ec012c3561af9f4f22a98c2e7f9b41e2046623a4a2c2187581f2e1b6b819986d79be35e1db2ffcea6c59e27c7736189d4465af6f7e9be6528ede816e3b274a29ffcafb9f4370d78333fa3fde4522bc083d3e04553dacc511bbdd8fdad0fb8041fcf58839a8eeba49349e884b9f93b52a367be2944dc9096abf920d3b055a36802d30fda479f906dbf4440c761cc8fd1a6ba47b6417a34a8e56e73103807fa8904a9528265c046a2bf3708ae216f6842093371bd48ca080ac916704bdf35be2fdc85a2c9533a2813ab37033e3aa88b6dabe8a83ac842c9f9808b4049813eb2b67a3570d3e70500efecaf341638462cbde3edad9fdf3398ba12191189e488700d673deba49a9f0648f7613185e66877f5a777a33815cd97b2912e60344828af67c658280d7bca409ca028da41674560521259d4cd546510e7c556b003298c759cfd9e3335d232b0deccb4001cd26e2563a522c8a5d495e6c44f5e31c9cf17aae50e82f99706f15db4629cd48ae15bf4e81033c5d56de9353597f4deea8957e836f74040ab16025e66be131614072fb177b594a87d7d53329ec943f00068474889104020c180364926e661edf6dfdab15e3e67879c0786bf4313a2c7a683f04efd06c57a1af89ae226e804412b4f8cb443525b88248b21f4f9c29fdf4c2dd4a3e1af728f3f5a81a33199644dd393f7bf87ddc89d9f3d13442d1741e922833a32f0b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
