<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5976807e220479f8ef2b0f1c01f357380a1fe85d5084d108b74200fbf2c854f15a47d6a061bee3a6068cb84f0b53770c3be0c04fe8ddb57b235e9937a42fb9ceb0282f5ce91901fad43af4d4e5667c2774bb423c04082921d5d5ce6a2a5d8946d7d4330c6435cec996b7fa10f83afd56a6823dc40ceabec21c32f6b3e7b4a3a4617a78bfe734e32b29848b2fdd171f545d3fe529d71718b00cbc1620114cb501108ce429e8a86fe3480d002d02a191403ff2a6e5de2b61b5f2e3f4b22075db3a25cf11ea7e944e326cdad31c01f67aa580561bc0e4e5ed0f65322ab14544b3c757391453a00eeaaa8f3f74f4eae1da916cf76cb984389505e8d592fc5b74a6e2a1ab9f60db4ebbbc046e07f2b128b9dd84422aeba29c1b02950202b6907cb71eb70580d5cdbfe8a1a7d71507763cabb2fab0d45dca85080785a5c31fd987f3807dadbf782d1028b647f203e9eebc84381cbd30506d3a093695238eaa8972edb0b2a25936fb6309f77a608a47b8f930f0318185424e429b4ab946d8c46bcd96a7152a777f2cece64fd6b84fd030ade7a3dcedb9ece7f5909f4b19d1e30c9b10d490865f0e8718c424a8a1507fe4388b4bcff343fee62fa660bca0a16d61751bdb7598f9fb3520c52753ebfd6a0d93e096024699af7cce7a3a25c9c3c9f1641313afe97fa5616bcbab6b809e86629ec3b8306658228b193f9d8304bef29d843ce64d9512066d1f05525549f6d14045b737d23913398e1859511081d96878babdae89c22e4de8aedea6bdd7d140b6294d9b815d69e5b3a363bd187b50c0cc9cb8a9926c259ba44931a8310303ce0861744f42881e3e05d1d0696d1950e59953566e56314460c8cb40226f1408e97836efaf100a5cdbf267e87ef7135a959608235ed2c2d364126e3f67b8a7368f04b0b75e3edff378793e00cfc5f1ea181faef671b2124712912f7491d0b2a51fac3519ea1f05967359b37b76c3b6add2a3db59369ac2709ce9a2092c000d2c7c1427858d6ca1604e2248f60c0df49b91eb997dd921d10eae5c4d9ee4a52ee0936b88c6f11903a9815d84c2c9bed83d89756361738300b2c1b6101ca9a28313b4f25c3c198e22ec33338ea5681e04732e8cba79f9524ab5583cbe292cc48951c2171f374529dad66f4d5e64cbf1d672c1300239bc02a1c32d0fa2d941942b2d9b8660103e0b0b923a18ba179adc262c1a6d89cbeb7a2b84fb92764ae79f65fdb5432b7162972f4f49697eb354558ceee89c2ead34354a339216a0668155db1ff1b8a6e9c6dde9d56449a1283d0323d23186fd5b927d7c04dd7eb9a04cc761a281ad702b89ac450f4311f9cf7495f5430a9322c69be934239b827addfceee26117d864275094defe8af0949036d0cd9970d4b4a1307fa1578dbe35f4a386e67ea88bc252e43a9d2cfa0d9595392908119327bcf06e57b506323bf30bc87ea882db6d99308e0540e72f7f59edf4bb57d94b221114de7cbe16c102922a691de83daea4cc6bd3135bf3998f54482fb026299ecb9aca9121f4533daf5a216a51292cd6f09a5fcc5b8e7b4b8620501282d8d290bc2cec5a95c8ccb8db6ca0b6ee67e91f48a1d3a2105e2cceb4d9d76d722d2ab6e54e5a6785d64362fbf8c9a26c20d310a0a47af175c614640fd2193b4e65602cc4d81d63fbf9c338cd96fc53423cae438c5fbb95a8ae8c54e80731671612a7047964cf62b52d553cec500572119cdb82dbc63e8cf2c0948e19b094d05ad4bb36226975da0857161c92b139e3c5e2fd7a2f606d71a98925507405e554145a546709de90495564f413ceb80e4069a84daf3ce66c78535e0320192f9be319be8b330318334466de8f7d74021921053f99266e8ff159debb58a19f8d0d533fcddb7c4a9921b0aa725a24f9a526c5e3985b15b25d5c8e6be9508fa4d454723b2a6c4b16f94332d23c34e92ec681b3c87cc03b7fecf03bfb5f5c6f97c76f902bec6cb2cb8993776ff9ea8d8a6850ab8af9a0cf2e384be633a98b7cb8aaa6b4570382e634f01c5fff88bf69cedcffd25031cfa9d8d737ca27775634dc1b01317870a1f74ab9d833ec99ea942a69ac3bafa532d30da9fbd0ac85e2fd75652aa396d99707521464c3acb8b81ea6f232fff4e83f6ad87769b4e343722432e228f76504f9c7b7394daa6a52db9d15452af8497d46c10ebf032075c7e607872ea8175235d0ceb102c8bad9637c4bcc1a5c52d6616057b47a60481fea5b500d08341943488709af6eb2a1a9b8ea94e077b3669d2fef54625df8ad91ec1b64d8c0df71c8c1c24ef6fa566de2b6e00081bd780c6106dfc6ac9fab86e46d2468b9fe072983843320dcfaba686bde281d2811c5e2fd1d5c02f0701bdb56c63cb55b684a66ef67d173925c9c42e792065221fa44cbfe01f87b3f3ef8b1e861550a1fc4720f7b2fd64bd78eea0e36a09cdde5414ae1ba3bf3cd623a60184a63f3fb9d8e35109d3250afb975e42f6a1be8638bd4a0466395608c7c4c10680125d094a27b23f834716ac2f38f27eddd125bbb13662d5df74cd442a5848cadc27b080eb61563d5295508c1a7f0c34ead3cb27a26c6e34b4f717aacb5a96098b518726e8979149f8cb425553eb3fd24b215f337ccde940b41312f7dc59fd327db32eef8232b304de15f8922daf3ca7558c9888ad226da8fcfc4b58b4fb935f951af1766336717bef15246f280949ad0e9139929243e9c394690b6128cf3d74a13f6dbf38bb2ffa6d021db5fb9e0da755d4ea2d23e872a56eec32951dd5fc101f179f51a379189196be2c2e8121104f6df245086388094c0ea8756a7e9f9419a813a29524daf9f5c8a15261bdf888f2d96e105ff77f4df64f0f3d7f96ec8ed5270f9512b83d54ba808a48eb543cc3a7ea2188b8e481fb6175a3f1e7625dd2fd9126db576cce3859e0e6c8de45bd531eb934d36185fdb7d6486f904c821fc1ab91efa2c22af986085bd5612f83347aaee74eb3b23795de2ba0c01fe153e560d8f8cbaf0935d87cb8b718bf9256313aae55558aff7908384cfcc6c798f28cbb77dccea909f3055ea9daf4f26f492baeab33dd918b45d5c80fb6b54eb8ea43824390a132fb1368e671d5fe662d16da621464c8a7202b2dca683fdb68534bfa5884d2a4380899f9142b3b6a9687d9eac72f39224eb710260392a0b402ca2ed0286dc8e34618c0502f31e22ff1ba889e78aa0daccb237d02e1e743f61ebd15ed165d7e3f005a477bb27ac934208c8fc0b1a854f294dfb5d4f0f61c0de0fea2138ca5c5f63d61fe3ec9b0dc587e684be01e4aec80b4da62735389b7eb1ed75f2465d15c15eae5f8c6deeea94468d8dafc836b3c44275d5140b395eb5acdd184c25752f91122a8a56dd93f0e8dbc15c96e21817e29fbd4c82a13ada63d27469d0aedaed899b5ee2b548b704c8b911e0a23249c6d547631f09c3ae413ab4dabd20e3ee90ffd0214ff9674194266833ba588ee212445b61b46f0ff6ba0441b7e05e71abf09dbcb8c4052e1cd56265a55d3279b9bed0ba1f0f37c3aedbe4c616711a61d6a549c5259cdfe1dbb86c9c950eced3599edfbe7504e5f121b1d829bf5819ed549168eac53cef02720f841f1ba802823da0aad4d04b14c664796961307f8ea65bfb3447222326a71078d051a71a2d5e34a48946bf34b507b6ff4f939fa8a3bdb868258eee4c3a58b6d79be828f151c94697ab1db949b8731571568db9f5451b9a01ba32b361d0d4e974cd125091285bf57a5fa855ce03205de520c84189e6f1ec98e97b2fc75e33ba5fb0c170574540e05376269ba1d766615f36b823a4977b0d441bea21c4b9603efd8d3f4f382b7724fdc835deda2b372efd4b2220465bf113746f055379340aace2bdb5c9100d7006f15ae88d4b0870c08d98154f58ea28c8fc5b0894863e4e812a23d6dc3409e35058792d2bcab6ca62de12ad73d0dadf07599e2ceb514d2e3a8edb8f9003b3eac1a1a8e5fbcdaaecf9a2c98b88ce81342e8b62d8e852aae4eaf487e3b3d4922676e9d0e3fb0566995e5bad07b4f825473926a4ffb3fd93f786f88b00aca05056a0cf4a73766dcc1fe3a84d7bf2b5fd248f38bbf291d083b5e05e5f60164802c2f0be8a084c8bc911f50764a259d9530df0d45c9fe9174bd350c76a1bd8e0366a35a7d0e0964a6faf696b8f72e76b93edbff4efed15b1720811b834887e91770ac2a491922b96150204bb6e84806e2dfe290e65db046282d3c76c27626de9ec891e11a3f92d47a45fdd78506d4723dce3accdfb8a20fb269ca9bf3db00a27e462b2bd6b69697aa95a7c367a0080f1b96dad8b70c8fbf2bc9fa722f882b1c7ac7681de354c6a21e0b892ffbbc939e9c93f6c721f082812de821f613dddc6466193bf27e046471c4f093be5e97cf8cee44c4a98fad34e91f6a242666e6523f0d661a7a651d391bec62a582012c09136c3c7f97092f663b09e803910dcea20e3ef30bdbcc7997b1a33db79ccbf358f7f2446578d4bdc1135d396b554497cc78e0f7953ba3afc03aca39677e92a9b46e144f5b7cae4eaa469f01ffe5ba2cbc5fc7c8bae7a34b4990a6a4ed065b5b0e2af90f79caf5c0c4effa5e83de1ee7f2ecd5a60eaec7f3307732c9aa0ac4f5ad658979e04da33fcd94800099aed036b5b21aab6038f0ed2c9502eaa6e17305c790175624eee03c31049dfc228b47fdba427257089e4b3dbd5d69edeb5e9a73618fa905efda083d953a75602ca6d9e3b9ae5792b683361e1fa4659b8a22fa3150ba385f0b2c84d8c7552c0075ba34eb9ec6eb87e50561f1767bc0c0b0a969d123f8541aa4e67e732c882fef940a2abab01496cbf59528f67263cfbc08ee93ce442618e23795f9228dea09524a086795da595a80965933ad004f65e80fae2999e08791441f8c882438ee8903ca1c741e7b13507678c44f8ca05725dd70c49e140c4a6fbf28a82360e5b18a019617644dcd187bacbf9a23991a16337f3b803ecaec05865db4f1b9773185ac913629304a99317033b3d88483101e1716800d7888a39455a65941704d18e19749a3eafefa954621fc53399178fe3a6527261547d1ecb401d69ff3ad7f69768a09f77f0907d6150d075dc6a34473d32142cd8902f156c8dbfdf0eeb001e50329ff47c60a457103187efe531b9c668aa066c96eacbbf884def96da49e64f8a1a3e6e35c938513f515347bb42d3bb22019c6fa206f96f30f16c7910d095ab86392717ac2ce8b7a475a9b3ac10fc69bd1c945fbf40ea80205db5906c505a5769a6f476cd84f1204b69ee52ea1fffc89f3f6f0bcd35199da5986540feac61eb139a201c1a7216fc19b9d8e728825211b42154f906b35bfe6edafd53daabd04c8d6616d9a061b5e492a0ab6c09e491e9b5f1e966d39a52d6b9f32067bc393cc27857b72547de1b0f7ae46e66e52e25aa47db0213737844cfa37adf6fb2eefab8144433d0413f4a143e588c7296ebb3ea6a138b20964648ddd569d95e24702c91b5d0c0b66369a0f823084e83f94451e075f32a3ad89d71f456db1ab4b7babbfb18bab34c9f48bd4e0200bfd83947082f0dfc98065ae2c76d7aeee62fe38d7f113d5f3dd9edd422ffffd68a3389349462b865d0a381b85d15618235ed9777a76655496a0f273083523eab7d163f2b7242d89cd657118984c6a15bcc581bc9d7ee6ba292af8ae35025b3b757baf7fe4ccfffda80774f4df536bfade1b9b63c430af43b58fc18706a6cfac59099268f4a40e4229353b63b258ac1c65d565d835ae3ac0d5cb3dddf6881c45d91b9cb3242a02c43a803f98995e90d8f323a24e684c6f912861fbe10217b0a11f589766d8440e63624e7bdd32d607fbde888d7a6d177dc8e334b8943541fffd1993bf5c5cfd4f31d2ff2718698ed3d6e95dedc0d18cd46b1dbd52259d301f0f4c2b24e918c30642e4bd21238d9c63db82125d9be34e6c85d1ed4d899281df181d93e6a12195840f9910eb343e55680852822b5b1790a27ed87a89c7c3510591f8d5653109c48d03802347ec8669882ff86c3a9672efa89a24c368d083f6c6f5fcdd5e8d4d4d11b07b9e87b0f00fe7533b336728a5fffeb3cb0a5c136468b25b9d740a13ca752bec35df9cfa3f6c6f3c85e2e01cdd5943ec240dddd3e1bc5bb6ba6a1e1eb614f6d0572a87c9107224d1316710fe6d3363270d9226b06dfa8092f64fd8b417a3f7a9226996d7ad9c3eca5a51a10bb9207876346bf95eb64491d40245242e7fe94b3201438071b638d67c907ab2677db78c68528444a477593849608e8d33d52f0b74f97f85ae5fa6c64a9c2428f642ae2cb9e3eedc6dd296e33267a15e845ecc63b8b77070168f79dc792c21757f838450827877e0191c400422033c4cb05dd2429f357ad30c50eebd2f88bc9cdeecd780ab841634b9143241864b9a9df3cdaf434dfccaf2100ec49d667680807f275a921a483c0e1a6584c0c6eac6718f70cc0f8e5ad19462626d9105868407091627a61888863ed68581b4a2a30c84e2932e9a15a13416bc4d5dcd246014b04d87ae685d1af9edc8377d030a34583bc49a441779ef2422086707890e4e16d67652f35b69b4819eebb2e9d6d7d7a802f861a0b9107d9428a48a65ec5fd0e5a793202ca7ed871260fe835eda65fddea97aeeeff9faa091db2754559d216e92232e04c2d2eb160505e93d7cee38b7415e3d05bc71f5751c8837a0620f01f34254fe2f49a61535ac59a485c6731301c962963ffc6a642b51bfe7b46788e1f089f830d32d2f5867dce621d8b729461416e91e5b87c58aba2a080829c0884d8484888a0d0a995ea47a02e7821cc2630f85da4e2c184b896b8ae180d347819174c990f350567b197e3cfba8b034ae37878047882635552fc6379639dd8390e783b374ff7ac8bcdc93f26734a627f87c830f08fd65be0f58137327a45975dc2316a0a0c8ae6e1f68c2294987ebbbba890fbd832c920b1d839ed056a8b76984979344e1b9210034bd7fb370e5fb35ee99bd821593ccae3c90447ea8c64787dc795d6521b4e7d3863448734b71646027a51e52fd0195d8badefd5d8b4ca5852af77de8f02b8ea4e7adc4f8a190f42d28a92b41a83da3a85c19c1e8d9fb5853e8b9a4a2acb5edeba319ff44c97716cd0664e123b7441c74765a8a8b7299e4585133977a00357beffe8da8385c2245d5c0cf005f21bb1efc4f0430428fc40b12ed7c58b3a1ac9f44ae9636bbef2d819453105603887c4e8033f2b500f71dc83d556b3449e213bf327e3f0aee50f44459541c04e6ce990924536e78941b123120d2367a4cdede0d70304f82e90f9a60290447bc0c636751431aced7873cc85fe75f3ecf6be0ff023a8bd3978a979139f3332e265316f4811f9976905d4b7a04648ce7ab5a6c698e878ed1e8fbd5e49d80dc8f2b2b306cd726443a5aafd0dbc3b05ab61ac90ed3c2b9bbe69146733bf516cf0a94ae5ef7ba29211c1bd74c95c46e4c0e4d7cb2865c6fb939c47d168d597bc48f5b14a4aa6f38656cd949910b0dad980bcf38557987fd0f575eae86641a1c04303c3f94e3c6dcb6d868af2fbc28b34a7a425a4ca1f8be6cad69fafe5b277e87ed13e68832339059e3a60c7f7a29266679023003cf522c2339abd109ac32921706236938aac9fc9903498de4572e2dbe5f9fd34d8b0605d5f8809780e2804836a53ebd9b555029757ebbb7fd2b7c7dc0c6f5f6f51e3e6b24b96b117b16261f6a64392f981d457851aa9f32a8e02ce5e2fa860fef499e195eb67543ef847416a9d368d9d5a8089bb132098c2e02831533477f06c967823b7ca7ab84a55ca838e1a4a63e997f23bc01786b4c5d089eb47f4762b656d244641a79ac88f9676027bdc69ee3ec354d4e5c0393720d01a166ca4e527c1b047dc9d2c898cc5233da2d85182a6783a3f60051f6ba9948b420573a244ffb237f84c7366f8047dea4478240f27b9a05e106181d0f6a96c7acaebc42c2eb0f3f5807bd5aaea7210af682a7aa6e3d49dbf438477e9b2ce1a79a23dfe37253d0d15981e38d3d14ad400080d741404de90e95847285defc6d7bab6c9684f8cceb72292fe50a797e73757f755f729dd4389efc2c382910df0ac002aba75979fa81b3c324a3d6504cb5b8f04340a2dfcaaf76c2b4405f4f264d07eb7d24ce7be650bfaac7c16acf4ba1125c1bc6fd81180637e726dd2e563abe0c351a556253fe906c0055409a87daa2c6bb727e88f5627c70f46c3ed4281b31994aaff421055974b5accd2d89e0d7873ac8df6cb8bd5f4e1c3bcf77846a07402134443ed171d70726a08bd39412b52b8be4ee1b7ebc65898525311edf0b75234a9e44b240a70aed39ec0ebaf751cdf0f052b9482eedf25a5c7da617751c6dd574a5fac127502de1ba7e5a27b20e2d1ac353b0ef40f59d983bddc4a30f586a1c9d86e2aa94b1b8624f249d4abf8272c82d8e5503a399e5a8301a67fcca70365e98f710d0adf6ddf103e036224c0222bc67599351e9769820df34a773f136edc3294e1b75bb66d1cf0ea3e00f5fb8e7d40199c7509ad51a285ccb133632e44f4a0caf0a1390ba098de2de815854c6ecb77f4cfe889270162925c6247093f8dc42795c8a4f763b05416c666e33067af4fa0a78a6979d6a6a1bbc4e7c3641649ef67eb87834068bd28073bc8ef6c54c23ac3efff609a4890909c7244baa4f64bef8481e1f9037e44e0515c5d1f61618f606bf998e7ce999f9f810bf6602724959852a4f9a93c55296da7ea38fb82d058f7244a4172d64db744ee92aed7ba9909e1b5bc76599f041fdba0265ed2404f678cc38ee4d8d29eaef4c27081d69d81d89af1c1cee8406e5bc07d04d3c90f072733a34c6dab2cfa324d734e18431bece4eee293be22afd730d4e8871d44b0e56a9fed26af3093a3103dbba6b44f0fd6a5a65395212b031b65b400a9a8fe4246431f73063b4a86b40ffecca174589dff130bed338f86d2b126fa7a02804694dc295708881d417df74ac8995b63606c502e7ee05440857e8481552dabc6b7a5932a134d5f1f530ba2a8f46a3d390ec8270a08aac6d09e37b104247048143cb634e8a3223422eafc8596f5a501cd636d55e443dd64387ca1e3cb4800bac648055785594fce5c857d5079bd8c8a85447e7fbfc4a0ab2f281e459b2292871dff19f8597ab97a464423ad58de1eff039b61768966408bf7a2bc9c4f819c0022566b7d162c58d729d3fde2aab217650bca16ff2c78e76881705841c95d79faaabd1f1366146fec67db68b0a5d5663e7df3c0e04cfc8ab25ee41cb43fdb2da4c14d0bda54687a4d7adae51f37401a52ba1e8cb3a4b5e9044b3496d78b58d4694c96209e55f22fcc0b318b06dfd16cb58b95d3c9b69226af27a0059a7f0e6cd42269edbeed2120a1aa7fe9868acb70fc6b2ae1d6342f13d0ac44c05f49a13b84cc8fc2e1fd7d8dc04f3cfd27f09ffe9f239fd831ecffd0e9138ff4e227b76ed71f7b07252102e0b48f98c810bba3e4b5aab391801b266ae5a6f2e9741d6b8bc6ead5722a0d9cef44e390805999e68aabef7376828ea47f13573a7c142c2b531b24cd4e4d0ad898a2b7b146e6390b90c1d4d509584c5db5f86a65568717f4f9938cba89e8f43f42262263e9980ff636eb27632d4267d6b1395c7851f788d30648a22309269efd946adbe766ff7295d1562c788f19775695e3d9b109698e53282c57d65ad9596b26923119e63bdb396f295ff032ce154e504dc0e8cdab8f744c33f8488eee15592c6ff8c8ca30f4522edde5a0a8fdfb512aa967b6e38e82a25de0b795cdf8db572cf2e367cb8f7bdc988dad6496a5643a7c80255a74f0e2c7d5caf1fa4aef69ffb45b6278350c18d3b584597f8b3654e479e0f48617a2d1a4cd21e80c1333c32747bd7203853ed3f18aca793b0ff090aa91040679733a7cfeb90fd3c60bfb1c2ded74fca691356fcdf8efbbc27b1851d07a0961a5e21912ed7773fec2d02e1d99cad27158fef4e11f420891a8935e2a12a24aa24ebd54478a515befe9bbc3831798df1673b103589a7011a019ecf20ffd1bfbfe32f0e80555a447b3fc1b8c6295b0b8f9182cbd14c9759ec65ebebc82b6a99a4b49eee1fbcbec79a9d02a88910cf5d65e5688d337f23d64a8b7f6ed8e53400472124825990df151d152f4577060a07c5d9a32833721afb2ceb4c04444edba05512821e54ac4fae6adaff788361f078cab59f11b50d4128c6896e7bde75feb7e924a54cedb75d3a8c07b5dfbc59a34dcb82743b5fe4aadb04cfd5fda67d25a9db9daabc71d331a4773de740fcb22947e7a26958836bec72b50411d8023609d3e1e25b80bef9ca53344b08e97f3a5443cf2ad0c1e40d6468e8106532e8c03a0001f4a48a98c1b337976a89f069e6bddae3eb5a27a2ac34f3e8b6a38b54d91323ceb637bdca44653f703bb91c4f033727afdca29bc29640321b65b3797adba97b972df08680a6596310ca428a4a206e0580dfa46e706b7a9c9137935f266a99ae4afbe0a931766adc57b220ba9278d485d22add242290c691caeced8cae1b6d886d73295559d0deee5c385e95f8509030f318e0604e3e7224bf4948bcdeab98dada9b118ae1eaf8e2c19675dfb8c851700cb3c6f883108c18464d1913e1da1d91f2d1d89fdb6db05fe9e7245e35f5b942c23529a1c8da2af9049c1b6375a79ad84c89a596922ee84f466b279331e2b5223c62204a68a2bdfda8de227ab3fc65dd249348181b7aa3dd0ca17861d929270a66b9aab3f5780c66e5f6fd9addf3657ead3900221ba3d18bdb67439c6185dbef6e03239a5dfd85c8bc36bc3283a5d73735101ae46426726ce33435232baba7a4f53029851d35e071042accde1ea7f61159c3209b60f1edbf56b73aa17b46dd4a9b88713f0984c26411f343789a3ddccfdd1b708a72ddf45b8b09f1c7d223902d872a120f73086bce3c273784ee4dc4dab59a6f265bdbc9d5762e0568a2e2d755cff424d061d60930b0cd3c7a3f506c4b1e65d8055bb981afb5d5a3a6d78e3cab615fde2946f31f10120124b6e9aa4622b298bce2dfd78c48d7f7c067895574328116a2ab74992cdcffee30c8e4a5a46c089c1b4126885f8045587bbf3b308392cfa8d968aee1652bd474f02ac979e1448feb663b2e535b29d6c8113d0cba2750f9a15a5417b13aadb618ed3bec3307abf58b74a2aa8b9cdd2e4de81ab3fb3fa1f0708226630e62d5796e514aad00232f95244634bb0e0ddf193db6334e871fdf6b2a579f4136a1f4496023c02758900a0d532fa603f0e5a230ac93e5483e26aeddd9c312c763c7e012d823ec3430f13e7b9d1af0535734a0c6a747900900276e483a2e19579c6913f1f2d24f63c08ceaabcce76edb968401c1f57bec49b54ff2a6d091a8b299ce604c705449dc5d27d94238d4f22bfc8dd28126a25f13b4830ef95307bc3dec080317b52c7b756f65544be7cb3ae3a735d936a0ee9ea6ea8e77a7e7cf80709da411885852618c597bef3382f65b05ef2373bb3b3ef9587d9c51ceb2cd7c8c93df7c025ad94f9502b312ce6647d3fc1fbd995fe90d207859f106a0b73995cdeb5af1a01fe8e9653e023a07f30b2f58b62856b3ebe741e7d2b4336f1d8a3fa03627ea14c570a6de41e1991d86826568abafd8558e07d3bee2e0b8e057c032c86c46a8d8e3a3bae2b0346dc4c1613633eb16b869ec625c4f8bf64fff460c3ee14d51a347b0938860f7fb14d884e6759e0eef98e1b60e10ddc8edc450a7f6bc0fac592e44c1a21da4dad1f6cf34e7c7ebbf35c103d6de2a81293973f30511d46169ad12061f5cec8180ed6f7c0cec5c6ef80906fa8022e4b6a0a8219328d28e40ddda1466839c5c0de689df46b4ac4f45edadbab0576aa62e409bc28d1351920a48291eba3f121aebedc302d190c5bc94b3d19f09f8168e6afe87f4e3e17d008e963076438105578434848455041b632ce1b1121b685d8fee179e780cbe95e3e950c16be93d38777e1ca6ed97bb43eb5672e6dfe53100cd1073bf6415886df6c6a82d41c99c901beec32f7507cfe05d779edfde11ca60e6a505625f9119e9cdf55aca1466fcb54237a590cb2a9214611536feca55c14d43aa73e685732dbc1e87dbb9475b26b71559c807049e53019836bbb13910f9fd0cead4c2383854f953505a686b851cad12d957789e01ca0c6572ca485ff6791a821bd0bd9d8bf41a442200f71c0695a92a0ca68737e239629949cca74a8a1464ca4a78792b1ce2652af0bd56d9f4f8e7b3eff7dc7e1f326360db8a3719fce26b5ecbdb66ed2b9190323b7bdc7ffa2320b99705f6df862a1c6c72079c2e487787021a7ce832543a3cc327ae96bc072d50ff2174f4898a2ac4d3f389a235fd1c1c1232e72d140002e045afbed2917eed51b779f0bc73a1c14f3c5a9135a52e0d3f8b9adcd7ba6d27a6fd408205a7d8917b068efe7d374325a9e0f9287f321c43efeace0c8507a917644b2f3c870fe8fa90fefbf0ce4cd7247b5153226b9b92434ed422c2260d300fb9be1a3c0104ab9545dc3532f478a52f0a0da0858a4513cde17d17fa569fed936368c909fd594ab1a701d80ff9591b2af88916121beab7ed9f5adc8596598f46052511a8cda385861a44ae5be65be0e35a3e75432696a798c1b7895ad7b0b53d88b428a13e2e31ad273d7b97d738962e47e69854f71d95dccecb5e8f3c52d8541c17f5e8e86db03b26fe73dd1bf4c159b54f230b694b308efc5ab65cfb1cbd354907a7710eae2c84d3c9e70b71b3a935cd0f38eedebf3d65023ebd01fafc18d4410ddbca91c0494a3a0b0773f980688f8e6332e93ccd899fcc81330a6214dfc6ec825762e071291de44751375ce054a73118e37fa91b31ca84cd74259339334fe10a9ebd5fb4b4d997b1c81e701bdc09bf14bd860f63cb7b3f9f54ee1d5eb9d6a3a472061234aa8dbb81822c325f5e51b75ebd0e5aac6b3f31f7c514c1661daa3a9671e1e59891b0d5f0d2bc04e7ce4c646f6031eaf041cee4e63fe8c8b8f4bc3c7226d4422e0ea769af6a6bd28710d821e319b41164cb8c4026e64daedc4042fc0516d0f43aba8a6bb106dea51cc26ec2c5dcc4912516465d5cfacb3ec8db63ffb9832dc3fdff0c4d715d4f1b3db3c62a44bb5b33c363e387434d70d272f97c4322fb356215bb4e3e79de679658e811878fa5368b7c0535d25213d94ad2e6cd985039ba2b4e8cbeaadb086c3016ca5457348d30c28c48e1b662661f95d536adef26f05ab30dac90e7e83452fc195894c0bc1ac2eef32ff815f0dc2c40e6a3870e2b66c30b3cae6bd6b6a4250897c38bbb7336fabf51b699174a0110a3feaf42913a9627176eff4966dd59382f5d70a711d35034e2f997e971f516d707d2fb043f0027d905ef21a9435971db8a99d578c88e73b578bc80d9bd38227ffbba4c1b6058e3349f7b57b8273c4ff0a60408e57313f1ccda9a3a3b6c570aca1e21ec917e4af57c513aad4a919138a697fa8b2f980ce42fe962efada4d4b0c29091f633ec391ba9f9f8b94337c1c3d6fdead0b972c83e62d2350620dbba539e3ec8d970509daf51929ef956f858fd8820364c6ddcb93e03c7aff2da3ea0440b08dd4ea7f401c9f2ab34f9f3d977a343565d294fc3736d57bf501554264cbde1b6607bacbea215cfd16b420b0a6d75320af2f7c83c6a69773d848e060dbd2e2474629762edf1e7b2404f9eb662a570c4dee6aa6fa31d38f6e578959100b286064323a4b727203b76c6e05305a5285fe2f4a68a4d27ca3ac8e0c46bd8de8c1d0ae378f34f3996c2b00a124ef98dfcc75954aa90a31e2aa4211d757dde3a39db437b7121285d1935540adef2e933cdc42732a2657f5bdd14ecd371cd0d569c6ec6cf6027846c4d8f643835e168f88f4bcb718d1c97e064bbeba68e0bb57bd7b0fe637ad946e9443d5f0f4cba0d01179c433db87709cd980cb124ccc9691563eb6babdd081cb99f7148dcbe0270954b16756c81f718af07f2077384b2121302dac91bef8801b7d8cfb4d8bc00d4d01a04e11d5ef0c09df49aa52c1651f6e406f89156cd369ab95fd2f2cf996bb509284ddc0c23fc49279589637a236d2456f1ee2734c2be50e90892b23faf2105f8cd9777caa5abe2b258d7296140dd7faf4a4f2a71b17f0be905c365956b872fffd706edec6eba6332968812faed7515afc278c0f58a90a9bd620bb4b477bffdc4a33f1cee825081675ce3926fce70661f93319e460b774caa4cb732e9ad7bd5ed310d849e2bdca315d943f18ccba0cff8aa6f5b931203501c6dd98a063e6c74b0c7fd9ec4f8c71b67f972a780d0cfd37ca8e37c446b1f8e316c68271921dcacfc026550b9662e61fd844e347ce10006a4f8fab6fa2e7a014ac0ffe91e9595e58f2326ef673e36cd926a6f21c4bc3dfc1fab4b6d3aa189a22b81c34832d1c5ec8241f192a2c30a78c02600136c35e7af155ce5f954fb80fb8547962158789d9d02a724bf5bbd4a7d65bc9636dabe56a5bc298f003681987f75e85f486e7140270b5cfc01d22aa76b76522a521947d34381e30ce7dfb4cc87daeff21ee881cade383da7a170565a33b443a0dd3e514e53e285c8df8b7d789dac041bab6de5d7c0114dd2844c1ca99ed50fe9e13fe1c32fdb5a162d90798bd1d0e81dda7c9f8bf1a5765a293d41fdfb9fc7c79e0469280e12dad848e1c1fa17a4d86cdc6ef35f259581f4503b415492a0c3748371b2ff547a30de0b22d191237842db0e3634de65d83792b1648656de73ab6f3227e14d00213a00436410152b5ea673972728deca80bfda34b7c0c01dfda88c586aa7e572afa392f358c7ef9e34f4a4e104762f47fd0c26039dae10ac63b2fc465555a5927fc4edd67d50f53ee68164925860b84771bfbb8548aac93d14dcde58f80654505ead4db7d705ee7c78e7928f3a55f1b971a320a5a0bd477874ce5cb0d57524cdc59ae73a04452c4b244208612d2b8f54026a44e6d176acc26b3f07c670203139edbdb77c5ba9efc4f13a235963745f40f063e6985989bdca36b9491efec9cd8e0faa3ea8db5eaa6f3c1a01f5402e63e4cca3152a34902b49a0c75a8e96dd23ac64aa902ae796cb1721e2f6540124d1628a2bc978927d723de99cc581d6a7a3a083423b1f4582269bd9414913e8ccea73fc35b7b0f66733a32b18fa15a817289404a62667ab7bc2974b619885048911e19c5d9b1dd277bced9910b58fcecf5ae72374675e2d17d8c930255d5c9260b4a7ef8b57a5505ad851a630d02c344c691e7dc465e220adb68531f7998e6fc354308d7542c24f0ed860fd765dd794b77decc10bf13bb40311b90b8a66292785668378ef130737c53f401788a0cac147984779360ad377a33242fdd8ec146996d9c2827c22b194564129b19f12846842e32d6412a574f21689c95acf621353e8dd6db9a916ce94ea74fc34e5521269a5aeb5e793b4abccf35285254809825036c30de9a804f500d3e60a545ca8652f8d432b227985f55b3ef2947a541332d1f55eb027a347ccbc1b52660cc9e189533c3ef9e4f9d76815d801139607a74bf54e0595537625a094ef772d54f71f87583affd3c2f41cc07177441e26e15a7d8a99aea4b37a6a3e2feca2d86dec96043b313c65aced8427f704c4ec60df4aebec91aa3270580bc5bcf0b65e3d6974316d22f357d6f8dac0d485972619acfa85ad15055c089e1075e8c7412d0df76a4d8fcf8e79401201f93e3ac668e8afb2110d3fe4623da6076f8a898e5e12f4479cd6f75b04767473ee17a543a4a4804a0f27b16dff9ea85f4ea8354bc324421bf8bf10deea199c40a4a4116e40c58f85786f2de28d0f8442d2fbc97883a0486ed90aacfcf139cf592f4fee13055f8fe647856ffcb2ee0fb2298e272f2afce740d197f49f6acff40e3bb3c5284a42792ae8c210c0ef18d2038d770b3bc5dae3f1e7878e932b6433bd09c9bc9f11135fc68551f1d71f700a700dc8b7e2cc5b53d9194b1d9ef63ccd3cf44f3e1424a93d94b60862bb5858168557a53040a02c77e13878b83873e8a85f2ea9f8fa711b2ba6dc1a328d0f9cd65ae8e3e0e82413d7c7f4d9f6b6bc40d9193aea8e2ba842559f83e239d9adc41d068ae6dbafa7cba464a96db4f366c13b0d2bf93410f00e43330eb919b411827394240071ef31f427820734ea5a3778d1fa7491e226ed2c6edb64b2ca50a3d08bb66fe768cb92c21c2d66567b172cb0373cfbb29377fd2e0025dc777bddbc8ccb4cf280230bb3d0ef42b191c317ccb532bf8b3fcd0e84167f923394e93fdca84c5db64d9ef5f7031e520560c33d8c9b04850d1016787bbba3155ee7ae7a6118087c8e3f07c3a1a4bedc2bd0e76bfa24a536784cdea51dd0094d731d56041114ded61ee05cc189a2c64530052d19b8ea9b048423f7ea0490d94c9e34eab951477330e02163f72091b0024cbdf463d8eeb6ef522c975f7cf0df11a44a2798a42e2844577150bafb7289c592995ab5ce37e159f85740ff22ea866b5699520e180c24844b96f95adf807f8c4c6d8aba42d1afcd31f56b6a30da1bef61148cade73b7ea4b30b1b04f877501e7650eb81de3d7eb27ef7dcc24b1e368ddabda44b3397cc476e3e0d2b1ff95a47b4a3e93b507222693cb5c096a7af2966c8dc6581413bd2ed5ed80c172bede811041236906ad9fd30ecbe3418437242ecbf5fda2c4c1a21afaffbecc2aeb31b78e02ca12c1e937132459186e8ac97ef1b014729a63e7ceac14365728a60fba7d661eabfcf72ff862c61cb7066bb5f24ace25bedd6702a5867f0f76b2b50982c42d853d59dbcf656ee4480b1df80bed6c087c2f50216671d89b4e6f81dcc31e1e741e2a950ee2edc0069bc998559beaed5f3236733b3df02c1f0f5402755b2378693a9b3ca16328d6b48b37333909fa4225de02a06b88e8d68163ba4646f58f2484746086318c201fa52e524c60c920f9209e6f44312aa668387628796e00842ff0ba04e932a0b1cabed222659a5274d09707ef16eb321c17009b84eb87543241eda210361e0812917fbc86165b6e66dc71d7912003c60ed248f505de7dfc60ec9618dd9e3ac48dbf535b600985f92f64a581fb5923afe11fe52450aae9d851f6bb7f612537cfb719572c714470fd45883e604f6bb3cb84ecfcb204e37d39ea654025d693def2301c78d8f02bdfb3d67712fef738681f9c0b082806b0b09592f57e02f79fd362856990067383d10be89ae0687c763d42859b7076de4107782c84a8828c57da67d68160a3bd43d9eb3d03e9f01cca5f2d36869a33ade8de17576172186b55b8a6a3935d8f778effc8317e7405628337953c5a015d3c5ecd64b542dfcfb1bdb27d507bae57833a1e587c85bd70d7580e3cd625f9c6630d3c9c0b5a3e73ceebd40e6d79ff0f0ca63d3da56f8ea51c142c7856103e77ad0ad43892a94963cc0d49368c15557aeb09f29655158a6c1ade447e9bdd7eb34c367c900cd819269a9ce278523c97aa09908c27490ef34502e8e9d6f785b57b7852714237a278c9339e27f2bbed7f30d9f92c916ddaee3b6863c60b2c0c62447659b0d22cd904dca3dc61ae8550dba0e9207d57085bcd17f8a7f30ec3587fe6ec5c569390e973eeec2a3b43db496e38f0124050ff8a2f15ae9ab1eeff320426f700dc3a87377af7a9780638deec646a4b37818dc88945cf3ffef0e45023ceb4aa6965d57c83c7d364de086f32e36333b169a4464b069cbb483ac25981f2b20886c68f76454ddc004dfda70c757afcc994568c813c0beff30ca09a5fa209393b127e9df515e737080d34993c3269bb0d7bd5460b207aceb01b8dd849238267a139cd76d70ff188680ff9094800f90dbfdbbee35d748514d177ade06937ba7b429adc7ac4a1813cf0d08ce908844e70db16c4b25802a7427d3538cc4b03ac81e719217e7724ab0de464b6fecc9d59cc1335f63f6d2616619aab1ab5f9a5bf356575d0692570a8a938983b2657a2c2c90999d3c0ca3c07ea2b7d66bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
