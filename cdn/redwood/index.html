<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7bf8b752fbec594f4e7cbd3774b077ad837a65d2d31c79317aa8d70f78491fa758e2c1ee77013e35196a767368a125a828a8f164bd0ffb570ad1b701b191da6fe1e20285fc40f9a45ac41eefd483c3524724edf194857f34e35cedbda1c7e63dfa39457c9615d0f5fd2424354d7a908faea042cdbb140ace1fe060694ef295a8ca378bc7863fd8b281b24864683b06c5f3230e9732a6df3289b7b6284cffa70275b9ac4b12568d43ee58c57038eb9d1adb31deb0f1a989a20388c9ba0f187de481d55f288371691e5d83350d855f499d6a31cae0cd1d870f85d7ae477ce38304d3b76eb9befd9ee653f071036a7af83282e226a751ea23974e42c62a760132832774903723286e5c4f6a4acf20c1ff4f0dfc39f3125491f993336bb59ca61af3ce19d38646450dda02aec62302b3359527d5e91a137a1fa48b43399bbdebe048007a2f87d4917f19263602654d185facd4118d32b482148670160f4349573eb3308ea3bf1aabc3b91e26a006872fe5f7d93a91dde49b89be40516f38e02d5d46d785e3ea09a817fa3dd065b8cf0eaa7b22274b7b851efa9275eaccbbdaa46cd69b5e9704adc6dd642ee4de259be0ad4454060c14f9db1dbcfee5f860b4580f7589be52ba14564ff7124d2fe9d0fdf31c992b057ddc34668b5c4c0b4b744589fbe12e9f560c43761e95bdcc54aaff896cb5f013fc8cdd89ec4986a7ed6f3214efeae710a51874c6ab6d029c8c1130971c0c56ae0b1af1a9c6c41e39b89eba0516af20fbd5cac81f878d281fc8390ec5da4f7daba02acf8e0b526d2995cc25691f3626f1d6fec86aa96660019501e42f0357a13a33582e5d0c4be04d5aa8afe5e7edc0a02ae6b812a232d9d8850861e49d0efea23c618736bdc14942b1e6f7051ec671f988777f397c8b923d1f8d0a50dc8be5e253be5d6e22916f8417bb87a115cf674017f985fca9cceb946d676222b6675fb5f18a794b6f8ed6b6d777c719971019d31ff2c3f8bd254c33f9217e667730cff1839a030600546f42a5957afbfb0723e61bae0786e2272661a0d64a773e76481da2fb9f92ebdc5bb059091d8781e423580d285980d9dbef3a0d5532696726d65c3fb1a5b60936ed529d2e44bda5817e616137e8e3a26dfcd60197ad06bba095ab7cc8bc0f375b177387d4d5e9933e94706c0574180631b2755c8dce662c50587701cd91f2470e53afac46f29665df9ea6d7bf03aecc2456df8cca4fd28b0276df4c5bba1e0039bdf8b47e44198c2d1c3325ccfe248f36a2430626f9c3cdb5f337851f93d7edca43ba92299be51c99a8b023a910a183e4b3144b6d84b8abe6eeef13ecff96aa0cc002b85face101e896daf4b04c4d5f552f75b20dc664df44a00147510f13552ababc5b7aee3aa43939b429d4c4e289b42ebb19854ffb1e4b8159460ad3e5c4e2ecde0d6b68c400348643cc962e260785fe4512b5b27b1ad197b9649ee1c260a8c819383f7b52d36f49ac31e4f9020dd1cbfe331ad66be64bcc5bbeeab054e5369710f1bec5935c6749c096bed35aa079a2d3eb154ba4f9207d1ef78c5eba0eb9ffc9da05bebb10294964676312edca01c767763131589aafbdb7477215cb6686970a76572257eb41b11bcaba94f1a2f0e023ea0dbd30fa78bb0c4f10b8bd2f86604cd66d4ca2e6174edf5161eac7a3cde378607aebe31439280dff659cbba37e53071907698907071e0e8aac8af510c086f87a03cc4c9e00bf499bb2041db883550cc442a5db5c3507022773ee84529f0c66a562404c1998e7c7bd0f51a78b25373a85a41a97cb5775488138b31720e3de1b5999bb96524537ee46a3a15140fe349eb9e05ff2808bae8de0ee4c1131fefbc34ef81299e1437f87394c31b02c0bfef12c995c961443b3efa185771222744066c300d1dd96762fb158324b6ebee066658fb7e398379ecd63028ecdc06b0bcbea937bd2f4bd1101fa592c68ab3b8b12ce7df5145275b443fd05f6ad1629eb522cfcd17a218827c658c8a7f10f57dbd205f3e0c541c1d9e44af3af835c44c797dc3a4271f71120d86310e8ba043f8fd67cfd3db0b6cb0c00ea5cffb7d64bce0a9d04e26a0b784f478cc81e97bcbe547c5bcde9e09b075928b374a16123dc3de67ef4740c802cdf4e8cd340c263d2581b79d4a0750ce69e95ed607566d63c6e51fceccc266b4256cc2fb85f09aa9317d77070def35f28179b7f9b6b51940193eeb6afd99b21889dfd590748ea68830572d4214b85ee76a0c69b086a9ad2202a7d35ab1452755e1fa1939c475066a3b209ff74d116c1a6dea430cde2f3b524f3c58fe08783bedc8378aa304da3a0fe1c997740de08aa1a689b051ec50383264bf617d8e53527ef21ef41a5e7ece0d5342fe49fcf68e75ab9a4debebf1fe51ec4253f7fc49ad9503229db4572b63e0e6b126c38ead333494cd7af3e57afe17660b8c286cfa3c6e8a8284c8004d402b60a38759817fb37ffb383692dfca5d09f6fb80c08cd0071605df48320ec657b4cd2c2fe295c9c0902ce3830cc5c158245ce413754e9ce6c757efcd11f55dddff49f0b649d865f7d577866019090fd70a169ebfa78d476228f77af15a8c803170a1bfb1e565e8eb29e110319bc0a6544c3d18c83bc7cb71f6a6fdf59582facdfcd84ffaecb545d2c995622f27ffd7c4f5125eb242afb36d3fe9b39c699d7ea7a5569a321a89b4b7e901cc088adf3be7f19deae6bb3d89c8f98826febd6982408fd01337eb9f0c1a6e4313c7fb027a8dedbba2a5269751dbf59ad7428eb325fa45e742b31032bc45609688f471df63eef8d47c0850c78089e690f76a1c8f8c80e86e2e87104c0ab0f1b183cc5e6789d257ff5a5f77f517f073f0daf07e136b3df22409a601bc9d5623f495af7fa9ea113b57813b0bddb5643d44062e20feaa27b1308799fb2903c301e4fedafe220af7983113241a3f28e481412da34710594a933701b39c92a817a025c0f54d1efa6254155f15473ce6b6b6520bc83c8312d252c523fc4889b3d2a41e7cf02bbe92aba145efb12f86c758f079e896972e97b072bdd9b8345072e67be535851a0fbf08d3b38a17a0d91443ef14222bd8e2f61160415b67e2212c7f5d31da1a6ce024fb7eb6294374003ded23545456e0bab15cb640bd88e740de74937f462cadb07bfbb4b94c535d385c0fcd14b144b2ba3e71202563633b8a086b82fcfa03455a07de810326bdeb503615f52f7adaeb7b0d9dc0941b63fad177cde99e5eb092ee6fc8308aec1be3d55341cf531aac8a4933c7396434fa22f2421035e7173a4276802f93f2c9d249482857aee0c59b91c5f034c17ec2360b418bffae98c8a8ea064b4b1ed1e82ea27a58f038c28514e28d6c683e5a5c2cd321dc0239f8f538335ddfec65f84e0d5621c8ebd861e59b8765d991478cf34ef01f095cf2e3b7d77a9b476dd17acb3cab51be473005038738c8aa426cc4e27c2a1624e29f05cc8eefdb12b16d6140d58e9a49d30005c6ea2b8a072c554258aa16056f771383340e318f10e396e7519082dd58e614057bbb3483b613e7cb5a73dce43e6e8acfa3572d85ca775a256d687f333eb718219bc6e166814c9e376b561d153c38d58791565be4fb9ae38621554e2b1a955d84fed2977176ad636fa4fface7f33d1d2e7ed3b31d18ac6dfa8b91bec8ef93347bca499e36c978c5dcf531ed84bfb87224c052ab967f4f28f0cfe7f53e82b4df1eaf6178a1b11bdaf586a71b6e264ec9196900073bbcfa36128c3f5c27883812da0cad3edb73ca78c92751ec41d0f0b89a0a8ee71443c62999e7fea3aeeaf7c3cd9aa5b76bb9eac5dd64a6970fb8570d561f0a7ab2fba0dd8b65b98402e41a29e3f268c583ee0a35454fea72f2d80de3ca092b78cafbbdee1c628997c8e3bff7d0a72e28989bb612f8e5d7cdc25392a8dc105094c67f3593cd53fde9e3b159d0c1b302f13b8545ca6df050730f7fac3c640aa29da8637611aae82e3ed2cc9db98ac47e266644df1b1b9ff97b0d0c987f05ff353b8ac00b332bbcc52044518e11f8c76a9c7d373c2925bfa3a6fdcaf5c5a7bf64ec7cbae1d6e65ccbc1b045f9357830412fec4d4f2e283c383cc7009f7e926f9b7ba82a11ce01ed0597b18fa7a0fbb5902a40390be49faaeb7473d6142b0e21eb43756f4a93994f982ecadaaa07ed25ddd08d3b0d5a2b5d864fa54fa3ad460613118eb32509f6ff9898758b544fd1b9d6576cc4540b929712eae5173354f541a953806f7537ca43b61105c620fcc23a9355613d9d7a0cf2a0ba76e6aab1de56a17841b40c8d6222ef2e6027f7f0030fa7d727324e6f0d39b18790c88c03a6fb8ca1afbabcfdb1dc3b5bfc8b193adacdc26bb519d36389c4f293f6186f7002f2629ad06026166845ebe7f57fda8fd0ab5e59c84a8383afc133a1e11270df463460dbc3bd6aba5b45dd982c58d763cc7ad280fd895d7773aa4e1257fdf655382f9aa24624d368dd5f8f0d5a3ea4c166a2782aaf08a090ca27feb77f9510262dc90507c29b2753df00eaa6571cf94833a8cac65795accfc2247f66cbaee151b860b0584491564c2543051d5d891533616371fac1d94bd2501746216db4df89cad3e829e8b84c3caf6b9f63479b1c05b75884472973fb4dbcc2bd7a465f430eac20c880f25ea150e9c2bb14cd18448d1476d90ec8c714e3c23bb5d10c9a74b9a6d68368830064a950720ae2aba7989738e5bc10ff3bd3fa92a2bb759ea05e17af6355ff808fde3bbb7ac6d6137184159b4f3e175d62d0a3ce46fdac815a517c01424072a6128b3226cc79add2f3786325c369f0202877704e809b5542ee55bc8096cc4df1c62b71df1b7855c32f3cc11e3283fa1d6707f489efa2de0606904b7af6d605e164c4fc67a3b83d38da1cb1619760c8df145ea1a54b0401eec2a99371f01df45ac1ba038bc524277af6c8fc77bf26615f9392909e41b934a0e114e0a257c4b01a7386c0658b0f1aef507ad754ecae0deff56869dfa487a7b2e0f39c0ef7a8e06b40c173d74c641228ca522fb5d2567217ee50e6fca16ad9ef35cfa309c0275f7d0fd7051b967bdf046902f57ce540c333c7399d75a1e4c7c7193bce06c4ec0e7a4673f85bec4d687970b48dd81a44878d575dcd6c0832ebb68a7d663af4d8eeed8035bfdd9bddc969065e441e52dd3176707ea2c9b667d4e4f8bca1ba2aea3e3bbcaf2626e7bfc8b91fb8ffe29c1f9e28a4a5a1ac5800e0ee6ece4a8699a3a3c0f20312754863cfa3410405f3dcd44a5712931ef7de63f09d8377d07f1ee0c87dc04298d6a2ae3dcd2ea3cbf374993fd0c773e475dbc6f6b1cec73d91c3159ec75c3f1f0ffd602d88864ff3226e7966ad2eccc505fa411755266e20f6bdcab8dc766f588ea6ac12556cb6e5d5c6d83e0ab8e0a2f700dfa24a0757c92d2c1571213e83ee46ea61000a764672d824f3dd1638e3a4cbd787ad5a50ce810521ce79ed9a6f8542cf002fed7063899a5fd571c87784cb577e85b7d9ac2f224408897464249386bd6cde808f9cea3667c2faebb63df6730f0c536230a7a0cf8525900dcda56ee38afe6fd8c79a6b2eb1b7d6e1b16e90f72a21b4343284fc9f2abc0af15c74fb9611a48045edfbb940621cf168b28fd63f552614a084b7dc131b8bc140057f0cae141d7a97ac3b2c9758e13925fe2b288f2063a60008efd55df5d2ee4f9f47f38661187a40c1804c5e7046d4579547fad5b06e16292b22fc8a1c2de90ba109ae4a0e1e0f3e5f7da2d7cd7c230c6eac629f9c637f7282ea89e70f0b858d02e6bc646a21e128d99f7392a66aa59aaae8d33c3bda529fdd5754b399b6a408eb734342f8daf10defd294852bca1e278a72a3a63255c0a0e894f68a6f0f29f4a040e40926277ed79f95eac1b073c8943406a267e7d7d16d1aabedab5b2546705b506300d36bedb9b51d70224ad41fb8e7817230115c91edee602dd3b394f9e9d55638d8cc5453f38a749907a4c8246a8ce66a1797a564256ade156f572198ac97b434ea42a92b7bee14d9d7906fc6caed9a4a2cb8cc726205080399b9f6303b622785e8b2bc1fba646999aa36fefa42e92a0027b9340dd045c720475ff9bb8f2f8d68c4bb66e05bc65733b955853f70752e1b94c51b4ecaad70f6032c08700e19284836afa5430aa734b6c40e48e108f577f3623ab12676d82ccc19fa86a9e71b09d2a648db037e6b58e38b79bfe7860756c75952f205581bbabff5c053541d270fa5ca140f736f9bc1fd07b467d8a0afddea6e64a2857d8a486af66d2731515f54a54e56ca336f58d53602999b758625817bc98333f3731bed741a7a3c18323a9224b75f4418f1ed0cd6ace8813bed99d85d85df2137b6e76d199f8d9ea1c2fd38038c7b8a6b37767b7d3f2e290ef4407d019576e69c90924612e950d52cf496cc807c42cac47b2aaabcb50f64eea93beae159e20089099fb5926cfa521b6f2444122895b38013f40b54159406e8d48f71523a35791f8fc9b10100405ec162191acee51504689face30c11415bc9080abc0d94232dbde1e4791be353d665f94d6549fe30bfe13fa48349498d2598b18728b43a77155964f4de8cfefa56578105900543c69d57ac7f9224d17c9c61b8a87af4c2af54883ee8a42bf24d1dfaebd4430a01adf594027e241e03f95111a8af6c3c86b8292ec6e86ef0194585c14b2c8002a3c9c877405371a9dfc1d60dc1ede4da2c6f31664ae98832beca8138d20adb5db1f3c2dc294f29a5d2b5238922f29aa0462b09dec943d4195cc9d3088cef3fddc837d37351f15176cbd478154c40ad788aa8cc242b7d92585948aee8031d790ad24318d1ae97e9f8bde400d093b936ff3db70f3597e421503a32fafe4b940a8127947d4ef57755280bd8d89b243d75e3c0c8f23b165d944a00d839bae701da7792c47332607238eef05055f5fe253585918df6b300cc63be1eab1888c09b474201bf762363b27083c97a7a888a96764d304007e30c97e236dd92b0d339fb40ef0f860aa622839a9712c3c24e731c8de4826c5b7899a00d2240edf715d9dabc481d8cef79d076b5d9e600ec8c882dd4f69f5065e373331e9c6c1cf2d608eb76938a24aa21875475fec977d76d6a172da00a089cee616ddac68f52b5fb9830ea394a173bddf75602fd6a3faeecb291ddb9e27f0286425de7e19214aa1eb9076bf47920f1e903a44d25faffbe527449dcab381ff7597277f989f66026776f0b53ead81096affe4477d0ab4832b23299476ea9fbfbf74a4d57ff428a274d08bbeab0a6051e78dd46cb20cb7b0a47707fd6c45fef0a1dc69c809f3c8613f4a850da8e7ab5a459383e12e62b885c2af4785f67c2ed225b93f57ab3042b1210188245e1070d5696dd4e16e527d3e9b0343d2f90638588e5a60e08942fcb703d56e820836a36356c756855938edb872f9b5d5bbed72e89eefd9c4a92aac4040109b60738c17776ef6827355119545ac3154c4b7932d91523a50247e33f5e424d2350ecfc5c61d600a4525f62e5ea4144acff2ded7ac5fac4873f2c6cfe9ed9c1b699446a758cb33f2d4a4e999b52a40cee3f29607b1591a6e644adffa0679857bb44badfb07257623747c5f69b18812e6a553e73b95c5bbaf30d751c22672960e0d019aab9c6bc24da755707be25dec6c3b5771c2ebe5bd49f362ee2e4e23d8cda1925d6b718d002259aa1ebbe7c04b72c08a636412f0f935227bdef2ca0903cbd1e40573232e7138ea6061838e2b9c0a24eedc3440bc274f4720d1dfaa15d1c60ac4b3e598020db0c4ec04e5882198cf416dae95788f8d37522f6c62b457ab1308389035c7be8a82f44a4878e2e0a3377211536ee67d4d93c6bab70a9a7173db7d4df04508b18b746f5ff5491ca51ff381adbd88150b86afa49b1f345cbdde310dcb589bcfea89dafbd321fb19c5a75cdb2406b0665a2680fdcc2d0b6989256e3591efa05ded2f4372785d8d80bc8577efc9e6bd4a29cfa5083ca20f91d0128c3f8c3e956da5ae1e41133bd387ab0e2183c40ae52fe4cd29963bec8cd9f7d44eda40e72e58e6df4629140699a1c555a57993f10de391cf031e720557c5d79c7fb64403292ebd86852d3d37fe85a0ab2fbbafe6bc4aafdf11f2552f8b5fe89a1a74076a6814855819e58d21d10468dcc65683e69486774b319679699e004e6f974ec0f5f4c067f1ba782183f9326d1198d418b63e9cf218fbd07415c476288a104c57cdefa24b4a5eea7d26c0be556cf4bd79c527116b408bb301b1b310e58c3f2f6d79bad0776e6b1ff5b75f43bbb420439cf1ec789dce4ac0c564fb8f8c2e0a7f05ea67f641550925c60be8b6885603680bc8a29ab040e8eb5a6b545a5660965c5974bebd341e76d3bb8231d874dfd62febf752982bf0810d53d02fff2d7f302b28b20b5b9ba6e4867da8fe53a7ef2eb8c78e009aad1d837cb006870c743ae576eaf7c2a41d3ad10cc3a1f80d6d21cc41e2211e2fb4dd018e78327d10a96b8a840702a916787685012985155c4f2987380ae0d482a006ee06fee512bc107cb3d516beacca4e3ce5e4dd18118b211c441671bd33a3285b012a59ff17cbaaaca6663dea0a98a2e1b6ab51f3d1ce469835c1328d90a9b0076c2a8ca8ff5ab8f6feae5447a3486a9415a669c9c7fb4a01b939ddcfa3b16f686144634d7ded1bf4f55bf96d6fcf5c5b5c6a24c1040f8af909aa0979f28186b10f0e6883788766c76e1a097a5d848c30484a7fe2924b6e7a6505e93ca1777ab6285b5429240df5a9334d8aa93a9df3a98079112e88ea6d30aa1896f84a490bee83378efaef4b11d5a20d9b167c2a6d0b8aa8de80ee48ecf2b0328bcc833947b6be6212f96722de7e1d9b6099acdf8448b9576e41f33ebede9308bc2f4399010098c66841ad5ceeff965e1b5a64eaa00b51524e036544b594f8dcbfeba1a9cf1a70af6aa5b45ed55a1898c58ea95e10ab518210996f0cb1e9e1495604ea224a55c1f831d486149c44fa2b4a632f00b3e9a3fcd9c67b450852b4ca95f58f63356d3d2d09f5413f49b9a5e0ddf427716c104627304b4d9fc297b3cecb1735241bf1d41d7c22ffb535293c3f9cabae0b9dc45f7639a5196369e8cadb57bde9882bea73658f9a2f6d27c29eb5836d04cc91891c4592ad947c99d2bed538ca61082f8aca024b28f01205a20eb359c07c9c4427aebad49a81c28a285c3a8602a195c029191758798e19a640f085f89e53e6eb3e7473cbecaa4a13202267b782c02edcc9bb2d83b3a4e4c129d68ad0d15c7fafb4af7fc53349a11c1871c92ec9324fefa9b7ef747dc0d9b4cac0a9cf3c6ca447e138013000b1ce2cacff2a7c0c6b31487aff5c9cff22d411f27ed0bad79e3ba4b499c0fb076ede384ee0b33cac9fc96bd95b420bf00e95cbf167e5840402cc11bc675528943d82175e3de929485be5d81197b49b84ad91871ad92b730475f389e5dee506afcb6a91fcbf6bf581cd042725e77d8739fb4a952efe3bba28428428c787ba616daf25cb61807725349c0d788cde56f77af4fc0543b98a77746d874d756112b240eb3d467071e7dd3cce8dcf65f5bacf1ee1ca93125c4ff638331bfa5ae1120e76011a59f6230105ada626a5f05f24b1f063090e9d894bb38933190b1922dc0886bff26566e3b64c6cc7ee0aee38444bf6d4c1d6da907cf888b66f8386febc3fddcb5fe1ed1e554eafd09a8c99739c9552b3e4c6f81186f9d3222c80fc039824bcd4aae0d40868276b38a259c6db974c2557c72109cc0f2f5c40edc2ac2905be2b2bf65f11dc49c2d827a6924bfae329a530067668243f3538542899dd0ad068c7e450a35c47fde3e925f3a206c66884f07fb947b6ed21f289ca6cfbd01d2281b8212c34379424d8dd5a8040d58c120ff12e9a9696125e87753245b5b1fe498ee2c00bc5d923ba4c63cd705d3c3c51c1a32314ca50272ddfa831727d36c7fed110196661303e92cc5cad183e3408bb8dc509c61b9dc48f3340597e6b6b624a783b7020713af2b1d6ec0e6a876e18fe94f65ca260ece66825a49ff32156041c12e3578c4c1b736d9c0d5c93599948b98d78f333afdf9b641eca76daaff3c8784e77f1195d9b1d72610ac235b41d75deaa612776a67330090bc51617d6f36340869d9414748bd0c601a2faa26af397c8713db71e4c5daa5fc8f096e1d416aa418ff6f18e85d3c8ecc3a712c4da50a41853a7ca086fb74ef2c0edf098459b88a1f40c97657ca4b7fbcc95065d8a212c19ce713b739dc0ab37a08f07c5b3c1814d62b7556b46ea7aeb505d472ae1f621546a025f4a60de26a4519df50ae957ef7522d66870fcd1f2f3d1a9b5bf3e29aa9f94d8218c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
