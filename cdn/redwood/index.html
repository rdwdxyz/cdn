<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b789f7b9e5f6e9bb8ffc3962be394836582e222f2cb23170918815819c0c572844302085dfd224f7c1054473a3d6772c91343d788b8536fed8238cff32230924797cc41389c3098cc62a1c2b4978f11b3c964ab35f3f1053eb8fcc44f52cf011d46420343d5f59764a43194c11f3b6b6967151afaa3733bb8966ffde149a1808361ce0157557eb08241c17da9174e1f1d9c6ac5a69f3fb66277ba9f6daac923da11ace63749c17cda5a85e170508e4d91abc1ff38684951329429ead9a2b7cf3a8c40347f615bc2b8edbfaf2a2bafb6a3988016d9ed9db4144f2c6c488b9502a17134821cd449010bcfcb880199c08305bda8253da8a4864da991d098735755088a4ecf7e3b0ed2e74b64bd21d717ac82b29a613f3afc4600946d201fec73c734553aea632d0a561f4961706d6e0d6f4d107b1789a4fee8524ab4e8170a9cd254214aa7570b714494c4267e6134c5f5bb13f3343ecf770d30eca802da4e29e5034d51516a57ecd09e4c50ced98794a315dd4cc49dd0d8ecd36d4bbe7906075050543f96e503651fdddaffa71ee190c37438812a7f9dbee32aaed5ec7884ece8bed55b35eb3ba589e4da8172dcfaa41736f6fa55251ce38f8ea48cffad29683b1c45411a7d4f4df980b1ee446b159abab9499b5c5a221bd9d7964f4de204cc227b56d35ff6f6684833015bdd47f2f3705077054d72b3a7cc8ce402763d9c76cae501931cf905867d0e81ae6d797ac7b9b17b47b8de0b1b73f1a6f3a8c1552d340c8d32d2c4af0bcddef5abc31f2dd1039e18c0ea43efbcdcd47062d0ec0e5b66a6210769a638868105ca68397256191d4f84fdbd19d1b9525ee3efcfeb2644771fa40015cce0e7ee9f0dcb2fe0f576e4ad3117bcb4978b818980d6b00a501b23eb3c1f4507fb55e3cf81d5f15ea4b5417ddd833251018f4f8a46fc55bdc093f2414e0f1f370cb63aa2b2c4f127592e594ec65f4715a9e201a68313c227af53f4b36f35b70077834e245e1d9f1c59864bbb25aceb3b4cc4fb0c3c4823ba622d029f9411d8f2a773c221f31a40f15c2b00e7526567e862d431345d1eeb0a65c01f9de3ea9079a91ce3ff088ec217aa2d1890ea68688b80f4c9eaeaac3b01b0b6f3da2ba7e9a67a0f78ae3812605311a2d861103db6df7280a18e3636f9eb0ae6bd5cfc8093e767d8c2b3368afd10de7f7d5ec96fb8a12fc204ceb7deaf280d9aa5f98d0379fae370aa9d13f6aba3f89ca4a68bb12a504f13c172a193361d58f8e1c356978bbfc71c714514041fc2aa6c8d7db22ac073568c34f44cabb07105154b309971e01394014b21c3d72f2c07bb7117da16c6f65f648c07bb9d77440217aead02179dfbdaa17e9cdce12c5138b1c148c4a51d2925142ca7dc3c20f43eef935d87e650e44a461f0ab82c675d1d2c4d51fa7c26fc81ac4b30653d70aff6fd05d8965cb58222596653e08f017d041266fc2a740b7e3a65dbfe761bdd2ef06008312d04060cfa3996589a37d7c07c0581d2b7f772ca4209a6e0680be94935f8852c3fd1c35b59fef20d2abeaf60a88356751304194f1c5e3df404a6d9c0de15685e6a8f0f8114e93d357c92c342ec155aac541bf7741c98a95834e9b2bbcd8cee826900d610c59d9257963739d524ddef3823017922eeb781021f08d34383c88a272e51ba3678d7e6ef483bbc149d552a7aca80f92eec884b15bd00304f23099d6874e77a1c3e05809414cd030ab8bf63cd8f7415e77c68c264aadbf8e8491d019d6584bf65c14ddf3a0f42a3e55006b26857f8c1d9b44239cd3101b56beeaa043ba8efac5cfe5b523035722bef80a812ce5f818deafbdc124f00916cb4e2bebde94dcb16aa011dc0a2a4a4ed29788a1470357322b3f0d9fcacbca171bb7b4e129b89b5544c4a7e31c7f63813dd20eca833cf7da47b5341b0381fafe34e999189c48b128760f92c842e7457438dade8133da55e80fbb923b1367c7fc0bc6084c3aba07dadf540ae333a0269a76897dfbb2bfe694b3ac5550de8d7d2340a2244072c63a38ef1b6fc2945d2ac9bf8f26802bdd153b1a465855f092a45ec71d17965303d14e1f2f364f1f6398410e378fdf2f6c1633016bef83b87922b2ca447e3690216f4cfb798015a92511d8a36a8eb2e94d6dff748f2da649a5cf3971687c117729d7eb0b185ee1c7c15c61d7906a89f10b303fc4e23efdcc928bc11ddf06ff15d4fd5e0c2ae5d9a801bc7d9b1e0453e99c900ea508e90921c6006caab496807f8844e9c8bd8d77997023db7dd06fa714167800ffca13973f72d6067cf14a2931185c226594c9b1e895124a394cf3a11606a8924a0b6bf8877ec9ae443de55e24eab1c7b931c650c8a5eb570154b4760d5807373475ab233ac44aca61fccfd5589d30222ef987c5e2247756dc9e00d41a51a3512ecbbf373c83b10095c27fc71941ebf887cf7a7adf9e7fde48b894c46085afb1199a007962cd97f88ea35f52f15e687c54c23bcd482b7939edbbcedf9a29041d7e5ebb1c29242797aab58cb9d7ba371a40782fe88ff8b77ba386697923a74ba68c8aeeb01e564f8ac1fdd43a5bbb33d8c9296b6b8eeb1cf92374b8180938e4945c8d84120fb42e9e7d86a72bdeffec017b66760d80c607fb6b927faff461ebdc2aa4009660c84404faa219effbe55e5afd289c21fcf9de0c4f289b68ee144152b6ffa6e2d364b09fb595fc0f9567d0fac91106be0b2ce34644d33783944a749e27b3ff124a8184cb272191363f1b619f9bcb0bd4841f9b4aef58e42b56e9393c4b30894309493b461d4203c9c361260d80b09ca9b3b954af4a49775fb15c9061b008463c2569b45bcf9e7c80dd1d76c8377ce3ed4c55b9b04cfacf4b2b63adc65af610b1ce8ddae2aaf1b91dc4202cd3d74a3a989785a8f0b69bfca34a1e2728cdd3ec27b979868900d6b1d67d7edc75bd945ced9739804df62847bd02372400cc68c4604186349d2116b8d0d8c031daaa8b166825e548054ab8dc797cee95a8d9dfa94b36c7d1172b892505e01115f712bbbbd310a62db7acb966170230e31aa8102b896b45b704b7f41cda616f5a22897876815923010746d0723a428052f6cd8f7316c71d3ea2373816e87e2493532e53b58fb2972490cd51dde3c2fccc606d41b953b8016494fce4dcceb178eabb84b14c30fbb74dc2a87684ea866148ea35bc6439d86fc9c256ff388b58c85a94740e1f5adf7c7b876121d6bfd097a775d12efb4fdb0b873b53ed3a50037775e7f9ce5f42a54c3c1941befdc0e5d462cfa83a2ae0e29c24838d389ae863d882e24e9fd1c067ba4000ef4fc056e2481951a542573e3d2b3fbdd213c54f857e3441553a17e9698e3388c825f0b2c42443afdc52bd00d403bff2d6d10874c4aea26bba6ce0954f1c7731d85bc53d23bfb0d0245cddc4d559420c44a318ebfbc2c6293b9d72d38132286bc82c4728a1d23e01b2307b513147a8d824b213af5b3d6ef83291e3dfe5d0ca41e399cc4d700a862d50735f187dbf0d30db529f21c2eceaf1525ba671a40d7070584f5b7458a1887f52ff13e37d949e7259cac000e7eb180d29a8a67dbd79bbdb31e6b7368e891ee7e6a49801a200edb4ff4685b3abdaae6e799dfd0e686cbdcd3f70b37b8a6e22114c4a312b3c245eb494dd4223b1c62375f57d78fc9832d5dbb53446d39ec8990f4863e5cdf911604d48a3d8e324fa426e32676d78e668cf2eb4402841a9908238b159d6198749a20088cd9b3c8228fb8f0491498a68d2bff21b8166d35410ef0abcef77a1f943cd863524818328198ae4b014958aa556694592d4b2686d00c9d5bee2862b2e996df215964f043c2f2157de00c7a0ef737816d249fc04fc89e3f4c6398380f9212882069fe0e11fc91ab15ba9051607d94b0f16c23c264539104213cc9dec11bc6888c94d0d0dcda630086b2c9cade4641c221e9da040b8733aee11f04f497287af892675e7bfca1b9eae102035c4d3baee89a3165d236032d4251d975c5264d4767da54809b2a0c77ebc7ef409bcf8592834324971325875751c34877a1df8994f3a9e2f2053f848b6c4c5dd24c44f23d801960295c61b971ba097ceb9fab337cc5cc8a62817f5b143a2b620658ec82ee1baebf400c7d87ba2a2f1619bac2210329e4520d7e8aa29a0a20896f929577bf636f4b7be66217b6b3de3014608b90a4d77cb6d67df0ab43641a5ccb8bf5630e808a01bfe7a46762ac3849c4717cc93d19541a5eff5429721bd3c0824a004ef3f2a5fa88b883ac20335b1480322b3e655cc14ab6af44e16c0f456cc34b4c4d6d4b6d7ecc1eccf7d09df5cad0112fdfc2109a3d14c8ba47d444f7474051758ea606ad571db3d2bf8770a1ff4f9c0da6ce07173f773ff8e095affaf8fd2f75f33744588a3c809717f9876705e9e0667a7758e01f59fe7bc3f6af6f668f06685be46ff91e9f9d19497c5f0ae919d69f35d0c0b1a38ec1b46d4e47477981090369d87563601f20cfb3a32d173f8791034204e0ad35784359c666d38c7694dce0d700dce81f2457f1ec12f950541c9fdcf82564240c84e939a8bb2d242399f6b27a33ea1509d33a1f72ecc54cb4f3ce3942d58f2257f9d6a8bcd7ba8293ba859405b1ec5e738b92b438a6a08ee3333a3933c319174f226f3c584297402dafd896479a0d4d16c314801c738e24e5007f8f4135c517f2472138113bf0cda9220bd19e4548c877a7eece4ca59406cd998ccfe663b4e3e06f228c74263e292fa822492e48fcfdb1ef54f6cfdc04b0997e22776ae0b0ed781a06c30db04fc1fdb107a8097d21e6cdeb7836f4fcaa4ac50f7b6141d70acb53e1b39e9c3efcb408072fc3866c3b0c1dc4656f6f187e81ffa45e36dd502091fad9e8cc6b5c12689b93978b49d146744ded53c4feda0e27333050bc9ca7de7d5c0e2991d015297564323bff801603809d071408f504cf1b8d7f16a4fea6c2423cc7158ab6c53cfab3859f615d09fb2b9e5f24f87b696202b54e0f94094dba60075e05e3538952a10e8cf9b67ae62dad63519199fc8951a78ebc83d33e699154dfe2093f8e39b113712604df79b2089ed38ec70ed125ddf5dc456b5927ddfcfdf9bb7ced5d8c9bf74c6f6f9f4c927dd5d4df76a81bc1e3a8e1a4c8c0c36724aea949dc4cb31ef4c2593411d3068c97a7f5f09cb2aa5cb7fa954550d9386060b932907db5cc0f61057ca56495a81bd6475af2de87b2993c20627abfdd77d2a627fdf972f58b4a29b685277d9d55e888554515f5c3b89ea85b4af770437e37e926037c5aeaf08402b3a168adbd523a244bf46cac09f2d9c056330a29ba317f3c8400b644ffb4f14f2f533d79994f9d694d81625aaf896a585ec0ff1586b822cd444852d828d957d8fbc27383ff9adedff169b0e67b70cdda7943e52b0daa66b6bf3ed443ff051db750edcad2ce6764032727b3a58a7c946572b8781157d6a59c684b444f4c88cd1d8f41e31d3c764986b273d72866e72335eaa763e6df0479c725836dc6a82cc4e56aea51ebcd4e6646e1aa33cad4eef8a1502cbddc79f541725773ad40ad195b10503379d8d971711bd34dd1870d5688d215657b21789a76adc936f84c37292a8e0fb616d3d227d2b5a308f67efc7b066e2839766857839694411f9411f96d31c65215336f0c093abff3a0c15537509862dff40883d841a2674070de0b1e73c22d3d4f9549d12c329ab4e237acb915f50195066ad5135e13c4be9f67d3be526fd1a561e8684169affbb3edfa42bd9f8869fae9839be08403f80712756cea520cbf0a78fa5bdc1b08eceaf04ceb6526c78c356e8a17729bb7442a4d6ff37dc88d5880dee9f1f8043200a150956ba1a18380179b6c46b5c981723d7cda4632664e8af98d9bd3b36bb4a98dbc7f11de1fd3778e956c239448c7b49bc95c38950f6033df83e191f235d6d3fc0e1e11a6be6e20945cbd4245535ad79037a7228c769f770694fc33c5e9183fb2dd9f458db9123d7a87eaf0c951d2c581b85dd4a677ef0ba3c64295b1e4769a2e6cd230484377d02e4e95fd1c826d030bea83e9601bd48644cb8dd06afcaf7b5a33b91d4b69e99df388a3af649ef3c8ab575dc18bee8ffab037116f619b8667f8c85f07ad340d3dd29f92edaa15ec2cae74193d1fee722c61d9e2dd215057bc688d669c03c63b538ddb1a7e8cb27c157c4e02587cf0d691073c347f201a9ae4e8703c6312096e9411b23c4c3a899082d485e8737242172d9827447b73bf8627e09e94a1db1e219b60b53ca1ceea6b3db34e14465dd442da4a0b404b2aec96b07e55dba22bc22e3be81c174a573931f52da4243e0b80af38c0302ab74b448dd97d44f1e7fa678120075ed3eae03ced6a0da1cc6f170d75fbf34c98eb9b442cc60f210774fc811c7012e9930fcca03d9c1acd4a220e7ee90b81d040a68066bb32a83c6dbf615e5ac27c4dbc7b964785ded7b2a09c30e6cf44accc6f4ca73ec6817f0c3dffd5e174486d82416de8c8604fae31955ba719806309a21db240fe76866dce73d59dc7aae7b67745e53c4a9f1e09a0129348961524959232467bb7f02183b9759046de60750d9caa5d7f320a7ce875cef2cadf1aeeaed049509292fbf2554bd77ae4346bd2507832ae6b8af7e4cc2e76aa611504b8e53fb90767baaec424dffb9054437784168c51b02144f721ef0f518fbcfbb698f60c519f4beb9898f6885a2b4b14da8c02ec73ce259ac2d3085113d2613486d8fae95dfdc30390514889170ddae752cde9eac7ff7db57e98bdbab9ab1a6647c4e81f7a642527c6bc70f6180fb3741033a4e9a671b27d32bd72c2f2b9cde8d01c58bf792eadf7e0ae784fddeef83f4cad81b9a82cbcc321063fadbbdc97501eab8a3a09f6f33cfa69fb6c78072e20e5df52a54163a0e0bea71c4a2b448b302e693168b637481f561466161b5037ff40dd4b477483d669c35e39c73e2fb63c04801bba714e06b326ee016d91575a8a0048f4d7cba6c4df0938a1715a8bbac636be1a042e9d92fe8aa412efc82891314ffc6d3954df1b349278588a6148dacffd43f2f53703753057e8169e0a09d7ac7ce88ecb0015c47c46bbf5c612c8c9215423e52be877e35bbaa65d2615a6563f9ba9d7479b43aca0e78c46ab062f811483803a90d45785557e3a45454aab023d12f12b4aa2b0fad76207c9a1aa9a00e78d2743443eb5ff6a21cd5ff1b75f3ada22df596051e52024d9fbe9bcfe59387d4acb6da324eeaaeed034d02fa26faecd6a21a0e0d06d8876f1db5a2bcd0fb66e249425be84af2002e1b84928915eefb92e97d98505118938f0ca41384de8eb390604dbfe60b4962d949f168a6993d9e8d598abc2bffef5682187a19316952960b15919d8d7775c9846104fef475e4b0091bb2d0a8df60f9e967786e0c0cac03cbac4ffa704194b46c974622913120602d800b1a81d447ddefd507a3f7fa2cffefbfe504c1bdeb56ed0a6fa008d0874973cea5219752088eb85431047dafc5616fb5640a44ac8741f84e590d2e628e2b5602387cf3eb3667c2890e6299251e34f4adc255fedc280e4bdc16c28904e262dcdba5bb09aba849a2918ba2b3e7633d1adf114edffda379706443a380ca478d4cb16cfb6db5d483d777d6b61d93531bab455db5f25d573484e2db50198adb92dfdfbf8cbb9269256bad00f86a95bc6fd71dbf6f3280a311961d7c87779837d9ad68e5e50afcc9f6d85c684146dd00d0e5b6eeebae1183430347c1a77625d112bbf52cd2c5e281eee2fc44197ee6bedeeafeb27324497fb695bd5671b3b22b2bd333d32343176bcc7e22af3d889518d0f2fc9802ef208c380dd259ff26df6c9e8683578a75cce3e23083ccc0ded760939638e1aa477687a10507db9fc39ca4bbac8a88cb29f5d70e2ed6255f7c38441887553ec656a50ae0e6347d6a04679b56a368d4eaefffacad706a32e2197850b52e1619311e8f945ab8dc26e4cc5a266276cf748c53670ce1927367c3e0d2a8c16022b36b7bcf122797a9130240009b8c680d04c6f37d3ea098a548209c7ae5a30c73cc12da984b55bcfa7f32a3971ce54c1c0308955a86a5fe0a19ea5410d373929bb219ec264a121829b6835156901814397ed8e31cb70e56bbac8ddf2c850420c188df275a5b16ac3aae157c163bcb0d64d1dddc81694ad2a975b61a88e7cfedc4c6b1fe2a8d8c58a278307cbdc44be9234f5920eee0fdb09f2ae304b6484510de9b6b4c0e6e4ef4b74f9ee90fa719d758252ef8a39a70fb54f1981d772e9e89d05b8645def4d5bd23c54a43b52718b58912018b35703dec38d9075409a833d305b01643cd40903e928b469c0e29639ded45aa7a02c88ef08dd15c0ab40681ea221d2dd3e01f3a3395a36e8f641d04a52d01f6ac4118cbc8a9270a76699c504c5ea50347594a51b124aa1fe0b76ab58b6080f32a39c9ca7c9815a5378648fd9e20d5c2321af7ee7a2debd4d9e961514052095fd544bb1b37999eaca3b47e507d5de038e8bf3e9df04ee0e9b37e0c7abece2c5e4dd876385c20e2c2d667893a6d10a7a2c401b33ddf6da952613b6fd37df2be9cb5216675e7223ea9b7cfc7b080adbde4f372b8cc6f27fa79553b8b5454855876934e635265755b9ace340160b2b65fb0b49dd23db9a119e0361695fa89ff6e489113eb7870171851dc95c65335688cfd48e0f7f6fe6b25585c0201f98b8f1c42757108fd6d4ee0093ddfab9248456c536b28f8677f375e2e849d490ff0fc76fbe8e673a20291d17cc785c3f5fa1b7d781f8455cc7fd1fc894ce8d935dc52293ef8e913cd18fb837ce34b734872e095f085371dd35b5830d9cbe832e183baac556115f1173457027ecd7f22d2e25c5875f3a38cf1397ce00d54b2c5340065cb1317b356678df3b119182f6b1fe0100aee5bb2074e990b2ebbdf102ffe5f37a29efa26b05b3159c235c8efcdec3e8594c1d2c7431aeb41f74d55e767cb16b933a34f10e0aa19d3cd709619770f6d5a38095c2d17b14f1d3fdcd251caf871243f85700a5c9111f03a141441decc9e2602e972a0a0fa41bffff0d1acacf0ed784103b1c3dbf8a331ce060c871d1819015febd9bdb583995cedd4fe7f0c0ffc870c20111037d9be9fb42483f8bbc3351ab411829a64d721eb337ef5267c8ea26bb8234c10fbb0aae0ea5774bcf6581092e3cf80abc91da500b89a8e74a69cab766d06349e8ee392084c57b87f6d1fb10b5973d3b0185655cbd23b5488d7f5308e509f8182a30f1d336a072331f4e60df7a7e3a8d7a5399b49982ec2fa74b315c4ea065199221073d119cf9f33f4c5c7a4d15b41a229d8b439dc7cd5cf15ce973a88e92553c4ffe7c4d39c14b1c58e1a82a6f62b2a3d0ee4ba614822a9e4d3370d6dca12aef9d035b826d5e5b5dabc55659e1a5cc44ee8884b73904e2cd224b824c39467d0e6f424664b7dda46933bd7f855d47c2cf9ff07ce1c1a8ebbf435fbf39fa379d3c5d5e0e5ca42b9f73fc6869d97e11a422e510e9405cd5919345c70a0f966fddd213daf462fcccad43bcf6fc9a8acf7dd53d9cc18049c8a0879802dd06d31225b9304d223df75b9d348fea5bff1aab65c5b5886caa79c4df0d78062a63b31a9bcf4c213e200d848e3dee1e191ca325927ad30ee1f33f7e848a73c0156c813382dbde6b6e196aa1fecd43027609ef8691c820cb79db6264ac493f0c5a61ae9f3284d83c376b35b47c04d74aab29b719cb7a85b836b599919185b9145bbd1d6327a93ecda8461f9ab256d38c598d0f5f683933eecf7517211262ce7fe10ca2826acec42e1cc32796d052706b256fed9723e85a9a6bfb591929aa69e1fcc7fcc764e9850c8656c3d9e5c565ff1583447a650c2f3a688c50a51896f1f0538a6f1f6bdecf8c9389c82a10fdc821a3851f8a7647ec99906a824b1f680d56b3bcf509992d4020d82e6ae81372cb14fc97f6b3ec9989611439038f5efdbc13f134ed73569bcb60205458d5ffa687bc3307835773d481ef30fe3141449220a9b87e559c2951d1216a32bbe160c8f0604a3a27d2d7653837616d7bee64b72980ea043fffed775199c57b033770373f56f1012e7ce41a1554059380fd68a0410f3c7d1d36d9ab9a5cce952375c81d1bb808522fb24bc76255bd6a533c9294fbae9ae9dcf16a55b1aafd003f5a5913c9c4e6898edd2d6527a00fa70d0f8cafc27f10e449a44ccde8dd26a8fe38d441e7c914ffefbdfa9e576bb73f13e0bfdb6c03b50524584805b1bef67288e851fd1475b7878d32b7d5448568792607e0d78eb631d850492c43bcd0167338be67b9b3dd156f98511ac24a7684d1718371c168a506aee0c9f6fe63178e78df06acdee350514b1c8287f0c9c7f18be35746ea178cdc67ec959805227189a4b4861cae780eafdcadf17adeafebc501afce8348c8eb2a143c2376afae7ab788db6862bfa481ec741c39c5bd38fa1847f8aa05b6770e0178eabcd2d67926b7d2c05085b026ea7d793823ead472865d701b90117480d17d91728506c15b5836cc02f462cb28ae23701ea04d7fb0bd19c582a1f4a3f61442fa4daee9cfc87bda7959a7d6628d8d3d67e63edd0a9aa3e8929c85d3610553d9c7f12dfeef3679330bb65d111b5fe6235b4998b0df655efeb76f29b03390bdfb015feaf5306a196f7380ec3664005ecd1278b8c7fb2eaf8f0c53c1803b4bbe80ea1bd23d94a91ec363978072924a795716ec45e27091234e0b12d44249ed47dd228b2b0c0016ae033f39c1bf7679fbd59107accb1d1bed678057be85960ffb1c77b42fdccbc0cb6cdf311bb71cd465304abd5535a9b2835026bdbe5b45a597d894dfa3ff78e1308cd56dd7938054042041f2d4c6c2656b14f4c6a0b365c4ca41cb308f25711fbbcf2fabe1924165fb3e0243aa6a7d8f832505c4d8e2a552f3030cf79bb48e22adbf3f03efca38f30c4bbc1d8eab3d73a44319fef8492722fb979c568b4d325ec14e1abcfb669a795b0e2c52cbb23a7aefdde24d2c7d963cd4fb524a5db048e33c93b6e13e6daf840eeae5534026eaa91282ab1b3819f469c87611ecbfe621c160f17f50b7c31814a60579053c02a0614fdabfe7cdd249165d82028a8c0ffd2029b75fd10aa49f232e0532cad6f7a8c433318e42824b1d7c9b26047e5c29c77eabce5692d7d324e15f0816c125106894cb7982b27dcbb696eb82d89bbdc04e377a01b2f0e4868d8752dc6312766396e3cdd5ba405928a952185e8d44eda7e634a6ba52c1d0fee345e148ae0b06651c5c2bcd5665f313323d82eeb47f6d40fb4700cd16ca9a72d76ba08c042db043b0254d1d9128149c5cf57eddabebe412be95155c6047bd1202919e66565866dd0d0b26490ac5c8aa074460d1d29729df320e2050ac8bafeddf1cf9b19a8d35b900012a279eaf8a63ecb8bd368f1136d669d0249690b60fa1a1155f010925fd9bdf31586222d6e370ad4f9244be2c17c4ad863970c5e636f758e90364494becd937c88c7ffe9985fb09e5d574207bee6a455b8b9a20c415638df037a04726031fcc7671cf8d008b21491b7031cf0bfa6e1a85b32c73b9b1cbe13a47633f79fb68d628de856cea2aa51e1142c7ee1c1684f28c20d6e049f2969973941030d18615a303a81e76034cb97c72da3baf229a38e5f339468e046cd5a90f958f6ae85a604cf222a3bbc833bd6abdd9046b1f3289f2851df7476f3800fba70e987c1e94b7cbddafdc5b3ffd3f449943bc2d578eac85510a99859e5549b1ff3f48b78dd653fba517639c0c829876197051dc51befa3fc62d13ee3ff7d1b923ece10cfe3689f557910d05f70bb893b45b9737ca5db4ae512c879f9b54770650d4c70d513e406b3c89e0cd097178c3c3ea4d59728d031afabca3d4b607fb68cd1aa1631179982162dd573a44048743e83eb9e9601e7147596c3b91d91b3b01f8acd21e98974275c4ab59a1feb38d01a294e1557df01887f550e2773851cca0ca48834dfc683393edb6167fdbd720bca122c3ae702f7a85112fdd74b32e13c326d0819b922adb3daa88e5ac14e395a317ce2d3bcddd65056c51953068005a73ca410ee140a51c5073edb68e2e1fa0736855001cbd72ed72a901b80f6bcb3d91dfd4dae51beb8ed68defeb44856da07356d21567ea47f934a672becf63f120fa7361a78c1b0dfc1bb519b85735bf1339b43aeda9b0f9a7d74f87ce60c9cb0da1959970162a44f3b3b1b1b618ca90044f3f83964c1341a57424e4a314daab791b5b17360be9e154a96c233b622a8473bb11b9bc0cc4b5f7fa3bb470e6d6c20f7c01f2be28d112b52ee605930d5bc9cb9157c596740b81f61c4d32be884bed62a7a78c9060020ca43b437e4a85d352e10cd01471751df2d73b7d151161c2b0426d133186f2b9bc6ff5de63321910e73e4324c3475dee5f18798328f36e32cf6366561fa03ea5276e4cbb834d644b6d036be527da1003e38dbee48a145052754e93de0e26b1f4955a630cf2c55c0d90c5f858d40e87cc1e418b0ec02dede79ef72e8549310b617bd678d9ae10990f941bd413c979d53fdad6459dbe872a47ba1778e36eac7555def9317364d1e0a097c943fe77a88b58e505504b92476f4137ccb83a6d5aa864da7265f1a4343d45e1165dd352894cd337a851b5fb6c9eac00cf06c2e8dd0aa6e7d42e7379f70ba091fab5eb368352ff3828e57a72747f7c31a371c00b507a80bc5fbb676767b2a4cd978d1b29158e96caccf2812152db8e53d26af784647c74dc7e31e8f48c941c976509196fc168271cbba5da59ce1916952cad389b03057beeb6135400c5705673fb46be459cb0d0653ef539e92ae8bdb4c2c4477f9aaaa83dfc8e044458e51b79513ab34513058c99865593837e48b46d4827fdbb34901063b6e3aa8885992e2d1d47df8cb0347aa34d28ce0b0b605750ff1af3d82e4d88c31ccc4d3bd393a4aa9081c57c00c3df6b1390ee7e6d0f59caec3ac8ac674cf2723faf360e8d5fe51bc2dbf79e78b51e04a2eba2a7a0aaf4ee8598c95ffc6b1d27eaf10950e7f13fdfd113e62fc430d4896b954951c8c322f0fc453d61a9ed7fd271631978269cc729ae000a72740c07a602bfc34c4d02918e3960adc8809a8c999d72351da101c4d5c484dce3ef654e1d50f96e73f1c7491726eb4388562b9fc871b1289b4ea353b069d91aef3c757f17d53722cd7a585ef34b165d5b5b347b5d3277464dabbc6c60278c0d257133e1b6ff749de0f1c2c5a614e31ed0fb0ced7a972b16a398ab9696ec7ee656c5159d1cea427d8610b0ee1c8797230ae7e114f66f623eb46fffd8fd0f0dded3d344d1749e5ca2f872aa7900dd8d293f6d7dbd9023811018ecb6f6ca4dd52b199b537cb4dcb13f535b71e1ed3ac693a3ddeb06ecbc28c868a60ca6dd64a0519dd62ad36695af4cc266ae22e909ddf4ac6917830db4200b19cb31004919e1d73dd83d70b0628c5a06a2857664298a5b941e70e961ec125b69b85d683946c098f35fda7b6b1261bcd0499bbd3926f5df3901b476c246707f1923ff2aca5ace7bf926ece30e7a9de68c475dc100e17bf86cc3014956fbe2d13b5cea7c7176d367212b31556caaf4c962fcb2d9fcc76a60ebf63ba952513d6cc1fcc890277ac1a2085c6b1630e725a32090e11c30e9fe2c3c56bd1ba5059e1e90644b48e140820e7a3b7aa9ca22f850b343b9bb7fa3a2d6a4b4a6a3d5550239ce1c79eb3a1f54982230c88c4176f37900326beac4b8a8d72883dcf00ecd046b1e941a75c0c1576459a60631aec0ed6dfae638eca8cf0342e704985c700015b688d99074b02dc817d37f25d8e10b581bf088393fcc430d88e871d4b4fa9a54a0c1413bcfdd0d5764f99d7dabc7f11fd6a3727cd037b49246a8faa0e159297e9cf8777a0fb1fcb69a886dd099f302f3bb1939308be05dd634ad3fb56d7136f5b40444a6ab79bbb4fbda6c159ce8aea6ed921188f022eb7bb8a99bae31afb4c216c38e79ecf39a7f4e6cccaace08f98115a425d9da49e6c152b73f929af3c10654ed6e4525839416b89aa92f1d95dd281b216a680da252933f17e549191ef57e4316fa4403379360913853265575bfd7adfa9bb304298dcf5c791ae885a45c7a753d65b110f889b193535789c03cdfa6aea5eb8e2ed65771c1b7caa8f333822b8d01401a2ff1adbfb39397fa58706fce740c73ba0042decaf9ded9737344a12316c49c3881322cd5d90df219d7faea534770e50ac6c65dd1d006c5b89b36c1f3a13d9bd3ddbc6ada3570f4f76502902f2b190cc9b803bbdb5a46c766608ca6d81d0e77c03487293b0583afdbdd73c471ac45870de44c0d3075a61da9d60bd79e99bbcdb5386973713418f1f12a5109212ae3c1b15ad05dfcca5802d2294fac9630614f95b5c8d16d65db73f5230141992795516a7ecefab9c20ed5b7139f9ce844490bd456050286a808472a1e2580d719f939d569872222869e44357dd1efb9bba5fc6c2d7988a0d968dea233f24478d6813a7360d3873b6d824c8a4f4c1db85bde74aa7aae5eab66494ca1a915106c4f3df58c4e4e888a7f8ca97d91861a699d5b1f314bf3c39f5fbda71b0becf7b600b02622d4f8485fd51d2b5a89fe6952f2da1f98e0721da278762537a22a6cef87036712a37719f1628a2dc82b83a8e227286a384b53dac82b893aae6d03b811116f0d41038cc8c32c81a480e4ac6b297eb542c5d20aaca6ce07f08e59203db9e150b3d0fa5fb6e0e556194ae825b8cf4ec512eb32425abf56e021cfcb3f9fb67ca11780f8767feb51c4701b521bd1d86e5ee9310c05c9a405b9223d1de5f6d424fb0b61ec7ff3486d0c3ba9890ba8aa8fad23ca469951df98cf064762f0a3a014d2be1b8fb6cfc5e07ba5d5543a7c270a936ffa64b93699860db522cf20be213c026f48e644f01929f5b75c5c6f1ab2a3d2ecca107e195342d6dc8823f3c1e35f6be13922ba15a550919f65e36efb63630b9ba906d0f314fef37be1681e6da3eda90dd485eba1dd7a37d615bce458ba15a8c5d666abbd6482df16c5bd5ba78fbc553638f10e12818fcb7780057c4ba921bd1e1a3f6dd8e2c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
