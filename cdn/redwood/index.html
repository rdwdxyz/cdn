<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0563ae49f7b3a7083e7a17769276468d39e06478fff8d3903b1da218f075b337918ee32afbf0cdd14a7bfd39ab8015d71418fca1e294c9abb5a3d1b7869ceb54fad6c8c1653dc7e400e1a1196e02945d5840c8cfb86b675e66d6f1262684aa69e52426ba1f651326a577474e7dc3311b660713b90803e470b3cc0dc08c8eccc62c7541c0013b192b86fa4ff1436679f5f317313711826a95cc816efbd1aea8636f581b5b23b4af1518e679d665b96fd0a6c1a8a7be4d17c746759cb582da140c8b6589956985313cf2aac97984fe5e59aee80b3b32e6e95b7969d143f93b038b6376a40d27f23fbe8ea9b0b3d5a5e262daca586866411a9437844540472b3c673eb092d599221ccef64d3e1dcb4248456f27b3971d636ec9af2821f41d6e7582dc553eb3ba48aef8745512f2e26e33d85362ec1b8889162b4059de57d359c1f74105e7b7bc144ec105000e78a509ebec47041c37c11c7baf3a3255dedb47aac9965dda79e35b40d08f789bf7eb8645ee226a36fbf2910999f3bd589ac6a10e97875382bfa8b984aec79cdb63cb1cdc33e6b6ce91390303fbd8afcd44ce0067b428c6fd5db0084f03de7ef33fb60c251942568548aa4c3e0874509e431f5e663e8da586df3051436141f4052d0b8a3152d75457b517b11231c55b157e45c214f95a6e8d9fcbca35ed31508b90530f4bd92a3456e33465cccef88a891cda6454ccdb0d33cb136cd32bf3a239aa3f376aa753f9408bc7d43cfe924baa5e1970783f088c89f18318d6273794f00a4cf058bba4b850d3a88fc920186f1702d6fa32bf098347c4f2730b06b6be0bac3567d369ccf7e377876efcff8bf60a36887f9e5f472261a7f054cf7c1154d70741c80b604d6772e971ea22292764ada2f5c0bd1f8536cec5721b1213f47da2dd38dee20783eb75d180ef37ce6978973e1a3af433f2012c66ae8fdaa9d3b89b96bf6dc27d15721a95ec875b8a46e4b197b29dfd805c67bb0a769ef3ee2928f33c3fcaa4621f49228804adabccef190bff9a5f6104214f2c42a0ddf02ab75e52af2c51149d675161f0a821dae2a3626b191211bece9d641aa96fa4091844258f842a31b61d6bafb49b787b3b2df7fc703014020f889a5dfd56a7038f9b96169e31e5b2703a733717986b7c0dc42ebc18d21a0b4e4f0e1316e9bd51ab3c33cd619d44cea0a2e3fca421077ea5a1a3016a636630a11e810b81aa0cab3da5c397c5e87667a1e829b364c8f7f99b6bdd12cc317376e0245544dde3305213aadec4388d7b5001ea9778611fd88930b499c49831a8fa7bde20b8ecd263e19cd377f002494a3230e8af50b8d954356efc431b141891a319f2f4dbe517f4ed13feea13871da8ca81acbe3ff9aba3b2a8b4d2cd80549295d629f93845433c4e521428b84a998fe29bbff59238b26b0ada2f1441fedc9fe542b289d935d728a88303a3f06e559f7513bfbdd8f575749659a8499b1ef4f1b058ccdf7f5d64b2b31f180e5e70b5623cbf374737bc4210ccc6e670caee76c7949a0a7a567fe2c2b75b8c2ea4ae0cc63d9a366a08cdd3121c2eb23770ad3a9b6e612095989df119c53db0cd64d51c3a9a2cac4fc1641caae414c8eb951458e96404918c109f10b6751238d38c09b91d0404adf0638d8cbec831590c1ed65fedc3e8c4d6e9f3146ec1a04047224bef0fa601b437a3eb65d7608ff4ee9af60b1e6b59c67c505da8f8e0baea02aadb2235a19ff8d695e7dbacae0376f0fe6d8ae834404c012017e3193051de884007040ea282e3f56de8e6eea470399f8b53aa41a835471f25791ea1495a8e012f7dfba39a8a02ee1a6fa5749654d75c875439dd8e8d409041fb6dfa0b612db38eeb067e7cc2df78d354d60276b2e185e9e4bf71c85499697004c21c37b38f43cb1496d926232163fe85fb80fff81576baa541119a42124dda4da86c67063555edc4d8c02b47d4af4867328d6657c62ccb7c355d64e307829c2651b127ae3adcdb4df4a089493091586757d7577d8db53f9722982c6f10c4fcaf7f8f3822211fb150ee676e10477ef808c59ec59009ec5cdc9ee0ffa15e0a4547e6e013fe7f5555abe765ffb86885c5574dc2796c00da985019a9e726c62062f0cb6caa73cea31880d8af3f7c3f703966ef9d2584d91dedb99bed55d5abcfb3912eff2865c452e812f5e4accd7eebbbf6e4702c888369f71580c81ad88dc7aa0fc2ab46a97cd6c14c80097330f7b235ac889c0480cc77470196a860346fc7ba9cbb3c2d3bad54957745f6415d9088d25170439f4bd25d8869966022b4cf9183b99303c8c7f50a89c596e16640a89f4a8fffe02531c0a948f1515956d8cdc8859fd69e945ed08872fbcb9967599ece6f55cc044755ea46bc741cfbbbc92b2a0172ef8a02fd79e50233769bafb74f3ca8b07fd118cebf325a4f5a9d9014021880f91ce1d9e5485a7ae9054d692595662b586f97b86d1f36dfba382b58ca025fe4d4a31f5009b90b43a78268ac4aa3db1251280e41fe4cbd9ec78c8891e4fb91d18d0a31485a457150b7bdb48a221354d5acde16b36093952afddac6f07362170fa7dd82cc4db9deb77ef747aaa1879349f8f3cdd46bda4db097d21a16806c4a6d24e4bc50451c493e6ed2b4608c4e0cd78791256311b52254d1e5ad691cd438aa613bad070906f38d4feb897c385cda34adf5dd316ceb3c6ac028e390e0802fc73463e442c2b0938a3340dcfbbc461a51793b90b3655aa6374dd00309f8149fe390d4261aeea5fca924e96e1a378283072e4da554e7e01c1f0340c1b3afbd34b59b0c583a6fb27c3b1ae6e0ed90febb72a7bdb84371862415a258955105a94cecd2539fe9cb1af31ce170622376a6f6ff7118d87aaa1ecf3a544de41ea8789dce576a1f0654f4195223b78879bc76777a270dd7e4d9e450e809a85b3489574468ebd3806fdb10b93a1bf7092e50782d4b7b1ea3d1cbd7133afc582bf217d6f455da74ff8d4fe02ac2f5375c3777db6bd90b5396898163960b79f7c2ede8255089a8a7c0453ba5eab663a017dff8c1f2324abc502e99d8e71d992f6d981beea2b370b50be9886ec43d5268d9ac4f7cba77a69db8d831824277acb2728b280806add31fbe3bb9ef4c326f5f2e31e0aa64704295a241162a7ba021187b3c491e4a6ce910200d9dedd62a76cd80b19bbc4c45c5c1b7eef0e6513e336dd7c3338d20f9d5e14322b29301bfcb73dc60920305240492bb927940a218fd9170f0fe5f65a7ec8e3d4eaac82d85d07b94cb890e5a5a44943572b8d6adb13cc0bd6464ceeebb081d705e3590bf05fd5c46312e8aa2b9c1be9893648420342f7e10ee7647f3ca7910827d086b7486f52a7c50d4fad022418cb5c97127c345966117377d484f6c128b6fe3495debc2375033e21cba9dabf2473ec7f3eb2f223a7940054547bf14adec16fd9ec13bdc64640f75f575d20bfac2007fbc0248be824cdbe66801c08cbb289cd92089834ea32ff10ceb87e267d764866d95c902432c6567baf9b53868735090cf8b4108f1babcf955a5639f05d2612f9b4694fed2f2e04576e269d09ff0e6659b51b2320a1f7bf0a3d1110fc70c978b95fc7b7dcdc977f04a37d49f72838bcc25ca8f37fe253bcf0135267bf4c411d168cec0afe396880f8956c7aacfc077a71bd29763136e924bff199c682c5202523b4781476e7877e2f8e74a8da4c12797a680c1813140fe33c56f406fe382d55daa79c6e56188fb11373fc3b6a9f844278bb5649aa90c035ed806310e1794907f3d60ad21870dbda265db1736ec7f75a349094b113898fc6be6b52700846d322812c371c307ab1b53d67a0fe0bdad4b731de25267aa16887409d9fb874170250496449b5e9aa02656041607f596d3fdf3950e5d569a02a8cdf260937d812923a577ecef3ef38be88fe4f7a0ee7bee7692db97a90c23530028cf5e2bd46331cc8ea20b7f63721c63c2061724c465007641ab2df545c878ebd904730a58a210e63d0a066c4cc83e34a228e834651ca7783e152681df85d398afe2f8d748fec8a35a41b8ab33ca429e0d1df4a1285a50102b67b57f6b69a4812eacfc08bb799c81e15ebb1a52cf630bfcdf3b74d1248367ff5aa578c6ffb72214456f9a9a36fa7316961c454da7fd5ac586a010f6f9c8167cdeceef2e4768722d35fa547f38260f5eab11b15e9a9e62efcfb709a8e6da29c793207b9b3f01a33f5a5557ee6674d2e101e010db6d11e569530c945112f46813dc6c80b19183b0a44f8130585911efcd626e5ef8fd252af2a063916b41a93c374b202945f66933b91810a4844d29e864fa31ff16e5fd09849664bdc3bec7239c778c2ae7419d3b443e09ba7fc0518d089bce538926eb3f75ce108d69285c5a670ad0fbdf08615d5bb1aac3c60fe743c9ac0e7f21e79dec9a163daf80f3d4849f9e0764f71b01169568401eb061694d9555ab05a2fe7b8c6f59ecc0e6dfd0a1874dba2e05cf2ea9e839d7970e843e40bebeff2b477c90a8b92c3f2cd37237a5bb1bf41e0e013747aa94fc9dcd3e24194e5ef21e8c7012ef000d2f5dc27712f6ae67ea41456491a5f348183a4d7bdf29192203ad5f18532c625abed1fbe21dd42fbd1e664c4bffa20390eb45b9d89bce8b2d459b55d4ed952bc93548235c72c1bfee67cad1af367074562201a249fa7df2ddd0402d635de64ec916e526cdad84fd68ba6df0e8c50cab4dac1c2c054883c26bec56248c4d8a1c593fcb0fd245f38b367631edc80eff95416ff752f982cb24c336b9cc32c9dbc5d400e1b3743679b4cf26ad537147f04f13c5af076220b29a2d381d5107d3e9e8f7baf8bd2223c993bf952620a48a80f8efaad401cf6355f0e13b5be25cc9d4ee2b0fc02377cb56e40dbc54eadfde7909f22ef6881014340d86ad55cb1a39ecda80ebac26576e608115d15137ba16fd98f261d7cb63057c8a186e94e5a8809054f583d8610b7f31a03cd98ef00da91c5e5e372cc7db10a21359f8170d4fa182e61792d77299e560b798ea6ab9673959f609e0145e243d52b8c2c35702b711d767513ccb364383ace6dbefa23bf4af6a11c28965fe1d6acccbc9fb9721c13702e782d5e78628f707e80793f77716b96813c4985ddd3b954b54324240573169d2209a972214f5ef802aaaa96e36928af4fdde8f0d50678268d7d56c04a61a14165d39342df0fd719878fa0b89599efbd94ee09610bba93a7d96e547f5291a7cd321d81c21efd59bef5652937e049d0803f648fe2296f03ee69529b50267b2d1c9c23fde66fdded40f5e1d97744cdb67f0937d57da167bf1128e7d9fd23a00b78830dac1e4b942938aaf8542e25e3b6b05e987f4dd7879a56bc5d5ec4d4e0afa47d76742c4907b6f52015bb5f1e4c0fcf8f827356ed29b84f18d33267b874fa385f60af65a0213e6c5ff06b2b97f2cf00c26de097759896fc8a7c67734824ddd34f8c9b4cc969df9ef45e75594d38f45204168cdfe363589e6e030d8043fb081b64f78492b7c8d2af37274782e0233548b376a745b2d36dad16eaa99b0f928187d50570c79c6cd8a940ba8a64f33c85a990ab573f0d762e2a4b1f76f32756939ddcdf89d6adb558017d1b9bcd96788c23a849c968a5bd7c5b43924a40edb10ff2be70e7774fae0ae615f59bf75d28c0fbb9572b35d20f3908d86736cc3d2a4e63ce109747de84baa35934deb6217c6523387b6f5c3ac1a32c5c9e56819a311d3969185ce983c0067a404ca2ed4ab22c46cf1032cd6441173c937b18a0665a91f5d4f47169774752ac5e15b2a1b64aab642a7be476c549fd498f6209606111fd466fa8424be35b8207f4ec54509482c77cefb6a52b6c16c49240382507870defb5983f4f28f389ded41cd2c56b3ca7c258736ef92843dbf6ead36f8ded3288cd428ba3bfb80452008828cc5cfae7ad601e9e594602375d80649a431f40587e41e77ec10e17f624bbf265f039e93bc246a0d8b3b406096824e6e805c2453d38a39512d7e89051564c5703136137c2363a94de1af6db3d56f396e6428ab4d9a691d3514a5b4b344f053d2ef6bc0c9c042fc84fe0cbd9ce4bfcabe707f75750b2390509535cc25e9bb0ee55c9cd2069db25788fd2e9558007cf409ba0c78cfa802483ef22e35074adbf11a7eb95d4ba3763b790b76713bd1fa6b12512f0dd30715022dc2ab8e773e4694126b23bbdf0d977384527c962892eb1a3a2fa9b288598fa78289e28e53da830840a7f3e35ccbf7293a38c30bb29ed34cd218e7ed5d2e4be33c46ccfebe61c6dd16d06e1997e244f077a01e358ebaa511fbc67f82e2520917cadf898ca21fd4ffcd4be60cc7160cc5e21f97617e0721951bb21db579f216a7e9229058ccdc85cd8e6b9998bf10cb4a47b59618025e2cad4d99da7075877ce70476b32010dfdb2e5fc7ca252341f71bba1a67013320d78ef853df81752b772c70656da36a7e58faaee0899263f90516a7da1974ae1176cf0bf6e56c810b1f8caaacc58a29ae38436a86490331ba3b0696131804bb12a4ca1374d9283468610da6bf952a648bd8e09f65e1e0e2cc4e696702a536ce4fe11ea1eaf5fa5de052435f173f6b673ddf8ebe825dfb71df8b68383b3cc5313757d2fa23418c1955647517c2add1b6366a1c3bee080b097ffa22ae278be448dd7f4238f9210be5f7a4e2614a2778aad4877734af9a75921d68284e00c13345f3af500847d37f35559c3c35793cf82b7e2b010baa0a23d46a5aa007229f8b2caf714764c7570409974b5fa1e9252ce0a6a6e0a2ceca5db7a2cc96ba59254e8ca54646a0e92731ee38fb5e12c2aa6948ff4c8ea86d9bb94d12bfc45da6c63330814c94c9befe00e004ed065bbc72e89ba8158a136aed11c14eace8042169889c9f2af35de2b300b9b8d9bc494235d86cd2bacc9bd802c5df7b293c6cc4b4d091a6d931e5ab281d3d61c7816e778a915c077aaa6e0f15ee6efcf01e63c43cab5088c36645d5a08aaf09f3e5495f86a962a7c37d0c6be58db5aec778860c2eaafd14df6a5dda12e1794e8cd5773e0545d3e73bc0459c7e000366405065af751a103870910d8c3a815b4d454971a115620a6e891b903550907e8d56871fbcb75dd33d98bf28d5b94a241fd79d4cc9cb9ad2ee1798b372591e5f83bd43724fa334132f2e06a63bacc48bc25548b5445cc765346489b52e9faf732d331bb177dddc919006a8c8377ab4443c60ddfccc8c00f06d34f643ba8b2e53269cdd51960ea4c4b1cfbc5de730da7813601075725ac2f81192b81d382c234f6551e94f228c7e1bf6c1f711402fdc1addeafb26d73444b8539eb629041ce3789966e1220e23ed7402ae275cc3230e14c73a7081342dd465c63dfc803e0a81f6b10a374a27b124dc48323e0f672e2b39410afa475b7c2134bf3f95b95b7d25486169eb78cce7b9677c853c76dc059eb21a42ebc1ddb5eee2693ae6cf200c65af9d8776771a54a1abbf08b241f74f5758cdc7ffc59096a531220336e3034c381ef2d9d413d0058f8f49c467ea6dd9589a49c31dbac650586fccb8169a17c15b63809629e17604bb0b3bda72bea39b1775dbb630399f04686053c714c05491684e4cb7e24de1736a8ac9c46582bd6116b1d4f6a3fcfaee4f5ac85a54291ddb55f46167081b32e882882540cb90dd0137d05c6955800a9ddc9d79454fd985b1a9cbecc04439dcefa9b7d7b8d2bfbd710e2faddd36b078d0dfcd93181dda1c56fc1e87447c22bbc4301365dbc607f1ac41079309dafc87a74779986b2ca5e716591a480272283daf14489c1d41623482018e1d78c0b38d84c75c4de8a1f7d490a1be7a511407d3ef3eb43f0decb30c2e70aaf34fdb3fd8fc7c1f0c318c508e72faf8c5496842354efea1bca18080be851e283b035a59ccda717505b56738dca8e6945cb385614adaac2deb7d7cf0deb3874bdbf7615f9309ffc6bb07f6e26426b261a298bca113e9323b98c2ae9abef275f024754cfe2e9dfcd1500b108249312f63726825c09dc91580bf311c002418f67757e88cc8d4c886c38945f693f1b4d8a9f71308b104cd452245630f0086d9679e4a16bd468a69580cb2be58415b741d3568eb605425893903edb1ade8cddab8fc3541c590e53ed4686e45166e6d8e6ef25899a4aa7f9fcb8895dc61b0d8e776bbc2cc8619e1ad12c79b16765b17a1f5782f3f6309885f30586ce4c6da9fee9719ee19f2d471fd70d5c74a2276979278f4087766749494192e77d784597bfcf31a54e4275558e99ea8d79bcbf0510834bccd77fb799252b3302ad99375d59dc1c1928829ca06c1a66a39f9414d1ceb1fa9150b596232494c2bd87a0039b21274d2db5887053e2435b0f1175c470bee3b1a2bc59aaa88a03bb6ed98928e874ff0ca40f291548675960217f454e17f4e4f5d7c23b3f82cd11db934312018d8b752451d2eecd45367db3b0748b1c71a3a58e6a533ebc03b55edf19995879e7614b1d91395a398deb75f06f533e98b7405eb6660fda2492f6776b72716e2f98e3db84ab74d52a05dc4c80d0ef761b288553d99417b430c542df818c09616705472b7be5b6e9e52657558b9528a552c289b2963a7bc4394956c278b18db6e0d3890a2d20b653f2a077433bc0b3b60780e36204939c9f4e822be90517851f7ac27da4ab34f32b710e3d771241199563c4dda2379819e04acca6bf564014b0de313913d4e9e7038235198f3bb05f3447c52746ce168e4fbb2b55fcc8180fcb5455680a8247e18f01fc4b785402eea800529ba8e97a4d6d26fc049708487438e94a200f909f2ed502baea5fb85029f427148457d92e2566dc894d49d9a44a4529728d0fe6803db425e4049e163ffa843cce816b372ee2c024a294a0f83fcb73503d73cfe1173851327e4c8a1d0014a26b3f34c62b84def8b282d5f78ec3dc0569699e2e7b3aa84173e74c9e781c7d3194676e0aa9c468a7318a1461b7a613f84cb6c79509b2483053b5a8efafc1e1bf83250bba937ea5733c69fa4b68056d3ce36e48f28804548ddc03c21376be47157552e48609a17fd48664a53a016c86e9541c6314b24b3ede16d79603cdf416929db2d576ee40f47d24c7224176ef71a4627555e32e1cc9a82d99dc0f334e6d13b8f7ea655d6cb8a7155342fa8e98912d6fa7a325583df5011504ac81fa57bf6df45e0f677880ba5dabe74099b5b6a5102f663bef7e9e43b1d0a7314c602af3cbf0910eea82e90d42c02ddf86a50b3bcffccc13534d3bd1bf0a0ef83d9122067500c1e07b9e47d6a7fbea0fec9d690c01f0f9bf4e197bec982401030ce32116acc63380b4139c1c2fe21719aefde7867bc732e2a06fbcb5b1f10e814bf1bf54307515fbd24c7b16a42fe71106d334ce9b850629ffccbba7f3412c40b1e06f5367894d0ab67562e003c1ab28d54853ba793345bd6bef6e17d30f471a1a437cfa2ca57ea9ce382057aa6f0ee14d71d150b5e908246f6d0b665daa6f7f304e6e9bb0318756767c8e89884f0e15ef00871588cbb7878d947a2f2d56717daff276fc8fcace2efdb714ee826075a5c2df164ecc5e2fc897cfef5fba6158412a414513e7dd622044d98929a90b76508ec8367a2a5cd187c38f917aab1be0e35df6b1d6fca1a6b1dbd3da16dd37e7afffa48fe632a34b23c12d74d275b29028e681e3010c1673a5e03b05cdcc5a39176705de1f2d69ce4f9b1c32bf66bf518f04ab0a095a131fb74f4f4ea7beaedae752ad36561fe2017ad21f3d06f9616b16b69db37cb1605d8d9767285e95e840f497cd8636dca7cbb998e5c39bf519568d6e97d93b177079c358faba74d17d42d36888481d892aa37bb151c127947fcd2676cd84b098eb42aa319683c90e171fd3003453201469ae7b90d517c796193f937c2d180cc8546ab1334525e77bdc3f6faa96975db3885a574bad1cd72b347e79886bebf2f2fc9c939124f1e8a55a0fb95f9eefa553b0b29f218ad93c23ae7e669bc9e1a5893a73a716b2aa242e193225452223604e7d565a51ca575a8d1f6b832e6e0b9fa08134d5d97071f7a83192db8b5c46ca21e99d01af028d5f1a8fa3e9caf60f29c774df22807cc92fb5e49153baad8d565534b4d44a21bd606b67e91a39e6a793a1b5dd9d3a15f8b01b00b30c406a2cbce2c59a7a51d18d3aae49193ac3bde5425dae330f5930865f1ff2abfd6c0bc97186691287824ec87aa0365e2aa1b3fb285ac1ff8ebefc8ffc4b458c4cefe4897ede99b7f95e3f62e939b80ed5644f3ea95cc4210bafa86b9c8d0afe8365f5da048167f0213b46f6abd15b1068aa5ca662543f1977eb8722b0b49492aff0ac8753106cace57354924f5c880dcfc685343b931fd0f4692b5feb1bfd1c8808874e09fa543d2a3a03a79f012aafcafdee98a7f84eb0ba3381be6a9cd6e072095b5d9c50f2a97b4b13dd9c3365f4a9dc61b5298368dc7be0d67ac5ec153a1808f3aa36c516e159f443760b5bb3bd7ea49f5c2f005fc910ef9ef8891c1aa5bf2c2e47d3efe2aa9d7e15ae269826343a25889dbbebc86d368e730ef7c958a7ce06f281f8ac4c30fff527c517cba638d41c43ea61022287470cfa6e0efabe9fe5e05e40260c322a20c944d871648ec70d07a735de413c388d33bb9fcafee2cd3bde0616a893ee7432a5b833c50d0ae39a506f72ffd2a25e28fceb1b2abc66090bd3f727a06a791edffdf7c1c3c67cc3d76f97eba9e6b2c256809a4bc26b63d9d93c00aa952d167cfa8973212a1074c91d7f2ca7eaa04dc26336ca0b7ae99d76a7f0b6b85e0a5be1b4597730ae5340696711e0a1e9a7cf9ad040489f152d6965ec21e58c58e715e67fa007339772880dcc6d35862418632232b289f6a45cdc532de102737302c524cd56d204f293a835ad09cbc690726ee797637704a01abb9256bffb74ddad2be73a753aea2f7b34b95764ce659f2f676b4a3d3b1d81f86aff4375d643bc464dc4d7e5cc1850bad9b6e7d6007dec31dda348124c0cb70d40655517bca41a212aa40708573f0a5f0c44a66763732bdf62a69a300df310cb071b174e81910193a81944279591a9412daf100148b652023e2e275cbe7e956d93a41a2dfdaee94665f742efba5d6d996ba6978e194630be41dc332cc4a1feb9bde4862a23a7118e300e9d19ca1ac76c9c73a835b0e8a04b81d717200ecb95083e7eaecbe98f1e2b6997fa1420345be6ea808acd87836ca827abf12b0e3c36241838a17100240ab92111e3eb96ebba99ef3c9d9adba30a204d24a3c194271a3d59196f7ba6dc5a2391ee33652cae2aafc4c3ff10374d17d8971df0e6da6860c7316dd3cdbb4782220c6779fcc13af0bf36e835be8e491df135e208df92deef9e53447cb844788aec962467f4dcce6af20cec34996d28eece6ac8a32d96795a169bb4f8be11fbd7a2ebc80b38fe6c579431b879f4e6d1386d1d228ceeaf610600399f32603f452cfc749cd6cf73615f4e691b96dcb87e8e5ff3005c2005b3ed79c5e57ca7cc31030c7eef7bfad2181b853c29ce532c6e6a50a68207c747e4cae746201b8fb30eaa9664eb41922e75fa03a0b65d75942f7878396f7d6d25023b89e80cea2697f2c96e688e5b509e2b76768edf130edf6797325f100171112cb8a003492e19e0e93a9e381a5847989245b863242bac92ddcdca44749236b8717b8699b9d2b9829baa41272cc87b2695f9988108ae8412259560877e0ceffeeece795fb030b0797f89d37ca9e2f709c4caf776e38cccdc62d232ea61c4e8c528134cc979b869ce75ff49135fbd1478c4c254a7cbfb047ef2e8425654e34327e9afe70bd84ab571e14794ecc2c122c300536f4f72b0b7f0ba746248a36de952a204fcf58d0181ac088f762fe1b85b89f01eeb0a4df43039f77e7652720c7806d788ec48feea1b6ec3be234b9a8423d65c6ec6579e154100b09c4f9cd34d20d5be561701b27e300d866efacc28ca4ab635db65cb7d6cc3e659b8606e7003bec6965adc4f734b42388ebcd75a848e920873683f23eb609257f8f72e10eb1c2b0a3992b639742282a0fd717856c96e0182b0e8c4d204161c1ee6d9a0d224413f36f21ef226ce00d22e2e58aec4ad95055c45296d29a38ef0b7fdc38518ab84767631ff5e9d01a9c05fbad0fbc0886b5364be109710352e8c5386909bbe70293da8be3e40f287423283331cabfa7af4a0ef63857bf03688bcb5d55f7fadf73b5010d73d26f0224b0e8e1e080207fc0c35b193e83dff0ed93acd320e79c4ea90f39bc5a3f71b92d2c45c7112f63e820dafa608f442fb5a5bb7bcfc2085f698387137bbd0e96e24210d210428112bbae96514a5b37dcea59e68eb06a9deba9e6b2266c6b74c33f89d206366b953f715903d115e6cc92941c1cd2dcd7751676d65927606c54146233ddf18a473bc6be122dca84d444961724b8b674f9e255200090fc39649bf586207eaac9748bb0689d6d3f86431b81a800a9a0d698e25a393f04956ff77466674cf422d9e4a3dae765ff2d02e4a728445e46918be5fb5a55c4d22eead800c0c1502e3e15c346b9744fe1a3c92c87e431d8fa1f3502ee1198ea719d91c7f5310f73fd257aa832d7e42d212e3ac672f6c56c9c9a8aa1f89f9dd3cac46e7511476f8d65be689d1230abf87aca3473dfdc957d2e68c01a10d403f27bcf55d1e87b7615592b32f70cbdbc3d3d08ebf45e2101b0966a56dc22e404c8af3d95389011bbfb5f423df994f8c207042649e7ec2803ad44cf0b50437dbb6241b97ffacd2c2033b34b2c6ddead00ac1908f220a1e29e4c42a490c27f1fd55617359f2bc7c899811b2ea82b0ba251471c837d5c8a433f46c31ae2367168f7ac1ea070531cdd3efc062964f228219ac20cb40b177ad354fa63bd88c84cc56c3f489d313d548de296bdd8d8929359774e9eb6b125636d451850c4207e8c71d3e40d5e7ab9cca6cfe70bdc9e9571ec3a6387c707dd2f52f80e7fa318d4491d96f54461b044767d6e247eb61933053322a3c70de6c2202d3b6c0fad8ff816568012af886dd606af8c50699b03cf143a1adc7e54373490c792211a85c845eb8236111f80487cfd66006ee549215f2b63ded3bb3b23e49f3aa71f5d278b54d3900b5e6fde886161649bdf868c16a3bbbde18da9375d736997631c95c8b3f56dcc3469298c75a0a555708e2ccc9db1dd8bc9906b734215b3bd4e79826be3cd553bf1691379fd7325c5068f8ee50aa27f3b9f58b5310f74448f43e88cc4752eb1f41f51e816ca94c9f9d2aaa4f9a43a94277a528fd9798efa324f7ad2aa7c8be8e92d1854fe9669e774922340d81ffd73b7db573d7b9c59b4d125d0170c07b9b8ed787d644dbb9f35cbf6c063a45a87ca36d8e6375b4640ae70a6d1873ec1e161e54d5b9c68d690a8cf6f3bc9ce4ab6f8b89d37c595e107cfa93b9e511f8449752087ad0f4ee6bf815225fa68a5ecf9c36ee47b74fc1d92c5379e8936d235dee2688c011f28e902d695dee768476702209121c93ec37d334ca1f3ce75d005f57e5bd0a0f4de1c311ea454d769b25982808951b74ac55a44b7bc1d7a88643cd93fc4f1d0e73df51d56c1e2ca58ce2e42314684b9ca177891ef9c5bd58b55eb17f73c2db832c2a89f769e383b9f72083c930da47cdd9fab691ec3ba9fc02a3b16ca51ef813f64d76e43b4e2c3a58ebad44675b9038c53df512f7a3882979ec9123d65c040d09ed1db8c32afbbfdcd8803a43ac2c9957b54b21dfeaa6ac3694670263d66ff04d4c12b8c324f7bfcb5bbdf411ed0b54e21c18768e4cbf6484a198c0124ce3a24f8d1baffad29e8700a29f15b6b849cd31104df16d57d02d120d31155a798977a3c6425f58bf3da94ce607d675b6be06f0d00197c60f14f59ef7c87721be3d14aca08a0b6e8603bb72c58fcccf0416ecf10dda993de4ec5b527aed51eefeb4729a43b5c40d2808eda781117a1ec694500375938e8c225bcb7520e5b4d731d4e86d9d6b63474e040db21f76ab4c61055b8bb86000c90b200fd8cd016a63160e8b9ff5f265de6dcff8d37adbefed46723affe9cd8432cb78d45356a01201af3a1cec8d93608e7b1911d85420f843371404f90cb1c3d53c2d5974e85026d0557ae2c18698a213c7d1f6693f181bb8465869681b1fdccec317badea8c550ac5545f8ba499707680408f9d749dabd79211498037d7f90dd082e740201dd3b568cbb6b72c5d5434b381b79036ada9217079231d875893b1ced34d649f7b2d445231bdd7544870bd9ae6070c797c5eb6ede6915da89c52d0b1140efba67c5f18fdaf5115fde07f89a18212a11ed52ff67aa49f77240916dcf8ca1c49fba18491fdc96134d835f744d65c18680a94df9915bacf641f653373ee1d9d8de360d9c8541129c46e8ca15b58f17b9b3a808c9275f51541cc0ae964b7c02a8ac0f63bfc8e8f0cda0abf3a389bbb0260de78fa5c99789f62ad03bb5cec94b17c4a0b76647cb9de1a992fe4a7a7bc23c8d74bfdc43840dc51f111900655fcd23754eb1219f85d2875fab9ba98c66bc41ca4f0e28ff99e35af53991aa9c40685a0a13393ec831a615404792dfad9c38435f4623624ed9cbf4ce80e62e475ae99920b677603353e4c9906a902a8f60f7627f08d7397c31d451bd9f3be148ba24e27f5d8a5c77ea86531bfbfa97253113e23345eb6b73863caf3c905545b918349fd65da7b3aeee078684f43322c140303e180bf1a66170bd938d1fc7e7e23e47a4be85d7dbda047dd30012db4ce7dbf9fa9e7024ffb2485200e37017184aa76ba465c4988569ee0bf18580b58fc9762ff48d14d76023bfb6dad1b63fd45a469b405e2194e6ad27b2dac51b9183fc34c1b34d6a18a212663400a5f39f08632abfcd0adb92b2598b5b934efae8a5615e8354d6baf26fb5b0f9764310e8be56208d408ce384531a0d52cc95b68afc764b8dad83f7f0e36b6627fcf325231350343c0e13be7caf2429275c3a0209d2adc4585470cf5aab9159626e88dfa7072e29e59a9c83d8ed02dfa6368919269dfda01f5533adc210f4e28c9c880d888ba9cf6251783e1489cd2667d0e1a82211cd3f9f7fbd7ed0d6a8a284badaeef8bc0f19a68126fec97b61750eeb518597fe022e4efeff5d1b13641ec80e650f14c3726d7dd8b2c2e0a1625a127e9d7d8a3c0e9797799f4c5528ddb6fedcef13c21c188e2ff604db25c41a1004e5cbe506cd1080efbd971df214d3fc98ae47d90633a4be8c7a46e6555a7bb7acbf33c573d2676408ad32b6bc71b1dbabfbe70b5ccff399766f2f301a5777bb846b3ee8dc1ce9775790995879c72cda3fe1bf2b524400e37c0a8566981a132cc0ee288ced615fa0ceeeb69817f18a4750c15fbd4e5f5c2c21095693a077bc07fc782f28f3e2c2923b8299e616565d0ac943256d7f0a5d55e86275ab8ce1d70b898ed6461eabd02def9e5979779a0eb297b6d1c32c4c5de2dc7e5d99778c4e5fc3c0898d683604682b9db00ef88194fec74bf54ea272e3b93e122ef16bb53da75f04dcca25701642fa07ec5bd6393b3892d0b6c45bea024516146e58ab06acf0aa51eecfcad2a2d26784477a0e748788ab448b284a76b797e012f1a26a7ea1ac778f65cb71ae0eff37602a190c5a1657d2184a0be23094584c3217823b8bd001f176d9d04e74e3fb7d1f6243d9c50e5de10304b901698952485bc0c273fab71e73995a2f086715ffb3ae80d18f5a87e52161e48c439f81d4fbf7d8e6e1b04b82bbebee3fa4e71704ebd61b13d2178d55b9d7636e84f2c9f4a0aa843634240c75717eeb07f2e70e590bb362b89bac25a3467d13f6ca077af9adecf98d67dc43982ef4730b87d4d8ebf4208338d723896af3b0e11883ba0e5ffeaac5602ad9c272fd66c510117c8e36164b55a8d16e5404edbb8b51cdbeda3b055aab12bf447f16fb116b1faab648e7cfcae4accbd855fa1dbc831ae2872183bbf7087d38bd568e2494665d6d1db0f5d3201ed6b9e6acca83db4c7b0930e992091571c1d2a4a4eac4db41845cafa11177df637f23bc80bb24bb5cb3641dbba49523acc75f873c2e498ab42f2e5765b2c024e28560bcf7962097caf4fe226864134e1a485e84f720bbfb7afb90aa82c9565840d0edf10a39a1a8394b89636c0da3f61f952a0546a096ce52ed0dae1294ef191ecde27307a257502ab812c9294bdf4c1240ebbcd01aa6710ac9313b32927e2ed6605e4e14b021ef3dca3cf14c19191d3180fe5078dc6e1ed9ca22e4893d4ab372f6d1520ca4a98c5e6d9f9428081d676ddb1bf58ed91c1bf41e26c38ffea4c638b1243cbdda11f19f60da4646c606df660936c24eb1a2cc9611028ec2620cc53079c4a4d090f46576a970092a29921c259f49d1c40319ee7f29c604debb53b13fc51c4f2d4319959e1d8f6081531e7b83976b6414e050d0a0b383670b19709a061a35ba1e078ef1228f165adea7f48ef6a0809c134d7dac7c76ac1674ae9fd5399b02318fd2c5934658b9c77dba091e3576c14aafa5f7177352c09701054db8010e6d55439795b728824d61210825297a11b089e128c1c1a86332a6070ebf90ad194d663393cb105ba18948082f0f039f6ece98aa114904627887f585226395e285d575fb9f2d37c79fbf8ce2944834d2301b6d05347199eebe27b8f2362cc35c57c5511a54f0fbe6181122e6ba64602ff64153fd4d28603334d06b60a60bdc361d95abd0bae7d5726aabd45776306e3a46234f22c66da0e747fc125f3f831d2896bcda6621a64a554458aba0d1fcbac3c5524ce64df432d161f31133a9e4f3d2185dfdbd4173affd0f1899df106d110f79c765f4ce8f0d51d23ce0fa9c26c7afe7544cf14b56cd79a827ba627fe1c56a19047edf2007ad20a0faf2acd5417758095e98a8be8aba8df11c9b046bb5dcb299bf6dfa58aa10739d10ba451063c452ca8c70abed68bea088bcffc3a53ce4a1f84c0759b2f064817402da7f7f494af69eb2e9b2a85b4809413aae20d7e38e73e37f58ad2937b2ce077e846d548172f2bff7401dc42e4300798689e8320bc76e3a832720cacb650c6dfeabcc2827012a5194d786b3f4d2ae7d0014af93f4b996cd70c04770ada4fae4cdcf3645356a03961397d00a80ec1309c7a1678b8b7382d53de517ec3e4500c34af6b837da9dd4c8a44dd0e702f5e89dbc4e16dc7312b25572071a6793e13e734ba164fde8962bd261ae6f08f1e1cc44bebb846b4099078d64898834819d074e06e7c89571497bf2aa5d37db3bb25b879be0909ceb54f77bd016cdce54689181a02edc92c8dfc28f23185207f775d02ce0b431dff8e1407f30ac3c835839841f3f2ceb411ffe2bd2ece4ad0b92f00d473f03aaedf724dcc564053035d9b7bef6d257f6a74a8c4a8d28b07155b0acfaa39277ee9acea1025c5ff79005fd3cf48add60a54888560efd4ed1f2ad34ad9b40a6d063fda429524bd3c686857995188981fc3f50c8548508e403b0c8576eefa27c9202f5eff20bdd770153a479cd5b10845db8dd3a1f6fc4f92b0506ad2024bb738cd2b02c6c606c9e6de9b9f53935fb13fd77d5e7cd0d6141db8d353af8c6d46818fe5d4072499f532f61ded58a26bc6aabec6e2e35dcac7417f3bbb13e7cc16e7cb74bbaee1d3ab525974bcfe243d61ff28d937fb933d31b88bddd8de52fef9d89bee35ef7ba403bb8567bb26174a0742ed067a85861b47e21d5a6e52da76ef0ca03fff3910c7535b4c2b8900f359eebb16285278d4c245f6f3fed9f68a7a8ac4f0a303700af02966ecdef1f14032fe1c94c41565ee4168a6ddd78e2f09ef042a23afd60180ef8134cd24f1567793d97fcb776febbc5c13cd4b8f7af6cca85a550253aabeede8bad79ca2e56255acc95b684005f9375dfda27ad09b695708cb4575131ff5fae26428cd5eee36e932738761d5e6b2e8417895240a7f685d6b452d845972d31b397696f4d78c2633246e2b7120775438f5c590cb756be930bdfc2b9fb6d5f0d4cd1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
