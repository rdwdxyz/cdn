<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82f814ac6c1dcd5a10b14613f6dcfb7a3a703fbd8933d35d397044265c79d7d83ad07a446a7b9acc0289314ccaa6913207bbbf635a29da7c7b1b1dd6acb5ce5a53da7f302967597cf5fd3df518882ab2f7bb713ed84d4a37dea808d94bd09ed83b12537141f87f1d3b0c9fa30cd95bb9d6d7f7ff714c39d2e6fcd238c88ebf65c230419477eb4e6115b99a265caefbdfe060225b4006af5ff6e1450738a5e01e9924a9eb2285e20ab34555bf594a9fe32abd36782ba0fcbb05e5c2f94f46557c23dea457a0f254be16c7734490d0bb73f9aa51876499658f42e977efea284353f2606f72a6e40ffc5131d2ae9f87c653b489a73a9c39f5afdf4c1819313d44f9c24dc4c2342061a98f3f4ea9d8fa6e94cb69087dcc647bb87801f107f5cf8ed2423197d5ed0303f1249e4befb099cdef89e0d24a46268011bd57e60d386dc32df8dfe7c9a880f62c25907bf7a0352be3f5e56cc9fc157904cca1d8e5da69cded747dccce35b560e88c53c45cd8f9abf04079748a1a62b0e0b2b4552933d4c3a75749c642ec82462a11f598c9ce1d8a5815af0416a736651370de696f8e13029232425ce44afc4174785065ab7238ff2bdd92888ab30ab8da0812f91ddadb228222193ecb1ff5e8270280a1da0747f43bfe459a5e460fabbb502880c99b3f045278d19ce559c89cf8e5d26edf0f48efe0b7bd4dcce250a9d0c8ac2601237555de469ae90d75caf1bb816e940dc92916db11cd024c9fa768098cbee214e741f009ddf46d3a028d8a390ca01b3cdcaa52aeec2ca2e1510795476cc888c36b8aded2497a47f69c6a9376597a5b8791272c44db3455c63a01575ab1b16e3e8d817d34f987e7585807536216bcd3078d2be4abaf274e967dfd4fcf2a77f72444c876eee40e60f1dfaab58bbd895a3cfa9091904c3f93db3ded93830ca5473bdaa6553a0b6f960830d321313baf4ed638958c649d1996bd4419696cb93500bbf4b33645670087739e26a63636a4f82059897f92dd4c9849665e28cd60ebe1b0911cb9a7cb92b493dbb77ddff08f3f701203e9daefc79a188d01194eeaba4787d80190b2ac5c738e0d9a0ddbbff4c01b2d8fd185feb3f627d1772549f330a97c8ed76906489dda38c34aa3afb21e75d3a87cad67cac0bd047b0dbaa5e1b144ebfa5e250af8ae3c96ba7865ff7f7cde22741f88bd808257528f469df638089c258b642408f8ed0a5b020080e31278e2864e0e4e62033c8d05888746578429ed6c6ce0940b8166831b9bd42bb249a3697c0fac0fa5dbcff909978b027e400861056050f735ce2feb44c770700efcbd545cb31e158eaf762dfc4450c4c66fde417a53cd01d53a473ebc776962027faf58bf67b4fb7efeb0b35a0a1537a63811f140df23b6788968e7881b0f7f07576097d265e6c661a52bd29d6e8edf5cc1d9aaabd78f4f4d7dad0b9966d018fc595727b9745d7b3d21c1e13da2fc42a87b6e4dd5a087bb06249d51a9efc784cb10aaf7ffc96761a9a5ffb1a00f090c23082cb2de8d00bd73108a5613865d1cd911324a91ae71c52a8b1acc91437daa1256de156ce7f14d54dac439c7699fafa17fb46a69a965d2ac7c3c93d17165f0142aae1b3cbf820f435ab28e7a837072af38edba36dde169e3d24aa8002db5ae95f24b008847ff57a49ff0cc59f49608041d4e9e126f63082f184b65653358776e2e0a1ebf919293ffe1f479ba00a9f659d0e1e88042308b90b7ba15683894ee14a4d05f14512da841ba4f2f20439150ede2d463d7f0c934dd3d15664214b06aa5281c38b07e1d9c28ea820d324d1075e80cc9400e1130cd0e4099e355f4731c0288c792c475161830b0cd776135242f9739926cff1689db4d571d31cf8b45851b5a2c6b5a7b413c65a6073dbe87c8eac28dbf2615070ff012abec6161ac5c0dca87149be9a69f6da39da63eeaee402d38b20d45709be5819131b1b55d8231e4e67a57a6efe7c1673383f5739148051a6b63dcea94991186045e683dc4d8cb0b26f7b51ebee566aa605d2441d9aa04100df64d3a517969361e01ac9ffc09dce3226bb5b3db58e0897eaa0e235a8103849ced1b93121f58b9b2331ed101d3a482aff9f9b514604b19bc66f14b56fdc212ea878bac22006724137c9fa3923596fe5fbe11cbf379a1923e556060464e1d06fa314059eb659dcaa684f1df2fd022c7092fbb0bfb8ff93eaddd5dc1f96857cd501336a50766cdb5d8fe91f07f76760ab18029c8b49683d8c3be433fbd963fbe00438edc470d75404362f1ed53c4a20e3832e0aee7b1be1ad876c9e649b10e931ece04d0a511df7566863770c785707e1e981836344a602f2bf5df5875c1bfad2772e530f43b326aefad20855b439dc9a4da0143b92667da75a44a1a8096883d7e0cfb6b41abf6010b79374b8e6a6fb8d7b2984b4d45298362f214fbbed3ae336ff4a83c31555f7bd0e6b5c49e1e2fef32f26443f0747a70f3c8a597029407972f997db223492b85c89ba6cf4fd75f952aecde2ce85ad1237aba4b53bb745fd1d9ec52a515503f561b6aecb78fa26b498cb6cc19285538c2cc5882f66eab3c1b1343a706cd3fd70ccc905432f08bb8107e70ba504e0b419233fe2de0f78de0c37861aa765d866a06e599be6ef5dbfb58847bff6d19f549a6a7fead18dbe53bbda7f4871364e63288286ecfd833fd69ca16e780a3c53d0b957285ef743e940d8544c58e344a7cc14fd2ec6b1cff601f9f15a4d46988b4300f9fdf4c049b332842fd292dbb04b7b739564b4e43935026b389481406087f0beab7b0876e05697ff88a067e9c9bfa11fb57bb260496836e7e67927cfd356c3f279441aeaddef8c77ec30eea8f502babc5b952e09db82ddcb1c30f7a736891f8f9ff46ef8f3cf2180232d3db71f7a32dc83d65cc746fbe87eb43c5177eb3d4b7cfa8585e2f60b14fdbd07a134a97508315971b079731b675ba7c458b7662b2ea940b21596bb5c3bfd9aa137ba7bb75eca72135052a7f0e1dc8ae64b3bfc5501eb3a4ee120d2bcf567e88dd12567cc89e40161bfb14f76af00f25ff8936a7e65af239d8a257eb39b0cc5d336356a9fd17e031b3db5e3eae518743c7cd314d0d621b0a5d266e76dcbf9faaa1ee58d76febc2042fdb6f0f29931e4731e00582e8d549d2c2d868091659de210b83246fc1811ee0a1a844a9d9b43520d9ba0d73c199652ad0b12ebb6b800c4b1c1167f350ed378a1826d2ced2aa4c2a65137c3cd13f52658b4c2da758cbadcd1b485148da5fece604b3c0eab51e707e0e025553a5bb730b0d2466b434fa7ea9d03c9da1ee99fe962c2dece0ce90078450c09ec7868ee58b5807ca4546a6fbb1bf35778c48a6dce7ae9d1fa43f381c35f0c0c3edd2e5bd4a639489d950127fc24daf5dd88bb0e51d89fbc1f3e7bf05fb207b9ff071eec128960eaa5b7c35c7b225a2a8f2f0fd099b29b440c30928cc2c75af47ff6168ff1fb8d0034a1f3c3efe8f85ce5d80c04e53aa75c89670a68d1cfdf6329d5ceb2dbf20672f8e4ab656ac6db4e88867c8f0f1de6bc597bebd715688d58a0d5854fdfdd6583f30d90dbcb6bb7366f0965788409ba401473f3fe7f35bbf62750ca05a94a081fc88f78b296ac72bc183a98d110296bea4fb9ec508ce5d0de20dad0c0008901fda120d873a33d17fb19190a1e27a687ac7773f91d89476301399bb01270ada2a2245594ebd21fe66327f343f7c573b02fd1709088ed173d5fc27074721f6d8e0f14e4cbcab83706c101bd3223646e951254855a54f3abe7d67f658e3e27792af0f8d7b57323b2e1e8710d074c06ecce423c3c51bca10d837593b3a6dd436b09abd5501771a02ef07f88526e78d977ccc13972af00abab7854d2905c673a9b866a0a2abf9619d00f326b50a317bfaad00589c0882bdd267a184cf1cd0510150627f296bd49d9ae3829dd0a1f0e3ef2763b6606701530d037010bc976e84b35c1bc237dedcd6372f09af1c7920efa0f9b59b4389e24847bc96d87c3a70401695d19b96dc8b4d65c782a59a18a3f0a1a3114e41c91863477f72c86f6e1c6462d3c87a7a1f628bd3ba131d8e14754a85b7d3f7fc42c5aef1de0fdb38f8b2dbef9a5fad9c1725f2a8ce4290453a55e06241a40cb04917ad7b261780f281ac7017e462dfd83ea5e822d213915fb82078607a89b755bd5bacd60f49cf3e53d7bcfa9cf52a8e051bf72f1eca0bf6e416e5a8759102c1db672c4022852b9d94adb2671fe5800ce9092715f1ffb40f050edc2f0bd22cfd50f5404a692b1ee839806d2f0a80ea87004b47e2a1fc0e0c7d7816bba18fa30db45a5f5e9c83bc01838c738a974f9c4efbb4db4a07bb1aba90fc166142b0c666bd21f0510d9479404f1c3eae68f130dd2d344fa6c4f1ffcddb2b52ed9b2f45593350db8ac1dac4d51689732fd75ec713b3be38fdd75c712b6c2f7a6bb70b236b83ef4a17da60716e955ca19ff10d501fa180577ef0889915d14ecf66f9fbd428bbf5385bc37da9be1bb64575251579b4661ef80545e0dc1208b0cdd54813a51dc49ce5b78121f99d468c5776dbf850307c2749c2de0b959e20a22622b14dfc11d78824bc07ddd9e8751bf0350be90f030d288b714f28ead5a7ab0b7545c463675cce83dbb2ee75d34a31f8b684fd5ee3914480b5707f64a674ae5ed98ec3dd6deb247d64946e2064d878e732df2201e6938e065abb65dbac7cd2146cdbcca165387c96269f07e5915630b2ec6fedc4e368a36d1e756542da69a60757bb49b4eb2db417f6aa303c31b1f6622c6f90d0e3b1d0c85386938a79d70be8ffdbc0190c64c2df72ad28b91f74ad88e44f2961f9b932959e3777534e1e66511dd19a0d2402ef3b7ff1bff33ccab4a2431ff2628f6d4012c316e3571d1a49c5b545d6c0fab0116969a55799924c53b9eb1c2e2853efbba161d9447b80a7b4123036bfd24667bff20f44e74cf70c585536f75354ff49a9cc734e1bb15c1ef553a2e1fc68df0c8fda9a310593e5c67835339494abf8fe5e9fe80c87d642fc1732e8476b32a7d8e3a990759b023d426b0097b98fc7b3ebf51bf8ab02bdd21c03afb2794787a478297ef5e06480a2d362cb48793ab29bca9976560b2c91285bcc00f532c394c8f27788c5b52a5aea7efbe39c332616f650538970fcfec6024eecc28489e9843ea25cb566521a3e67d55a517f7be44955911961744cdc6392650bb8153076e753d4c839b13e5afd88590f2fe6934b232b3d0c2291ad262c756addaaa6cbf9cae4f3aad64305a6af7fc917f3f657b55d886d2e700858886ded728f565dab1e242df4d7ade6e70e7876c6ce021355a9dc50ed71da0ae0b60c2a66e6e5f261d5458cebdbcfa7ae6d1478a3f699dfa1b31cfd020b55f44eb0947a72bbf6e544821d84d8f94790197cc6fee184d8801a294074730a799574f5a7e9fd9498ee8f641626befeb3c206ee7fc341ea3eac9d020a919e3acc35af5c51662d67ae166cd1e4d287081dc35aa5cacfaf3057a1f6d185ff830a41015fc4a8e09d7d2d00becbf6ca4831b4e33455894acfef64cf9f562b29812772baee05e24c629acc2f31ad0537fbea899f2681b3e4a1e6bbe5e4760479f90f63a6b383f4f8640ffd0701ea2ca90302a7b17b5ea4805fdbe28eff3036a4030db21df370e2fe8db21983001143791a9a0d26a2b8cf2a705014989c5026d2eceb08c42041e4b4eb65986db8b9f2bc6181156f7a0a88ba2319e1386095bc2ee9e955890cfc5da41052571d3f5b0062149875c5de91a47d7cc43ca6d53eec493bc8b364a8f834c88b778be4e337de2af535b9c19d31b73bfba9df40d52e6c5ae8cc651504005d232cd804423a8d7bc596347558316291c47b54cfef62af03838cb7d68f7459847dd65ae4be180a5e9def81acf7286308ecf0ff8957949ca7f523a24c37e7c109a40c830ad69a08b59e4a0c5a8a0643076a70b81dd460cfeab0724a5093ed65ddde3ca41f8c8d026810c4716ae4aee07610502f3e7985c99d7b25790bbd9e36c86d6ff3e1b6c9be4cda7065ec520dfb6e3bd4bd9a3e04371eea14360587b0e3d8c92c405796a6b6bb0611a925a87f9e451d7b1019fdee734bef16ac4f80c5f75a8d501eb4daaf10d2ffeff4e76d6a55da4b0d4b62a4f6a9359febf47705980610352efa4be9e2c558a6473c4b80b312cb719963486a91dc64db92807e6a2d3ba9b210d4c60ebb48ef3bd28aa40dd3216d3737e823a3733b429088a5f73de6626ecd586de6c8a3a3b8437025a9c0fa7151778f7974b048432095bf6e05f92c5a06ff2e519ca68b6af188d3785de9f20ada8496ad41f11cb2ddc01edbefa95c4505e46aad8ae1927a64cf1e64bf41a1f0b4bef40fda675c03db1e023543340bbc136def47d2c559da7a540e52f11da2e516cffb672e04b6fee6d3b0586d3d165b1ec819b2af9f3ef89d638193ebed4a5fe9cf650085309650adf72a6bf5013e5dba0a427f3aa1274da7b36352b2673be4f273afacef910b8b385320ae656dbcf11447780caf05cd619685374d9e484f8adb9305bfec1c9d9cbecaf101842335af435c73ca1b74e4a7ee2326a7aa0d8f665a252c7471f98b224ea8097922e1d46cb17d8d43889f2b0a4cc0e8e4b53bc35c1c79addc6b91acc07931d25733dbd994ab9200f22b743a82e472b9b0b0d373ca1b7552b83f68442f8d453ca6aeef9ddbfeb60fc847e1777e306da7353eaf2845a1abedcda12ce615d22258e68e46e720a086484bc70220c3ae8bd6f549564aeb89393ede0be20c0f6b17bc8768708d68f7a560939cc4bdbfb859c3210c54a70a317819f95020d37bd3266306eda3723bdeb38272def62899af66716765d3f2c6da95462fac7fb6fe43f22a06d2ae9690eb8fc04edcb8bb7c070509ded8b2d13d9d007a985c59202dc1979f806835c9a783e0be1ab1b58a32b8f31254669a8dac1897178931354237ca1d8a5c66616248d11b839db905d00ccf14a21eba4b981a6217b0c143723ae3e49f85c5d0bffd51a2b4897316eb7c731a4b19f12c2a9be7d713f151951b5ff69906b77681640633ad523d777bc5a083bbd24eb759f9340f630e38f8a8eef5d1a09586a61baf0b53e8f22dc5246b55a2f144c8729b9c3bc707396a65b7e4eb4d7815d61867bcac8006e94f771e3c6efaf682a710b9e5b25a5ece8e7936ad0bfc4b6d6f4bc58c0cada895ba0cae6b7b5b39f74af70a4ea7f92492f951101c5bd08b8f1d509e8b07ef7f7c87d4cfd8e776deaf7fe8cabdfc0bde791e59a3d0e2cf81064eb581f38feaa03c3cc94e128fb3fbf4df277d41da1196f0f85df1c068248609c1f0e8a7c0c04e47f99075651a5f268265943c41ee86fd690f88c75f6a954ef8d6f9ee3d6ffa23efd6119aaf2b3875388cd99180a917516cce753b3e1029f6ea3440c46608e2200783e2920ec37bad5466ff490c05e0503bfbc8524df93cf484cf3cc8d6266f805c938b7421f1eb15216f266a0600932988ba422f264f9e62feba37c9f95f4f17bb4eba04f47d48275e36a4282f026f51842d77968843e58f1154d7bb6f6275edcbab12d6f135c31855dd9bd557585dd0a4213cc6e327657e8fa6956d03e44734adf60bc745daf3c15a11da5c8f192e8e02291fdd89a95d4c91b22293594c2cf2a3f6edcb8e30c77ea8ec50c863fc7bfad9490e808fd0a8327b70dd19a4bb149183e2f72e6f1bc897e24efcbd866dfd024590a1a885827b5c9e01fb1879624dd437630bf8977ffd8cef7883572a58e2984a19f14e231841f57b9911eef4311d963caf8cc76d223f957c26c3da3bd5e0ff1e318f23346dd0b2c049ec9512985877af2d3a42e19602c4f0e43ba06f4fffc9b8afdc7cfcfd13f5276f90e48843ec78724969dc1b8b06f232aae40f2fc5e504ec6b551c84b1e8d2d9fe12aadd94c38ef06be21a9ee07f95a497d06c5694be857d4ccd9988c87d75a10a34d858c7bebaa7d42233c4bd1a24e003b14ac1e228579d795a2523291f2c9630f7cbe4716c8ea1742c40c0fe676e1c0cb6a4fbb7330d83b779b0379e67e828549967dc2f74dbf89e5618dce15df8f607d3d19f264a2e050b3b2e2ebbfb3be0c3b80514233a9cfbacd93188b794de8998ddb5ca744420933a1d2ef45014a8cec3cd3dde1ff68b548602485c5ccb58fb951f15ada96051bfb5cdb4049edfc76e8bb90cd1712fdd4584e256ba3535b760674f97e79cd0ac1a5a2a9de44bff0b2e8e49e132949beb0fc0a6c310acb6a87ee9168313a6a6a1ca39f8a6c1c1043c5739d94b93588d405cdcc53d14dbc7d2005174e4183e784c2c05009a6da6d699fcd59ef783d0f6f7e6a755839cc40ad25a63d62f65c95306e97f6f75a3175dc6ca576cfe53caef732b4d8f42100ec31f6b12d1df950bf9c5704e1c39b8bc91a83c3c9978f71429a5cbb7fd47e4b8a4c6195cc335ff19316c12caaf24644ff53ee0b658e62c1473194eed90733f7f8537503d3b7a8bd50fdcdb1fba49e2f02cc9bc95d740a9672957a9e60d70dc0cb0b97e29649e24a87871f1d44ec633f77bdb7cf94a17730c4efc5475cbc1230040cb12510f3c640f9aa218a21c8ef71ab9635de7b872f7646a63d85688f9391e84385a366e11770ca01d2666a4fa507f91081f18339774aebd0b84b7918e00f968a2102d22791f2a05f7bec57cb9ac7bd390f69eb457e072d142353713077198867434d4540e2543f97bc7e3af27bfab64bc93c58b063e3d26feea9e4ceec999de19ae01adc6979cb797cde4e1df60775707411a5ab53aa065347fc454f247c4c5bd17831a382349d50ea1868fce4ab594304d9229cb81e32f56f4e203afad26d0c2b0892e764c3274fc7fc10d296064ca98b88a88f758203d03703f3f2d4f5e280cdb37b30b4173185f5a1611a25930b1dab423d65b7f397183f791fb093b83ca553df48c5eedc480ad6318c65ed1d5c2867b3f7c5f732df8dcfb9d4b14e2247f84c79552a0bbe1b73869c0b1386730ace1bc584da98bd7042c11c75f25df0f62d80332c94112ad129aa1adf24a5e39401345ad968a3b3eb9f17815f3493c23b73fcc359febd705743ae3d1a0a519f86088991308820294e98b912347e0d9e21b3e24b83c92157d3641485e04177cc113839f0838bc54c81883e5dc1e224d25bf447d8be7ab05884e5568e9855d9f199e66e0cf2c1aa46fa4100b23f4287bf9ab8b0965c2f55a958005138be6874823f11e5c2bf51228a412f18bc199a0b9c6d6f1d75e981108eee1755d71447b7ed75dbd4ad8af16358bb31e540c8c0ea49f473dc41e76e85fec0711e09564e2abc7714f76d94675211859574f4255bbdd1de44eddb76610af638a5e1914afcf240449b6bbe5c7e5b6dc4ac95754d10ca1a8b59e1442dc73b2b1b09ddeba81de2913d1934d121c907ba8a065d16f857ae3332d344b3bb5daf6069a628ae24a495ec55a20e5e0bf0005821e49df6f5f177c136f3e46f3ff2a15a710911399790e15ebdf308fdf46298e3a26db34065e72cb7bd83514a9ad948c81c7bd86f4db1f4d8d74ab90e8cb1eaa15301134e80db8bba02aa05b31b74654259c8d6bbeb59865e6b57b9ca6dec54c885dc709b2293f7eb988a8afc610d921b2c51b85f9df0e1a394b5cca795994d3172ab7b1d36cf248eb31d779786ccfe95375c7265539e846b215e020e8ef9f191e00f81d9aca1779509031e773ddc94c2e95f81ee1269b2dc252ca24e0162ab73d043e88c0d71f16c3ec26dd5600ea0c97be3eb1d02aecb577c3fa19ba19ae3fa19cdc22e80382950abeb7aa56e24c9917f5518b229fc65d426bc1462fb7eb9286f3298c7a8592e96bfaf136ae7dd497fdea1dd80c67a38b4bc29c0360046eb4e6a86f036b2dfad6413d4e98473b163ca61d81c7ec185ad95797c693708bae2382abec80c231a2db451ae2fda4cf1fcd7ef4913962dabe98f5e7b8475df0a5273ab5e06c00a300b54716ba85ffa1cdec74b36b42a597f10363458f684ec7f6075addc354ca25bfbd709a53cb05401bef6a601e6efbf5588b50699a1ae73a2702d1344ba94163ebdb328d321a57ae1b435ea57c87f08cc784b0ed1d34f0ae570255a3c5537ec7cc262176431fe17c2d2d17bdd7bfb5db454b9c0612059aad4d2a090c58db76bacd6b79abfad821e95d50be7f90c19c27de3aff1e58edd0327e62c3f44fc1cad3007087c564e54344510a8a6f4fa5899656640dd377b426c5237e895961f820a5113aa2ef6fa3e0d7c1b81968734a91f2923b6e8538089e30fcdfdf80ef9b6efd8d7450b6b3e0a92656bfb2161a5c2abfb35d0f9cba5e4a41ae04c08c2623332f129e07f8ed09099b67504ced739eb0b41104","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
