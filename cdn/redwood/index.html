<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9740e6597e96da267e03b86184c7e2028e8267975a6830c8f17df3c48b77d26ec9c82bf03660b6bf7988103d2b083639741d8e011d3c5625fa0e1b5e4c80b46144c3cc98679d8c77b7529f86bcc6ddc899faa266e2beec4261076f7bfce14a68b3a4a05c45f25ca6f68b417420e3fa33967e9ffe148ad256d3831541b285f2c390b3e8167df784c35cd2b79741343d1457f3c6ebf9f6571466df3ebb9941bf00a2b16a350d94bbda1b15427a9ec21162ba040a8a2c0b39590b88efa76d872ba33756f586356b6dd6cba955f1b92fee847577fed57ebd6120207485a9af03798360762048090b5afd7124376e04b08d13ebbc68bde157ced51c10887ab1b27f0534d44701ec073f167d98e02442d1e4182038e08af4d198d9979c47f1b8fa74e6f90b886da902823d8a27c5a71258ed953a77b4a86e33e3a8ad2611e739c5d30d7aa0a539a615ae25ba3a8e296b0dae1b033dbb85923387c656c9bf80e69317867b05ca5901d3a18f8d1cd8cb871b227310bce3806f28dee320ffe769b73fc09b4294eef5df03c109d795dc2145a88c8b93c1c660ce0a2cc343184f5617229725a6d40260e81bfbb325a571abf3e2558576b0f9b3d144bafe4859c826a3a2dff8cec5ee68e2e0b637583c1643cea7b04c5632ace05c0ac142a524172a57502c0827a3fade39b8f918f845d73f1fb799e9cbb085042156064c918127d210cccb68ad94d5d03b278fe159241bc55aef1a1b627b33c9d9d9e3f7ef25648f80baafce30cfb83a695a28c2746ed33d38883887d580a9c3163b1ffa3ef97620281d72a781bd4639d902b309c2337b497e08d0a1ce821d2d33172bf407722b23118c7580c284c8ceebcced9a9a067539045d1d6b773af11b70e237ec946997990c58f817e02366f549721a980e8d581abd28bfc89e38f2a5577da0c572f67ded969da39b3fc6048258276482c6a8c09f9135a0b487265dbf944359853e4c70ed2baba1a173d1c618db3dee9a9165bdc6d4b14fab8bf99596015d2822050207dc05d42261f529abfde556a5bf68e55a6a9bbb09a0f01679518108d4a8a3ce3ca2885e712cb7b70d8754bc5db30827fb06e822bb6f340117a1ee8e48085d51eb408b600ee410fa4fd6f6794d98faf7630debaa25e4016b84e0a978a1e41de181da373580bbe1ea08553775b0cfc08d32591ef4c552eba1d6b0d6af50ffa28ecc29105438e02a873bed074c4f98cc9949f9c15abfe791743a3ef3e487488cdbe1092252b1d7d699a63a081c6d33a4acada3a55b4b95b5e2a0e3e6d3d14d0500a55a6126403c75ffc7ba2d0a07b360c95801c9398b6d270932e6ea6cbb8a8e927b43f86677d9d769f3ef89c75ec03a55c790b0f499ac05d6d717d7486ac12c437a198b7150abaa31f4809d76ae9bfdbc985d41a3a74c2d87a3008b34c2abd536dae4d1311e435edd4c4eabcf6337699a9e55dda868fe7d2ebd7c4f755c9cde4649c1a88097bf640d9edd95963e61249d2af294846e3967a9f2216e7404455e74c42786feb7d7117558e8be518100236650388abc5ddcc5fd671b9f2b83288d767283755b36a9dac16302139c30518b0ba342d173525df99a668d4e08696ab8ae2d9aa387f1412f0239ecd3c3d26e3bad9531e58057332b350880b1a5b656e52449c1ff610f093de2e7f6fd7a665e943e82e45b45fd5dcbe4d980efc060429a77963af4a4b1a8db960b16603085b535871a15ef02b2a927317156e7fa7b60e75bae5565ff9a647fa3718ddc29cc33b0f7402290a8c16d0ff3aac07d32b747c0ea232c68eb2f39fc87ed0944008d200c39b9246fb39d2077ce6137e9ea5416c67f61a0d69c845475bac6f4a27597db44942aed0035637999a746c38e932000248084d65674c6242fe9b986984e1c54d2fd3c859902b5f5acf9df0526ba575176bc582787fc1371ae7f50ab0b05b879c92d3ec651754f02d538fae0a4d09bf00ee7cf68b1c56f93e47cba56bb3afdf4fc175ac66af930135f5608fcf9dc2f3396493845044ad3af67c774deb7d05272425de3068421dbd7ed52b37bdaae9ab5b6c67254fbc26af87b2fbe90671a4196422fe7bbf0038165438ddbf6a1acd268f01cd83ea3c3766ca76dc917dd96c8a7467cdaf8988aa915dcd041e40f8ae65ee9728675072a5dddc2662c238a5928c74b8820db00f47e92fbbe48371785632f881c98d7912e024c543dbb30d30e456209fcddd72175d5959d6d8276f13409a948c2152d6ac6dde7fa213aa44231613be529dca86b778ee52669c799fc6870287751f528c49090e29449e8e467cf5c090e565821cf33b664b92496c662a4a3c75211be686e567bdb097fb2c024e2da584c595ac842df9cd7aa797b997dff5e041d7cae9a2d6d6691a10a5a0997099a190356b799af8fef9b8820ed6a020172cf0bedc4552f4d85f16816022e25e5633602becc41334455112a135a0b9ddea92fe35092b1ef769411cf81a90ba96a29fe58800c9cfbecc67287e11c9ce734f017413f643bee688489b8f01ba901dd60edefcbb316f335def595bb827f6efeeabd53c9fd901cbf29b3ee0aac9a8047a6ba839ed71e147e1c7cc36971dba1fcd955cb1b70d85768a477280b96bf84c3b4ac1328271063f40c531caffce4673ff887c3df87ee5389b2aa6dedae9673ffefd5eade964c620e21ed05ddcdeea89f6ae7ee965d7c52b827a5019721f7b636e728bda8a57f196293bf2d1ee869eed8f5f7893fd92c215819120383ae338ada0b1668f2f400e2b7a0717bb5296c2d5c584728fef9d36b2e11e2d05e0554b1db06fdc4ee6a235811d15a036db1eaccff1b9f1dc96f4ce4528020f2c00c85f788179ae807207bd658cded28bc15b8416bea1eda6eca19ba88244350ca9ee39e37eaf0799ad0eb2cb8f155a63f8d04ace789abca008d6014e8cf0d9315074328cd653d24e1ebb27e6695f439f98322532608debf048426b9dc67753d75323866eccc91c47be6a88018790124bedaf02d499b454276cc6f7f81213b7e16b33a0a305983d6a521fee1c69a4ef74d515cdafd4fa020f557e9a911bf64fb96b86909351c2b2906ddb3fcd699e1c392aa2cddc5b28753a1476e7bf5f94d3984ff15bcbf37a430c1785ebb9f26142ac7c08f1d51bfda240831a37c65508b7e474807756bfb59ae262b0d17daeeb1d68c834dddf21542d85789b561925536d1b7caa840bab96670ef6cd19509a0a69809cd2bf82433a51cff1cabe59f6dda1aeff7e74b969b1daeea490f32f8dcadf46424a79b26523243208b36f17fc38244910878486bfc8fc9f602f38548cdfc8a26ba6ddb6067c75f5930318906139f9da6107ffdce46c1f926f5add08b91aa1d7247d10ff44a56d4111d13fe012cf5c2061f428e999f2044915df1fd7aec82604c548f3f97180912bac3df11b05ee9cff1be1138e171d829fe2b874ba5995b00ffae287105f2183f263a6f554c4c3cf5ff98b9a0f068f25680457035980cfeb9a1bb53696d49df79316afef92acf5cee745d056617a3c8c25d0ab4889bc21fab9138fb03597659371bfc89a67000c7d08b05de879454bfd7a01a5438663acbf4ecce06f3580d633bfb9ca9750974530238081ae41fcfb761299b232b810da2d9eb9dd3cf6baa4bc761c213d4dbd47b65740a7cae571f3e3a61dc93fec4e12fd55dae0a085c1426c4860e0caa3ccec88bb261b994f8ebce6fea264e8096e22df51919cfbcd217180955269a3e93e1352854c1d0561744d8c55f83669d6d704342449d5f2826c59ab4c0fceb6ec45a45b38d33d2dbae6f0c25cd30e2569f99ab40fa3a406c2093842eedd0471e99830d91d6ace2b33081886a8c6f2bca4516c972e1abedf58ae1e0819657b23391ad829d9dea37f26816a40c9764db38ab2ea423083542fb2b3c8af04adc8d80192ed4a45ff853b91a6d8ecf6bf65aca4cf0abad423dd6ff2c62685144f177d7d6c718ebc275d473bfed6b0ecf334dbe9ba707e3376f4ea7cc747e98e267419694939d8fecf1f54034918c53c47bfc91daacdda4f4cab9dccefb1dc2f75c6958f8ec2b15c813d9932b403db4ec92fbaa7bc61c25aae4070cb3f64ce3a69f0b1d836501b113ecf3411375001fc242ab5e6376935b7d76d34077c87b23f86a5c07ebe99c76eb4c384cee0ef5c582039982425071b136fece8adfba3e1c7223f81c91f50d4dde92e0b6e1ac5ea42367cdbdc6828a8869742436ae1129430424a42c157cf666d102aab19f49adefeee11be7b0129db61fb3077da0829708bd1a9f195a473bb8facc25c99fd72133c1e0d229521b22770b1c5315595687073ba83287f4c54d93ff8c348b775fd8480f814f30be5235a3c53788dbe34ac6f9f001f684ddce60d8fee565650c10b9991e896b88ce27f3572078d60ed43d0467aa0f26ffba723208baba27522c5925b18cf92e208696fbf430f620a65c2b0f5c453718e21cb6326752ca079243fb8dedbadf78fdd220675ca7801963642490adf6133271af367e7a8fc52a250b31aae7679050ddc766c732f3ad604fbc06b22dd9f17301008b4a69a3628a312e1cb3c5a9a10442ffc3a4fdf6998c6294fe7f32439034d3e08c5eb5eee9cbb857794766693f87a57e89e13a8937ee951511621d43a9124228c944246bb56864c848013ec26cb654169a20ca16e2b59d18971950aab814d93b5a44ddb2062f12fb3ccecdd45516f772d007f3db95e060ef5598ce83c04b752eafd867c418e5730f0d9480e3b9aa699d27643cf3c3e7b2d26d8ad407027f015282f9f5cf49f444617d684656e66f7e91f97e87ee20cfd9cec4e38746ce6dd005c64ee9e8e3660fb62b712965025410419a7908d2a94f99d10c5c57aa062739447f2a2982cbe4454cc0f30e7206b2973db60be1c308c1a677902e295e343d3d82ab33344d22b6f0d0576789c8e8983eeeea04fb162f6d2539e48edce865fe179097e5b13498e3d21fb088a94cfdb030b1609b64d5427d6ad163e8855e869f0728332f35aea61692630093ae962b14a6dc5ba5cf0a322384713da5042b014707015ce19240e4e7c44e1d6a9972725770be6e170292b0948a72d3281ff3576e4cbe3a6b903b5e553e06b09f796bc205e22cbfd78770dc8ba67cee6d89c867ac09e814b79aa6fed8179ec213c6beb6193ad3429becd2e5aa1493061a910d79a79d1e9729e7d87e471974edd3b71db33afa8ef15d0078da37f68a9cb52554731c92307b371dfcc632d7c5d6a30d0331d95a8898bb1a2b3811f37ffdb505fa8fa172c7e7a06d151fe3eec4241fd9ad6516c40fa48c8cef8e616dd4d3092303c94ec3c1b14cb825017ab68799e50b3f6fcb8d58eabb4759041b6356401b60de368e534123a7aac98ba5a518460a09453db16b8c5df20e256ce74263ea5f0a06e3a7d476f145639a4feb9274481d1bd408e9f9ba3805a516942ffb7693a4dbcd740b31d7d3802b6826a0f2429e2887d30e6c8e5b661deca0362e30d18634d1223e68cdb6aceab09f7778ec759b52977e341e3f9ee7cae238ae23b966c68844f04f5086abc8656ab99e7ba472da355fd3e8ec8bde280f9ff2fa16b9fc061707d4dbcbf85ab6e2e9c3bf784a23842fb1e2e53e1924aec0d5bc4a604450f2f3ca61b908b84b9fedc58384156c1e9e48dad2cfbb1b879416ddd1a553f9e65437a20f8703038e390b31a36417b8c1005a168c042d6ee2f9fa5f2e813188daec578836541eaec22fc7fb09e86042488ecf41aeaab99c984631114b0060dda47035355092c89cf2f9877e83ddfe10e48cad4a38fc881122cacb4c4b7dd6829eb42c6869bd63981447d034b1dd18e917c2a08cb907ce84732360867ed3805c52435ceff4699cb91f47e3975d1ca7cc21a6aaa7b39a3c12f4ffe5e266232854a166063e63d255831306f6dced7e5126c24b5bcdaf08c2ceba64ee7d23c5504cb89cb38a92d86a3ad9e5b8075fb356ebb0fccef54ca5c43b0925c9a444164bdb32dbf8929abc4ad9e631663215c660b63ca73b7fa4dbf239386a67d36d75ec79b23488867d7a83e43c1b346cf5512cd40eabf3688923a10d78e2b1981e3c95df888aaebe16f2cabeb473dc87ba2c025d741b7ac43e83c5bf455a25c83481083760796449a1909e3f480391b056ce2d6251a5192040f02b7114eefeda7e01f72436e91b4cb21eb2d8f464ff06dd934b84b5ee269001e4f717b9fb2f7380bb6987c92e0b0f3914f5c2df0ff87f2c65f099b80d2b9d6ba8366ee2aacc1680f97a938a9e060f243006e4fae90ab0d248c7d4940d91d6816492fad1edc8f19d020e6db7dd95d68fdb51de1ffa1e3ec9ae3f8700bf9eb083a3c149136d0ccefff0cd749f3b90aeb6516f0e5f554e86b8055f636a463bbfe05de0ec045bfb57d320eb07b73c4de965e65924ae1de7a0143d217354899d4edf34e946def12e2b449ac38c3b8cd0bbe9d2a68e7134e0c238ca26992a214a73d441560c82bc184e0323f06875fbc5f80770ed6e8be2081c5c6537ee1bf4f8ae6db6a0cf6c50f0d52b3b883c7ced25076b0ff272acadcc3c80a00cb8db47d8dff9b26f3a8d3e28e3317e6d95e6b3d8f179a35cd7c3caaa0b2c9165c86a9fdbcc58fa731d8936629fbdbbed29446fb436d97ad700ab9f418920a6c6d0ae57670986e9495fff731ddb8618b008324bfcedc5791d5539c6aad3e1b83467f2b628f65123604dc30a25cfa8c8a4858b459bb64da17f6f0c7ef532c431c310632c1831333a0f5d3ff6026fe5d0bcca0e157b31ddddcef5cc85cd6e0ce67ddeb8dfc2d474f10a2817900ea5187cd909cb9aaa005fe8ef6c79aac91224690e9cbd07eaa53886400ab635b737a494f44d93d8bebce52b9ec8b91bcf61310c76a3c68f0f1f8e6b0349b1ac94a3cb3dde7f8bb5b14df7a6e8642e4aba1955085293fe13d27fcfa689bd1a2342b7c56e5b0985fe23cb1a3b4a80193c77a249066a6ef5587359502721168c90b1ba62edc72890dc6ddc6761663c65e86003022cf179fbf65e99ad1657913ba162c70ec1b251e6a40ae107d3afe92a7d55a91916344d123c4de94018e4d9c62e1294711c61de48fe7d91a1a36e3b510b20b0703d8f589cb7c521d290afe366ec1b32d55f12a03f451dc37ffd5f7421d873677658396d4c0dc7a05632b89601df7787de9b08018e9b622f8a0934a3848ed33d8cfb5e958fdc83c74fae3901bcd26c2fc0817dad96b2bd901a5a4c14f46680adb845034abd25015bf749eeda97ec75779211bd3a17a2fd2552d075ef9987a5845752da59c24d510a33f23f5cae1c526cb7b1d03a6d3ebae8bbeff5e9211bf066e51c8606c228e6d25c4f324380ad17206c8c4d29f899a848c6944fae87a19abbc813fd9a48b19d19a3c99288de596e3993a9b2c7f6ccae74805c5337d522bfc47fd0e047c3265c39280efb329d5de9f0f4aae49e74084ce9697b1fb960bc54365687174b199510de5be908c048d4d70c43406b928b8aa6e60f809e307e93ef5459e558dc9280f460aa39e2b2680e6753d11f3185c4846dc987622e4cbfe84d8eb60add278f29849b352387dd3c3a3a2fb4ceba502307480284fc5156ed62b3d9010c544bca637bb8a62bbb242c1eb32d4c9121485c484f20335403dfca1e0256956a7d9c7cb2a7e07df4400b6310626af4286fb6da5325efb11ee97babbd0dbaa9c90a1b58afbd0064e981e377d5ddb0e7b00f21ac1f018fb09d464516b4c73bef2877fe543c86e40abf537c519f3dee34357162a4c270e034fd26f4fc2f024adbd7070cc8eb2595b79a76d55b89a0705048d5a98fd2b917b05e5c5f8e24295c4cc34e78b9eac80c6127b8405ad72d395ff1c1f5af0554d0923c38651221676ccc28fee2b28b42b5ba9f5b7b85285cf7249a0b5b170718796f3cbd583949ed108dd9b931a689b0363810f8a47853bb434f0442e8be4a8eea817613a9d569e768898700cbddf97e1086c4661f76b37343893c3c9f4244ef32c91583768e0ae15c33210b0441adf078b8e4373d4d3008d4c58b7ce69becc66da86c60ddc5c1be923d8a3c303ec4de4f726fbef14fd7e8a39d17401402a696c30da7a1219f52e358bb5e150e1f11fd920831edb1a2c827b82f0ba092192467b54bef0cec83da091f48faf0f260a9bcf881af000ff3fef9d47db61fbbda2f19ab2abac512abed3c1174a04b05b0a0c7b528850d20ad6abd60ab4f4a6ee796848dd6b8e5c0ce896d1e967ab02f0ed313492f30471bf36649bc3eb150e3fe034157f34dac2c6d3f6be43e41bc1545722fe874ca4859e85429a815be396b7cea97e6a1a6ff26e5dd5262327d2f8d9af796e12199064ad88ac3e7bcbda3c878fb6ab13809af3beae8d34432c5d1439298320568bf64329326b2a6a64c15ebf645d965eacffebc459e966d1c4b16323fd2dd08440b5da5d149a4b6ef745dfe20f98a578fa551775948d0799d8cd17e8d0371c85c25545185d5f8759ca8e2e83c3627a7a01e5054efa144639450e5c7c6d8d5c56317932681a860300807d0f45d88ec915608c29723ec3e523cc580cfa1b5ebb11ded1dc41773327292cf5c6e4d68fec8be75a38349358bc1c03b22bb86f6e5d5fd5600fed8a521c269f4168b8f32b51c9efdc6698de647f9f7015e68536d1b9e75b089b646324071effaaf8893821ad35b91ed7aabe95d5483a355b99c34973462ab17e9e1d38623f1f6c84060766013b8f6ec166700e659663f06d10f65542388651d4fb2810a9f2821dc1564eff10a7fdc3670e0d8526d0b2e47ba9a5a2c700de5843d498db6b48f22ffd82de66221552d4392908b1c2746731d8e9055cff2be70f0a5ec65d5d88ed455ca11907745595bd0071e85ff3e51f3c7c5c316e3c2960960a18517bc02bcb133712ef484ea8803ba8dd15603a941d9f208ffcd6c54864509b7a0b3fa8676bc8e06d1c0e927c196b7706493c1c27b154bd9e3a11c2da4ea6072393d17eb7679b6b1f5370c6ab82b867f733309d96277bc748cfa60d5a7617e1191346c82ba8bfa86ee104e406ab4eaba2cfd7b1ec36f791529c3e47514ab996179ba5cfee90cc6a79c044ab826801fa59805dd32f3e73b1174834292aa46dfce5504a0afa47c6d397983daca54972a4fbe7ff06ea4897c386ab415d2b233c1c1ca3634e5c61fd9b487e4bde13caa70b421e079008274c0700a3d8360fe60b8898e6d2c571f6f3f3a673a8b47485b2c02535c4f3410bf68c4e4deaa2cacf1c9be273f5f221d06094ab8852e661fba4848cdf129657cc08996431036ce6e35f6077266a75da043bf7c3a2496ac987c066b94c640dc188bb7b6e6e92465fd917526c884d7a38e90fc2435fd90aa44ad9e652f00aadc1c46a44b0e02f1ab9134b6d58547e7b0b5fc23bc4488979dcbc48b741e884f4cebf900b4bcae1b1e398065d20d167836e83d17922309dde0c4fc90af89982838611b9666a3cdc2b1a6649d378ccc3f517519f9f18b7dec46b79b016c879df4808b1900bee26ad33bd814ac0cfd3037ff41aa0d9c3a482e71243613e7ac91b9d8ff2e8dd2c801ca1f929a065c03a0c02e95fd566d52c083c32864e0adad7cfa50e14135e2792c3eff58d1c452c2bc82cd82f32f41af12da8eacbbc798f52d1f0c73674ea78751f7c6a7024becdda729a88db06e4ebc261fefb7d301bacaf932dc0b476d52848ff60216ad7e0eaaa5ad58b04ddd5c488ae80cc54f2459a3931cafb5dc728746c77742aef707015a9b762aad312e771ca69f834ae4faca2823146d42b16d0b9563933a6f940fe52d1f6b57de412259eedd7080e13f9f4eba2dcc60f2c26c5b0315b30a3476b8719aaf0b00d090cac727e5393298100716cc0fc81992926211e40e9f9d9659f29756d3f69cfe6d717ede15f0b14b8e30aecc6eb06cdbaa6536e24a282497edb59133941257e3cd524451d92af29f664af146e59bc30ed622d6d5d9bbab18a2620ce1d755c0bcf49c3010060c96ba99c68ba6538904cdc5f7c13be869e74fdfe2ba2880c9ed35253385045ca5cac9b266468abd1c0bd68ff70b3730f222ece7a0b55485418e1be3a6ad285a2110bfac1cf100c2beca09cb86496f02ed338d190ce8d11f5034352b588b49550bd8ba72ebaa6e6ff71b9b2a45239aba60ab432a0d82cfd31672e16406c6073ba85d537e99d15dd12832c78eee1f87a5f5cdd634962ea9f2ef35fc5d56e805cb195f70ee6ccd2f865114a048d41470cfc5095f9407e4d4bccee063c8f3a4e9f2fca907d63e04992dca5c42ad143f460d25ceaafe5a21982179ba6817fa38b14b9da74b46cea2e8ef28464aff972ce59be320f3d2dfa3ea7821c67390d9db3354b1c35a09066b2e140e54900a2b5165ad19b6aca62b7b1129bc6d798feb3ac5b6d8b80b4329b3c74f1e22a7961b6fdb6acba7d4668ea672f2df3240db23695800f46936246bddfac567b75ed44072c6d021f6f3e69738de20764deba26433be0a1263a0ecb84616a2df418fb9e9a272e99fb744af7f44b8ccaf28e40e197cefd451577c5249f19085555e3a748c4649ea69db22aff4fa90c65378892443ece73b0094a47d23d71a687a10824add972896bf8ed4301968c88775ed371c6565813f3bc51a218f4024a58eb8b0c92ddeef6ecc95e9425707b40dc5506370dabfccb73548b213e97677dca6ca153769085db1d122f681158eb54841d12bff9946787d4e759005efa6e6988363231df1f70fc614a0e8575ff1df91bd9970b1aba87ef291eb212bc45e6244128d12d5e063a35c1d06992124514ec9b69ea560560b48abc4de9227cda2e5a611b02207d42cc3f435c5b81af6f73b125a48926e8fe868233d06312d896e239aabe9e28600e05f1a35f1a6fc62f6a2a247620512a32365ecba83b2c8a1ba0567c39bd806c470b315543714f571cfca473d841c339d6a0bfc5c23b2fb2e0150dd603d9169f23db1df103994d62c59c504fc1473e007849472eb0226c8a259def61637157946b12fba116ddeef3a1dd169ab839449b57c971a27b5a7a61cddde56d45ae4a3b72bb9c9a632133b6665464d5e6557391b4f720c28d147445f5af8388561865aa0646bc222fd85e4344bc454543302362471d82ce86acf6fbca478a33d2c5d67172d6b8c39c3afece1262331721c5bd0155133e165619dd0d2097f011b8e4e94037c7ec794111b3307ebbf2628e820a289989663a99087a81a4f02e9da51d52a99b12ffe9f6aec5498ee395436cea1b895473c994a151428c8cdae43a149eacda1aa2d748e28bae8f06dd9a6d2c9c02744b9db88c3390b7af42bd9a9a9062a7e9eea85b4f4de00e785ccb86b345a67d0f3d347db7d3d0c49ecca0459167ef56f58746e10ea79092b82a3493ca68ebde4a359d8ddce5c2e133f146c756a93889c68d136dd01fb5470740a073e8d89ab556414562f1cceef282c173aac1c07e982476af1de2a7285cfeffa1b899710d12b3d8f432add58aaf94a6daa870fb647bd1fdc715de6e880eccaa7bcfa16e855d8aa8822e008094cfece526fad0f8839e17f41286de2374c7af6885e5887aa278770f357ea7361327b1ba86c4dcfbaa1b9c2e7f00bbbe8e9167b357087e96f226667310d28930e2025b4e40f307551a3bd68fe52c781c3567640275574ea7e9c39d344df0314118d1f83a26baf716d45c363888fd9cbf1e87dda486abfc5d5bf67adfcf26b1d7853881d2c2c1095e925527f145066761110e9e941dba99cb36f5676bb67e7a0e1cac75169a22c685e67f80e132a7e103e7dbe4c68d48c071d53bdb19386c9af9bb639979ec0ab0a93367ed34c2d98aeb50ee87be4eab8d71375895eb5167328c5021d606e0a6f3ac3a0183e444166c4de74e8f8ac91a9f3add133df864cb6aadb3d8903ffbf0e0b1ac5182f0420736597afdee6368c923670d5f6f71f933ab3d1a7abf6e95ad0df5ce54d9174d77cfa3153df4ebdc70748c97ace649f93f60fc016b00951074420b84071ce4f6aa966fc1aa3d1bb25be778ab8caf48b74f81c70169d5eebfc1b48e51ca8f229c2736c3c50a976bbea7fb739911efe1d6384d90a73dfab96bb61eedea520ae4be91ae3f69fd9c4dc3c2f329b0787f77a78aa7469b5fd2ad3fe80c23fabeb46c77cb93d3364a2e31383162f4bad9bf5680e85ed09440f25ea0aaf652af8bf0180fc3a53d5265dd8dcd5664b080552efeaaf0f1158e8c91ff082b048d2f8f81b5bf0f1fbc9f3acf4ba8d1da81a7fbc32ca3fff457421ea4ebed050d4f17538a2cedd77cc711eda6f546e606e2a10ad70811fc94210f8f7fa0bc00bd467b61d2e15aff671211b4552c760a88ddee1d8ff7ad687efad36fd3c6c4ba9327b241e247c0a530f9b80e734acaa05898fe1899446f7b2679c7052e49e37a10a7da74f2290de467a23385a0679d2ecccd207dada6fd6efe1ec168c570c2a0de25f8930f385d0db60c5c024bb7cb9e182b97aba33e3ffc0148801f8cc7f168308779e7cc251de67dd46ffda708e1034bcc94229a763c3a3640968e8b92caf8d052fa1969cc5f842ac5fe334af941555a449fefd8f33a15ec7ac4c34a59d9bb19b16ad7ff8378bebc7b3100fe360d47d1c01dae9aa177bb3588684771bf137758394905c72309170a0130262e344fce2f72ea08014fb9b21707b17bc3340f489a7e634cfd83d5b5106675b18b4401fd08b5701007b795f37f637e39dff38d00c079a5c39835042261f05e43f1ad358795d80a33df0f7a3ff5d98972cb8a83df7bbe9e95fd870f9d1ce021a48aba1034225f1eac557586063cae12cce97a02e428edcbdf1fadf2e8e656ad9e4eb42dda921b5fd681b5f2a195c4d3199f9b3ef1157aed905537428cb67598fc2a1475d5da8b10ea47db4f9a49925a0f3e9b701a9daed2ba59ab4b2776f6a59f1f8f1ebf3055d63ffd64f21ee93d6dd02cbfcbb3a78f2567de3e28093d6d67bd38aa5d2de6f988553bc1239a20912a57aa308b891c542791f69827fd912605c9fc33948c5e3d1c6b4f2c377c55bd47d8f0c823f2da5d107e36e1e2b304e33170e08e2685260e12c715870b73a1d8dad648a3bf5bd6a86f2fdbf21c3f8207679b7f78be89f10a208d1fccd40953cbac3c77abcbad68fcb0aaba2266248a3d304bf2283b9b0dfd923795f98ac525f01c0d55bd477b3f3cc2f963364e864e50973030ec325297d2aec59dc7465f333bc364e8442c47d48bcda51f72e09ae5e4b2e45e1290bdac4e2cb2340240dc8ca1a037d51f8a2c965953599c9665acfebf4980025cbea9a5a6d766b6816cafe2cc6fe69a29421bedeb3b48b08e90b9f18eca34d135dd42e06eb600f990d9eba1641fb3523e7834e0fb27255e0aaa0048207148202f889a02252444278c2e1a36f98f17b40bd784c65a1fc6b8183a6f9ef099448d7bb4c967537a69d26e8e5266bd6ef4c63b65b6b1031a755e29bdf515f6ff1cfbaa0d48d57b44201bf987ae6e568fc4195463d47956e9d538784a8450cdce1eedfd2ce5b99a35e0146fae6b37cb8a470bf11664f79a191b6d82542edfa199578cd74c5cd80b4f0c884ea8b1e9e2ad42659462b654ebbaa0845c18d345b9e360bf1a6d62c6616f2c08107663c75227eef393b3bab0eac577f7ae5a5c56d85f774337da063e9a58b76118dc1731913eed46d0e2acf9549e5f79cbb088ada0fd6bb1efc3b140e2895e4d489e3efec9df48e5545b2fb104badee36d7de8494aef8869d6ce57b39516303f23fc06e6911731ed32fe733fbd19bac6d6b4cf2dea82ec0d6547e011b19cd98e2efdc00e79091f479a092caf74992f2922198df098d8d117fc967974a08f477e2f4760d3e9b0a556802e5d18cbe0355e34dcca2667ac156ce2273c545ad9d18a10ae8921286e1ec55427431af8771aba715313245403d8685e2618b027d4b6fa8f0dc872cbc4584a1b7d7f220b19e57896defb2f5dcbeec4c2fc93d69339b7f919c2e213b2aff326c6ed405ef647b85975d13d7779cf3ab13dfe562dd666a198bd74a88964315fbddc7425da2f32aa81179590bc2d22f6242a1418c18473bafbe89663eadd69117cdef9c0a48b7d018df4d94372bde5316da84b54553ec94a43e527aae55337bcf90a05181669fbb0f022bbab25f834254dcb8a89f2ba9df6f388f8bde2b18712fa3750b477a7865bfd143cf0fa5f0b6457b69fafbe032e86499d2d416c62017c24a19a10385a1b742f6559bd82f775a1f794226ac61e3953e60548d560a1467b24269054b15188029d6917b923d679624d36bb5a276e6cee3955d16f0a8c105596cc77b082ec8a734301040ce4b0a9ab988af11eb2295fe0b18ec68fab829d3e43c74022d8d5198633fdb2e6228136368af0bcef1717c2e5c51b369dfa4018db248d4344c839c16de26d07ac31a1b784b1bb343b901ccd0ac2d25cb8643b7d6c27d868b5d79d50eb83e22d2a6b06e73427bc8f80a2fa0d12694ea78cefb4377d6ea60a5e44c4adc56734635ad869c8f2f19f4478e0109f59d6383fc2160a79ed8d878c00715cb9868a8ff2b0c7ecdc91543f772061d124d42056b679207049fde0544dc6ac8b90b229bd2a6a4f3aa3059114ec3edc61f679edc5af1d54861a6b2143ab3bb15fc66fb0db9870b0cc1b24e08adda201386127ca10f94f622f3fbf560829f8c9673dd9001e10f6ea622eb13e3b2f068df38bc157158a89ebd8b20e66ab7e62ed27fc7b6a6b0e45565f3f3220a86f76d91b2afa10eee003ff89864f87181dbbf72623decbfb99f6521ebb308a544feb02514fe4a6e5410366a81de9c1c4a87fb52938026673663c624738308c3c0a64944e10cf132003c9b295ace49611cdb58c4e01f68ac5046a2ed2c12f120a270bcefc46e4b9848f1134b49e4cb72cb24d2aee13e772fb97a13b1617778234e890ed089660b878a919135d8d580d317c9521b9a304570e4a5cd4c2f937f43674a7bc493393f3beb1114323179f3658325a98ac803a4695b1d9e13c68d000fdf920a07c17bcd215423ce2dd0355d13e6445b9ecff0a2563b014998c7bcf631abbc1b26cd381e38a6286567dd1f965800bdb38861d2d4660e017f4d61c86c5014f1818d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
