<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93e923c55d368b0b315bacf8385e5b28eb7f893e86fa8b37fcf7ef076ae3a6e3fffc1341bb5fd3c06c39b4f13686a7139ba47ebf0f4c5a18373883b0aeac36b57200bf355082aea8bbebc90a1138ac18ac26ccb22cad93d6afe405ec1c12f79dbb5ff668b332dd5e90762e8e79b20d6f27fc342ed0b68d293f6fa06f7c0785b5cbdb57173f46d34539f74bac6cc7812b1c2b6dc45bb56d8fa756799e50abe9ccb0ae4c7dc8115ddb5e9c08537c4e879de7f1f13dce49db9dbd9ea2d6413d55a84e716ac435c02551c819dd6b43234ea3c40bb22c78fab0e9d66fdb8bd45f1debf3f536578d8069be21e2d39bac46aa51241725f0b550bd1bff948a246516817c26b47455dbbd0d15ae8caa868e77a186b258522e3671550ed66660674efc373932c483cd97b674d4ee5f160c043a7313ff85fbc6c7f3d470f84227cfaeb09b4a2d1fc1122d73185e47757bbe00e2c95fa1e10525e3dd3c73ab0c4726eb5d22d276779150f4ebb8956aec48e10a189f30f0eda66a719b364ad52eebdcb4ce7fa1acb83d81c18553438b738ee32b2ec6f437e8f02ee5d2283f2803932b944ffbcb8f515476ef09a74a42b5686666f859dad285374aa4953afbfeafdb73a33d52416b0cdf0fe20915ef5541deed07b67f887d7a45d342fb7c3b54240b43f2cfc70d25c39f45fdbf307bd445e6662ac83a81d6795014de1ed3e2f87462c22923aa114876ec303b33b7590aa834157b64942d1024c5bb149a0268ce406a6a7119b0930b4f73908d16fbe66dcbd410ed8ae1417a39dccd4a36c4a0d002ad5afe4321ddf1cde9334c110dd42b9bdb90758d762a0681862db288d96bca239fd962937df5a4de351dcdb0c3fea4242310535eedca250866cf6d0d94ac561c001213a17af0dc130a27a8db433508a764435bb7366b5a2749b43918f398d9b8123d12453421cf2139a0d235e50bdfe65cd800f0af2c06f789f24b22ab3840225564a5784655ebcbbe6e587446ee9daf1914307e648b716d569a1299f17b7a685d01b8ab5d7ff87ddafcb0517cae1d4b2445f721b6dbf79936795a812183ce28433b530a5900707905a5bfc263cad03ac2f75b94ae13b65c1edc00d5f1ced28bc303b64223cfb8f3cecf20202229f041b8d50f457cfd071d1cc34e06d6f1d01fa9f11bfe57d12215a8b7b9be2800a9135e9fb480d4374c42ae9318d67ade18d2c4083973b4c02b2900ed7a8d436dff9db103b5ec7edbf8d72f1d124c1e03b7fd8b26c3007210a7f3dbbcc54bc2351225ef2a2cd1624d4c7409de23400642fdd96f5cfcaa8a3a4573e498eef558fb33a3b0cea52a4b50900bb466f8355f99362d6a75a570daf0a8c80c656d53114e920dd53055b54164122354189538dbfb325ee084829fd08225fb04389300c7db92111fef6d6c12e9870f671142aeeec9b4a60102e6b4a3929bd3ab671c9818081e474072ec23ee4492c8825b3e5575e430abea554aa98b06a4bbfedd59e41b0f385246ba571f9578fb38654d708114e166d36378e76dffcd744f507179009a57e7f75d49a0e26d54ed8102e305e2e7d1dad5e456539d316a414908dde1682578835a5a4a634b6943a1cc84d0264a9e744e1563bcf01c6c755c674fc9b330457c5c86c8a9013a3c6dd381a3ea041d3e758346d2352b758e3105d38196af8bad34d77b0306988d506914572f895ec852b8147b6606a9b347adfd2fea05ba1990f7b81286a53781a1ba2ce1425da7355c2c8e4f25346a9caf1274656f94aba6ccb6cfe751fa95d591848c3fb43daef53209333a1fd53100c35e2274125c364652e6ea4f4ff09a3f90e9589ebb8dedff7a77f20d1c66dba155818b042414690479111373bdedbe612c040ec05a4648406d4a3f9ebca6c5fd2a7b1a188fc5a77e38b1ddcd4c7301ab8987f918e8e16e325c7d50e527bc7740ecd3188e6c62628448387e73a60c103b8b9fe44014dc0dc7cc27b2fa7abdf4c8d32b44de89207d949da2f9443204f5ad9719fd2b43e8583c7940c274cffe911ff63b355142508dd55e2be3279217bbfc5d8a73d3a3a8ec179162fe12b45a686f4eb21bad30f963d10118b280ce788375ffd7e3108ebfeccf8254dc59eb6a22f3faa47d41d19c59372b246f998e97f617cc3e954729d2720210ae26ac748e48010cdce5e991b6347bed5548ab988e5315dba6d92b6c3d3863adae6a52ffd799407c82cd532d7c7add1915bb9e70ce6835064b3b891493b708e07aa8fc763b04301bd398ca9f8522109e4598be1f4038f0d41ddfad5b1ff033475a284c13f2d33d85a360bb2a9ba61faed6805d6566e0f99493758393e436a9ea9a7149d87c42e152c9408b4f878b1089f51eb4a5793945025617d4096f4944e9c8d3654365564fdf183710aa478708fe6f70cdf0b58871c1b5decad54be82759290a661a919dadb877b5711152eba601a748e8c8958cec236da6293f96e93d0c1030f567f4cfc54f461bb726ec027b363d312ac141bca5aa0d9f9aa06a29f421828fc771afe6c90b4fc18d5ddc6e84f3b7a8a6d4a11e8b8d3a138cce15a82ad04d1fcf6bea5f1591ff386827c2e25eb3295e23ce71ecb519c9be3285c2d96d250920eba8314f7d499b1c6694ec0e8cb53e675cbf2771ba86adeed50115de8df53b572d3aea85cb3e773761f8c42027a04c31eb3049cb2481da21849612a8afb55aa6d7ef03234238e131a7873355a42a948fb1c62cb788a76d6153d41fbced1f2e2175f2cbb49ac79b097e7fc82d98bea1adaa67a56a8923aa870f68cc4bac4b9e26abfabd8eb12fa13a8314cf0b295bec9184114677d4d586581adfb7047e517632bb69f0d10e909ed53e049d99fb6240cbb22fb26474bcb374d97e9901f2533e0d10332b354161906e4f052f9549580bf1c479af2e3982459d2115c09eac4ab728e9b2c48cf01b438bb7fc875d31048d50bd206ec205f18e8a7b400dcd69a61879d667783c6271a9982a90667c5930094a29d0b0850f307042687a8227ea4736e4b0df993727c4bcafd6e680743f17fe26bf7f83aae78ed2a305b95156076a45523263ec5b92240d16b2c7eba332617a04a33dd16034cb85c5908fd1ac1d3044096c059074f7211b5e582d1af5654391a0bc3a9770f65dd3420fe5cf077521779c8a65c3f946a0e9b47dd567d0b759098f85f07fa0ae4e6a1f43dc13a575cf79a437bafac8c02ff173416220c486ff8c5dec84b3e5f989c46e1804076f9cba87f29870cb96ad5483a764ba5479976bd28b491de3b00a727ca610ffbffe3c6e9efe2633c5c2ae5b071ba6cefc21cce47758cfb0c806d3bc4233c108820cd78602611b0b3fe43ebf47a4e3afd0f585b61ffdba76495dd7cbd4b30b6bce873e15624c512fdc5e26a626eb18d619ca093a4357cc704e141b4300873283201c43b532a5da0bbff18a40801f5c5d5f2cd66be271161f78ec71ab3a2f7318b3519367adbe6eff66aafcf009fcd642c291b0a624ec1eee5ed565111e8345dc9723911a2f1e85075fd68ead687c8648bcbbc65bfdd510582c5b4dd19cfcd90f2bd9f84211cf671b75e413104aced90445b402e350d0bdf18788f3e21180c562188e9a8f8dcd4a5ed8bbb2879453f089034d4a2af60fbbf3f3b959d9ee7f754e3f5b10eea5d683bdf3d8560f9d9fbd1136fba0263a0fa3746515b2f587362b69e326b5efb66926e617e1d4b8f3f96da85b5dc8881ce677fb1f94f67bfba84a9f9f55031e551847779742858a63bff4ad32afc3e8ca6cb913ec438f8472869052c77759e3006f710b6bab20b4113b9d54c496cea0ea94ad3093e448b5c71f342688adce9dba8d524fc498e09289852319be1edef9918f58350b31832726df9eed23b2fff21d4956a553099b8f76ae30e43a86373cc1d3b92a73fbe0fe4ef7576e6ae6a080a152aec745d81447b6679f4979f1016d2a87cc4ff6c0243cfb740ba4044d41a7899cf4e81e7039e1fc975ee28654c3a149affedc50c9ab04920c43d382d04d432636427f63cd8d159293344fc0c78aed7f583b4ac8fb1bd15b754102894f09221396a18eb7c62d2d1121e7784e8ada5c6a72b70252be85e1d8c2a37e202d92a43e12fe4147d2b1af55e7223f10670f6f615c279c3d2d62621442800fbfa7af276de01d3b8a437918dfd300361cf781eb5381c84d93401f4b5645e0a5a8d5aa95aefd92b51d39f2010e9f85f5994547aaccae6922ffcf536639ec9d575def405ca392d04619fcaa412fc763a9993c29c54bb7e8e80364cbe0029c5c61f87b44a34c2c71bb061aa6f3a1c93dda4fa7cdb5dbe12b9a9916fff8ad42f17ff187ede19698677722413b9f4c0163a08087edf54c8a137b3ca96a7388413cb3249a94415ef30b5a6bd527a3e64124c2ef5576692806051af61c993e78af46327e02f45f284c358acce1cc0759e0b15bf4976f1eddcaf4fcebee79b7df0421da05f00bb21633919b49784ddb451f4d13b4ef0ab061db543af6a6266f76a3dd21d017559f2b6971cddb5557e9497f6dacb0e578317807359a0854e70e41ae2ef74777127293f968046dc9733f4b94bee4e3860d59b89a40ffc60ca580ff5ee2c01a814c4bb395f5a48a3755e743c7015d12283f84cfcd2dad7e21f65702ad9bd0c89c1d6c47954286d479f1934141ca2e22f829c2657e6967eba4fcc640116ad18d09217fd02c3f84d22d2cba579b1465b40131861d5d1f3fd1c31693ecd00ce2cfd93813276f9f7490ff80ea14db7773d27d0ca617db313184d033b4ad8c2f7b0adeeea07ddf3fc014b2c8bcbccc1711d3ab06c0ddba656a6c53db9b28d32388f095c52712d90084c581f8799390ca2d44628397fdd375ffbc4c68630ce09de31b6136d3766f2a70cb7ffa1adcee88294e88f86842c85d157cfa1eb430fa5d0703ba40b92d18fb956b155d17f4c409762bbd8dd189f67e579b3190eaa316e1acc6d6bc57eb7e82cdd8f633648b56a41ca76ac2ff562d833dd88fd026ef09ca1544b084d599363cec540e2f0b7dfb115fd0270801d865ec91e5af73e0a8329bff5f6e24483bcf4b924717446a39687404b45904d62d1cb257d8601629dd4d2a9c752cae928db45bd43dc80bb7e1d5ee75258396622689cc9fd6250e09e78890cdfb32088e973cc6cb3e18ec3446e7efd1cc02987d09abebb7c904278559cd9848b692d76347dd9532761eae4c5ee8b0289162f4d9ef71c1c05d0006a91f2bf8400cfb3a9894b5a87473d2ddce15d56162668934acf03a217964a1a7d86af0b2644f54db99e508929d81de9cdea7bc386aa1b0c486be9d406b45684aaa152cb229483c4bbf6ec740442c0d081fbc3384a2e70ce91a2e5f37d5b85c3aad588b3acc155d2ebd1de49cc16927f02c72c529ec0e4f822071c824ddf7bf1a2c79278e6d8f3bbbc89a26ea22d64a57e6bb5c8a1c9ba4212a4289242cbce151b188a7a32e82a4ecbad9fd07ba0d17f77402018d7f0a398cf68dde27a6289798810bfa806d7d2d61bdee70ae00e4bae340bd5e97c285f53392c597219d9d88985bcecfb9bcc45739d88a1f238af8198502fb421199246eaab09c9ed7316cfcf428184f9bd3530beac52ca9b3bf2c2f964ede9fbb5e234f544d0b1fa744a7dd319028763407f4ecc5f680ccd340b40ca709d7cce08a388cfbd603cd3f6a8b8804b39515335a9fa51694f56c622dcb3777255da2c8f6ee96b4461c976dbebe19dd072a97ca0617dd23b562cd218daf2620de413945e9b315f6f13ead372a44b07f423ee983c99999bb716eb4d990ff05e674825c8fb84e87b08954498945cc3e6a41e767969db1095267b63d0bdb61c4d567da0649e19a69d72eada6255ad14dc238c638d16838dd50187786fc5e7a0b70d870c54b097deb7d70223708b1011322b61484a8b8f4b90bc5fd662154144497f52666ab69cc00be1e417794116ca363f258a2c3331db84864e5c8050a056db585c83ec73c0102b75e222e80160cd3c43ebeea7218d18244418609915bcb8fcde6489bc6568be77d1ba805b1474c161e974f63ca8afd82b0769f503680fa542dd661969fd790ba8fd8e00faf5a52baca36bc1412ccefa43ec8c843f32d97648ce9fa81a839c37633edd7e141b8eb1597c1d7e23affa9acf5bc043f01e01523483e25be49f3eab1c9127e857a992e5322d7c765cf4ece2dc3420d594d92505fe6fe298020a65fbd553b812925397b3c622da4a212e319a729f228ba4d9756154fef9a9cf0898066ebc567efe792b26ccf56d42e3a5a5850400f034689b8c1a618f9600e5397bc867534036613a0b3337d19a87489e4812f9f7ce80eefa8e9ac445889f371415dab5c8d30165c2c731a766938f931c7e9a8fa33e238c70aa3f81d8b5dace59d0afea41eed90c4c936ac86b3abae341080d015e37aaddb6a799584115064a60433aaec247b135cff9c0969cd07643644e8f2833eb002a5ab966476e8b7dd0cefa1b4b47405d5f2ef6554e1bc573ea40cb43884c420df9792b02390e53a1c100cb46de4bf121eb3bfa949d76808535a8b35dbf43d801e8c01ed300104477474f0f0be7870a492c61220c9d5dfba138ab33fde6c2b9102879a4bcd65eb38a1d8fdcb0d8e6cb650c2ecfbf6f3e6de822874fb9b658f83f89af9998db3f30bf21d4dd13cc7110a3c4d7891dc973f73a0481e172d95676b43b65116718e7218e1c471e3d2175dffa4af92d5f81f95783edfab12dae2d95d153079539ab2c66c021c75735aa8e6d44fa2f0923b769392120977d58162c3de0ee218d4e83238b2121c6d6765282e5262702cf3b4837f4a95555a9cbdfab8b2611c39000a8379e7d51cc4bfe75e418ccb103442991253cd85278ce15d1f1c2405c91e54ca5c31df783211036ecb154fb58445fb817eca1fcd7e46d1947ba75306c8c17e4d9ba865b35a81ef5d29b016457afe08d2deeee593899f81a6e1641f405e9015bb479dccb76ed211fc1b0381a2aa9c8b5d0a317ccfa6acb9e044e3787f9139810195d61ebf58422ed55bde81f9ece969504ab2db0f3ca37fe7e952d10ed2a7bc1ab5b9d5bad380aaba4b82b572385dd15cdce3d50d9114b40a4e585d17eea7455480a6a256387184bf82a0e38e84fd0d7e7676adb517a8138b459fec40883414084cbd2cc80c7aaca739503f6a795d9421a1b7489de3cf38fc68a60d8af5f7339438a00fff687845b9e79522dc9bffff6e9e3dcdbb265f7e96046903bdef15c397c1c876414061a02b9f44a63117bfe83639fd161ef26251d03a6ba804a1ebeb19482fb94320ff583b94a291853faf3469008d96588c45f9f633363b70b445384a9ca00d1d10597cae218d32abf47e0dd133de9b0015ed43c80910f0ace377014d59a2a276c129cb9d8ee13a21c31125f0ad6d261548e38cae573ac7c1a020009533930d05822816cdd187ecd624018757b40eea73996ae025dbcba12c5776017568a8178ddcf32af38f51a10e01114f623d228c0f64ab9704b02f8ee3ec5cabd7c5f7ba52ae73ccd1eb05bf7498edf415bded0bb721de05ef69cfadc162fd190be8d123d768f863eed14e73d8c5973f684ddfe78b58bfce088e8eb5549229c1d56be9b42d6b67fc4b6d47c7a6dcca0e86c9c1ee71b70ac75fcf09dadc7db631f95af7c2175ba4659633c404ceda7f358e4869e3b0c2da9fcc6bd09dd0efcb26b838095a5fde937e63d310721dfd0a9ae3e05b8bee0dfcf792567554db041dddd53968f177e26be97b75386ac4e1485293b7ded52d04bd2c64410c96b16630e2c5604a4ac8707242d72d728d6573e525c06c25a57c3f6a1fb4cb70b015c9262ec61e4cb5c47e81e71581a3af76ed38f71015acd30b43300562802c0e6ff89ea675d84a37fca87c1dba9ee0775fa979ec52d56e3bdf2e1cbfbff35fe466acfc6a48686f9b52bc74b663db1dcb27e393d33082af7eab9b4fff43b931a6a05035d65a566e76e427154d376f2ba4acd6de003f3d084814c2770e25f8f6ab6973f01d2ee829d153a32e2e7eada073470546f6f918363db34ec919803415224c8d1fff8f91a3f08332954dc9535127e9959dc07d5407c295e184b09371dddf94a8de93ae9ce0c734ec6f26b086671f4f9297f0f1ea90aa29d4cd1d1e44cdbf6051b78e31c7250ff10c5b2c5a8b3afc28c89193e6b2930ba23c6b18823baeeb9226f2bde33c9fbd8e117e05c987422999901a203bf0fcf4c4430a1f1b53c2855fda93daf50af11de82e175d5a5521f218e8126c7538e6bdac898450ffa8ee75329305d2c69399b7ac21a467e7b7c8658779d8ac3acac3e99be439b959c83c5a91b0467e81521f5b5162bba8f24b1652021b67264b51ed32ea2d7c26f27d71928566fe99f99cc8b41e70a299829f4981b921f91a32b2dcefac0520ee67eb4f3504a5db8577b64734b9a69e19f13ed44189cef3ec7ca30a18439d02349bccba609189899c52a0669925c20f7a4bf41bdc719a5b013e937854197418e829d60de09199a7cb7295e7e4013b48c607908af13853058541023a9d8c7113242ea1164df719f6b8cbfb6e61b2407d6eff470d5b9a0634d805263a7ac53e9838ac773f14238d2e40f4842b94d72e7b5b735df2a122bdfb7bc0846fa95d261b06b1fddb2b8c76ac54c2ad176c75c82a8710df172761e18557f68d3f80fc773cc4344eff3e31873d233c72fd61ad6138070aa601d36cf045d29bf0fd04313224732e9f90c29c3f3805ba2e05717c10546a6b72ab9d0c43d07ded71ba601e619ab0a43c00bee95863c016adfabbb08117d371f81e2672724b30defb5159105e384a977d876c6aff0e1bac786c0909794b01a328689d1f984c34cb163dbe586f4ee5fe52c1ce4380d5a608b095fbd389e577520232d153b590c0e0f8087e97e68ba9001d4668d352dd843fe120cb7c81bb651caa9df1204d18853e0d51989984aca6accdc0c8d9aee5f1b5fac2af8f81d915c4535914d02d8892cc5b46b28339c4bd801735bb2d5c4422f8921d35dd898303917d0768f5f211de86d8ecacce2ecbad4ca8483b60422334f5e44ef664bc8408b202c4eb1f5ed6ef33e378093fb7eb3faccc8f0f185309ef6b4f89862dbc127e330ad76dd431b83ec0ed328e90cf852ed0372b6c6c4ddb7e6b1bb23f99168cdb09ba32be84571b9c483f4b256d8920a27a91a774ccf7593aa1c5a9b4beffe4bd4327b56a9d9aa50a8e0a99af4bf3fa9e7f7bb3cb80f0e3bd3b843230f6cb0ca358035507bb051e7be54fd8b4b3e4f849a501070f7e6eea9674ab8c349056e4b12016eb78b29edaa4c279b81331cdc50b2863ddb1ea2b3f1a2e0ce945601b26cc4082577c3ead046052f3bf2ea8be73a295b7693bfb17bf91cbfb5cff16356049fdd58166e3ef851533d2b86b35ddd9173e23389075767b8dc15a2b81a140b55f7c2932209d79e0770ac6fa0ba66c68a1c6748ca9da406d441c1c741adf25e116f28163fc517f6a3b6a71f6aa5c4685ec6e7c711eb7ead07e13776cad4b7e519c9bca78abf2119dc9c7875928199bb2cd7104fbb520c9ad3394c8f35e42be0b17d8febfd6d3d99e51380d7cbf1f41d3b9d73197fd9a77c120831ef8a747085636d6eca93c1315c7782d0eb2b9de2c5b95baf40129e6f7f5145ffed3c9483f5b52ff6d078b66c900c36671495fa998f61e0b6f5754d2be3cc6450ebf7956538f9a224cf7507ead09d4bcb1dd2515d4afdb6af2e5e6af831fec95e9849245885eab38cf1b05498f74847d56910504d76d119e232fec601cc2630fbb3e95a19a275e60456247255b7cea888f95825eadbe6c1f0232604890fea49f9c6bf86a8293ca8146d7749103b9d27028a58338b0e039b5f1212f1a249d4585ca57c5d4d06063052f009a4b18affe4de130f05778fd7c5d03137c0840737814baa2c7c6ce1ca6ccc6997ef3574552deadff1c7f3820f903629088d37c2c4287698e1150a5f9176a9b1ab785c0c588c6c5b91d89c17263f4051e93737d8a457e73df906345a8ae27b7fc3288064c658dc7696a68bc34c9aeb1964f7412c74a144ecdb1046b6281b8d04af89c0f5c0507307ccda5e600ee23ef1bc248c24fd35ab51abc54833fc8fabb8f824bca476dc6132855d323f7f7dabae04329a328400e32d94903e52a4cb518cb5768973214e621b685fba453f3478d4409966275d606c775c59a3978683e4bfe140aecea26765601dee59d8e9cbcc33bc4894128fa7acf1e1ca58f86897043f4c6faea7aaf0b6d42fb0507d193f144a04fc99c67aa3244f632535b166531a32a05ccadcd94ce3bbb21013e887ba818fd68cd6f344ff567001b63845e0ed5beccf3dbc7b2fc2e07a0e7f14083639b095b3d3f00544947344113e98f13431e40ee6465063637a9ef733b465130da0cd2a5eab974b93cd315c7138ac801d15e81ef37a086006479b2b4488ef3aeed200f078b45d77c22fc9821ac98de5296373e10b5490b11a6d473274e9b09e82e9fd9da3ae17412949d589058449415ac6f3d6e60d940348a24e49e4d6ae6b5529efb0d9140f5f30f35241a44e9d2f1cfb0dd91fe0181f176763a9621b2dff078734c49480c0c5fcca111e611caf3e08ec160a6cddab25b3a52cabce605167c43e3bce28278f9f99310bf34be158edb0c497501ed41b70e7122c6914135a2e61861aa9b3b1180e0fa125a65ad4c312eda5c7ed488fa2aba96430d007a7a01373e222290da8badfecd1138d988914ace170f6f06ec7bdc74cd84d9bac063a540521ef0c52e1498484fccf73e64d6db62f4e068975c31f853eff0ebf05561a7c1b3c67593d4e04376a4ca02c45fadb471a65e26e03cbfc4503a219d1c95b0c29cbe26b03db399d8f4439228048c19cb483260594b39ef46e66602b2ddabff62a24c40c7f220d8cc2db98b1d1fc8322aefcc9602126c28280090fd9a75e0a56c878db22ee9acb2490317be85fdc77f5a8be6b659389f32e17f3ed50f5aa8d9bd3034c3f4b8dd090357d0a1d40a03ee9927cc53ce4997d22932356c5964e0fc40f897e416cf62f3c38d928b7f1a5ae26b5fddd2a3c543aba4289998b6a736acebdf19584ef5023efe025a314604c242cac849aed11d7ca8de8efef0aab9d5a1b516cb4cc0bdeaa0bb37936aa934f8d22a676818705084e59c8d301a02144fe89d68ed9402a2f5263e79861c675b5a5791284170b199cbdc0efbf3bb728dc57deeb56d1a8c6bcd2510fcbc81371549277b77057ed48b6508d06a0dfa6e2b67aa42bf76f9eedf06e94ece40cf2d4cd75dd01499f8d61042a88d0f7f5b6c39e20ceae521596ac31cbcd913f2c5b47ad77a814d4387bef938348c2573b62575b83b2bc8d50855e094e6d32fe76c7f1646074ef9e1f10989d64b71df23118715cb86538df88dc2386dcca9af08cb928170c84c44db54d21def1b26c59c0a2792ca1450b5e473fff971c92e7b8453b32dc30d1053658faee653a4e080d74c14e320c0254a9161713df32ee20eef85fe5a6d3bc95f9f4fb4489c5e320359bd4f238f50e65c3bd127a830dbe1770656fda08e621282fe639ccb69dab8142026daef9d4d02f06c21d58ab5cfb0ec1fcb0ae8fc2fd9091c91367863143a0228f1103206fec60ab63c5fe90aa3b8c8624a57432610e22cd2640d0cb5b691fbcd06d21e7161d5f9a26ffdb66ecfee71119d191fe51a26be74341c762e29db12f41a827a9b50e75ebc111390b297ed5c417f12466578c1138ca9209b07981d67d2bf50d50580a93a9541acf41990b8a5a5052d198a2dc596782ad69dd96a6626f1d48213fd5463d8ac8a010cb9102296b32a8b4011d196eab399eb4d972a7b394d5b1169a7bddffdf30f39893bbdaff6f5a9b30ec4ecc4fd2c161609fa0d38d118421fb62663065477373339372191cc5dc61bcfadc26e7b76f85b0413a42747aead5a34faa0122216c8b5475fc842afeadcb3d167ed1fc011b13333cbb8c5139497bd43346898ffdd98028650b1c4057ca5beca686be912fbd21c892f60f0218730545007de49d3f10559253d62a7a2f95116dfa7d6d6a9681465732c981bb1352c5797900a1a5d6877d3cce3181375e82e8d77a5503ad2eb236615bceccd4038d84b838db2d2d01625c24566abbf3e42147e3d1d25d8a393172550e5bdc94df1709073fc4aa9e2f76c9a556ae6b2979d255db59daf37d6e83b76a045ff1612b7a9cc56b8a1347bd26ddec30d9a72ae2fae0e648608a1d6b20629129aefa4a1ab76ec7250d86e892c7b72c926e5d026f7fb99770769c705ef6fa40183a46387762c24721abefa4be045e2add7f32b92889616fd637ead97ea553198828b7dd538cc0a500180853e600f2949aaa51cca1a3759ba0d5c2e1d66fbce0cda6a9eaea2e0ee742351dc0ea4e285978e6ee6c4a1dd8f47ea2a8a2bdc385121f7e51e9a3fea7b7f2ee539a6fe87fc18c96cd1a3031b83ac83590d7dfb2dcac8e01322ca5b7a5f1aae84aa8549739cc2964bd4524fdcf89325d375637ae180ad96c964e0fc511bad2b99ff44f9145b7a5ab4dd8ac7c635ce855e7569dc9751d893730be638669414f108a08179bbac63987d17d34e51ee01f1b89ebe7a62a9383c783ccdf246cc3888ca6f7b2e6b301a5f21aeb4973f968c5765223ea3ea0bb8153ab83e319c61e64fa4ca3215f033160c45542a4d439fda92fdc53f707d8839dde4de6fb2e7996bbfa57d5b3053baec76856d576249decf1169b6a0a7c136d07c79c9de2d6f73021d929b04aeb398aa85b90df4bca4c9c5010d540e1b9802d08eb928eb877667b62e4720e49150b6113a47479af9d09b8eaeec82ab7682ca6e8297e0148870a0836b15e9555c94e6828f41df65bb5d5eb46dd2e6d1b836be796bec8fc945ff774c72d0d1b816efe1760fbb22ff964258c749566e58bbac48c4ba5c8852694bb0698e8e8fd749f87f71550fac3d9b36aef20cff057d88de9534dbb5c6fae926e59ec0394fc4fe4ed0e869b6024c04c4ed447c5031f17bd80c71ccf16beee2c531d0bf2814c2043a6fa15f72b9769be737fbe46cc2463b71b4e3228d2729895d1ad44e80418688dc462b0c005743dd3fd102e78e9051044bb6373c55f41a1d0718897158b17533dd366a04de07cf390e06234a91043044f4c4523756f28cc17a3f2e8f21d9f937d6791ea1aec0386d66415ac63e2ab8a402dd54239cc21cba7c9c8807bb96d799f6fdfd4ff6dde521f01fc08a46bad0ab065f8895fa83186c47df2ae4f8ea33c0653a8bff15dcefcd41dadc94e7673fc06ecf81e1da73562b9b3f47659e8ca64a02a121c7143a43dc5d03f156f43f1685b632943f97276dc8b8792ddcf602e32c595e10f74448f906a675bb94e5df595c74e5da44f0d2d9ff3e4f41bdd1172284884cfbd6b942a3712cc061bdf431969e124f7f24779d2e11510029f421dc80c9fe63c68d89451ace398e82844fc343811a55b1fc5ca511e251459a6436857eb5e67b7931c55db70589131b99c4829432d3487d3b8aa79d51793006f77471cfb0065b5e6c784aa1832fabe1fb9bf3a5908c780f304401cc84705500053be097e7b6d1d80cdc970da13cee2012900252d20cba191f714d160796ad9e5b0a38608f6161e368334c282eb0e65a4f69a2612b9cc092098216a7677303568c77a67fe51062926e59b7f8856752dd3817637b0e86aca1d60bffe35c0969006e9900e7f55cce847b1a0bef5619d46c6e915a23c28fb96c52d7a40f07cdf741b98f22870ea74b13fd4d2f317e17f4b4a2802f4c13059cded7ab80eded137c315ed060a8db2f8cc9f8217573ba17d68e38f8f2481a09052ac24b65060b22f84a8d5bf437614013cf33ff2940e3f3a897b0e1780e120570ed294c9396fbd1a7e91c0a20bfb38434fbd2e7847e19dc4f34147990df7dcf1b7bdb30319054b2f74ad47710666bb21211a26797b817667d99dd8cefb657e69b97b300e40766cfab357a99979276531cd97671edbdce8cafbce918839ab7ec41b5049ff2608a15616601e93d0edd1bac1b164df09ae6a2981e5e985fc817b942bd012c2b12bf024506e8574b1d5f3e1b3426dd3ff61156897c1d80f5e654795baacae55a01d1cb80e18ad8dea4b5983fd8bd6bfdec85e040b7149d80762fa6f12d79ec71f2f31321f236bcf52a37f7790e68b156a0d17e345d15ef4f35694504abfb17366bd8e89615f3c8e370d40f9d362ebaadda1d0f75b0e34933b32da26d8e61546c39ba382ad229a38d7b7da49cd9786d6373b01a70765369a644ca789d808ccaed7853cb40ad56230395df6a603423bda45bf65b0dedbb47079c14431850e652960f29cfc4e5df08634ac6c35a6359aab24c7d831f5d61cc5af5bbf56423eaf1c2081740e400d0beb686bd3cfcdde9f85a4659245ab8ab0f3b38f49f08948dfe533146cdbe96bc7910217e82ca9cebbaad161dce35aa8520afdc81cdab6688800e316f690fa0586b185409ab8efddc961877be518329bab812c5baba6ae3ffacd685f40bd2cdc5ef9d09e1ba55dda7bca61a982fb40bbc8351a09778bc619586b2f168955e4766d7422bb19c165b430d17ddff704915521ccbd9819f7cc9e57777d3ffa38698fce0e2f02c1e67fdfdc814281f12dfb23bb934cc1d22906872ca881fb63bc173f31d195611c483b43bd089485093c15ccee5bcb5fd2826f1309ebc0f4a8ce54452d8469a959eb18fbc855fc086ab533a7e73e633a7d9621dd5470d471bf2dfd0f29b5bda672b0426376b48aba616499655061fe90794a10f294ac18c4bc15fc535595bd207dbeb853a17079d987f12915e97050159d70089583f53fc8c9f81bd54264fcfa8dcdc5ae8489fc85b4513f264bbc7430cce6fb36d4e124bf5639b5e1fa912e4e027227b1827900f0d8398dda498ef4156f536b8188fd1233fb2ce9d90ea2385c384cf6650e926d6496d751b20c6e98237e1c5c1741ae34439ad9240b02ef5b1adbf97527ce76ecf6481f2240e3de9516a4efff61f94ecb64c54bebf54cf85841da9c10c3c37d0ead0acca2bd8bd974d74897cc4cc5ff2ae186871ff164e326f41c083e0d52e316da0ce8e39ca59c5704d1075f658c4ae447d8c82996acfe3a58161ebbd1232bcc9aa6aaa86e73a61bf5cd8714e50f780ee6ec2d04f1cb1de932f1b13e5a06b91fb9d27f806d4f0cc08e6b113a609b8236a2f876e2d5d5297b88728c95d8cfbd3aac3836cb52f39eacabbda3ca5f6e9ebb8ac536e759cea703cea90b8043f58ed32b8c7b7d981879be2996eec9567f87e9484dd7cb10acc9883222568ba4a3ef4b046a1410f780b2d0f883b7792f10a9dfa32af987def497da3405cafaf3ac84d0db235f59711d2c8680634ffdef34b9fced91b36f8fd48f713e0e7c14287a23d10b712331146142a96fd7fa2983d950d900af4a0b0bd1d3fec20e6a338c5cb0683f4972ed893091641d2e6edb2d40a9dc11968d5a7b85188a7c513daaefcd1f87122037d259cf8b3633acbb0fc7e2f42ec1e2ca2d494f818fc43b701e4117d953326f126c1c01c3763b889aa935ae6960559b34487de7b71adb309742ecf58b72c5066467fce17d43fc006361ad5b10347963b78dfa77ab8f865296d4cdb003246f3dccab033f72dedf07992eeb4e40699c9bd414473a2952fb8a35e8cdd849320438ae7641bb75e94c5b72e19d981d8d84466685eb5763f5bf27a82dd7d5b1b2abbaa59d0511556c794002d78540c26c87a085fa9270a060f51db01b242ca10d37900ad0f36633e52c8e999fff2f6926a3c35e971955bbce7f71e0064b34028034466bffeca5070437e0aa9832f3f749f9bf087cf9c7286e371156da12097460046a322eb5f21ca683af93664ae10168ab4db41b271b7f4cd190bc44eb456b35d38df25da564e3f7e120a4c380553957374d2bf12b967617002f20981e2b31edb8b4596b3431981f390b9cfdf8b03bd7a1996e622e91ba5418e28f58d982ce46e7bdf9d7e9d3d39ec74a086e250b85952826d55edf31b69a965e8ad175c1d616a2253d781d0efa9275c6435bde2d05070fc7026b06bb59be1338e771695056e84667ca25d604f4fd8b1393922e633e2171be2a6fc54e838e4a915119e8ea72885d5750b5c3e289587c3f4566645982e068e0a1236b51d3c86d9a7e0bf367ba72519acbd1da2017a0789c5e33d27e2fd70a273c8a3bcec946e1a9999b31bfa5bcd54d1302dc8277b14e4fe9ec60045a1f268ae8d2056a872a2dd611e5ba1f0a754d44877067a5284b6b77b2dd68e5bb361aa3ac4a36cd963390510b4b0f3ddba0fb4aa099b1275c53c42dee6f2e005708eb6e27fb6b2e264e50c6d2f407c03a2bd325b3725d6969bdaece92500fcce53ceeb8324f5054da336eaefec9f7c9ff75ccd78aa81cca385259b052931954a369d571c6105b6475f74193b84aa144f6a66ae04486e9c25a6cb09a6b23b3a4fb585cd03b87b51799d21c6bc68fad7dc7c9be14bee31326ed1fcaaaea1fbc6b9be1d12cc0bdbf57376454f27175cfef2c087df4656c6216cc8c9bf083b9df22325fbc6d40978df1c74b273aadf1616bf2ea870cfdc0266cc92a1f2a63a85547c7706e8c235e72582deae854c35c7dd9a525383d6879e5a371d71a951b2e441b09503722373a2a7d1d5124742b184e92ff1aec6a16ab995f4352ba0ae64ea095a4a84bf5d964edae6b21038e0a009685501c8cdf4f802b5486680bb5fed69109d1de42a63c00fdbb6df7808e04ae1eb91cc8a0c4b2fb3b099b21f0d4164be851035359eb14819fd90abd49728f56934508d3add7d59b162dd2d546b76d1c92e23f26f2b14ba9bf006d051ea2aaf07c0e875e7e869643bc6fc64386b6eaed6a363f44008eb252b66c9a57ab646285372c72b2f1de052b99b3631146e45371a260444570d7671aa785341ea8ca8835dbd933aba2f5c94627e32e39cbc9d5d4130e8889e0b287767c78c29c7ccbaab913cbbf78c3dff093a58a1fffe1a714f02bd2f527743f0993be993389e2ed7ffa03e53dd4b5e7438c6def27a32506d34ba1d7ff998f066918acc41b7f4681e792be82b3f84424886c425543fa1e0754c6a5f1c35d045f93d4f23f7560daf864230035bd6e52317d1747b9853da0b9cff08c3924372776869843a4e4a3bd82a8491346776ccfe59780bf583ae7d6d9ff2945c06d431f785b744c2ffcba588b3126a48ddf95644e6874f5ca44d43dacf27b3a0d1c40549d49389b9cab2b3f4a55935719c1db1d57a2ab5a2da46154f54de601f36db142d305ddb42ecf99b1aa5ea4156a37b84353db4309342f71a562868e354758398090c69e12365ae1da7291d50afc76eb8de182ac3adbc54e48d69ca5abdb72956ea1171a859bbf27a0a543e2be784e044e68ec520221a0322ccd73734bc4eeb4af5db4f5f3aa7ee635dd110504b5add5286e35b03be79f3342a8712a6c55680d69f4b0337a33faa9546554479cf12e3aa21942468db202fc02ae85d9feee29a07695aa7ace1340fec61fd3c04565c0bcfa17771c3fd62cc5ad5461332fc94663b208029117c70e281dcce204fe47ba637a8d8a3e00c3d1f3ff1f1feaa228f32b67773d6f8858fbc3fecfa2ccfd82c9edab5e9f19992710ccae15a941dcbb7fc70c873d4e0abf171ab970dd5e541febf571fa80ceeac06a4b5331eb0b6a923f4326d5f7e64242d279ff2efc06fd6180ddd473537407e231f86a284d2d370bee98e33fb91459f5baaf1727a2d56aba8f0cd2f4f7e1ba41355b08cbc233a9e541f667d97cee17a393642467b935760f203d411be384d379635874ae4ea03a64ffbaccc9635ccdf17fad7e8f106c20cfa6d4c76413bffecd1bffd9d0b931876397c5938a04f8de8a7771f8ed0a23e10f1b1b7d4d869cb182464ee3cf38fd6943b8c7eeff4b38ad6bfa04343955941887cf8bb1959899d6b5dc0e71266e7c3527aeb2962b9609999e2a828e62f9b90aa163bcfe8a40de2ca423cc1e9476e97ec975b8fc2265714dc5634275c83877c5cf21a630103a82865","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
