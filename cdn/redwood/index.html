<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17d97cba87f882dea394c56dd04f0235527d52d9f2e1091889d97ce1c38fdbd9d64a0e6d20ddb25c1bbbec4c3beec1884fd848c766f6f8c05abd9e1c218eaf0c3d3f654537347b43911801caf6ae01b4ad8ea04a8a86fa062bd4452058974fab6aa98c371de9552067829092f61851c132c6dde24ee15cec62aa1581de2231889e6590137d9110648731a6d2c24579743a514772ec626adcc1a85d5800afb648e3ba31fdfb9bdbdb7234009bedb02f383de0408329c657dfbf7b0632edd1c18e79f5fb73efe78c2e28a2dd6d61b280436d766410f8cc771352479d2ca0bc2136d92fb98b8f157998372ba8a6329fe1fa6c7144ef19d65cefb4cbbc9f06fd996126ea7bbcdd0cce37f5b99d1b8211da49862cde7136bd59cf551550b824b4597e4c5d97db33e578f64727ce4234b8839ece46a6d0996c931b567426f13299bb8926e7ed1b4c6b082a22b7f06e1c1344d8b94d7abe6f8fe89b4857de5af6b1ae419701be1aed6e03e8798061e85fa88ffe3ec74f8ef898c84b437a136167be8a71fb59a5ea393e6c5f8b5d53a8d0e0827f64de90b756a97976a0546d844c5106f5428536594c03cb22dc5d453c43bf56128826f9cf713daccfaa10bb529e8b3fd9231c3ee99895f25805e809537051a6d92c5993d1212b39ea3009f7cf0ba185d5b6cd3a925227b593cda333f487080847611af2b3d9fe74c42b0636f96877e6c3e4cf456f4fde9112b10598a3d5632a74dca6597f89d493ea662c9bcc7943a43d597494334fe09dfe4093861512d7697cc986d34f3f89003f7c12605c93418f2c4dbe1d18b832e601650863b28e621954084efc6e06c8a20a5992962dcde4eb5b470334efad17861a0ae71e70a7fa55a180b4f94aa428e47201baeed6460f14780b12c05c92fffb4d3989e81c0b150ee239e77721765632feadc75a7af2760099a93be299afc3c675bba08b84d70112d3e09561665c0c2ccbe3470ea166863439dff2b41e7102bbc693f2144687c65b83180707ddb362b36e7cbb356e0c59ac330f6958dc415bda3c93e01ca76a6d4444fc9f8004d3b16b1bf8f91495691eb1b7677e1c07095eb3de15b891578b50702a0a4b1741cfbd180c1684ebff9c7605f5f5d0aa03e72b9d099c6d7a0355ccb214c5313a3208ae841ee09f58699aae4969508c61a47c8a155fc8b784fb7e8e280e4de9fc54a054cc2c409d913d15606cde71fb9b7ffa2ac748b9b472fb60fb255dd63dd35d5a72bad44915c33c3d08b881a975311cb8c0dc3ffe55553b4aaac7aa2532152028b18bb3adfabad10fd163b9254e62e8297c2cabb45aced4d7dbb7be7ee3042719c555f06084a17f0ff9baca17a2f0065c5b3c778274d137fb1b5e85585b287e66831e9f3bc14c557e7fa863c0bc5464bab3029761d039427bd2118247f601a53d9dd50044d3756a5e5d9d906c17a7298dc3787367e94f6714f0af2c688f990821e61a8f17d1788cfab3c85242a9fb3b5106ba252e04547a1da99f758259b4609fa20ec475615029372697acace76470f993210d6d1a0511fcf35cc1fbb66d92e1349ddf1bc9d1f59ecae3e7e2fbce9037c333c012866abd0a83876b8f05c067212cc787990c86ae5d4fcca2ec0cc42633d19642cac632cd785b2da1d6c5a59789632c8997b23587b9062d8f5da194358fed52a6bb1b7ca85066c71299baf0e3ac78a34406884db200989082f5a8ff9b3a08194ce437aa4f4d9a0c83164787f7af8b885b7cfed91ed828e4a4d3533dd05333929168502034bb98cd8f9887b4ee12666faa3d9b365adffbeb1aa5c46bf7980ef025043da06cc3054fde049d7ffc91578a91da985148680f13b7aa39cfef4ef7594cd4e96c05f2f7f6844bc5f060e13a42b8a77b1b999f84566a422376c0a93bb189f80404862499689b0eccf207d9e78ecd39fce4ec4908d10c5d76baeb237cddcdf84446df1aa66dfb7e544e30395a2b151cfa26e3d3573546374338756386787b6801816ba985f1ac0e27c6236e33fcc48e155bd6b4ff0c453d9ab40927449646ec540d3c1eb983502b69c20fe4ef12f13bbf1a3aab779cb4ef27829c75059290f70c2325d190246024c6323cf9b152a6154d8f0f3b13d1f68b4512f0f73c1ad9dcdc6a716dbb71cc0f58d4a6def5bf860967acda884afdbe2d17bbe537359197a7c69f3a7abd8920fe6a13bb3f6ea00e208a56bb9f7af9661f5d6a49cfebe1638008ed25e04e80309c939b82be204c3247951a8c6fdf37198df191db78b783f7c686196f918b1913117ca1e806be6b880b5341079c0ee06f3e210fa072a77c74b198fa70b093216a748c329edf78dd7d6c546832067f94c051aeb777b0e3cf1ea12ada2cdb4eb245dccd0b914a40209d6b16689b3c383e7cf6f7973f0a041aa8d412184307be757f3473e3e448d193f731ac9bed689cfe8db1442b25ae03b91bb1a9790f0b5e8c2c3801187d53a4bfee4c535a7379baa6af11265ec751e1f0ff40e2c26c3e9803074c88f39471fe1bb50a39fd7852f0aa0a6af0a14584704e6a7ab9721858b7a17ac104910cef0882779c55e5fa45bc2921cea0fa0910d64bfe5fa4ff6e74726d92254c4836dd7ad289e696fd1770b01ae7de20884868e2a9ade09527886da7f4a89b3bb3e25d99f492d23fa739ab27f557117b7b32623e80ad83031026619df32af9d2de73f3b31689dbb074553dca06463b35b6ec6fbc55ad4faa9544389c2e20b276d8ab034987608c745854a8f46755951ad931c44a53f899c9c74182b007bb6d9675d2de8cf509b6cd5b71417e6fee95f315cfe8bc37d71509bbb8d191324c104b96763942f0cf1985604c78899547c86446be46c6065b810709cfe3f6636ddcb3e731bae5e9832f3fbdaf12197fa651a3a4e46d089bc377bac9f8656a9154284dbab15ee0f03f75fe2ec8080791fc551167a830e623cb23682e839648bcfd4eb684e71033a03bc52bf7407039597acd306b8959890d5ec558a9fd39f6cf217203e622274808dcb8158b9a417039c9e07531406def8eb536d968ed9f81fea692a593d35360b8f9afc6bfe56e776706dc25b307cb730078d416973fc8d00331c2658cd619093a7860f40b0b81263c55f29c51e322eb75d409a01e841163cbf9218d7f8f57bc742870cf30c426d4152d3886a5d148708e4de297de0b44339bad5acdfc3b23dd960eae3f7972eedc639007b027babf05977f408551d85797f5df151bfff9e9c51fa05bbe0a25fdbfbb23d1fd2a896fd18e58f79f2f6a68dadc162b053afa68c8e855df3b75337d8446d9d271b90046f1d115c7ad3251cddf3044ee015fbc537ac7b6cfbcc714be0fc7602109e10380f67893fc32724d519b1b4d86c729271322e5adafdf4dc9a4f30d9135e997bd7d4b15f6d0222eddf85db7ae43a62ebad51516801e893ebf18ac76c09332bc3813881bd38e42d7d570b97fa9688f773393eee9208bead9ee888e84ac88846348b75d6df88701c4a32c3ee963aec8e52723c449110529a10e65203bb83beaa6e704207e6679658f9003e1c580fb13c3e3d069d43e919ca4a74fb118d23c0b7f5f9a801570d15802d68dc8af91ebbb924011f9ab5ba4045cce133ce677cd03b10bdb5af5c7c71967a9469bb588734a3178e71d67db40c1ec9f6526c409205fae31e6620bf267a8c969c255336ef613f26891c9565003d62a9f657a2b8930f3d402e65a409a59353f17a58b659209e36ec3b99acd0f4f06116e43237b8651a69beb9a9b9c2d92aadbcb5c097e6bf52a7b625991497b62e4a6a786191cf20bdc380040536e0e756eb37d5c6248e962b024eed9ac4432a2ff481fd81ead179f42e20b25152b89ac88de1afd9fa745bd0080fb95cf4b0baeebc21049ec3784fa95753d61c88a4fa26f89bd78b46cbafcd83f1ea2facfd66fb271cf439a86b25f87bc64fccce6531fbd50b39dc77a97cce8569ac5149b56610bd2bf8eeedf59f60cb691588574fe117e876c967044fd848864075346642c3f685e5076c2dab158d8b04bea350c4995be2a9ea0ced19d43a19efc07fd02685f78b00d1683aa8e3b53541023a6e47c1382830d6a83a4cb94dc4c5ddceda1bc5ef97d5e5333eb095cf25050f9577896742b7b7f5f10fa4a4d22243d67edb3ab7e6a8e424378ff4afe7b91c3ef1a3fca544f9e14866f2aa8a5d21926731a21b3872062b1cf828f96024d85543803dac32e63253e2fd4326e4dd53eda213a59952c749abf3129fd9dfca8d397ac24090b79ebbd396bb484d197d8845aaa54458aa7cc2412e8fd7e03024eef7da989f75591c4e9c471e635600c7e941ad160c08fecd5f095139b5885bb01aad641f63a3b63368d7dda74bbe9318d0222c667fc9af278087dd2dde3884a2d42e1c9b646a543eeb3edb851c08de8936aa4c0efebaa27a6142bb479129a626aa214a0a1604cf7f740dc9ff93d6dc6a97a4ee32d1c5bec05b446c63e552c4602600e666f1206b87530bef0afdcc4de324497a38f438aafcb046fb2c7bcf31df695ab1c69fbb1f2c1ca715dd642268297f44b99fe753a84136f2915e23794f9746023812444417c0f840ae75ad73255f7fbdea11ad6c9c13e509482c7e84c69bdff3569009e0a4148c8307fbd241d9f2b011efadad4315a3459d7cb36533f73edbd4596230400aebd5c6d6393866dc1dc899269dc21f3b6e3e456b5e01bfa893fc882d3428289ea65da0974bbd4a1f58801b6871d317ea3d597cf03b5af1ec9b486a99b452340a60c0d44300aa11bee40ea081bec812b2ea1c6852bad1fc97fe462cae5ff3796273cbcbbcb88debd1f7830333b27f008318fdb4be5f4382b4fd137c24d09af4796b738123af1f06ed3bf1dd719bf1eff1df39fe1182119c123bee8918e2d9e03b1bea77c555e09b61914e407835a5f7a7164dee0409b367210629d319785ba92e3a98749f5790544b16bcfd2bd4cb06a15855e395a8f587e7ea74c22b22bd51e8ad65502ace48b8ca73757a2bd057f6e76e4fd9657eed120bb13b4fb208d7d0fcc0d38d1f7f73e8638e8ba90ed65de2de7e9ce2e6cfb20d028a3906ccd1f52b705d5270ddc59f602db37db8973eae0a88301a79042aa7c05227efc6770fe0fceb5be1dd4f93e9f6778fc8a6de93bc751b1c2ccde1eb2d70a22566232220e26bee97045f68ed508b4f064dda180c57b4344803e740115cc44bf293afd8e9371b838908bbfdc1bc269653a846f7552af3de14bf18debd9c0df92d2a6c31fa44175339a1dae4a30e20a99d5a78c0a0bf4b5e30444d2c9c75804c8a0622e1655c62ec0539a48a9c4afea8c71eccbdc4f322fcddc802a1aad5df8847cccd40dc4320c51d07004741bb2f4688cfca027f343b1892619a6cc914d9730b1419351a2167d2ab3598e0ba2ff0d84fc77de5b6a2e393fb2e77674124a4cee12fee986b0cf3091013d7bc5c7867248a8c4a703720bac3bf6a92f796989e16e6bcdac39a192edd2f509cecc8fe75e59d03bc29dd9a2313ed6bdb126f5d35f641602bb5010e47ce743bc945dcb1a48b156601f71ccc414f4d33f309ae231025be66c9d0ba44c96683a962d231e67e4e774186b828aba2f922323a4861be02874b2ef57083180a7f7144be51a7d4c3f5c74652b13827646e9cae014e9ff752ff99beaee387349fbfbbb211a5744f2849bbd1bb567d4b66139d071f35d86445013faca17265c8e8def45755d2c5f462fbb86e31a15d692fc8435a39580b6eb7ea9de8061e13e634e29afd09411b822636ed164d868362417047d4efe98ec825e672e0def7d9951aabba8c516cc3f6f49785f76170500859f2cb0bc4f53c55bfc59f0bc3109a49ad1ddb56491d81922ca60539ee13ec0aabff712d0376814436d4c7327183481f6e51f85f67a214f01689fb18a7f80db923ce9e06345193db65344455a76d19cb64a6359e668f817ee2ec887e4c3598e157d28258257071588ea9c9bcc33fd50e0249d8e58ffddac7a117ee74f39b761f89a99ccfffd403d5266d7d1c497af48a2888755552c969d2ed33e8c03a96c6ec860435a9cae3dab18dbc2391337632eb5cf35ed37cee889910d71d99c0c5c7248581344fdab30946d901bce76f1d5c49d47673ff7e3389e4ea734c96c254fe081a7b039760119d06cf5b15929d44278ae0ef4ec3efc33018ff6d7cd6b6ffd2d2db3a356eef9f4655433cddd17e2069ccaef3c9ad030c2c8d493f3e118c53bdbead0dfa8f654969c1d788e3d54ac838c5edc35a8f1cf0d8c36efe7177c99fc61f2b6cd4c420718f70bdc000821517259fd18fe6c5be3c065d374775f3b0d5ae10784856dcb992a0650ba3e935910bdcdad301c2c7d707c69e1ea1bdd6b066ee681efc71b6cfa6dd5f9a57892da6e88a8204ce7b13ab826475999b23c86aa431897ba4083a63a2b138ac3806ddcb95d8edee2f50b3181e9f09395d8ab980c2b5751f894d4fd82671741620fb25a3dcf3d3f3ceeb3ba0ea75e7e056ed6795d7189b833fbb2dbbf961eb539fea65e950b3bdee5b7558f9677e65ec5550b16309ad8bb90b2a7af21069c377912f1049bec27d78a76e4ef0c88a70ac0be1c866f3823320c97366f9453a2d95dc90ffb1ceeac09f5c58b00b9de9018698bded4ec3d1d61224820b210a0e56fbc4c62fd6e0e1c838c662b1f653064c683897795337e58dfc9e55826ff9dbd04b770dfe80cefbca42b47d68e8edd51b10bfa229eb7ea63db5f9b764bb7634800c1cbfa86a999435bd8e417f14f94a39749d31e0058117bf8d179226a8ffacc152aaec0ab43a20a4870856d1f40dec3f57f0cf2d74a8880fc0567210ad65c56c183a9f1425cade545229f48a4b63538831ae327dcc18093170000000e7cc44998235768775309750510eec87ab80e7b2bd329047252a853b4e842e0920ae0f34a2febc3d98e5aa1b413db15beaecc808e28081dbd88dc02dd0245c04f6d89b2b1669a70019d35ff04e273c5da65e54330640ce7e7c4d8bf32d06474101bcc7656dcab9b314e65f72d222c7157ad0886b46d38174e416a80a04b3e3a9f1580d3fcfa91e7e78f9c1f290f665a31f747f7a349df409173ca6ffbde9d2a215e6cb33680437fbce4ed10531c21c953f154270523b0bd133e14aa5d9d74483ca7466b6217c59668b8fcfbfe371381113340ff93d7feae5c703239bd06a20ed13eaedff7034a340381922a0fa69c57ad5314386d934286dd4f06da65590de3c03cb97296fa15612da19bc34ffb6f124e357f5a0bfff82e7dba6637c7ef9aafed98949a6d394a1742c9b660bc46b23a298b01b7f203fb23bdd13cce9810b1dd6b99f518d2fa2ce45acd052290f141cf6c722506400769fd95c7cf5f263a8a77cec75e217b07ebed43e3c7715f8123d3cc56dc9921db383fdcad5fbe75df565ee1bbbb7aea27f24f55d4412fd784bec7d6a19ad3f496344094a251452b9699eca6d839fdae32847099ec590ad17a514b6e6a76f6137d7b60607feb6bfd409e712e6f8c092735cc14eca2a4f5eefb69b15c4cfbd2f112eb9d27b0d72c9c2000a3da688451ebe30126b06c6106f7339778315aa7c44283248573719221055535f7a8c9641449a7deca788e810ffb03744282cbb64d61d5977de707e5c65d56eb8b678f723904974505534f616a2b77b60284f46cad7279b1b4703d9a42368b5fcefe362fddc3b37599a46e69644f1f5588316b4e3f4a6f0bb24700d1a8135c3321d7b4027330cff02bdd27cf208c1edf3c0200d6ded1766323fd51c73be55a4e1be86955eb94b25222557420b7632d2771ef8c7dcabb7ac57e9e170bbd1a5dd2cf7ef9f67ecb5cec5e860559e67a34515880dc38819f54a7e22ba266c9b48a8532b4a78e51d2036c7bdc602767f4acabdfff40809276d035c65aa0682d0a7da4840d10f9e2ce581dacebee4cd6416d12eac6a03b0f71a3f6f71cada3d12274e9a151e10c0d2ca2efe1c25b4d99857328aa93c72358f1426457406dac0859f083740c0f32d25b4e62f8430c950611a179894f030bc6d41685daa2b1f60d209f6a3f5486787069464bd26bc71b5735a1e4a3b20dea39c05449edfa5e263ba1684649d4e457afe287febb64bf758ccad2d488ffbd5653cd2a1caa770ef18877f257d269161968a1c5af2755777015cce8ddbc28e6875fbc65d018711224a7c2e0116fc1459c1b17c9668fc2d6a9318acab4ae608b3d1e5cbb90be56f4939669dfde4865b5c9e04cbd912579c005f184bd2920a1dae5672bde5b3a7bfee5395dd4112f07651c76a16ee1715e6bb29ac35e3d9a9ccc39d413c92a318fa338622d8c23201e2d6dddc57f173d60f6d8d14b521b29526a8e9cb33a7d8a80694622012bf64ded4e610c58698dec983fce9c4e9600856a01c1ce095e49efdd28f77931efc6d20d8fd7b2d9fb838a91fbe85f6455abfb48323444d960472276bc216692f3fb952da1d705a4091c9fade1f56f14db83df1a4f975f539e498686819ace521e7dbd74cf7d3a19f01d5d4feb1121ab806a291164b84093fa56a5b7038bae845076a3523c9fa91f20a549c682b1630e734e7cbb0dfbd3fb913fe6264e2625593e580543d430ec5d73598573c4fa381686599416afd0eb331840e14f8462a94d01c860ef07ebb67d3e5df1b6a87583c6da8e56efefa165f3fff060c5f790fc86f6e0be661fc58bc2effa0265a54c5645d9fb78c207cd793405d20bac7ec5068842697b9b7c46bea2c70372482d6ff35d5fa26dfb2cb2a8e812d465d44477202e579289616edd547ff72ed28a3f8b1b6166d9ec0b1d55c2a6ff1f53364791363c0c30e32257927282cd95a1dd73c08bcf2dcc48d763fb2136a8806651ffe82c15b7dee6a69249d5a729fe3d48e2e7b70bde475463121f5a14a45bc596aec9a3290d9d4523e43532cc9e2b96dc3e94a7fce66df23cdc1c44a5807470da7a0230519f09422d4ae656c685e5442ac6ec875ca2baa5cbf96d33169ecbab0071f6800650daef7793920dc0dca589324c7a6c882e1077d49ea20f8d6d232006b5a13086bb9b2736de612df08ffba61d7f4867a36b9a855ec7b4098541a83ddb6ed25dc19a434ae53927409229cf9b20113abefba2c01b7555f6915a293eeba8926774252659b70c5ca7fb3d9b2aeb71543ae19eb638183231832306240e35a2556ba7f4413e05a547dca6939ceb3ffb69dca71931e5dea7d19d74909ba11be28525f943aa3074b38294cf8cbb0d6c3b7d14bb81cbafe8ad8a6e72dd2ac1c9a6ebd5ef7f76d2c9bcd8fa49a59aa7a4ac12889c4669d59c6c014388a7125f68da3a943600796ca81be13861a058e4a55ff4723e00ba4f13b798f8c66a371a521db88a2a8da1453757cdbed7a412de556bea80fc072c0059efdae579860907d45995eafe08a5511ff93fe8ef70d5e98620ac39538c9c566fa3588280f410899d0b9fc8bfed081bd681546fde1db7fc35837aae70f4df496959ad5244297a97a524a707232e2793c94f85c2b889ed03351312455a95caf8d0b28f53ce153d8a5cbfe4a2d45f75898344aad2454d566788de2e426fa9c728dd122edacb3d678a1857158b09daec1ed1ac7d64ede107376577df4317c922ff0d23ce2de39af4745a1d6093335a7e5912fe7e03e6548f0002bd39c9f88742cb4cfce64d5169234d970a0fa54181afc9fa0c73bf925e5cfc6ffc90157c60ce7973684b4d9aa04762623c0597aa7950e33e62878d4d948f70039ac6c343e6e67409854a595059508d3145a06c6f6111b9f53b5e0358ff763ff7ae5ff9acd1893ade6f820d1a6c0c18f03575af221bf085360e5f4ad8f309af0729f46981a13b874c517e4d6ba3d6392bb9d215c9b442825bdf7f27deb8c0419006a59318bb8c07f87ee87d5ecb2417d06ce4c8150d8bf512c76f01510d6d17d8cc59bd9d42677dd33411903afb4c6f2381f740bb4dffe46bd25dbda3d91885455e7e7c951cca1cf3facff3699bc51829ac9dd4b3ad098c21cdfcb3e4ab722ed5cfcf1c3449ada0229793395cf5cb18cc0b0dc40070365bd2f194b4fb89c16f13cbb7ac22a0adbf712000fabe5550c2513eedda98a7df3b4f8ed9441fd7a2b4729b243d47765572f22d0618206f5f6a8321e29b87aa5b47c6f837e556446e4ad25202eeaf29ae73c45a557b6733b1e88aa438e599f01f16f861f1e1d055f154be8e9c6021c4082cb5309157541c238b81795bad618f8fa39bb9861e345a45229939932ace7dff361b4cb19533780d3b4508597c97230a2781b457151a734eea6ebf428d88ffcc5e5e14e0d16a531028857da07243f07f7c96def2f175931547c19b0df554826df5c592e1f3b667ac19db8ec63dd2f1fff21283d6a49b6da02541a25f196a2b918d4eb7ad9e90042714fa1eeb163b7952b9e3cb4f9300feb145d316a8b16bbe103ad4f578ae0e4fa7fd83fb60ef6e73fbcd7132c2d142c5de2755d86c73ae321a30d8cddf0600f9f6b33134c101ea60a153599a9a26d41afb97195954f35b8daac49d90162b768406eebde0b8c5ad75c645af1faa5a4db4229584ef35f02db3e498c3f1fc474241ff1b18a8733ded841b59e967853e7dddef61f52fe18c0891ff7787d87781f7b0aa5d32c4242b46163990d30ffd3a18f29feef75bebe0152aa85555537a33ba0c02dc5c9007e1023f7abaa7bedd675b3a7be813af68647e923d79dc7b809ad7c48fd6fd6785d434b6653aeb0752c6112b3dddf4cc300a8dbd45117fbf4901c7ddd292183011f8ba2e6cd969a533ee95f88ea819fa0d0087aa03863fa68f968b2feaf016738dcf08f6497cc6d69c1d83e895a7ce6b2f806b252f82deb17a9ba5719fc4565adc7d04e49e8451f3f7a71417bbe465735db7248cefcdd137ce0c912fcf28d89a4ae09e066d2398695cef44fddffbef6c3d40194aa3da834bd6b7e1cc815262486bd13e40c62490ee44fe48cdf6f6e55234383f3fa286af9468c6d2e25ef7331d4f359f7a57535a2b1ec374f81d3c40cbb0ee6848ba44e8f268a10e93854b968ecdffbd15c827cc34d936c7c10419652e6863916f23fd1c0ce89577555c98f14585cc18acc2f0bdba4c518e99b35ccf7e9466dc72efe0fd0d628c67ffabf271049175f09a9474b07082709969eee8ee5b5517e704321ca52686a9f1f89dcde96c6c74e7499bcbe5e0b1448ba164c0757bfda1cd634e7086d00d0a6fb30d13b09e063bef8eda61a394a2b753a5031ec833aff2000e5d6f0428f25724c0cb1c0903ca7cd521828d3f36891485e72874a9397ff98f350e3d070d985330fda93079e57a3dd2df2927bd28227fbf0599157c921f24f1daac32df6d1a80ab1c52b0bceb29ea582fe338644b1a1cf8224d141501ea4f7624e839efadfa690e767311ce1ad1d606909cb8a444cc1e1ecede4cff909a58ea4c478dc39524f65d49a173d1aa5bd4d84df6e680b42479f899b493650131989f3f8b4cdc1142a6c786859b0a05673c7db93edada33535ea6d415c0b8bf9ecbdb5727094c627cd5f8f6b2bc0102038c3a1f64131068967bd2ac15d1dc45fde47c69ce56b91de205caf796d1881930b7ee85c37b6b968ba32510b305715af275cc636281bfbc534e2a5b0242eecc49d143b27aded94cb4dd6631c1f7434d68f14f034fcd592ad6ff76ad0743c01f0574f2072c041bd06b8c78528491655ca2fc29932a5580d3c27ac6acb6d8e0f73ea2b0c65ab775c23e8c763d061a866207b7909ecfbf59a73439d966412484934f06f3102ac6b551d9d6cf1daf90213a737c1fd9ec4fc0225d2a51f51618cff8d05766537e7c8250e080092f83ad2b667b79a0de7ac9020a9c3da8bfda3dedf8106b5d680ca323c7b8710300c8425fe2a0ebb08971ea5ad7cbe3c64af1c4005ff0623e2faf087957659a119abc81655c4197970c82627a62fcfd3c2414fe6bfcb569df23e15551ba6dc15fb428dc567e607ba4253a84e8a5095c152906b279f193d39f485cdc4e8acf6c6a1b2f49ecc34d45f0358d596a25d2fc999815a6d650777a2ff7a939d50d4a6f283add807ba937ff44a25d11aa62f013ba4b1c5c64f344d443566de786ed528b88fe2dfb0c805f9e8548f4ed4683dc48b2b59fd76fca6f008d77060887ddd3b05f5676022cb5da1f9e52ce463167dcb04253f7cdad68cf9bb2549907c4dd6ab617d82c256978c4138c45e25ef699a3225e4f933b4fd306643b957d8c4c51456c79a5622ffd418b54fe27f02a1e5db7aa1215bb9392c235ec2340baec9531b5f7cfc6e7211b1a0911c7ade9d30cd92ad067edd02db80853fd4417d6291c2dec84840e4fba722e1841c068f63907c87844bb3c1d4a3c258febfa17922a769cd9b2b279b18d7d4f38f7cf485b6551a1d4bccf30efde8507b073f04f375daea82adabe8b5534d27126433ad3d2ff07feee1aede2c0bf543cf74ab3e01a6766dc85cb96b08821af3fc0f1efad9d0639e781d8f9f23c6f4d5f0bda9c373e9c3b063230ecfc3b102fc9775610a09cfb7f63e4c6946c5bce95eee1dd058678bb460d86ff34107a438b15051666ce861f174894a830afe28f7ee66d1c2694e80965024d568e5ba54e34931e3617552fdd7b8cbab3080cffd5a819b809cbc5579b55d2fa97f4bb612fa478c0167967dc6b7fa3564b85092fe72aeccf1ac581201876807deeeeeeeb62f43b06de6268d95a1e3d0f517d35be6373d24f0f098745013380f20f53d03993936da228da0541aded17578c6406ebfd26fe29d5d750a0934ee47db9fc2178d59bf5c1a371d99f6393f9c9c9ff7f50d41f2d1101c41eeaf2d5b56d702a6b8bafbe9e405403645f5ff43d499755e22df1e5b663cdeb2d230cb6c2fdce38bf652be05e859427b9d5b1d7f1bf99b4fc267a89d2fd1b280fd1e4c6ad69265fdbb0c049cd7f0933636e03cf98b6aa2b70381329aa7b0e6c2f0b2e9d061b79de1f8641b3a9318dc11ebeb6acc14cb04c199a8b6eea629555d9df6ded20bc3b72d82e83b746c7b0ae4645a3f4e93fa81a0fbc15c8a2843d8aa3d8014527b70446632f29388cfd4fc7a403d9f9b109470554857425d02c5a67f8f50048ca7b7deb3bba57a9717487b91d2e2173ff63bfe4634e2249c6dc4f9360606ad34510d5a90b96a86180f066e27ef135bd825864eff195a0407193aa30408afc32401e8e7951c42a1de4103ecf317ac7893c57b02ac1eda771432bfea694e03e3c7e5630856780a9122890effa039faeebeaeade8ef2ea97bdc125bc1a0eadeeb6f2b29c569a2a8a76fef228a72981c299ad336782b9c6187d98537ae322bb89409e2787456f5525a398e2fd3d1bd230a739edf7723f56ed8c1fb5bc858b0f8d7df1f46c0943d2869b1958dd17da0412e07d2a5c867232263fb81440f35aa22acb774bc2fed05d8a424019ecb6c2066c44e7bf90aa7621162b33805133d3993cefb34b8c7fed5009cc1b0709a315c6843f955b43da7b3c413902cd7a7619fd2f0524351c24af8174bd96d13011f19405b67371c8cfd113c0b31f1bbb5b8cf63af9ccc56b02bf9672869b6d1fe5997117bc8bff2014dc90b1e543fc90a69ac8115ba99c888713b48e26371872d78b98138477e4727d459d0ab9fcddef88bfcfee65071ae77ab13d7c3603f03a59d0ec63e0b26c774f19d8957f9d721dcc799850f45cb5aced41e14c4c83ecd15c7b506e78e0494891e31282e200b361358f2125d2d2b3cd136551f90f9b490d2b6bde3bdcdf3feb5b31e0d4996249268e8ab2bc5ba751e14db45b505d287deee6bc6d00501696fb72181214450e75f6c21f74bd77b843f1b44720f35a6bcee13b1e06aada60bf3d7fb03cf83356d0a780e2d166a9ce44c91c20f055f85810ff011593a2bdd1155bd43ace08c4e88a9ef87c0cdc2e2cab59cc402d56ec29444b1e73bc1c85987fafe6af66daa92b32a46faeed48802d52616c60193755c429d912f831765db679ff0c3227c017df5369832fbaf604223590af84e5b1363eb838aca640074d8042462192f4fb1cd6520874284887cd5be9ec740b4c73d13288027ecf166da435a6c3e34e0ed25f6403806d49788d3e1c904e38606b8b3d780008d9f4662878d06dbe629534e24313a0f2ee5b83231044d3997e552c22aa4ce90de89e973db9bb2530f9fc0cbc1a5dc4ac128bf728e5a4919311cb41f306561daeabe54dab1213872f85299e60384928ab421d32a44674858b9207637731e803515915f8b8ac8612d73be687fce85893a948d18d4a8d0f6e1e22dcdff4091f45100ea97e581bb67862ddafb3c736cdc47be4d64b5570de940015720fe818207ff92c1efc47e063541a3249e82d08d0da8ec5a72634078d420802568226a522d10d032bd6caf59da9cb3354d6cce08bb9ae662e64a70a6171c8d3d9c342f625c8bcb51687a88e699ba5c1329ee406d3acbeec7d918a1e0001e61062dce0f38048ff6aa3d9761e00c17421e5cab772d411c2bc3d6a355c0019cfc34cf6ecaf838fe6afb078b20764ff0c70fdc39f727874afe24590e90e3c3d6b97f063c5632df9a063ddff2dcf2421335f57638297380e02ba1f63cd2d95c184e47e64988bf09694fb230f809ba97db69be0a8a2f642bdbdfadd052079e6e77ce035e22cb2ba3017f8ff4ecd51cd568bbf3ceb5010ab01f7431223c4f9ec863355e88f319bfd8fd3d6d867f68e1ba5ac3542275207b8da2d9afcefc8aa643a2bf97061f741506e2c61126dfd4d730224cce7af4aaf0b02090abeebdea871fc30cbf9d3d51b83d910d39a7d162915cbc9ca682cd503d56b50f76a3b89e12deddf67c3bdfc6b3afb9bfa8140b005b7331f72afba9de1f0dc8d664613b20877f16df075c5ef04b15dae6e5d5c01cba964e589e3fdaf9a9a81af36da1027b8407b079e479657763210f5a121dac260a092ec407ae5266f02c14d74f781714988de7915891e74ed31b4db11dd82616bb2cf85acaa5981332b7ef7a71dd64fb5c951f2113488d479603af3be91e69fccfdc9540de0dbb3a30828bf1ff1ddef1a9b6e801173c3e7857e97205bc50e0d59df56b0ca704e60b87e79b961092c1f7803c3f851d7584ead3b0f9da808ebabb244b6a3949f9c5415b0c4e5d539cb64785d9c7d4a73f32e4145c5866f581215f232798ef140e7647498812aeb858083b60e65ebee2459dfd6110cc1bc05ababde8d0ed75d8a23f91f6201b1a3ff4af0289c00f60953092fc01c37534cff62d591efc7a22addf35643c9a0a00bda2446dcff8182bb15dd1b3e1d5d9c8347b3bc9e9e15d838c7c37b40787540e6869005dbf4fe47ce553504f03e875d01d28a57893ee75cb0baf79429a5984c7af3e7b718b8b134d291df2dd0664e9eac64b0f834ba356b077e4c508b07a50b3e18aa4c207b158ad2a54724437a1ab8a04b6d7f78ced389360ebf8dade8c19cb7945364f84a6682d31b942405ef114542f0fa51f681920d4d6668de5aa2b6589a02ee2e113152cf0f21691dcc9f3e6925c2cf8d386250ff0ae0b9ff45567a099cc3587d2c51ae9c2502d71860c2ccc794b6c13065160e3ecd574ae781400b2315a95965931caf739d867a79fa150a7a751c7bc743d95040625b8dac5edb54d020c62885717e6652d286e2a869349bd93f294b37acf5c455b4153dcf92cc7b4ffef2105819850de92fb57f2d4a46c3dd1e2e284659ad38776259e58002306928a0e75eb91a7ae3ee87eaaaa2506c28e7e6ecf34de585e685178f03f92098360def44355ff05518e919716842e1a1f91d3128e02c206d76cbe0c90ad8ec528f41db85e140a8ab970d4db5eaa6814a7b18334fa84355f7a88aeaba79e4c9cd6e41062a5501fae3071cf4fcdf7ba04deeb3bc4dc1fb8a2454e8621a243f2f62b7645d7baca5715177bae0f5af098b1b8b75320fa83153caabadfbd371d2062b47f6fc52932e78fb24db22e526e61b55a6a83027e94908a6dc7f08c38ea082850146769e0cfdc1c5f58d8ebec2690d5a657ad38daa49a6c4a7940dc0bfb8fae9b8a552b3a618e4f1ad29715cd6e711d6dcebc07b69874664f1a1b74e457baa50f4642628a0bfd73787936d2b40b746109680fa3064906270843416b546d3087f71443d7dc98cf93de89767f613cc087083031e092549b894bd9bee94e8510d30af2389ffbe44ce5202bb3c352d23686add6f2e542ef68ea9e3b775aca722379aa75002df8ce71ea61d6ce55a2953ce388ad7c9a8da719df4183a383bc9c61cbfb8d0dc9a8029230cc7ff07cad74e85b6b9f06051bb6aab8ef08858f43f5dde134b3df8c1bdfbe60323ddc310c2eee5e199d80b0e0514d13cf99bcf2ac6f1fb2bb8db7a4443151ff4a3f124699ed7f1a492ec05e0a9582f6964f67c6d01de7144a2b199a84513070d9f905f0c90754a91906bc2c9274b6ea8b20ee9a464b14ea3882d4b1472015020e0c92f5276d89c2f6e486b4305eee6bf81761665678f32909f105846fcbc9828dd4bff197c327cc543f74a5c73ca5e591b52144cec7579dc6392bc15ff974ac4a7a8c693c3e66f2e1d1b8b3bb26a20f344e2aedd1427ae16eae47db194c02b619a152f5305b0a24826dced49077454880d1a742e9c0fad22daf3548efaa8dda4a3bdb980384febc3f18d19cae91ba0284b494cf95938f5be8efcecebfaea4321f8a032ad2c40998364583914be8dc3fcd0d994e1ce60d52915aa9689c4de3f61b774fcae9e9f30ca974f83b94def7bc2084401c4535d0bdc29eccd3551ba4519ae837268817418e4a72f422874a0048a8c20a637866f2ef28aca5ed2ba5bb40a9952771fb6495056b222baeaafb6a5d0bec249aeac50bf5d86c8550cf6d71999cf18bb9b99e127e649003adb185f658dc4954256974567163d48baff7647af07dbe8bb1a72719b24f5ac83e09b719019942826afad54e770b3c848a588067686cf39e98c7273de0a012aaae780e2b4db1188076709958c341d8f653f2bd06068c8bdb3976fba3de18f94c74cb6713b6cf9f627ac8e959c9a9f7bbeeac9500fbb2204fc8e465af2ac42c900afe3f3380aacc0aed1c593883b06e4d7a8695595da7e0374935c9132d895af2a41f7cdb10400bbe92e08ee149edbe4d0e902215b08a53547f250a7eb8344a4d3deceae3701b28ca769ffc69745e20e5a6271718cf7f8cbb05f0dbaf80c476057b40788db26d74834728d98049048e728a0705e0a3447c6efc4688abd8eb970a87c553f596ca001b706086c035967f27bb59c61528d63a2526b448fa49b578e40c3fb227b38fade92cb30bef76166088840cc69fea90500b99571c901149d7835397fe8d83a212602862faf3e97f8bb358d0f59d4175206994115874da889ec153285294b3b0d87f27232754b3291f7de3f7984399d219ce41a8279ee5ad6c459abf2327569c3d672e5729ea9119e2e005bb4cfe1345ced70cf11b89f18e9c55fb9199b3790f1400c40c5fc06333b4f75d04a0c22b1795ade0d3b041ae35a37338103756fbac5c6e72bd1d291782d9e4e2055db308ffd3821d21b98d9239058034d9bc4a1b4bbdfdf6b9a2067f8817f114ea911c5a6ad7452d9ef4367e3bb4598c98221ed30bcf277c08d7ee81f837b4b4eb990c3d1fb3a10480db61a62ff5b462df2cd3e69e753f8b1c7eabf7e77f2a23faed189c6889aa7c6eec3764a4a98aa4bd85101230da33adf0bd93d70cf27ee843cf52a516ee7788a3a8ed9e70e193452e07e9b3d4d11b7bcd047f5c5aa7ee6acc5a48b66bf84a421aa9dfe984ab589147cca624f039653c428439756ace7b4a2b53b5bd3e0119466bc2484077be104883a7822e7f8dd48be64e11d0bcdcd409259d288ba8370c408c933da91038ae70bb9420fce2c47e2a549f2d916bd5eeabeef3a8bb7cab8eb86d3d6ccefdc73caab1954c50f9d75d21c948f7c330f06aa191c87f0b451fff61995c754059d29b63ce9c386c9caa03a15a748de975fcd8af6159ccc37913779a79bef34a4aa4959e4c869e944840fdfc77bfdfc179766cb008f846efd01c5ebbc1a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
