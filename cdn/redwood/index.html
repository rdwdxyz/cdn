<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4b73ea61654d9756d21ff70549f6a85ad437c633d4939f89de16e07f57bada021bd3654b566aff5d276aa996e405cbd6b8ce14fdef9a3b99195a1fdca793f91cea1e9d8d45ee2d7375d1d0d5fa128d960e6e8802433f626ab65c0ab7b626840de76af1db9c4f08a9704ef4634a7f7d86c381dc65d9d555f2f2f1051379250ee20dc3eb9c37aba5c2fab8b226ad323dfb0b9c83066deb7a1eefc7273b531a54782ed5f8af126c68ec9376b09de86b3ceaa7353e798285f9340571bbf768468549083950447fdca169e6557d84c9fab043da66c9f1d6556d58f1d5710da1407e41073e84a3936b5e8053440f776323e8bf231196af8734d192bbe83695b0d433a80de80ad791f071b6e80c7c79f3476e89f5b507d41557c2ea696033bac7f7002e9f0f2e714853790c2647f423ed12c4d634336e5344e730e7125356ac45f8dda1388e0d9890d2986b74b6f11fc10d327fd0009527ac4aea0d81852da59d378a273f92cae44f49fa90c397b71ecb60f8a878ce5e187fbc2442507bc53d4f61770352a9a76d819a4abaaa7f1a892d42674459251277fe34ef57a92d7a402eda24ff54567b5737ea69c8e8c748234acf0c2d29c7d8fb67bd3579f3fd3781f4ac83f44a0eeb4cbdb63a8580f2333202eb955e25e50f8f0c13f32f3d7ee116d5f3d8b3bfc7090a115f616520fe05cc11b56baee8d3e79341b5ce28afcc0abb7665b4ac0a78839d510264a0a1f08498bb1d11e31560d130def7b0fe820f0ab13e641eea0c964ed242e989ef40a06d045c2683ef17782beb96829684603efecca79d3127c756695ba5320431518e8568549d665d60798bf5ae245b26b09c59b6ca0693457ea630b08ceab1eaef7aa27089dddcb706755a80b1cc6b8f5fabaddf22f788462fe6ec463b4f1c3891aa2a352e0ad5eecb15ae89ba8773ca0b94de177a993f759707fc7614a29387a142ebe3c98d7a8bddeb69169c476b8f6b2635f325ba9df8591035e2f737ca83ae72608ed5aa82f959f61ef07d237ef4aaf6fe510d4d1a14808b13a0c27131a1a8348e2b2174508249e0c814e87c7f2a462d052b2c78eb3a151e455fc038beee1ace5c1c075c4b4f6d83401a8adaaff762645d0dead7f98fb95f2cb321867f6e00a87dd7d04afaee905cc90b0787eaee6a6eebaba67f677c3b505f96a83d5407ab2a189b713f07f4d29e282711e78efdf86b723e3d1f6f0fa55d64f5b7cf29a4e0eeeec5b43b13fbd6538f2ab471f421bafb4b16bde20c596c79fdaa643e0c4ce5480fc70d8332536b86e6f64a8fc1394d8c474a5ed40dc08694da37723ffe6d67b30fd29549a60144de14122b7a1e4c5fe4f9f47dd2d0dee7d14e502a7f5caed0611b553369666e79f9c57ff01a4b4f95f26e13dc731a7a449d21c231486cedd5a5d49daf88adb076972f83c27bcd9b4b75c2ab69fd04e2efd096759f8ac34e1c56c94f57694cb4da1d6ef0ad9c3b4be85cf557f3e91756d834454cb816429e64cf1db90a8b855c5769113eebf5511db9741feeb5495aec3080efd4ddf6ba77eb38ecde08d956f67487d96a37c6076812e1e6924c8d92af5e01e33ad89cc5a4c74ce9b7d52b338c48c4efe8180e359c31c4530e52ac25c457b63cf71fe47d388940b9254671bb8c4139bbe4d66e113a3426cdb24e03b53a67024e331ba17490b3db06153a4ff097f1ec32035ee3f066fce1787e2553d690e0dd2f36613d093f4e2903bd3187c1eb7397dd1c905aaa48f548a9770d898075d1ae3bfb0b6238fd14379fe1e0839a41187e8f55a283f6c6a04c497b0cf9e311f5af204fb98ba3621909b0368078924673bc11d69a458fff3fb9153c1f76442356c1d8c63252276fbe38b8909128e8102b4fec50dfe26deafc396b510c85159e9e2ad2e6f969e32488583f6ade1b3769e385d4bd3c9382c30d686c24737ac93b8d98898ba03527d1c49d69684f45729a20e9780ba5f957d21c7d485936260299e01bb80f21de731438560758bc14789cdd4c1550b851c2ccdb070ec6dbe7f7c17c1241a6e22cb6dd30991ad7907541f29c50882840f19ee902b31940005b21dd07d2f8e25f981dbbeec12d26726664c6d3e31bd9876c0f3b3fa33eb0c771c69ac30216a58cc3faf3383693ea79840f688ef4d333fd7684fc862bf0baa91471afe7e483910b8108e8e72dc24914faa5bde622f7c2f591d3642c243f0585bb55351416cf8460a36263abd1bfab2d82a7b696c71adffa33fb74bbd648436b16afa3f2d75ae14d82cb7f496e8a640d034af2c7e5b846451b614760ba50ef8f649e4836f3f3df0ed70b9bc1d2b18e61b1b220f19c90133c56c37f8d472714541ce0fc0cbbe78058a7667b1aa6ef98a3fceafa98619d4b3b9ef7ff300c69a89ad6e6ceebc45725d5133efe9baadeef69223f17345f42adcbd2bbabb5093096003da04ba50b7446928ec24ae76c7775723cb063f025f6008f1596b0240f2e10ac77501ab67154f697f593efafe8416b2b7643ac37a91e931deff1f04d967f29bcc32266660aa53d334311564ffc1635e272fb3114e51a36ed782f3df23bf22889c2e24f8a1e87c7138d57870ba1d1dee185475751a37a7704d9dee427dfa574247094f99b3814e4201c4271b7ef12d508319ed52b019b262bccd495f5626bace9b03ba9786c00180a0d29b700441fbba9345ab50b8d7399abdce593eeb6f6f3ecb370fd0621e84b4b7f96d256a7a22fbfa8e6575fa83d2a27b82d555e679fea7a5612f95e5eee46adc95ceabb94548f314f8ee0e05da9fd585f764312992caa62e70bfc840a68f40414f8b4f566b5bf1e03a7df7c289e5db2a1610653d5d9a7d5c118c892d1fa20a6c50b0817fbd885bceb788d41392eae6b530902a3dc94d38d9d4a2b1482a002a222b356ffdf70d2e58bd0b463e007e179ef7ff2aff18d386327fde7fab24864c0bed2501e964f1b73ef60cef0a87a3cd1fdae42840922b3bc4ab88d7c774478522d8614fe21086cc0f62aefa03a78c90044184be98dc68e3eb9c8264698eccde58cb30e58494d1b7ab76021955109cc78ed91770589b1a26cf0e33c9df5df86d4c50b5d19da7921b7a7182b8a78704dc42448c5457d0045c760f8fb3f2eb91ffc99e5b62b5f51063bd6f7611c12696bacb21a78a8213b7ed92d71404b38b539b4ff9ea22762bd30a0ce53a787273670580f838135f0db4f9fc3079ad10d33dbc530910b55c863c6e01d619c58e8c46de984cbc78179a9550432eff084f6a0d65ab32756dc186e3fd832876bb8a3cdfaa92492edcac61615c89cfbcc1dd0012104ae7f25e7f0361635b239ec72ecb40a855f55406743d56c4f625c152d0f080763259cc2bd6f572faadfdb3ffefa2cef079e02a2cf61533ee8fddd463870519e37f6c6aba66c5e7e7e64f500ed746b0f77f980308ddf03deaf3134064c275fc2f0c5d33e61c1a0d57c1c076863d68d477546207b276ce1f056b53271f9f75f049c4338422a54aeb3834a700de011ee775341a4d6f04943a2113a1351ff46d61be4db8d4cb60e4ebe7a15097cf792a0c3581f890716566d5296aacc3e1b1662675f4c69957ad2ab0090051b956147e70e8d475030ddc450bfaa79a106eae939e4be85438815bd11a1fd765e6531612394c171e4b2902750120eea2155bfb62a99d096aa22acb4ac4a7011124ad8a169f00c6c0b280bfeb80bde57b26b3f35818f1158edb3205af0cc21a209454a11a6c2ddeb197d6dc96665b1b0d0c6e66fc0f0bbe105872275b08ac69b04dda09b7d920a8b74b5315ca32d625d007f9059b533d7db9e03219eb34c9b220881e937726be73049474b690b28500f398486dd6dfe00376ca1cf5fbe1fdb6cceda118b67afa731cf0b72c6cf68a414e8f500b8d9d6b7b584bf269611a0998f7e1e67a537731015824940db6ff547a84467cb44a33b5e67e741c2be061a17b21f9480a2abe0b4e0197aeffab8af6c48051fa66a53140ea6823dcfc7a8e1aead3f72e3a43b9c7859398c147882ce222852857cb3f858e7d7aac4aedd5adaa3067167a29eeafbff2d31ffb3e02e84efdcc9e1749d2b32f0a6a229269949076a2de3a7a56247d534fc3c2c4e024880d806a38482a4f68a3b561170c601263d0f98710faf35c502204817d7a187dff9748211224a5142ca6587c8111a970f730f82c17f40514a71802411611c7022017e018317ce92d303c32b737603c484aabc0b064412d183c538c8bd965d21bae51225d5cf2fe393669c2893c8b6c71ce63f9b20a94a87833b5e4a2a44765bfa91dda2c873910b98a567f9da796355cd81a657cd388895f05204bca0ed0b3f988720e221d9d214e52825b715190c1cc553ef1afac53b4e95262e47e519068214861dce5c3d45b8e840a0be66b37610a969c71db53cf7e89c00b31f1e7f5bbf2a7628fe3b5ae5469f5c0b7e039268ad99aea58a872b749d0c82ca6dea29d7796b9650b2799a151067610f7ff875bfdba204a2657e736de0e7db60a2b874783ae27eb3f7918e4026b4339b9798730dcd6700e274e29fb348b889f0fe5d20611f8b5e75e010f23e9dbabb70284e9561a4ca64e183c3cb729b090bcf7e7ba7d6c67df123b248c8a508bfbe386a9c8982e02c2cc541fdabcf3e8dcf172def6ff252de5b3ceec57a2d3955a2f277e3935506b3ce6276ad6cb8d69820370ff4cf6968d65608cc8a95946efca4b55e09c054d84569617d5e949b824610e1f1573b6f6dca2d451dcdb4ea519773e7a8cb05e962b363eb727f0c7993cdfe806191e3416de6de783baae47593361547cfefaeffdcde215b523e4e9c60f34b58c8504384c2743d4a7a938de6b73dd239a49c6acb3c96fe03e0d827b0a7cc6092e647ad722fd53bdc88a5e0812df0de26bc1169179e06a3ce68409025e41dd70abd47f0e0aab7850bd41d5ddc0b23ff1486efe502cf5b8cd019b9ab1474614a05e6684e53c6bd6334fbeed0fc10edd2026a3d625a6ff43dbd87517d937d9b2385afabc592806e8e2182ff2319fb1a1db148ed60c675cd45a0462deb2b99a991e99869fb3400788c2bed0cafa7dd4c527a110cc46f41ec4b55a9995a541461aee8e9ccc22edd4c1f52002b664f723d23ea288ff3b37913b4fb904456db7dc0223163ccd95d8bbd771189f07afb551feb944c488ec1d55ac557923c17da8e590b93dd4a06f402e09040fc9996844a5a0d8ec66c2d4af84914433bce1d2f99ff30cc367ae248edad6283a99f7f6e69df139e2766785089aca48fdc6a8f64c7a3fa7a3c7d56dbdf1cd236a6a343fa1145b9536293dd0850ffe707c31c29561bbd206d1a54435847534e4f3786ce0803e79729ee4bd7cfec7c4a1ab7d551357d9ac3ce2a4713c7a227b8652e78c251725750b5dfaead13ed33cab5d1082339911a32849d907d875ac1a1ceccb50c1eff4f3f1895d4b023a6d6b8373779c444bc0b108a1d95826f07eb3ffc8a4b4001db845ab885ca00d59cc1898df23907e068d4f8480800b054500d814a5bc0d055c6ae09689f6a83842894c3b7b7b38a6b4835251c0263c59771ac25a59c2aa1911a1427ab5814d4bc59c74bfe860438ce5154f33b2c6d8abe1a91b273bdd8413a11b96664c64551b58bfdc93dd0777e78cd3850e9a63c456882cac29856230d2b3eb91a3751def2c31920c097924b9e44cb39f31eea5e3a5cb2e0f083e89a28315d98dcf1d939e9c7763208fcdd43c270f174dcd38311e025f880adc58f4090ab8695b4ef419bd194bac5226ad7935a10cb45557676e6dbbbf92864540f38cf55e9c778ec2d36ffeef0547786240f4d1b60f757bda66d5fb7c37c2a93f6182ecd4183edceda9f4b89449cb671f40872c47f1d7f9e5ac3a69aa7b1cfa86bbd3e8bc90e490a009976623284423d95588ecddcea34496cb5b4225253265d8355a6ae8d5c80b77b2fa16251fc527e3b3e2674f637156315431b97902d4402af6f7d5c619f1b1a2c0372cc713119b9e1012947960f97feac97291add9f0318e209fb4711ed39c4f91515cc86b3e612e53e41734cdf6e35037fb39d56eb5907636c2d850a44912d4ead76dd0e7c114dc940c3e77bf7be6531553912d499bf77d5c145c716133cf6c8546045c97da43a76267da99f7edfe3d0c6b31864ab0e0f9b58397f2105cef8e6585065a81e64568365d1ac9a2da2734c3363d68c0223d34490964e3d9c48ce20cd433a21778f7b3dbed0634cdbafca82b0837816ae0a9222bcde63eac364371fd9811082190facea8bf66fa2a04e11dbce5cffb5ca36e229e9bab3a096d32267164bec3c672cc473b01dc43de8b613177f7323f44c7688b517c909c7bc0cf4ec64cf61079c627fbfd90f8c3aea95ac93e7499bd587533647c04f9087a857b7e1c57ce59e037c551c4cc414ae5f75228b70eeb9b651b812b9a62663bb0839186d71c5c536896c8e69481004044413916f74fabe9ac37a2d11afc3cd8e7174acfca43018e20f22ddc540dac93fb5c8d7860297e2a89b4b1ef9ab2c47367c57fe17fcbc3e78db839f0009898c904f6ac8de0d8d5ff4fc0c145650262604d2494570a0ec8ed2264da3cc4ede0b469a26730ec04c362c40b0bd894210facecb55396209b64a9be92a9879aad7ae3d7d62f0dce97ca9ba4035f6c28ecf7ab5afee4c02fc8bbb10685525e649846d11e3c0919525883fb86f2dc9195f3c287888773ad0a51d29037a1286856992028702cd96084446b547493c52e4d06d0064dd2388100e3cd2da0efb62fc30401179f2adb9b82c3a3f5b9fd1a1c6a26157705fca83051cf53b1236f85af497a80638c250b2d9c71995634d9d80b3b797035eeaffb476a8529e5806d20aa28db2872da8697dc7227a30d2b63cb38cc37bbac10b2a5ed85e10edb5f374e28f8b34bbb19812fde4ec1832f0d9d25797026eb20fb81dac722283c33959a4c98d6904722657f9ff9702d887ab49566a2988a1a7d26932b0c019e44804d26d2a64017e0847394b05d736d6adb29d0c3b3e4109544a94ff267d96c832ae37516e5e55fda8ad53b06ce0d58e0f04ebfc0a94a9907762893e54bdb9f4e5dd2691a2bad243024e2142f46e77fa3928a0f956f64d86ea734047bee410d6f7fb69ba50dae94db07addc31fe6c112c7e6678f68bfaf69a8d2ca26683579407d4d912fbd6dad468bb4f6354d6d5caf20db52255a3516492b7e4dd0386708c4aed183ed2e748aa9416831b699e73322f1c12467873d35b343feff5c4b76fa8c50505dba15a60218735bbd0212ddcdaba91c355347f326f157612314790692f1ae5bf0fcc83859bc41596712b25fa91eecfe04c5b8510de55a781f3d97e2c44bfda03427805f7d74eb408ea00da14d41acf790915d341807c421867aed442fee5cd7cd50381df27205b93dc3f67a24f4e407088a0a21d7ac9586d0647669768525b11fe6e851078228418c4b55184042d117492e5a141c12ce6a70a11350937e8540b6f56580719820e51e6b6e2263ffa58f37589851c346f30b96f8bf2adff7848fd10049f3f5ebd08e0f42a41749720ffd4093612e236344aaf28f5275b7004d46c25c5515e999cfebc032620033fe40ae7c4f14afd7c0e3b08cb940e37512fd1b246627105e526f008bd9d0524095ed7d355cf990e249d8392538d3f561754872cd9daca1f7dfae885350beb8fd0db5dc059f167b52f07cb1effaf75500535edc1358a6f527a7a9fe3eb25dd87ad096ab1a728cdf4c4aeed32e48cdbc2c76d58d74b0c4033f69b02f462e1d92c365140c105ad3dbc9875c9438425c6a6da6a94a88f7923ea06698df3d14e177ba7642e7d060ab3309dc8dfe072e5905a8389bb2639f5ccf6129aa7fb464e6a551ad2e2cc2f46fe950db3217fa6a41f28b0df9d993bfebc7a05cd163e84e391c9887203e9b729b517f268c487e996d8f2fc2a0003f4c629f790d7802554a151d1d33cefaebae4d036b7eba9be3df091072c81b1649981cf00abbeb06da5c116b2f742add27948034c7057f3ab1954e494d73a4b9c4ea4051ffe37bd2b7b0ad38538b84fd7c6441df54ecb2c21b5f104951b26d37a9e1c4943dc8530c468c2777007bb77dd14af2c0905fe358833d09fbcf4173f6d9ec705198311da0cc63ebea22226088a317859ec553475e40d73341dead2b755f91f3861736d8c14d5b0e75bffbc55c99b83afe2bebea40575950bb4f450376d173f7133b959cb9ebb51ac108421fdf5efc44a097d7599469c83a223d70cee130219f2d76f4ad0d06e94f8bb3e1829c9be52066c904da8797337a0178159b2b01ae26cc9728a4414c3bac29bf739f8903a91bcdd0c005aebc49c7dd5f933dd23663cb29c5eea1ac7aa091cc0513207e3418e4258df31455df6408b7e31bab55dbd4e92c835126184916e58eb48eb9d5783464c99423c5851d5fba228c969a31a7cdbb2324e16a03954b3a8d08ca933ce923193b67df89a31889773f449a8354f77f7a0551cdc6bbd049b7776ec685049f7eb1d7a9b75206bb00fa771bcc91b6526f1fc39d66fd33f79da3ed0a02791dcd3b5ce2dce697940a2b0ab61e7af602ef01fa897c03b9460387db0814423839deceea474d5409a3768e00f457b98e07a815b11277bff12a0f15ef336c9ec3cc15c837881bc1b796b92a844bd49d835e7d7b21787b572f8622996f97ac9cee67b81418f31409e692dcc1daf555a98b9d07b6815f134a15ac9bbdb6c404b67597aca9f9282538ed0b4a715cff466a74cd947ae05418b802f1cd5fd61b4afd607b83ce63a0c2563c3848d274b989e0e1ffbac1a2914b5b7cda622edba20eb0673a117a2b4c69795a8e4f25f95973790b6582e8dfad108d8128bdb4543fc4086bf6ce99d82e99597e896f88a0b0ccd9a85b0ab595e2c52c742273211cb77e79a0a2836ba39755ff44655ae38cda6d42a94665f6d0f814296977b8384eb2b97ff8bdc9b483e46850e0988332492ca11f3d5205c96b2b9140c1f42e78df1bd146e1aec318e0e031084cd21b50b3e436b3cfb5473830a602f8644cc209aa4c2f4e60788c4a890083b1fdb58c30e512337af9c59b7dfd2764d36447f328133e5ad8181f1709b1dd279abe970a23fac4cd30b58563fdf8c65bb71fb99be89a98f6fa46c2c01220f41f89e54fbae841cb8da4ea6e9ff49f34b47048f906467eaf7d1d0989ab7fe960f12a1270b19e1324f62ea134f930956e5b2fec143761d294401c320a79b9870d3271d172ff24b433dfecb8d916c54d98cb072a9aa93307bd9d2139f9316aac666422b88af4dddd3ce84988e423d09334b19862dc64af941dc46e75037eb6e2d87adc1085d0170b4b5ba1be0243169af88283462affa9d3a93fd54934beeda00242fbefb24cc08f9571cc5a2933b0ee89f4de7e25ed65b50d803bbffb8f42c177a4ce405b1adceac0e0005af49c701cf7f56701673450efd11a339ffe89363505a02c0d4e9801995bccd289c571777b4f77a7714d17fd138a2d1cad12d79fa1a047c26d551f4b3ffa3b9a834b280e24e190641f66f754db16b66a5904c425cee6e3f2156336f25dee6a3d0f702ba61353fcdc1c42447a38bc6b27ee3c81392d8eb3a9dc625121b404ae6c2e7adc9dcd7743694a991d76380bf3324d174c2b9765fad867ac490419239d70c7b46d879404bdd4aabecfb5d931c7eed44eb2702db94f090ad4f9dc5aa5d297fed7b16c8433d9fd73e9583d7524a2a8153fe480770b0f7180acc11ed20531e0a30de679b064f5a9f20e2d7fd139b489b29cd9819f5748812e8124c958bc6350b03c3288a4cad9a1145cdf8dded8cffbd3cc9db42a104fcc30450a0014bf10bec59fb0984d54be765d960c2dc9f0f4c72cca4dae1131ea63c5512cc0da4b776d32b36f35cb93db72965e95e146790160f53e4d996290885baa4e1599b5cd2c90728e94bf3ef672ce756da2bdc51fd79360f6d3eaa14b9eac55120dab3f5db6e8400c9e4d29615a338b1ecbe3b67d8930196a2b9a7e8d7d81e579be8c6025cd469eace9a20ba028b2d5265e9e77173ddf19a2913f9d5ca05bbf6129740a5d46c63452ee3d4b67b8038714652e7203ae817d01bdcba9dadfd85db78c83bf0d740ae295fef4b30e0fed39af3dfce494d1ba7826d14ef8bdb0dea4903ff2dca8338e893da68867171cf8f7cb1b53cfca5942430fd254b0b02f68cc889608caf49b3b15e2464c13ba4aad6b50c8695c4c0655e944a765e32fd67bbeebbb9de2f8dec81a9b65d771cbd9565fdbe6a9376d964fe8919c971bf97919abb7e784f8f61790b06987d08b781b80f3f3069f371e1b805476319e0adff3bfee274ef057cd08e975f57b449715dd2f6193ba279b8f5158d229295469cae274dd15bd59509f9c0b2f502093b94553fcf381e408ca5d923e67e52214a5abf659d83166fef18de35823437b14aadad5a6c0b896dc15501b7ebe572bb2f0d631d6839789f9097498403c8f5b2c2f3ae524506151363ef6235197acbe4cf973b84fb32974f0d8e70be6ac4272ebb340e1cef8c36a6ce2f8e6b8abaa1f83d68d6544e3d8737fbca35357545a8b5f28e332fc5a15f79e0c3c475b9076656baca61e63c231e5b15d2d09df4470145fe153ce4cda006d664f11679c79bccd46d61daf306af9453c2c7f94fdfb6a32fe9a15eff2c35a0ec539b6f1f548b53fa6157f935eb0ca407948ca959f4c114c506c75c5101c08a2a275a2c5ed035e6ee8a169f961eb00ff64714bd2b282d329b6c7cf6f6876e45ca3bfab882ffd02946a18e6da5d1f82a2329a0e61a6fe94993ccf27d01999800df2bb9899d04c19e2fd6f0891aa8071a874c33eaae55b44be7474312ef18162055b4b776d25e5c84de539f43b50c704003ea4d3e2f4d8325b833faa0a4fd952cf34aaeb140823fb1d285d082d78e62754ffb652b5aff78844ed3594f72dd65f21cd34d6e1998b5671b1e93b3b504c6351c604877a69f743dbb5c9fc2d6c79d0240c90fb1f3b18c9ef8af56981ebc8b8c080feeae6359c63f1c2833b2c9a42850b5547071a37472ca7109f989f4a3b69adfaabcf343c5db9dbea80e3ce0adcb0e46717b4d7e63aa079849a80aea9cc03d55814484d1dfd329154fce6307bd441cb156d05f821f79fc9ad1be06236de021726688bc346905897b9a5410a6adb7e4055a01c34f7751b58cc708574571b278abdb069fbba324567133466a3ce400918ebc11d65e623d903fac30ce616695c5c200b789280eedad202d93e53529fc047bad96e0c7022942c754292101b38700aad1afb7d81fc9ed7920baf12f311b1aafb58b203c14a70264db4ff0cf4a63f2d60545ff6ec6f6734835b401512103bae935edf8dedc3276f5b4e92025a47e7c946120a773ae5847da23bc3b9000a20eb4eeb9af6cadb23f04eb12998278769bf9086f129e6ef819d721ce5be676274112e929332fad9f63ce2b3d6a81a4b852ae51fe1850a3d41b583c16f7dbe27d5466a46d620941c3e90250d4eeeac7ce8fc129fa4a43235c1ada15a7c5d91caff44f75aaf5f82441a8b9408bcbe7bb8a128fbde374837f7308a0a45778c613da78a7a89966888b5b97f293131a608e9eda18d5aafee93a3cde14eae441c88de39c2b04f31d8059d170d1ca36778eab3f5634bf1123955048a0031a5e2a6078f9e9d2144cd63c1a048a9524f96ce1552b5c561f6124a211e1268bd562a71637a7b5d3fc41c1ca0f79a8a54b3caa40bf163ab7f4ab36fcbf37b5ec5413fafe2c6efbcb733b5e36f337981c435404279455e62b794ac360b867609aa43101d977c34fe4c8ed243c9b245d472cf5c5c47ef3edfe825306c0863274c1a84a97a2ec95f117fe2d991f03c6351f5c301ed4f5f6c1d7d6bb3c781928d861e108767af20436666a27ad49534ab3b79038bcfcd91e299a656877be6015667734576dbfc508ec6935b163012ce885802268d8043096e705a4a2389a521f42a4179191bf401ad3b8ea1253af375416b0d2a93e5d1db95eeee1850a299e736938911008918b6dd907ef07b32382b3402e53cfa25c966cb1506cb306b3fb8e59d83f6a143a3bd86bb7c2703e13ee8bad1eadf53fa041e1d9abc5a69cbbfe258819a858d3c6bdeb7da73d1005e8fa763ed1851b4ceea6734e7cabb9d05c8b561174ba7a5433a7b3765cb82d10ffbb46200c50cedaef13aef55bf3ffe1adc70b283a0e1685186ef6be78ad312e22546226b47857cf64354832cab1863084ebd18c0196961e2f90e3417209beceb53dd3486c17e9a5e2604afddce548c54ad47911fe34d930047c6b0db80a27cfe44fbe614e35d1b17d87e97d4a430ef34b6052f4f65be126c00662d6b8985248381b3dbf5c9e47e48f616bc38eb8c14fb173e77676ccf943b361f5530cf7bef15fb0dd122fc6555edb5220dbff0e242548127ae26b7af8eb49c8052a8a645394fc83ab6209ff9c159a060d07fc32a0cc41f3a5e390e6e93290679300bc8b0a5143780027f33df708f8f916de4cb464ca642a301a2937f25ad5f566bb5b6e6166e30a82b7fc0dc087f8b4f96aa43fd008cb9e88901ef87113254de5e78db87c3c115e6c3f03bac08141ed5b30657cb39ed6054c507284b764269aadb97fbea7679a81f7dc76a30a1a050ec700b8021ff4f769bea0123894c21008a292ebeaee5feb6b1b7dfd3444290247e43023bd9c7231f9f32be7e94a2e37eb48e23a8d3d8a202aa8b286844124175493b4386a022b92f8695f61bbda6f8243ce9813da59b155d43bb3c1880ecdc6fc9a6910b6d9d46659163e9bcf5f32c281390130a0421f5ebb16247ea403843bda67aeecb8eee90a5ca976cbba1e0485f5f4b532c3b4e49c565650af26c92b7dbfe9f3b81536f5eda116e4441c69525b9a285d4f2e63345f180aad767697438fdbe5f4fc21ced260f15375844e024e5e2556999681f3d19a3058165d3f5bc5603e6dc8721cf7689b21037701e774904d55c43360a9a458ab447b79fd0b2612c853d0f5dee88468c55a3a5fff77e3918d9aa0657dcddcf912fd389299992779d9f88cc4ebb9a3f9fc831d31748e0ee3751a16c1b6481d24792e398a8b3d87ca205dcca11dcb17820188a232cc8d8d8880c5c900f6bdf6d1c37a0ce73687336895bdc6b0aafb610f3ff42dc2750f4dca990ff1cd9058b32b1d791e51dd58ded6343a6fc59e45d4683ce300eeab1166d10d72298e0b7a7ba5c8a912ff4845e450e532728c08dcfbd4a657efcfee2011cd76fd0dca4afcd26c23d76053107f01c049d952b61ce7fdc77c16fdd79c4a8e86f4d78729ef0460e485e22fff05b06124f1cc568479f8489827039f0d6ef50eb67e68af80ec6d2635cf54d84e09ef4a4e0fe40d15f9a3f7f79cd2448f0a81df22e611978cc956bbc6e8cd7c9bec6ce591c6b61f0ddca2888b158bd86ccb5f008b99befac8e2fe46bcf07bbc327e44cc284d5d1aa8a3ce4cdd9cc019be505d8b620a6d0713425b363447ab99b8da0b8a65f51939bd61f0d0409dea49d8b8fa0f5267bbed1131ef4203bfc9ea0b1eea64bfcf353ee1159e2804b6876eef2574dcc77af085d410f62ea7a632d3b294dfe94b84f00b9e6e39728a50cd167be8f760e8e1a09a0ff9a75336009c7c9646bab0971553cd6f5df2ceadea7b53b0c1b6048eafc6ca2c478d0cc5d1acb1e1dd59734907765bd841363ba624a61df1351839ba42a231f5b460900adc6a5b3a7c37c38d1d68846299b79d39b666a4ddd07de96b5b70e15713e5b70b938e8361dfd80920338d000d9e362f752c8beb4d2c46ef7efcb0ca4415baffa59330cb55f6a00253f1b38aeb8b6e6b65c9e7d5b5fa2330c13625e038527d93b3b2993bfa8ca2fac6b309d21e671e03e8628ef612241ebc60a1215590d8354ce0283daa1813cdb4b4a1598249a8cad049a46c0de17bbd93707f8f545dff66c51ff39706f0b9dbb2338a7c62613717d12aa3f493b9c307ade1a94c75c689b8ef155a4186d20170929a34f6762898172dd77baa37b690c2a604fd9074ffe80abbda88d04b14b31cf54fe0449da9a1d7f61e08e5f0ae7539be34843df9997465d07f52791b2d98c1d94ed9a34ccd4852168e1641f59982af6b9f1ce8f343b08e271ddd97431d0c452951e19659b3b445617d816ce0e56b8580f64e7fcaa4e0748d8be8cda167e5495cb14164536e5ee8e4239dbecd46bca529bfab04754077431dc9f88c7d15e805b90a704b438dcb749d3b1df3f284de854f470efade6190709846fc47958a6981dfb9a6a81b92514270ec3996b049f14f8c2de59712708da3d031fa80a91179153423b30816321d87d1ea12cbb39e51a9487579d1a66baae31c35ee65a9536b355bba515da908d73b9b45fbdb15631ffb1bc358a8a8d77a22d3ce71993999f95a4a34a911e3442ac7a264d153273f5faf2061f6f69a576cb04bd9de63e32c67b6814cab4a9b15e17ac82f640ddd5b93c372da295f9efc50c1103534533e209787ad11cc433c861e3e4fdfff64ac7fd68cb6f65011ec46c28c2259b32b269fbda1e50f620beebb4941a4700aedb62bde133c86789c11ffc09c7416c0483e3d3caa036fc6678c95c4ba100e27553b3bee62f12b6330414a49b960a4a5e0e20be091057d84d3cb567a4c8fce08e7acc8d21c0cfad21524f86d5d3077a5aee852ea2ef2901fa2a080a56f53ec7623a5737f5dea13cb59be24a66e14819ee2e912a519da04615343a42f81c11c54705e4697ce3bb2a1c4b77f650cf23b6776ae81813c7129837340c0169f84c54f1d4c3ab43c027646e1008b76be081719f58a2b2c8ffa36f9f004643f2e2d34d326edb71124036131780d5175c2f1d6bf8f7e5994756663bfc4237ebc51d8196b3fae90472f372972f99804d7e2b30e7a4ffb22ec009c9634f2356562c8eb851ce50c1d2c14f8803c1064f7205f5704f64d9612f32d5b9c8cfdd977c4df87a1563366f8f5837bda445c0039a4abfa8760906dec8c7ce7fbd176d9993f2f740cca99e39620869a39689d258a2268d218633d6215749a1bb1789b5f9dda650a965304e47dfcfaa57ff53ef86df5249f25294d952728d3335ddf254b3605cebd6e8e8bd3de0a07e07584","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
