<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9487160abaf33cc0e0cc803a1671b51ed2cf4278464b3fdd19a70ceffc081f510fa45e889ece112b8dd9474508f63469bf40adaefde145fa5e0e5dfcc7f7ba8b02a384fc474a72df22d3ab77eb9b46d75d97dc5b0d178accafe4881f185f53e234788cf87813f95e517675676352761d42c27ff051d2fc6d4be70b2cebd832be181c6e08067c053f38001141bc22ba2654baa41392b5741666032db39c9964edbcecad1a5e3947b3c624b5e747eb247e4890889a709233d99ae08115ef378dd5e25152c8c69fafeb839fba5c36d88cc7159706af99763a809b0a6d599fea011d8ec041805c38f74d2b8b0a05c2e9cf3105cd65cd2da55991b21980bd479fd763273734d06fd82bfdcbc6e6132206a66159a88dee90c8275b73f0357f165f3a1ae060623ebe0ac2015b6df53f878fe8639f7de53c85717aa4209fc117c92103583cc9141a718135f545958e0f9e95dab13467f2e89cd5a17c09a407f133cde2d408a445d5da32496dae0e1b6195e4888c7127879e60cfde8202d31f3d83555a4b76b8f86de77a46700446c5c1b5f7d8273c7bf9088ca55e1308333c9efbe628df6a38b97c8746e6da3884df2f6ea9bc333daba49a35fce3b6337bb1d2c2f409789d292fcab9a6eb822655c83bf55b66f5b1e035beb5198583fa5794fad1d27cc9446846337072604b5304deda31b956028af68c049f0e3141b3b163cde7e4cbffc27de40df01379fb695df85f71db0f122e088d28b25bee5fa3fbbd5444700f79aef799435dc3757bff4790e117b158428d2035ed2b6c6f361a544783e670bfe1c36c93b78c3f0ce574f651f30c2fcfcc3d5488d7e8a09a7296af0e3a48b961e20514268757a4e385ccc4c64d670cf7070a1a79c79e7723c852a13961b61e17dd0d59293d21ad74faa46de941b8f600743869e0192adbc7ff09e6a3e702d27b9d3f8c5bff961f1a47607be4d56ab8b3be387881c89b6f42883f6fe82f57d5aa9f94b88a14a897f99f2bc0b6f80c6e4b912f51406e7010b99cfc64421930491bb80b313c3b6af3494882972a915cdf93c7603aded47f81bba2f85dfec37cc535fed10cf482ab6b4337b8414a84de3635d7648fd575288450b40ddd5f13c45992b50bfb06c88f908265ff24d8e3865649b691298b2d27743c128aaa8c38f93f7903ded59e538f7917c96a3fbe8d39c12e672b76ccf13c501a05422f2156b94390f59d6085b80645a2154da50af5c4633f1ad73ab0dc5345d2b417ce940443834de78ae2deb70cc1d8de8029d985a2235d5a60851d25af80172cf8fa52b50357012eaa1786204df31908692c19e704cb8fcc5b48b7a5a8b40a41d1f15b04d4e2f0c12aed4e71a51f22263f8078f617f80a3f56eb5ebb08b2131c31d348271d8cca95b3f81498ffe82bca073ce0beb258a0b9708d9045fcea210b082f0fd30596853daa744abba60ef904c61d0eaeccaa889369085b4bb66aa5319baf137d6a666d54493a2b79d12b646a70a99ed57912bb0b0faa1a8087ce564e0044da79bdca9dc5bff156e773ee664169da35a923c18e2c67b3ab86743b0b7a9f4511ab516e3349625fb1b87f632f8ad2c9b33ccd57b31b5df73330dd856d3a36f964418842a75d4e97ec83ed96e5ea69a355ca021564d4f87b14286d84e004bd279c4131e6e780286102d24128558d79fe9fb181823d42005fabc1f60b01bd70e2f587ba360abdfcdf302384860e163be6a01dda6f03bd1b855b00667b54377dc07595c3b5ca902c86d66e3ccc3b1dfb7513e38f90bd824033268f4f6bea84a2b6442959ea6f1b0b501d136e1c367c25e92fa5619c86e75776261a981f1f97ae82316fb1f6b393d424e79df95b41fcffa094bb70140eddd89075140ba0d43be75f40db8d30d21a2376fed166fea4e63c6ce8497f7d2f83cd9fb9c85db194ea76fa75ac7c95ee956f82a1ff90968975dda76c62b430a8a35dcc280ef125161cffeeae15d3f2871f3a6c247af81981dcc50d31172ee5eac5992d0e01591f8c1310c64799d039b4f0188bebeb6569120cf34bdefcd27a152aec902c7b08dc6c3f978d98974169a1eb2519965e95be25b67a113c51e1f8d07b54aa8e09377823fea1c6246d52423d64eb538b21655f2ac0b888aa5cf2f7b056fa92d6cb7218bd9ea7a29d854116096b951567ded211aaa3bb9c9f2b1c5f0a9e177c5046c6805b8e5880f46608c04c6c7c183f56d228150c778c0bf2457bdee01f3d9e985bfadfc081d86bbf2cb57cf26f0db3682b45d812f1d6037182eeaf10d4cca439204a5b43e47e94c0b27313f9cd867a776e2d89b1fb3e514cd1744815c378b2671a531351604bf57f1578e9554c4921b55ee5485b79ec6bfa2ac7f5781ec8ac8ab668f606904eea7bed526c7a25eb39a1d6ebe90770cd4755ebbe5481bad185c6221ad56f0d0aeff4ac5e12f23cb4368e6e446b7efc7601687df910226dbb0de9c632411970fb5b3a0bbed4c8163fd78502469845c8660ed7608858213b3a7672bf6cac3be112ad58bbc5b332a1d150c0de3f412cfd7835382020c90346bddbce94e5180eecb70dee5a9d36ed429b1abc452ed6d6ba60e840060edd1e959c32e8e41a73368f4f7b4aa554ef60abead35082f095103752e7f4579ab9bf55e511fc4ea052b1fdd2c2da2f49af67ed3d54a30c730186bcc282019fc7cf86f091d401c841be3bd7410576764512faad687f6d4d41f61a5f4b5b31f903b9409fe018bbc5a3509a63105b70a11fb497d6a0f751e4ff411b9442b75450e611ca64c91dc6db81bf9bc3f649268269c083bd2da67079fccae51b674e1c49edda4f8005d6d4a3e0d398ee6e14ffee340cc28191e7d6263444f801f5609bc979cca8f16bbe535b608394f2616172f34032fc597e951441e4d68a642128fecbda28c33c32ee5ad94704bde4e917c8ce47cf7ce0229a38e0392898561ddf792b9e53f9a1c8df6cdcf7b457f786e361175f6e9ccd48e37a544a9d9e2aa0010c761a87d55864823f19dfd91c22488b97d40d6f71d789af30ab99a485b42f669f1741bf1aad957e5a74e5c85d520bbbe6bdbd9a780ac7da4cf8a51aee8455cc5727872942fafcb562373158fc4f50ba8968cf20f91fb7ed84ef92ae14427fb5330402f89d6871c1e1e1ef69d126f7852eea8710aa05947c2fc801b9dfe124015e3c523656855167c5ba298a985310c167b2ae4ffcb81783d573117377fb13e6bd378dbcfe8458ecd0bd0b29de1f1425963b62ce57224d62c58a540d15ba98f1ebe1f336c98a53d6d16422bbffc5691c8afdc495674f3b033b8a9b560d9c4de8abf31fdb7865a0b231ffa4632dc6a2afa3308c963207f59620f3b980f38fe284662d3699129f7f4cc944fc13b49e80e899eb1e08b9c082ba8e1e0da278579e4fce37f8dfae49757e3b50820e30d713318b6315bd84a130e2ecdb2bf6e6d0386e6c205c043b3bc13fb5e93e063bb3d0ba50cb5babdc65a0bbe092ca8c0136fa2e7ceba80a275c115d9fbb5f879ef57baefa783ecff2ce1fe2447753cff05ccb1e35ff51081efdf8032f30a9d200298ea756d3d3f91f88e038d1f1b0f275348ee773887e65b049de1945589ce86ea4c9f17e9ce773e4b61181b6dcbd7d920b266d3e020444f90100c970efe12c8942d7e0c5e17a0af690dc97068d86d5f0275684e4cbe3e78ce561600593831f30f38d1fec0ea8f986701790289793ba281dc4f9549f876b48e337c64209cdbfd8e159f9d1e9434f10e55fb422c8fd73abb197de7a976da86045e35cea7ccf84617d2248da5822fe3ecee441594bc450e19ea09ccfc45aace4b038afefa75da4ba183152bc3b7bc8e257e66b6fcf6b498df630375a5c5a97305da25e7d96221c32faf55cd588997cfd544b0863fe132dc6b190a7a95f71540cb83b9e61d63a9db6965712e8d16e097545d5d793f4a47957c1e838293e837b7e355a510bf288c4342b218a3ef8da5aacaee6111b6199d93bfc44a49a4fed521aaad841dcdb80045f97610d69a68c7399b5c0114c93ca365b43271a5d8bef01d6d3c3eaf5d4410a60986621fe0868cfe5fce6451a102910ff743207b3bcdca62a7a69c69d893c89578f282efae8c7d3d112106b498bce51672a252446d9915ca804ce9425b12580dc7df4c4aba34c61350dfce6ca4b9d431a3a54151cfc91a1330d4ff4ba80766c37f6ccc949da8e9946281841ee8977ebcbfc30e5ef10191bbda53ffacbc91c568a803d195c9085f63aa5d5ebea8112a2decb5189a6d6e94d8a1f657e659baad5c8df1b756babfac2ced99957fc4b08b766f729f9d171c9cd904e1a929a2b9279879ebd7b82ab80388e5567a3d4959dec90e31db455237d216edbff4be1564b98a79290864263d77798109f9a9b99e11d6b5c8cd920b5ca9e6180d87f5a73975d9221ef3197564ec2c80b92031bfef5303c37aae27fbb9af08d7bfb4bafedeb1b413966e022ac8b36de2f174e3e1eb6048046efb3eb943462edb090c1aebac775829b3bd8cae6eeeedbaa3810ef1884b264ae610772a6f0732406883b1a19c51eafa4b10ae13ce2b3a415a6d1a9af080813e8d896e8f4dfc40f2cc6aaf706309466c961ce18501668991d84881c17972f8c84c71804ddade81c7e0894e54aae2d58c258a1a5495a7f8ef50eeb3a70998ee1aa3f00c5c977dd48b6ade7c042dd7b3330439d653ea34e7b1115145be31693c14d344b5c80ec2bbdcfe70ac93f1b3ff425cd9cd7e33f3bdeb97c021b2a1bb90a7ad12444f334eaacce03387918e1608ab09c9077c2f85f5d5e5c3b119f3ec68cf0d24a9677416ae21a9e839e95964924a4b9d4a8b9056b665dfe03660ce0cfa340c4c8ddcb373fc97f6f2ea8b646256fc58823f7dcfa28501f0f9a74949db5c914d171c26065e21e248d85f867391f0bb701a722372026a02123d9563a920c48db0dddfff76c8c65af1fa5be54f15b44a80e35ef544d156769fee0f82ae3d9710030b7b9bb078f3b2881444c25ce35a9e02faf93d7527f0219dab764beabb41815f4c6c4ff1261923bc152aadda2c361e8273bf8da12c5c5d78247f9d335f9982aadb603626fcb88d113f5824f2b626656a55115061c81c7d22b5dd9833e012b1c545b293b1903c277b29fa2b568547ee42c0d7133632abdd53e4f574af85eb7f9c442647c5c7cec02915303e4cc0cbe030ae1b460b4186a2f5615d6c909396b12755c5dc70515b2eab1f4be62b797048c8b0d5f2523c3d7531387784121aebf59e2babf50121000d3ffb05f6159df732a0aa87f725de4624b5c0e1547255d28634b2aa492616849bad791d91b8d41237836361d81abea5c4d677efc36f00c3186636ec20009f9e82f4b524f22e8dc3d98ae5674981a6c1cdd5127ea97f4ca3c908fbc3f6630c4cfbbc733d1122e483e1bad421cdba3306c87c71091b2acc0178e64f4a7bfdc384e14fba869c9bbc1e8fa80d15342a41106b638dde71c0993336e8057906f61dd359cdcec4293bf1863ae505d0ecd566f28b13437d51479cef9ba8cf27acb62c59fdf75ae989c9a92fb66dfdfd94d8213811279952580a732adc16f2016f5bc3f0f0bb11456af6dd9974da49bfd0f3b628266c3e5bbc602676d9f7f6be494e82b9e83062fc8eb98d41f490eb978f28763b5b8b9d68f2d2ae0a60a54d514abad82d247e52f7f07c51ee2365ebace3a256134b48a422f1be3ec88ba67bb62b2d38549cdce330db837b8e26372dbbad115da6fb1a7deabfa27f58b3964edfbdb4630bf3ab8d5da263fcf9c50b036419e32cda156a731ecdfa36dca572d1ea547ae36562ecb96a54f69c9d5f3e8b2654a0a2b2dddcaf9dc875dcaba8171930d08c80c24d629390654cd33b0b6ef9096cb768304c3bfcad5d02c540db702f0eb0aa38a0c76d28f23a4b2852a2e482d8aacf2ddf6bf6d9dabe180e5d325778c71d6907e1bbeff43ffec39fd69fe4de80264b593fdd61745369f814fc2dc78c083e1d2039ce398c97f2042883abf30e79075c3d95dc67f90a55ea686465147b034ec676069a61f1a0cdfe5c1270289d9d323839a87041415ff0d7d5865b3bf399f5d05d49a190cefaf437b9434a4debaaabef0b2b326f9889170c5cd92a17add1396e85b561e525a69d8db10742fd5000327effe00562fd5e61db938c6115727782c591b5b4a41b017849535c2437fe3b2d9216ab41c67855b6907fad56b2bfde2c42b477a630e54f179664c70f3265242427e6885bca447679ea5fe732946432df2d1fc108a047bc0cdba1f1b7a1d1319c8bc2b627d59cd39773fa6e18971fb6d0f6f889eb7ad531a04368098beab94133179d03a5e25ac7e97faad15b9f9cc2bda4fc135ea55e8803a01cf37069edd22d88139c2b953149153f0431730ec999cf549cf5806ce880e24452dffff6955fff3c060a003666979ef98159848cf85996964c1243cf2a63f11e8b1ab2f9285de9c27dcb652543f4516fd1888f22cc3c14da4b788f2785332a796419a7b98d7ea762f28e2549b553b0960694746df8952f59f1fdc50ba38b0e470e1a0db2afe296396dc01ca260f63be3cafc1aba6a976fd246597dd5dd2ab8b4bcf075519b44a2e553abf199df69078c624bb939f1bacfdebe7cebc617640f15651dd1f3eb259a8d8e0cddbce021334567d0988e315b50887681090893b75f109da27642153d1163b2adb8048d32bab3584591be66f94b1085024b0d66225f2e928dcae9ba100ecabc00f96840f7e0919899a1b39e3ec3b96433f022fd54f7e2eaf758ef61c09fdd7216839fe13ecf5eca88663295ba2a19fe2bfb2b2105feed07287e83e889c8b6c6d9f5fe46d97515119e34eb87a681d7774598c8bbb747e197fdb34c6710683d32760150a2e2a424083aec5ef9cf8e2e23d7dfd8b4d19a72853f208443f847566b0f2587962ed1c8630c5cf586036e7a5c403bae7d64a7029892b97cd05ea3b97e114c3f83a8421682af4604b3492aa9f39dfa4c3cdb3f380025c0626b2aad3b335a2eb9ba0e33d285dcc19f16154730f91aafd478800006f471678180c59476437aced6de47b54cf2d2ffca0fbbf4ad32b4157e669c1f79000ff0c5853408e4da8271770b755bba8a45b62da3cd460b1db4545e73600116b09230ecb6faae42fa5ea9844a7878c122e839ce5f2ef8029477405fab69cb7206db308143b7efa5b2bf30ba2a893b496677054febbb0f319d87cb573ae8897299d16bf3252700c78e89bb375b0a7fbcdd7ed41b1405eb8304dbdc297f07e74739d2a4aaf86a4ae15432387f2f116cc81bd00424bfc61b3b9505e73528d7bfa3a991c3258397daac756efe2e07fbbd6a7656443022a9a7e3f7e166c1f41944d0f82d705b92c968fde1f857a32ee77ae773ed403ca58cc542e8e5be9bb6c2b81bb90561da5ea9f28dd932ef6e87bf95bf2c8101a79221a0b1cf99723c6258262b4a2d333962dd059872cf79a8280a4bd79b04f9e8e142ee61558eca3f136ae6b5015770e67def22501fb2920b35a00096f7735920cb7ff85d8b21c93b5dfdcd6e2adbaa08bccee715f14b46adf5697772dd0e0dbf735ccf9d80a4e8cb7f6dcb0e0745e7f7783e77b329b3ccae3d1739b505c44c218ab30a8b18be00ad7d153d491658cf6492da80ba05ed4d71f475482ff652125010f97319d9086d47555c6c1a016f5112b1c7061b54b68418af59339d662ccdd1c8ba9c0259cba7a58a280ae6470e1888719984c2324b856bcd19262a4aed65527e3838338f065f8eceed9d7fc267def4dd6a056fe80989d2ac31e8bd37308ac1c90344df783068ad6f13a47a90c36413a59e43552632ffb4c05f33544ef55513e9633c41e83dc98f0563d5fccf01fa00cb9d501a4f67875feb11a78093a681d72475e6b38b0fb441720509078014297f9842206e105ed51e65c6ffa94adf85eb071d0a3915f55ad2122b4c379d44e00ad3978390d32f71aa533c023381c09e0dbf83945affff2245c964a178ddd423f3f37c3ee1e172d7b56da615e96b56b450ef98f7960144098c70240658fa3bf86f422692597bd5905718713b676e30c6d92edd92f3712fc5ef4eea141206a03cb638d819238acb4353f7bec1911f9dcf1c204417a56f962e60207b4a3c626bb0891c5f65dd7dcc7ae626f52a5ef8cb999f010761763a84c8efe372e20317114b681b7ea1347bbf9151f97dc2de479e0fe0b9e780576818daab7ae74abecf439a9f119a229aaa246c7e415867e7223210e4d5197b3ced77501fee08f2b4166afab90ef8e6827b3b175e4920d75d5269e45bde87d5985e10c5b3688901ab23494d77d5acda9de2c951591cbc1595d71c12387d4133ca94a80ad0bb763413910c7aeff1122728545a272c31d39b08e3c8858d217e53f1238aaee84c3e6f2a18e06db7094e17b4170522ab6ebe0d4b8a0d7e881a74fd16a921df7d17bc07fdab08760412b8d39c028d8d6b2fae898a677edc7233b50f41112435f2c0e9961a39a6019dc4c525bc47d4b8abcbeab876154f2694ae35d1a9dad13961fda6cf5c33d8780174895b00cb462c1243abcccec89ee436d9899bd28805aeb19c70fdfaf2dc2271fe34c2b39f225ac476b4eaebb550ea5ec34e7b9dd12ee9da43c16d671b3e0c8cc4d9472b6993cec7f5433a248c93b68f753e99ca8a28944a956ce4ef9ccb4c419373856869230e534d6505461aa5dc6effdd4cc6e26361eef3796c89da6294aa21148ebc3719fd5ed8cc15340916852bec6f377f3fbd697f770065dba84004caac99e1f294754caa8754f065445a0487e200a0293be7ad83f6a0a8dacf1d8fe17754d5e25a21d793aa349affa98780c376816e87b670ec64f49b2f566d9c89bdc152f03da67ff3331d1a785c99957e389967305fe02e35a463583f963aea43358831205d4d021809ee582ea11b9b06a4b7d2253bec255c6f193405c9d5555f6fdb428133a58e1ea968dba43cd8d5a78141324a4a490c4d45dab34cfa2199e73132e4b722aab5d4f568747d0d560cb92bf8094467e5b6c280fa4a8fb08bf60da0a122c6355749bb4cf62dcdaa6ee2b3def563922c8e58a3717796155df4da9e438b560677e43628f330a1395d407e069047af09e20eb854b969ecc82ead5089964c13bf12ec1695291947f60d7d5cd81aecd96e1acf887e6052cab21813ce99c7151c34a3b087bb7b60dda8a28f087fcc750fcf8b9a707a7c63c56c2a35f52cae4868e00812b4b2477168933b9ccdfe20e05bb0ba190dac139451371639a471d8862a26657a7acc7c83cde68b77e1fba501d9d7173699d040392438af944acb4ad7ddaf5507c9a056177e6db93e54fc6a7dced4dd0be49e5fcbabe6b715bf05f09bbc2dadbd471ec32e91a91719baad2e5d74f035f27eb43a87e8416068da3e3882290b1c1c83ac613e0354d8d26b7cbdfaf5ea7324421149d98f01e78a96bbd1e282945a7618bd5cf3aa5885a610e355866109d259514d91493e3acd8c9afee5107e32c29768ef4acd85e0161f7b625d437336f7ddfdbac4813c45a928aac6eafb1daae4a6673946a0ec1d35e4261b782103959c960ad473dcf2c8ebfbbe5fd16096de776c8facdffa89f3fcd2986ec5cacc51e879bbf0674c2ea01a4d23fe214112144eaa616f06b4c72aecde80de961ff7c3cc31a8302a39b518468a6385942b2cd222ae89651beb487e590fcd3dda5eb27aff34cc2e2daf114740b1f4c18afce6f727c7f78d451522e6b9d32c404fe2118bafd993582c11e3dff7f1deb82887fa430027c46683987731d699f389184d3441f461371201f397bf55ab7d013e66bee10bd947c0d0582fc05ba5ed45ecce6bc223039d0f4c5ad72075561451e76bc771cab5f4184354cfc55b0841cf53f847b33c655723d2008ac214e92fb46783c216c421f5f8402940abf083bf33d58ce946d6458eb903cf4b7715ccff46cc3d16ca788900f639fdbbcbdd7590a98bc7d875b849a2a2a4f8c1b0080181719d30754b17a41822af78ddf713b3c2b84fbc491c5a3bce0297a2cdaed59d0a707e4cc715909fb23983a1b7f540a014a0072587456869ff3dc36f3ab5f80f8528e867e5c86c4d5974b930249fd560657f2ebe90797bfbd4eeaf83c7a3a4dcb91cc1daff575d56fbb1146553856650b27771f851dcde34fefd07ef339218944790b33c5fd4fa978e67f3fdca757ebc8b42d886b9e804261de7934bc2f68c733a5dac9d9b1a05bd29762e649e1dbcc0f431a5aa6ee6a99af0a64bc1607ec80469cbf9d2d721affbbd47415263877c2ca5018334c07ffedafd2ddc0f085b16f0c5a4978c0aa93d9af8fa56122dd278dfac74cb612d7e402a9ab68c4f7d237548f28f7a222c7383f39bfc62b8379ba17ab94a5e7b98f96508350921e3fbaa371309dc0f5f54e4b95e32a00fb53fac01808e0068d5ed1dbc61393234d325c05b570825e8cedf56b04a3851cc92a5df8dc3176005e17028af8e24563fd0bc179974327048be31f1a7af67a98178175dd78f4268ad71e5114752e5c0a6d919c7fabfb4b5fb773feecd50af9bccf07ec466ba7144f02d490a977fcceb808dd931e77fd6c4632f4db318d70adbaad9d524e9db26b6fc2d86072fec8bce0b932dcdae374cfb139a086bf417dc51e46f52969be63f3b9298ed988e8fa1ccc0dbe4074a2e734d36108e502740ae30db11456042e6d2a2ae4bb20b25569ce129924d41d76f0e697ea8a0b6c4b4500aaafd8c9c6b0a974bfd6bc4517065a39f2ce747215e1bd8e1eab7ee2386412fa5b090f9c8a25349f3b7b6775d8ddce5d69f1d611393faea56687c5ab207aaf586c9d08a7ada61519f5ab603d0b72aa10e5ad75e961dcd40a533eed735ed0ea5c0af128717e62f96ae40c1c4d85fb96f222acc65a63fa2a2958ba5a3e45a2f66193533d486dca6b5f959048012ba5b91a4b80cc73926aac3605aa25248d1e49eb5c9319ab69d759961cfea8236b1b451f3c30d41386b9e0823b90f653bb4a972d0ae97ec24d31a3f43b21fd3d2cb48da5c5a4ff213963c534cb98b87f28149d5819b0013ecf4c60795f5eda90bcf625d00ef30b2427150fc0206d10f082a55f6f434f8cc38584d7c29b996e964b0daa41afcb1f15ca89515c609e587ef828f8e874ec4377cc955a75a5b062da48764d816e62607f447cea296636ca79c7f9b49dab80d800bf2ab1c5cc1088d3b20878d6e94a0437028622589205ecef014384743673c58b96873786bb1252906bfcb7f0934a05acd295adabe3532703a0e97a62958411aa9ac5def4ebbbdeb7cc12993d3906e7c91d99409db304e71e0cd8db133987130e64c05528252d6a576b71cf88eaed45d03592dcefadcd1125741bd32317931ea8bf4910c705db1668900f69d896ff54e68dc4bb167ca207a0d70fa08ec7d512939e44e8523a8230c4fcd156a7d19c2a7bf30ef6732758e0c50f3ab5a4ff58941b6e768dbcca66123434750a15c5fda53a0f0046e010fd955369e564801e0074e1a63527c7f6f5eab3ee8395546d5716a262c3120b206656268c40f97829715a213f61b1268d5643164cc478b5947fdd1386a8ae45d23db6de5a40f5d8a491e08d362948e9431e98b4f50cd8a283e6712b452dfe1457c8311fd4e5da4e4bd64b27137e11dc89a0ed96ffadab4e55e8fa7d65e252f40d76bd597ca3876f59102b9c7b4395932e93fa9f1b2890ba8595b51b7fc8e7ebd619486eb16444cd0566d5498728d557f5db48289c687696dfbff56ef5badef64972d774512c8b2e6d99c13aa603c74e313ed8628da3651ae4e2602b9003143be8363152286404aaa8fc9ecb45a6b7b5968fb163fe27ba51e85fa4ebeefa7b552f8827151a284970433151dd6afa066b5ed89c03d2f49d6b52bf98ebeabd2e4c58923210027df8bd12907257c9af4743815bfed371432aa0598de0ca3f994e913b9c87dca8de24b37a3af9076d960afcab994699c39d1f81a97189f7b2d2a6e9b09b0f7cc85e8c11195ed72296a077cc02a51c5ce5137e925d489e22ba40fda989f5564f95a14bd14ed9d70267e968b75a7f3e0a10021256489d8c2037455818792d7e170dfacac89ddcd8e595bc2780882f707b88cda4dbd105cc593cf2707c67b536f7d66d85b15775b4abc77d2106073732193397adc107c7bc298e1d5b02c719b6370ae8a9943f21e325b863c7b49a93e4863b2625df0f7079eb3013b6f64c4c0ffabd345dcffe46b408be000562b7b346ae7f5815c0d28ce30af67019b1bd095b986695ee9091d56ca6274d85635cc11614f8eade1f23dd9e04ddfdac07eba15f50eb52863cc1139ffeeb0ad85e2b75abdae435ef6a8cf1a914a8362ae20d5630a3f3a7548e95d31cbab1d4fa11800285c08432fa8490d59cf684262251b04f1b6c6888280b2560dc4e4eaa4757a2f265ce55937b9ec63876f330688011129954d25e755740de4cc79efb42523535b232e52b9f58f93e1ec202eb3b410727c184b8b6bbb9a4f5945163032d3c3089c0c787454e8db140e871f336fc32a17926afa5412e0f5ebb3cab0f1113c77a7be15dd6be6cf86852c35bf2f7a43ceecbe5e46495c504ffb87fc3c6bc42e795eed3d68524c3704904465ad0566c3861e745ac80c4ba56a26e568cd6a17b2ee7f63897177166ee84348384b008b915a03e5c6655884d638ff1dc8e140a9ebb4845573252cdfc6736f4a376764f9f33dba691002e82f8e1e0854c98f3e73d0288b01822df40f1935bc25d0c49e1cfcf09ccc089f67f2f8b6b3b8a913b180a73f1968bd5722e3e732f4ba4bfdbe5824e2b85762ecba74e608485dd05530ed18fdfceaa8c21ec8dd7bb8a726be8fd9dbdc1d0751e64c2a120f07ee9beb5ea19f2ca346b0e414f34ba21d391b81d071fecbeac7a34aed5c1955deb72172608174805da5429dd14c90a50b3d812570f67f9bb865133e9a499a860c6a8235bcdc9585b393708bfe63567352857425fd18cfb1181da1efb2f48fa50c680227386ea3c5502823ca24a8cbf6648f1be39755822ca8f758b99faf25266f414c1b7e645d37b39bf557dc457f94599f16bd7c1564099dfed1b74e81d6c800a5c35ab1c46f835012b5c7a995c1c4cb3236df4d1f476c45125e13b02ea83d8fdd848ea34d3fa63d46d0e8c95ba15238768a1cf529195133e2b528fbfb7df131ffaddaa5ed61301247e68d58d54f7254c5b74fc411ae0ce36e1dccfa5b392388249bd546ee0104794107a196a083fd714ab3159f38ab4a1b16b1c6dab1bbb402c6b59798bb9d2b157cffe971c18ef75e75392dbdd9647bda49e8ff5c1fa9a906818002ee7c8990f7109a6df50e3b81f491a754778f9f3090f185b812551a50999e59f9c71ff9633164bdcfb4f7d2289ea0b8cd3c452f41b431fd5e9e7babd75e12681620be20887457c91af27f0d713eec63c4bf63623f202a5639b6d8b31d6f20037eeee68a62f3efbb20c7e922d4ca4996098cf16a0edc33fbe4ee436207e54f1653ba8e3bfc73a014015fdb7ddd0e2513704fe1df04276e9fbcfff444166eb7b7282bed6ed851fd25c98ce3dd0f560e08627b4bb79761949de923dd6f32f364e3e9e81fa060fbce36e3f5751d4a72f6aed3ee92d2954f1beabc24bc3ff10654706a0e28cedd1cf55b5644f845e748809ec2fcc7cdd6ab124d7ab9299ef0bf9e215d77304795aed8635aefb07c42250d2a81ca91c2b6c488a9f03c3ce6d55a750f43b3cec14273375c0f93734a69b307e86979de64d989ffde6f98efa46c38c0973bbfe5d910275d754686d12b388d9305f12f73abf92ff8c03cc73a340f4cb372eab76fc7d472c79edd356fb0a590b5a9b5c5e934c9cfb27dcbfcbb3045898f4eea736ab2aa6360d0b59778720799f9559709a7fbe1578b46b3315fceeb08b07d8def18f65905c3c14511e577094a58eb5db753ac4183f91face482784d89ce2b93fb1454264c796743464fcf444a6f2ddbdb51d271e94240337837170ffb57514e68b5b776b58981ca33769b390fdbca33f5b6b64544b4e87b5bc914f48976682dbfb32a824504563232fdbc3c73bab2cde742ccf84408ebfd554565bc48c51baa94c99f03ed992fedce421b4c9886fdee213b77ef484ee81c9021885daf7981604df98613ca0d1748f2121402de1025898f817ecb6fc20ceae1d058400e9e301218487d2f83dc40f144347cdfe4c8ccd8b64370b66e5c0d86cc5032fe9448271930e09205b0dd4e25118c1d089f56fd3a358e5b365bb8ce7b2bc730085d07193130fd432c74556283e28981a0b1dbe314ee405da0c4fae679fdb3ef342b1177887b43efe2592571e4353bb886d2630e936efd0f2efee1972aa3ed5b393c57ce46212c398fea9972f677d9dc38060865cc5fd4987687d6dd52a84ec945ab26345901d406abfe767577ef822d12fd8bd2d5384013125fa31046b9dab5af6c29728b187a9583572e4e45fe79654b729efd4f69981d7db92c6314f0a1e14d7f446afb46964b95fa4bb5d9a9151228c48dbf7b28da373a50bf44dc7f23e0addecca9266178d0bf81d89dd81c0b8ac7890100da6164bc22f6289e7374417e1435e7b959ff51f2e157460e4099ac7cf5a29f6ed6c9da1f7e93d887d9ab040a50cc345000a59e7a1dbb11c31d58029b69a24e73b0d8ce458f3c31493a7eadc407c4cc510fb775fcae240951464dc0f5de4cae8eb4b899de7fe4f2f597df6469e9947d100206dad077080faa8af8b0eb9ce4ce12aae586f332417c85d92977d30b4b4a0526d435f2ac57b79fffd74e4c37d97f970ecc2d35e10a7b53a659c03512bbedc0b277f71cd6553edd193d7c6aaa6b41666c504612fe48b611335458f47fa40e5a237e3da71013562697fc3b48edac9f92a9a7866e98d9a0b99495c8e7e07918fd6979ee5d2a26f4823856c1e6c447c4c32aeed18d10b3c9944626331122ef2bb41a34ab16ca024e20af834da5b6783f95f375147e6afe43d678e329eedd8e410c19a35684bc54e61532bd4d20517aafd60c4e1513c03c8a2a9f3b9cbc6bc1957f1365ba4dc0d562e2608ad20b946892fece72cc3ecc5299364d91b1158632a031514f10d4ac64a8673350da085dc987436efc8025cb5b524c97b08a6df75c406ccb5264f652eaada23d9aae1bbaaab1e4fcf4aebdbb67fdfa0ad3d89aeaeca27e269fe67cdb309c7c1a272ac4e7709f744462f66ca102743a0173c2b57ab008c14c4ece27111cb34a5fa6d57d803bf6110d738005bc5c01d29d5ef648f6e5368d64aa23ed4525bfd76c2854a2af060efd961aeb2746e6ad06423f3d1636caba20d0c16f22adf26e038f0a9aa65e973f50ddb5b34a0c341bf666d9b5600eea5f82aeaa0268773a7581a9d69c49e8b6f0c307ae207a79167e1778ba3c9932617341c96a58f8dcd38251dc0ec0ede84bbb8780876cda0a5000ceab5a553bc7f186fe0470130257ee29dcaba5cf3952124fa2b5d0218bb67fdacae76e38adcf0e430ad815250e24641a0d5c4e8bb99c89ef0e8391a177347846c9b744fe628597e01884556620328131355f085c6b0a70d8928bb38c07fba60a338b50b5e0d72b638b4d787f2840c56771d6db4ab8e0f861507c834f4c2b9abc3d93d9e7a72743197cf554aa99410039c34bd1ad057498bb02c7b373c789454a560e87a1baa8b26e6b39b3606fa6b493c4d25b278acb405fdf77f090ead77d3ab98ed79b0585a9bbb3be98e6b065c91e6b7bfba6ef5f0080550a0b194a5d52275ef1c652e7af3eb4b4432e7ea31ca56d2ba6754b60d02ebfc792eb64f41f0607da86aad2e03f67d5ce0c6a13c57a0b582848abaad6828231b45593b570e49a650534e807d74c7167613b3cecb6529ebe1874689a5da81596929d3b469fcd1825deac3c3abb026509c82ad79d8f8e4a2d165708e187ddb735418cc3a3e3287f4de9f50e71778425352e1023b9e792f254979f96c4c2025454c80e3274d598fa4c3f720c5e673312efe5d184cdf36f84694e1e8e2511c9a244556f8fa06864d31ef0cc01e3a2c7cb3bb7f2e45ac344114d90066154395b6b6cfcce979e4f39e9bde94c0191586d8172d55805ad10966018dfa4eb14bb4a04549386d9387390ff3fc4e8de82d078f5baabc2d29c7ed2bd02f38a0839c880f8dc7cc3d5649c985254c5fcb05f659f1d55449e2a98b896f8b0a1a7b019f7d24ed6af53ddd6177861d67195c597b999bd5e18e3cbd5aec9387b6516c3e804e6df185c8be6abdd3ecb74d8560e0e92880dddcea605f605d898b618c4588d00b93dc1d020447937de1ff464f3278fa5a05adf8ac05ad54586261e6fdbd95afd98fc3c8bca382d8f5114e1e651eae1f582fe47cffa31ea9ee5affdd79e10cece7d2f02f7fac51441455345b39542b5f1369f904d43ebd942fa9294fe6fe9a68384b5a1252db80a2f383a2c1cef0a9ad3c7044ed4ebff4cfaa6c93a833b07dd27879d08873ca5528a758e5d9c86197a03d27b871a38f7be107ff3c446b1f4f8d64aaff7332c4a7edf12ce6456e13920483cd72bfcbce19d959e7e069484b425e8bf0ff8cdfe6e66d7499576d7d5ec15fcbac6c26a33cad4180dca9b3272d36e80a23bb2a95b31865646e483b666d1507f06bbafd4c1c9071cae014a976cf1029368d8b8f9c590d3d6ce36dded89cda12251cd5e13fc21e78b1e27b87fc1c1767a146227635537efeebe4dfd19ad2f34a5af39add7b2095c070311a65f4d7a3bfd8e92327706ee67d8c3125a8e1fc612687ddd2848c6fb6545b2531eb864751581fe4a6f565e9f064936c9eebe74067f52e2a21f9aea2c4314eba9a85f8aa0a49740ba80e988cbd7b55a943918a7d5428d28317931e9f8dfe881797d99b21b1ccfc34e93147683e4c8e4a1f3ebe3a249699843683a17c02d5e5e907a4db7363f5f172e38790effce9a3e57690079a35022b618cc5c7c1c92989668b6fccf9f2b19a4c4c3d095b11e37d3261567c11480a612193a51ef4ccbce491d98a8f0ef4f229ee91d142d7faa8f2e54523476dc2798ada6f30dc1e48e9cba7973a20b5c7c61b30f01b4a9205b43f80a4d295273f3c738649cf3f0303ee9386f1e731a58483c07ba2e2ccb9e27b3b14e7a16903829dd52b3ca6997c7146c50a6654dd4ee5b9ea99017d59bab54c6837a15c3a120b7592efef04fb96ca4792df279d19aa569c6a325d40cd4afe3b868f613bffa43c609ec752cb6d3d28aa52aaedfeb60fd9141844c2c0a06b265a91d96f906afed29aa9f1c42c697bfb72161ef9393846d18093e9f3e64803a4e475547a49b6b7831968cb12d3f5f4147e5a0c824dabaf500acff5a2d2f67dac6f56d580e8e9c24b100ad0f8ea2cbb631542c32bd3631a22a1730ee9e1917dbce3217356749589bce32c339af227f6c4eaf3ac530b0625314b5bb4e8342a90b3fb6a95d8848b4ea7f1b7354559b9464addf3fddaf72ea2cf83ec24c65d274c935059ed53d826e63b159689f763a783982a113aeb8a9be25bfd38d974c270bc9a2a561323bd0bc4b80a427247bb17e76261e5c010259dbc64fd22fa5dc52e8ebfd3c57da37b5108e497deafe413edd84a7afa0362ed98d72c147488d753ad03f86d815bdc370cd30d70b398dfcbbdbf112a9a955c502be16cfd83a15c0a879db7cfb27d3657ef81b68244914ddac8cd8469d4b951954ffd46ad5aad3524d686193b69a2bc519ef09d34f71464636bb947574a4699ae76273a966bd5dfba3a9dce88b643fd1b8f0e27cbf47fb22c8ca5ff14dd12538be11e0f2f02238e30ab7290916ba209991ca0acd503800832241cc03efc537494e28384ca2b65561a389cbd4db3083e5709632b4ce3f3a9c5a067acf427da0eb2825f731b4f8aef2e563649902e11516e7598d53041c15ea3ab22b5c3906d28536d334ef6142d4755e5b3ba3cb30d0811fd7c5957564164785e83a3f20619738fe30555976dd711ab45f3cf5a1bc129aa27b7029fca91f6e4adf1f09da9f0f1e66f02d680c3b7c80f038c6c9c7485ac0ec3753eacd15e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
