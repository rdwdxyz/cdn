<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d84fb70626db64758aebab650bc315943551883826321ca3bd4aaf7cbbec0273f65f14cec22adc2c25a2ae6bb6af1baa21b0065099d1b62cb87b578f45fab7818023ea9080679fad7552cd9bb381d7bc1850d09912312438c17f76e289d489dbadf3b6b976d17f42a495d9fba321129a3dc2dcd615a61113e0de58c87bcc361e51aa4a9dd85f5e5305c94cbca829cb417dcd7ef13adaa7d253808ac1447c0a8e55966ef7fd038ddeedd79aba9ace1d1695b2b3e5f4d09f790671fb070cba358073e2d43f7ef43eea0b9c1fba818f369e5649794a0b385e6bd128e51b486bd53b6b287ddf7bc47703eea4706f4b0d80e6db71e25d19f2593033c94fc3ce0576abd01771f513583f42f3c36c7b4fd7686e320c662847dbf43e1c703ef65e4f59dced1d7bf369da90966b47467a08633c8c37349be23c01547f74a655cbad7b53a1ea1be4185a80b0e964753ea8a67dbd0b9d89778571f804529845eff84d8770e4b3325cdbf28efd6a005b827642e9f8af5cd48d2d44f11417e9952e7a4efa22ebd28b2a92ba39675e57ed88d3e505345c8c975882dc06b16e6b1a32bfb194cbbc144dc1464e7ba1e70265df8e11bc201bc6cf43e0f3e1439170e02bddb50d42e18c4a66f1fe247fedc3d5afedd6f93426b812f2fbd95b7fc7684ac25ec5f2430dfa1f02f220c676d0874531a4c893e152e42aba37359ff14309daac522fede2f1cf946bc706c1ac0904bd23f3295117a3dd7e62ed927d25f67010a15c8b3018e52e7afce36dec81d31fd41c5e75c30938fa261acff15278943543e8657b0649bd08dc8e9d2e14a1bef5c3182c8d398a6aab8df6aa63946364452c3c2165ee17ff8f6855eeeb5b2f3243be4ec6bd69496c136b3ae67ea2e88b941689e29e6db30930f0fe26967308a71db2764244482aaad99c46f4944e16c2af02329288ab121885bbcfb42b7bcda49d85b3c3f269d214b03cf37ed5935f9eca1006ef6914da37dc85a31c7354926f589adbeccf432c18f071e2e32ad20873cfb8d41eff3e2d96de0a569d4a5ad843e95fcb85bc42c3aafa0be267d08dc11b800136070aa6455d73a2b6f71c244fbebd66a22f695e25ab56f6e0c24521135d2692722de9e1965fec3dc83243948e1c83a994610020dae927d708b0edea0530b26a30ab6d3c950a6172c43dc6a5e1addb474fe06b350ccc78803ff744c5304b9e563c50eaa434fecda6b7deedbe0cd795cdc6d1322efad12adf535ca2bd7176d119f089af0a1a6ee41f38aaff9039a2c13f3facbb362af6238ab5ab23020c2ee8d53b1c2dfc659a12b2e085084fde3ec059e92d809fe2f5e2d70ebc085029572d4c8b41cb57664fd458ba5fff3456b3f83c5623edb5ff123e019ab8c632e587e1c6292b47023915b0e0dabddd743c3d003d5650a3101b1b259031f2dff6d112ac8c844e9ea289a584d3a479f9de30c168a59e2a9127b062b276e399e579a09be5e5d6c4817897e78a7f1067fc7492f9ee392af8a4afc484a484db7de67b775cf3b96ae0218d5763d7b19673d7f809382c61fd3799e316eec72f40fff996d1fff86462102ed08661bbb8cde01367dc78cbaeb880e2b691fad70ccdc466fd9264a3a8269bdddb7f7df8ff4fa137583b78f26773fad50a1f8bb467d48420e9acd0bc905726a4f674a913c80d63d9f012dd8626e192d29254e860738171a69db57e0112af3b68a56d3a281dc77ef3ae0f222c853185b8d4305a2a9f5e3c50bf7d67b0966cf1052aaa05e672eaf9d482e1cb9f3517763dd086f0180df7455b1fd7216609aa7985edd62e46be42a2de3ded0f2b71ffb65dbc0815edb212c16fa8c9e279a19b5f573122d501b6fba2fe2fa0ee21b93354e39e5658a63f48f9dcfa8ddb23db55b2f351b7222721b2554209c7c60885add8b37ac00ad3cb6e566fc18dd5d4d3472d98f388c716c6effb14d831fc7b7f05899f7b32b351bf3b8fb1de51b59d5825bc09b1b0ae2eccaa5ccaecfb5ada8c912f71b1d027552f0e855e5067ecbe6d0f76aef1783cd351c44ec75594132e475cebab3f89d237ce917eb241e1d578e0978b47fa0ba8dd0ab14dd6463c71596437be1e29c3074261df0db174d0589d91daa678499d71cb0cf8cc036bd44b5f9d7185ce3f9618860b332e873e9ae4ad43069a82f6590035f8b15a934464fae0047b8fb0209db581b1df42b36777602209e0984c7f129675d980cdd32db4fb89b571349127eff16fdd0449c82dd076a6845e669747601b9dba8dca85eb3ee26b668f21e76d57d646fe1d765d284492fb0a604ee51dec5d9e601c2533ec9e72959ad15eae32d2726de746de59efda1a7a2884a79fd359fe5a2073f3d02da4295cbb5a0a3d26baf1904f09ef5b04c1a25d1fe20e44b4f459996e675512ec057e13af48804bce864c3c668663ff116243831f3365b81bef59c9ba6d9bceae03a6de4648f4c0fa4a7048d36ec0a0b7b70b0f5ca085e58bdb572e4f8ba8a8a3e9947c1de783a226aee69768dd1877e146e44012cc097ba986095ccbb32a371f09935526f97ec1baf049d1fd36874d190d6955ab41506a4c59288415e648d000d8a1ea37a89a58b5e43a3b6ae758f6319fcdf78a7e2e944491700493424ca430d5d4148f9289f78448e455dcd5cc882f2912b4ab5b6c363cae52f961328ead0fbb2b084ff6e3f2e9a86414e0bcd5ec5b558a5507441a8fb9d5960b142fa100923c7022f09cab5080fa21f82f60c2c746b85444f05cbce99bdecfb5ef2d23e6f829044c6cf72510c34f7d60c8ae11d3fae70e84681f0b5dd0ba9621dc850c0e94681f04348707a063f1730f6daa38cd598be82c191d7e1971286ed13ad608089f3c8c54e84eddc402983c0cf47e586cb1401f086a386850da8bf5db93bc2b5362c774481702ebe32991c414b7d38070c71f1bb74f01741a22b628bd567ba5b74dc08df931e733c022eecfcd97a96c64dfc087a0884b887fadb40d705d61684b310657166b335299b436df194c1a50ad69764b45f6ad5ec6bf50de70cd77fc40b5c0cc6d958daa9e76027e30e29798d4878857ec0825c20eb01c8e16c7f8f361c8e6ac2bfcb87ffa2440188989a272bc2579e56ac640c19e40c5090ff5f13a890db26b58cba3b6d65d4f515885cc9f54f51dfdb3e8923399d918880de5fd17b8fc49bac4a901bc3f8e3417f9f0e86bbb770228f9b8cfa44ef9b3479aff2de4700c5d4ee7e8ae3e8a9f47917d97ecc88e83d40294578e02b15d80bf4c3c115c79ac507dcb519bc8922dedf29c0832d3c9e526059f23a4660c02182d69aa4d91abe2c75b7fb245174925b84b8ed7edf904dab61021adbf6ac06a113310f08324376801fca937c934eeeda9a8f0dc47cbfc77a67d58ef3fa5859082ca6b190f8a7fa6b3e5d4eb18f274f0886504498ff94399824c05ab2c6148ba63e88baa9b9fba9f7326aa209d7b3b00a302e1046882a8e68e2439831147eb1448bc199c3b23833660abd654086be1452e32dd654b30c4de155a6c1a41f3aba819554df081e1e0a128dd97fedbcdf00e84d7327c19eca9416f8d9db65d2bb9f45e8448e49e36d6ec3d77f03a5c43cc8f88740267dd2d5c29447e0720f0310e2cd8142b4e1dd37e189b7e44c9a486ac5c903a5ab3000ee7287875950c25924f7e732d817c5a49b5983fc1df19d89ae8320834e0a9b0be0ca73ff6543963b2162419f72b6d094df0be3bca806b78964649b193b8b41992bcb43cb859f95b17382c45e4a1f71a4f3d24fdff48c0f768c7997bba645d213209b4f7376773a6c15dc8ace4b982806ca9e951996dbca0b6d80545d9f796fc6f57b7c444c4fa8363ba2e175af236f224a5d91d7d97f32b0de8b70d3cfbf93d4b9aa4ddfdf7ecf478e3e9dc144fbb7d415a7b1384986d3f209c0247ef465316afbfa8f2d8179053e7d6363c41231b6bf0d75e6fe55493c46fc7529cdd53aaf374b986637c459bf69b6ef70f9dd44ef023df5500bda47b94b8554bd496bc12e54e36387c307f18901e10b614baba7c505f14268ab446ef52c4053901c272b819fd1e1a437012de8593a8e03202bfa95cd70afe436fd5cc043570b22f9fb9e4f9f9460ad224894babaaca37d5c58f158aa5efb21a59f21e828ed493c02856bfc5cb033f2eb718c85a3f1983ea3c372193c2d740af35ba8a75b0ae1092abc034ca49d1fee5c3b465c155d5952909b68902ef78c0767602294b1d91770a76b2b4236a5b3cca7f2517bfd7a22a5acfa6bbbf1cfe4e70dc5a43ada74c6d84e4c6653b0bec3cd7d4c4307a6e00b482b05e717ebe25055559e6aa0f3c148b083af2f02b16e0235092ec8a3b16417207fa72c04be92a095dc6d17e301b8b276a370abc999519606d5f6a44d0090d8d968a2ea57d9c1bd57028c236eb465cc90f079abd291f32be08d5374b7bff7b484c9f864ce48b27778d6b295f11c9f1524c780856281616a25fdb8b2a9caa5b22f34ce30572ccf08837d8163a3dfc4370eeeacf6a8023f4dff610f3774a0a4f3f07eca47ee0e086847cc0be52232755b8ca3bb81049e9bb5f677d1a3b131e8b7e9bd3d9cac1049add8fcc506b1e5fd94792f527e54ad1af3b8b35e9ec6fb5d6536cf9fff7ec20500077d04e82af5ab538cf486bdd8b3a0d3c18edb5ffaa94dfc9815c4f59d4e50e6a7c664dba2e54dd6492601c3c5a6b96d6c47af5d69360f162b7cfb7b3a26d20051a3c35f23e0c3e3741c6ef629dc2029f28967f76f8a7b65d149a16f349f89a2195b2991e4a912283cb676ea1ad8e3d3e889bddf277559467df0128babf3059c9b7612be2370ce9041b1e00baf843b6c215431c67b54234e2590286cca7e1c07418e7059bd1051426ffcb6f62c38ae1790e7d13885cfc78bb16d875eb6222e992075c0aad71a4f363ba6ef37711e11a4871724ae752fa73b3f2a60892d6fe002deeb4d92fbe4886ced3762b0badd020383813888ebec2521daae47b2430f84a7f0684a3008fee370f4b05b5bf83008e2880cb12c5b2eb762382a6625db5fca32d04dcd3b7d609f639a1b9cd33cc20761c5e2559133a169382aa1b75fa0669d9cc4676c44c0c653585f5f765e26b105a76db40ee58c412f0fea155d9e0fcadd11c12ecbb3d263522559926c466af657d73fb722a643c1e9329ac76fad3ea534ebebe025cb42e0587b877547fb1ea84f02284908229354d3a43f217de480438a0a128396708615c68292776b61c4e239c701bad8123b53b7e07785fd026338b35e4cb29331484febfde5916749f3a002cc605967dc78cbf97a3434b7e01d410b22d2a7ffcbf8ac164f474db54736093b6eccbebe3333693a4e5dd8fdcc2d0684b29fa621c0b2b7789c597580d524edfcefb7f0985ea53bcb9a18bcf76b53a0fa7fba387106d8d01ee94c2aa860685a293dd7612ebc91e8a9aa45dbc70938615e45385517d82a0818cf57331a6fcf5449fd38ac63f43ecfa8c6c2b796adf1adb1e4c985746c25ca649d7cafc7da306a654abbde7f9d3b307d2906374a508bffd4bf79405a9168503db2044de92e4cf12e7e180873ad768b6bce798b9dd5e841bbc962ab9e43de693e394c46efd71c8f265b0be4d97dfc1910d485012ae3ac1d94a42c8cf451fd7287df10ff4b8018798a4c6eb840a282749d0602c74f0d2114322a1d0adf8d0ef7849a87ef1aeb4526206b9be1171ee81bec0883d70878cdc448837e53f16aba03b0447bb1a9fa41cf6a794c617b4510b1d67cdd53fd77b1061226a486e1d1626369f9a28bdec658139c091fd8866b17bba8b1def71c08f6e1f1f8e39bfcf9685dd92390354a1b30fe939507e0981497c8e2df64896073ce57872f088fb2b0237d679cde5051b39e075caa6c5e14e8edcdda4386554167473da4cc2462c6c12f939679c2011443f2ec217c75624c216ab35c749155d6d914abbc5a40e7368d6cb084682cca5b158270ff1e23b7c9e49f6c1dec9ba1ce9591c677015021926cab52793fb43b7e13aa47fec098b7d74a4289c6d05ca32171911de9a1c1b711687188c91f39839e95bd7675f281a2c91379fb2e3e280c01f9be17ae768acf08489a499148a20cc17b7f2f2bbc4b4244ad831af694d249b2571c9c5255da8c0684607791eb87af5e7f67b96bde5ecd461dc022eae54a9fe1f9c29fb3381b05b1cec1bedfc9eced3db32d50e491fc9eeca4fded18bcf0a747103693cf36a52ff314bed817c9b3da0c4dab917ac592e8e5cc6d2c82a968b3917610e5e861e51926e41bc8477b2012afad03ab919aa5defe6afa1a90a72e72c1f18ac33e170f2d2c2ce4128e4534b6cddb1fd80455ca9872d6791f7109ae24fc7edf3f5a5dab3e794beb62d1fd6e3b9c7647db955d111e523e7d7688b385a9d7de8cc5e7c1a914f165044c7d72b25010d28f0862175cdace9c6767033c7cdf539a9f0aa7b5e0677fc7c9d023d9c9db2311293bc384a1945bd6b665c88dc55affb793e5329aebea9108e92f288f86928ada7f5fdbf7395f0a5016c245ee7ea63205859fa5932010cb6a6eeee305bb9d91190d9ae62fd8523d0cb80442ba06d74d4a5af5b92e389dc94d63e90d9fa0661bae86a81354d972095fbf48f62ae66b9e1259c450ec7bb3665a23b38024bf60cc9d2e74bb377d1feff74ab0f8734419eaa9d0cc72488b294e90df20494ce0ff84ff17542287367d74bd80ff10d0ccaa8dc606472898d9b27d374ec1f6d81590ec07762d28552eeb25ec6499cb240804cb2044b063218c025af464b1b13e225970c74ee229967f047a191447bca7669847d5de20bd94efbbbf51c2061c9365d6f0aba1f9449db2f6d9f6fbf29d3ba4025dae4e4725f83e5416a9f8c2f9a6bd09852ea977d0655201c0466a06084cfe156edbc2241880052775d9603dfd15dedc7000e49605c874775177d630c18873bc897d3dbc2f771e02fa865103eb2dd297a2a613d4cbbc03816419a13e2056d2154a88201ba0465088bfd262e3381e37ed79ca5462927be12e453b12f1f98b9e51d464e3c2724f1b0b126a0c9c9a19abfb61de0c99f1912f4d74cb55ac4e4c9100bb8d22dc2c642d53b1c4a17cc29f837cf0313dc4451951b13fc0c251ce6ca62d981ef6c110a13928921cb59518a53f6e4bdf4e16cabc68a4871129984f642118e0a7da5f0d170832f2075a9f6ea594d539e8e330a25124c5ac2a76356dd33949adfb64dc65de0b9ccbe2aef541e6e78f7f76c6266da8f5d93538229e45e4a3c28675457d81c799bca5269bc87428e9cfe839d5c135729172c11904a3b8865c128f7e6c2998252903e4ea93a0390d088c28d43726ff4579e2714b10f411e7fcf4df0f5297fb9c771a205bc4f4e341d38de032acfa63ee48712e59f79ab181b0c4f05112419a4658ac9b7d19a84068d12cec40dd46df19fa116ed0cd90479c82312205704781565516398c2bfee38d574849b657f74adf9d00f4e0f2688a58f5eeec6add782e05ad1cabfd2fe15eba574b5833cbae9b1eb6cc44f704765df3edf7d55a40ca36d7dbce311ec77f943a204c022494e2b97a53563e3796c9573c5bb3f4c0597cd5400baf7f47416afc5f2efb7025dafd2c42452c4c6eb60d5ead017f1946d31b19977f94c20f9588262551ced3cdcac0575b7d2cb7b0abb08f7f09ce36039a70f4442a8f84ca134e2ae851a2d67a8b7d162680332d275d59bd2e00b7eecc722a12d084d59d0e5633193d5c1726766e03f60c594e00aa3b46bdecc9cb832ed39f9c3d7695cc58cc7ed26e9e8b5620c0e7227ff6a8e5c22fbf3b69635b20a4b37be1bbb3f98b711ffb2925f12c9fbe3c25aea6f7d318901f3a7ac5f97f812007b0a4bc2774b5ff1cf5b3ca84f5bbebf6eaf4d6c1d0abafa66c28228e58b66d48d3504479923045b83b16eb11f94e501cffa5a158084e2764891dec15aab8faa6232bc7a90d4bfa2171a4a5fa227eef7efe443709b87a3698c4b11bb5f13d19537f2bf419c94d484d5b157c554c150be5ed8447d5634c8d4e1ef7753a501a78508c68cb03e0d022ea8bfc7bd6b7edc37ef34c4b6cd3e334eeb81a39034c69529bea62a8c96365d2072980b77ac28add1fbda773c696560bbddf2082d76ae65fa3ed9ac7cbe3f4ecd1e0c1c7a8b97a4518bcc78da7593bf7ca1cebb7d756cf762a23903cb25005ff2d6b86a68ffc3a32f4e77872f13c75cd5f0a92664da218320b6aae7389054bdb6fd74b6dc475aaf671031ec38a35e6970538ba5490f7745b0b4397f23f395fe2ea5a5aff47b05f1dbc466be34b13f2f7804edb9a9493132f56a6f6f7317a81775e432b9c0e29efc63097970cdf49e6ba099a48cec108e622cf6f7a066ba66e3fbf57b37eb6bf84d41ee1ff02aa7a57f3f84e169c276a0080131f5c42ba17933bf14690ef6e9701605117b13d104b8b24e43eb981c7ec1ee88677142e4731d36c16638a070e25eb450aedb2649dc61be66c964a4f39c860e263349d002456dd756acf1ec1f1e4a1e4be3861326d9f10ebedc6f3b5a0699d5119a9f0becd0093907b36b0ce6cbf415c24e2d6a9fd89bb89d20908f6efc46c20b4e306d54cff75cdb487891e11401bf7f34c6103c368a3488add8c54c5e449764a459ecbc98c8bed9b8d496cb95771395e08176458610b72751ed060c228bc6d797f07bd4d6610e0964704e456d0dea8baf9f3550933fa3639fd91301cae5ff242853a5f52cca8beb173a4aeac78d87f9ab13a0d78b49a784b5f61d1ae2e18f38cb78caf2a4c41847c4efcc54b0b54f3ae6e00cb93ebd1a2716dc49bb8ee8303ff687e06187c8d8de87aaef4fc613f6807e885a44f095462f255f2e5d56a5cc3dd332890d719c637aa03f7cdd5fa11a6ee23052442c411e137c06dead930fc9ee0cb3201a03e711e09938c00ae6bfa128ec1bb26dd6f18108d9addfbed32c7a0236cfad0f8a02af086d514e52590010b4a9608671237139965387afd8746e14be479220c5eba02f271c8f70200a027b9a5b4f5183e11d0af5f93ee3b29040c91c9da72c902ba14d42fee1c6f202825c796ba2dad99b2b4c954a8b46585d009f25bc1f4d8a0dd209cdb64d605713c6d798d27eafa85c52821c03cc9d608510acce6700d3938dbcb24be61969e08888474893f20da7af31bf7ed262572e472009fa813bc8469a92cd4565406096370a56af5b47d8bff88e644b063824d2d72c7843fecb9a8e2db1db367d104def4fe0eba97992c1052b2837708e925c66694f8dc31e77b03b0ce9067dd128ac75579451679ab7d3e4e5b6b2bd3535ec8d54fe26388146233a13557d37875f4eb0ff6947b426b8dcba5afd8d0113a339234a997799381444ff10412f1d0ecdcb6788aa905f8cf6725a76b3e9a939fb2f3626c2159c7f901289e9c5a1ed59f2cb50c50d316c1aaaa5d6f6c34323e4902ce242be96ad5f96141a631077fde20fda68b6914521a8922c8eaee7e246e2d84d16eb6af7b42f73548760ef3f5b04cf327b8f125e4c79df6c5a3ab04fb08bb7acc97a57f751540f561f462f6107756c0b28109867be3ad6e036b78d7b165f2bc69a75ca1bffc089310d1b983462876191231dc63ffee82f559b15520350a6d51b334651e4684287820b4135a47e3765d4154aba4bb70602051d3de17957e9920fec755ad4ee974a1c5a7632d22e0c5217b39e7af1f425d27b7faacf5f339dfbcc78c38aa5b0e1cdc84c399fd95f8923351bdfc86c5693da6e9cbea68c7263079eca047e05890baa2d3edb7995f09da684a3562bdbcc5f81ee862b024eadfdbb9f59a9902fe4fdbf6007e2cd62f9803c8434f22292211c9c4d5d8ea89be686cb5c0d21fccbe53af456a6c8f068f4c39b12c9ea87aac2fbc5908338b56a2dba9f93b80f6d5d4a0a3a534e204785916dacbb1aeac800fc26c05a97a28c33cc255d25a97f1f6c7724a5eb31651be00910271149b469da6613e6a88741ed074188bdca1f54718075b7599b0a828b7888202c3f2afd804ff957c921075fbd74cecc5844112b1e2b7c3c77d0cdfff93d92d5c45b9c88368f367222fceed003573ba40c14fce79c9b807a456052a2e50deba4aac2764d151ddb8a90a4b7f02860c70a6e6c9be5bf5a0af12763e62469b9f92e369d994189999fcb7db64662b355d92bcb439b40b74528df20ae7df0e8c09ad5caca3795898f460d79d493b793e8dae34204ff72855192240d37c96e887dbdf34dfa5877eeba81b021e37a32c06971045c167f01c413702fe5d62f7e88c4fea36a9a9aaa3c95644165c712424dabc1b840f3a88e9318bd55b76bc25bb32bfc6b07b697db59be01db72fb89e23913928cc0e7080260ce2b98792e0693236190c8efe4a492498267f79325c6fe53fd12bac80edc4ab08fa885ae7003460cfb5180790759e04ae0d843c501e339fbfbafc1d59f868e29ece743686d63b70c6135762148fc51b4754e5473dbdc597eaa81b38479424bb16f7f089789a3e23068a0dafadb7d65d9fd1e2fc4ff46b0265627723ca403a366010447a8fb74ae8d65f68048f4b4609efd5ba9b783948ce392ebd4aff0113a5731eebe808aaecca8947d4237c24606c9b0418d11b34543423f593fe7d1afe8cc34efc86c58926fa15b6fc04527305c8cb310e9574a382b00b8f05f1400cdf6c357a00d5aaa9936a4eeb41e563b4371938fe2e5d14a4289c4cb801e5f44e2aa1562711aee3fc90d193b474fc4322477771502ba5f5e99e86adec226ec628210bc896a4df3eae9ca6232c5e7e71c19f920fbd8caa632757f7462ae2c57dd1f9cdc154158bfeda7409f6568618b4a8aa9e0811a5c08610a12aaf2bb8d4c0b70ceeba483cdb664e3162f782765a75e71ef8c4df91ec77d053e165724601d40c7fb7e6fb9c5b5f9ff946456f333fe4887dfe2baaf2a59755efbb3028e371e42d3b9fe884cec9043c3da03c5385a2d1cb286d36407b7a87699db9a6bf9d5d93c9e0b8bd4960e1e9c41057beaa8b25aac2e9b55d3f21d6745d7030a105d95f0ad6d99d27cac9a68b6ea06648283ef395950cbe869251f71f60733cda72aa6202c2d47e6415da5f2d4130c59b5f048542010ea5b526754e444f78e3826d9c1885f4240d239dbfae743c74584955de4b9dedeb82bb16bd74ca7ecd389963e645b23c8e7de3fecec6e1e7859c7b29b326034117b9188587f458367d925d774dda9b89b2cfe3cf37d110b0fd6375cfb657893e9f4e351ed213870562fedd5fd05f637441080f782bdf87e00b29f12c2cda0bc961bb3bd865377f5ca656b5562d344a7317bc4aff7ddce1b3b662f500a49967dd9d5732a2450b4f0a159f286635d964f0de1fea3ebccd5b0ea4a2667f1143050da519b8700b92e8160ff8e28482d8bd79432ef045a9a080d1e4f1d3aba594f37e1a0b024c9107f76f7203a99d02f6a499ca2944b7e43f7c85ea54f616d89a6cc121f10cd48345b370d596483b526048e1e3e0fc979b3a5735a308aa8b2e01a88d9bc989775a1f39c89df2e18414b33803cf6a7b2de15327e27e6c7a03f519d7849a161960744783c1113e46400da49388c0b073dccd7567aac6f61621fd5642537b4710c59c572b77a0a958bac86f5e4ef4fd505496d7a83472cbf95cd1ea26b8a254966762a364613b64afc622fea1feb7248b0249c069a04e9ee722dcb49cbe1ecd196c908dca75a79ce5749258fc2dad552ded9ef20b929c61e2a618b8fdac7798b6beb517b03699b3a7dd137ec004c7d86e60e0e5cec08bfc11063a7745a120866c817375aaaff42c04c544c29fc394dc9bed3f3534426a505df42f658c7d8e2c62b8c32946f8c0433795f3610d13bda274952eb91bbcd7a14ba4a92d24aca4ba4ac623482f9ca64f579fae985c7412ed7adadac60ecb8c09269b99a4bbc410da289c8191ea5a35c1af4be77faa8914df9d05e7c9b767b4fe7b7cb7844a4fabd3493d11500654d236dad8adde8317ba873973fbce5c0b21e3c6751a7a6589427b49569dab8f04648ac1f902264b2b91bb37a42305b789153579bd5019263b2c6cb4a4a0068623ddad3d1f201e6e70488e081e632d16e9b45bf2e4f3cefae77c41fe54c8545d7edb65ca41c401288d7e645f073b67a5acdfdb796f3e739e5da0eb30c0b17fee49f9e79c251754d58eaed5a9e67652b4653d5e446ac6ea1f7a4938d7de2ae55fcbec98281fcd701d1dac1c0fdf7dd86ccf6ac45bcaf50c285507f452f73b3a4ff819c2b4064614e5ce083281225b37e0dc6733859244049bcdf80ba73dc5a765b1c53435fe216b3b94585ec00239e77379ac685d94fd25906b02c3b0e2036fa12a19cf42c6056bcbc2fa498b44efcc53de0352051249d28160dea78c44acb8e1584003bcca45578287eeb1503c8330def68e8f3125937e5ea9c61fc476a9461fb2568a7804da5c53017d0c38c40f71fbaa732383c2588d6cfb7d71fadbd9db252dba23f3bda3dc7d74a5e870ceb038a41e7ff59a619e0da297fe01ff498dfed4584a6739a9a5bddd46573f8c55280f3f76270dc67989a3dfa9af79a6c81c45b56389dc89511714c7e423acfa91a44c38c9a3ca2ea41653e4ba010ed9207d8eec195e0bf7469ff3e2825349f6df5127c15d9a2aaeab24aa3c03b584c435e781d2193861bebc7b9f3ebd5b49b406f0cf00a13178ca3b356ea00df303c8815f6427c35cbb7a1174c33089b005f7a7540d5138f5de94b7eb8d145fa02c466c2a9fc36e35715e3ad4b8acefe15016249e9c45a7a6d57673e65f8e77d3ae74c00a03a7f3c0aefc8da65b2616285a09aeeb6bf1cf9d22df63bf0b493a5b26901c97d6059d63e11824cb9780029550506d9f022a3806842f1e6b0bc9104ff5532ce573f91fa8d7a69e50cffb45974b11bee4d2da51183aa923a3d03678b34cc9be3fa9084a18b2deca0e2bd1ce824551fa685d941ac986c1f5a68cece35344ba50f9a3d10d16609bfb239c0e9ecf95f7e1b524901c1085914d8aa084a314c7b529ae62980c8737cb5789c115acb9ce4b14f36ef41f5208ad1cc1acfbf6fad66226f1ec20c8b313a806cda5fe3e0c2aac42d521d94e90734adebbd1a235f9f2c947473ff6b260385b9ae28dd8a0f4462c5e69fb1069d34b0664e7f9057e2788808d3ef68410c8d72516779acdf074b72d0d4a358df62f343ce6adba04929425c4fb73b617aedd9a37f0f0aeb97771322c64e3ef98b4fdac7d9a00b36fee0b6e57369f54966744dbfc292ab07523e726cb639415ba00ac0c167874be14e3183a70865fe6b529644c05e237845760be5c80b778d4886511e09a86876db1f6196ec53037bb599a6443f7695a2b3abf8e2d3eab9041a2bc5316520b7f095f76df4f43be22c321d22f2220297f2639fedac6452cb46732bba467313b25bb352ce466d8d689db8b1fc2ea0a269b94f1393170912db4b8397d78e3b47efacdd06e9f396adbba1faa46c6d0110cae69a388068b340a6c268b37c45c1f44130333c95cf0265148addf8f45e60d2b6471bf58e794225b293ed10d680061e744e25ddca638386b6c863f934e50aaa287503f296179bed8a55eb52c9d35290e8ebd20c5516ffc2cc96309dfca3b9ed9bd2c5cddf95a117d0f98ecf62af5efd22d20baf918754544fcb823459dfbc19913364e440a3b85333fbaf4702be8551bb0ddcd4e1c8bb3623962d44a52bab99d07494991c9d10a23c2c6658274b484c382022bd5709754eaa804328f37427bb54f956564e999b570823c1fa713a5ddae27d470f0ac9d32bb2cee1e450424700f787ef48d2706dc2ff82315b9f63ded30c0d0eca5b472f9a310acffa35b7460e579291de37eda40a78008a70510aa0c9b8a6a7d3d5be4b7684160808f14db84aec5ec796e4a2910225d89101301b4253e53d10ec4f7a3c3e3f80efe4a31e7a5097980b4daf675e3f12b493abdcc5b8229cde7ea4f890ceb65eb38a1b8f49cd43b5942c5af5cd271e8a505f19727da5b9936afb6db32eea5e4994277687f2a8c8db26b8126e9bd765d6a1650dcacf1aa08698949089f50dab0d61858a02e8f102631ea8468476a14d3a764926ad73150d1420a9997f75c2e569162b108f0c6ab6b31429fa727cdf612175aafba84250f3ce3e106bf6effa4529bb643151d53f75ee3a3a57250831902a74e8858314d2f15574f6f99ebd12bad6ef6bde6628f70241a5e59af811500f233f28c2ea2fd0cafb04bc8552d3b6712bdd734a6bd9907c2fd9e02d1d16b1d849e4cf6de3c969d5ed7bdf1930fee6538a8a32921fdbaebcfb210f9a7d3c6654b8bf8cc9686fbd6923069bae5a589b7b0e5d654edaf689fa7e3d3b26b6decba215ee6190273af322199ee36830498fedf13d7167fc2277a4002739ad8915a0547c1e3941d9c9140e4972d7cde843a7fb7d4bc0e936738ec0af4d421e67fee8d5a6635b86974f84e7f8ed8d860c26c34fa2bcc8682b115bb6b12b8b0dea2c68c536620f813186997b7637bd1916dba61404a916617a3740bdfd84df229ed175b0f99e21eec0edde541e4abb9a21da174a8918e361e2488af6f3d9ca842cbb35d8359d3669c9c50a131fd7c98ec3939264c926946a5aedeed8c3855951d97f7f0dc1c33be6bb5746ba4d01b1b4a3e977395b9018826ba7d92dbe8cb0e696bad1819d31f3c7644c542e6cf73d2e59e731e7d418e2024ba3fca09a1d8ce096c416fba9049c394cdf22738225614b08d776c137edb21176c1cb3c52b58bf8b3fff00c6f6e10bb74c38ce462e53b7e5dc14d34709ecb61c20d962ab84bf2f9e5ac1b138a3210f5731cc73e3473f9430d687c7b0f0fcb9163986a2f1aea1ecb11d1f77b280a563c2c7b86272653a96b38b043286fd56e3962e9a22d269dc2d33c4dc72d874396be79b2b2dd385ca3a700cde5ef291b2dc500828e3f88b14bcb1b6cba9c741c42832015547995468b6dd661ed7462edd8b775f619d919c4aea0d14bab25880e61a73ee4e41b55342b887c840353136787dd8e886724206e37f49bb57bcc1566383338ec1e1be2ce0fbdf73f807fe6905d426e04e7eaa3cebab03fa7431258997c7beee70587667756003b7d543268d8a994b63c56c70cab521e82d49c578a2ed95ce38eaa5f9447fab2e66dfd115beec34fb36549339590055a4a77968b66d056466cf83a8b7baf4753c30b8faeade5d35c91f5a5f50f8f08520517fa934bb4f56f8305ac5ea5bda720ef70f0704749cd1bbefd00531b57457224aabd6d65e3e0a73f31c49575e605c01ab2bcea430648cc3a20131a5c7dc5d06bfb61b10f31ccf556c8c5dde5ad193fbd005d6451caf3d8b0433d0a81576bf5b3b32907c4275baa2400f845826db1f5c486ef89f635c22647024ae3d2858777240505b62e6f4688ce6276a662b77a1ec58a4ce42b534d12186b0b37226318bf6c0d473050263efce397378ebcda8d075f569c1732cd71f785617bf8fe929a53976e0863afe40d643d67e2d28ecd21574e6a954a5d20c5e00935766cc010de54e38a65bec5babaae8fa6ae7348ca6fec3aa8280b1bd01d679af4a44bf4d7dc7dc8e7a88a438539f9b41730caad004b60fdcf02403165c2e5153e994341d0ae61f242e45e62467fcfca3033ee98573d64a3c6cf1dab445364e2deef0b92f0d0b3c7dd1f5927c567ed3360a681aeed1cd11eb068a0158b2dab2d36f5b8299b035511e2593d20fb9a954f4b0e84a92570dd3acf990df0391912755d17a2f5258c19ef2143874469e1d01bf03131e4c396b8673bf78eaeef15d7f72ced695f24f9b173fd6ac3894b29e3b9d5d752783299d5423c8600fda4c63375f686f54b6d72a1c9ddbce04df1a18d7c88d6beb8bd961d81ea8e5f787542b6e94fdaea32bd42b9fd261f2376f1a26fd5fffd67c381c6f7077d9ba87391097815f978d5c78dc297932b7191c3a9213417ae57b4b22e7587bb8743de969d2deb591988e6bf2313a4f848cdefc7fb2973d4d1f0930583996cfea891f8ef4a64dccc9eed3373ace3241e2e84f9ed73cc7eddaf2d7309c73fba100009f32b71499a532068de4e62e96605ae2af1277917f6a2324883e467b78eb23e6f0ada839bc18c4194535105f9c8461d07c4ed1f83b2e917696d2a08fd029c0fb549a4d6dc1082a05d69a77bc6d04acd044baa13ccf2076bf75a4973dedf056b5fb2ed89210e349a2bdb44225d0f28f397a63c3df0738df571b2f08e5a99da5737ad1ebd50dd527983ceb2cb4d9bf633c261812882480cb3f7a7931bea3832c5be1bce4dd9493c781b4b134623824f88055ed10bd3336bd1c51272cae676bf9a2066fe78abc9f16a6bbd81cc7eecebe8f5341de0fa20135dde142e9f30ac7a1eced2eb0884ed5d951c80d89ab09a03d91bf3273ca29c00fd161fcaffe2303065ca9c3966cedc464cb62eb213b99aff9af1a5a32590614a80ac1d93fea1a0573a859cbe71dc5aeaefd10cbcafbc53ea303b9ec3c2fdc538dd753637e7b16c1879a849c84353554399a975a93c6653c89b905d07766639554f23c4082aa6b8983ba7f80ef388c5c8ed004a2896147f7d434d23e336c53250d972e3dfe54ac140d44f7f0bfe1290fd02d28627d7a0a032a2e01dcf1d8c4ea6d8d71d26cc4c8d488452a4e2077ca9920a546a18a0ab7f73a8349a5f11143be1ae5e790828b6612ab5fde441d71fa9b309dc8df41ddcac4a4ece0cec4c9ff150c91ba51e16312be2fefc577d4cb28e89b94f400416ac19b5f0f804f18edde381855457aff5322f2e377bc78c1aa4c7b7e5ec23f6733300f9f9b08be652abc4245cf9d8c06b25deb76fcfaba19aec0e78e2ad050cae9ee779ee7ed8a447af6d9eb3171fd8fdc866312808f09874bcde45f0c078d9f6a1ec85f93061dbea5918a96b83988a34e6df5d6580ff9f246935c7c717ac878a708280f4134ca4ef3f1b7d8951d8bd3f725badfb6c8216bb5277c9de906e8eca282f5c8b3e902de324f4427d3ac99d7cbea9b1cfc37edfd2313a02f898475bcc4f8a4b5b6ca32599b92f56c2aac9ad21165391d9547a8388333b4229d75b17718df21ecba393fc3ce6e9d73f0716556f986310e9f0fe14bf2ca5f56b0d423f95b2349e319fda935f9fbfd3d4370687288cc384263c26a287586ede97fe8debc19f543b206bf13309a4f7d5d97443b8d6d3271a512e1ee7a4d11cace0d03e1fe9b21a03f1e44333185a6dfa2437e3aebd21e3ee3945d2d2c710fd8d1c1e81f1b48577fa9a6881ad7feb73c85e8579e0767fa7631ab6712e36dba535d46930f121176a184d60a95ff9cc1801e175c037339875240e2a9a89ffa07b020b8b5766fb39835b205311f18d03ec1ca950c1d6690cb869b41e3d91e666843c57d4316b9ff4919bf6afade377e12a794f58d0ffca01737bc3b204a2318fdd99ce279cf8c43d7688728df9b157074b9787cc1c31e0a046e84ff187d55bdf08747b89cdebfa856b5ed12685d2083c838b59510439949fe98eaf45063eb22a281b0c8bfe71d551bed17e61dad49f9db2dea955dad705bdd663196f46af4cd2378cecb72d1bf56e0da8e633f0f0cd0b436a5264556d54baee880e1957667663843ffcec1880b55edd2b4568c6f3f0117f446ab190912bd8e2e8a353872beac41fba1e70e075e031043b6fbbf577b2aa91b024799ec969a2d90de05e4cec09849c4e4f71e12d5fb85c94d0792c11d0d3e7886c5f05d4124d1f6306a363931abff88173814770542fce3149137d976fe010557413254941d7b9cd52b65442b486b8c5e81f1442d14d3fc66deae67e16f365acf7b0d69117282e344243adb320faa685646116385ca149ea2e933b3ebdbf9b23ff62cb1f9de84e4207943ff55cd6b16c8e51e794a078b1527a4e0cc1faadf8bb56afea765c7116aaa51cb6c53ad4431da4f85b78b9ed893a554f2004bc07949cb96060b28215afa30c48b9d8fd9e6a6a2f6bd4497ac9fb6cc4edec07e90fc35395ce303733538b0f6507fb64725b0c4de9539795c25d3e9048cd2bfe82618cac5ae726a1cc20fd1ff74fca9c2e9e850b2e874c98c2f83d5496f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
