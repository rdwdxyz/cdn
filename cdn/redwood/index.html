<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25389e788d0230f49de05b41d0c376e2b46f72f4efe13bee3dd1dafd52546f061964a466eafd698d12e104d4b63af736d75e4b88b2af3bbcc2644e37918c4c802ea0cac2a294dabb63409d3cc65deb40189f7fd1b897285d4d1063384ac918140383152f1d19fa69781d05aff640d9b086755cb7431a0e6b77d6421b1a46245f0840061750e13bee465b4300c3109052e62556d841d1a13476ca88d86b384783f89ba0bb8a34e7684f47b27d230e08f88c69c3d0ca3a64bf7558f60abea756baa16bfce3a75b39c0e20fbf15dba2bea5f486bdb32a4453803599684f2dff788895058d0308324b8579c21ab6c7bf6e268fc72f9444f2eb1298a9fde0128a28118ce1254cdbc266a3fdd80e480afc61c4e51969080e79ac8786e47ee428cda3d78e432e4a17cbba822849136b52e4bbf304d3abfad6595f991a044ff7ccc0b5b9d7b1425bf1706c88d594fc97119a032c858a28342f186894e51ba1eb42000aab912db124b4b44c616df6ff4a92467961a58c50675a2e46bb77cec6bf480af8f087507c717489259949cf7d39afdc18c5b055b749ab3491fa39913abb8c1432b3ec1c66f40b1491907aa939a57c06cd7e2d646ca43ff2802016c8073be4d48190bb44484ed79f1a49bb8f90a16ceba2d6bd990f5a80d3a3ea4a579cfbca6e05d99223c0055001f93c9ccdc580db5f58f7310cd885ae7f5a99a24b86aebfbe2f483679e3b8fd7c8c38525dadd798abfe44e360c72086849ccc9d3eeb2750c98d20b05d7f0db592a1e0bad1c428bb9883d843d151bfda0c10c207f128d5bfc21a1e036ed93ba149d61684fd1ce5db1c7f3efcd5b09e22295c21ebf42f1b1fc1875fc13fffad9f15582d77f0115fecefca9f597986d9ddf8d6ab908128f3c9ee994f48dbc67f9cd62c911ddfe29773a2157c9e97481ef48599f566895f391fe67d44eb4bd502961b4b46bc040ca3e886ad7863c8cec6e472294a0e80488ab99a2391cbe1c41460aa91f52ea229037748b74d2c99394cd81d1e9a06173c744f4c496eca9fd8be18b94c85446118168a87fa78ceb02f532629f0430d9d48c6d03bca86ae9009134a9838c6ddcead46819f470910d45c84537ba3921c8f9500b98c75ab0addd1efd4911406d915759a7287432446d04aaa1bebec7b75d3751aeb24236596e8959631a6feec5007adc6b82cd7dcc14d61fbc00d3ef5d25a67e5a71b5e09b06d3d717019802a82b6642f694e5e2bfe960923d90c749aa07545dab9879b584509454fb24dae4b547b449bb126631763cae25fcd0e38c4ad37c514b8684a440a59a3d0cfad55d640e96e9b97d1a42acfb2a43e0ed07db8e2666fe46bdb374e1932c8d50adfa4c67242460997024eab731a028f20d2a3cfb9b0d91826199b3dff1cd22af85de0c86d233280b8d0fab84af9bdd799cfe984f1b79b0d4764e9881235f4b2e7c532d1c9dd768cb354391f3eecc70fd1bc27e13cbd97e94d0ed9df718a3af5f3ef7923766f812a3b9164a30a808a02f5209faaca9f6489ad4385f34b57053d49ecffd98a23685ae3a4ad4b0f6932fa1ee0e8e2967897b1f82a4dc0530f731f99fe3d2b4d3d135cd5bf633a6462548870df2613bae3c718618dd53702962bbdc08a82a2b3b17fa4db2bfefe644bfd57575bb5f78a8ef6638b5369f9b3fe46df544f3efba9cdbe799eb2ca71650b955f5b0a15c18875d46a5275e9c95d7f679bdbf5b7df4a7e5d5d33cdbe222c347544333cf3328dc513d3fb85e2d94ad112873e2f076ab32da782b09c1a21ce97817b3e5dc5d9f10bd4399704c2d311eedce2c4fc0f94e6da41c856dd9d88db5d837e6470245bbf4166296359b8a999b45dee9b553c04cb86e34a0f4aec16ef8b9c176e00f07d31b1d31382d91283626ce51d1035b45cc8555aad180bc4596b1abee91786e0306c65b62877a881e867bca6379ce49329e8497095d7f422effcde00878b88bac2c0b9e88d0e60ac31f19c6cd6ebe127996408d01013393494b450cee085b44085d3f8aa62b2ff85a0101ff98c0faa46f5ac37ad6ee12a7d39792a93e84fdc34b499e83806d18d1eb6d607b2185de2a705a4bf1b4b677901a3bd52ecde51f373b33349334a72abf99b6ecd40ef1bae9bd8b2a70bd0888cf886f46a2cc7e62fadc0903abd56b2249f303c5d914a370161a08c1f215bdf9d5ef0b358a0d5ced40fab7f9fdbcb6bf1806e83592686e69883bfa851ec567912869f51ee0dc088e4fd414a4b84c94873e11174e96a1e28eb57aec9015834870658a019b43152abc34462bb12189ce86f897ac652ae2dfeafb5137df40881233b26c0fc9527b4283b6e37d74b1e088bc059d0c7e1a23c92ee8fba5ece2573cdef0730f6b9db17878c446d4f1540f087efda8278ee1645b647480d15c422414d38c0ac1471289b008212842741fa41a770516879222cb6ba27e00926fcce0575e6bff6f8fe60416b163a58c478de43cc958c0a08fbdd84772b4689856725cb9ed04c3d49ef15a8919ce53d80f4bddb635a99480d055d6e134aee397da61fec512f039d8602bcd75a458a4df9671e1fa8023c218fb85808c640e7608dc6c01bbe513b1e77a282cb22b38bade9713142a675e33d49948287c67524a7e6924e595a039ac0c9141f1cef307d899a9a8b7b7847237c946255652c187f6f6c1a22c5e79ad6b6a1ac1403a362708c6a2ae0c1cc5102eddff8398df213698550d846eef1af5d6d5a7c846e0b31ef6e4f54ce7293b2a36bcf8c7ebf1b56fe963bebefde61c68d94d0854dceacb22a806aacbab53c66627075707062ed6f0decddbffc2d594c4b294be3f34d362baf8f77d49a12d278859b4584b83c706a2e079da4a6d6cc2aef8d0bf177c27b8019cbda2b2cb582ed49277407de3511a996afbb1f3547d3030da509ef7fa4ec97611bf029e25481d19ee29c9450d05172f944a94402ee7433e74ef53bc3cff119b568d88db3598875b817a313db3485d248f84a0e9cd2c7292827e28be207f6c06d55a8870d578337c9860961fb9286e68db4a18bd38316201ccdc6ac5034b80ccea46a6648762cd452a049544d8024172b0d7f8e1163bfc1526ddf06dd8e3fc7616e9d23319e1fc97c29af8e3c35d41d05a8a66e2f41f407eb7183b3d231a56b654c3f84fad97180fbbe9d683aca8a73aa319e24cffc946314d660414365c9ed5f4dfd6eb2d371d72ec6b702d75fd67783e5dfd59b2a6a76b8cee337e75af5085fc869a81f9ff087cf6ed5337baf3c90ffdb4ba85c35b913f49b43e3c9af6e4cece1d09bd54321b0cd62c5506a9d0f4e23aade02d974cb93c16e712c69e6e51608962534cd45977c10e2c550f421e349592586945563659a149119b546a18de59c5518439641f9c6a192cc47b65f93848c9ebcabdd95c961246a315000468f2dd2840d0710b02b99bf428aba439ce9c49c674a3cf797aea5fe274e19e3d3a4293b7f15e4e19013654af8eddb1c487e97a3964d31815644a162f1736946eca68845e4b92493e9ed281dc6c2566ec6b7ad89d6d618e781b15d8514afdb1414fab657dac5bee453483fbddecec38b8c103dc73b2dc9a4787044dc8e9e415cb79343193b5ec88455d68ae7be015dd941669243ebcd49a616adda8a3684cc78ddf6a6ceae38a68b3bdeb9e4f8cb37a8bbc7198c252c5eb250bdf8b0cf40def908b04cb37c027a2c6478c6ce9635b29c0adab5b64182e4ba9715f652990e3bdcdaca6b1fdb83d20d80f95103551d0897e910b6d93f18e8d910851f1afe0e2b7d0ded4aa7c1852defec60d71cf4b14e69b628a13786ccbec4ba0b95cd70a40d2d5de84bef74fdaeb425fff977d229153f3b89c3d6afa71787d37537269beb70ce488d6f7e225dca44604ecf2e0d0780f3a0d6df91826265080bc974300bffb3181ea716955e22a076e28d753f2a3e4d02fe313d6fb3081b6b1051a79a9e8490223d79c535538072f2b7a22dd0ecf58312cd430609fc73b4a6eae3a2bef63ce6040eb531d4c32ba4ea642b0506f7b1fffb53b401cb7e5901caf199a3ea10c9e5620d9b5550f7f17feb2d130fc2becc4e59628f888ab3552c1f2bf92a4d7829ab6b563ecca77d342d8938c94c52389eb77424732fc43179204834d94430d5e50117597d75119b70fa9a9ba8fcff4c73d1fe36b6246aefaeabb6f052926ba32f55e71950413143afab14b9ebc2492948e9eea88ead13be3296b107e5480db131271ad82657614db419e5aaed4f093241f1bed3dd7f8644315e9739f8b4e2b5f1b48dcc3790f375fd901c343be8d62fccdadec93fa218ecb146e4a8d8b2a5de80eee86d8119d0b9db0a01849be53f606191b01e829ac1daa86c90f7204f8da6af7c43570d5f4ffe3997c30d1719783f9cedb3787aafdc28dd0761834c94d67a63344d2e1c17bffb3ace20838c6af82eb0fbc8a4578b6088715d5edf89cbbcfaa3f7c13e2317340c95a1c691694af9ba9718df7fdade95141d80fabc7a3fb6c076b3085934bc611fb1b0956d891e8f9cf1e58a40f929017077c3b3a70a96c1669002c97e097e8900a05c0bbde25ef3172023d59911a0b5882d2f4c873a10d6daff30317e60c67d005871776df1982e475c2b08e6c2d8c16b03943f010fd1f9ea30f9e8f05b656b934e28304e6705fac5c9548c466cdf22dd4c800b7ffd6abf9b7c9792a95b0d48bdc84d456340db7bee862610e3853558baa296b5fd7c139bf1423f13345f64440a5b01485a558a5985c529770031c279b7594e8eabe53fc3182d2344c34f1462651efd5d2b2b9883c6992f4208067149527528669c67babdc9df48f6747da567c8b2bae35bad58d78ae492953241d344e26562f2c95131cf886e5e3f4d82aafb2d327329298c3697c1d3eef7625dcb22f01f490bcd3a51b185ce7edf50527f95e58a3b5b78613ef91c8b1d5bc3e470971833d9cddaddda40761819d22b7c1c5fa231015dc70160550079e35e042451ac52ed8a60296212a9f5d67994d431201955c2bc7460c797b52083939cfe9e538cd5762a0b6065ca6223c2aef1f9617608b0cdcc66748964783e515267a7dbbbf7590d3dc9a75ad32bdc44c91494bcd54cfa815e7f9f83549de09da6b80a0f19ce8d710cd72e71e0caf1ceb664be25994eceff80b425ab46aa0e3e9e8a327d4d65857ec5da0f3b68df3720542ee4137b9ff871af835a7ca920b6d7e7550486c8335edd33b76ee905d9804c7ab08d7512e884903f71b1736bcfa061db922e19e0b3484a10a0d570949347adb4403a6167433b74bc7713797bfd71e474021bd63d7e7440b0e4e13e4d1e1bae48c32ae3af39f776ab372a620e71924731b1c73e5c0e9ad281b323e52b4017f99e4a082e92e7291b1c4f96431f5b3cea7fe7a7115d90da924ba8a0478c7572e0e98506c36c71a51cc51ad01430b5c32c73c040e8b92c89f011a679eea06ab21895678a201d2c41dac858b856c0be35d85907ef0e8cdbadea4b42a53b567395415ae05ea9a10052ef47e6eecff1e049bb0fa52647e8755356a6571a5ce3a3847a32c3eeca0413ebe5f11da7ef592ac48da9b095d67abb8e7a537c5f6a1115cf44592981cbe3fc1770e6703be92ab4fb530a97feba46314ff84bd31797099d627ff9ca5520df195bad52c5c68a0479cb8fa87fc79f53c988e83d1ddfd8533b3cc8ab15efbbc0cd75d236eceb6de8b3fc5a177853266f6730fc5d1d13cae99dca668ba4922e7f23074c7b08168d76faa8bd404ff067633de56c50bf5d8825170892e108257d0be2446d9f3e10835c7d920b35d7011bcd5ece4a1323a5f7fdffb608dc3ae01c52a685a742626e0e6ae35cfd59b207ea4454285b0479ad68e5329f9e8e284355ca398ee7d385d6bbdcdaaaf16a140d255745f22f62d0d5804391b58dfbe2e26654677cadeaf8ea186215c7d237fd14e5d6d5512f4a8c9507bfe393407e6831f87bd08a9fd02cd47f98befa04a411844c92766c661a87708e85fa38a5772a8e5d6b65ebfab5789b0eb5c6167660d34e67dede12b95ab6d3c230e75fe7eb72442af782af7ac6b7ea89255081486b79245a9d9c49eb198eaf651d37b6622cc9f381589c6ca21bdae9e4748e8d952c96a2e0af5511bcd79a1ec1c916a71317e2d470a39df726168c806acd4ffcbd3fb864bd5519874e86709f840a7045f72d0742f4db73474e8f6d6e507a37798d531ac957ffd1b4316f8e1b9e78d34c50aabea789e5b5a1385f0e8936f251ad105aaca1ca8e9ba5abdd368c3eec95ca368c02a7079df60add5c6b5bded5570316fba1de22258a1f0c30808217bbac294995d51d78d212f20cc2fd524fc031f15cf5d9ca8dd0536cb9296b8bc72b1c42d420edc7fc6cc3d2345e343203a77225f187c8554452e9746ee06daddc55ed9e42835a7416747e9fe620148d8d6982aa3f8330cdda5446c7e344ebeb91ffc22c59308b46a3832933b7710ff3e8c8dc650286e0eae84710595992d25540f0e6c44f6d4df31566750964938f0c7e6ebf92c194d5e75203ecc69f7acf362e65cf4e8eeda83f269d4685ff9858e7fa45396af6b917297d7c4e2834c8cf2882ea3718485390671685212efeb0e75c38a07d2d1f45fb5ebdb3b2e9f1746b420dbf6c39c832b1da7ae6b627781c8a4f62b651d52ef6f5f4324273074d30ae7a94be573eb4f77c90656e3c5e107c9eb25d567b5e3870efe46d5d2c4957e770ad60695f8a396a7504a9aaddfb51446eacdffe0aef0bc70cefeafc527b989bcbbe0d894c28a459aa428678ae5af1acbadef4c9422e74787b76b5fb7def4d3514e24d08211fbc9d4b1a7f7a024dc8b4b5f3c64cdc2b198f874aeb6ac143361a0ae7dd400d2a152ab035637b83f4e0283c320632d34783a13f013cabb8041a923a379db53d46df8c7ea971390deb766b4f0be7aa71bab69a534e0ab0deda1f2825fea60066f27cc73ea67aa955a760d04dd65927800c97904f5d978eb2e4ed8dedd6e9572d024984b1f1922e5b19e46b8c2d0a757ecfe55a71adf8fab81662fe66591f572b8730a6200514c25c22d440bec4158aeee999b78a5c07d41d1440959628d9a9303d092999914ad958751bf235bb04332b40ccb8f9816954d9e37fd3f866c1a0401f1d0d9510e3687018f379314af4a9df556edf86d63ed56cbfba157ae316cf49007dd3636b658efeb5148c868f3b87a811e9e8bc217f0d21c927f63f1c65bd67e76e8b489a22533ac45e6af45a55dcb3511d186cb327b354c1195f848c948ce254bf6bc311d5cc063ff617dd360bc7c17508d6b5680e1c78269366d48c9d0c00c02f1268d31f3520dce8f4e129724b372681832547b22b2e7065237f36392e15ef249ee24310ba311beaeac89b6cf6b16ac3a9c8b45a4a78f96a58d17162eda24ce76fb258985a195fac43c2a344162814ba1f183ec9009411516eeb87405a79a5ee47a4ee87b460876fe6d7bae4ff52847709b0a14ffdd48af30f198d36d2a6ee3f8eaa1e9a5db584c577dc64d0c54f613d9943a639351439cd24ac9e8f67401e888789338f57e88428ca009ddabaf356a1862249ebbce2fdd6fc3dc073b912b961f40935420f99ac62b95d296648ea3300fef54dd5e68cc264b2697f7ba21309f1fe50668a53248a2a4b490f9fec9c5b935ff610c50aaad0f04245096620877774b662780174ce10bd3519f15bba2d18abd92ad6f719e3b26c433e31da8dd1e618f28739a40ed2c2b3dd0a50c47f604ac4591ddb6d1a4caa06bcbbf47676f9a7e1b3553b449d6a5668141b6f8b8d00785adf2c58ea9e4f60aefcce413d976de2092a27049e4471da4657328c236b19b5f28843b2fd782ff269dfd059e75c3dfa92473a13341552fd320374cae0bfc7771a3056ea06b522f836cfa8fa1f4283e9626f92c590d625ba8578cc058faf268d282b889bdb43652416998138d5618cd3811948dc8c4320ff98ec609f8cea6b9a764250c31b1d37459ee6f57129c50f750a3e2594402bcc16d68ead4304404646ef9966f130d2fb49767daf5117491b22136bc912aa1c5a856a6aaa681e12fc47148bf38293c7853458ba3619ad8c5a1755479762814f201204239de092c13c139cd7eee4a9a8ec4b192053da8c470700a6c570e0755ffbe793b0a730923858325584c01c354bca373be17f0c18dd46dfd707387fffa1fa2633e225d14db22aee67f57d0181849dde1f7ca9813352d95fb87f4561dc4b71f63cfb8e41e917aba1cd603392921b179402e8b6b890ad7e102e36f5da8afb072f79957decf34940e2fe81dd598083e55931c01bc3f9af3c4a99b8e0389297424a9ff358b3e4cb5cc00c240784890c021edf7456d711be54a00fffd5c0dd3b3f7fb7fb33eb94d79b8410c9c9f272a8f4928abe2e08b469921314eb5dfac86726e3cb65b67ae27f44a9bfc7ae22dc925ad44e1954e20fcd592d71cac234c09ceb618207e933a667e1c4e5e9af616d0b56694161414255fa046889b61880a5798473950b355e6c78577ee5809d0caeb95814f6c2f26decaca76a7eccf65b30a383460eb93c6c492064b650132540962302ce8342c9baa9b93ac6d590961b45256248c01f8433091a7049048dec724d40051725305225be97ff24199cf74f70499a83bd55415f8348cb6842123090905d8851da88223ba0c64d622ae3cdaf14e731aefe6c10c78d5e79f68c36d266bc97046f253cdf30f4e8d91976819e36a883b1182b573d01b450c0b3867e000b8a567d00adb8bdd5312858a4f82a5f9efacb3999b600a2ff547bcc27c3f8994d17b209afcce4b5d1538aaa985ceaa3dfc714b61e8f7eb19466593aa93cf4d019589b4d0146ff290eaca9fd14a02067f758f1d2451d6f3e48fc1f247111eadd6c0f05e6d528eefa1ff1c02f17f1c6754077bf89f197f139332e4cc7c9a02ec0dc1136697e4e9ed78d1cc569c9009144349083940e2a09ec8ff3682ebefad606f42d7638d6f13f7c8cb2d15ae4488fa4d556809574fadd0df0d2d3c0b412b7c600a88b4ec04a2eb0bb177469946cef9a0692de59fda4a8c339f589859c51e33271d41d373107b9417dc6c40f46bd5a31b8cf7807ec22699a2a5b61c468b470b87b1058721e55eb2812c7bed966aa821c19eebd7b9b495cc96e5a14cf340d55aeb0286c364847b240c04e528015392bd4cb7cc8db3f3a04f3f5167cc4c984407ec66cb5a8d952b184885ba3f1352ea933da0b8bf99d3038011b0504fa2ae44c2b111b7d3a677c79a0e2ce469b2f0be69801813859440b101e8c7e52a6052c21924b4bf24742967f9e5f5685106a7014286954f3bb80404655b4043e7937c249532d0a9db37ac52f31599fd3cd55b2a071fc61ed3ea5442c8d78337fba965345ff70f303f20b4116933be3d5e36e6de0e4dbab0ca8788abdd55f47f79c40fb1bcbcfd8bbea47712145c25f98aa651eaed8f6610835e4fae6df9d2a2bcd4e510e2c226a24999d8855c3f7654528576048d86fb019ddcaed0985f3339d7a1d8b30aec8b390f92676630ef25e502c019ab4a3b219416ccc5765544bd98d391ff9a6b863eb3059e83c3914bf25be16919c9acd9edeb732775075d44b9d00d18dd253d9c942ff5453da1d6a14509e7d0871d49f43c040b6df997ee74559892b52fbbd4f11bbcc5153610d144d3f1202641ddc2ae5117d5d495d965551ebf988ddcb05e3447e7ab8f9d05606b4cd073963547a591699c539f5f98a271c237a9428412ba54323e7f8d3431bf25f04bbe62d6fc43bfd2b238c9971c9f9ecd21f2989aeb56a2a3c706a8456d60c85ea4c04760fe57a590a7ab94e1ad948fc97aed5f114017665ca84e0fae65752dc0003618fa51b6b2759953ad3ae0f1336c6d5f1b08fbb7dbca0f53cc7e56e1894627e55fe2f39a077ee1ecbd129dc7914b3ff8184a5428d03b64afffe1c7ce4f419e3362047d346e7249fab3f0d568ee4afac89ef3234da18f226e6d18cdffc20ede7925537364c0ad87a373ef99e34918a957bf16b840de776c7dcd19e27c85a95e09e5b2ddc0a701ae39273503b28a27910a329fd59342f2502a74c7cfd906d1fbefe4e42a7e3b315738d05f02d0af72440558f661afb44ef94132b1e98b13174d492d552dd453c019d45adcd1c229bce5a08ce8b164330652281a3c546cbf2125a4723370f4de4b9bca21fb5bbe8df9c1ed59339835e2d9554397442e2c8992258e09774697ee1e0eef4f89f122e80315cf231cfdab5045d2b03ffbdb4aa797c2112e02fe36e55e38f40d783a935a20e9b3370e196bafc649437fab56fa36e20b7dccf394de1af97d21577fdce3165eef6810951eb6f18fc8d351197f231d4fcc5d2fcc8c5c5f1fcddf9f470643ccd19ce21fd1dde0fdea6db1df017326f9cd81502b9294cb168eabf856d2d78751dca8ab939902852a7531249964fdac840ec71a69893657fa29cdc38abb07ae32a7d10b8ea3bcf74139677d46ea374fb842558af1f7272a65aaae86890574d6d78c466be6cbc02dee824cf2f656e89b5946139c1cc7847c46ea17af4b22df88a74c6d2c32e30673904081d35e22c40fad7a51187bc5dca662511450a72e80418e2d010c1b3af1e7519a7c7a53c8a25c17ba93a30f51d6032f66329c6d2513ecae5b3bba689e0c0d069ed1f22f6dc6f01babbbf0217776977352086285f410f9b63c7c79b6d9c8770cc5a271482351e2cc2c66c43f73163f5c4b548f313b29f02d79da2706935ec3a83d1a62f0aa8a59ba713c6a78aaefcc100250c6cf360f970e1e29cde1f9766e93e1c2ad9c57a7d568b1b6e154a1b4510fa4427b6385d68b74d55a29d7c01bdf0e0f5acd85172a870f98f029e13ebf15de0836bf261c05f02a95288d44012e7170a13eb2a6db44ec5d6c7b84cb651e20a3348c4ed9f27ed2d03cf204b3a187db5bbe46c9e7d785dd336944ae4fe3f62b1a3242d461da5b2cea35bea90a220636597bf07a8422d087f1ed4f404131516a0d56cd5111fd4037b4a53f953d8c2da3a646a3496fcb56be1647c8a2f649ff693992fa24db75e586e8c302d654b996ba6592091d8d0202c3e6307bb519007743db362a474c03e5fbfe21ded8d5cbc00e40d640aea9951c8563db2981ceddd8c7ea9333466d7af136b49917d7349bf99b9bec5757c9c94ffbd2a2e1c1f7261adf3e2682a4d9f76960075c123e72db42b100f9c6d956f3634e5a74c0062e09524b35c38724fa9507a632d3eb37de74bc41379ed67b3f69701d54d5fa8e506c37807fa460aaf343b173c369ecf090a183da556c15b28684ba44991e02ed40d5f3db983213f33fe5854e7d1971d8cf2438944f4c3d4b58879c20b1b5a8af9c869081621f8c150e324f4aeb70e1d027926a18afdd332873d9939ca2b8e8f0846a657c9b91b63a219c6ca72888998a573739a1117211d5c6babe3caa36b0e9b060cdaf500b2ac8b507613cd354f39575f23b52867d2658bfe2173acacfff1ecf8c56674e8f954cac3708cbebbc98ee7b4a023aa220cc078cc6ab66f1717202ad4a85843c552577285602b1ebebf4ed12a4d71042d0814ae13c6210e72aa4879744cdf4f534b03d3c8e2676479405e92746ec8b41e36eb130eb6d1eda197139a53944ff7016ce2467ec9605a3d26ce85b28c675bc782dc814cf0c4a6bdf4028e4a185f8629e76f765083bbb7e7ff4034eace469a0bf41847c8a71702ce2188dacf10d0c2bbf88d063aac89c5518a3fcb67101d9eb905096021e4603b456e9e07023b9a26595c94f3aa5cc22fb34d2ea284bbe77c0c49981779216c00eb37e845ac0135b0aa485c894091f7a9c2c42d0f1f8260d4e5ac81d0727f75283b026ab099ef1ba43afc6d481499b1021b9e8e7f254fdeb460e2f2414ac5fb350e4f7f2c35d18dffbff0bdef40d4012b333f74893d3951131d6002d8918e7427b6b91ab6c03d2e020c2fb9c11701de15376053e1f73af2ca1d3a5d30c8fc5614354e8c5383e139c261970146ab3a2758dcabe80720b37cc1717377e4aa08ae5e639899ec901730f82c55b81fe6afb2effaa3e25e832b7b418fd1c9d177c6bd2dc50958e338dc83509e5103c82c0c9ff108793a5c87fcd5ce91f6b0623a3069cb9c45c9e0f11cc14c99dafaae7508257f5d93cc9183a4db669728300ed24aa13a77cb19a06101c3712ac25a7194d08852136531e2eba13e06e1820153d73024aaa28e2ff4bf33a3eceee0712a39c425ae9b49c2bacbde01b8f8b4f54d94faf124b14f9283b7a4fc2b696c37e0c97089fa0009d8f990a244b7bb130034a300afaa1977cc164fed7ca02605b60c9e071c2a1d8f3bae72ab2e407ae613b3f53e0eee2a4e34cf1626b641cf8b876b29aaa9655e43b841efdf9c6ab968a40c67956d3c8710e6dc805aa74cb1383185e36dfbbb2dd5a5c2270cc76db8dd9bd7000628ea3ec2d346baec253099f5d7396a732ded198a43d085bdc8548a6f1eae8f487af9e60b129e0a1ad4595e6095d5174b2c4a1ad7e39be5ec8601aa7a5db3c5a133456f997e45784aadb4e5e5e7d1b8cb6f12ee8b4124dbe93b0f9eec629301836a37a5a9e3d3b3ebdb949761737a618900d3d77121306c3b5647edb0efb4476db5c301334d8beb808438e9df35bd28cc626176826a2314a55301d800831d0bdafec64021c3c9a4d771515dc5a3bf38d0242f9dcbe70dfbc14c6db41e45d8d11b2e1761cffdd544a1961cb23b58b6c6e9f6251839b589382a4516de06bbc894b2d621554dde65e5f782af8cbba947cdebb3b6296f5af66011a59bbe8a9e70980b28055765fcd3ad46e46adaeb9609e73df784a5a8a5cd29caff27181f51a3ecf0887b83789b21748b86428387d0e21fe941a1876d3a4011d54d1bdc8be52707043c427a39050f597ba71f44bfd3ad328b05e47ea1feac0cf3a46590c03f1541805498efb47cb244046d69044cf34a4c048ca5140e4120993cb5b07add1435fc82551b270b714e8aed0f557ea22f254224ea0697ee7295e25a97f8a03e83458989e95d1cda71d172f989e1fda9ba1ca08d2b06fb0fa99eca6de9eff3c0a96f5358bb99fc3a626840d67a7c42df155c5375cc50c1f05d0acb46879ba263e7747802d34ef8f151565fd3f673e6b0762d5d4b2d4a7bc58d81657207cb34af80fb27ca7de1072d8c204e4931498407f9a3cc7d581728ce5a8864be332568e01f8c731e56c20e3d9db586cec96f0d70714c1de58a6fe5a743cb5caf0328a883ab03ebba72246d10cffbfbf885700db5d1588e40f2a298364aacccb8aa2d325c4381bbe833abb03a9b214672142340c1921bd225b0e55396bb1e52c750f1031dfe8149871afab9e95d537b153c66055e5bda3ecd5f6ea4c11f3fb4a994410b0651f331beed3a559ddc0d8bc073bac453fd20480ef3a28c82921e8fb1cb8b3495393ac76856d8c9928ab97bc25fca3b761f172c7c070be08c544ffba175d3d3012d6d0a2416050b2908b19e1fe82b0a77d0fe04d7a32040c3639b889b5aeb1ca8ce9da3898881ff2bcebc66852de79d22975969828aba36d517d4ee93661c784d099647371fe2dcba03292c40e0093497ad6fb8ed4528da560d83cad50b6cec46fada87daac3ec65a7c7a32a3b0d932103482540dc42d9bcd4b4d32ce471b73e9e2a8cff7db455da660e2ae5d7fd93691794875750b7ac15276b8ad34b82c6545b1bd19935bd56c8f22ce586de8107acca03ff3b64b951d5d1245ac31aade368ebd849988b1ecf0ccf24b2e73fc3160733db7064dab57ad4453c20ee8c063154585e9f674c2f63aab83ca734dfd3595f2d1d7e3da3466e439a84e4ea45ed9427768713cb84618e025a1acad701570de4a25b01adb5f03fa8e4b20778897a2b0bf020524891e6ed63be88adf0e7dacce2e06e4fcf16ee20604ac9a3c7b645d29c9115060bad901992e1a031e308a009c9eb7eb1c9cdf5fd6467922672e3d11221f2eddbb905782a1fbc1e2ec9326ff69b9eef819183fadf5bafd2503260eba24003347cdb9662f96916bfda22552fa2c4265f33b396ed2426206f0312c66562e89b3a3582bbac34e54a0b5021f0251fb98668e9b877125ef84631c474980597340174911bde46712bb8320fe5608f5ffc92cb7f8fae04e7633e97dae50263b753a90e8ff869561a4dbda9d21c592581482ace23b57fbd11a213fe66ff2c8af144d60057794d05d84e5fc2e512a671f06b0e3bcabad7c745575707570ba55a2ada004a4bf19f3576990a22eaea246839bfc2e487bbb310c275b6e9e01f09e7b23dbf9269127993a10fafef03b497f9f438cc057b4d15c86e0809de7466789427ef04247e867406c795514ace03414d1ac24689df38099f56704556894e8a86c2a15f65d8dbacb2365d96dc0bde2974dc1e8bc7ac8bb5cb84a696db232846542a6a398e7380e6aa3f6dcfdeeb08fb56151777cd3e0672ec363579b4a26ecc429b48d8ce79af777b4ed5e2fc3228737757f5b00f200e340c2b465a1690aaee83f72bac3fa2acd5cd2d703f595a0dac67600a77a3bbcd5329927fbecd2fd6eab2ff5319796c24fc16b15548f4268ac4160717621b11e79007943022f702ee9cc58a91a779e1ac74ee134d2b90013a13c17dab5ca493589c15ea573ab1473b2f2eac020a99b76ae4bb0ebd67948a24ca8379e68f4ff12327b6beec6fd6b53c8d7f6908af0bdb7926662ec7568e570d79964dd1b3c6d2ca226626dcfaff4eae7b18e13179c017ccf6311f9f86683b5084cd8d36e3252c7d1bacb4763b076e9ee73d9ea9b451b6b64cfda54710c13f4796786fbd4e429e90ab28308b59558ad0f003f56f67edeacf98dd5db0791c77b2f9d190d56e07e70aa8a8bee38f16c47d610ac430308118c87d4ec178148259ab74e54fa2ae69c3cee7e998895c674ef65e5efadb1ddc35a1005cbfb478f584bfe82fd06f48781f4f53702073a9eee1babb823199ec69b77d97b1db48f8732eec3a69e939c5c1e756e69def7f50d5844c720344fc5e4a17052ca4fce29bb16cdc4afc5869e96da83ac06a37a4d09bf8f7e6b22eaa034f55863283d15233fc5e390162743d1584b588d63400438f2fc43494cf430242f267e621a9180095a42f86ba7bfbd7d8a7d310fb16530f812c73a90ac3e19472543e00aaf403c1b4c3391d5f3868191b3b7fc6353a310c3fb8433b702fc79e076450407d9589bd7402e5bc9b144c3dce0c1e79a2fa6aa5a124179599805993da73cd1d8960c432398dfca95d667659351962428419d95cfa3e57d3ef6a8988dd88c3db3ba5dc8fe8a4be6d5df39f47e5cf2a717fdc06a5ec22d0cb32ed5dbc78c656d9a7d05cbc3b311b2aed56f59824507af68bc3e744898adec268144b1da71ac8f6da064048d071dbff0d6ba422d547c5e5918915a4b627e440f555e04b66f906ea0637cad6e847bbea581500e2f32ff61f66463758109a24db3fddca5b611f0f71cb1ed51442ac0bd228800e0308c4ff4fa85037e29736be1715de473ed2915165018ffbcb4db3ec4e410307420e87d0795ac426dac5f9b5b3bc6259db9d3cd773b71d34ffa6f989ae1b0fa0c84c55faef577834186be424502b84c29649b5c115787712f1a5051bcf82da6a1defccb571d01380eaf49caf9474d03431cdcdef1b1350cd16bfa0e9ff5f6b84aafa440d40b1f2de52dc92dd243020e41eb4ccea3eda8659c4ecd5d8e4941195c7556f5acadeb66998720205c4b9387e3e7e34ffe13d1cf5441f14526bcb3247d2c9afb8b7080bf6a6bbf1f3f24d40973c54c990d79d1d8eb2c95f4fce09506e40ddb018028042ec9fe8ebd9d06f6ada530884b31bb4652414a2a6fae26cebf9fdc63a6cfd403d9926588d6a32d8f5d83242a32f72bfac0cafd95f85c05be5ea1a3c58fd17431b214807a7cdd839839f49ff3de9e0393f5bccc85baf8340a15531bc4a3ab1cb9ef3557238b13c085e9eff825a36e28b76ad7100857908e0bffd39d369f4a4500c26bfb24bdff541fbe270c5e6bc0591a0060f4cf150e121a94f101dad264f35f829091ab677bec79a85007bbe9323f6af2eedb784b7dad18fa9d6ec6478c08a8fe40abe3e307467a86772e17e071face85304ab1efe4564b95bff0aac577a615620be7a03c22e8011236c5d7f5071150d305c9707350173b196ac4fd564194102ae607882fa30aadbdacb47d3203fff51fc7e8d8c68b853279b5ca9de38426e38b05546ca76397fa2d99301017a9349f962c830de9d8a53afb11c9127e6734fc23662a1ae82b1eaf3e1bdefddb5c3ffdc035027fc5f0cde9549b7f2fc669f4777d3aef02d02b2a877c1d7279bbc7b471ab926d12ec925e2eb290e59d7491f570c7bc2858f7d602f26f97be0dbe5107879b4718d7f2f02d104f041412de6540696c4058a61d47359fee0658083a4792a1e688106e4031ab677b62294254d8672f897783836beb7c965c5d0fd614d2d1962af2e65dd9ade85c35e1a075b0bffe87b82d05823671f3dbbdb88761a090e1db4f441bb4346905b5e8ef8519de4401cc17dffa1a4e1bc9d49c08b494232e612140093fc938876b8643607667a8c47760e3e4a6f3c6f603a8cc83157aa6d3402f6e649f100c686d0598d44cb3e9ff6c4303e7507add8ac3a4aad860d672a16477374af6e37bfca9f44189aa363e62afba5e74dabea8f95bd9812bc564692e4eb26bac3264d75a88bb1754e07f978f50e2381564cefdd3499cc986457a6fc84d2abaf1e32ae4e1b2f8a790362e8a3278ce5e5fa166a565098c5b73a15bcf60c808d23223bc69f7c79b88e5f5e0cb1e30732459cb3da0cf45c3205f7aa3c365e1df7bd49a995e09f29a454b740dbcaf431915218b1b5a8c3f2f337fe31577cb97ab1426e360499346f0658620d29372f36dfd74f5c631760ba66d043fa01797698c5c2a9dea67a861b4248c7cc81e1430ddab4ecdbc86228f344174122e91e173fb44a2280b5ace656e8b94a6512d17bd9b6fa154d1a2b855e9899cead8463ff236027b789722530105694e6fdbf733cfa7d171f53c20aa3c06aeb22ea88f4759daa2236dfaf3662dbba7e6affc52be5c033de3bcd4868675d95783628444ee668d33bda1411e9ad15c3c43d5418a3825e7f0f3cd76808bf5ee51908e83ac8e0930f6d055ebf0951aa2d043608ac31501cc079430a9f9274ecc31f0ab530ea1ca8140de559bfd5c2f5aa1ea91226fd63ec4950389568b7b4759ddad337905ca3fa830081f3032e5d5eefdcfb788cd257dab6abd9adabf3d9e6b084b617134d33dc16a9751c3b1ee736c6cab2aded8aabb590807138d0c3de6437c7eb7538ca475957c350a8764c22f7e470786f3344f361a517744bfbf777383b4877dad8005efbc10e60318789efc44974064c6aaf1462ae9cb92db22cabb30ec3c757b19663ddb43a48fec6f93af4221fc1599b7f9daa127c9e59da43daa66a7ec4fda8ffe4f3ad85ba7029b52f3a4a0f27e6e42dd26d1085e6cf6c8ad9be7039be0f5b351b8b804e1e4dc729c236a9c4f40c41bc21f45ce146f75e3e3eecae63c5d0e4e2453dc2ae9b424396138888cfa15e432ecdba5d70499a04efd0a27afa1302252394aba87269930103b4d077c9351171dfb82aba168f5d576ccbe8ec847c5907c602400a43b2ec726a140897c1a7279ab3993b8710525ac1653a4ee5617be6dd9ee10bda3bc92bc0e84d38dcb877183465d6e7a141062d5254ee4ae456267684ebc6164fbc26e429ccca68ec11db16bdeb26173c5f90968c073c418219a547733789cf9fec050d4596c0f9649a95f2b0e41ee8d300804ff9348faef9eed9fbe9208bca399fe7e0fc3aa4035114221e82f2a05c4393eaaa0298a0d76d7102eb714341a9f970c729508bc886adaef7bd4bacee2583a9a355f6be5522ed2b4a80a526a6cc93b036b0ea7bc07f71f64b61d3b6a899fb16dfa5a88fb70013dceb8526b6d04835e47c3e4c64692788714889b8e33770833cfe65b3c3f77914bdfd8e8dcca087abe63581b532ae753b36a37f14ce10d91d0503a511c43","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
