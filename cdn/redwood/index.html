<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a99bb6f2d2526049e05b857486ece1a8fe4e6b5e1f85818ca0e278d32b837de22de420063ec8e7ab96a718aed1ba373d7dd4813e086d74068d3eab4abde64879d3930bacc30f6b71280b3e837a358d11494bbb3c951ca2b56a5f85a9ccc4361b598a10fdbfe36e4c97d35eb34db47ba21a03d30c7ba0160df118d57bbf6ee758a12ad9e39abc30e0071623ad67b7fbcc6fa777d6ba315ead232252a7d7d1313fcb3c4adcc7bfc542bf7037c9bae0e42d57c8cfc4c3c6fc010c41a66fbcb1488dad5cee676efe9fe3b2cf221fa3b14eb14a09ae9099a8f8a7b1ba3de08f84187f448ceeee3f7269fd62b09f68506c47e755e711c7cd4e7f56315c276227ea92912b06c9b58b82e556335ec6cf88e499add459e21589c84f37dd6ade226eb02f1ca00ec60de62b6726b0d7aeb611cee4371f4428649816ebe8a277ab3851014d185503b0c1e9143fb3444fddc4d6909f234cdcdf6927e111c926232e018d3c5266ddc26197584c40f71c388b08c7b4e0d5abb176c9712c196267c70cd735c2bb2a345445eb0b759fc7884838e5230c35fda0ea0f6590d39c431053493d32c281f75076f712b895db46efc85fca546cbbdd01b55f983f60389c7065c1318c4b733aef655f030555efc122679f774d2df38481ac8386108a97d8f0ac3906d589e21182ab5d038e63d2f354a642630b246003f30db628a33642b13a33357dca9c346a35c5a6c3e359983ca153c569bb885e56e9583d8031b1f69f4db0f9d74d04a4049ef9e00d31526ac8448867a05cf982809e713417d93865e6f8db2b8dc4e6f8063a79e006988c3b018026f7ecfad9559aa0f432249264f49a095b68e51e737b2fda8c9fb81df487b5384d8a9251a5c1a16721e74ba8ebcf096e163f98fed250f2b20ee98ba2603b5bf847762fe12ffe9180a0bdb44c8c5cec79300699c9bb13c4378bcb6ffb0372b90e5a88e734b9712467f4c58f0ebe87632db09e2a3d3c331bd581f91b247d9367fba0814db899b517fae3d508321687a1704804826e5ba328a827cfd4c133e13b3f006a30534efeabe913cc6aa49c946dbf178f78fbe6df2c9faaece6ecdcd2ce05dd4647af7c532315cf0a9eb9de0f5287385c50578ad2f2ecc4848a8cc9f42344499c05cea1e69bb6d98204b5ae143eb41c36c5ac41c7352d5596721b9566bcda74b1ff6ff13549fac65f4a37fec48bf3e8d3391cb236e3e2387d4da94406f32db4d0eaaff975971ced38556249c0444b9ab581881b3da77e393f0d51672e94c68e31bf95dd2578ccba0ff2a074337ae6e7b998d676a7f28def80b2e657ee81c10af41e1602ad25a6fe244496b0d654fc38003785b0051f4a052b053f297a86ba0d13cc9c469b135d015e0f345808df8dddb5ee840bdfbf3bf9f1567cbc6fef9b2324399eb268b1a922790df59593275ce2356c514c2f52e0331f787c8eb8484486f8ba0caf6ff54d892dfc81664e1502fccd48dee2e961d8d2b72d307054c6e7d0e546f134dadcc1a387b7128e1e2106fab336353747fa434b9a38a0759ebe837a8db2fd3c9173d502483f042340b5b6cc8cf38dbb9d9abfda64984c9fbd14fe6dadbf68cfa91eaa889962af825968919eb5fde7d35ac0446d1ef2c4a98a6bcefb9da7fca146519ad9e91d8f7dabedb3842c9a72df45ee8b7e535972aa75ae3fbadb81551d4545d187a321bd3f61e1cd2eb02e6953ddca5534a0dfd03d002cb15bace528366a2f82da1f3757abf680dd1ef7119684e5ff8da160e6e4e256136fc041e977aa57b5624237c0c51eda163f3c4605b02d2775c91371fbc3ecb63e02f4a4c3531e78df99d2a655646f5c6c3c60a50db39d324e33f42c4c8908a6f8812c7405db7ce9de842e5d3d4e5352c8b1fcd052109e4c0951cca2db0ae8cef5776090b4da60e3abdfc097672961a2963c6443768adeb0bbc278ced04c7a850dcb1a83645f5e29866f1ae639f26ca91c7d2788447786da75b149b5793286bea8cb9597fee79b54800b55689377a17e0cfa2fead2d46bd65822e42e5a6fbc7b3794b377904577a7d9f0d3d437984e170aa521e0215caea55ff13202e46ef3695034cfcddf0833a04cfb098f44f7d0942ad166c70a06c8577cabc7d672d4ea6f15f37a119b38cebfff46dbdecfe97435844853ac6f34c997ea57e1d2f30863848047ec8a2e0400afbca8cc424b5d5733d09d752f200c76a682482b1e0b63d6318231bb5a673cb481e9404bd61dc197fc990f2ebd15eedc3dc2f4d3a8133096b9e5147602d85021428dcb09772b80c6c6755a6b0464d9dac6a10f2c963507ad982d43eadcd7b9c0fef2e22c3e2cd1eee5c53d76b5dc553723702484a0f8b3856a893948af8c00b51c3e572cdc6c788a3150ccc9ac5fbbbec19b4cb07ce61812bb54fdc7985b7061e72a18178933236d84674eafe8858eed08023a0b3f774e7661ae7c62d2bdb94d493912b8788e9157537d6f29006d17d86e1118f6b055e7777344752298a7b7b7f13ac99e4a5e9607d65a936ed8d742830b952839b9690f0252b803a28d815c6045c3a72ae64e6dc66236e6f8e4fb659b78b4657ead3204c2a74584e6dba19bf733cc5ab077c4a64f809c5b94b4edaf703e958ecfbac08a28e4701b008d70e017d05a64f44722a098a3efb3603c1770696522357d62d0fd3b16a140f360ea21968aa8c81da35845ec9b4b4f254e371e7067c8e7504ed231597370a8a9a382c0806315cc41eefb04782108ab24ab78d89eb38e8bef59d75c537e31a2ab333400efe92ac542522ae9b4f4cd722ab881b70ebd2ed59c6f7e9e30352a7b249048b789ac72937197049c0d848e07ba2fa5fbc4db3e73628a17ea04d3795406664032cc92a9e7920b3e165a97fea960df8504591deb6335fb47c59311039e6793427568c3ce396b9f0b8366ada84c2782b6231ffbe89c33692e148dc4a9cc57ffd023d0c6fb5245763f7b752cdce0b148e68e698db90a64f78a285b9121174410c9210e49a55a66368ad9f4d60f9b526d1d9826561cd8478c25c5cdad08f70ffb5944d151b518c3b40f33059e57b52dd858da656079f2d3cc4eb9a7496f38624be923cc7c2ea9d0a435d4933548ab573f40113456e5df956f10e33e67645b1c9e9ca41e2149b2a0135030170df3f7051aba4570f1a4137319de114eafe6ff56f7068ea1c66778ce645212673bffffdeaad9faa38e2ad8f767c6a3031c2d308f2339f27f23f02a209e1ff350c9184567188fe1a7d5298e475599c44db242c22b8f486399bbdfab7030d5f7909ca1f97b65369b3ad13b97688fc2f4e202dbb91a0ccde7f6b7654d0db6e5e675153f2d1c5231a6a1bfe5b76932c7eec83e9bcc08782d67d9190e6811faaa44393b02ac6084d1c9b56d721cfcc9f25f38a0b85c22178051c2e1fd4abaae3a6ab059da7c6fb80b48f4e2f3c8fe7b36fff0aa705e6cac9d3cd99337da95e60b839c5a936a7f8ce9a249311a1cd65a79e76096638b98154cd6543b43f344dcaece32e0782434a1bbe929dafa8de96317a5c7d1fe8048e697ec96fcb7d9a3f84d6598f4005027ab89cc536988f60482b27059a99b9fc83e9803c7a1ecd22f6b3653d7c274313c9321efdefb9b3fc8524cf364ce1801ce4f00e3a1771fea2ae1305e1290338c952c1fee5f1ffd39a9cbc6563752b936bfb6ec3341668cdff5b5a304d0ea8b871c7d439e78253a0f7a141db8fc1887f1a2520919c74fca199d9f64aae1b5f7e489299325527c40e92953c1e85d648dadab0ff025a9d7f7ea465fa2966145cecfb9ce0b8120c0c622b4e7029d8a085dcf2eae5e2644cf2e340e17e0488187c9d4429210ac1cd4e128e104224853b1e0092d6553144eb5cc94599e294e76cd093ea757692528243ad5f820bb6300cc8eaca473417aacdba40bcdc757ab7fc9f5481f04cbeb9d7cd0d82fbfa6f8710eb990857fa7da202efafc1c6aaa392f425171d554c70dac7e2a4be0bcc2f10aeae60f35f1c37949cfa38355d197fff4152d998598c9d6b20cef483d449e77d5f73f2b0c4ea7f6de98caa51265fa8dd74a7666ef0cf60f5834eca6b21a2f8045f249b4c9e45e9d79ee5f318bb70a0b1cdf830cd1d8b3b02e353197309b85500efa9d16258009e767a3b16db72e5c96b4b7695cfbc0f4d7539ea3d82a43d3dfc33f298e35a0b6044f5ad049d0897edad11a95b7dc881b5be8c804e2ce408755d3e224c2d899a434f38ec8d399136fc99b1e09905174a2050c467648873f1ae8055413788f17a066fc323ea3e1bb98ba5f0d69f7723fef3b16f869940fa38e85af1e4a04e1f9cf86b5f5293fdae7b7ec27b5db1420a63ec6410ac51c1a2d563249e81d90be34d0cae1c5563cae28130b2a0fba6cb14226d466cf3949fe4a1a29ad38c3ca1b86edb76be0ab179d14e2d1d8dbcc334cdb7889ddb4ed467d62666b85790b77dc87ddfdbed35bd9884e2913bfdacd310a0f3f5f346f4edfeeb5e0761c7eecf9ee18156bb9b664c5e5c7cfed30f0fb091cf08cb1b1c5d647c8a42629e1ebe26403b56a230ae7f32ff8b102076570af714e8b64d05ffa9f75bf1ea61d4ff96ad85be46e2337761400c7be883307b325cf8a102fb44d6792a01e5f2970c6087fa26ad1f36ef9f4417b4222020de4930b9fbc72169d12ab51251053f013c38b863b0468cd4ab20f52d2a0101f5f210ecd3fd0f084bc746ca74365c1946c6ad8dae11e4ddfe9b071135dddefb51b460dec0bd10d751f822caf57eb7d5d23610b57c282bfeafbbfaaafeb138192d464b3b82e57b275c41b4b637a0189c06d8c0fd1dccc9c459cd6520f93d30b159d09ec089a71fa19882b2701523048cadcf39f9d65a46fbb17d00bef03be82b7f12b19bb1edadb37b4c12cd5801b270cd1cf33db7e1bd63949d511d00519e1c58e999d158887d18eaa293d8f314febd1c58bebabdf0c8e5bdcc12471cd61ec85349d8e1396be9d8653e231c13766fb87a8475e1f17b9dd181fc57a3477e1cda9d9312ca5aa0e5aa25a6140408cc50591699972bfda5ab55b67be5a80a75c09c5d8432abfe1ea535df50c23f1c03675540dc0572c5ec8f0452df4fbd3dc7d5b81993ecd6b716c69a38235e84dde7dea11a2251f5225c75933421a7071b81adba6d964d2e43c3cf9463766e587642f8fa11d209c5540cdffb3491a374f759abe63661a622f44c7994469f056710152580ddf2aab7e7e03597d837434c48f182773e8893a84c8ce9edd161029cbd473f4fb1aba2739e83c758ac8fcd6d7f26114f325fedbd0f58f66a96ec5f4cfe87b94dd71f723239f1b5afa12f9fd123351ec7b4a6d60b1416ed693f41d062b09a4015ddfc8f0de7241a89e1790def2906f3f95b30dabc00c2fa0d827a0ee6ea17ddfd7c08f7dbb653bf311edd590fa17dfbe8909b5713936449afec06dd127d3485ffa536d3833bd424e93c03c29f38a5a251fc41a966de06db1e4144e2748a836195458b8b338e74b16246fcde4dabd5d47b91d1d47e1c66edda35c10cb951d6e2f7b34665cb05daa8522bb59a6110dbcb7482c0af1e7dbd1b2b6d3c841296ff073b9559d63c3cab283b9daaf0dc17a417cd6869e5767ba02fbf4fad8bb9a3a5a55d471036b0816c768ce3a327a018a7441af7fcda0776c860377b35b448194f9a5790bb9218abb0079647d3093c1df77cc5c91e6f42da78052c23103d26586e3f5fd549245f0197c501ec3f9452268ced35446cef1791437b02e94c0eab106bb9bc5901ab5786f8fd16fa41c2bcfc1bca5f83b7b6607f135c333f10614185585ef26867434234d71a3745e8e61b42176a491bf5b806f7543c07cf95a9cba8f03ba58c270a91f54f3ad3947c8421138ebea10bb8da2c8595171dc5a8868be25ff871fd4041b033a3e30201227ab306d995a14a258eac3bee8b7b4adde389588122bf382ea668fda99d3d9c933c4cb27e9c5877c50a6c25c510d064ef458312c98ae7b48df508c8387605225b1f233234ab9ccd3d37b9d6cbc9a31981de7120fced3255e5d6e220814396920b7be7b164cacd5658f7d8e02604d225bd79d5b8e37c71d6849f0443d154a7919a9e0b5b020cc5c07e58edddaf2ccf9440febe9e8884992d0e07901112c1118d5ca59a3653fbf64cd565926d483c35cf9b85e6ce917715a14ed125394b45d9519f560a7225557756551462d45e590ed89a5761b7e30ad5a91aaeff2a5bc0ddef984b14a7958f4d8feeaabb43886a62fcf6b22084d7ea60464e6835d2c64f157b06d89809dd6c143a3950f71644bbf1ab358a8e1ae31ac8ead10bf9740ab03c46739583da6c0dc88e6f54e5767a3cf1a84a3636eec9d7e62191fbb7bbee1194fb00f6da413a000679a46747e43bb54045ede24db71eb1236202c1973dd9528fee8eb8f0db88895b3802fdf4a73b71321db1d20feef30365b36b100bc4faaf5f5ed7f549c8a3d2b25c903b168eb356173034d7bdba5d609b85bab3c457d636cf445fa00bc80cef757faf364fac6dd870ca583c9db235917e2372c24f09001788a61bffa052191cf58f6da62452cdd287fa71dce2b445665614141a11aa843aca1c3ee90f14560b10193cb92242813a436b8bb2ed90d228d338bee869369132b7dab46efd2c501e2236a6d1cba7ce82b504874e878584e626cf193c21ea5a4f8304b997b0ff0bb2d8ae323ad49b56ed3aa4121f8feb19b14ebb0b44ef4f26d4386ae5b9f58bcf77b9caf3810ea01d7cae500c2f053aca57e7af3873fe88c50495e44142a8ce5ac3ce8d4ad986f4cfe0f18ac16effa8477f4b744d558fa27fc7361d004d67764a23296ace16fedd2e348c65e1045c4d797acef583d5a1441258283893e637d76621724a01dee9cf9c47668343478d25deea8903570acc0ffa0506f970158c45383eb992a9bcb616025e4c6541b9db6e9a502f43246dd8ba15d16c1701437af545393065f5aa86717ea552242e50e11ee8107e0ca6183612ba8d34d65b3cd1c88d2e3828d77c0dfa305c489803ce4a65e8ead6faa25b7ad405446ad604de97f4e0a74ddfa78c42ea9bcc8393388bad1fb69405d8fc3ecd238cbeb945ce1c5741792616f0537eb893a8d519b2ceec35ffa8ab3aa19cf56ffc4a1c094d231b2f92fccaad57ad85f0c9eb2a4b1668ab29f33dc9d4a0d9cbaa841374139c5545b1daaa466fe67ae5594c83b5dac0ebf654d82d16cb592da13253907bff400e520963e0c2a3881f85f47c3f43799153415176ee3fa8a9da919e9ab8be13af96144bcd860afa515e7ff0b49262880b47986484df07c60ff37ae7bfc5f0ae1da9b4c5fe5c895dbbc18aff49d6a2941ea2de9c1b45ae43e81f9a3afffd73a0d725a0b6993f02269d411c573966eae895f9e7032cab4ebff0cd10b5842bee66fda812f3027642cf116507e2e8d82d0700a8c93386809ec10158ac5c0584a47b51187efa50bbc10356d1b62f1610db9ddb910fbcfd9385f118ad0cba90b2a95221d7ad6f730111b2c3da9be865773039f61aef3b09f52c3b3f994d0111a6a16d14a1c82152d080860c510f1a67e4ced389ac7e2ed7a9a234bafc5cae0fdcd81307a75c67daaf47769af1139c3fa804431c4db9fae5e8f27450f15d0ee154f61044dc0147aa88e39f7e116c7877f34859bf3215176a3eb6d468289126267066ed418a7ef1aa3ab3e314b00341bbb5a699952d7cc971c345f14eb38321cca978ba0e219ff83fe242a04b02f7b56492623de23696a5bf08bbb81e35377c957e26a86cc586057439db72e47450f12c187ddd91e0516f10f3b97355da870447f308bda982795e5b4e4b604c79c1c44e343b6661887ecc23bfc6c37f69bf3925775108382f6972ff0a943b5153961a7e1d0991a155d1f6d10b0c5584d7aa5097170fbe801043493b62b92cf2f9385b5276b2e1a2ac01c5a833d2f525a8dd958cc688d59e9af48a0bc86e2f9560de574f4e2bf5e273e8c75672130cd4fb552f6eca4278d0499ed6fe716eeb55e01a59f2fa99a0c3d893bc9c1fa18892209529c08e038bebd49dbf40bac1f0afe99a5a97621eb95e6cba577ed6f0bd87129937f5c24d2ae5c2a0a829f49fcded60e4b4b702b4d27cf66165f61ac2b45a303e0a688364eb3395481548b26d22a75a5afb69fbaaa030d0e84cb88d6ceef3a602a73149a69eec4cde26372c17d4aa066b7e3467e28588a9d681250d0699686753f4c1c4799c75b2f01564af0c74af1818b16a1c173463bbc386ba935f7408129d796a8592a0ef0492e49e30e6a6fffaffe0e22fdd97d1189b07a4108e8b9d8326a079dc13028d7994b9b7b9a5bc1dcfac965254067baf2a8b138a67ff00abeb30507e4922c14ebcc57e187d15d187ad3801d7229a802ddfc9522abbbbdf994eff3c2d37117636df21942ed77b106c2f3acf47c8001157d6148f8f04c7032b13178801357bbb99ccaefa12b2932cc2266e97a70ac02c7beca9c0085c9650c15092698f158ebbfb8237ee3be0e6f04c780f46088f7384673f76f67f136ce44ffc3e7fb18b0ff897f654b827b8576412929fc44b725664b9814bbd3b586704761292d4688bb886460bdaae40a50aa88d141cb505e67a722569b69bf332ed5e46046d9224084527a7761df9b02162b39d56386835dd79c79531a745fe5b4d1de6b8bf2e0bf4c6ca4f2143db7a40a8a90a2a62686d427efed7b5d1c8195eb856ab7bf4f02bacf51fd81024b88dcc7d5f11dc900e73463784ef71f1ab645043fdd13691339822580804c41b1d079bfa306ecc33b94e72dc2f54a573284a7011a9ac934a8665f2493dc6838bf3c20434326fd01f379ce95d344d39f315583eb3e7abe9d42731797b5dd0725f5d1cd25d8dc651e2a8fbaf408c450907bfee318e3c4960ea74f8bdff8d72acae4dd87dda0b32e950eb178b07aa402ec70f3e09aa1edc9cf3bbf1add4bfb7e25059cf42345f51ae2aad1a71f477df9a1b932948a3b2e6760c185d222b4ae6a6cf7350449428d5c7a30436b8ceb94e2e6dc97d713071336bb1cf5d4c5b00231051c151606c57408c7b352bb70cfa6cf8d4310d243cf3bd8ac6c9ba1376be8b09f80ba5982bc7becc43d58710c88957ebd9dcf4c2cd183b8484feec9e1d2f411578ba45df6756a252064dc4e20149d173bfc6119c02b11fad0a955b075936fc8d8d4a45adb413d93b9e7d7a94713fbe1ee1a95b8bbecd455546e05680c05723b450644870759c105b79f9e6aa15eb1358e299600f27614303327853f17b0b48bb0d9e8b45b7ad6dc2b9ad40f65e433cea4ea3a42b3d803463a56ef48a9e7313043a2c27cb7368da8d9c6510059322b594cbee9008323013b5ac3a6fb031aa0739e58613c91b58d75fdeff4e40642d1739ad32b8802c159ad7919817da6ddfb23a8af6ad114fcc0a5fe99033d0b042bcc56715671cdf67c78cc6b0130d094b51c98c2c196230a63db0e509ef6257a0e5039f61f0fe30b1476fd61014b8bc8997ab1b9137a2b41f6622d97e1657643e91d652be693891b74b5f24781aff14b5a1aeb2bfe412d52b83a111e18a916a7a57080c170b2e33fd925f91b0ab42f41f17deacc26248d603633a38caf2c59562be086aca097d56672234e36233b617011b9e1c24919284b6a082c1ca19288d7fcdba950474e17b219f24cce58c40f3279c5f3fadd3df4d7530721fe16a01832835258f2d61e3ff8a3deee60bdae62ce8605009a6f5e634ebb5f88c130721f23c4c0116664e1cf069904350b4ef8ceb0a12697f14e7aa21b11d4c81df349b1cf67cbabe6da9fe0d5d5607622d7c7d0d4d9d04e2f4754c02f2a5712e5529e0f170287d3fb6790d1b391333ba2f697b0adc89a4fbb21959270a6c2daa9d6003c629567cf2c03f961cd07f8fd180b2b339a8d03ea9b8109611d7d45b7235a86de33ba6aecb2c5946735a9349a4f31fccb46df37f566463aa9a841830c306d84e60e82dd68de9e0c3616d01f1fd728f888f92a6b25b82722493a42ebefada9d8c13abcf2d6ce6fb5ecc45e5e429ef981ccd4b618c65321a60db96e927fcb85dc759097c87ef6648ef7ccf745f214437a8650b7be102b6576510be749c5f1517972d6fe6cab32e3c334856dcae35eda1eb5635cbda43241c12eff84f064adb76af3e9912c07d79a0061443f091c77f14363feeba9c8e489a6ca6ac1353393c6ee4ec298f8ab9c7cba0ba48586c16c1f9a0d0e3a267773918df4027d842c77996813451a6680afd933ee475658b4a3caf931134d7244e8be9f1e8631d16d2b26ee9429581318f8dcd3ed168f08149919a91bde43772f6f467abdff4d48c1b470c4ca5d98962f5519eb374343f16e31d6a2946d2f8ab2eae8bfb0d1b4af9f98fe8dbb85363d11d2e29d62d2c53a0de168d8436a46995f27d8fb62f8f04caca6f7163082a0236faa62d4ec9baac096378d2c2b7e6a7fbbe717f57577d20c52e5ddb879afd8a0a5d94ad107a325beb9b4652f109b16f5028dff484fd4f1b5c819849fd378180fef9a7ceabf18e906c3c91ed4c2dcf960406bc08ddb53918ce1d4d8d5274dbe7958bae2a1ba5a0aa7ff9558bac9410243aba14cbc8ec6d58483f604901b5134caf3a69ec7e6c7fa4c9f0abdac9c605c66dc98737ab32277faa8562f75b0f3e57251ccf62a8883f7e195c0962240d999386a7123e3de22aba3eb73aa7d045cc9a1c4256bd8d0f060b034fc29afdb889b884a870c921fe61c969e1f1ed7f04d87adbd4f0cc99044f0cbe8fe64a2063759959d1b0064c3bd4315113e56d3bb15a9c8176d995b2506c97c63a24994b87146008c2d8ae0cf2c1f2812d5bdabac60c4ede5c620d8213f827a02151f62f65d893394339e65a053f7c3d7101ee2ece29c68509b41ecc395e052c668ac1d1dfedf402efb8685a5f548b494c3fdc2c455b956201975286d7d0aff193e0cccf49976a991dbcdf22e353136860b5b8873cb98c32bee9a70f617bfb00a364da2d3aa53948a91128aff6eb8ae3329b9323eb58795e2487b93d8cab798235abc495f99c8420375beddb7d510d0d85a5c00f8416294c19788dae3a73bcbb139e2f374f1ef544c4a0e8baf369ccf4b1985e9fcb4e3c965d3503f9cc80fab02b07d6d96cea5c6f0e8adc16230a1f635117a0d53344a56fe07d0d82cd7c5950a55435534016aaaa7ffa73e9fbc70049bb7d2761af97d51e471bb833fc303869fbf4dc9733ecff71a091e1ef3771b7732583d3c2425f2cedb9f0b58fd5acd8a578465fc8f4fadc7e6c3f304c24239ce7034c9700929d39f438ca2cf5cb3f3035be11d62ccc0b27d6a0caa329eb397781ea75807e9abf18475078625d1bed003fbf5a96d0d8fe17f58399961a9bd26a848eaeb900ef94507c2ceae4ca4184f509945f9d304155a75d1d95b6e3d4425a95da0a2be18e5f750b7c06933f443b9ff3c6f34323dbfcedcea35e956a1109fcba678ddd7c8efe46aa7e8de1c0f8878e1aa900e2390ee1c97bf521d99e0495296f11d8cd3cd7f536e6d4fc5e3629d7bf5807514ddaa8281c1859025b0fce80a27c5018f4c74652184516c67c05764b28bb65a88151c38581a6eed41f70a4f3b22f376805049b53e0f92b205716103372405516cf20e5cd93cccbdcc94531558562c8a73ca5ed9585bf38479370cc659f79272652b33bf3c924db03d209e322bae5fc11716d76d30a848f2436a1e1b9732bbdf15352449d7792c5ad095e40702225bdb6e541d0bc58e2002222e432d6003f55934ca6dff456bed3e8d654c56d2d00bfd455897a0d7e5680d6192f783ed15d47990ce0e320cec9bb7d2bcd855296e56f189e259979858691d4d96f00195ae3e6ff9c8f957d7fa4e576132781fd14b8133e8100610ff2fed390f695ade8d0f63b49592116ce36eb8ecdc25f1d83fc69a22b9906842777f466e83d0f42ff26e90c57d372b39c31f412b728b2d1b01ef6256b3dcc25407b42c9f2ba7ccf2dae3756b7b8b62b93486d5f3b32b0e783af961c2278a6b056c8607c328112b714f1706ff1a70b9bde8ff02238d95d617ac1f7f85abdf8fbe7bbdb318ef7a3a1b7b83dd5259d1e09c1130c5efd46a2ada2f2f570744f4611bf6fffc34291d3ba709d6ae9b3fdcc0330b8657edbdb252fd5398e5c5ad8e83ec1527a4da32f6b6efa7efff6dc01c21b9ec71d2a6c164194e0cea9ef56fadaf849a17074e04bd6b85ec72b4f03f69f1248984b1b57808e27cfbe25ee538ec9e0f973ae7d935c8697e8fb8485fd9c9301e4fa8d4528f058ea56500e2ea3aee0e9318ec6e81b8ae57921dbb3800d1f4f70dbd1e5d9b9aa7a62f6f378b9b62e7c8db928c1b6fbb3c37f9e01d0aad5eec9d082f4be463c47ae0dbc87666d2f78215901c8cc2eb6567b559770fc8cc9e3a824376ac2929ca9b1444e4a9ba6866aeaad9357bd33f839d62986e7fd338656a07538ed8cc5efa89123e82fa8a75982354c2cfb413dfdb467f587fd001cded0eb437b83a7453c2324efcf6b69e804fae37054239a2aa645a70e85c8781067fc2023a06fccfdc7cbd5199e96c073059d594761c0de4f5d95408f6c94da6aefb7983ac952b2c09e5bed752407bcb2399bb559634b32e71501547fb099fac394be79a4d455f97ec5a33a5ff3e3f0fc2951a7c6575f38eedfd29a99fd41b31a30a46f032216660f69e91b9e5ab16721ddedf62e10904dc34739dff30d74e89969759a15a513e0c75ca99794ddb7a86c537c996123927655c8466b7eb6e98f995290d010b66f0145b6e9fe72c470ddd64d5a76b4df0fff2d73a31a605ddfc96fc001641570cf3441a0f980758107c207cd7410fbd12dce9d9d4c353b1fcc429e4ca576c783225c518876f3dc299e464d262ba31ec8152c2a705dec2b0b214fa58bd4181ea915da9f9e59e9c6f4b1bffab9ae556394297da46a6a6faffed3d6a39653bb1185c71c3355c82fcc81e9b01d83e331efd367d0471832bd7958843262fefc039819285d2a7c973133dd891c1ffc0743c7dcec2d1db5c377ed52a6344ecd1becd9e75b477924ac6370ae623f43a5d98805c6ff811d43edd2cb47b2bddd32f708b1552e23cd13df445aeb0bbeec1bb266de8faab9c74400ae693399f8131fb522a2fb6ad8a4c3ba4e602f87526bb3b6a3ae2575faa663e07371a114ccbc39089ea7a478d3150a4c21356b74cdcf03fe78496fb1ba51c77af0bf1ce5f8cc890dab986486d9cf109d47da7f0fcff36d3f18ace2830467cf2ef9fc798f689b172b8aaa0f98ee8cd8ea17f5a358f9dc031fecd55af9993c594b8804f8a7fe78aeaed5e89a8a4ea93cc60ee0cd47d254e4a574cf5c309da5bb87f45fd0fc7da3736d4074655626c142274089f91a1222296f3c81da88dd7ea27d93bf893d3e2f1f375dd5937efbf3e85b935255364b40a25e9e644349d0b24c8e7b722a5b50aa0f26c5ccefa4959b07966b0c6316835ce6643cb20db8aeec7ce0c169f6e300bb0c6d418e4c4388cb52e5c57bd93cb910aa0b41a14c4d494bff1a083bd78827aee2794b91d2ae5516999f456dd465aac31687ab4a6d9528db0d5197fca2aea770c5de51242ce5accc3e3359d05e83e23e92302187bae8ec72745ed16d309066d84c22e1fe0ea42cdb486e6eb1a5b63a012fd40ff75b58f18af55d43bc7f343c0fe78905f69320b8b81249608e3c52c6b054b6729950df5f90972cc7cadf78100850214ad4cd487ebf5ffcf2407de5aef3a3d526a05d0cccbce8b0e98cb6030e27bec2d1757bffe05baebe7d1619f31dec348939fa7cd2ec87174d192556a8e8ed5c0e9de4ec5a2334530bcaba9ed2d78755473ec253f651abe3d887c417dc4638aa51003e87c75f3f64c682a2b0cd9be39835567d248dcea935f3edc2e6f2700e3311ac69f352ae3d715beb0ace3f31eb32a42b3a23afac68259419b3be85befbba20fc74154b84cb17c090dabc13f5a3f4b3f8fe602d96537012008d28fc2c92a6caafa0d270262f16bd796043e8c0e7140cf30dd93b2dc3ce7a88a0b515da2e7b47a4a5c140c7dd5bf55f0e84d9e9ce8edbd0b32155c379aedbc266e33d1db1d18eedbef67ac73d232f6257967f153ff7fb9e78363412477c4c90aa4933ac671c17a9786ed8b03c19d2fc51868b0cd1de30947cf7bebd28b7a25c8084f313289e5cec2e036f02484c29c127c0279896fe625854018bf80b3afd81f63e59ba154cf41ee35f6c5e8e56d11c76495a2cce399bebd40d2faf50adf43ab90ba2e1bdd960df68b5d9baa3d04f3c9cb487781c31d7cd84ef703a7cb538da3ae4786221b29751a66e8c69c1b08324bd06ec0bc6fc83bf7fd08908ce4e6d6ffe8999d03af6d8c48a8dfa17ea3399c4f88bcfee5731245d6bbf6bb59eacd1ed294461ad7eb90082dec06736aec4ea9078406b199f839ee611b305cbc1920490e27890abf00e604bfcbb2b9fb1b64870b27dc273ce3a8f8d3323e559df41f57ff720479b046af849537fa09ea39ec3c61366c73e5466647083962c358d9170b6e6a41ba8c042c9330f709c21ad0bf86cae0f8b684396830de47d4eafc1943ab5f41e95c2e483cacaf35f78ffb7a3026ae7a10fa11a0baca8388e99465ec50267eeaa02a81f6127b96fa54687b79a373ac4e3656cbe1c73528ecd7398c4dfb469e82491b5270bfdd0d04aaaa67a983e4eab2e0e8e6fa386dd77ec049e405610ad06fe3249f2fb2f0f5e4e0b1cb904eb1ff55e63b4d8f25183eb71f9f39999b4b0ae0c6b7b44dc7fa59384ef48d6c1cfc4a4529c39113b5d7711a2f44b2a32a4c06ce639961b79bc16753652f4b8e2642f88be3a374484abf845d4a2940595e04de9cfea45a33851e7dd6fd2ce700f195e9d94077c617cf56335d1ce8f86185aaebf54f51b574404332180eb0a0adda055ecafe053205cde37425568cfb08b629a9bd8b4cc54bb20824b00ef92db1cbea38d8fad613ac6249bfc7ad2c64975278c9fcc558e7e91aa9851d8b88bf1f834cc2b4f8fac0c11e9384098c28a19d52f0ef23553b101fc9005465791de428930c23933bfdc0389620e81ee12b0332d52f4499ec9e83559fdc52542c5d1332a61a1254a31415d49f788f239639c19389e7baa762494ad295053d857e077dc02636a5990082fba4c2bae98ebd6cef223f1790eb3d1fd58b20e30f486b9e67f2c5fc267dc96b9bcc3361059eab4722a2e157b44a76e5bf1be7c8a98a7f90254a16013825096fc60b0acaf01be481ec9b4150fb9344f0296f6c82b05dbc52c07df2a0ea4f3106c3b6b0a95f7995431223fd71892c5059e66957fe06ec7cbc9ff606d102296cd8c0c17ea80deff36405cc07a75cbdb62200b0cc071c10cf1cadc9ac373282b4fbec51a00a6f56084d9e3304ccc1b3f8185b7bf61d9956aecef9ca45aa2160c670d821fa080b7910f733b6f28689b8ab6ffdf98efe60a67bb77f37124c0d1debfb7061ec67113cbce5614c8473f1428f1fb66026db01939abcc8ee9dfaf23c7398a0ff954a6101ee6a7faba891b0e3906c594ac4ce7852d83847dcda63f4d8d252eb993f3f3ff4067075bdea0b7c0b50b1756d8a8aa7c15f8fac6f1258c599cb2d6d8a3d25af675ee98121416ca4ac76b96a87803d09c6ac872111742fc69da2e695a394ae3148d87a9f8664d9652b3d40dd6dd5ea57c17859b118fea406d23cfc8df71ccb9c643b8597797df2469532c172ab8955418f79d70e01e5bf2cdc5ff972379baa044adafb89f56791515214f8fa9b4038d6d1821d041e50cd1d77fd25ac136414b062dca337e877ee18d1990717bd1b2d30aa1e4b911668e8aa8e3d6ea3bff76673b825da7159c9add67e309d0a8b1ce13e8acd9ff95cbbdd8dbc4d16551a00c66142c5ba7e5a4d60d78b1121edb00cf1ed22b0ba23a9829adc84bea863c8a670921c458c596f6f39ee786eed5b5cb1b7813c9d33e20b63624ded19289a1939e1182ec3f3b86fff336026560037f68b7072837edfe7dbf7d5507a32b41860771115e1c12f8b30aa3f705249114798ebe8d9fd2014ccd4d4fa368fbb84a1634f61263b6438ef4482e48f3eb044342a812dfe5136331d72c8dc55d610a5eeec80f3a80d2ee6b3b153921427cff867819261c265b8db15707a531e820a1da2eb57e0ee3594c1fcf7dee1d2d5fda84793efbb3b6027599e2bea0237c265f2cf3dc624866afa7b6e75e27b32fbc4440f5f54859791e96380bb8889c7c00ba99edcc309198d867cd77becd5ad48f5871e282bfdb28ef1a2e594f4d62a9e3809d2db8aa94d42c5a5a4762af3df3809d1e07c919905a17be7277c93a580be87830f1121eb34a2cd595ae2eaaafc3521334210ef82383b67d317d8592c53fcad6082e74631ef27a08dfd55c4eb6513091b9842b47e8041c3cdf2951b29d704c05f3ca4e7f82a941d9366f9e2055046200104e227ef0e69d666a20a3fae266a944b4e3a3611145966da46ab4ddae45d0acaa08122181abda68e4c8084872dc9a0b45885a82df82a463a91cf82469342bde53c763b46a68aa20b29127f63b30c49fc804917a3f32c2cd3b6e2f45ca32e598a488550adb02b1e6ece393069a12b066b4a9467cee8e9263bd9d7dcac03460db30c17bab72967b80871bac8e99089edaf02aad5a1f619a30449a66e6a72c9d80e3669e63e9eaf316c40d09049753c9933f207da4ff3eca683de1bb1929374c54adf1eb71872e4ded89d658c4fa40755a6a026ea237e9185a93bf9a201f999ce27ebedccf438e8343701d832f160a74f70422589fdfd0d8fc42eba37942e6a7fb253f6479f605c8197937e440e455cbfe088dd1742b01049ef8a56d5f9480f830e814b08f5155404c7053b13aa2305ff0dea9033e9cd4ed5e7dd3e75130534a1fd049d9c88b3ac6a77c3d0769a1835961b4cf15de732f1b980980068d6014763845a29f73c54ef0819a0e6385201c9f5fb48f8608826089a55df16cff41ef01cf3212cba87e26d0442ee57f5a430c14d29fe9e965789e2253bf7d79bfb521e201c867c07ac347a0493ea3633f060fc5a1e758ed777932072d9abe3bccf19d1fc5c6199215ebd9e8bfbaeeba12152614b8edb51b93b24b4ac0783ce3a3cd182aa089e827a2e6805b5210b8edaddb13b206a349c8c91c4ad7b4c88d7df9b494a465727a229204e5b27455d675191523fe2ad0a845b270cff84665d05e70d79a770af5c25405c446111b99deed16caf0c209a7a424148bc893b57fdf0efca57e5106b3fb2d311439b5874aef11515a7a8e0adfda6b4652efdc00891ba4f6180fb79a30e2cab28cdce63f9f2caf8219548b9e231c67e9355c89a70644d47eb181d52cc1b65565d00c4641f092d560ec43349cab8c8aea5e52f659935d674e9516414e3c3f4d828937217856f446de3ef559a2112b612f40e5227e3e496bbaf8aa73a0a0189108aa60c035d28d8b1f32755cd8312bfb36e7ad401b1a4485c366c4fd59c498fb5ba96662add299a310456e9ce58a91dfa9b5666d917d3e10fdd4a15a09763d2f519f33f919b126122202979dd655adefc413d2e908b561a863dac7a9d6203411216a69a6abce5e489b4f2e3ca025a47b0898a77fe82ea1c2ca3e5c37def60f18c268ba82266dd1536e54b3d8da0a768f7bc91f6a760602682c7a09477c36ffe764b08648271315e630b9eb883bcb5ad7e986ddd1b4da4e17cb3f5291306b7d72fafc3326e694f481d4d1a35312dd27447c69a87cacbebdcb97ecf94a62ac5094de4d930e9992d0c2ef959296afab23840abdab8046d77ebc9e04ef2c4695c8189e7dff8b5b0338b8c310bde57f1179958c2784f7a67e153ba34a7b0822bd275a392d314dec9f723ae54379ea321a6b2bef2111750d722eba7696b8365a80f718cba59d57546f254fb1e2218b349bef4f19cf9badae73fa059f6463c7c26f602e40b3f313eee1896a26921b97d0e3c1ea93d2fe0ad4286a2101e4175c8e12608d7ed873731f0087bd9140392b13606f9d80ea7c52aa273ddee4e03206b84ab1e4337a949fa8ac2badce8017c1384461493d80a20a7f9090697","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
