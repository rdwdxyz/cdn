<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49e68777966fc2c42f9fe8efc8dbf958dfa5619d8f17854b518ea8ea366a9206f56914dd459d0a7fdfcefd189a8355a19b31080915bc6395d7a1fe117a37316d47d9a2ebaae7b743f9e6b64488863355d1a4a299420a9aaeeac5efc0d3dee4206533b1440df17a362628348d66637675725f4e84f9e5787bf6b738a4d06f5ed28c6887799af1d55e48060f14f124d12dc63c44af2134a702d4cbf511aa9fbd3e9785e8ff818834fbb15702763eaee064b6268f3137f5fb0cda212aea827bffbb58d81fe8d1bf81f4b5f98b62b9d996a0e4c9279617dec5f55c2d1653bb941790a90af6771fde4210d43b25fa4fd484817fa189730b9d9a5b925b58cdae35d3fe928ae892a9d0a1bd1008b66079014db8190207e8f6f0c03314a990246877dedfb672732cae61f0fc9c5668618e6d821a55740e12deed9c41af8261f06d6a4235245219746fd132f7222bcf912979d4cb857e694d9d8c75265ad64112dd45216d131544b8c3ab245ee8c4410d2c4a74e806e27995e2ea2dc7ec75ac5658960e84613f78d6eb67aef9a218fd82c45dd49255b1c442fbd94f36632217d0b03351d34853cf1392aeb81e3b25dc3776a068b60ce8fde9f2bd93df10864a15a30b148216ee90a0cc8b25a30eb0c7b0b8cc4c86ecaea901716a6691cf9cfe740fcb6b7c3a0a490a5cb68a506e89451b8da93f09900b874b4c9be96b084ada459273c42be847c3ac20fecd5c37fdcbe81bd80c2ff518c0e1f6489ca7910ad81bcd035828b289a94eb9667c938503a31e54fbeb09b7f8bdb55883f7933559b0f5bbc8d8572f31c71c6297922036178201048a2bac4b6e9e9c03bbb821a151b1b4d968d37185aa2b07403db491de92db01201209829c67e96398976cfb2b18ef3b969bc1b1de4c8e985a61095fd2a97f703d75f104b54e5ce78da00fa6ce4399b90dba9aa79dc46ce4a8d1d725bcff8c01d0d6ee48089d169643cf255bd793141a965ad94376db3eb9948b92b8c82649b71f7cf21193e6cea6f377cd72ab63d11d247d26dd1d8b1ee686f639bb76a406198bf3ce92f002279f8ea091a71f0c60cb365bb55f8d2685154d54d2cb756c3c8182fb78e0c3e8c754eae6be8bc533947274401720fbb9f0d2d53ec4fbfb65a858601b8f726508b33f0bdc4c7c333efc0f2339df5876bcde02ff7982e116d66314c9b15d1e3eef13d631da4099f8c68f38300686713138fd3c70de4f601de7025a61695d4e23c5041ed352fd5853f944088a480b2c424c33c8d0c9c208c46d8dabb718e691d175c09893fb70eeda7a26e88215bf8d02339b9b6cc3ca9573b026454dd7e69ec7780efb6ac5cb09feca1f06212f1b908f8d82ed8c29a6e2bf82fbbf5c2d9997df304375fc8c115d2010436b819b2d19d4d5fb8d565fd022421e21820d9fa11275e0a7490796053b88a0d10d01ccb54576731fee79dc2a9f9244cab7f7534941311cd8dce70328283fc248dfebb3f65816d276337c1ba0a4fd6572f6dbcc919acf79f5619aa7c6460143ad4288c3cae6b35cf2006532fa7332c5fa2f163ed56e045411eb8c06b75bb5c8e4cb6046f7a3090fb91308659b1f53de851e0a8de03ca5406db255ba4dea2616c94927fc05383e165006532f5e231bf8911ca5cd6917bc5fccd867de83c2618f6cfe4b9d103b2c5fe798615767b5fc1bf0a27203030df00db9270f887f5314ddf92208b6b4205460be9c5471b302eb8d1c2ccdf1da120b1730091efdec719d0c323f4731c2d0946514c3ca74c697abc1f4fe84fa1409fb6cd869188fa506f09dd2f87f8524ced8330484d8b6f711e35df4a0f3f1b379df12e816caba851ef11ec40755420352d5305bf599ba4cd95500fc7d57627690a0df84eea3007ef344017aba33d798cb31a998a9474a74ef573d4ea1c535c54fe9c70708b42bc863b3f8f63f175fd8bd73e607b053239203553ed00b83f4508adc13593ad2682cb94d7fb5c7dc07e969bdfa09b4ce5fde0346ac8a9ca3ef48e3a56f7bff11eb7a9dd5201bc86da72656e2830a2012d569a7c38b6eee3dc010d9155dafabb1aac3537cd6c25482c14129f65f329b0ed58eec84787ed917fb852f6a872ccefd3487261112d8b89444304fc4a5a4e6ab23714429cf62080a0e25097f10fd3cb63897a8c715567d05c5ebbc4aa5aa3d6ba95dfca6fd2a209612b54c1441cfa31008ba3e92312ce978d59fe83bf066d83ed0e341efb72e99c6eaaecd734556d23115bc2a869ebd01d1f6fcdf73247d06b459c7b91e007f7be390df0662769c41414db67d25ff459bf22056b1d961330aedb7d4c8cba85e5770518c17bdb186fcf358f7cf8215e3d751f6cccc7f35de7f03a110032772a84848ba633909e85e7d6c817add03535339a8320a03cfbbd0b639b54836a5d5d26453af44461a90d9229ddbeebdd8cc93ba63fb77857d0be5276b8f82e25b213b4860a7a17720f5198ada68cebea011027ca25317efb5529771278ebad6bab234b6271d9a3994dc5177a7ea89ea824f10d2c6c1df58e274ff4a5ae3d439ccba349028dcb0338d6b9c4e85ec09530515d708a926be21bc063b822f631b5733aa90401b75f73e462224ee73caa5288d49238d664d0013bfdbe05cdad1ed7bf03dac418a842e84cfb28383949f5942d162e6ccca41e7a542846bc110b5f9a0d258e32da357dbfa6ad2cef48c6719d46ec1480d357ac52417fb040a5a48052105b950be7e467004dec9ee7f53ccfe628dde32e20502ebe78d94c44d38caf30b7c1350e9ebb82f4f3fd33dd651d8a67fa472f9bda519fc12181de28957da3ca85f8ff27ea6067f1a513788be6bfc0e4dcb5ebb779e0bee90ea3f89a068e34555e906e96c224e7b24ecc9b6a3f7888b8ca6f9faa6851c10bc893b59da076ef5fc75e2cb1ec481fdec377a9dc294ed3f2f382d99f95bdd5346f70736f7b767f450847e77234625669cad21865ff8b3516d808bb62881faf61c28c766193b1d92af7307abc4d74a5b766d00c689756d5426fc147b3ca53ce8106936d31e31b066cf415debd9fbacf66bc52da22d2073aa743a0dbbf521d3381f657ab143f0cfe6af7b3f78582741a53b3f751f3c759078636b714e1db84f5ab8029875fb0f2e48507cda725fe9bef41603b71cbe45cf0103c80cb28bc7bfb5717fde8b28dee33002b374e1717e0b121409b7865020aa6b65c38d5e8e4099f24f94c8b0777aef911facbf82121aacfcbb4fd1a47a6d77a99c5ae84c25d3db1e9e01dc3a14af640e193988761f42eac85467923ebf8523d305be8b6598f66d37ebc815b6db643aa3c6136edd43555ba3ba73d7bbd918ca21a1babd075614aa33a82fa24c8d4b2753e295cae493b8290df09cbfe3f70be2d10faf2592e2a097ca332722c11a77783f1f3136677264259eceeee9ea9173ac36bed81e48a6c36e264b5e5af7705c0b611aaff90dd23ac6a471840f82fac8fd793135c59c709a10027adacb92689329cbe830e90b6c7500b0f72a8eab1b907213c12b306e141caf20ffa69f98a5f9ed3c054656a3c0266c2cc87b3d900bf6480cd8de26afe60b38da7a4da5c68238eb230fe287a08fc50fcce89ec13cb6899c62ed304b94a686ec44ffa0038cdae4384b0f59bb8340684367b9d36892b1a71eeef6b6c0d1be10ae947fae7daf7482e18845e8962c5a784cd7e614f9c79919623e3dd2bc97701c2898ab6349ebe9375850267d11be03badb810db686b6be0fb331038dad20b16613d0fb627ded0cfb08afdabe503f44aceaeed8559d13fb2c10b0b8f2b5e1d14af129f59c377846c3194bfe3564af1d1b32356f02e8a1ef9f8234e09110696a2513f285a3487e3256d15d24870765463421a37712bf4e557b43dac44a8238d05f4482f4d3aaea997c30a7b1816e17c5aa88de79cf3c5868a81fb6570ae0e7966322e724d0f872a269406969f41cfbfb9064690373471132a3ac7d38e983d35abc1ceea2596fbeb17d66d77d20530188fc485036f0cc84ac80163259eba2fd6b5301203aad669e8ad3cc44dd0f5ebeaf933d3b70c4f05b27ba845fdfe014cc620735dc353a88fc49e2917359df8ebfbf1094bb06d9f08b92b653d8d4cb6ab3745a98aed1d64cd29012ef553cb3536cc045a5c976e844b338c1952290aa3f3e57b3bfc126e856c61b02a8988882c87caa53aa5fc3d2cb72ea78452f1126b81d5ae1f4cf38f97ab3c31407e5387433629582baf81537e29d35ee3cf163ebab88e2f18b709702d9f3bb7d7a208423200fce9dab926287b87c3948bdb0bd6bb555b4538803955b3cd664affc40452f1f97ad9880851fc27907a985643b19391b7d757efa56b163f863dbc81f712f6a1413b07dcf7dccdf80c98777b839e6529456a72c88c309b417b710cab3611bd06dfceff7423fae83a6e499437ffe89490a13dca1cee18ff1d6d81bda88029679b3508d84a185d64569271db27e14f8f5a2a9f9dbcdd57c9547e19c21998230a9d524f124362f566064ec5c5c26ec25d00c2e154f2209db02a4e712d5d299d5685ea0d6c1dce459ac0022aacdcf2c8b16b6f9fae5f978b90329dff53525bfe3fbb548bcf0056c1353038113c8f8a7f31b252b05c61fbc11a46c8a2e1f9012335d17ffc1bc51ef8839a666a507ead45450c5bc947649d7abfbe27f73bf5b06179b683a51a53c95e78fc5bdffef1675c4a1d8fd05a5bce7fd9c775b94f52502f4e3c35156c1941df953ff05edfdab33a6cf8342be5dd8a0c8baf40e28b551b34b061adee46cd9c0f852fd9b2b4645bf0e7338b6aed013febdecf5d94efe05050b943306de6f80b168644c8c36331d94508c1860e8279e0d38a46a4f61c28f1e1eb1b2cb77c55531469f628033a574171b837fb4792afd7ff49e5f54cb48e6bbfd7248ff2b14a19296298da5e0f5a599fda5f47c0691caf08f25a91039d0a3d5bc1366e8f27d11bb8be9e1188289e9fb920441bc30b16fcc5fe3b371a1a1f6c58209b0f4cd8f62f5d6accedb7d9dedba40a355d36dd8eb2f9db194f74d292c41f0499100b0541b563a9e3fbb5d01924b8de75389af2934065acb38fb7320ce79a61e83904bf75c9467a377cd22ff406bc044dff4e2ec3c23f30bba5b53b6b152258149b919f70b605b81ec2ca949248c42a543b3a0b7a88208fd82af6d1ec32b611f4442103df180f1dbbb77881a2abbc635d57c50e95e0aa27618148cc6603af29dcb378c9f8a0e97cc57a8b90550bd8641984cabbabeb4a6e2bf133bfdab39ea5e03253c96495102965105ae91151ef598f159ace27b0d646b043d0d6cead1d01e38d777a38cad7eb8696ab96ed19300a8d60fd030c33992161f50f9363ee59c5f00b5465914901c9ac6644c1561f47b35b32575b4f8c7cd602922e936f455331201cf63e5d91c0254f78b429f3de0a27c551f07dc08c1f806b202b145fe7a0ce729515a6f2b3e4ef4d1985a11763ac2c72a23655c03d3f916a5866569c8c0bf45e2dd347a12bfa3a958851a1d470e753c015e4744192097818a8c74ebdb580be5c293ad0d396945e92b1a31b594ed8c9c0b6817797a6f33c5d2f781b1fc14ef719f86cb1de638cb19e0def7d98b5fb112b1f271c46fbac2907ace989ef229ca62dbf4e7c7dd86865aeec3375cc7681c75180b8738c49f355909cd6f23f3d65bef6432080d4a9f142665d7777dd7be9942276bfef4043f3d72a39fdc9040e31ec91bae38e93c9498e4e1dbf2d078d9c325a13586eafc10ca24fc5703ab89b9283b7acc766b275d261ff97c2d0e8576ab8c59e68592ee354f81479c7356d82d738b2d917533554dceb554a5c59d0141cbbae0b4d6c88a4fdc3cc309d06ba1c6049d7790ccae458b0244991f7f84f173afab09bcf22cf095554dd6ad07a11171708721e9fcdadb3efb95dc4000f5457c760632c0fe9999989a36354376e5eed36d0121f794d6a703e59d4c658895114b714a5bdb2706e2282d7d41e41e8b0f96b2786cc4bdece7b0de34abb1e7d434675cd29758dae05b955bb29327fa3e858749807fdfced95c0f6204db2caab1831d1b33f6bd15e93971514810882d2987b9a3b0ca4f999e939a24f8f334290b1bfb742632ee9964f442bc4cf4f164384a2ece35eeade066da6bf2f16d17d8bbd8ea7c3eb4e4bafb9638b7211ef348d731fd6f4d35a00a9f0d03314e39a14fb458f1e8ec61614781e22b9ecb6544e6017e09d52c1a46912abb26d28e47df7d5fb05107281d800cc0f4e0f1dbf0fc0cd9b709189f2a7f50c2f6ae82029e7e0d1dabb5340ec59b9f9dfd33223c4f4a7f1dd7a1bbb80848a700efbf2575b27c6050fe25ba474ebc2b213f894b5cff1d7a4f36b7ca03b964ad7f7f532f1c20fb80f3083a6b57223ce5f3dac81cdcfea2d442d114a2badb9c7cf6a963c747307195fae37a3d5f17cc89b0c65a92987a2e2739f03943ff0018c3995c678ffbd7f06896391c6435f3456d2928cecacf7679e0d3d837546b025e45818633773dc099cb92e0a9905b59b2881f0900349ad60d939fff5fd1147f3451892d2f676aa4b9c03127993bc0853abec8edddc0e420de73c129ecc61b3be23abe32ed3c0436ef0f0db8ad60ea3172a3ab5be0e5891732053c35db0b9724546962f3160fd42c2016c6470a69ddd36ad456a4a999142cc893da0607a8e5ee57ce69531bb7d39f2c853397a77424906b631372ad662db2f52c859aa740259abac3ebca9084596a0302abb74083655b9cb4d72100e76c24430257c153088e89775b82547f06e316f515ceb8df1d78e51f33e738b5ea99085702cae498188427112abba1ad5afb998fed6901687542e295220f1bf9400fd5056df6ff17230dfab1acfcfb2aaf350a2096919579791417d1b831475db08a5ac5008bab8f0de862977820fca7bf6d12eda33be01b70434bbd61295289298f689f23d139b301a9f288729476dfe661c3d81d8565a1db9fbb228877f685c647ebd294d1fbb98f0cab561960de29c5ffebc49ee01f5bb6bd9589ca0403671fd07721c3454f4fc24d9c25a4939a07e8368b03df7d5fffbc157d864dcaec380e849f21d3d1776101e2c02b236ec7507c4d3ef6606eb95b00c3d57700711235392a59059ba7cfb7fdb780fdeadb741ed3ab0252c8bb8e8fde94fdff4c96b0fcf6f10e84dface1ddfcfab9daa495c6394acf3d4758d2910ce952eea5fb67c3754529bc5bab4ecf539574a3efb78b774247c005fe223c32ee1c8b0292b2a8225fa0a10634d6c069ee9590b2b37ffd756e9684be6b158768017282201638155d669daf906d26b4f753f0894451cc18f0181e0c64170dfc5e57655f958ddc909c66b361b08529076cb014ef79866ff06f871af7525345f5187b9fc5c983d3c328e45de79ce536063dadd8da63974ab263f886c46bde017b480168ecacffe47b4aa7ed9ebd02ffb299a91aa4f35c8308ade9f515fe9b94762680b335244f1c7b070c97b972583313096ad473dcd5c26b8d73c0f5b735e34b4eb988fa88ab3c2e60ac67997870a75a955e28d44cdf83ea470e8d980b889e88d7ac4a30bbc2aa2e5e9ed1f23ed9366e2d029152775222adb490b9157844f00f0812afb4d9646145d1d998dc194f9cf9743a8a4bf37ee497b5e886f8746a616ea81a5dd6dd7feb08f808a38c8ce0fb662cce29dba4bad8179a030700e47d39dbe473151b5c2f6feac039618cba39c992a3e4721febbc03728c1e20f8eeef53ce7d41bb0a2849b5f10c21be9101d3bef75efcb8c4151d8d8a31ba42727107969f86f85f85f3e2b0d7ec88bd7632ac3bcad4aa1d23c193d444c25ca464eb2f614578304d91c85ecd1d122b57fe381834952227cd59f46569c66ad81b7baac41aa96450d23f5a59cf178c95173e53c8f001152f821975755483b0192705c74005d4bb1e55c2eda11b2f7adf15a50bb162cdd479098dbe6e1834bc13ce5adc957111b56ed324b9c6aa7cbf79ec151d6c3aedbb8ca26e1ee8030331585d87df1b988aa998b71d0102e3e14ec79fcd8c875f5f248d15e43b4fad6dc54b0019846f52d86d4306f2fe58742b2926faaa2ac5f992c362093a5b347f0291e287de74e358f69928ad7e73db5fca841a2d1039ed5cf4e4bcf266d4f100ad7e580938108cb3b8e25e05ed4a54bea5e50fdb65ef681e5b2d59574b660e574380153c2f8ce663175af210217327aabf8cc8c34e4e2d2db47904aa9d5bae231ba8dc08481a542a30d0a020fb9d863cd45c2dc7b418f3f61b6f55f4d658d396474e6e3cd604d38f278fcfff14b5c960aa736972ea2e2e3630f08b507025bb6dae5921457a2f3cdfc595c7b33f8232f24fbdfd245d1170850acf28d44871ba0954b986a84e9621a78d4290e79b4a679fe61a16a1138f2a10b3b7b37132ffbe62adcd004aa2d5b584a6141bc9a334c622283f2f5255deec8ae018cbb1397305fea5894e995e797fe44d186cb8c9bbc0594c69d6e6cad2d748305e60b1aef28a4fdf671edc1c00d4b9ae2901c0ffffb9d1d7a7034f88559de1ae7dd78ac97ea0ffdb1407e4c716e22ad5fa08be4128cb812ec2b93dd3c725ebf80cfc69b232eefea1c2f5ef6f9ad57ca02c3181a98b6658009389bfd031fa0fd5dcff6e4b0a9c91c5d8a58a323ac61a5b1cb7778170089b8107a94e6164970e8bb7c30ed1f32daf9267fab025d2c31fb3de3acbd032859517c83878d4b4613c0ca8a9d4abfac98468a76ac8d7d446c30a37d7034e0b9a0e8dbbcf0174011adae61988baede68068de60957563e5cfc6d35bed92208cc53590bb047633da9318f60f68d9e21369f0f4e60d1b222e8d1da4736e0e510e558d2f6fa1ab1a997ae7e9f9e295fb1853a7fa87265f891ef9cbc662ff87618c491a31007543dd166b5002b854a309e7c9eb073b88a3e9cce99b9dda9da066d2601de62a36710c01d89befa9995d57457403d68fb09ce941ce7cf408e0efda54a2be1fefcf1c74b0f141b12622d34007f08240b1cfa638f7e4aa13f600486508dc39b75c7da91a4d7b47b932f3bd3a46f404817eedfe1d07e0245faa4623349212a351dbae1d7857c8b3d02ab68614bc2e5bc313530e5f8d84f43f4e30d40afabac4cc8ebbefbf07a499302f0bbe6c560e43cfe701d6a3d6b8135e98cafc3ee6772d66ddf55fa15285f89160d6c5d6f3efd13260fcd680259a1db5552ee798d9195527be8e1f70d87e16c260ddf9b503aaec1ae521b51b6e6f1ca181e9ee99e5e8590a75e3cb48c12267bb578ff85e7a4050602e5c3a17909c1c4d1f8de315db3a4d17366155f0b42efc56135162919f8e5d4dbcb3dd266c2e8caa82a21cab3d839cf173bfce33b8a7e6a5c646f372ebccae87c5994a092938559ae005057c777e099d0bd81fa104bb6399e8f0557bf29fb921299ed212a3b3eb4620efeba1b4b414fb031029f063e1f56268c75e76784874dba49dff3b22afb76189ff96c70f3dd6084bdd1fb3950ce427a3fd5319cb1a66867f1335aeb75f1f911e4d2d1aab0a163f98da14c2372ce0bc7338f9d139cf2a47c6b34669ef79c4144ec69086028cc7363bb98ad7fd06b18ab9764ce3e9de5a3a68a415a9d577b594bd9d48ccdcb409aaaf31e3d4760f3220d028366d7a17f43cf73064c33feb145d78d5ff8929861d5f21e9348e1da57781898c6756fac799772dc3843b7f151c002bdb5bff0b152b54af820157c0d4059b3232317c43c9c6d652bb30784ae46d3e3bbed9f9b000f7721986b9eb6910f9499137d7a827c0f4dcec70a37212a712f9be44d2e970fdfced89ee2ca85b64ff15faa97d27889ad406de0c819c94d54d0e3baee58bce756487c693d8e4f9739de45c49ea5442242d1f07fd006697a69dd5136dc33d144721fcbbaf15c7ff52a2b7cdd5eb0bdd4fc730b0ca3e8b2500a1dc15d6b64192f0f6feb47eb91d9e9d9649f839f699704319a46158eae31906b737747d8a2bac6d6a7d4ab73745c587e77cc2637d6b769016d5cd55886c39d301b4d78a2a9892a6b1050c466dea31eec3f1fc3f50b5dd573d3853fb406a460a3cd4f708eaab6aa6a755a1ecc53875be43131dbef6e584d04e5846c3a3c299790a106160c76ed6e945dfb7307e84636a7e174cb314c3c14c891585589bd1ea92b5cd91e518cda6da81437a1443d307508711e76cf29b18db35347afe68fb6a6a40853585ec0f6e3c09babc6ae853f3cd4bb6809cfa2f111985d1be0e9aadf2bc131a1c59b77ae7e61e847ba4531089a882c058b6b675a4ac3534abe8163fdaf2d5e7a98ff409ce957f14e32b510126eaccd0036ca8cf133336023fca3bac8ec7ce4943b13f2e93486202fd6d3caec0f9fb01f7dab3bbe5cd3a90ae8858e1f529e0403be26083fa23e24d6e6c2060cda25ae38f4607ccd8e918e247ae9c02c02315c7f6fa5413dbe7eb0c28be4f2df6be2ef4d45ed216bf2c654ff97a3caf5f509e678808e6bc971febc3fe46233e35cb1f9664432bf667cc3bc1ec600be19d10a0c96af1b7ced71268e3dac13d611bf1c38a81c0613899f006809c5ed0e793f86bc41c53246e350b44172ca32ede501abb8f00069952ad358a5620e6950a125aa74aaca8592c9a97443e904260ed4c118227a834f13c6f79eb02b9840eccbd5d477920436e1dc253e5b799260403cab3563bd0accf1c660b1775b92c3dcbdc9535c109c143483090ba759357536988e61b53f36f8d003db73fbcd70757dac088a9185f8c5f20ad55b6d7471cb19d77dc0015b17a5f2378752a2f42752222a9e226f1c8f7086495dbfebfca8ee27997e19b855c691b9984f3b38da0f9ba5c05068828930c564b15dc44ee1f2daa3056dfbe3f0c2f08b3910f921bf6ad0340ac8434c898cb3f977da4702d018c681bdf9077696facee07eaad8324ade803fb2adeab93fcf427b44918ddd012b0813a2f0b166514a880d7b1cf50bbd127febefc8795c74857422c5ca24c718f95c62d434058c54afafd1ebde9bcadbe7c0ec06c28fb7f60edc43f17685a1df186290166a4a3e215b634fb4926507fb336dbda59ac52fefb458e451b553560acf64ba13160a9fd9875b3c4e6738f72f541e7c01a64b4028bdcabe7a6d3c973dfc81c9489e9060e6b60f62c0b1af3faf656d7a0d0c658edfd7feaf77cee8d022f47c84c1577ff87164d8e3e835a6f2517ba5cdd3398127425f45a71b78cb4e868af9d14adb20b435e4865dfb7a48d686890a09ed8b16fc7a1ad50d854bc97e6f7271f62022f50f754057868c5b6b563bbfd0850fa62ce61d921bebac1b4281a976d94092f3a4690dc6d5e0f675bdc76b822075aad50031a5c8bf533c4031a15fd3330d2d66d5f8223e971ac6ebb774ac47f61a52e173ec707c2d7df1f7574e41a138cb5f72b1d231e27c54724aa5c825ea2c40cdfc97d0e9e0e09b80b1336df392154a007a5a32f0bfaf3ca4bca3c65b12703ccb9c39f6995de36acc0604e9c44d507ec1e8267a6de549a0b68ca08bbfc2500abc243feac42c34e834e35c6b076070dd0acc068d62549ada0115b73045d421810b21c4b7018bd772ac0b2b69c5d90360e6c246de12f28fd463819fdb26d4f5dad02e0afe3ac064339a6d9c3066224af6d4dc7e3b86500cde37bce83e614f5815c3f4c45cd8f0dc1c72550d055072b766d0dc4c072582ed96ddb14416e423e91c7ea9181e233294e6ba5dc2e23f696324550038b408f1fbe904d4eec12d1c0e820721139abece70a9556209665e72275bf796a4c0e1d0b7036806006980733cc4352f5360f518a4be30565a40abcb4003001842df13cfb5acf81a09f6f0eaa2f5ee762786417980ab4e38d627853a26f524dfb1d418be7964195a200551f785da4f0b75a360ad352cf997d6460689403a973714b874149bb128c2630a4ef3ee538d2bf683e1db35801a396f7db242d3813ada136f2a326e0f4bf26fb8516858b388162a6afc65bfb31cd1162d4560fe12e0d8da82a00fd4a681db868381c1a431dcc555941de47217b37e4d80068da9480b258e5315dc6886d88339649bc8c04ab6951d66a3e42a8b13088e5d561a5e749333279c22fb2ff0461ab26af83b7d59ab8ca057ca70df445b5289c09741bc28d800a1cd35b22638939cc7ff56772b38437a50736fd50202e22c31f0ecdfd3e923180e242cdd5ea111efdf7762952da65339d817484d9aab824972f27463ca9d771df4e8c0ae5f260e442b3341cde4ee7baf728b3d3bd7e967d184110b47a974da9bd705cd92f9dd328e8c4f9c3bad7287b174d915b6107a20d9b1a7e493bec076a56d7a5c25e63e895582ad0f6c40c99c5e352ef278bf60e57fe81882f1233994aaa6adc88a4a2b6ee17bb07dbce5b418aefd92301c73eade2d8e03ab59e5ab2dc3f7afdd6b28234510a978474499fc5d7a890dc49705706838b885a9a56c3a09997fef8d4012c67c3a1c325bc972a481aca87fbf3b54ca0621b0637cb6c2573069f7914aa432b12c82cf7f2b18084f4b00b5e5520f6a18d6b7631b96fe1ff876521225cf7792696b8eacaaf57f7a513cfd8acfb7b5c8ad4ab01ffa0aeb3141cc0a492c6237b71c9c1fce65be5e53b19be9f3acefd1bf899d2bb77a14900f92b913632407143b3343a88d8cb62b2083171563cceb1297358ba819345f05ed2842d38a99aa44a9d5ec3560b362f89d9e74844b24d2fc8484cf3c925204ca1993fd28b495a44ff68d05573f9454c46399ed2ef30422d853feeec538077f33001e93c7f72322055df1935e4dc6b7953cecd496166696c83926d361a451e4b3a7ba3c4bbbe2e5b96d50c77ad087dacb77fb45f0e06759311445bcc8052400a9bae3d193d413d92ae9af2ae19cc07629ad746204ac79b201875778e6fa14d445114108cee462c879da081c7e6a753a7925f4e04ebf3c60f203fe39431ae447e103385b9219cc14fcea557b1565281f65f5a318f229fdabf551acd481e8870f620cd1c2823081099a303572aaeee2b5d9ba8977a19b681f0bcd1304ba800f42397665ecb56bfca914b641f27ebea7137aefcec7d13048e152f1e1890ae0472bffd4d75f7ec4a650e8e5bad23866acfac2d0376790934670ef4fecaf9d379847efb3a82ad8f3ddabb5018b720cc244c1b33b30179911456a28c6ba0874f6d5a9be1f06292613c254a36df4e466f9929ee250399c3bef594e408431f585defdf5125691d340dfde3d1be48540a10c602cddf84153ad2ad4189b396f9911085524429124241a25279875589c69bc4ed681c1a86d85bb10f41dfdf7f8d2fb39310e52093e3daa4ab10df623fc0b3f8fd8c604d6a4fd6ec8572a9e148644f1b81525d146e24f94fedbcf3fcc476cc16f17feddd06c000860d04415e5da0a5c1e4c88c90878ab378147290b03f4b0c93dc542ad11e525394c597d156e2ae4748f6584c131c4881b5238457c32a8e69587138a6bfa40da2705cc7edb82c943ff4f4f9e3d8a407698829f53df64dfabc4f37a75727d30db8d7a685c59e089efd739456501e4fac3ff94b612603123b8f053d03674453d7698d59d8b4da61f7df6f7aae1131664f51331b619cbe8d182c54729f7bd977e8d8f3cc584663b07bc36ea1c5f4a65f549764e116b40d14da24d4c2ad2a901f62a4d49a30de2c83ad17e196d87db1dbba141930ee1018106d250a07f80a2c1cb57fe8fdcbbd34a125683e4f579304614c78de6a4a394e61ccfb739496b45df1b0c35315a0fc4ceb73ee56cb28c2555ca2af2c11a9ab5e1d6eaf63e34c4360b79c8a90624dc149b5e4c13ea8b005b970a6170e49475cfc0a575a2f852d70dc625be7045926c693cfaca6efa4b2aec46f3790cb2a04a2b28bd12b6e92e948c4edcec44e5f0756c3554db9bca3a398bc116541995eb8763e3105b38cbcb91181ee3ebe1a215dfd34c58cfbddce608d2c45b13655d1d862a5b7469c1ca28805a49d81748f33b6140ec0cc8b9233255e56d35ce11840f9f894214d1e28a99c530eb782643b7b279148572a40b9afde27d9f0f12a94941c4db4b3005ea44d11adb6d370efbff59fb7df2409ac6044393722358a5e17dfcab288060bf9231bda9855dc3e1e22bdc19dd84d6cd8d98db0e58cf411b61347d5ba02045b997fe38b7b05136a6fccbfc051729bc548c21118b3ffaccff344139841b3546aead19e51323b6f4fb4dc5413013baec413dc32abdc931d52f51f0d38ded32f2e4e652c5f0a7ba545ba8e01726595aee82270f1747e071676ebd47386ec9609412158cdd985d882122081b42e59bf2e37613bd39d0a920f9d9b2225ab48ea0720f47d7d683c14a3a6fffe82e839769607feeb9ae1ffb0573ccab36e143928089703ef96776b0a92a21a41ee5baed61e56e6d645edf292de0d2bc3eef817bfee35fbce290c4e608f12a48de36a6edabd5228c041af38679efbd7709aff3b2f2bfe719e4123cd85c03a4b75065ad24e2ba44aadc6012583e2cca9a56e576daa9f79612c32fd06dc5875f62bfa11db60926825b33fed6080abeb8fd037b2f6de386bb95d6409c96f8cd861cd828031a66e502a5d73cc60e511b80d3470dc8a7ffcb23a2ba8d6ce06c1cf18ca5a0a191000f094a625533e070e1ab92d3b73fe1d48e5e46834dd060dc370bb2c89d55950eeef72ef058981180cb3529e1338eb402fcdac6d36c13c3f38e643c97af39ca495a2003ef3ce67fca709b39e63dd484ea6b8bc3f099d38b70552157161520b46ec4a902c78a315ce1c0f5ba9badfbedcabd4fb73745797852ef654dc8c229e259a73c7ce4cfb2ce375301409a8cce949dace3f48048dc580719c04c4d6ec894f08d5062bc4aa9a314a5c7a274ec487a22d623015fafedbde40730b69b3d4feca40e2fca2aa85d89906ba5c588c5241cb47b8bfbb163a3aa476a3c56960c5a2819484bef8a2dce00749cc7e885ea1baf61c0cc0e5ca9d9338bff0e2cef76deb8df6e7ed619de0a465ad25b3d0560abd60e199eb64c03446640236788abda90f56050b6d2f106975216142e158b878769bf8743d6edd49e5f3a48066d556f98636213d8fee09dc91ab834927ec0e4a72f543d8508cfe317a68718580b57e59c6825880acaa7bdea0ebc01665668a3d8c70a21818806f3750dc4c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
