<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e43e4176897d061efed000b4bcd59213eadb8c4bb7f1d9dcf2d540c715acef3576df3a31ef2a450729c0a7d7ef64235041a694602dcc2cbd3181edafbd5486d5def13615ec305ed502ab18d9c5f7bf96f6e5fc5a4f00c565b6bf44c677daddb5ec168920efa0ffa658616228f9cca01a67c772987c20eabe44606f634444f77fa76d625daf2f743d58827864ece4ced471bcdfc53cef92242a531fb02df9bca45496dcb385d54fb6a96c660f17072aaa543b44f23aa4b09d14781eb9b41769bbfd5a789220bdf35f348942860edf05985c56b44eaff1c37fc4b72ff9cc0643994f0c9d6920a17441271cc7a601e9e004cdda921b63577556b1da193c31149d514a7c815af7a219354783b83b1e94425910cee88169cfccf291048156330dbacc23e8d4ac445e065aec86f3f90c84c7e60feae5abfaf396d4db45c07a1c4557fd8acf5ddd75206ce0c0d25d7898a47e2676d51949a052380bd2cafa0cba474c019fb0c7157b0ef582d6d96cdd7b5ac00fea830ac1168a372834197db47441acda427bc763d1b5ffb3ef1750713efb7b77cb95556919314c5851624d46dd75798847b7bbf4f6a8c70130bd9ac26609b35a10be6817dbcca5f1e22e7814db0ca4b196ec476fdbeb473f5fcd2adb1325d3deade6ee70ca067130f32731d18316bc2d08992e10072bd8cba4bfa2d8388c358b736b01fb286347d636bad760f9220d466f149aa2db74925a6829e0124d76de1cccb8cba3e135de4fba6a7a8a6f5e74c22af22f3cf29acadc7b2241de8f32c29637cb97be9cba27f31242db2e40fde8c647148b65b0ad74b3cb592b585843de779946698d01736807b7b78911f6a45a3f778713b5c4d1e98640bd0f4d314434a3917f5a2ac28b981490ee13a530d5b85578b7b5017c061a48758abeb024ea1f42afb300eabb4a66058efacff8d92a3e5d7dfd3968f6faf5fd99642f3b8dbbf53ad566eb887f3f3ca03d39a1be1f438741ec8af925ba9d8a06e735082c30506f28ef0d769839808b54bc2defafcbb8a8bbee750cf37cf04dcc3a7fa82fb595497606903414ee714409dbc1a8069e954a6c313ce17994264d0fe65a9404b32e0405690fa149ad87bfd91be967e8415061255834f3fa616336107393c49f39ff94021199dd78eba4d76b4941e9b4affbf92c0ae2af5ea6a124ff7c90394774f01144885a04bb785258726ae6cd59e284d5261d9036e7d1ed0f5226b24d8181a026ce6be0a303cbccdc5d27cac5d2b17e12c71f10718598b20e7cad76ddc9560b3e1f6afa6618f6d6e6da720385dc615717ca06aa547f7fdfa6042fcb0260fcd4d8c9a98847b8abfb5953e66a510b39c4b0dc11091ff2bbef7236e490aa7679a7b27e674801c26974fdb33cf0fd03667de8a28ea394d16b4f5fe10e216b65f49eac05c2b78dab3db35f106c0e47c1278d26d57e65d6513ada352d008240fcee302891f7a312b474d32c75e5223368e61f78d07d93c54c50fb3fa1d8b350e307c4c2e5a7e640947b5ee67c5cb0781c089376758e645e6847a17bf59e227f76c9676cfa1bfeb356dec1521dc186de729b1da041dc03d6d87e306dbc48784e29390c55112d46e1d56ce80d37f6f3e7e136434be4e4b9d8e192aca9b2c4aecef95af89ed4c6ade01414a2532f70f17f8ddcbc16884ff48c8b86e510f58d5a4ec150a568fc8cfdfa53008b4566d0cc9a8bb28318672211ff769b6c86110ebaac81f7d39a0c3a77027093d76fdc7d2a592f30951204c920b6c507b31e37f3c6e14540c818eb9911a84cbc0d7c45e7a58e9eba17ec2a20214ffd7ea3c64438bfa3d1aa4b3aa15d86039c417aa113339ba39530508893d96cb8f3a1db7d4b7ad529a8062f6b6f945a694ca644c10d19cb7bf4f9ea1af313ee31724991a32b826e0fa44a6e45f3dc0a54222d6fdcd5b6225ce86b2e1b403f872b5d7910e4ef27018ea65d55bb8fe09d7a97b68d02a72c6c03323f26eb93b09e82af119465b662c09a5d4a42254a484586e367192d77cc1fdd00fa0c0a348a1a0a37d72e2c65b00a17a4e8de3ec4ec87b3beda09dbcb393d81639fab373373298d4784f0fb98aa8a1f7e7386f2ce6ed4be41e516477e3f4fe46c5c2ee94ef1365db274ac2e0a5fcfb022a920c5305d2490beafa8c7add4a3559c8fbd00ffb70ce0bbaa8200dbabdeccfeafb99c429819f7dc2593a17b6339f9d7785b12de922a854932e7e4e37b302bac5ec009c0021fa5713b9bf5845ccdba8ef8e8cf82021aacac1e4a487f43a26d5fea0f49835836166fc728ffd8e73151f5453fbc6e0e1ebc6dc40e667e1b349965d49b6e4bc37d860e9d648d1681c89695f8e69d234718098f169e6cd253b377379a67e7266cad06565f76dbefe84df953dfa11cca8fb496bf2b5492007e8ad7f03462d552b6ae68e39513de59b518c879ff55113a0f763d5636fe18dbc787f67ce77743c80879a099b1a9cae75ffbd7ebcd9ebef4955e84d7f3aa3611e3dfd5fd280c6430bfac9294d81912264f78dfa3c95d87c160d03b030854d668d3c90a1960e37f329975302e254e7efb40c8b081e210270d6877be12f5b2bc1e7416aa9e3e0930d402895fd9b3f1125682e9a443d574c9e4083b5b031112d42fb29331985dc14f20b06757e20e00ac6e894e560789b4b16c612cc745efcf981620e5ba66bd8d1be4cf26729fa5d2bcd0e4a1c4f07a9320c19307bb580f610f21fcced42d1dbc2ab1d120f40cefdb0305d0da4d0511b909b5c00ddd8f0594c3d9c5c4139bc3601b358e28a62837936b15e79806019f6ae0ff2024de86603c0b0d6a22984e0aec799a14341abc171078acea3a32a65ccf2d9748174f6f5535138c5c0d4e7803acf2d0f5a0737924822c1ae0cec1364fbf54d91fce42faf846d716da7671f72f7937583975db0c61a13422355cc064ae1773e08d3272d23284ec3a17e4b67fa901cb248126f2ddf01f5b56f7ad990ece97538d3522d5ddc00b9eb90e3c7cc293e6b2651c53a656eaed5080abd4b5292b2b452df98741e833261d5522a21078c9a9b87994aee6ff791ed6e29cf696e3827a8ccc92093df546ff93956d01ab97878a1f725c24c202635d7a03312d60b8be187f6977e333f2e1f62ee6d86b1f171d8262d60e6a3ffdfc843c727197aa4cb000947f21e289718ca18aa068f6c8c497baecdd0e75f0dc3ec7e1b0b831e0356aa32996a449bfc2ee81b4d933cd3da3eea71e816cdbac3e98714949bc127e6815480598079b4bebdab35d678f6180286ae4b63cf0e6f3bd2d8bc3129fb892214993bd64f95211f5576cf2c24d3c60d55985af6f785fbffbe1dd9623e53399e3b280c62ed15ca0c7cf70ef69e4ec4fd0cfc90ef0c1057b04478972dd88dc74318d2469debfba4767c1fa9717dd1ed9f7818a933195040e9d8b2fb1fc2f0feb3dc71884c48d685ac762e3b74c4ffcda66029c09c72c2186e35f7ee492552185be89e2a967dfc4716bd1adcfa3c1ecbf1238a728a27d3da006022f228036c490be402b6971a9e2ca33aa3ded3b6260c1d3034b71590332851ccbffcc785d1b34b771fab304bc18f7f8929aded7234adcf93f0229994f2a5dc51675e60ab0f4feea33de411c5b258d23b3b8437b4ceac93f377afb1b78146ddfc1a565bb5a403c0466fc09cf8d7ec10d4b8ac39e2171c2d5d233def3fd3141d7337aae91a9c37b6fc1b3a2aa7e7900a7d9affc40c913c4a2d892c814a0234168243f95c29cb8d7cf825aabe00f97bbb492deab3f79620158483c334218f7cd49d88ccd4de35183ab15d8cca720554ddd1765a54c4896290900a9f831aefad2d8fa040be6e4b172b629b5cca1e0b5483bf5822970df6cf6b3ba68b799ce53fe7277482e4d20cec0652dc7dfd58ae896bc5d30c7bc3b740341cca7b1738adc469f8c8abbd56b37de1a32dfbb8e8c42fd666921bd3650d44a07a36dd644284d4ff818e4e172128738be49ee534070e5669ef9f4a3aefc560d0aadda233f06be4a2e42ddb103f3c2269992feeb14d305d36228a21e79cfaabf598b762bb5c93ad7b146cf026e775fae8ef70c47a2181216a55005fafb57513b2a381333e65b8af28b422c79d0579519c1f2335d712970748b0d8f58decfc148de09ee054397ce4da8a36d4deaa5cacbd1af84adb9b2eb88fff99174f6a63e3fec27cf9fa05099de057237b39714fcf1e4e6c8aa32044bb91d719e6c00bd5da6ad474e6f18f562beeea10b97c04d7e4841f629de8232cb8b6ba1d3d416044a6f5e4f8089eacb8081b982850ed52165104d066aa246d3d94132847efc64f972442f4a689abf0534a2aa8b3829668cd249b493c389dd28e8e60b61cb54f13e0d8deea260a7c5f36f86d9a0ce0ec61477e2b27250b5874144805aa09687d83f8e8f2ab7fecca8c504c7905edd740913efac28080c76040e5a0e783091146934b611100bf2b5baf1fc4bf102881cc9ac78d9b97dd88e413e1ba963d223709674e754588a3380cf160068ed0b64fdd2898788670a57088821639b30d2b1fe0bc9418cb15d07f98d2c7020113ae44fd4cea1b0eebda2301ad03e30bffb7dd5d6a4a904ae46ac96e76484242672300c547c77226d3ba7eb4949b95debb2b1533afa3ae335e858e2d23b9b56f812e65851843e67814bbaa855646c370a90f39c2fac79a3c3df5c46134698b723614ad32b0c1809c9551908911248297432b68adf204ea3ad6b601a45f67b979b9377ea7199213dcf9b9ebd2628937eb00ca8f832d534cdad880f2671c4f2c16039b9234c98db7ee13bf6d1f41038b9bfe247edf24c14f0990afd7121ab92ae4e32c0b055f67c1fad529976912b0e6a8907e7b87356bd3ce8e678a879b648f72079d68db9dfc72857f0080feeb2183b7f79ac029f98795a939a0c9676bc2ac2b64bd7ae4c0c2a836dbb0761441cfdedfee23d31432f296f5c3a4b9624e4e8067be735c83d18c69a4b9fb58df463c670884cc3aae3991b7832fadad95e7a1265aa1bfbd8e4d5071dc8b64ba7ede5255251d5fbe1fe87ba6de4b2e4a2e7d584c7e1888767bed12dab2ffabae39a7d6cfd925bb5d98f81800ac10d6c417c45dccc84a9dfde2644ade9dd66f47c0a57a63cc35cfd36ed4dde76637965f7fb89daade99ebe478d58c833923a5730974fc965201c6ac653876a2d8e9bd49f1e31a3a7e7653968be52f9c98059c059346065ab01aa1ba219fe936be577f17feaf3e951639bb1f10ff70dabe55291337832d5bd33268676e9784c744fa2a138e00ceb4ab2f30086bd2847bcdaf6577478c23337a7bbaf641c13bda134d61b5464bf12a926af639bfeea4d794a0f10c483e4666677db7dd432d526ff9e8914dd6b88417a1b1f34b88e6355478e675ede780d6726c9a6b61d4814085bc0e3ee2759246138da4e872b098095ef2a01bc542e6cbdde1ba601dd53d0882d1c04ec0a8ee27ed1d91858f6fddfed6aba8ba1e7564b4b1c85da5dcbf1e12ce5cae1a05dc2e9648c00bcd215bd73fada8aa53007bd73510715fc4c79b269dc61be99352ebacf8ba2405d35a8007f71b22f132dea24d166c855d7275f1841f0ccdc488d917bd1395b45c2814dc156cfa207a81819e408ee0af6bcf45cb6593802e8fe39463316332f892a60d04eab42e7862ea86a518e3d87ef33ba29a9b442eff17736781cf656ba5f400dd7bd07ea650649926829056e67b385c048e01a685acc42bde1f32e4a76e9506d07914c84fa184c8cbe13c4c962753ee23f14d131497fd3c60c807feb2b99aea1d5ec72dbf37aa76239aeae33c4f67c8c4bce7eeabb36829cec5df5eb8ad3bd12981ab44adb3ac10d6c39972e51a6a26cd15fb003cf210ee331478cbf4a8cb076f534f811c3f72d0be939c6e2cd3411a8945b321b7d2506395877d1a519e753cdf8c4240dff3b59eca739a734d044b56affc4853c7d7a2af48498a43cc6dea45d64ed35ea04ba35e8e13ad86f05413b7c207a842637ec69442c5febf96eabe1777bbd9f74f7e7437123acc00aa43d383309679ab32b332d5dd53c2de638136e79ae3302f829a291f1e6614206496742860aaa560959583ec512bf9a1b47b9d9cfd797b834a33fc03a05ebb2b1a16913aa76844a390afa646321d4098f6b4834dcd69ad85b4d3d37cf9e5d0b5ffea8364f52bc8422a0958e3c7556f336043b43a70ed2ff761a8812b90950db60315390c2eb34f62ba7212f016851a5e2151ad4e8ff3ea4f64fc00f0baf58920b1ccac707942719b8e66213afc7c52abbb52084bacca1c2ad21c8321bb488378dc10aa05c3416c39dd43e084a5311209c95ccdaf91c9066a0baf041ce359457f65b0de8562219d1ec2ed8c662bf29e30281af937a29547b42ed6722e907bf5f35b77007c647ff3d4d0f1aa3f4513feb7f4d32987dc4a5521fc6ab2a111f4b7bf200bb47a12023299b0fb5d45849b975755131f87d62bba5ccfcf6207aa9eca64fe1626abfc1615ba1ad9bcb459c5bf0bc1a27549afd9d58c8a35c50ae2d98e78ef453bb33e661999e2d17eb3c45446fd9b73094d62e8b34d08b16b0f52f04ba3b42422ebd37598f3a186ef44ebda1deaa557b0692dcd1d7a544dff51a93d300ef33ecc22d30a49d86c031bcd8f5b429a924518f7cd53a235528b0a3f62e8d769fdb0e85f6a40f32ae09a880822dc1ad5e440c2fa46cec8fd03fad95a6b7dd1c757db17ef4080bdfac7f1437eb20c6c2bd510b488f95275ec4aeb95d61a378c5e015c68594aa64c11b959b878891a93ba95c3f54e690059380b6957b0aea7f15a36902fcf56e9b6c733c036204d6e4a0a2af61157a68fe9cfb17bac87ee1f7c66bc8ccbdfa36f5d7cd87b102aeef60badfb531cae11d1ae5e9bb9a4096ef87be6e095f882255de3b8b553765e4ec7abd0ef469bfa5452cdc7c2b25aae658ff78deaa270ed09d77c7fe22f93503fa92d3a48ceb76f07b475c0c791b5b2b1a6534d63b15ba2edfe4b1d12317d66942847dc7da48eec3b852539a2e1912b5df898d830d40602bb9848270ccf60962976cbe0848b10d17cc66fb8cdd85ccff1ed5920b51c862bc0dd02f860e949063c39193eb4762619a84dc29aaece8a6c49f7d4c23de08c75cb660d1bc6c3c59735d3a7e5f66e29d1a5ba4a6960f75f63fa5f964b8165711560a89b457dcbe03a1ad40afd7f22fa00fc8afbb4d582ed2ea0dbc258c8e24d057c58f346d7b29a5b04a5864f30624ee8890a9e0d6dcd1adeeb1f7cf3e357a340786b0c295027c3895f5914e440fae90ff3b2bddb795be4c39f080b0f0d42d2db7623ced09fbb3cd9606d3802e8b61b1646a228ba6f7da33ae98f5d0b14b62ce9cfe804bca52d563a4aa866da1576cdaaac6d79975c2b673c21e94da3bcb0bfc64e0ebcd6cd1fb8c1fbae363d6d1d54877032561d3e0685c2e4b4562cef31ff706053a59454a9b76a13b11a40302ed34c689cf1e2da38bae1e25d7773f72534b357ad93b2ac0e2c098fbfc8866ec9e83ba6bc96c38043f125f9c878d9fea5e208be7440a37943aaa0b77fd09ded22b517e36bc37590867a5c98ce805e4c2de46f3076cb870056338db093a5c7136d5bd5d2261cabc78af1af137c1bb2a32000a67f9167fdd76b328e5f44c8efb457206e69270b25066fe09cdcb5157fe60c18f37f195aaab0642e45774e90ffd7b27fcdb08c91de9622f7292fe301a406f119e66604eb81bab95cc1e96226d0e55d38b4c36c3752e6bdaa21380d88f24873dcc300d58b055978ebdc8dfd6610375f248e4f1c6ffc40cc42312c82948d53df19ec0bb49aa84d8050d1115a67a92f4f6e5f27dc8bc7aa1d64d97b92d1fba98e051b4bb7b4c3ab6ec2e9786ac08320e19cfe84c5410d913123a9f82bf3637d0a0ba84abbabe5231df765f9c71f6b427839cfcd113a3203ab08becb7f9178423dcd0d04582a6abfe284ceb274f90b3e4fececd2b52fa788c4ed2a6ab071541f21d91b44085f92daeb360f0761fd4655f0a2d08f37e03088c2394c46920bf884763c75ba14230e0834d239ad3601480eaabcc4ec325e58c533525b3f0f0b72e386a58c42e0faa618a1170ab64f4967f132114669b8e3070f605f6fe746b691b1670accc81e733543b7ec9f4712571ef3207cad6aa99fdba98278fd599980791f1fc4b328d4b476b4f647aaf12190828c20a34cf3b0d766f63a09f6a4ced16c7d47abb1843b7804ddce8b7b66f523d7e2aa4f195051a8c40b6df0c67f9433f4f9996e893a6768c012472295383b98a7b6d8697e2439b96e16c15747fc82db0e15bc19435fc03f2215d58cda349e9f5e6a331850cca141cc3cfb21e9c1901971c56672188131c95fe95a9218fc63e58356ec3cda526895644f5258fb4e6504510a7f0086c0fb9c4a015509ea717e19803db85ff7952860855c81e5a61c57fb4ded265e323825f2887bf1b2c4102f94e79e9486505defdb786b7f1dbc9f06783446b1f430aa7656b02e3113c585eda132d998caa2d7cfbac032aeec3bc083ac4f7d3e8571a807497ff3fc34ac37df33ea1878c3642ddbbc9f6ca83d9f29102d65cac9e71db694046ae5e5a8e9545409735d9fb15b22be54581d161c89350184ffcbbccef4ec7bca7527ce35f36810f09b391b628bfc44651a8599dfa5a4ec38923f4ad4c5459a214bfe0a5f1e3684376c1a5d1436dc260c1a0e1d08d35b580dd20e6e2c5aef43d6fd3b17ab8c0e4ad2f119c0cc896ce7e710c7cfa43aa884eff6823aa65c93ac7b295af930a4db0576ab79474798dd5f570220b04fd7ece860aba933e66a2092e1ba4eedac8007496a7c9cb854c5b96b0c1f02eaa0c0cfd351d94c1dfa4aae84fcac83c6e1342951b992f9b1d64d33b88fcc9142f0d78b9732e1f05980a157c39a6a4775ddf6c2117f21c38ba91716610a5278f9a7949fa796184a25736f1a497c0a02175ce0dc2ea52b85cf6695ec6fc798450201f886b2773bf7d56c4bb7791db2908eece538d3326cc97e34a71b84eaf08bb7d46a51dafff7b0b5b4ac91467402ced810afbaa968869760194e763255757bd1abafa59f95d0732740705316e6492a093e2becd64c4ae9c32721f335aeec6432dac70b78b08a6a17a8b2a50a6e7200b7ab00ddcff880acacf7d5b7c136dc4b7b0b6fff511667aeee98deaa87fa8b633d0511efb67f88b9681200acbde532b30dc649c519fde9da0a0dfab062ff71868d6f617a43ac063bf541d9ae3eddd37e02b31d3d776b0875e7d55ea67a72f48a0fc4c7691daa2decc1a7376998606eeb5a118493013b0762b118ca0791061b704684dfad31f14e109b9a719c2b4f065f57caab055b4d9f15a884d5511d2166cfff67b3e9daa8b88aa0f73ca66bf5692d4cde1f8db0e9048a696cd8fe44e3f069d983078da3e489defcfb34a82b0ca000cb86e27421acfacd05044dfc647f59bfbd2fdde1cff17fa75480406feaaa59c05cddf58b1c4f67c8f60b8f29a56ef22eb094ff251b21e6f2605fdf9ea3fb116e42cc142ac7e7290f58f85788c99a2645b03bc963ef2328e7b0a344fbfdb8c9573584caa58eab530f41a810cc56daa77b23beb459b1ad865042e2a2f4df33f3d5128d535279e650e1b20a86e621d45f0ebc9aa1bb5499bfcf416b83c4ff9f4a35eb41f1c1e4a59247631d4fa13fd4dcaf5df0cd94ddfbd34a33363a538d69bcdaceb66738440b7a24e78dbe08aa7c1b4cbada3e5963ceea648346b0312f0b290934271ab57dae9ddf170cba8629aead933730fe1bc409caeb2b631baf04747523777cd94379ac6d23d3d0c5085fde6454d2f87d237258a93d02a884b79b0eda0297f2d3828032c0b06854bc14d71a35c77e6bde75160f99656dc9e9a71b9f79557f6d1dbdba9baaef4ad97a7fd0b2d90a6843102acfaf74c43524b69f689aa995b54957811118eb0133f073dee14e9fd428b0f4bbb69335400ae2447e2582a8458578c564f1d765397d77e107e34e00b70ab71b93557f18be4038ce9cf8090ab5f832e7f4b5d02b32a0aef37d730d2bb68356a43913abad6219338e23952df4c5e5b4c6a6484501108627fda784e6599972c1e09b7f4702bef42a6f6a9d6db279836b900e9c81d4b00d9b626521f63c7151cb541e55d114ed8ab7c96680c0067cafd29e51577be3d7365edb3e930110fc98512571745b6323740ce151103e10ff0746d811060cdf39c90e6fa19869fe66882f1feeb8ae481de7d9e0710f68b8c5f3ef26f8a6bae9b6946a8076d5e93796424329c2e4632cfb6c06be38e431aa133710d6de1ed1646a61731539b32a1d10580480e66ea5993446c6dce199169d4f8d9d217704764a35f60350bcae0958dc32f7483515d2afe69f8c802ccf574ef129501d866e741f6ba38c9821403c5feb2b33351f43bab233637e8f8b956a30cde673fdc9a3f65bb043c186b8ed450dcff052bfb4ed63efefbf806b9206e746ee03f3a6fffe916928f409e4c56502bf91b791c39f0010b15b68725761696e6f521e223086c4cd0004bff084d6271d93ec1a703375cde88d5d76a210cae382ee78880e5be32522c9d592be1157459f091b6c799ddf5d1e240ebf7e746c4e8d878b4015911c2c51d0b4fecabcb76b411c1420574fc350bae3005d7682bffc762e3e500f9829df0f507f9703375ce9b04362e2ce09d2567ae580c621753dd4823800adc299fb851400cf791319f68a45026f414629860df09c49ee2690963a4861cbac0a9c80ebbcb96a6021e36d6cfcd74243b52775da6f6da4afe162d0f00be009db992e286fa08f4823e0cf291bfe0b1473b11999b0cdf146677eba4255667fe952f94b386290e0cb80eab9cc49214db7eaee3837f0a3ba684f7604595b699ef821df2c1efb6bce6913a2c02acc9eb655722eaa35f53d2919fe5dd41da4612fa7d0a0be6276fe79147b771aa02e27d10454629db73616e265c5f21e020ca41fb182709e00cac2a9a1218583ebb5e1642e8e1c85548c6140489503db7402b79c6bb82addc58826990a190989937e0e60cdbbc17d4c2c044831285f906c44ae5c815d281b1c8e2cd4f193b4dc8092f69a0fdc0408c457bdea719aa7e914e56ddc5a39ec0c3510b2039ff4d7e4f1fdc90c074449fcef4b74056f3c355f486a625f73b7856a376fe050d6e9ce93e5a537ddbafe9125fb9ef0bec371fa3e6e952dbf7a8b6f81128516c63587156d5b8631eae662cc22adaeebd48442a0ea45f09a2bd9a0099ead4500bc5d5767d6b7aa8309f4da3a51fa237cf0a29fadd7700ef94cb874b20922d33de42491fb2aba5e4cfc1e492d392748efca2e6149bc65c97647e06feccef7a17cb8fe0571f0eaf66e834cd0e81bfa2194d2355511940bf3d395df95c1f9e0bafecb87d9994166fa9aa2f20200c0573fe65937d3f8e5410a19fcd134f72aedd5d63b0ef997a97a703653229bc430e7f2da30fe9054809ba5035f3b2314404f7aaf1f88b3d9b9e65cf015e36c46c6176b78682513d3ef1b46a7047a322c0cf967925661158b747943831974ddfb22fb554bd91f6fb38c23477891eaed6f0e9a5b0d4fa299ad59afda41fbe3a6d10da468434ab8f5b130818040a462a1596faca68e4b25abf473d8770a6ac21e1a8b3690cd44825e46444fd86243d9270892f53074fe359e46baaef6ebe4867b1df8e141bab4942af43c6b03f0cdd370ccf6b4e054fca33b073f7260f6714967a1d5d04ef2b9ebc40d128319340e3b3479b73b3066e31aa4dfa609fe856f46acb9dab5d43a16f89a7d486753da2853cef8ef79bbee3288c75d651d719dea18746bf9b1c36cfbdbb3d5aa66d16fc253f9118ed8972e611e8a8a5320a3ecdc775a7ca3154c0dddd517347cc9333cbe18787a1ebfa9a4c874603258eaf3a80a8888571232668b2f117f8b47c53b5756924b231003463e055972f1300d0741e960e961d71c3327ee7d4461f1d3fac791e2f5e206774b02eb3ce12c0d4e9122facdc75776c77fae52030b4e72e9c4b3b0867a1638c16af42062315045008a4d9cd757e984b9532a5c236f6a1620a17b50624879e7b420dc169f415949249fb2b17e5966d28196dc0fdba6db0c85b0a108662a0621b9022d99030d91f071460f99f8aae52a09459e8513d0d6905bdb8f221a4b1ce6f2e35acd8fbf59c950cd8b15015e078b1fa186c39a42a44e0ab95189aa5b40ef810041e94e9fdf4f9bab473e755438c1a8f3ed79541d48f4816fba1e29d028f7dd3781c6f517073e2ce28ba90ab3fe32a494f4d716bd90138785dc72490f5cc79c7edda34af9b37305f52a9b5d06bcea6c4fd3382a7318ec2f1d1ee58c41412c236c4844f319d5cc5b17d27b68214642562dcfada40949b7d605f13d0dde01be888ab93040c90b2e19da3eddda59cdabe6f3cca6c9b0b851ce439e4018149298b03720d62697de2283bd30e14cd23839427b37bf6abdfd2832a3a07234dbd1b7b38a8baeb4ea47c9ff2688e68ae4850da4fc0a34524c34d047493e0a0bec91d58c8904fc4bb671686e3366f75368cb51186d4251755dfd4d67f37c6df85e377eab43914a501128350babbce50fc93c3ffed1c56447ef9d8281b05de94fd93f12e8b96d18e6050d87569eec66c25881c5d279e07fa70792db3faaea4f0fbf3874ce6ac36eb0bbc58a03f571f3afeabc3e0995c70a4b2296cec002f0d0283c3c632daa81b4d7ef6584b29c2538265989bca7f4dcc9226f72d233d0147f08e6adb69229d712f7b301eb77934693a00a6e824e37a94007756f895859b2cd810b43e820fd9ea9327a35b0f2ba549de3f3faf1bc0967e87ff8bf778b5476e44028543ca76b622ee56b019d08b02fd3728ff80143b1fd1313373f12647bf59baf08db3330a423e318107baa3d744c65a9e0ec909be0d0b235d53ddaecd5e65535659d5185873d9b15b9696e8dc50fa823965c5a5cca947c52a11e2015c9d5a2253dbe306265d86740100b8c796bdbfaebd17f0d034a61467c8bdf1b0bbe347c8c4aae34b146dd048c169c1594288d6b4c0a41e41c38a4e0e808383fe2bf76378d6f724815d4905ba56f236c501e378ec256e57d97dc338a74edd8afde3072955691581f188a7da1cfdc863c500d478d3f3e556eb49ba4c026072485caec6fb8ebd6b4e7ddf9a98dad1e695bc3571406d7f5a37ccca9480d33ebf35ca6aa838e3d166d00c0830c16fa60988efccaf3c712906483cd63b83855291aae080f1a0b3d939eea95cccf3dc66114eec1c9dc6f51b2e9c434a0e0e60880abdbfa4c1386c2d0f4b7e50b23df32003226cd3993838f096511f31fd2c0aebdcacf4619bce57c366ae79fa532b409b851e6e0dccfef2a12bdbf427c6edf606171f55bcc640896db8a466984b5cd6be3ca13d8a2cbe3076970e68db4c84e031a5d6f15dcd9df4dc42f3da4d99bc4de85d8de6d28f54a0b161940b75d43f581c89e9298723f9541adaf922e01da31c154e7ed3b07b6660e247e4a51b5123d50c000330a876b5e8405b141402a4323ed503d22b830e89f4bd2ffa1292b75d0019acb05508a56079f34829e481bb447769222779debe472f5777fe87ed0ff611fb89b6b029e726af7883613d4cfe5bb0c7d126a1b9960108c5374f5ff71df7609ef4261b301ed5ae5aef92d3cc184cd18d70b254f8fd5bf9199e9124b4934686b430b143a3fab1c0d1b9d58c4c0f390e2e62cee3a634f57b4f5c2b61b4db9b2289d3effa2c6779dc1d59a2075f50427f70f4af09fea8a393bd9f65fef284e1dc6e49c80e819d21628feecb886cfb788f87171edb9b7510ab4a789ca64db1e57a9fae8db45bc233ca21613fe09857cd22b0d426056fd9d0830e4a78d4204b344b5456f47743c9242e43db9d5659f608986c806e8cac476fe9550eb53563f51338d1497e06ac3d3f601a58ec9c4e736620feb93b2ec5690d24e80cbf1f66de7adfd038fdf1700bee2350495612295377b9e4ddcacb1a4df0ce89e176e92abb462e9232ffa6dda3fcbbfca16d5f1287beba3cd1c8971cdc16807e5876e7d393d58f1637077af3e5e6766585b375e950e41e9dc8b8be7f847140f973088a453095b89dcfcc9090987ff4732c2aee6ba3d0bc61d1753ef4b69fbe8a467cc7ef7d755b40fbc765dcdbafed54bfcc3f923f46d70db61916a9fd97e527eca1e4b5fcaa8ce81ddfc054f0e7ab12cb96fc2174c88984cccadd9de628c43aac8b98fbec987dc267a01239242e4ac445e9079f57b26709ee9313327252f8bbb64537ad359d7bf7345415286874d64179e977a1da8a0c19d362bcf72d4c24ba4fa94922805b79712667a0ba1183aeb8a1d70a1487ff8b77fd991dc0585d1e40d65f2668989291b985998c474faf7038c033ff8c9d3e7a30ebaff69ebc68a4bff74bab9ee2473b2dbc5465627610eadc27d33d30c0bfab64eb9da506b6e054cd5f524364a4c01702b7c6a90b548839a5c9d47b8aa46e5d209902ba66927df8c40429526218ca47af046282d35cccade812d1723d5345564936466a624982f510fe12bbd04d1f3e131e5816f4d38b0cc565b4a22d2058aad9a9a542fc19629300811639388ca9f6398f418b2bb59bc600469fdbff3813a8fafa154ca1ede30c534da1a4fa2eba64ceec2d562d4d3900ff10df65c657448f876ad9c150c3283c4754a057d1f8a091fb2041cdf18efeda1680a92ce2ed5a4d57d29b1728c0e3a3c3df96ba543700cec3f4d89b47380d77043ccbcd531874345f8a383c1904d8ff352c433a2128a17c944c4b88ded2b7f2b376ed80ad7cfb9964719d971f4c2cc61c47a7bd32d4b6375bf08828690e879cb76d0e5610317076cc6367b106473ad1cd574738f0a53fefc5dcf167db43f296fad5a6a93923c45026272f05d64fc85e15b6be7a4032c630502d90efd23cc98666928c6ddcd3cd5ac9d2318894032e65546dddb28950cf1ad8f683b58939e09296c379352952107ee96e085cd82b786a9448b70ec659df209460e5a0146d13ac44f8354b1a71fc4cbe3f1e8f74e48eb94b7295fd66f75b82e1bb6989b852086c71dce3a86a250b3ea0367975873f92cee41232f1d218eee9b3087def99e206f9f935d62c94632fa763a846de7ac85db4816aa36c8ba001f534389dd4726501004eb111a5930cedac16f341fb846e49fa6521b7a8eb1b6be556cdfcfbd1e77bf8625b93d4c36e8c5b792e34efbd93bf0d3d9585ca56d2bcba8ac31478dcf142dafdddf4c495c970a306d03eb3743796dc4831fa1fd77ea04b15198fe59d9882828c7ff948ccd91c479af081bf9d586f2b9c90a45b822021c2daa14543ea0c36741d03cfbdafa4e2b611efb92a3a597effddc236dc7b14aee4e51a5b9ec1de36e001386946434cf639edbf9c1cb1f7fd563819c9044aad029c307fcfdfeb4591d72a45fa711d099d932692c1d8f00f33c063c69462efb52abf5810513591f2705a9ef65a20700f0b2dd5aef43af3ebe8df0e8874d935f41e9b22b763fe087a060b9975340616fe72c05463ea1eb6e62e00eded26ef3a7fcd522db4fa3a0a93fad1d0961183e4830a43fe560f35467ce7ea9edf4fdef10d4d95accb9671551caa6df018040509528d135b881a26eb73f06d8748f99c75a568275a9b20c8c4005b0726facd2c08613d8b67de767bc90760c16a02a855e31ac3da02fd165dfe1fbd39623559590edecafccd53371ffc917a12e6e5e0e03487fe0539f3fc1c2591e9716851e53789d9be3053e0d861127482dd30d55b38aeb1a9ba32b38177a7902f2daa03a5ea4aa681c97c4fffb50468e477649793750be6f15ad27cec795470ac3b60c5bb81671eebd10a975e05059c94df7583a1cc4620f7352bf466e4757127157fb8f976e6637494e389d63b8d3f86bbea39f55016e91fcd1f6faa103e9d7f0bc2e54c29abe2a49273c35acd8541f3f672c2ed80cb168ddfa5207f234c4712d47b39063214b3ad5ce6650ae34c6f235ff719ff7c851ad6210095466d776dfbe5e7bd1e0803c66c8a46dcbbb392424ce3e1735b239619171abf32c86821c3e06382d705761ec824a800ed01decd2e723de726641666ad302d9646282c1ea7b2877b21a41f263d9a4af96d4b9c78d8847bc1aeaf9afe6a6f7e9421666dd72d4ce1642e9b7e726a2321f1eda9caaf5c00b124130484b3357e44d8b5046678d023c371f842d7f077cc1f29edff1a4b1be0ad53234003b0ee9b8c5518dcc21125012253192a6d84c662ef37fc6c7776397f29e8ac6c4004cb8bf61c70adcef6c4cba8576f09ed576901abd83913cfba83f094a40577cb4745b7dcff3d154c5dca5489cb6e502110ef347888c52b5cd41707a83ffa2b6261ba33a1ba12bf594aa8cd879a5245428ed009dce18c74eefb60ac8c7b8088ae46d2a1974795295453c805b5f96148a927bc153a138e0855fc041de94b7e4d1cce467437f28426c797595928808974e79dd13aca7748f8b776b9c3d30ab270146a9e94b374ff1f35d624ce85330a2dd1ddfb72edccee18e1fdacba42d973e4a570f07f76f52265d9548ef60d7266b00b613143a604f548feefb15756e507e9aebf608cfc2cff8ac5fb985ed0c45ebcc546cf75b09baf367d025feabcae04f829ae3ea59b6fa99946f64452cf2a70ace61e9f208a996a4b0171dc4ea05ad4881f969a4d8fed0d3b4f62c58176ec75cb7df0e8ed05c3641379ddf84fd1ebb4f936525c7f6a56868c6a68c656a3600e136afbc76a5d79013cad6ef3f7fd89a590c0b7eb5508e1324d6b9af9d853351e24a0fbcf8f73d345d819fffd43983e344f46cc28af48951b7cb793c2c565543ce0e7a66a4e30ad7b3ecf2131ff5579fc86d03ac892332bf3168edd9e61d743e4f2147f617731edbb88cd159173926e94e2572a51ac6f4041185672a63c29a13b1b6b4d0e713aefadf90ec55cfa1afd4e12a862ae76ca0ae5c39b780865f9d3013d1c880e31f1a8ad26b650d26a17b9ec15d652686920d8b2b1ed199241e19efd91d93e68804a8641e298e3f82137c75b0a48f954786ac1c5e972686569de6b0d520c8ab8d95b0ae3de8c43c114dd2434c01b084d4cc1833077b43341ea1765a1a18923879edc1adbaa6dd2cf4e24dd6f0ff5597d40da70e83bf75f510f35e2257159927c921c2dbf661a807b2acaa8350074af9f5d9a18bcf1a81dbe01092ff8182c3432de6d537e5f581cebec6ad6c14d53c74db408e9281d04abf5edd4e31baf69bdaaaac4dd36e7649eec88b99ca568c55b4052fc677e2210c59c897dd1eab45143a1a8fc95e5557f51c2b6e7dccfde409e0c421ccf688fcfd94f082cb75bdcf4b48bfe609e43167a0f1258c72c40b8ce798f628d7ae0578a8ea45b82d41cd64874cc67528d67c7e41173a62387549c7129e98ac46895fa4f72f7278422f347e3c10e062a176977d7e84116fa568ef054344984128dee897b66e89caea022a1e8fe3c2b640259bb84b128d94ab6d745dc5722bc0f1fd0236a80b929099228258bda07dfd0516019d1fc161b667f92297f2b08804e7e988e2a7656ce871ad11e56fe3abea9bce0a586fb75178f96d652d726777bf24f00fcc140b309fa2b5827d2b1d526ac5bf9756384d0ced45c42a00a02736bb52dd5aea213edc5e10eb9fcdc198967df4a2657902985dcfb4a8cf723d635fe9f2d1c264474ba4d7aa2f627fce8d5494710a6ce5e44b282abe0dc6db11f5025183cb9796d3d1e468aa1ba6abb68643cac8ada44ac186d9672a5d21efd3bf8ae4eb6e27ef4fd6f0881245435e7e33890c6f44e3104880f7d22292e0fe014e0ca3f5391781ba6b6c5ea3f18e6e7689463a8b2826d8ea0fabeebfdfda3b62c6ae0b49543e27f0b4af7cb310ec3118a82895e95ed25aab1d9fbb4a0bafc7790d3c8ebf7fb55d92a6d8c6f7ec7097edb4ed5d6454125a95763435d363956fcbf55ac217ba73fe98196b9ba6cbeea45b9e33f68de353de9a45082bbcd638e241a2f1d3f28c64c560465172bac585e83cce67aeaadda1255dc6d19df4b94fc9257db2be9c50ae7baeb511918add4045cf134","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
