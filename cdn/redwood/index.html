<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1cdf4074c35ad68ae875a6a1dfa84b1d05d0ff0d5b5031b760edd51180d3d7ec571244a53805815e04b26a753e4bedb1f946bb24e6493356755739779d17e1f6becf64a54a0f172f26cb72f644521f89a3ccd73833377e01e7babd02c8027a66162ea33a2cf2866f789e95b590ca1ccb05539caa8fdb525a1af25533a37c0a09818a8b8cf68c83bc4094c6343eafd561eaefa437baa01e475c74d8640a1894beb07f5c9caa3a370c9abb976a2211783f7b52411c1dd075cbc73e37efa00ae88b8f01977b12bafdb7af50311547bb8376dd4d554d7cbc7fcce01239160d25a9ef5ea49981520fa60fbb3a1e2e9bf3cdde20aab222fa500e667ac155f12533adda56c493b13c4c6e6093f3cdf36385a805803c8ad5de3b894d0aa4fd7e13381e1d1f9aa197ccb021aabfa1f5ba02abf53145d62a66b2dd02b3ee7934babf395d1d81a22d6f8b84b43024e462d59d9f41d9540ab94f899a49f8f26aadd2eb0b45460e4c987227342ca67907262c8cb2d9d93e02ef9c299f00f0f1697a4d648867de0e425e80838bd6a7a7ff6de704df488acb0ad5add18e3021a7ca1dbb494fe8872a89c1f2a578795c3d13a263266b610ad8800e95328a4361ad78fec2e1276c865907be50cdfac4b60a2cf27a867f787131b86085aa9833ad81599c29dac50f1983d635b72a30ef48d2cd2d56b01c8a1f71cb59dfb68e00db72e308eb6f64d821c1512889f1c3d1e5c72b8f48cc8be66029e3a6fee22763d15928a6ad78c42bb787b70f42a73dd20e9389fdc5b767cae432fd82c583304063aae95fce2f3d291265a0fb83e54db6149aea56f7689adec7e85b24cdc011931864400b92643af1c6911f9583a34e036d6d6a8e415c5bb21a5c79fdec70224dcf384a16e19747e7a821fa4f3d2807f420b3cca06695c1b34e921f2ae69869b71cc18f681a571db1110dc6087dd4515ab6b47840e0cb72a69ad1e4cbe2c122f5488a3b3744e35f6d7aca4a3d85dda5738bdf735e3168f5225bcbc650cc48cb000d0dc82a7599ee2e9b9be93bfda62dd26398b52adc61d18748a4d5ad08af6f2243fc598dd34431531e3e7018828f8fed9d0ff66b3939d7f9d517f7a132f9b27cdf5fdac0d0f3324b15bb25ef985ebe32b239b2befd035f4f97fe19532d86fa045848ea4bad437fa64e717468807046087b1018d06d9164609c84db3fc3baf97dbef3e2ff2729600f9a32f268035f3ba3c552385cf652c76caf48a22d106c1467d451026d03449b0ec6eeafb722ef8f7373c34b64179169f739ebf75661e54a121c4e5001627cfe0efa17bacc389493f397d73211c8d4e0778ffa187e2c67af6f0996aad39cc5a0b03a9b6dce2a0054ef88b9394e8d2a43b2c372b631feac08fcb25d95c6abdd5a79679b6fe469bd7c0fd249c13649cb48fedd6562297376b01aa81f24eba27f639ed27c060520b8c5f36b0f465c0214fb95fa39d2b5a7aaf2a82caf893edacd3f2f589eab8216301b122d05640716ea3dcb2f3cdd049a3d9cce715ec4a4561ac66c368199a9caaf3d560763b30e5c97989c34504db48dcee8e653742f585d9c56b39739e99d9f89166e4126dd6bc146b99d68d7d7866eee0620d7f1bcacf6181b88f64dd25c099a52860c24e89cacd9b29f2a5ae1f6922196cc1364097ef6facf3bc476e6d3edfac65d38b2c2253b3ba3507add91e12c811bfe93e355e00b5f6b2c8dbe32da8246b403a3c3c03ad7b613c37a983feb5a77c472e951bd2fb7454fc1ea88a647a848f5bb881579f2e2409ee1b0c9d8cb427d5abe3c5f6e6d68e1f7ea5c05fbff20b124231c764e998343f4f5f7d97d5fc1284ccaef422dfab3e4785ade2d200804f8e51a37b7b16f0e44547e4d723ffc36990a08c972bc30f1d8bbaa8e663756d6851e41d8e1eec7479627be891113b2dd37ba5e1fec8c00da0ae4cc3d66aebbd2ff8ca8a622b2db64de9268ee24d569f640eb70c082d4e33209bdf5809d9128d9e4659210ae2f59379e73cb8a25eb2073d3485dfdb780d5623e665d996d04f1bada1316e09a07b91058b171be4316a6cdceacf11d6e488b24d84a4cb71f84ec32e70c82ea0af8546bc44e9c28100320e39b7d641b5c4ab12ef72336551d3f39be734e9099d8d5985efeb19d4982da2a8b9ef0e8dc57116f96d496a46974d82d698b766a52246dfc9e2b1299b53a64984a2c22ead32dbb56595bda51ec6d93e00ded0945918e3f8d1a11aac6f92592acd71fb9d2a4350e640a8c33c652237302f39ba9e052d55d6a0881804ac0f689ab9e62c3587bd0203fca2f7332b07942c03a0ef0a961f3f6dfeca4dd64d294798a3990789860cd33644762169bbb528cc222550302256c6086466c405e7e2759844cfd6d1020fbd8708db1f64db765a792ace239bf7fd8dd4343ec31debef2db3f83b26bd163bb256c93c1e421b9a09528ac2a0aeac3d5360cff1301b23a43ad1c9ae40a5a5497cfaeeade1cd2552a056ddd5a8553efce1c1caa8ecf439fdebab9e1ba725197a533b814e5e5a2d14661d67b8514e7b01d4e89ba89d1e4df93e52b7b79987c41c8abf6a775f2e94ccefbc2553cbb7fd6ee5190c70b0b7d5e6c02423a4967d7c318a66ea23d98c7d92e410ba006e32930e8262b832f2068f3719e838e1478baa4d34b47a8965c15be262075b96f8b94848629c3aa3f2f1261b75dd22ca493ec639d1cb3f835186a021c7abef1eb586a7f7a510ba8da063aab3579a8cf3de90e7b73b1791b290bd661ab10ab2ea214bf00b2bc3f4066605bc2c803286fcfb51e0db2c9236388d9823c44c3fe98feec474b66059328d21bb31c8f3d6c782dfc7b9e8cf6c996b5ad36b5abe7ac8fe5b9fed771c7c8ac1a585a5f31a87439d2bfda4e84fb2dab85395c13e17e72e96972f31210beb75e643c33f3e12183aed3b7e326735ef834d4c6fdbc57776d59b68ba39729be28a70d8118d65d16e02dfb437acef677ed93b07fb9962fd62199724bec79fadb5ac09750bde07a924be3194d8d6e3ee491b77924cc7297b752fd1b61d695a14a6bdd2aa8c03bb477cc0546dbe00ee330eada3bbca1a5195bbfb3d861d69d33131593d96d1f15730e9e05169f7f8d78f33437defd155d8dddb1b3f0c91980dabe3fc4c389ac3283ad69c5599c41b9dca6c1c278fe78c71ecf7b84735053f1f7c2c9112b3b048e4380f34a1673a692307c1235e8d7cbb199fb24266cd6115d68e40d9fbae28cbd7ce7a07315fa20d01672f74dcbc532e535abcb6d692adb810aea1834f1139d1ee58de813447a13a11b37785cb704cd6afd72517eee85e268f016beb2048b372a224a9b64205540e477d8fb6e20e699dfa20d8daee336c2345ff2b93bc3f17aac342c2289d0b33191c508a9784459855a412a816d03f12ad2afa8881c4d3171e1ebb96bddec7db70662cd0124334208b9ae286fe34142bc8f8105178e698a7e5124243bbcc7879a0033d5ba5cc52d55cc7d7a0ef1e304e4d6d937401bc7d44aa39cba24098b89f0ea8b140f2fd066138406e55ea262dfc314d5f447e1fe2be81df8d89c30115d7e14d8d085db837afc631a63e823515e40aa15fd80f24d2d7bc6ef29813923fc2978c94e197750107276e8717fcd5682a43be1a2574ae1d39e026a24e55cdec65fd3daa70681443ca4dedbdf143698e1eba5108301ea6e97ad87fa13de2bbaaacbad6ef6b9a30575dcc619410b2cc83172dac818802bed3e5d6397c5db0c56f3bbcf35b75174a5feb20a7302e705ec6d04d643248a58f277225df7e57119d977d8e0b1ddeb43e8fea2cef12f11dddfd29e1fe8c6e16691ee913cb3e8d9a5e7840ac01886f60594c73041a8277173cb7fd93a7735778a3d7db1c4e9afe2e18e835876e32fc360ecf8fafef5ee4f45bcd84383f63269698bd5f8f753bbb10f295c1fcdac4f98262898cdaa15646eb649c830580cb138a7ad655374d31195ae83e37d92530435b13c86bc0fc2c2159d5c43758aa6022d4144946820445521a9f24d9fb9dd64ffc85b4ec3641fe464e4344358ee8fdbb0e1f9d94ffb10096efca4032738cc995be6d300fab7747e8273b9b138fb001bf9dce17d2a99b62125ed107b7f202a20a746b895e894983756d26b061ef294e0520ccd85ca840eeb4babbaa95312bda80b32360ec9c8652471833150e797357756d030b45edcc2f1a3ad4c7198dfcd1cc2475840a732d09184bfe51cc06c1a564d875503e8405f33bb08c897fa26cc77ca853c72262c7af915097084834d314be046deacf604324e6c8de472cb412685b95fcb2eb9d1937ec25e480b27ff67fd839fa26b76f9d5cbd632f22c7449153d5c4850468140dcfbccc6365d76757af110fb095ecc5ec1249de89be82ad6eed97167fabc95591aec238b213aad57613d34c568e70af1f620bcb11c33cf5ce7e7493576bac7542489a926e4426e65ccc24d091d0e10aab6964e1d85afdcb1fd97da98f136bf5d7f9bf0337c76255ef7a00109e6513df9b63d6b6f9d65b4ac2878de8844fddf44ace5a9abe96b8b4229b962acc2a95f6ed7cf4b1de9555fa534d53bf6dd5953b48a10c4385870eadd6d70d6821e142b92affe038f88d19ac0a1e16826c4bc1b831e9e65ae30cd0a4bc1d4e2cd08631fd22a339f0557677b4c71d53793034b28cfc2525f471ec9745fd795172ab3989c6fa45d39b3c7e8ceefde8bf3829f5a7aae481ccd52d9cfb3e4664c190cfcfe6a979923bd9a964169962925c7b0fa6eb7784cc323f7964244b619f7ad3d022d2410716d782eb76f7b993cf191b6630e32d033e10a3ea00b07a3a359060ac2934b589795bf27cdf41aff2b02c0927db9d93b15eb61b003c4850129c71cf9071212247a2d6f237fbab453d0de27bf0dbee10bfe8589553003824245eb5b34a8ed3f510dac27bc457c144b8cfa2d9526e7999c1f768d12234432a6e4d6805778bc34e81ed512f2ec601aa0c68d7ea72db6a5124c7103ea8ca772086733e7ec6699cc0c34bed639f18f3de6770cd50a791049736dfc13854d53678f3724400e27717a01f2610aa8be4d4acc56f393b4ab1642ba5c2cbf8e5c4542d5ad35a227fd2a87cdb18ccbb448a1582e991e607c18b3aa4b6c5e2f2e64588e540dcce7b130cd409c11cd7da887929ddd21ce75d62c5f4696481012225a5d04aecde82313477a118023c26e529bc41308be445b9f263713a62530d794dfc315231cd6367b2fc63459d62c037ecfe4b4d2dcc52ae168db6dce042924d8f125b2e9e6eee183eab3ff67458bd23efe6ce860fddda76ec881a94118591a03d279ebd2d5d30408cf2dd475ee949a4ffbff20240655b0d2f40ba477749d47da969c898c017972318f2bd666a1a2b975bbcb26ca47324eafb4a792a4fd6295a4ae8e52aafc85f3efd9f5a94dfa70965d7ef1aec3c34e635772a8e8edaaad5e0a2d68a25cf2696fb38a5a38306e03b1e9369b9cb30458e741b65e112b2770dfa5b6f42cfb468fa91a3ac9d4ad6b4a83d3f0f931a09724cc5dbf83e4b798709937b4223518e11f8e1db28ba6406a4eb2529fb5a27faa37d971fd834d47e4401d70e3a7b8cfc1b70bf26b7a368e1f457493f418880e55099128e0a95dc191b06c6b35f4fadf083964022d37f93f36b3a99b9ddef31f289db5812e7bc4735b49931c988d3764285e0059966ebbaa00223077a2dc7b58f68b07d5915afcff6d82ccc431213d6bb160d916c9a466c2ba6f54b8e8e3866540b0cca081d07ce02a313466e600e5f1c777f340d648627eb58c7ac1afd1d93221c3b0f254812b65ceb4e18a1a654ea0b078416449fe76700cc1595af9b8bdf3a1df09aa9a0f64e68656eab56d682ca34d527b50b2e4856f4abf651b629396dc8ab502d90cd56ca1da76f9051f301f17f97e0be509e11a1bfd94756ddb7481fd17855ffe1a4f0e34416382dceb02d9bb4ad62dc71363f2d42a9f5ff4360f133ea5253e0ebaedf6716c43d9ea5c92803fa6f228c17fe761166573e2a95fcbb488eb2aff7df9decc95e19c2594dbfd1b53e93e82b628a882e4808e6f2a3e7a349261c17fbc5d1b42e47016f07570846b58a7d851b5dc7808bbf6d52b59e6ac124ed98f264e41a6a78022f022dd36a5262ce925b4ad989e4505a4469c58c215ebe3e5b6d6a5c96a4a2be6a2fc37f065e0c751d71c25db6a81980ebffe21ea958949ac326ec87edc4f82025fb5a87d25663d1846194ef940c0ed56c873d26433f52b4723380220f29d47807c6ca78905305332d3e98c2214ed91ac0d565996073f75a2bd219a31cd0b4443ab8a7a3ac210744d89a31868e74b2bd07bd2119e81ba2d4337ac6b9f5be40ef6c1695981553de045160bf6a8b0034488b5895c9631bbfadb502935108b6a78478e65cc39e392dc88d78e5b9a5acb765c0f49d20bb1838a157455a334a25033cf062e4fbef33320888fec4f9563c10fa5bf3c7dc9df2c918d079834759d3b2618556d3dfcd3530a5b093d28910fe6675316a1e0b41941f4f0b254b10ce8706ed400261cbf07bc2958c829201c2850bd1112a4a95170b6e047e11145de742f39d4002f404e0481fde6a45e25da3b70f9f3890428931a3fee0e37ec3095f667e2519ee63678a41d361a9d0e1dd42d74ce0fa092a689c6c78d8e824bfa8018df0f04d6f9920185db16edd9a88bbace582799038bc0a50fe4d6541a7f60ee964377b0d7baa16aa27c90b9db31a6bfa00d5d4f319364b692c717d8b00ece0e68c03113fd4049789ce2cf722144146c952784cc9a45a2d5b6673676de94808dbf3e0f7086888608e9015067620e802943b31f3bf8b610511a56d65f4ecd4762d59f60dad0f0151fb29252fde47f5b4c82b598a71065b76669544f0f07a9eb2118d377bd0c0760b0db56046d62bf30395671d44afecd20186cf98b4c0d51811585306a1a0b2c3b898bf0f3815d30b193973cd47e7c9f441e0cf79c8de4f2a02e0b7b79c778a8eb1ad14e9c694e737eeeabd24ae8ca4a64dd15d95b4a8317ad5b4ed329ab8291cbf0036650b1bbf89e7ee519cdd44bbaf3334a7874023c6d000afe4cf491ebd9f6476ded1880465143d3505b4fb157cff6eb1a7cde58d4ca27d797650813ff2644f5fcffea06f12edc5764e277a2ccad106cfeff310078817c8b6e4c248a7ccb7e5e4eb160aac6a49d9de1992833335a5c76a9ac4adb533ff4365a53a59ac4477128c36e5ab2a85ddbfec40fda8165c4625d16c8b2518d04fb061c08c89aea5cf44024ef5392e26706847e69276b088df1adc7e8d6b24e61753c861dc3b6f2e70c394d985175c941760f2175edde2e1403ca5376813ab8cef55039a0c60b831d28e1eec4c19e749a797cf119f521d328cc0886261770551e3ddaaa845da556309c706075efd08d5b25034b15512567ccf01fe4f949432c8bce3c60693ef6b7a14c6ac5cc2fa33ba0ade0c7b9dd95af8de7978c2eef014074a1305d61d12f52d21e243a52a611d30fa63e6feb1e58b1fd8cef7cc83a3e4940bcf83e1133cb3b38c03656400f659021372f64c453a8034f889d5784411850a1492f861763bf3680f704529615cfe8dc124cfd6bc861ec7658aa2d35795123b39584c5c6bac81412becbf53d012a7a62b9219cf4a340e956dd3b207a6c1590732e3012169ff3fd9617268431a61bdee3886302636445ba06cb068a819af3891403950d3949678ea252d919ff40a2dcfb6cf6f5ab31f5d5ac8f2775127910b154d58326fcb81c0b297b95fc85fc02361c3c6e2bd7b8e80fdbd71ff329b71e53de4e69dcb410e7803de232209f1622fb4566aaf5af6d8ef94a1f5c2bfb2914253f9649a0b52c7b9148e7f7d831cdde55abed7d6ab46251431d002b3f8da34db233ed2527f1e4b5517fd27b8143c6e6024a1c1ae2faa97246594384e5a14728e8905b5bdf55f0c042d79327c6880015a1cf14b373090678de5e56b9fb51cbc3212b14fd4634c974e72decfc6a33079a5aa96af79d92291159e4ffadb7aaaf51a4ad68fd07b39c0d6ab11f029c734d86b38af80fb385ae8e879687f9d26dc2722d3e99932306ba7410bae1fe819877ae7519d5a09bc412834eeb470350fa71cac22b783e74acb0af1824d650427edc7ba24cdee109b266c533e5fbfb1d287dde4acc2edcc6b5a39f94166881fa3bb9a9837189bdb32f278f43b5291416cc12b45636d3659ec0a0c1e0bb450fbd7f536a900e20b3790c69cb82af8affaed88cd8ab8dd03d3e5ab5738488f57cab9cc2fc46c96580f12e4141156ec19667957f8b0c2a598529b243ada33438915aa834fddecadcf77eb341f79f654f34b99f01d64d82f6264a584b3f0e804a6ebdc1eddb7904d5b6c46a145875e04fc227059c95b55424ed6606bde37b234a1eb67eb8774697896492cf36057f73e92301abb7df917d7b55e86bc655f0d1ca3f48591b6a9b59eda63b3c3fd091add051fce11353cf8f7e85d990675c981bf0ca1503a2b2c8513da46fcb44524611ec0bd59dfb282db44d531c435f6d8c17e5463148fc0f21801340301f8b2232d6cdd4aaa6ca4bb3afc4b522c31cb2f7e40ecf495300b51c39af589fdb95f59b5316c66f8482e921dd2e907056757c844635b5d99b964b9bdadad660d901e29145c7f85c82fdd3ccb5a75aab2028d3342140a19f0f2b0b307a45299c3e57557f4885c87423b8b33e86b988301441c9c40b9ccf061438766da47eaaa48c401be8180094584dcf2e0ac5eed3e683e3023dbd86af22d62f4017d93bb0caf20dc68ae92005c39cc3569e8d4da9b87f2e940570b1bd950770f5e6431d7f7d79ce036f9866dd23eb78c33a5cf9027ff35049e2f82eb30127e3a3ff6a8088856118b7918b00f84f84e54513ce036fbc4347e3f759d4b43faf05096b44d0f8bdd20e635b141987720f5d33e5cbdf9aea329ea4e308e628fca2f6d0391a28aacc759a1acb0f1802304f9bc7271a7baab5a3f0387318301b6530e64b17384363b8bcd5b95e9e54fb92252698689bed7e07b91bca4f3039bcc3acc8b63af299a8a2fa57de3ae528acaac916b8c12ae3512e3c04d53ba73d0cbf951fe36b61659f9ad550178086552c4f461b76ca21f7fbf6ecdc0ac417f8836a9c66243a9be57e239add3d95be9d268945f96d756f4c65541e3a85b0405054bf5485d4b2d92210f744067274d19fde38eb802503c8d2aa1b76afaa3ffa073686b45f222397f7bff6c8d867572da0879ca0c6d5a7a38994fc02e15aa89e0520392a96497c47214095d025c5b6173191e69213a9f5fb9ded371f163fbc87eb9f71cf76f6d883cf7b4040b991c008bcc481d69bc81036d12dbe9b14ac062852ca344d7b73bd3fcc6bc7020740a1d5e030420a080e2f38dc940ca5c8736e3a0e66969eaaa82f8afbb7476a02f4d355ce6859eda90a5affa26cea359141a0c5913f831fdf7acdb43d6c95db634daaee735de6a546f2618c5f6d93048c699cc3f5d71871bce09e3cfd0bbcdfda4339dbbdb096424f3e023ae84314bd81b662cddeca531182725893afe4fc87a63a2c4a72ec61195b4d10d84c4180ab1ffd817c29f2d32bfd2b5c2d72a8f26273dffcf94c2af63343449d9da60e933ea6635389db8ee023c1c8b0c6e173f59d4656f5e703657db93d0ba55dd9ab6a06b62c600371f08b2411687f243b2858694b9ee52ddc201ddc2f664f71045910c075f8fca811b1ee8ec5c1156545b9f165b7719bc566bee849129dc0025433e922f2e3b19abc492ef029309922fe3560418de22ea58c54d1ca8911c8dc66a56d2f821d8f20ba4b9e09dc93db54e5f0ae414c4384cc5b67ad78522a9065b495f941c4b83a7cf7d97848b432d636b03982843f63c4be3f25ccddf819f5a17909e3f9b218712191fade3a03665178a3184aa5cc02467261bc3e394a329a88d0ea0f347ec8576111f167cb2a7714fa78899b5697f633a5f18dbc5f8567f385ddef258153b33361dcf01ac749e6f09262a04130bd586c04270b084dcd498dd0161636227e259a13cdc54725ff2c01d730172ab1c5f4cbf278909abee553f2f13e79d4cf04eb6de18fca696b3284a78bdb275ce0e8e2408fbd1344e57a653c903cd65a6bc13abd36d5661d48e888a6e244d353b6ee5d0743735c64915890cc8eeb668e433e1142219057b0842fb98034cf5637d6f409ce7c051afe249501dd4f6c8293e14d10d4dd5ded81335ae6f5280cc39b1eba0b7628479bc9346e304ffac76e3fbced6c145b50146fc44f42fefdd52290f87b90a58e41afb1edd2cce23575705ecb55725c46af313443862892a069de60090337f3d22898e6929f6aaa4dd4fc231c92f92adf5436b026d48a4e9e1b8addf9d2aa0eaed40dc9a9dff533250051938800aa9d48c52e1311f090b4c0cc41530eb33ae6c33d0bc9a6e8dc6f5eb47ee97ec39eb422e79de983570d1dbb2bcdd3c68e6815625061dda3d8a0e18b85508db7c5e058052617f6b2ee6f4ab6278840d7ecc298e8dc061b2a252a9a5294c63b37a731210a128ae8926a4a349b6d7204d05ffc93d43b16d6d4ba9a9e8e2f356a447886daabdd13474421c02cf2cbacc2c4c43acb60964596442de0a3ef5eb3e3f2a2c1c1aa93805a2d3a470b9a325f326ae83c3d5ebd4e4ed84d2ae564d0d502677dfc463e6afd3885b74b714b386e94cc9c9fa2ccaf9d171b515c0aca2d0cda0961c48b29288028c9c4135c25d918897ede964aac9f9fd76bbd5e761ed79cddc303e69b6f6ad3a0730d41af266ebc60aaef5af4322d25110f1474b6f4ac1385af56b6e2d81122321fc270c4fa55659ffd3fea59ef160f2c9787968d1ef21301902f61424823cfc13070ed160b91b2db998ca72e468abe6e69f731efae21f712f85d914a608d5bfd56fa504e0d974437cd6fb37fe1f689d661e645a8146dcb2fe1ad61e5f84375fdf6e209b7d9a2a72167329e4c648454586a81ef8a3941e428e1712d031854423ffa55a353bb5c76800788a85fc0ed67d7f5e02a09f584d7722cb79504b2307ddaf2e43d0fc644fc9ec443d5d9cdd78f861d498650fbf855f4fa778cac7308a515f588101b3143085ba4fd5b251a7935b73c5d1f956aba71dd556eeb281750d9029b9c3337838422bf0d08793283fd0d8c84449eee8fe1350b90b29a6858ecb80c352b40f7ab063d1dfaa5cdc6314957287f23d04bdfb5794e281042599cc20edab6e93146c1eccf178ae65bd07b3be75d4c631af5ba98204605627d56623c922c0b12b4e0bc1267bd5e20fe0114e8e04a09d3288ff7fd81db68f9d17eb752c352f2f64c361d4144690420443e19f4c9604be88d3fa26212c5f3be1db9ea480606ba5d99db1e5c2616ebbd3af35273bebe80a9de78ea4305699bc8e708043f6e2564053ed7a281d33a6693203d2268fcbca6ea795d0531b436bf86df36f85c4f692243f5452274f3ed0f98408a64c418b2c3d127615dfb9f41123d9a752ad702729f2265ca407d2d7d3df53f0aacaee97477dd0d55ac104c21e655e91664551083a916f6f5dfefcee1ec5708628c627d56e0c9734175fd278da4bef5af5535c9f7596deeac980f4c47b0e690d658a9e03a36c06a77d5e108ab1d1783ce00f8b1b066056e7ab87df53bbb69641d77ebe923170998d9d730887f739fde4ed666d8e7401307f0ba32151a32599168e209ee6a15cdf7a61cfafa9094f61863e4f1bf13ac1c1fbe0948c78528e74ad139d082fe0bf1663a15c41471d6a3a419d849cd00388575632825528760705055263d013cb5b28e074502223428458df7bb605ad13d52acccd6184234e08081dbc2f4a087f7613496bae650706e563204d9d89c89f0c756cff01b3284116f7ea627f84d18c0c05fc61683246d7e018257b1a544ef48d839b09ba2b0df3c3e10b5a4910c46d7e4ebcea63cacfbc48a3c7bc2c4f60707265c177df3e98b994b41d034550fa867d0536c596cdb99fd48025a4cdc814c2a53ac9e74978e8e9f7f6640018ed95e0b0e2c73adc9164ceb19f0f0532da2e8260dcf39d1ad0bdb93f5a1e5f7eb89ec4984962c47c740fcf83a486737860366ed2695cb57c9d413fa74f8547cc654fe8359ca4361310a30127c5664b43f218a3b1249e84aa161a60258eb73898469b07fb9dd032010d131cd7538349fe8df25f48bfdab33f65f707d0a1fbe71ee48f3b808aa050498ae295d6113aed1885893916fa3889dfafb1c42dafa6aceb67ffa63aa1a5bddf98b1cb01e564fedfa4382640b9da7e1fb61985ba311d8251d297ce18c509cd87ad072d125f0d5990a76f8a11fb6c5b0872520668048a2859729b9a12ac3427344a835f09b0840a49f1435d9a56d114e20f574b8825cdd26ae55f5fad9f13894b98ad744347050185b9ef44e8576b800b9fd903b617c45d0ddd19a8864d2c6ca6bd8c9e8c5af4aaf36275f46d85b73f7f6ad33d85d4014ef696e1916f53ec546e18d9ef4dc76d48af87fc39014b6db693a3c3e74f251d61b509830b053c5bdc12df9633ae1c4db0cf062cfc12bbaeb10f9dc5c7c3941e4969157a323d7aa4d004db0ccecd53f07546359e925bb12798d68883081b3ec851dccc19440ccccfd6bc2218902fe255c8ee0d5ac7815c3b79415a3f185dd4d7c6083b6e6bf85088be8c68853859a17c87e9fe4e0e67c49580553532de2353bbd2a3cc25a9cdb7c3d9c9b49fcb8e44b330c8491fe1a5e2dfa79dd61ddd3aed7d520dceb1475fca67ed082db9279d704c55ab744fef014089d6f8fb221a2e4f575b82f72bfc3a071bb9ba5c7250144b638bfff8247ff5d5a410c86ff8383a4c7d10b9a4f08fc1b828936487a70d1354ff526703f68b6ca69068478e2edc86b0b2d3cad37eab49fb1c1960e75d0a82d73ea1d38fd74978a9835b9f3a14ff54cd93652c80fe035c4daaff7cb7a127054a749c1d91e2a2d638b9f34e3a84b3001b12938be93233fcd601330ef7eaea4a5c5dc8489fa06750c5d68fd7ee7de587b63dbf0007ade28b2f6adb8bee4c2389d80b848b2cb512fa8753feaf9fb22cbad567d10401d16d6000cc7a8b37dae9c3de9c91fbba137838acf962db10a0694bdd0a3bbfc53c23a058780f273def738505f8f2ef8ec08d89864e71c3277c84752bad8f0fea00b57b6f8003d09e9395dc35ba38338bab2c5f00f658e52ed7c05e47f26e8b92b14946c730578cb6cc274300eac7edcc804ed8286f06a384d4dbf2434b503fd1b853dcb2748afcf9d551f07d888536ec338863e57284172571119cbaff4366254304c1af62aeba174e6e9329aee7e6449f5e14fabc9e9ca9198b4cbfcecfddcd09346c73d0217c9d4a0be2ea1e32bf23ff45578b6931b5dc77b6bbe280dcce61b2ecfe0d73d333fb4859927284beb0615541930349c8b0316e27628a2af426b3e5622e1baf6e02b5899a1ec839e6a5c7e426e5b9351ed61ad61d9d1f521d4d05754fd6c40ae1ebd7a91d20ac7e7a413e0cf2e2e6f868ea20b7eccf6372cec06aeb2eb7293c1a7df4fcda674c9744a40699ac828fc8047e6db3208ffa2cf7d00041b1c5d0dd1cdf12b21b921401e6915834109b045a7d0d59d259413352474b956fc330952784f9a2985ee30f5516289de1ae64f3a7b7962d0163ab68cf6dd9908c5c9dc442a4018699b19498832cfce7477231c6826c50604cb554d7622c557928529c4ccc7602894c30ae2af305dba8cd34f4bd32fff2a097155950c34501de3f3c5ddff98a7b38d7ed0efda190ec16e504269a0a4e313fff3a7b283c89d9f4c6bfa43945cc922b44ed238939910a7e6ee4a55a290159fb3b09727a141adbb3894d1886003447ee1bd6c9b98cf946c71c25f59b4da0f62173bc305112ab128ff43486117c8bd5bf261d4f9e6d360ae2cdcf9856d2d72af3c1b62a985e9170cefa7b28e92d116d8b8e730c1cfbee8a6e1401e0d5430aaf7a393f4ddb4b9a87ad727b625d2259a91106c289903ab1969c2fc42ae6a17f18088b2c857ef41c4ccbaa83130f605302736fa9e522df61547e6b982c981bb1adbd0a35181c6bad0ba64b449e52c0d014d895a75309700d22152690881e6f9fa033f4f9663a5c84e4f76ee793996e4517eac0a2d8e195370086bb8f23782c80fcd6240098a14342a459823520e87832ba5704ead7bc711d6b3b30341909412a804c4e39af89cf13bac662bfc5e0dd4c8e96defcbfaac9f021dc8fa252ab31ab528ce36923a17e7e06533cba2608c1ccdc02eef833c671436e00e76547e4f0924b89eb5f52fb9406e620f58089d3c990a5f33fa4bca546ba66e92f46b7514f33f9ee218e456b21ccb6b037e84ddcebe3c529d0ab19e7a7453fa20fc2a5a1ce8e39f77976c80ce3847eebcf249b207204835bfb6faf544780722b970eaf8eb567dae68409c412aedbe4cee7ed92e466a9b0976dfd149579210feaf799bd9c5ce2b5e53c7a536471993ec6abee72f73163459d397bbc53cac71a268240ce1266f48a9a0f216ad37ffc3fc59144b4e4affe605b9729819585b06e3aaa2f6684805914cbef38f39efa71d1bf3bdbf3b65fdb75bcee2008fbfffaedadd7a9b9735e846828d1ee4329e55a99b13afebcad50ef6a0609bfab0c9911fbca261817ab3dd12dc86ccedf4fdb590a776906a389db332d5e3df3628560e96c68789277767bf25509982655d59f269374aa5148c06d75ba49e2329cfd5ad412efe3688a799135d238e700dd8e2505d0b44c4d261423bec4fd9979d4eba0bda63fcba505db893762cdf318bb1d4aae1ff5d0b2659323191e45bcfbb9cd38cbac24c640833049a954c5e4e60b9d38886f9dc6e7d2ce44661301aefa40b30e47d128f8d88979c2c9068406a6ceca585ba45c84cb305a3a245304b248db60177ecd6e72815b3c7771faf69c8c3ae00d1ae6e48572922a82eafba9b17740743124efe68d8d9c838be9d82baed0224651387ccf337e2172ac621aceef204b47d4e47aa9e015d8b454796cda5c8d7c9ed6a845030eac34a70e8a54bc402ca02d5eb0afb2cf87d1ec82733833400d24924782939531e0bb25c30f6135617f89c8fd1d62fc4c2ad9ee8a22e6e838250d8f1c05b19a31b8339bc44d9efbc9fbc6ce7f6dc80454986164adb5d446ae68554c8618c68f9dd7039a69b8ff8e4508edfcdefb627cd5586d2e24dc84ccc73e0a234fbf8fadd9144afba3c1fb66eb94475d3c9e40ef2c13d969079c2eda3d574b65d0df616eeb1fc879a4e4c5107513063fba33656039ffef2ea688e4fb062d82cc3dabfc7c06cfcca00b586cea29087fbe2e39082f60775aaaf7ad39094ac5da835668d5fbf78323505e9b04d5281c3ae5127e0c4d942824fb5c9768541d263ab30e1ecc4625249a64dd280556a54a0de0cbaab636ab33d834e7e49b0a98c229359f98b9c5acdc8dcf4a19a5d9a47f6495ecccade4b5a44cbff882f6c8f6c736ace8c20e3de0141cc292b027c5d542ec4c6ab51d027bcd9c824263b07d9152c95b9a69a5dd9ae73742def91b43e4db159ef87301342cd3f2541aa4617582b514d61abc575595c8236a1ace580fc82b83ac906eec1db8aba827e66e7547031824c04d68676eadf59b02ed8f2f0b24fcb492adc9cf0fd358cdffec985371ebd9b5b589c800f7b18293d5df4092bc3f49e7b146aa49a21fdefc329a509391f0af654585cd577c781dfe9b725084456b5281da4ef0cb49627cd4f54fcf64eebb2abb92fdb5c7b76eaa86e087340675e82819f7ed26fad236df6e3fd4129e386d651986f31a89a2245ea2917685b277241f1c336c396afa25950943ae42be37d2cc699169292486810a7f774fb8fe6340b0a37b073f76be5ece55b8d78a7528bb5642a02b6144316e13b0b1a286f84cc7432e2705d89ae5add6cf46f0ed1b8ba5c8029484296ae291e76dbe33d89172304d0672dbe794efababb38cd3d5c43da482cc6fd570b527d6682758246f05f41379ad14d8f65457cc3e84dd77eb3fa54aeb1740b6d8584b2533bfb61c02e60a70d571730951c84115f2bbfc350938825dec239c581b3114f78c05cc3c1dd043219c35718ea982027ebe87000ea3c29d8fe254e754f9c59b289bf48d0ae4224ee94e8d54b11ab95bbe6e127f4d21336de222d968ad997dbeff399f5b0ce9a09e583d3388b252fb88fe4ff47be31a4703704a26f6142fe2ae1f3b0e5a1200598a2ea264657f27b246a6f7ddac8dc89b374c4d9770388ef3a547c07cf2cdc177b08fb690189003ba7d10248fa7dc8226470aac58592ac4f2165ff0636207316e56d86741dcbe7db8fd18030952649925f9806ef883ff0573e0dee85aecb56ce8b2b883c15379a2ddc1d775705365e0e13b7b13365eb30f826ad02d696404e66088104e0752f07a8b45581e50550cd473959bb8ec285b39a68e8ddbd22e2337fb0323f23fed71a150e633ec9505b270f6a629811fb249bebb160ead981daf27fb6d194a12cb4e6aa6ebce104718a57eaa818084468d0f6d5b1487a0f5b741c405ab7c532aebc742a845137f7823cba6cccc38bc71ad70d209e0c3fc3e7e993ad3235c92a6dad75f051a6d3169e6b63fff579b910dc2d50eceac33a487de6c2e3196f51d0debb3e573b64b30ee00fbefef67bc7f5a2d04560888c3008fbe2526550bd343f500d00c8944cc0962ef7e139ed7fc73bae5e1d13256806b0c4d1bbdf947d32cd4f9240372b5f62c30f21251690fc5b5a7e7a3618eb96a173231b31995e1d0718f8a62fa82cafaa0d2094db325f78a5531aa22405fdc3f6693fac97dd30375cadaff627c6b85d922c0d4e197b94d8d7a48482346dc747ac3e9cdf0f5a4cc667e01f9fcc8dda1fe75da53c633f28de2424d758578c8ca12b6baf03cf6e9ddc77f4e532fa1bffcd2c233ddd6b258e7df188089c6b7837a3786b5f14c955d5b4e0d790017d771b069c52571adabdb531b9c17bcc09ff2e991d2e66b5a58f7fdde2014125b1a1db9109a80134ca3234444d845496676d1f6b8acf2e48f6c009bec34b8c1c48a35d9ae5463d6c1ae10ce8f21f18e767c0fbcf4790da41ee4e8d0d3309d6548bfdda2984b4ac53d7ad621fac60b461d8d5f5b6b4987ecc725d7b3e25e3bbaee86471d302a40705ff69b4520688ec5c5ac14c0d960347bc940a6e98c97f960dd289255735ee5dad563ed78c13420bee63a53499e5c9c84f6506b8f4196bf43473f11ad187834eeb5ad819bc1de27429d0a635e669d7a85f830ea337932490c9135b0633a83e9ddc5b978a3d0d88e60ec9fcffe4577b0c6e8b39cdfde5bd5149445edba2f48b307a1e8840d89377b45d16fc5ce623e36976c329522aac359b0b359aa493cb8d65a00978baae2f48044b94fd17410cf8741d6d62405ddee5962f6dbed219b0034b90548235f34ed1c3c5252ff7a1ae2ffc86cfd25f86009e4c6dee31b9d3ecc0997305e25d9c89c5c4c09b19e33b2f4331265cd41ea31d1a072c1d61724d764c7a9012af4b9ee3661067cc3554b0f36a117be09fe4491210b39816d0a9f991f586b0a99d1f31c5c6f106760378d149de21a72a3de681cfd34a9089e0c05190a298e39f874319f280ee202457c5c32f4acad8c2b4890d8b1f90d5c3d194e7cfbd00087cbed4e2a6af7ed41e37fe3730f2fb75acc91ac6b334ca1f5e215b02b524a0fa1805cca22362753b673a5def317299d7285421a29071dc1b07e9f8dabcc2b90ad38eaa22349cbd2095e2ed12b95588fc4e07fd91b270d346e54df97d8e74cf8d72d0545eb0323547d70a101ddb3c8afe95d43b8ec9a5fe9f2f30b2025d52065514d78c2eb25f43d66044178f13c3e9d634b1f853c8c3c47c398187a75c2bb7a5ee6464538296ba691218613904ef8a4909ec72c367de993d5823b22f82e9fc9f41ce243d819717de4b996b00c6e1bfdd28396bf3810d6e163e890a6f9db30a24ba31b397709a5544804ce0052b47fe1ef8efee72ed2468b52f72c0ef474e3d7e1a74343afdbe1905ee10c182ae13df2488840e696921a9290112a6af208a9ac40c1cce64795607a6c41b09281bd1fc833915eeb2934b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
