<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"054cc29bca17ec1fe791bef47522f1fbf0b80d51d91b3dbb5a92d4ce4bc59a346f2087e0a656d9f74563ad871fa036f009693fac6281f24732a42bbef782831043ec3f900222751b4d26e0d61f2e86185f5280dda983e4443fb4f80270a4c8d37ca115fea30ac329ee5c9c8327ecb794c9de9efc51bb2b48bfd563e3a7cc3fa5770d67e1a21559517dce4457cbc16e914a74187974d873f34bcc9179523d1aa47c025936bc0f9a535ff1e209c4f589d47e76c1bf1e9b911e6883ab6072bf54cf2b7f55161448013459eac205bdeec3677de8f995094e68108cbc5d672444c869cf61c441e6a96756d2e97d753ef2fe3c9ff468cff18d3d62423871e40c774c53774ac7597b92a05e5cd8f109dece59a4add62fda567fc1e62ce2e8864a52a82a27fd9ba34ed46ef3d7d06e70599ab426c750999e3fa72c4300c1062f7ffeedc853e92c912a6a7ee2343e011fc7a91e541798f336ffb3d83ce1b887c0e4d8b50336d1fa037aa79331748395c995732f46f0a08acee9e514719c260e1b695b52c320df59621fa49e702fc2a3cb32ff7471d5508e05c66f5e5f8b921c8ae365fe71cab4512a6011ece575aea649f8dccafaa6e4d1ee2a648af37a07d0f725c7c783ed16d5b1ad47bd93941410f9e8aa39990f949db77c00bfaae8b89e62e9da70eb11710ab4c5809f2b96662cc712d9db48dd45773f592f03e5557de44ac9a203d4cad4fad8d3f4e5ef5c00a2ec50c0eabb56ab835848b7819d793c54d73cdc33f1a43a0efae9b567cf7cb275e1bf691572f9adfa7e2b23b9c060a3c5b331b37a83bd0f1a77ae22900616a9661a4f93cee3341242db6fcd2639c6227468800ba635ef0265492aa9bff10e11ca63a956cc09a227e32c9da5808a05c697d2d5ae6f70467bf106ac21a890c00c9212328a62d63769f54bb44ac70b90dc7810ca1c05e13a1f01755d19831eb98b9ee8f3b2b093f862d3fe1758ffe3372c0c1fe74389bd15c2ad6010f2c55a68ce6ff82f38df7d7a92a4e40adbc60b8dfbb2fb0c8860547c79d83ee1fab07c3bec0bdca0f47775f8488796db669a822b657cd81c79be9b0fe5e99c1d19790138ca6bda98e14cda2246b055eee769f0cef42042cad094234537ad288974f01fdcae1c20637fd37ebdaa95b42e20e9c98e509a50d9757da96636726bfb4c30777ce79ab42d5a6d854a7d004402d32315480300c0492675c2eff4c13c083d0a8a8a315bc569249233db8c9af98890958245022f3e72f84014acc8f3010244f0e08bb61ab492a8dbf36a182f694d5c19e4c08044bcd87f4da588c524688a6095304e2be953975aafe605df88ad6ee3d59eaa53f8276516ffa48b47eff799f661c5a8e2518750cc2e7be1627da93f045a52ebd36f8d0186c192cc85574d6ed0f016dad8a91e777870eaeb4f9c84bd1f1fe31a2aebf1d2c29c937dd76b8ddb463f1cf6e20a60ad8ce6991c9e9e9e388f9178c17503c01677f6a7b2c676a3321540724af25d719cb2ede1c383a9e2cd59d7960da47fb710da1a2667c059baf14fb960eff9f4c36e3cd012f67addb9d4705c88bbdc313e00ab902d2f02641a60b21473fcd47db19b1f3d41688919b243b04db10ce5f872298dff1a76ff27ea2c63fd23cd4110a2bf8fdd223a62b07cf07cccc0147551e54452db2a254c48563b5baca1482f5891d02374cd02cd2accb394d4b025130de032a2069152a9a62049a2cab12b563fec268eaedb0f9c3e851c9f6768b6895dadef0b487ad96d6abef19d635dc200cfa7e100c3f85c75947bee7226c42946032b19d9b57924d25c03eea871282ff5e8ebbf2fe96f0c9a0f0f8322e6f3ff9196de6cac9920c85f38294daf2ac3aeb47bb6465440d02b2fe6a330db30f6568341d601f0364b0a92d7eb3d63b3890fea3b5f9310a05c20fcbd1ac81c8028ff5f3682313d781fd20527d3f19e7d3f147091d01546343c3757e4372ff24be9d377be409c4836c1ddca472466f2cffdfb0277a297aa2075584a691c047497581712a0c5bd87c6b35878efbc9fa2b0071ceb056358d041b919d5790e0c6b709f4eccf88597be20be6fdb6465e2cb2d2c64ea56f1a83a61d76c0e93d1937a59188078267bea15da7ea3c6e3c033e2f7c5ae8363fd2fc6b597be7f635896f925e422632f48b8427841980f36da7935821c45dde2e033e7f495f42ff80a0760daf97ab390f84e4247fc332ab8ab6a24c887dc4d583ab93ed80ee949a840ffba0cfad98b936233c2754df187a74c73404a4727d7ff5d2ebc537a7027c3fe753d516b4072ac3892ce98c3e06f5369c09b3ee37f685bc470101a4ec271091b788c8d17fb3e10aa829cd24d86cb96a9807c01138c72d0bc3c98de117529cde1b94e365b91a12b8fc2fb3117e35f3d0bedb6a1ecba7688fa62e9ce77df254b0cee294a0e23dda9a1ee9591317cb8e2999c8324acbf2030df6aca3775405d80d2943f2d4ad28d517d4b6af994a209eb1bc9bd205a322ba0c583e314a48a510c3c5e24f976eecfb9b9b068468be4512fb070435749e44b94ec8f80d45a1a14d3a3ef44f1194e6874f013ee860ae19f6f473e42f16e5fedb560320b24243a7b4cc67c2460eda534551f580a547e80719bcc4ba292da22d216a2bb3be3e09a26f1cf1c5761396db8a1fc903aad0d23d70779488a853867db2705ee0e1ca1ef32b9cedf4001516235185c359763fdf6f940e0965018f9f2f3f9e95f83b8821ce704e0786a5ce351a9ae5ad3510dcca5b0b6f1090bcc9d139622de0bd58508cd0ae57ecc6b7d53749640936d3398257ea445ef37f4580923c5c20328a32c671817705846975e446925b7e289d67b6c7f1444099678b82e1d9c2ed293a0c9f3a902b00b78f44f523ff7ae6a963b02f3dc6cbf0090709ef8ca8d507de3afdd40e31b2be30c3eb7db5fb6c444bb366cafe3e91c86b5b3e32ac61687ae5ad7f47a8f9c105a6442921bbc0839741748cd16f4b950e552e200b4bfc18f478f4f24afbef9de7b9fb110ef9b8c455f2013b49658d7068618f27f123f9491ea66a852de5145547a808f7d17fae4bbda0d13ad106f0757dd62d9fd0e8b9213c2ebcb0066b19ac82b34dac95d85c8a90e39d9993cefe5c7b026f708489195e0401bb8d0b48761ae3fe4ae22aa82d660e3a806d97f5db50f6682a46bcb93fe13e3d05476970e7f929f5e36e78ed860b5e3f86117dca0b2d9f44f3479471467eadec46f0b6e32228f6cb05f46dda378fc44b930b0576eae539c39e97352340d1e02274753dd25caf7c90b44b3b6bc28e1627b7df7fff658ab3608bb6d484242170dcbe982bb6f4771ccb06761a8eef59cc750544ec0814ddca2de4b06e7983f357215a7cfdd0e089f858194a67f5d3f2d95169a545b14892045cc41a94b1520048908b7d22205af87e3a21fb985230e2b337537209f84c891a76a8fbbd9aedeaa2c37a26f2663d1393bf89ecc42f2152082a2b9cd3d9eb7133526c9c91ef7ccacfb57fb0cff5ea831cafc555d2962dde8351def4fe7015882d68df3f7f3cc63302c07da6cc439bce7b8f15189019105cabd37a2248b7fcd4ee3408cab0a24f32d9a715ae3bc16c79e9983ec813b95fdb52d1a07feb17d73749e85c88aaade954d605da50ff97e56a2f241e99ffa6fc38431e5a9c1a9191fbc9354ff0e24dfb7e3d3b73f9199ffb736a7bb9f27718ff950f538b17b2ca21ec52fccee34f49b5a2ff108e9483f19b79122162e83888f25b0ddc712d28f0b0ad8cbec5aabd255bf56edfa6a8eb03acb758a9541dde4b4a765e8572db1976dfcf7a20b7633e3051cd7e3c313db6ad11f05f042f060a811e2b4e8a266c68e5ff8be01488bd6036d2e2d864d53b2f51507fcf9cf77ec87a70b3815ff4e618343ecabe0d8e1b4a02f11e93814f2fb335a1bd92f96b4c0cb8617e0612c38618c09b82e625c498ff525c600cdbf11a8d1059958507a4deaca430f0c0707d2b47a795b3ff3cd5cb0568b29b7b9030198d6528e4d1a507f115734fa2bf0b265c8a02d10fad1938aabaf9ebcdf01b32be685b23f7d771788fe60ff4abb969e28661f8923d23cbabf178770c67d12cd5b9845b01e8afd411215d6a33b3143079494cd65272b428c8a3dfa1abd6fcd24c1fddc945144215291c7e5e9362a42ae73ec0052f50cba7961f43b6c5fa25cc429e7c71fda8599cd96284a4a333d8bd7138aa5dd944a0f89420c204e98930a54be34d2af4943759a3a034ac3302bd93d6b21cff73e2e51e91ca821070d0a251b8e8f4c81f31a16fdedc00cd0ee8c91e6fe992b1b6609a2c00825f5644e4f84891c98b4a4c2642200fd9ce31d27c9afb8b9e937fbf3666c5c798c15777730b949e3af58772a7706999fb8d6ab013a09ff12f918a8ddad7f64fb2be338aabf16d395ae1d3025551565e7b86fc83c6ef334ddc94e84516567597aee5501cbce0db4a1a2c002e49c717a4e6ae910801791d9e059b4cbc3da13acba062b09ee10832e3e9b7f7adafdf229241d97d5b01932b33f656328d366ff9435b4433ec2b988da1856714028d2c4ff9e4bfeb05eb0a1cb2b51719528d61a6ff8bb4bf8c58d4cf1f2e03e01cdd07ae4fb45adaada8bbeb9ccbe29f6a1cb1e17580feb91740c8a42ef13df9b247fb87ca31da2eecd8c9c601153e74289cd3fbdab6d3270d08bd71735b51827fbab61869c8d5983178adb86b20afc7f306a9b2d186a8bbac59d4493adac2ef8475a55f9bff0001e033a717be3e262be9e54c341d430bf0b15df4faa23ce70e99d8f9461c8f3a74434c148af1bbd6ff992d37fa0ad5c112d16e3c34b129d17da2cbc9154a643ae6e04f2e464d0a83237eacdb07d28fbc474dad81cbf3aeb33968a0d51f2889162ba00036da83e667aef02c877ddc3a4788d841cf6f9c065daaabc08ea29e5b6829c6309c9247edb28ee6e88a735cc17036f693a33d7bdaf9d54577122d9a72db4ac53c130e9953d91ca3d2fefa655159f333c12fbce467543be764d99d0e08de5e847bf3b2cd12a73b02cf3460bbd796343233238f0dbeefc9e9e3f678ce4045fb271faf18c23b139edd704c89a8c9a69f12b919a040f1e7999f97f445d20f3b11469442dbf2149f5bcf790a128dcc96deffb2782fbf2c9a0702096b05288be7d91e3233f32da5659130f1ab05aff3e8ac0c5e691f7cb35e10135c9f512fad36ed37ca7c1705d96c83e5703f3057ecb1651803808fdce3f93c27c54c577b0bf0fbf66e8eb0e5b32f9ad26c1799ec0ac9be558e8023179903a44c684e564184c65ac0938b6fb6c45d05ab776b1230261a3966fc0d3f3feb28f1ffbc8474c07caf487558051503c23ffce050f1ef0c0ed1d4eed2249f51fb5eb565846ebf95efa771655840436b9b2ba1e83491edce74868cb82cce91804b2cc0bfe6031f334889ee7ea028db5fcbced6736c1ddc62e6d9afecc6542f3209353e31924c91cdbab20387eaae5572d5d7dcfa85a3347ec3ae54e89e9b397d63963150406d73fb9efd98e7f34c2caacf7dc81ccbf278b860608ee78cd78905d382781ea1793e08780631c7c85a27e042a870868cd74c1ea6cb0094ded7bc9c22bcdc94a253c049f25b3cc55112e8d7ac86fd13ef57ba1e01559edeca39432fa1d76ce0498a55959c2eb54adc7f1ab48544cf5c86b1c65483dbdb9c959663228c93fff944a0bfe71f8a4870128de2263ccca1a18478d091b26ba37c859508041c46c47b6b4a083dd00659d852ec41667828157348cae3b4ae0405aaf7559a914c6169c91f7a5eb5374e0ed64ec1cd5d66d0ffa62d71a666926ab5726c9089cb9441c5e66bf318145896936af160b262e3ab2f48491c8db05c7a0e265337c5359eab5f327652d151086887f514c956dfd3564e44e20291d91c06c7d1309eb9770ad83e167aacf4e20be7c39a7e34f906c0980d9e73b9ffdded72db855c51ce0df4ac0f253936be04725966d14d2d94f74a1cea4fe2874ef95ca5a0ddcbdaefa64285892c5c8c1d467e71ad424d9cdfbdcae9ebebc82a351269c876133d77e158975d14882b9996cb9619fdf016f9eaac635fa21ede7917f748f3efde54fe16c7f5454eb0feec510d0656da9ab71d9be2d743be9526855ca1f5ba1e329d91ff9db7f28ad694f0b8f6f0435e450722852afab9758fa087f5d206085471637a42317bcd7223e1d2b648f93ac7536961aec6a3e1234532674777fc3f98dac5dabb1d23b45792bdbb5a5ed85ed8f2e62cfbb1a9ebe93880441aeb4763e5b696f73d66a55e81a8b1a1251bb0393be1dce0be6b3e198726f754b42b2ceb989814b0acbb96f283e8e5ce3bd92f6d74df51398635dfe29e26fa270754fefa1a965cede060c359d43b0df5ee66a8a11b78544ba6345aa8286c6b8f0645e9539315df5e20a962a2b2cddac4e44b8d3e69706a1070ef7d540a5258b24c5cd989bac97693aa04e12b2f1d50545c64242bb4ffd209f3ad4676706a4a31735c271fd744914a039f42a9b96c4310d21c863f6e29536d01ba15a4fe7869e45accb99338567a78f895679a752b33e00ee7d6f4eb6cecd13c6a15252059cc07ee9c7515cb0d27f8e431ddac4dda5e855c164b9975439e6368d0bc8b4a573ef0f00e4070116b1bbe5d117722b570ad3dd56dea08b563b9c05e4ef2aac32c1e66a34e7a4638a02e06f1553e4d62de4aec391fc80ee6447d456600f25a430b78b669b46343928148be68b0c57b1d052fe4e3e3e5fc1bdc8b529da66ed793d74078b44e9d3d21d36f78a6c8e40d74afdbe798075571b99961cd886813aebe35bd2179ffd0b68090bc85d8fe8777e962afd29b6aa18c460c2904b683c3f9876c028a3aa7fcf042593b3d74c2a2668913c1fa5453351e331cd249eeb3957b3f389a43d9257ebf1450b1d8e14cc13a14ad1640cac6e9a5138e75037cb07aa877ed6d9b178f2e8a9196dd20c2528334043d2f07ea1da0def12fe3afdb2e5b611ac08e18b7ce19ecd53a95f1481878af12b3639a75a96b886ec9bb95bbd1f27fcdbcd351e21c7b362cca5df84b3d790eca14cb550fe654cfccb8fa9d897d90bb93f97208b7355a1259a84736a825d831e60677c055a31a1696f5a41b1431a5e6109d46476ecec5252579c5e1b597146ccdf6f35be34b9e3a351f8c299ac07525cddd293681c2f35d3c8b89c0340eab08af18c893b5c9d76a01cef383be21325c8ea14279cb5f6a3f9783c0a50a01d60bc56b6c11b7eb820bb070ebe4b3104dfbc35803620ed62e6d84631e94a52011e358600e8654f42f298c8df6923b8d86575e964019ea4295bdd3e1e5b89b65c231cde695a37365f81105938689846aa80320be847064834c74ea62ae2b3e1c71f3196758b1d53a9c87549a59163ae0410deb6f4a4cadc0fe16c41304f17e96f6ac8b89f124a25e224679fb166cf90db5f70448967c700795bc5fc35dd814103aea2fcff69daccd2b26cf5a040c15b54671d4c8245b508947f4ad64b117aab8c8d2a151e53b519bd81dcdff18a8f5e59db103e3c1bf015fcb7ba97daac125db16bff36bed31953f2f3b331f96de043998c584de35027c3f133294e9db843282c988dcce61fe01ba8713664c1a1018a62d91664cb874ff88d3e6c653e4d269db4a8f6ecf5eeddcd66b89be64e0c1a0d4ff93fa71fe42b01390b90a3456a8ea0b796ee165e11b35135d600cb3b4074e31ac71c90f64591758d8cc9c1b60f30f350c747a2ae5047037fff4bfce99e321ac9e01ac6be9f1e0a65822da5a7fd93c71f8dd08d597701b4e18507b290cf99dec078ed23a1e2b64a6b48c15e145ad72cabe6b75282496344bb12c9216efd378744f54d4eb36f08b87addaaab3b6a6cc548a132eb9d46570292025b189b9b0aa0a0c4ae9402896c5234da39cb262572a6ca0ed6a66331054a0a5c2f1f4eadcda5832e2d5733d82f0162152c5c5655910df6171e9deeaeb271f877f5d3faf404aa85406e2fd97b66fa58170c295fb8150229591be02e5abde2eb56ebe3277d53cf13b5b3c34408e2996d87aaf41a34b32a60fb2c1c67402016be0549a1f4b4686b8e26d78c7a372f1131d47eca56f98575027c2b46ae6f0877e86e4dfda035930efce368f11595f0dc612de70c1e031cdbe4670d513dd8652d7b37fd7fce0cfb7c22e823470d0084be1b2f110a0a3fa8f85ed219e8d1a62d88d49ac3331a37eb7f94adc668781a98886a59730d5469201c2d5cfb5e09efdf9023986363a9905d42ac7804afbdeb5bbe2bfe8f204e58a9d7f1c3ae1a83656ed1a237d9d863a531e0e1e10b6aa9e605c8a0efae35d5c9916cd1371aa1d1d6525f98d178b7c7782e7b0cb99164fa326eeb6dddb21b890f55bc11c3a1f4f1ac7f6f3d31de8df73f3fc6ea80af3cf0b73c18ecf26ed4027ac19293d3f10ebbb97a723286694611e16c106c29a95598b6dc2446fd68c7f7841851b768daa5b60e560de938a2db746a3fe0e1d0a468748663509b79584c8291ddb829e9cb58bf9db75a1dcb1521cb76bd5c63775f7d3a73971d6f0491a676fe996e40f6b99afc479b5f6820aa1cb2f8f93894d15d7b6fcecae3dacd9973d0d456c6df628d0625f00aa3a0920cb9362235620aab97806e083b705851007acfe24d4f24c69e8d0e41be8951924eb3558fb9496d92daeeb1d955952c720d419178310ac5b44aac09cb3089e48f48494d8163012381156a1f7c41118688b3f9ebf8994403e3f6f467faf1a844281f1e7a7206dd18396c0b5c378c4b905e3b17ae4b77716be334b8ffe6c4e52436062854cfcae1549020e3038ba5bb7be1fb89b4881a5baf7c540552e8ad1cb07142088ba4a8d43dd501a225cdff2b8729ff8574adf2d680d67e720213a93c0d7cc516b1fe865d34898698be527d88090b08678d0e7f4151e17723f862f913dd6f68a32e0ddc4add460f7e7d59428cc64dfeea8c79e60502652012ef5f4beb3aae2109c19d2ad12ec7ab9da1effe024f3b1d3af24a764d0f4f3f6d5220c09c99ea6b0637b593fb2de9431db0eafe0955726ecf293e3f538c6030950a58e5c88a2d6bbc878023f7c36fb080b977ec488fdc94e7f96b1a49a802183fc1bed4326a859ca03e35f83c8e3554d4e9901d8de99fa53c8e60eed3add8428fd35eec8e3cffbe0093810a71d1bfa5806681435af9955833176bab1cb43b5d4f77c2cbe87d3a7788bfc084f0b70d9864dd18705e385bc2f1949703c585d749010ec28e767b1479facacf1c7358002e9425a731751cffa6ce8f4a54fa1da494a937523087b988bb9ade9b8341f6646286e7cbe968debaccf623a4fb50daeede7a862058457c57bf41decea68bfa985317fce9afb7b2005d20c4e98fb61ba2e6705ae98997f1bb27de798ffb43d8013d540e7a06edc3170a0a2a123ccc33c300f6d47f51200da6ddc68d7cdc2b0a7a8eed8742d25fadd0453cf3835c31a69080a68de09ebb6978836a2d50e872efaa8e8b8537dd7feb675b74b05f661b9a1d55091faddc727493894afd27a2cdb360b353151f92e5a13fd7c831f45d8cdf7d71e9b1aefdf1b7a948afb39d3757fdfcc95c1a6f64af7f1770dc5d7b77bf410711b7a7825aabb60a40d91b091cc27835ee6e21d9799ce27ed7437216830edd0fde9eff0130d1aa68c4eb62289225e6d7ba16306aa06733d7cccca0d5eadca808c9af8463d67524d62e1f4db7449b1008652d8b8e301fff83e8a53e4217e24440d12f955231849d243fc402a888eac099112912143d0b7a2bae986dfca1907669bc18d00926bfeab28a179848d4ef00a9918d8f1b1876d2b0173abb3da8180909f8c09d3354fbbf60f1c7a972f5ffdb145c88ee32f461c4933eb594b92a551d8679529f37d2f442bfd0987589ee1356ab9b66be398a0610d5414f73dc6475f746b1c01db5f9e752e58fb910b4adafcf2d33c65a3a8ff131533db5216edd198d63e850e97a177681cfef367b889fc23f06783a67ac43883f5e4f2c281f9e8daccda53e964303b86d13a0bcd609728198100efe17b55d2197fa2a447db07a4b917bc4ea40bf62de2fdfc6c7a5ca154b86ad483d9476542161b518894644e5e0f0cf70c67f769584868577243ac68fd9ca916858bcbf5c19dd726d85b42e96223d334bbbb9f4ac2363e8959f96bf5cb105f2077a6b4e934c750e5fe18b06f7506dc75c42258de32797ba2f2b570dc4f73a078f58c4b5defc1a249a11043c8f33a16484e230e6c96be07a952fb2ce46b15d4d71908f0ef2f384f082aa46675f7e1e382d0658f37bdca6ab3231f494dbf204d9c66ae745eb5eac92e659b1ab363cbad5718367520625724025b058629f2c6b8f3bfd0a887e821cc336b77a176a8eebd8ec2ed9d1228b34ca1caeabb33746ec57d7151469858d96bea100f3faadf6a9b8d1260eb1034e225a1e8602beb334684a1a4eafc8f81557875061c811e660b33238a2fe00ef5f149f2da04ec3064071322076a881bae58cb2d06fac11e5c3ff9c075994232212748011d710b19cd514070dd82548043f3e11ce9cbc95ea772cccc70a8a69db3f8251bd8a3a66f1621cd7477fdd2e1024f83edac619f161768269bbbc3e700d2f462ad37a2eaeb8641bb7a99a845535d25092515d21d09d5ae011cf8f0628ff82622bc65cabcdc03270a2b58612092752334e3af56bd1dc4bcf8f9bcc4094383491ea729a01e7f5ecb9d39d8b353cad1b858b2f3ed4359f4db9402d58dc6bea5ce8618fb0a5a1d9612b775605768af47e49af93b840ac30c40863863ca71e26eeba03965464d3d7f537e081bd184375f45f2e74d62f4c8357dc4260efaf788df0908b3fae649cf0d7289f89224341fd0b820065276a540d97a2f56d60090e9a56fb49ed2ac351cce0183e96db6dcae522f61513be3512ab26794531cdffaf198e51cbc970eff64ef9df35d9f2fec17bfa93e432eea9da9a062c128308a70aa557a20f29f7fa96d9c51a1fbe92927ead899fbd2e663c096329d33febbc526060cbf2e1dcab7aeff55e3ca69e127e6e86a52b3cf0259e4a42893fcd97712d4eaccdac697bd0c855dde097e8026239329fd44d4ac72e3728487ff8c69fa5cd5229059dbecab3c5da5c40a4a5a99bba02756a3052f3b086c32f1a193c5f79e202f7dd85f4f52dd561cb6e59d56d3e0392484a4902118b911409271a70eb8d929120fc7376362c913a67dcf83ab7c7cdeba780b8e6d9444929398c48236336c4e866a4ca9bae958adeb80c032f5a44fc2f8c4571108c8a5a55b73b1ef53303505f4ad0ce985080313d78dfa54a093b143c1a2df24dc49fb39ce99ff43ba8d7eee2f559eb9d4cb1946fc77f243b33aaf68a001876acdbe592b01143eac4d6f4d8dea510d1051de482f6de1a449d77d790d32287bcda657e31f7e40d0ff378f5a90d012860a2de3d6731812865e7296f7c96871b4d873fdc5001af67ed02e3665c76b75d212fc476b2e491271b611e8085ef4c3c4ba5140be56323448afbad059f1a9c4081f8538e7735eedd9ad7d8ed384d145f389cb54d9c4e532bd4bb0dfcf6e45adbf71205145b84e401f719163138beca2f571b67b5f34e1ea72464172e2c5115a599ab42d0c757afa728585bb7dbb6eb180d031a45b57d2eb38bc5af66a12603deb3da717b8b79e2c9ccd92f1d986e641d2e2d490244b284bf4da91baadaa5fab5b97f8a165bf15f2eda441770c632717e2ad980bdab76da6149ae741eb082f8670c79056e255cc4901f123c76d2e6a0d352668724ebd1204b870316c329a9975596475653d218ed0c8b9ebda16b092e23d0439308c7d2e1340368d13499d72b44b67778b0c49898c227c0f07d27cc710bce3a4f02a848cbfe7612759b648ff9239923a0058e694b4c4d279a18f7e157888c1eb19686b4415cf32d1f940d68410bf79fd2fd9b9de3be274542aba6ecf0dac66ff7ff8de7e31a369ec1a7845b5ef4c5d2bfe766fc9cdbf6630237cdad7a76041314c63c3482c04937d4d095d8497f9c74eed45e1e753c98b694b2616bade1bb0ca4f182800b41891268d0472abab0a2abecf34be8dca693bd5f2a3eb172e6bad297c8ecbc1762ed119956fdcfd46146cb6d3c0a18404384ef198048f08873e356de51c566f69e759ea13fb05b4e482db26d5febf238a30890a0d38855f341ca5af73adcbd83cda8740ee874388c8df972dcae2f1dd0faa6469fd88881b65e777672c79977444fb01b837240b736cf20b216126cc91b7920d0ffc6a11b4cefc7677ef6ee37bcfb10e1bc7287ae66633546f097814f471fed30973d4e5e312734b6e9aea459ab52f775b1a2bbf36e82b2460a2453a91c45efbfc5e6898fb579f9a8b080bf29de0c82969cd4e98cac54dc73e5cd613d6949c3d3e77554e23092bf401a8aef39f830e1d99306a1e94d9e2e9a1b62e9bfd44cf08fd57d21bb700d84b1fe56d9c762ccb9ca42fbba61889b63f5b0da42231d91bf50d8c0b675ed268e54256d84563437ce57925127a4aa6a80e4e65c7ef19bd67845821bf59151349e84383ae1453b8886bce6519d1064ebe5ac6118f7bde7d85406631811e7c30ec980e694da14a92dccb768b447d10aa7b477b7860222774ea4a5e07ab8b7c3db1af9c18967679fe404d9d50cc61bca1b3b80a33f229148f46eecd26220c682e77e5b94a1c66ecfe2aec643d7cf15b1ec41a9b43c0c995a4eaf4214c0cc49c80d9592ae9b29060e97c3f6f03737b45fd3c73233d168fe4df459e24cd1ebfed2273a1f6ea9bfe86fbf520c282d691699c57d43a3b79f26191ac55e99016a9f04af76dd226c4cf8c3549443abb4e0650c0c369bfe1872258dc8b57e7c367f982563a052e368506cad8b8920318f44502fcc0224d1fc9496feeb0d5e079018cf7b5abadaeeb218f81b10572c6c47a6b504598a7958e0979b52718d2675390eb4a9fe7075d63d0313d3ddf742e4e5c84edd9ffbab03b4e58076529a886f120f31ae23a9597bef9a3abaea8684007ee372f8e62a099e7db49f9d4a22c554232874f3d3c302126480ef6c5f8e54cf51ea1d703543c07a04f20aa72328d517674fceb1502f16b766d9cc196060531ea5711766fb825c9067a5714ea9b77b14b83bfb4116bddfdee3f23edb5bccd0624f088c259d6f665b2d55ce86a68f5e7b1ad876cf89bceb558c1aa9dae5595d13ed43c389b63449726e9d4e2d2d36e77e7ea5632b580859bf7c2a345d49ef6d32e16987339c3008797ec162121cf3825fd900c399bc9edb08e58cec38783f486e2463a54ec868dc73c4fd883e40a816e393a91a3009065703fe666baca8f782eff88e57013464cdd04e7c145e9fed9d8b11c5ddb190ba581bcf34be7671c0189affc64c5defe7a491a6673456b10c059ea3ea4a95772ad4848afc0410c3c6812df6339cc6e2dd534a30cc5a5aa48d36d68c48ad47b0eb593fa53b2f80d593563acb3ae298238078242538c9ce676aa02eb4ee555b7dc202849edfdf2a22a45f915234f6467ee265843dd05f7ec194473a033aa175267515dbc74b4b799492925b80745165706450e10724b102c151109c76fe2524711ebb83aacaf4d64ccdc29f9af1de218cdc8112adca5d2239e36c992a84b9fa3b7e23c56b18a31b48a10062d1a29b9a28dc93b8d018f43200ee6ed15c379c8dd4bc29dd3e7efc3619a7926f5fbdfdded3ac84544d9722dbf6e98532b5694c4329b11a089899a5c22e5b07fd4e20e68d557dfd815ea6409a480a5b58a21ed6f02f5a49b0f18ef04e1db4b5d2b83d2408ffe49a98e7b3e3b236766a66375081d4e239d6f38a71084774f8b7e8a736002418d0b54f19e6a008dffc51044b7bd8ea8dc8346b3f20b951ec3ca683463abdbf1f24225cb35bedb196d26b9699cdcc2f5c4c4181b93d3e743b9df76de2aa34e05ef98c3a94d9a5887c442a678ca201233e42103397757937dccd015d78300c062162b45821d99966e7f6a38a6f38bbd162c33a2c7240d32556819671add5ad6c0d48fdd5d5bde585741e39fea0119fb7c81d32f866f2048a4e9a93481098c3cfac4a2af969987c978f66610e92ab5159385b446d8038f166865df2fe5466e31c0a6dd8c62f47091a707923aa861bf806d0d7e22b1a76aa025d78da3d46cc31ee35996ba5f3305d41efa50c21232f1d15ce946557490b356bae699fcc6c3c002fb5b9d6fdd4dcc88b5e251d4f778343117ff1e0daee845778ac24333c15aa64974d0b70f0a3fe6d3853f875d3686e0f3d1c70ef931fd594082b2e4e52bd9e8544eb481100d4a60e19301f6edf0e55639cf1368dbf54f7ba662377593482ae1856dbcf5742358b2913f30d8e9837e38fe24dca116b26e08f812b55768b1468694a7cc74fcf699e2bfb21bb5f9de6821ab05adfe63e9ee229f6923ce337ba7ec4b50f185fbfd21a9131c4cb8e35fc9aa37320c528a6416ae14a8bb2e59547d4da255d660ced9e61cdb162459e908dfa911bcbd070df7adc7f3bf00917db6ec5eb55746f327df3264fd8f474dbe15eb53f3dde7b71bf27b9d0b65eefcca952dedb627bbceb86e63819d8b077b584c7cd6b077d450dc558a7d6422f5765c54d67cdc77a12078f16f6f1b023363c7b834e8f448778d9625fb0791e305a7c4316441808600cf2b2fcd51d3d1564e5613e04a4689c3a639866b7b916820d04c65b342cd9e57320d77bf5f8135c75cf103529ab485a26bb78860f70af551c62268dc487b32368bc162f03fe4a1dbafbcf020c00eb565b41be008623a277fe783ff81421688895e09f22fedfcbb4946228b92d7c8c7b968490c0f730faa17b6878512ae0709ed31f95a0e045adb4ccc8b032fefbe219856a044f03b68ceb5fcd78ef0a839e98e245abaf7d562776ef79ed94e8160b62416c719554294d957e920e59a96840046983dd116633ede0ba31e111acc6742d950aecbf3c14874e8c8cfa534df4a97d916b1e565184d0d8e73b09314c0b9987055cba38f78d05443046fe519465163318137393a3fd5aef53a512d403cd3b18d034db133af25a485d755c8c11c9db9be4571286a05c81e2b65142d7d18e55ffeae56d73443a7f65586dc06ab44cea9e3d59231e09d0d866eb5faf21a616deb90132c94d035cc7214ce88565711e32f92ab3346ef78de39e90123f63b8499540a89a85f9b55895a3695b4841f8132ea5a77ba4ada8170a6bbfa7d2f48d02fc6f040b22b22ae6952c1c9bf04038a31cd015c19b22238f5d03451b48bc4c1c6ec5e44fb40233260024025fd932a89014df52757244e353b693a94513d08cb55445d77730d1bf0c2fef5669dae0cea9c12e575dcd8309b7ba222d6624ac2c61058c450c3310629066cf20d0bacac80b82251ecd62c139960c80ca6bab2600597ec3b5ffc6b6537b96ee7f0ebcb4fd021f97ac841b6329cdb57d304ca3d6b9ffa5293af4a36a1ce991f4baa60a2fbc8aa5bd961cd7d20c43cfe2a41dff5936378224b402a702ed5d5f75895b34b97e13030db8b98876386fee2953a53c18601a8c153c509ba5f6a1d91afa63d0b56185b010b7ee7121a3b6d043856d9114b1f54ee5c5950105db43e7c87a3124af44fd7b4a3bafd2fc5a41e028320d95f89a3f996e0a32b0671b64ff76d560b5235ff6519e4f329c78acdf4c0a2ba964f39d686bd6b75b851d2632a5fa339afcb9d91e0a1a9b69063ad9667c2e3a582f22bc4181d0670438e9c0d6402834b6470b7cbecb10df79a824a57c5678cb6154a1dca4c9570b924473fff20edbcfbfd571b23ef4317125f4402ee1acd5e1ea1212197cf42cbfd3dd7b4ec969b40085ddd45620848bbc8b28c52b6fc4dd3114be2151fb0cd0cfda9995e082ece7196e65d02673338aa88c66c85defb0da9deb71ea4e658ad2dc301694acc8edc5026ee4b5eda3237540edf7dc27be891df1de25ee2b1c47869300a0a5ec83b81a83c84ce9df8ec62dd99ac3b1793777db87b80094655dd506ec9febc4af31f6d84ad25e8dbd5fbd5f7414cdd216992546676138b778d8dccc70e59fed8e56d9b910932874e68040007e42e9a2d71f31116b22e5e4d1a5f6b229cc4e62780394a52c8f68cfc430e9e3c672d8986c25ce2f9351af0818dd05244a71f45ac041808ba2fcb22861658b7213f7c242fbefe528af5be9cbf8f0161295b6b5a7b93a16f660a88f26799a46a3c3de91235b707f04c87a214fc6b0de1f09ca93c6369840687650bc13961377ff0cd1ac8c708b3d9c2006747b7bd1d9fe2c94ef939178fc0925d81551c6a1e620c41f971d9760e7d7ef483283b5e289c3231a738900b5bd02942a2e1632fafab99b9549ff829a760faa35874a961f39454a08091fa310b2eb5361be3e565bc10f9163f9a09ff4ae4fdf4b8f57fd899700c4fe217868d252d1c07b65c1c78f9bb3d2c451b167f1a0b1df137da8b18a273e5c5a9cd68054b5f0ffa8f0dde5d7cf8fd6e99b9451e64ed5659730f48d73e0792994617dbbb08dc856b4886d4751fef26f034c45e986d59103fa213e16be122fa844dabd2293e327582ec7278bb33535985f68b72302a012e1dbaa5142d75051f548a808d85729e2207662bc58430e18ec04991320e9725e5c5079347643daae67954d09895b1b4b50e7070e7e8ec055d1b341c3ab74e96a43326f9dfb030616c5fce338288b2ddd514518bf46ec8ee0a88356cc75fafb4bcfa08f52bdf6f1adbe0c59da603785d3c1f1b7686eed96a0a5429c01a8a4930a841268094491b26aae8b3e8c1c5acb48789e451660dce92c8e508267ae6e37214bed1e914bcbf0680fc4e05027932a305a79affc06f50b064a82033e24f4c201d15dfcd7f7c28beab0614dc79710dfa708b2fc8a799ed76b939bc7c115854664ae8beea396cd9409cef38520adad837b49f5ec48e52183d468aa21b1cdd1aabbf101de72f9f4e0b4b9d4660bffba1264df639956fb3eaf40b4c52f9df0a013f55f35748523ede868893d36974ed1412719d314c28b57e4044ed9b5e10aadc1cb3c84851b04e65cb3b62f013777ceb2ed98bd757011bb659cd501255694c716add8f2ff63089f01909e3205ef64e7c3cf852e49ba89f3c9f4e756bd53404432b279cda0770333c1297554c9b97ec0b13830405b80f538cf6b4c159022986f43d066b56a91149758dfdec9cfca765be39b47b5671fc208fa736073c0bfe8b989b02103ae4eae5544e2cb754fcae70d36717c19d0094cc1e284c235819cefb21153a9baff2f8e167449bc96365d53b4eb5e97b5910d38f3c592cb8cceb9b3402622be2e1ee3a295ca4d0135cf2b0b61778474bc682fd880ba145356e88f617b912016f0f316e2d9d6283c43a1b3257924ed0a26196c6cfe41b61f582d091ec25514640fbce0496a9feedccf43f1ad381a94a012319d68e01f4ecbc3ea9acbd1c2044e1f5704f9c4136b980def19741251c2749fec80993318b3614d8584ad235ccd434ecf43368644553c9a566a6923ee7900f45bb67245e68f2bea9cf89573db1f57ad40080392f7ba1562957da68895116dcd327e1d5f4b3e6a5eb664ab95a25c03e0c072ca38715c62f0f33e5a8934e3e43231c861dbb0c678904c90252f225f2e028f99c5d386cc9661830f4dca910284bb2703c5f3bedcd5cb790822183e90270b8615e872fd0e8f8d75389ae364fd8be5679a2a52033cd335a2c4b77a9a31661d79690cbc80a7b3426eae41c233c330e80e566204470a65b37b4d8290b134570888e32f34448c600fe396763d180357f25535abb6403ab0d8f2a99fa54b4d40a34496ef366582dfbf12fe49753fb56c7d5d14c39ef48db152b0a66ca0018c7ad034602c78e5387ccb7cd1bc5e1b79c38e7975763af622e3bf57dab929337e2318adc2ff2fa0fc113ca1d130be1abe622500942dba979a109d9baeccce60bbcd64c2d6ed999111c7423abd161c2121b815fcf540d12072659e448f4afa04d0df84fa199e2b62c39786bdee76dc619cb918186d875b042e0c11d89306280e351042c83d514bd14d460138c263640697de0107eac8ab4a9a854f54d6a7f5ea5d276a77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
