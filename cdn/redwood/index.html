<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49642521f6fec18e8a15d9c800ddbda9fd3f41c251c1e37f84a2c74ab4fe6ed6e8e1480698f1fcb093d8ab1429d2157ba4986d4218bce38ede6f22e936de2eecb2ef5e4b4c500c63035ad89cc445bfcbcff603ea0457073bdc1d2c1b70a9433bac326d51b30ea2654f6fd7b95ec79bf664621f7faf8a3cde0f8942899d3f36475106f35915ed1a7214396d9319382fcb4df8d0d052914ec8b4e935c401feb3f7e7396767cc04314c732e5f847f66ec61d4eb9dc642092998653a5a9ea55b4fde87fe9c1a0e2ab077edd1d8191167b6294f2e6a8b1f39fd104e40aca394f08224a3793a54ed0c3e24701345580b60b4d254137694447e12321f5e90e88be03d97cf1a5adbf993755e5e0ca40d458d2ecf9c3a5209504979b0ebf470ad240a7516e72151122a8767f0f1e1dcb0dfb142ccb6e997c6c96f3721ed2ef7b520cdb12f8d005e9fd5b36549962834d7699b3339f52d01ad9cdbbe35235fb97d64c88790e708e4de9670cff5e07689479b5e511cc2a530cf87c5c80a35262257f39e4951aa3c8cea9dad41a79fd98874708fcc72fdd0b90f9d4e724d71bc506f09454ae8f84a6904df2e9f9f8e36eb7bfe5dbd133b4e618521bf319aa6c9385c3f501bdb9abcf46edba14e0d5d4bc2c29b63d3c5fb76f6f069cc418bd24205d8f58a37cb2caad41a2d7de2b5be4ab29648ae2445e2154640e8a299d7b65cd94b92336b7db470bc3fff3108e251ec895b68d15dfe988a728166c9d881f5796536451dabbf8e6c1b6e548d8788d687788c52cda58eea2a347bfe45fee521c221bce5e444f4cb663db91af86c24d93350f1e9d890034ff7453322f6555cf6ce2419a55e177a5c4589ca159f7b8dd4c93a75643603c93e5a4a75cd75a342e2d71afd48817ee406ce7c07580fcdf2b337e862e42d420192f27610077369636b6c5db32757563eaa677e09af321d3cf7a4dee28bddbc12c155f541dd13ad95b4a184a9323f3f674a5e3d8b9fd92917d61006a7b991ec0b67049048ca21846b376aca250456d1cbe272e7c58a9c7284bebd1dde9a6560e505351df01e8775f607fe8aa1467c17cc98a85ae2038cbe4f11aaae2555bb3701654f394a71173c2e30cdffef8c1b6519e64bbc231ca0ac13aa6537d3e4d2197d24f214d28a68285cb2255de06100654eeaf436dda3903c6584f1197f8588fb512694155b57a555a2b5a1b764a6d7ce9553d7a61fbbfccfdfc7a5f1ebaf02b6b91aafa575ccc901ebd91105e3aa2be077b608a3003ca2510bb9519f5371ec310d440661f4090550be485a232539ba58c6832ea35d6239aac16fe9914d4e37cb84c356e0cbefce8126094303ce47efaeb43928a0ad4ce2fb802221c62fddcab1f27a0a307dad17fe6113ef416fa1d4c54cca6a087af90c1f506e3cff4fbd8996f112ac6688a860f74f126782eb0be4f6e4a03c3a8b890384482a216a1ca6786985a979b6f8bde85376221c4aa8fc9e3e555ebe7fefed970cf0dd4afac5a141d61a7e2d089991fe20e40cba697cc5e8b63fbb5944dad04038bcb22337913bd6534e1b5e6494e7c51404e6438e6bcdacb3b0377b384602272b37bbab9410303794f7e28ffef86e460e76918983d641e64f3bd38b91f690d9961fd84f2d63aaf4a12099a9bd1f43054646afbc9d738f4ca030ffff882ab6ef655898758c086836595d1139171248b633a23c0487b359dc772c41f3e3d9165ca1c7b9b92970f85fe356be96ab3aa9afd9f0586769023616e8a684eaced6ad9f13ec5f9db38667bdd3f10e6a1757f33a0f679c4d4eeec797717e2c02b16a46e51d86db2346e9d8d22f3e336cc37006214836a937a8b544756503af514c82f1a2461d2fe18e2fde15fcf1b10cfec917cbff3dc8b13d5ce0d4c63ad2dd8f0149a965f3ad7bcb1bd5c3653499f399fad0e1b5a034ac734662731b724064341b0fae406c17a74218685465ee0a0781342b09338cd4f72c077326997cda3b27567ccf8baa86e3e853ad8f902f28585acb667b0452baf5f2ea7ad564bd0333192b3fbf4827e0ff50d892d8159684a8613bfe1383c17540f1c6f5159d7aa59d11cd9a592c838de0a4415253a2578989dab26a8ee6560601c0ff494f7d1954accf5896f4521a603f4be2b90673e5ec3c60a6b091c16fc536f4a2fcad0af27725029ea0e86d918537cf716e6f1a445b6c43a1972ba6e11962ea51f79c335914fa872310e8acd51c716e007aa8b9e8a985890b83bc05a9dfe3e25f9109ae135ebc74a2eba7b9a13199d3f435b6c59f86173d986ec75a16de23943597f607f7b6d848a708ab5fc4b51a5b21477c77dab72af64f7f70aeec29c4f6ba752fb8163e7b4ceea666774f378f366dfe659fa944ccd79fdffeee694a1137b0b15de3b722d4dbe90456c58880c891b8aec358a9071c583d601923ffebab14d0e3ddfe9f0f92de0eed3f494faa4b302aa35d76c9c1786df1b12b4e63821efef477b1a53c53a0a3a05517c644522d26c491b3373074a6d2212d66648889bda4038cb7b60ca6baa602215600ef08ad179a9e0f5a1781dfa855c298cef9d64038f55632743323ff380003e4b6434eb57f7d5680908ae92032471669886a8b4d1405e338fd65d8594e69421f88cfdcf5ab58edea40d08426bbf1245eb31cf7e5690918584d1831b3286693663a624c085f72728c8e0fa3fbb915634ee581d82ef27fa5012136602baf2d7759f87d92961a35e523b86bff76841c182d09a2e0c31357c26775d61c08b9d9baa9ba8291fd77f134beea23b3a89cc14202d114187d7940a8e8a0a3d296eba1bf8e3844cdba8e26ecb8672953d84484b8f6c9170ecc1fc59594a2488433eb6beca07806d8d868268c6c9520557d4593844f66bca341467ffae6e41a90930d8a633f0714ea60d14571c9b3d8be33e1486ad1bbdd2db2785e09de53951e13f9afe7ff3dbc8a9cdab6386377667204bf4fc7605c00cdde6764cc56ba454a74774ea3a5f49cf2ef613481ee9bef8fb4f271b8e9a1ddb9a7b64f438c77ec6b9922f618cc2606d90c1d4b3b28f49eb5252c9c14bbf6448483f5a45311cfa628107d860045fa669e35ad6cc5468e9d3cf962a218792fe62f4094bfd98592622034292a3abdf653a9ca0b86763332cca75efce09cc5b1b1f0b77582454d96f7be12d1fe7a7a7dd971bda3d30e6e106290545cff0c1cf19df50353b6dc72d70643c4bc92eecad68e20696b3b134a0d9917d2a2be9c306cc1e2d62248dfb470b1dbe55cf17f9f82bbde801a2b8e9ea794f45b1d644c9bf1954a333c5add978553540b2222fdcce74efd4a4a76c4f668759340dd9ccff511efd6beddc843cb41e0579476ee72fb5aad4649718af1c49066da32afbc788bbb8d141c942eecb9e90fbe29ffec78f06894749e77bfa98bf55a3e65c27e843652157f54285c30c291effb916bbb7f67eff0708ae8805294b072824381ee5759cef6c22b5207d52a04fc32b348195e17c3eb97c9127d6a7bdb2ddf22eade8007a71b5701d3959954c05f0cf4ee3abbcd62ab41c9dc020dd978fee7923b2f063db84509e1ca93e472919cd1c031985b7be79289828df293702e39907e442f8aef22166f332bb22bff8aa3eb41e6f95d9c3c0df02eb5008f36cf4fe1c1c28dbec5d17ffdf829b3ba569c5edd02e7ee3aefdc0d2dd43c16c970d8252ad63e97e8924ec4406af219a5dcf2ecd2f81d479060c8352edde3d6f4a784f5887719c08bbc1390f10829829608ed0c06b4810f3e02ab3e17a1d03fe45c2b4b6cf3be4ec219a41393df7b650ebf859c30554a2607f65e07e1b3a48aad277658733bf417a7906704992b12c6ec29e04414ee4acf5511127a3e991020bcd20c9003122ee7f1096c758aab3a7878f50bedccdca0053983e0e72473dab6dbe5eafd6a6f32aab769a2b6ea6b226ff515b3556d64fe5e3e759e127ea36c2852d611688ea2502848c0e9ac32dd2585e012cc989025eb7b540060d546b785d904e2cb5021444c58d3254342d467841baa590bb6fa0a7172bf9fc1d7dd4e8e794dea2fabfb15abe6864b6d3c074050c502aef18eef2751200a8c6ca5674890dc0e01d29519e66042835707a7cdacaba4c5820f924c8ddc071aeaf11f508a3a278217a6e6cbde5dbcbe3aee536053adc71a2456d8c3e3e2a60724ba823a623cb5f5d3f8db1ae1067116576a960eca5d844583e010c6922681dcf95d84834fe9f47e6e3f140c929bee6d1c1ddd88e0e8682ac1f162710290c3776e9005b3050f2af562e3c52f7560cea2031a5e282f1faa862301ba73faedf2086a1b46210b3fd14a5d4d15de245790e331f95afaf5a5067ed7314311abe7b4e7dbdb09042dd3deb39e76c28242c2de2a96fe50581637a25acf9495bf5b9b3bc6565486cb37523e211a0ca8385a4ab254482df86645c334d20e1fb7a15bd67a8159587fd6a7aa9bd2195b644e0a687ce05448c41c2c660c8ab7549137ddc356044adef4da8bb5931cd504cc1511cfd1d4adb8a8abc1eead858048cbfa502e4b89e116107a454b1b6d2f4cdfda814c11918056fcf5c98b9b62e2306efe314455c4ab35f38c9e3f0c46b1926fc6edab67326529b2d351c060e1b32ff493082eaec4dc3808e302af5a4e6cb32d33fcde2c212ba1e633b775c253029f6f61dce0f221071850e800bc3782affffd978a321f45f621bac43fb94c94abecb9673549b7d077112241721cfbf8fee5d22ce42f56357b04aef4858cd5ffdac8125672c3dd7120107b077722f7c377424ad95b9ef28eda32c34c06077f6012f075d719b27240cd6f4dd58e843faa456d29e7ad00b97ffdb90b0cc84d4a39b9d17c3864dc7a6e2f42847dd4014d2ee5ed2ec75e639dc9a89804459599b078a13d2ffb14bbac27c3f0c8227d9eb54a7da776f3c2c35cd5f6c0a7e5d8c74f4877a93f2e062ffc0442b5c4cd00b736d8eefb9aa9910068342ec536b4d67546c1ee7ee18ac977a1d7603fac00acb468e56125efbc6e11cc92eff6a3755f77c78efd1375e0a0d7309e1d6d62426142c45ca6a503b54692e7bf83f43f39b546f970e4b99450b68b592aa6484871e5940caf245895eb16a1eb40156630f98be8c3eeea8a8371c676f6181b206128510193af5353031608b8892bdbe9153c1cfe0306f4082db144ea9fda56058fbf7c02b0401d158ca25366c6f28603e684455def99b29c954b30841c8e42bbd29c277fe9bcd1004be85db37ba9d8752e91790767fdfef89abde1d4d5017984a0d063b3cd2f630d279cca5119e4472dac61ef6b4cb9868b1d68667a54d7be62101a1181796922681ba421bb528b0dfa23379d4bd1a2c09be72394b2aaa44f89b22b68fed04b8a09abdf2b6ffd67bdbeafebab75efd5d66a8c0cced0e8265879aba0d7eb234ac826dd35ff162e12a4a73fd6df0799c67df23f9edc91e1e1cbef477941d2cf2eb9e359407ee22664694318e19f8989377a9b3c6d1e1c5e583f2c9c289d18bd0eaa479dafd05633fad0e1c8d7f584e1828fe9c41d7fa60b8c12b86303cdd406a878f28acfd08027d1bd57f421c88c2618deb99e70f1ae45f268954c89911d7edb954b56d68708bee5570824ecb670e6d300d488f33dbba3eec4784bd732768693d0cd993685d0c21f73b1dbca7ec852eb6eebcdfbf186100a6680609614667fa527b1f4f7b0333809f8975e6af38f9cc249a7f24efc6774f7aeb7e3b023837a302f8a29590c87990dc0a165806c9b8104b835f1816ba46322e8811bf8212bfc5257cdfdc227c6df46c7270e77913e6b2067695c48dc14a7f98ef2c51f83677d188b6fe68df3249d2b8b9e83f925da692c059bb76c8052930afeea6909296e662bfa2328d917d8b788b7b5ffde0ea357d6c31d2387bbfcb8675268ec5779d1459d1224396578124d914546f5df6ed8d0b952ca22da8a689d36f62ed66f8e4385e1d981e2491f0ad387412120fc1d2513894eca2d3c540e2d988c54c6f7d1de8fc31288130ccb06de372c1c310697bde0728f81eaa9edf052711705cb5f20be54c62172e85b6a1b2a767a3e8c281884f6a22340feb9cf5feae675b691cb6b850fe51bf4df46e2df4d4438d02309c6eb4f7c60225de927dbd46e0867f339991060ae1c10d9f67af8c9f81508caf7651f856a2045ca1e5e7dce7d22ed2670c1a52f18adb424538ca4045811ff433b478c5d9a00ae33064785bc98109cd916505a9ad9f7ce6c8e91a8e318c784f21dd0c580a601d4456a8d912666b1f6d4ec7f51d3f0b3de41876b02cc542e9a1ea655cb54ac808800efa8135f142e4c03129f1fad2c15a9ce4ebfd2518ecbd563f7e28139d61f93a40c84902faabfa2ee699b872ad386358dfb5ddcfce6c4046529273e3fc8f4ef608ce7c113cbe3d50dfe8d2b9abe81df121c6191f93678d384c421e1199fb31a9071cfaf70b4789581552415f6c8cf4317048c3a5cc5984cfa85a9fde5504e4ceed1fcdb49b532506cc3858093ee99a112280665225a0f58ad007a6f60c77aa5bc6e79b94e3e154ff1b1ddb708e0b58cf00318d2f204706c09575728772950fe749dec5ab66e617c9377d9048c1ebab2c39b3c31752813ee2de9649bbec142ae7829794285f1ec829842c5565209d2cfeb51253946ff2bff33c296d14992c7dfcb99859eef35845091950d8fc527d66a38438cf03336ed799c31e6defa3636428a4707e4be8777d4e69a97cd6d7ef31bff72f873cdb9019cc809ef750401dbaa5eb0441da25666d8a3b518d22e67f4f2c990503651d24d1d1f3e4c67d1afbe5096d7b2f3cb02d29bec5fd55d7ecd998eb8b666734fe6857e43908cbef5c64a0d87ae1386dbc28afa327dbf7bf3b5b3af6b774d9fea4a91b60bb8acf6ade7ef7b6701b0dff842f0691c1e1d095fa6fa79e242f5c767bf6cb696065fffe35338e816832734fef77808280733f879e7c5f754c47e04feaa84fc0d805317aaa5f22c34ac7caed919c6329b9dd8030513e7e4d1b47b640638dabdc223eb6eeffb75ca33db296d577bd3115259c46dedc41bdd2d37181a5f22db679385ee2e75e8e5e76d031d6daf230b096189fe78e5e34129b4bc1c5117b1f28028dc6e27937594be49f454bf56549f2df7a1610d07fc121547753d8839a1bdb12b35e7f6122ab6e83c9581ab8696515717c3476d98967102b3fbdbe509045e37850bec4eae6b2eb18746ac5f94dbe031e0e7495ec1998a2e019e1a1b6549ee9d4b8e64184d3276f7d4e2e13f048439b097980c4c7d5a443d3d8291da06db317834c2b57062ec68d91262b270d594fbcc005a5c54d572231fce4cdd54ed05e8058141a36aa25b121939ae7d0b485d0fb1c88f8d9920aa643cdc93e46c5da76f5a959a052b9471e7363a401603149475711199310fc6d999ec35d250b6cb818a66a219471189873e777f7d214f1b05cecc13d420054b7d8e8d79091c6b8ca363cec9cf32964384ed01b0d5f3e8499581de557e80da09f500c749358000b8d3e68d4de1fbcd82f1563468159e75f8b73fc6240da9d741137260fbf2c6896e699ab2e472a2c91e7afbaec6c2f79b717d568680901cb8544dff83f35aca7832485f1ecfdd0bc7126de552a296595b23f5d51a92527396234f947680824a7dce7b7e2e53a8cdaf0e047f8a54db4ec01c1550943836ee28e3e179ad3ce5774074bbcc7a8c7a183ae261137c58a2da2bf569b03084a0eb2d84777208dbc0f209b6f3aa6a8829e10d5128cde771fac01b7cee7defd3d1cac19aa61e14b8b2256b06f7696460579ff9b33c5bbeea8099402549027a0e16b39d0c1e3a234702058dba6859bb0573d52617f0a03b9f1e992ede22a973fa8d19545ae35427706688881bd5f3012cead4bb0172910c1841f76b7490675bedcc6ac143487ce175cce8e5683e13d799fe35a0c5c1c13c818b9baf1142d6fea5da0bb9ec47757cdfc192abb08a7d000b883531a51870125347db51b812070fcfec793582dd5dec7b49f8640fcb7d32f1ddf4b13561eb1dd0cee65c4699dec46cffab8c840bf5bb298a18c0344aa1c1499e95759221f82df04bbf65dc8c017950f470e602aa88edb8014caff44c743ea69e1ca00a1e084f2635f79d7861f2e998adea9420ca30583b23a988180fae218a47856b391b638771ea5e4971bc26ef8a6eef7d4da494954c8868f1f965654ee4bcea524ab36567c94b1d3afd2454c796db3d7b84da4b2d78d0fc9830f0dff03cd23f2b0aee56f3188d0c6c26195140c94464a758b200855b19ed26a636818fbba1875143ee442a3945e30cd6e0ed5a71ae83a664928989a29b64b0a50732b6d32888ef18bd87ee3f9d3b45644511ac6ad3e2f31bfe1b52da207bd39bc339e0c670c9d270880313385eb29ab176336a8a863ea863741d6c36821d85d930c6b3831d4c52347e1507d0f1432d4544758a1d23d6cf053986ff5041d752bbad41b783819da80ebdd3091ad999c71a953d5658e89e28566802c9319f6c709195c55c7caff7bdc630f6a0cbc80f323b51c545900659db47ada465ada5e2250a6e2d3410a8ed978e2beb6c8c396424d25afe21d9f14a2f15a14d41acc352a15d3775bc36d3a53fb99d43d6a7112661b6967aea3baa4c15009aaa28c7066b48edcb3a47487e641e0bdbed9a28ab6a739751be730f1f5d3e46dd6237c883249a3c4d5392363d11ae942193d96c043d5c50bf6ab1e3d4d83b15d95f7b3cb76316ee511210cab5c5ae43e55c5522c0ee32d0c2398d7f195cf23073603352078f3579c1fccf13eab00681ce0abe06ec7df07ffcfd152275751f47e2ec85d27b56d7226f1bb3be94949fd890bbcd312b2f1ac3007556d9b3bb1b2decdd1cf7e1b8253a507bd2bab978165054aa053b37001cfe696110a5b53b1afb21f827134c96919cbc69e3923ae44503d6d84aaf03303915cb3526e83f599b6f1ad8ef45dde32c0ee16a97003cf3145b24bdbf7e327fe210099ede7cdd188b5aafefeae2ffe6fbb831f81c6bac94fdea3a6a3cc56e0ecab0ebe4cc1f0ea84c080ac95686d56338861280def670240f114bcaf4d82ce01555d0842d9cd8417588ac438d54d862ad16aa764d449230e65b1bee7cadadec5af9175d5bbcec0b8be7336758582b5494a6db94515ba93d8945cb7ea86b238ff14240d6a4baf95cf30b187fc9e74079ccf6fa4ca5df26cfcf6fb667f9121cb8967c70ffdadc80d63d017ab66353ad526bf0f559d6cb871c1eaff266a2817e5174b75a04e8e2d082d1acad623bb81fb292a39298281d7f0e4523248382d8a1e346f3db75ac9e73b797f8b56ae09ef5eeaae487692c2e6cad288a5173d79fb576f1ec7ad7bb4cdb2e962b914a47831fbb0c7683fe9510783eadafa67956d53392ad507d53c5d42b50c4b3cfcd175c0f7def7b2e9f33d66e93d308568ab82cb9b41b78f6d22a8906bad8ca8b7eab2587ec76e842f17960597273f1533137b66cb5ffcdfe054cbf781c2075c3c59fa14db61bd8834237bfd0e8a791fa7fda60c096c9fb1aae1adbe3e8ce7ee03815e9f0fee756e487928f23f2c7b3ee5a2b69fb44c856b08759252166bd3485da3a962e1beb096f6d1e76f2a41a0a63111f6733448dded877aa9288ac82b4dadc56476820646903b624cb65916e2a1edca728149162ef67c6ac3c27e7abf2d087312541512f3fef09aeb0de217f0d8d009b23ec03955449a56658d818f414c7d771cde518fe7c236a403a7d269db77fa98ca0d9f2c596a997546bb716197933a2373d04c0aec93b4e5731f6280812038f1f029c84848697f85a59ada0e29fbad5c1832b24f3f84c8ca816937f9bc56371d4569c1a0fc29bf2f0aa164376f6f4941050b25fbf824a1cb24e99fc06ef285d51aff7e8c8958dc5a427263782c67e97d384e9246956f4a5c2826ebf897f48ad37b01baf1d34d138b44b4dfcd2aeb95690a03add4faabb1884badfb86752b33c1241a2da71509b8493d50ca2146c4357c870454933c102b097827117263622277cbe0a27fe46bb51f85ba527bd11a35c0572876e6d0ce754bc4840fb6b2163732de471384d7aec26c397749f09b65c5a247ee3d43214235a6638e3193ed27d6983efc1e0261d4515120d50ea9580b75bbc58d0e0f287314c83928324b451e77f9eef180876a7d935dfb4b90ad7de3192cfdd91058d34155277fe6f3ff49d591c003f3cad6a05663d72495852f15fd6d7ca1bfa00a9576370d8a01b8d495586a2e4541d53743fb80747dec58c6a478bb46654d9a0cc9f0cf08a6895bea756c08903d0238153a3d415e526be66a1739077e8b35afd88b34ef489f2de11fc489758d48f842424ee7d8159557adf93dfd5b09da3b1c77c4b1b8dfa8d40bf180b2d3acf62c886563064a2aa211e8bdc95b4e9245800c89ae7a37829a285f32d519dc619ff6e6e6a702968da02535649f965cca37940148abe4b29a117d58f2424bd288851c39bb0ac8f0f87c9b80e9121c921aebe6e299077842cf25791633bf85d57c9dcc416bffc82b94c53b3bb992a75b796f317c96eec1fcf4d92b05c67f8132240472c3475705336de1dd941bab0face3ca76185eda8349fd780d55e13732e14857a2a295c4f51e0878effd82ee5fc943c8aeea8e612a03ba4c17dadc766859eb470e4e37bbcb58e0669d697617089003d8110d4a12cc4a5e63289a5ada9f006f7bee5c8407c3408d4650c7e81ca6a1d7294bb403301edc81ced004432289ee5af6ef241d13f6152c6e01730c9aa7c2b1489a661885811148aeea148f9cf9a02f3e1ec9ed7a894603ce4be8daf0731bb739bbab4238bb7dd2831fb4bb463378db6dc97c95a12ea119ae8a4cdbb1251bf26243c62786d0a269d4b3a874af2f607602c85b25be96fc1ffee911b21202f3ad05841e30a0b371636bd69bb308a392517d0c9f8d7566861f0b3e344cb7468d3fed396278db02a46e0a60bb892a78451bae4fbec74f40764688c3d342c7a7e45d858ec16e8e2a86faf8b463933bfc69d090a45dc387d4931b7ade8c80d7e0c4969b4e9127d4fc0014aa6b13ad87f817d303a95a5e78393eae4c6650c7cc8662768b6d3a2887a9b3faf66dabd0bd005ee60b94f154038a84ff53802e69a7a0621105d191c70ea606ca2c1791e72c6ace984b5ac77b18e6a56743c4abe9e8a460238d1a7847e824c30580ad08f261dd1c4c52f2c40cac6adadfa7e602cb165f29631beeb92d73942305412774e2a3d00f64c95cfeec63dc0ffd6506b28f7846f97b8b02a12d569e1409bb3f3d316cf666f088f4a7f594aa1413c58fd199455974b92caeb5bdb8f3a1577f3d5b792e0e973006273d6d3e2ccf5e423cb8a22dac31cf3b069ed656e17138f8eac73e87e844dc3c156af2a256e9c8afedcddf1b5871e544b8951d02632308dc215dcb4749e8c546a1418e7cd5fe875ef7a0733eef2c0b307f3e32237776eb0b79a3c450d2f2702ca82f5a96b0e02ffb12e28c0d543ba8b287efe4d2bc3c97d7797e74d65a1f5f0cb1d9399c454d61f3baa97494e4f94f4a875606cfec6dba656b5b8a17c31f318fd9311ac3412c0b4d1388bf9830d651497d88c6b95abe4b1a8b008f213a389157d0b503486fd68285de066e86b4bc0a25fc7fc000cbda2d386793ea132dbf73682a2ec7f52671a86cc559b9ad1eb375fe9a059ff0692e0fa4cf25e4040c9b10f464a1d46e8b4112c08998bf94d9dc95b8e684cfbb049d30763cab18e7e7ae31719f1c0bfd68464e063e161e0ebda1a190cde275f61e5ff18ad8ce2f1230d7acd892c09d7fd1b9e3533f9f3a453873060f8b71e7efdc4dacbc9a4d11cdbfdba47915c0cb49f31151a0513de8592a6a95d3bc70222fec47b61acb27a5eb66c4774fc5a727853cee12462fc3d47ee4a01857988f5a95ade3929fb6e1b99d47fd77374c7cdeea2dac7c343465b79f60c092e1a8de257109551ecd44761fa184364e64cf48bc052c0a1e0c8db9f9e9620296447473282c3ee3ae7872a60ec39574998b874c7b040dc64159962ebcdca6154d2f51b1525938ba2b9bd9644cf2c927b510dda1ce9462a4fbf7ff527da126bc0815ff2203c2009b8e49c8c688169414ba34ca6015fefdd2a7ec52d8d1d653c8b698a9710316779f78108323cf0919f788df1ee039a0f7ad85cb15e12734c5032908b6b7ef21db8a452084285f2207d5bec8b8c4bc9a899501a6ba6365e4206ef92a0e18fd1269b45a9ea2e1b5643cf9eb5e30721839711f46debc589013512c7792d1d880a34f9a9be2d16ded2b5b09519805b55c3269b4389976050df34eb9cc17f8e3bef27f955c8c33df5ab667c7c3c716a86e75256e7f39183f217be4afadf4ab364d0eace55f11e5427798d77bb9008c7778762fcf433cf32e57f5081e996e6324a282c11d89cb5979d18c99402cc546764e4561ecd4ab7a90ceee7fb28392de63488e835912fa77fefe1d78ca994879cc5f56832458be875e91e9c5818f07d721eeb27dc8abf2451aadf11fd80825c18dadc4fced865f183bfb33a2e5e591a59288492a4fd1ff954cd25a591ac32fb3c187d7f4bb2f5827ebba8d98d6cb620a58422fe0433c21e018537fb443d4e7c77506fbd820f34d04e422b211fe17dc566bdbeb1ec1ec540f518acf12481be5798a318745220747ad6b5209770bcc81880e41208e84db3e7197d1bce19159fb88448084422918e995a7dd63e497fc90318688ebbb4272fe931f264346b64c060f312e3062a2c6611b9d7ecf4ac53d3e433562476ba199b2704e82f828b43a791d640ce4e41bcbe200d8efd5c6591f4cd106f869b8f7731cfd9393a3153a2791b3c1c22f4baeed604b6ecf8e2fe17a02cba213be5bc2f860b40bc843877373096710a995d1cd2406b29a9876a83fab489a97a82bbbfd571b663b6b880b728cca379aeda9f17a168203fd504640d8144646dbdd606e3caad7d11100b300b3d160820dd6c57a9bc33c24979989ade6ead4cf8398dcb99b8957b355eba81f0dd9967ddedd53939bdf1f978615c6168c0280151429fc65aedb9c199a51562ab265ebd2aa594427534f2f315885d3ca8b4e544a4d2465bd1411f55c3612a09466fd52e61fe9a49a8beb3ec716ed760b12061f15821a59377ae56c2f750aab2bfb35467fe2d51f6933b29794c0f06f991f4e4e864a6c0ebaa87ac64199cbda1d87b8544d1be4a3c124852f1b5b25be7bd07ec027afa6191044b44b5ce37430698e0f1c8d6db4b29cfc0a9cd0493060c4666bf84af42896d737a4c3f794d92ec0da694c6b7653322470a218408ba81e50b5b57e19d6585b66b0067cc127c648b42644e929a927fc2b95f5a0218c2bb04c6742637416bd04b937f9e225a75e23e2d1ebd4ce9ae41b5e501b2c7f25b2607d3874c236248271ecca669b83fbe2fa52555507ef0616f937be3cc1af19e7985698be0e73aff53dcae00a274a6250c22e25db1580c716172f842ff27aeb6ddd1bdfa873feaf7d148e3f03d25f48c7e9e21a86099698a675259c216a04aabe908d1d7286cc6d8a3f0ff9aad8abf8e010126e4eea9ef25cfbaa7f93509256512ed275ad0043b62df0fad94379f88b110c5079e299ec447ec5d31546092e27eb77ba0681287f9e818d2b9ee6422b5e8c1faeb6bb79b72030dc8586fc7f04b369f408a4f4f91c5a9af13104f6515ba39b7e8da9b6741eb199d31777a78d798fe86db9e4e80ed7b48c207b7829e68877e226b347a2511dc233572f1e6ee511f600efffadf025cbd01a2216130d19f6cd6838d72a0a7e2b78720864577b6782c8f268c4e23e4449b275ac41991dd76376d07c3d7c3f5f631cee961ca1e9b9924f1ecd0ed46fbcc45dbcf5f7b50e2d969335bec84b96f25464b4d6613955e1979d06c5e23ea3b8a8e8be7b92086c3fb3fdab49d2b0f7f1a125fc25358e896fd4eae77f6d5a0af915cf729bd166cd5aa1def6e8b6b1cf640078190112970618070fd916070fd42e0281e264dee37b429d799ef22cd95ca510455e54afd7efabb600c4ab99ac88a9af51caa02cf47d0de26280165f8961ff1de82163e304c9071445c7d5c448ee2b5758614831ecc4eb386b3749f7ed618ebab21b9f278249e6bc74b2c495fda7a6546e1e74485d064519598f1bf681d0aa857ff5d1182b357b3b2b61c9c29ac2724ec228b43cd6730b8c67a31a6c48818ea2d1df786798bfa84e8692522ca1bfa2970c8a634ad0b30f8c770f9f0b659d7b5b9267a6013cc4af7a3ace399e0806c75e685f18fde4461519cb7ed27452dcd8cd776676806a3cd6e8cc7f6a8b397567890ce015314866cef4ce8f9f19c4aa1fda5b49f9080b31d1bcf7c0f3c2dd250154bf9cb4b18c47037148c9f3eeae58b0370c5d4b07815c31b7d408fe80118c0f533a0b8e2e40a03c139cd840dddfac528acc86753b62d0a23a86578944d2c760541c3482f8b9eaf01944c1971a51dfc1be14c25aebd86dfff0bb5fb412537490c2c99d0521cbafccf361ced2475ab810171ae3127839cfdd3a3930daa48b47d9b6506697e9de4840e54434b16e76da5e1892d94574efe4e8f11f71155cabb57ea5ce1d3eeb73485e96359eeee81c56978a02a78deebb7f9f45293959a35e01e5e8b3476e635f3e08122e2a2bf3a2bed398348d8712999a5d5f4405fcf30d194b521ec1945656c1a948051de8a8c2914bd38390ef6102c498b2cfd7ddd90fc3f79ed844a541d71409275309ab79db69ca28d0702e9a1d993474959b9ae7c599f36b2f4b4e7adc2ab3ea134d799c8f927cee8f4e36613400a42a419c53712f28f21cae652b1ed4bb4fe5c089496d592fc25626b8bc12daaa81d305b88c65552a8c91b8b3d3db210a65a2388f9dfaff0f6103ba50a0e1cfdb25e77147789456eb58b038d8d4c4aaae7cc2ba0fbf66b32071bb455f816666338245f8c26994d1f6032755e36a31026fc36bca9f3778a6cbb03104227eb86a4ab300062e639d6ca23901590b0e59ebba2de31bd1e1300666222f9f474895d735e213d81b0e35e331f9f14771651b24c00637c3445fc89b67a5c9d2a0b6d18442b0919c4918493d7da72f49fbcfd64ce460237084f6cb7e88b50fcdc3f64429a91f17a94735ed44438e9c9534c2240db66f9edad5e196506ab8493b603325537120fb550be02aca6dad10e3300f5c66cf9d50c95480d9b953aa23b30aa0e961359dea81061120a98ec588a00f92404f13cc24845075447e9deab670f97a0235888d5ac3013594df8f7480ebd06fde3de7ca421b34fefd5024be4dc3e67c64ae582bc36cd94e45846163efbe915dc2823fbc968d81f0b8d355f98b604ca8b89b4c85a83eb9a11666a55008c4d664a48abdfb2916777aabf0f444279041d318c83eeac0117f55a1a0e7bb68e3b1ebc1f38b52aecfbe1f53403f076aef94a85d4f80434126dcbd58a413747bc38cea289b29c1acfa8476a04e734379761897cd4476f146b50c5d700f0c685df14fccb458db386837001ca3824f4921bd48aa97b5f3e6fab9ded5e9d43b7852420f1aed16b92564a4090cca0eeb85b480974f0c656a053288d21db82cdfebf230f90213d456da1bf632840d186b6f321d18a767928c90da0f3fc3cc4fee623fdf3440423bc7cf5b542f4748311d7e3433511b5b424059dd35444a61351414a92b66e87eee3b0004231fe1f538eeeeab7f0e108fdf7cbe14d8268a610ba8654470ebd85a6c579e4b1a2e33f18e42f2c834801dd56c3282aa4d5f68bfb94536bb4c2e41d58d72f5bd3f9f36b4919dbc9b9452e534b492b35c582a81703a1f7c79ba5cec62eef22e05c93c17ce2000a9744a25ce5844410cc7d1437946d1e3814ada29776cfe724ab77c8d198b30479e9b4fcd71c1193821862705d7627ce1bed2c3ba6f799d0fc481da61ce98446398e2d13877a0f6b4dad4f2849b1e35eba38e012b8529c722a56079146710218239351873ea090e3ff9e193c14ce8dae21c55682c913c17594a7c5960e028ca8c1377be9062fa27c37342c999cb9df25d5b4c75a2f1bc8243d464ce80b191ea4bd2acd18a42f3def6a36b8c806a7e8686eaaf26c9af0e5c2c78126c61d164e4c6276a3308620cec8ab1e31b1f081e0a22448833af181846591e24e275c44f9db01c3a25dc490421f0e10ae18ef12f5c7b48ad56b1f4486d14d9be7898ce43efa0a39feb73f715d7b12811c9dd776f940797f82aa68459a416a838477d40f59cda5d7a21691f86fbfa0ac50f90b489beac657157fd92f8bb5700639377771c75ee7f8bf90c2d9e4f1f2da1152aeb0f4e9cf72a8ad5455243e2cf26d056f80a8fa611c64d5739e0b235a68ab0e9eabe765dd2604176858a9dd3030d50ba67367de8a7edf2a21fcc4b946896770bbed82e6a669e928447dcb0f43f864a6a136b7a7e73138b6a3939a8db6fcb66213b9feba349eb66a6d2900056e91e1a67284451b1874e3ee0cb54d68baa75dbf472e6ca5fae632788439140c7408a465527991c8b74d322fd4bf1a346deccd68a0c4745c8d45b9f2056c306de56676c926c29536cd9c9b6b1bb2e3a1002362d6bc27f27729488c6723ed2df01c5828a4e9206bd2fb7be4a617931e0c873624d327060a1f8eea312ae33c54fd63c07cd2488bbe7efb3f3a40557b49441d326305fd11b758cb3be5e6ffd4633ea57dd5c5dd409f1522147d8112d64bce756e7ec2adbbd7e6029e8263673c553585bae820e04d3613564dbb17dee4ba5fe085d4f54a328c65353f1a24ba0af1374785f5f86702775954c52b82a31124d8f7cd25f826cfb643bbd3bdfe9cec2e4ec87cf45da9fb8979804125e6081e4e6b6f537959ce8eea52f2a5e15e4792c348773dde4f54108698ef353ea26e84f67d1c39ff585545e62c731c3fd789d6370beb48a50376a5c1156c653cb3cbf1d0ebd9f2dc341362a29d569dc4a38357630d76eadceef84b6ef180f798a805915ab99b1c62981e6b13ea2dfd5baff7357ddb99852659a2af0f2b605afc41e51bb98238349871f6c4b3236b64942730052b37a2cc33932eb6b394ac44c055c329e6dbfab289b7ba233f4f43fa8535cf75a20595e3ee32937ef622f4f7b45b96a205a0f72067950dd9d443efa61303eba9d0aad2e43814e41399a098d15770a69dcbb87438c6685ebe5bfae35ed151b67fef0f4356829a39251f4bb8664f7d875225b6126ca8f197a64166f5196ae5140c3e8bb54e01a17ac6716a65c5b6c125610c8a7ffce40edafc21719e0b27b49493f7b8ed795a2c05d9a78ae1201d6c09884a77f8d95f56adb7b84aac402224022e93c969e9e25d2578e5c8f581d4c9c483f40ddb803f4f3b3c0ccf1cdedcdefe90fbcb145f963f7ade0c88cdfdc8e3c261438411fbfe6b5cfe5ba059b7c14155e3df3f666bc7721278005db9b6be272609a8e4adcf0693f0064bf63530529c26340876878186152108d36c233e32368bf9401dadf2d799d56e54a3a4b7606fd27e8536efc94a04305aded172488162090e6fa6b52fc4de915c092becfd460443d6f45e330a77c21180aee276a7c5f8ff69b48548224e4b8f54f863b61fab4cc6a911a349d6d961e2eb2b8dcfb7c9498f92b69d3c1fd721944d33aae6c7ffc60bcb5154e6e0f918f166f9d65bf437aa7665876ce45f0c32e7657b8735d4cb0ac42688e0340d370466a82f19b4fb1b9bbf12f2a199e97191e754afad23b99dd9b091cea574c5aaa3ac373b13a579a6faeb38cd2d1b2d2b1ed067c8086264db07f806c6af9b5a131927bd4499e38c67f3fc15c59971c483240d8d2c964f6557e58b3d0bd5152fc64d6f453bf89b39a187375941083691d0280f7a5271c237238886a752a3b41509aa1d5c70c7fe0b9c4faf1fcc1d5ff33b54fd6fbac5f81091d9051e9f3a5aa30c614cbf8192bd4ccf258fa6588ca02dc03de9f771b480f83dc103fe841e0d6ab9020f132139ba48561a377c969140fb7c46338a8ccba484baa6eceb53327379a5cffb47bb3fa41b4d7a2eea48280243f820d3c51ad0097e77de2496e35440daa49392bfba9da5c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
