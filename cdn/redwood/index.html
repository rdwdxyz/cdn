<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4ae8176faded59c3e6d2cdd5459b395cf1410d657e52b12badf257bacd111e10efc115dcf8a8891ed507682146b3ae866e0c1858778cd1130b789958abc09d31c2280d72def93f83d1ff4fe77a4cc6997b4536c3608169cf1470226e6a515e6a83598ad43695cb660d1cf0b1b5fff3628c990375e59e8dd48321ae5ef00679aacc73f3fe53a1615b92000b7749063f118f26798abec87aef8b684672b51f42ee0c0812d8af3bae272dd3cbb871ed88e44303a43ffecd7248d3a4aad47d8ecb7471eed7d1b0888699851b22aa6bf7aca79297b5a291347ecb899a3e5c22b939006b42e335a6b9c45db095c1832bdf77c3992f178bbdd42b4872788e36439f3b3d1c3bd717e855262581b593b651180953363ed1b151ad36f1752bc23694711997699545748ccda5417c093f9437c8314fd1ba35efdeef79ac783cc1e76a00ee43219394fea4b259bf1d3af842cb3668db7e4f9e2e98bc1db31da5911deffbe9d8242a9de75e6976f4d014c5fb0f28f2364ba0fa8a2abc257b76bc631d92499d6d3eb52b1b5c1c183260a1bd33ce60567a29233cce9fe82854c2e28fdf5ff4715b82289b0a072e644a502c790e5a45d8373b37e7dc6c31a4b330e8febeb88771d8803df0456cb67e02813d20bc9fc0061b74af94c65780f1f67eb1c86a828a4886bac7750144ad5de6c4ea89de33dc7c841acaf1465bb4a825be2fa7609bf5203cfa4c60665b14fbf92314c8deb39a684c144c3beaef6913e7d18350c297d00db67076d5674e464788b96f31fedab5fa3a70b05341bdb348f4d5d49990b232a503cba6cf2f6e76250c65cadca6721b5aaf9f2f487e969bd1e0e6278bcd9b33dde785cc141e46bd2b07fa1e1a5346f6f1cf82adf08a8a2aacafa0f1bc355ebd40af52c3783c3b57e3524630cbc9fa30e09deb97ff4043801b96b80ee24067cd1698104d4dafb703aa30ae33394b3a9f4b53ab9a10158d1b1fdbe9279ecd31c63552f5b55c49f2f6821aa8c880488166b89a23b46a965f5f63c9508f6b5ecc9b38ebc37a5ff0f7adf2f88a3fb0ed56abdd2c478529f4ebf79de5c983141fe98b94405d7499548cdf785d7aaafea7a55892bee432c73afcbf451422993df4a544916894794ff0065bfdd52dd1d8602baa940dc2660cc7d733cd03f084ffa8770adefb5451f0d683ba33b7c8f01697e364628275978550a4a9c9d49213ad324509503804810df33be07694007429564e8545d4f03b0fdc45de73e4e68f2bc1050958c6ee6f4a6805013bbf33f3b0ce6bc3a3edeb3904f5b680f35c517d4961b324f93a17c391c2538def52a12f0534542e64f4eb945870daccb87e9faf5a00879904ba36269243c4525026f609d0638cf4b17aa4d86f4df34b01a2d8f79c636bc02962bebcefdca70665df2957f817159210fd4341155a1b0d12c6110d2f0fa68fbccfbc0e7ebda3607220f5a82249b3925846ab19197b976775fcb44615dbb7b2a2a25cd2457702685087d9bd7eb7c7577bfa14eeb4184ffe455a8f3ebcb6ce70eb83d58af02465dd398b8e11b34526195a6f809074f16198b81e89afd5e54d13e0f8655d4ffba8648b3264141fa25e1bdc9e6cc840a97c7569d48fa35991f56cbff4786c366e3d79f54c6c98651730bba010b7114f6e62c0b24e59f67cbc21b589d0428274574883dd720e0f5018cfe8c0608c81db061fcd717aa0988dbbaca56ebe4e495f0df205a4d1c3286246ef909429cd83dda56d02ce5163ec4820d1a260e5cf5d61b589c9c4c19347721b9cf558db847715977f005bd7182dd48f3904a1ef43f5b32fa8a349006f1a8371dd135b977590e5f63f51fbab957f65ebad57a00e911646e6ed613a841a3785471e4534483f151ba26eaaf80c17226c85b23cb7bf4a5c5180c010e490e4ca61ff98e5189ec55446b9fcb7cc426ae774a28271faea0c64d652af73d746272187effc6ee742b2143a946b3e594ec925f73359076c332c3f0ddf468f05a7359ac5ac9e97de2223ed494c44511e4012402d45ba570f9a81a67a41a1a2dc679afe389e5dc628c0177752aa9f5ec9dfea15adb79185a5949a49af548db2d6dda6f524bda1e86d84b74808953c9a81f86a78d588aeac14823c6811dd1ab47cd5dde898071d09c25e3212c2e3c2a3fa64ae56fed5257c26bba15c88aa61854bb7477172cca5c18f62bf1432ccda373c01d783e1c23fd07a3161093ecefcacce93131cd09221884b9429be1036a2da348647cd9431ee9ba0dbe0874670c36c2aaeb3a35802c6f81d122e7e615a21ee67955d7f53689b3fdaaa12d43ac0cbcf683646d3cc5d04c7a127d7e294ad3a371b2e554b7edb1eaadf3b6483d74bf18abc5e7bf73251cba9438e64540a521c01d9580b9ae634ae79b6c1a55973e533f45e5848410a4e5680d0ac49706c588c9724405d9c74fb98a6c6d261ee8bf6bd2eb68a2e248c9a6ffe15a1d13970f26a13aa360fb169f0b5ff0c92dff983ef130410cf06df80d87634f3ee7c7d77588b99d58a41821a9b7bbeb62db09ec521665764500ecb44e493d48322488dcbc7bedf4f06a166a9d1a446b0506b80049371e4cce24a087bbe36314963d2d607fb8bb9bef59274f5102fa815a687a201d93cb5ea6787964d41ad1b13022cb08bc438bbbc09fd92b1e6d6247db794b869e26570af9aadaf533ce83b6120ef51f7641c8f95d51ed023f7fdccf6ccc6fde58ae969252f494562659168c97386346828488b9d87b94cda3b8e10f8d774d13775d31be9df2a3c8b7b5960a00d4f768eeccb0ee3fe395b3c41e5d2970ed6fb36e7e4280fe38877e822962e2014bfcd03c393be8100b3eed5090ef17691bdb0643e0e7923df90197444e43f470fd9d1b040ddcb7ef83739d9291dfe4d2ed8769addfc364f40a34ec49d60c7101918adfee99a91294a52ee4ec6a384d955c0a7933f92a5d6b24cf0e6a462a9f44c2da7879eb98275a9e472ce822dceff0c8946fb065047aa85aa891d8db95186fd7b32a48aa14712a3cee75154a2b11c097b7d24e96f69bd06645f63e2476281cd0e4cf037416612df931cc3315214dfd81cdc3dbb8b91b96128585d7a74d097992e090d5396680048771c1d9c2534bf1ccb46b5fd21522a31d43b488d11eca353d44a213692c82bc28357ebfdcccde2c7b3d79435042e51716ec13da53eee5dba0b602d1c6fa9de038ee57b2997885710199861fb1247a197fbbc775d8603835730e1008d8195c942b6deefd9f159d15331b26c0cdfbd49f5d5398721ea16a36e071dd14c22b739380589b7a48fdc5f0a6c07d60d7f9dcdfc7a0610b810cdcc4e22a557ef880fbb35576c0837108b16e7aebfdb5d566054c94ecf174df9251c979776087d4de69ef24c0db37afc87387af4350d1e46814f4be6ee13ade6006eb79f4adaf6de47cf668a979c99f9c3afec6f66b6fdd462bd2c717169d8e0de7beffee80462993988357e4885cc6e783027d483d4fda24dc99f4a316d57936a2a79aed38314db5d407fc68e327ba18137827210fcb476ea021669ec4bc815217c2290cd28b9f0fa6f7402add2d7a0e2f7b5c48e4fcef0b017905c98b6c4d10f822f7cbfcee119230b7913402de748bdebbeabc4b775fc6c083ce1f508feaab7e205167b78f490e990ac595bfd77ff7cfe645670aab3c1adce67d03e9992cef5f6821d553e32407bad613fbe3be2f39e186d182bcf8e72c3e73904eb1b586a507faaa8589f3c21b06d8a4620e63ab06f72c338df8c5795279f0c7bd2363c007644e794d0114383659bb32e46194fdafebc7ec9e8eebedfcca9bf21cbabd176c3232bef5485b47833a85fc13d5eebd875acb1eb639355cbd39593d8caa662eb670a5902f8051f48ae10ce2ecbabefe2a44252e377971fb4d9016151e15383c95f270052c95d161942419c5263baa5f50b6c6d0207883fb55677a485c1277725f48a70798ac4703336065be38fd48beade2579555f969785c7083723b937515abbcb61706fe7743ab1d9cd500b31bd9e2f75393aa22e20f7ad65765d82f601a7f68127813e8c058250b01243225589c8698212ed73834e22b44aacb5b3bb253c50beb8bf475fbdcb1167a5000dfb0176ab30e24e6900d3d2f079246f15294de2cd1261c1981094e92c83dc0107a85d4a2d559c75e945dfc99fa57ca5f8a6a64c1e7c873e5411aab1b0b22a5e46611d19c696a69c377d73950714d5270f3da809563d15e9b0aff2353fc61ff8acfad5ef8794967bf70e71de7f5af6de11c48a9ac83252fd0683f93200eef956f40cf7f5041d08205e184c9eac0f559824ae34e59131971134208b3dd065b901bdd1ed992ba37caf27ae283bdc695ec42ab07840886b89536a39cb0a9af4a18e7eeec25ef6e394290d439b98162b99859fc9e74f0682559fbe27a78f4e6d406b3cbb570afc429c93abb64956c5de970a80fd8e954c7d95d78e69ec33cc1a6ffde98c71eff7ffc508b15f2501d90a6cc2aa9b5c39fe6884185fd1cb29bb4fbad8db23e4330993a12a974ec3776b3c2634534e9b039bede4210a0d242e44c8e11f2f610193548c51202c14b406dc5fba9110bfecccf0ff5e59746603e6f48c4d5b2573198da98da2bc84285e77c6855c15ff65d024364982b1edd0a2ac8d9924e77468a478e82ef3efe3299013547864a1005b6f8def1a8e1f2d084c35436c446295ce00dce35ab13ad1df43d3a024ece392d78d91678f4dcffd6eb04edd770cebe0a4255b22b218b12f838a169c078a4f929141b4625e18fd341ae2ab6160034f1bda1703f6f3611dc8fad5aa9f5ed1a0b784b8439c54f43ec0a8afcd3641cba4fa63182674b4a43e0ae16c88d8c99e805bc6952c0ee8aeacd5937a62e19d04715b729e2d9f5ef37da19babfefe7ce737248cf42333e6fe120bb803a2ece005cadafae9cf2652b10135e7f1912d935edf9b9752421c8566140a03c89ebc4dd0891b49414958551942afbf9d8528e10ac3a592e2c757e777ffc0947d995c3a72c57b26ea1255ec9569d58cde7ff3cbb8475cb6fb213c7ed0c854fad61cc4c539fab8008972834d465ecf0e26efc97c6315ab430c4d95b455cbd50ca9f0e86148c9ec7ce7583a6903087a1d1d99321cb83f14dc4b9c4973546ce8adfef171f67462f422bd74184aea94c51d9c548673247167406f6a331d093b310f11b6a92ac48de98ffdd4e21afda39be1d3b9e5227664b7bf45b7f279c90f4dd473d38490288e27db057071474ab4c21724915ea45c68d719b615e22982e7218ec85fc3537202a6b95d8415d6bc6698e75a2d053d99eb63a397a06d578569b8167054d54127b94dd636587bb1d82a64e1fec695000d6839c0373229c5d7f50605073fbd0d6cca9764ed29193b9ce290afdceef5c23608ce12f6cd5e6d37ad26e5446b97d86f024b8d8ca5ab006f0b1670088734db55203a39da160de10beb2ac4579b3ae3aff3ce267dcf921650c70f60c7b3bb31f0d4ca1cfb840a2ad11f3d5fc50d8df51ecd5d942c84e426587408839d8229281c043420663d68d75b7601ac906d64a3e2ef9f4fe2174baf20c4eceb304106f281dd74c0b323a27fa5e6de6471a26713d9c61adeaac46bea67bbe3042b152ed31259715cc4f8c5eaf40aff80c4e9d26d94d70689a65b058a8c165037733c938d398ceb8b630c6f9cf9423a50d31370738d162fb5ae13052c30ad0718a87b9d2c79c3cc8c788de1cd12ecf1be34bf27b0a8549b2ab60788c8f730e2503765dd919e8ec2fcda24044b21f993794edcf9e48413c7c36fdcc0d5282d0ebf3a0ee71e0e1b5cf98ead6abb979c601aea76664d38ceb2a5d69311235fe0f80788f5e5848c2bd576f439696ed3c7fca39691a85b537dfd718ea0400df6183a1b7142c056c9c858b21e6ec71a7943c36561a557e6cb7e666c171284a831f5e2e9f94f94c5e18b545ad03cf0139a85e45b9b5c02e93030f2c1df96d8369a6c91c532db913538184391617d32b437defc16bb408f4d34d05777069dd292b438a8edf04ff3e350b7f68d84301072cacd975ae97f04aee6cb2135db39db52fcdbd561701b76408e7166af7f9423045027cedf2542a88a6bed38626a25b795e34f4c5820de793acefd404acfd3f343a1828176c244e74a443f8159da7513ddde2c8f4d2b2bf8b080c1ceb74c6f57104d9ddd0b949b1a72686fdd24ebf19080d29fd647e4e43062ff7a7eab686f52414f9caea0f9ce1dd365651fd4ccfe864edf5cacc40c6ce98d1070ce3a7ddc658abb082a164bad069b5d55c231cd6313ee865ac1e712f7b686152ae09bda7b6ced472343f322211aeecfe0815d64dd8434ca0b64e2e546f3659c1d2ad2ee48acdeccced11fa639c310dcb0b716747cd290ba9abfee80a189eded453404c35d4e7dd9868484075463fd3f55f93851616ca33973711d8be826956993a16e5f7b17ebf9c74bddad6d23924306ae7b03c9f81ef0d1185793cd7cf45a4bb4f3506523d8745283bfe3fca01146ce6b2ddbffbb0226adc360465bfd288cbd8cd916e298e37bcb3f10bca70606497a05ea387115cc5ed486d6bac8c53847717db691ecd5f637f7855e4d829d9625f5d414f543faffebed6af57636cfce24892da51e9cb72863d419d849012f1cb710a7851f5f96e1f947433255e90719c92b01f86de1ec25178fb8f174d3a4ad20471b8ea82d0d90fd6fc631a89fbdafa09e1f2cc3ef4711c197115c514d9e9df0055c1f96f68d9c8f39cbf5b0d54b56ead5ef86575cfb4a3b806744882ae27e4c9c1170e1ed4a66f8f238f54b31fd822b83ae7802ef18961cd905ba0340737e31f5a1838f884a8474eea2c6a6714057e99f77488bdaa857a819b11619b75fa1bd05ca1d6bf74a45630825e03dbf1dd026359adb086eebb1149505fc29861267ca3ffae7c3198bd7eef21d8d437887ef09fd5a474b2b6b3f0a3b578f2c754a4e02d42faf58999d0744b255f8a5a15e1350ddfa1bd749b2304cbb6b227251554b6fd840c8731ac89dd93315b34a78264b017a97ea4a8cc393666e234a3ccc9aea4c023445c4ebdc6564da982f5a89a8a2f643031fc5bdaf4fde07ce5f227860be2ad1b519b79531f81c5a5da7f5914946690a8401c57c912b677a9e3ffe43354e7ec7d3d950c577bd7a2fd51afb96ea2062a59421100b078383c169468fbee19b02f921c8e00f12d9e4cd69653d71cd98db6db5a19c3a90f3edef7bd7af44d4c97458d70ab84e38c2b8b61cbeae79d8d51c4156e165f514e19c3ee8123822f8756143c1d2e287007d85cc673338642ba3a76e8d150a1b825b75651946fae3229725cc54a7b2eca9189b2fac745933fbe4d46c9bc5ac5463a52213f79f7a2c651ea1b090be20a258dbe13cfd8aa43fb4423c1f06d712afc287d1b08bb3d29e54474fef5190f95c7af6637e874b554548332a04a92bcf12a85c3d6d7165d0ca11d3fadd0747980ca85a9078de9c261c8eaa3376934b1fa1e48d14b9ddae89ea6b28461086ff6dfbdec96492c71bbb15719dc7b76c831017c9c93dc1984ebd831a8accfb3bbb5ab02b6506295441bb5ca4508e0d3965a4f499b2719018258fdd245eb744454f646b4b0ddb24116486eec9b8bbd262ee29654d24c6a1b27eb0c28cd1e4df4844c003b10866eac98a9c230db2c362e6a181bf8801a4ae3588ccd6efe73416be6bcfc95d97d459bb4ca681d7c7a1fb35bf7acfa5ff5bfc0711573a4a26a42f9a0344280088dd8de17bee0e0e167f0c55eb5cd012ee066051dfa38c689b04957cad22c8285915ddf2b634b2be650df94ee3e1115802a4985cefaf0d7d15cfa68e0cd6df3882a82317bcf83937401a5d8c2f0d74632854a33b5cf05f5b2e8c90d2c811f2a0ec212ae2f983436e0a8776308a6986de25cff8b94a50c48e9b515e0ba7d85a40ac052616035b101575f8f196ed98d982d65c0bbb27f3c8ad152dd86501da26bb8a271fcfa2cad83beb0aaabe9fbfbf2f4ad354547eec8301a083f5b6082b6f75bf5be061ae29628aec27f75519b0e8d258af8b9fe8e3911be8a67a9231333fa10ec559b0b9869cffc0261cf79c75deb57135ca9cf9daa01f05624a93be7c826214bb4735cbff0436f7271f179b9d869e04c99c3fe6e10d1f5bce5dc0ee7ce1931605f34c33886f831946061b8f6735ef63ec5090c98eece688feecb6835955915a843b2c6d4674240140350686e943afcdab10247879fa92a138a4ee9a892187f95fa508d1c6c82eedd56914fd96b7b8b845c5022a4295bbb67b0e2ad2e05ba6199b90750985c108ce0564805341400126cb38609ae36bb4389c1496b949e0595c5f707ed152a77ef46dcd61df23b7452b0301f5475618ab3db15625179d3ccafb55dc5cc7ae44d3b0f966797e97be94961bfaae5a7b20b3d8065ead67731a42413be06e4c0c495ff7b836ddcf3f259927050959cdfef56740360399d090f7a210d28a4cfc75ffa43bc37d514802fcc6f9794c4392efb6fbcd04fedd64b42862f07208cfe81ad4e6b9e2806e4bfb17c42c804773f0c3c8a5b4053947623ae8f52f2381610f8edcb2a7078f6746fe8ad8a71c27160e3c8578b87366d38c41f1121148facc2d42b1278437a589e19d11e2e2d137d902bfb29b6b96c1f32d5c95ed6b5e5f8d751c85206c322131b53cfd53de5015bc8902f4b129cdfc66a907bf0f436acd5a615d69202d018117908a2b9b0bf9410136dd9ab62988614e317804c20cc3a1b332b85a2c509c8bd605f8c4a6a755dd71829e9879067876a39ca9722ae2fb7ccbd096a51e0652fa006d3fc222b0afa99f4ef419c56ef1d9661db19da67f8e5d311c64378f925df03aa3e0b1d5fc3b280f8bc7c8d9e103038c5a5f64d4fa0771ff04f46d4b4b714a1a8d5a17b0a7a605dcdfef264a7e26f043c952ed5dd53f96f78e4da929dfe7e565beadfdae017a3d8258ca6d9575c094fa4693c97260335077ecaf2767c0545ea56c578f2f21cbad1c0cb13fa2ec55b968ece76dc1756d2fd45a94a799b142e44c1689b17434c2d88fed5aee46509958f4621fef4035f105bc666e86e9393a0d7e91909b3ba3449a40b322747837af795d32a10b293eca4b230b6143e8f51bb2ec66bed6d3931355198ec1592a726c567d685c29a46a89821f149e46ab9cf8bae0702c9c40ab452938bde25b90d4594be800fd19c8e7598f272aca6123760315b8aea84c717cecbcb17d05a2affe63089ab0eaf4cf1f1358bfc06320aacb6928ec871f80e4395baf5a95c8fca37c8039941015428b0b314dabc95843380d4af2fda853089daef4a69a83740ff8c5b9a1e0df74557ec6da4df5effc8b4ef64ef5d0070a4b463be53a844dd1db011aca46a36ce9ddbb9387ad230a00199f52de349c25b00b22c5af1c899662b8021887438bf6e4f9c1c4f462231798960fb8261475a68e970c41afce5dcf6aee2ff23b6e2f938b03b5b005aa993976222d0c5ec5986712a68a17ff7b5ce030793aabebd2015a0dcb8ababf864a908cb187083eaf4358f6953d49313b05eacda313e010ff7b75c719541512db9d9fef5ce14e1953f8132bdc166e54e6bbdfa9c461ec9d98e0dbef9dfebe9ac0351cb71c0e3b173553f2076f651a8aadcf5bf4bbf4ece26b7a0756807a9b6ffc043ef3728eddcef87724f0192a7ddd0a59dfaebd4fb215321b42795e6816b3c45e0ed0d282bf687974cf6a8760b3df2a6104c46a3339fbe4a7fa990af9ed45e169e8aec3d77fa0f493ba056d387d90988ce7cd8724779ff000ab09ad8887d1bf9ebd685bdde2060d974389592dab4af682a82aa2a6688201db51a9319f00f606d29093dde0b65701686917e9abcbbf9e7a95b952a087106a96ff4f57af747ffcab81e07d1ec776534fe3e590ce2c6d1398fb9e00504eb57cfb4929b3de72393c2f84c6ef60ed16caddfe8c5402d39bc2c3fb0ef4afd773e90ab37af7cb030abafc2d1743fe22f163eb32c9c995dc448235adfc0e7ee8716f227d29ed8331c6df8184a726dadef78ddcc4c79b03cfdb3ad0c5598a8ac451b1210b8bb2b85edc3437d2e143de766b55fa4cfac77dcfd7529da1ad66a3f33eddc51e868526d0e163e825dc5bcac10cc50522a89f0509fcdf062b683bb43cc242db610ac6dfe7b141e453f538220f4384fb46fcf0b2f2f08c428ca6b1176bb23fcbec50022135f90c22ce4ef987103321ead6c234ca505af6727f602f4a0ae54d8ca7562c48ed64f3aae91a80db80bada1e3d68c26d5cd8edfec4c88ddb805327531af21bfed074f0cadc1e06b583ed0427085b9995d08f465ad9c8d16d812278994e03725e32d962b43f2a0f515e49ac5590f39b5856a9303c826789ed9dad7b2f961b29545ffa305078cfb5ef00e06379362010b3f06b3b3e4b9b7eae0b421a158e8ad079b5ae6891e08fbf3f79b5f1c56d1e8c6f60449314e3d2ecd56382be084df52b1292d2f7ca3c7bdf440e68adad79777d54034ed83a6a65ca5028722b2a24f51ed955cee067a7aa65bebd8d0e22faa5296baac5ef7ee87811b4fe168bb46f8c35e1eb1508000f372c090ea710e063e2b815a3820ba21e8c5fdd35544b5ac65c6d29cf9638d7c3ff178d12a4eb817a322adf35001bf996b75c0a42eb6703d9b502e45b58c93232a9a2cd32402ef83bb27fd89a979d7720be7d6d71e313412bb50bb0d83b473dc6ce4f3673d391609b75eb73d56c800d23951620deb6c0851064d6fa1e59d1613acf57ded824768ac11eb82441d4d7ce25d5fb2b9a8f20b5754e880eb70c180eac5c043e208403d08c54b493855216e324ebf488ebd77c4b9644dfe614b7d829138294a62e329a9534fa4095eba0d5e52b139262dbc1a9ac968007a95427c4fb3370478d93ef792ec1e545e429bce186a652c0c87fe0bd591b5f880d803a1612017333c7230f6e13bcac7ed899dbe292812c578c5c0a8c0aff18885cdd1647f913eef714b3274f0d7817f97a113d83395a415941ee7c09ecf5d0b31c16f0f0a4cf7dd3f0ba9d26bf3e01410000b15a3fd883c5a185448cd8a6cb32bfb8acb1d1b5e403344f5917bba96859d7ee76894270f6ccdb0f345d37f1c2fc90280c7f9961ddffc2fed5f8191d41eff92f87363662fab06ada0b4fcfbc3b4466611830238c4afdc82276db64902d0e751d88e4aed39724aae6237d21fd8be514a8ea5502a89e1014e7d0759507bd30e50d2b5d60e6b7180036f28ba0b755ee9d38e27ebd95d4c5c27492e99f8f918cf5889797494b04cb830c2720b0d9ba59770eef4a86594499f821bebc31ce03c9c1b5a4df80fa820e0fdc0cbb422b58e97ff940129335a7415a607961fd0f66e9fd6a19054562ef0fe86fd589425e8c346aad4ba0f7b57606a334f07948bd15da0459b5b6cbf168776b442f854026742c16c7ab1545b93d8123fc8f80e09dd7417231338d6f03baaaecc611e0ed124954f5859245959206ca933e5cb0b1049b1820ff908241ab85e0eb5b38f617b4bfc680d15225f41135fad6eb1a2a9170d38e90351184fde72d761be945bdc14e34ed9ffe353efe44ad244452a02b2bf82620180e412baa622e92fd57fa70c3f60d29a80fa644d1e92b8767e64506ccda6ca4950d8e7bd0070f988558d3d951b7ad8a91b639ff613e19b48f12cbae3b80fcd3e3659f633add82a4f406f3a4122dbf9574c03f8778d29be288f5b197645130a189d01c768dc4d56a3fa60495e112dd4c64114292fe08e919427f7605e98d89fa171ca6c2dae11f0a1bc343d229648bae222f4b63d332e866b5081f46a62336fbb61b89acd444539667d1976d857a8babc33603420572b5cfe76000e65891ac328fe92ab46e3333a1350e1e5144be4ce1b713c83bc12ed134dd293a3aa190b9979c2bfbcfe65b100073a4d23c4ae42b9237485f7930720d6c9e2bdd62bb4175d11e1b552e98e4912aa6bbabdea911cde0f26a2f0b9994aa6308e4bcb4ba76e0859d3508ea49fb84d3d8d297ad2a59760154abc31570af47b114452e40ead6272c47ddd6dcc35888f16501506fdae3c01a6d55e1f03c4574158d143edcd46e859a0299438667039fb46a9751a7cc38f437f4822b96e940dfe642305c04c4e44dc09d2761735f86b6eb814dcb0d2ed861c39706fa565a021500c956433208fd39aca0ff7441d0c61d417b81474b3475ed30084ef09fdd337913f1eb1b04460b8ce9ef7a4408bc9f656b3d2edb10692191a6577360c72f34face44475298c6c71748a4d1903aaafe443bab72fa6c914ca46584e33c2d87c63f930c614fe23b8e79879321d0cb08085dd41578b738496b46878d9542f749d38daecc46b6353308027bbf163b1211b142de4d5956bb763793476c78b74f294a1c58ab83e7e11362dce656a228dcefa2d69353c13095d6a9cbd732f18159a501400e7df1aa29b0324bd1203366eb5338f41b8e4ec7afea62890ddb33b45dc9ee6e411c532626b9421bdbb71e46b415ab770981b22ac33d166cadd1fc0800cff8bd66b3bf8beb0bd18767b59bccebfb42ae4878ccfcf3ec7361b572bb800727b1d2566ab73b5bd900698b6a2a036809951a71a2abc8460b73972236796ad7c0a9ac8012e8e1e5a58c5ed16c4c9204c0d2f0452bf8f9bd051001bfd7a12e49df4d0841b72fffe96be498f76383ec05c9ebc93e8b0699d5c12bff06fffa0d0fe4b882badaf8073bc8965424191f6b47d17305f5b271c4e0c06ed24c6dca09f36ef1f3d67070b48ad31c3bff20b78ca2a380483170af800a5c037dd9dc1486f3e1a5683610c75dcf783595c675162558913658657efaa3c4f14dd1c45230701aeb2d54c7ae1aba980ec059889e8fae4bbe539819398c253998c894027bffbf416d70341bb24a55d6a4d2c5946c0739e3805ec2584eaae2a790cdac832ac621064361f22b639cafdadb33e25745ccb093e595b22174cff92853d219b9bb68d9db4f9b3dd3846f6a2379130ddce8b63551e0611648ffb7593fa0f4b9b8b58543ec1e11fd74dde05eed71f543679dd5400cb3c200d83eb4663b23915f8ce67a043072b9159227f746a72b7da6b2a9d82fa58c2a0f2b68afa8d5078d8743e507308dced8ab46a66a66b178223ede7918b18fc11dc67a0a128f63c1977b3e750deb9e2291ea7eb6d1f2cd6c3347ee78ad337758774da3ea9b19f6e6b83a509871641211cbec0bfcba3fc0813628bca5cf62deb516794fc0d84819ae5cd1eaf0b2ea01f1ba25a610c6402a00148cbbe2225507e7c350c0d2cd9752a13b89305895976889c571389d61a154617890b0c3955e9863106a03052a9e3e37c0b1040a6547bdd3df38568607299e2b82f741b2ca753d7d28d6987f91398568705cd30d146362c06929de3e0584cc1a180f894aa020578761ad2f6b777aa2996e345839c6df9c7fb3bb9bea42746ef2f18f8a4ad4670223093d29a408e19d0d4e1451c4a083f78e0bb2e1b93d5203eabd334491951ec5dae6ca23dc077d5cb8410ab3b6495b06c2c27e1e234a92498d19d07d2181c4861f7befeec860883b06129324ffcb45413b2390190d38827c761f2ddda54e0bae542042834d88d7e037151eaeeb5db2d5a6b1be12a9d496ff7cbe98e778b95fd24dbe7340b791e2f1ad9a701b40e9761d4ffd3b4b22ec65fe0c9a51976f4f0e6195a4a3b66b040eba0d74d0f26cca21a8e19ca1ada89cae60c521b7510db542a59816ab26c279085986027b4d4d07a231452b666abd311c3ffe38186a4fa19d8a94136b70472159a14d2a2add3f96dea3691aad20b47804a64bc290ade44a3d2a525b7263480619f3c97c174f5ed493a3722020bed7f158a14c8bf5f994dc5b0ec3b065d96f2cd44027d537418a9e71b4978e1e85dfc4d7a86763a3396decd2112f0cbc1aaa1801170dcbae16c18cdf3604237aeb058d32dc6803beb44f68574be2f2cdc286b132b4ca56c6649d89823e87a85256ab2981fcc2ad493028d6b9fd4a9df11e77bb66d9dd073df1579453afb32854ef19ca190ff7a009d1b4ecd9a798ecb1a70cfa6a179c23023af43b5e0a3137db64a255d602a9f05f4bff281640a2c43eba17d771bfddf5e62b270b3bb5ef779ba93579a2b1012234fe07ee0f55639c226728d6a50d5594f77df6e91b57a36258a1ee58cc5f1a317b3555073271f8c0a830d28e45a44abd50a35123dcb538f849ffbe1729cc82077b62df0846d9fc47d710a6d014c2ef93370c63f61cd594108693fd71ae817952a4ec0d9b1403efd33cef2e9513331521d4ff8205ee47c49b1962128921d2ef433175b885ef83c9d41c98c077cd89f7a86de5c6725c8342880f130dba3ffa2abb3c7652d1298dc084faeb9b885b59df7dab61f336f7bb78346de1c60af54cc9ee2a13f30428e3edba2eaaa389913a141d4eec2681cfe909f9b7f19ce1ecf1a24bfdf67fd96029c196ff76559263fc455cd53a3a4e46473058e6a823417fb77b45001efefce06f09493dcfb8ac297f97ffcf91537fba97817d8ec6294e8b9669afe765f10dcde03eafe6080242f715b20a74bab7c75a4bfeecc898f923aac9a30cb475cb79c46948cddfe80a9ffe490fe9116749cd7a9d09ab425d99270fac932a7879dc02726b8ea1e4cf9e01ab294b8df1bb000beb2f4cc581cf9e123a1a7334dd139bb67f77f94276608fe4b4e613b991b111d1a2a1acf84ffee80dae48dd2c8489fae6e4a538d267d80e58fc1d10057722083360512181abdf7b9c2c3e134a18f383215bf0f54b9fabe427553d6672810184c802f8abd731e6c31d7fcedcb7a82784084da360040d3b632988b78f4976d3986dff8bba35109f1e87e41340f45c0c774ea6b348841c61f3e5a10a9ae10f89db7bdb302a07ecae83ede27b42e30e08ba0280fbfe2d5fa189aa47fcccd540db59a065955dac19fe8b1c8c65af2350a988db1a75dd66ed2f3c564b616de11ebace59c78bc2fa12e34b3b78d97d6eda70bfaa227d9c9354215cbcfaa045a7aa34fb49b91d7a1fca6ac1ed538c60ff1e34f3af9d51a17566be233d960990894d28fd1e1c6699d8a2c60b1fc5197609b0328a9eb1a7dd28e89ffc04f001a6c0c143964e8b3ee47a6c97e07e1c6c6dac73c867af7f5b130f6cf1719687ed0254ec273b10c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
