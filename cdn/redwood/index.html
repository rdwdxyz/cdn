<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c785ea22c12e8e33c11053194108ff9abd1b2fdd9c43dfa3bc77b8e02c7d41a1af4fa4e22c805b9ae6e75f5722349819f7757b419b5d2c54f15177e041699ed01e49f55b4862841f240133c75e29b9bae85869af27e54640177c51dc640493b0b872d59e76b64e0babb74348479d127418195caa07e14ab936e6aa7838e2465b6573785109e472968e321f9f4a315854903c0ca88c81649e00d65387192289ec02bc63a524773e8fa1e0d9e7895816873c9fcb71031ed52a711c03c76985457a54afcc0cbc6cbb215eb87c2050b9e9813d31d390044e3bfd05f92305a2989d8b99c55f8eefcb406ffb584335184ce91604ec94e80f74fb2e51c73d12d609084793d014e7870892b7b8902c697a9dc87e4a6fc3214c70b8bcba918b2b2ffd9368d2ee7b3b38d1798ba9c9c7112b752928a7dc1377bcd5af107a89b7a7d99eb6f60f8f33d13a15b8c022f8b2c8fe91c09677ce9d88133deb15cf16d390d89836dbdc7b64d88b27e75fba25a33dc09bbf37a1771769f0342e831d4d47394a3a41d8748e06d352418ecb1098f3e3a602429021538f158ce80cc9109161d54a18a9e165e1bb00073a19fb776dce9be376407551113ee02581157848685bfcc22d3fcac1be77cc163f18e030f5f8fee272e631c7b7a27862299e430a55bb277ef93630f6b9b8216e026beee86be488c285903a91e7b6cb1e971282bda7441b70f7c068ec16185434a82bcb6dd91f775a8c502a6e3162064069d6a33d976db63624d1a3dadbeca8864604f7af3d68678f443b5aeaf29fb0036e0e3ceada9fde92d2c9a0bf089010be7aa60eb843b9f5fc6cafc7cd2fdc23cf4c54cde70917e3c385f25827c7e6696e4ecb12fb585140545908a363b1bee7f24f6e7e6784b4314556e7770a7398729d4b15cc1f6d20ff273360e4fcea37f8b7d57db66e50b5c39da69ca60e339437bc5de021b676b762a7bc8e51b28b83b9fbd64ddfe994da5dff9bac71a031ab711fd52b4b069bb73972ccce4f34626b00a296c317aed0a49170cc367d6e8f3058108cb5d278d1c6e7ec4c2c76d13c32246ae49080f9568a0e331c8293ef693b9085fbb93d5d24afee8fa1d85cc5fffa50fc91c2c6dc8655fc243e0fd6d47d27532b59eac424700ebb1362a405539fcd3abcf877a622785732b77381d62dfa0ba3d544924853b7d3f7d628d036ab1a925b0f4d610b50c902a526ebbf7cb642c578ca85f8982884be42f093550b9459aec66c23aced180a3f69efc3fb76a78fa0a8d7cdc6c3693f50672889c3e88d149b45883cd95ac7351baf196a7e3ed9f2b5ea083b5194bd4ed338d6fa6d655ed957abbe4bac792361a20ab9f172e4c53a7b70a10718680dccb546b5e2e67ffd4ab623d621161f1e41ef994405a87ddf14004451ce2a9e119049838d74d0ff327084983ff5c079e15378e29d22d5fc66dd32409dbe6cdf7f00708ecbfb476baabef44c522fbd5fb20c94345eba71838ac06ee5fd32fcccc8c71207d2db70ae45fc66aa99531ed79cdc1408c69cbabd24ff96395d8d7a41d6198fbac097103af4409bd7348cab12b7df0892927f1982878d1a9982c55710d9c591181376ca9f15c9432c71835ef8fc3929c936c38424c4299bdd32e4d46d4b2df8eba85ca61bf376f8adcdf1ddb1bf9ed75488bc55beaf9fac4a5b86b47c656d5b8ddedde8c82f00dfb315d7812fe77f20784f609d5b4885e9252b5cbee984c262d35918cbfa88f3e583d84402ac0384afffb8f7b18919128091e1ec91a7c194568e8f9cfdd7efa54c8838d936d7bc235698d2d306a8be57f35d29edc70b636e4df369c82b39f51f4f6468be4f848a34510899eb6789d965ca2622557cda730ef8cc243fc643598348ed590c48b344618b6aac7ab7b12b11340b67f9872a08a99c8fe08ad26e6dba5efa3558a2da4dc3f712365227a7b4474a4e94d96d406c73b7318c1043513390315c9c10596f68d892a92ef2bf965e9a74652de366f9d3bb03fe4a92adc85b4c65c7ba3d339c26890228df092d2dbf8e818a56b3a9f03d8806730f82f4375e8fbec69264d0a82bfa5f2087a685838069a7554561def16f11c91ef4c6f7c91f13e01852cae8369f7f55fa4c733b119f549f4d6dcd100bd0a53b2cf4b8424bb13271a451e4d8ec44ccc4751800204c2333956dafa1f2f7ce8a7c142a35ccc199f9265cce872af86294c06ad20e936fc56435d70a1563a721cf5c9f849c400c54201e49a5b1f021ac618db7ff3a6a846a9e26210dd5c09e4265cd76ab2084692795187bc5d9b2ecd934e5126854eabab7193e646b5bdfabaaea1b96f0e9f71c3abc1aa44d81cf5dd8bf04c0fcfd6fbd8d242fc71fe3eca1958b62f4697c973b4b6e9e0aabc4d83d6e7173fb9a02c6dbd91bed2ce736955d67b26d9cb9a37ffedde3a617abb09da2714fd399529006fee6fb6e88a3ccfe51dd98ecd046526981f46731b8c11e41f3cdd6bf47153030362d91d46e6a92fa18d9aa404b72bc22b29c611b99eeb07304267fb8ff6c998be3769a532b607b8d9dce19b2e0f36d5f9c79dc6e9eac235e0f82f0858d83e271d03d51ac17c7872f50db91b0561c60a85f8ea9b5eae2c3d01775bfc9ad073263497abac858f383eba57987e41caa484ab3c3c6a1d1d571ad0210031938f7274ca073a08bcde1bed8167f054f7c63ea25f9162ed6e894055f26d41541156b153a30f8bd5ffc13b468a0d6d1325cd447de39f23800f5bcb3f678a0c95ff9f888614e89df7d56dae3debabffce3e6b04fcab11f5816cf0b03d3be03d42ac7fb5124bf89ac97d1523a763d2f9dec0d18057df5d89883b23d5f92a013ef17c34793e911efcbe6d78913b7763e42f4a6da302e3a653d0cf0c97119b30f2f72c70b74c68f409e7e7689dd37a2c002bbb667f5cc56de2020f36643ff6a5e1bda5ed618d9ffee85d6eec1244f797b6d164e566e55a8a9dff8b1ec41555ba12ecbccd43e2c93ffe2c847213f5c5b06d41e2443ca4491dbfc1b33543bb2164eb96c6d57e9e2204741764b9355ce63deda41fd85d23b33b1de6c1592a428f7e0def2aaaadbcb0077f5fcb1e60fa665cce1db7fb98449aff8b4745421869dd91c3af5b895a56c0f73e5bc115a89fbc66ad0ca24de3e06a79d045a4f0e0da38c86288c7172d3eece9265109a97576c59fa9bdbb73e99d771701c9112be9131136939a76f1d8cd8536c68d87c5916575ca7fcc5600061ed90b3b3700a9112be5a9ac7c6afa8297a3165b47effcbfa33a417892ad76becff0a4ed7badf26891565b0039b01a7c15541ebede76ed74ff155e8c77c76160f9936ae51bb03c57e2e1d4dc9892cec1ca752a12c1dd2090f13c90bd4b792b88a0208cce57ccb2292b0e44bfae22f42bc7698b59f4fc704c4ba3c3f2376c8f586791ab4a52dae7b26015dec8aca3f15a8449abb62f7d2762445611c41b0bd9d2279b07b490b00c7f700aa8b102e91526db5071a60c2c0a966a496c572d387e18bcb4b46690e28e3085401a788409ff6ead2103d4bc46e43c1e81b6cb9babdc28f579e41562c84f3e8939888cf60f1326b39bdfa7970ea5f2ceeb900d78efb5b94f1e7ee5e30e20b1118afac54f2debc0dacd557709149ebdea55ef9371c5207514c8b30b8aeebabe6d912a413268db232ec7fb82bd2d9b3a155baa8628823024fde36d0abf597f452d041dc4f782f49f7cb98453b0602d5dcd70032ae9971656eb5591d278c9f41513277aa6c98e128dc5c22914a19faf8c4e8c78e1c980c08c343bfb4b41f03bcbad3929bb1c53bc1fe08dece977c410c77f19ec932426dad4dfc84ca92f0d62f7a647c373c9ddf9706bf61c7a1435caf62bbc476f7f2d07b3c08a9766af46e6baba912cccb70ead80f292e450dc7a1e525acf44365176c069eca8bcb13f8e795c70ff31000189bf3e9abfaa91511527e608356120e7a39f1908f8b76b5fa82993fcd522b65abd7b72993cb50caa9ad5b823e20acab01e42478ef53379c9bb1359d1af979dc5753a4c27ad21825191133a3b74c728a77ba47ceb5dad795c1f39099a276121015fba7c88fa903c3ea18dfe1da015ef17a04e8d9f76810a4f1f201dfbe6c7a347a497551179c5c8fd23664e9c924c4a4b40dbab232a6481207eb1416dc43fd0fae947f6435279749b48f98c56aecd182c6a70d4f87446277674ac769fa131913fbc1b3de431da5ad9966368f118f6b88e92b9da48248442500b54536a1e876a7b35e5275162a1832b9d9c0e6883a35e16eabdca92b0459b3ad07f713dbab5be4c0e7c06dfc4a7be98d6aadae62c87ec4595402b3bedc60bccf44e0a858c8496a517c57a2e4f79135655c37eb2907f723dd0cc94a2191ac8c3b508e9fca4a477963b061b77dfe6f6c9c962cb3be1ce63d8eb393cf052ac0ac3e755d99659044617f8828d5a6a63b0a515434acd72e93b0b303877285c0ede7b9cfc83348faaf7f8bd789cee0af1dd586bcef543e5a797fad53696d08c725b2ac9372b09cd25f751312910040388bd93d75177b4ffe682bd888d422986ef464db43180d2fa3e39350d4108debb1f50dc024aafca1b1647f124df8b6ea6d1c99e5db02b341cc0dab982f9a8eec2bd6847bc4194134596be3d2773d5a0f6ed2b33137b56658c820fe95c5337bac7bc23db3c7a0ba0ac3ad900443c40de4627f617a4f47a062c6fa4943f177b113cc3115ce50c4ee5ce1f3c320f6340af922b5cc50687ca648cdf52eb7bb99c4acfe6bea89dea1688de844c2fe05513a3ea35fa344d852404f57e43618dc92aff95cf8f52d182fa735aec36d7d0e881b00a180ad26fb6c56c3fa6bc6668d7c53380dfa94f79a1d591fa42ac2ee5b163fb7605bb632739b336db782c60230f7fe2c2f958526fc55b71a7e668bf643f417dc92202a6c9b6524f05ed083808703cf39df9f9470272616974426b0379708980c73abb63acf5d167c957f1f7492092bda84d7eda9ca9601d53d9b2b041d57b5b7e9b53cf3d3561914a19dd9c630aab54fef39fe20c04e767b671f7bbbb6a12f5b8979adb94e287e4c84676a567740fa9b613ae48294753371aaf05755fbf514c3e7b0757ec970dd21622d468cf5f5d025c7b46bc245cb80733da84d65d86de31054d9367cded64e276f3160b398ecad7361276948e1d7388b8323bf858c97076ca0f6528b3648feb7acf01b5ca5da2bd2996583d7bf37e6e0ede5930c3e9621ec2d5e9e012cc7b8c11746d3ecff19899814ea0ef6cea07666191596eecaed3d4fdec66d5119311796940399cff2edabaeb9d203de45217d5536f9dbbd041c491bc126a4a43962a0b3eaed802f8314482a11a056b3fd5a139dbb4f2a691b82d42c1a244fbc272a6b32140efb1595722e3fc381e6ecae4271633359b412d83eedad83160b0d34e8edb8facccbcaa2e2123d82f2c1dbd1a6ec004f9e6710fa74959b9a2804c2dddf36129bbb2c7f0a2e8f4f6e8a0aacd865d5b65399a41fc0217b681d6030f8d7d113df050132fe0797d459290a85b67ad8ac1be7420857ec8f540b0976b3b2d8ef45eb7f0527b0bb1a79324da00275ff96db2a57ad2f715f3272fdf18147057dd1a12fa43f533400e06556ebbb2ecb92e0cc0f03e1ba8349b93e022aff70ddef616109de2fe821f8e029ea5d681f352f0c5398e475ee7dc5f97619fa8647b36b966eeceab82d75c90bcd5ca71c9eba9d564d41fe4d9168932b4b2267bd25b835fae5f4231bcc437d00a1b462cc95f56e81a933f2c4c946bc2b8a15412ce2224b9db0fd29a8ae6350d2043990544dbdba5fd9a4fcfe2857a199bc845eeae5837faf4b0114b230864d5518f4ca2fae7a8d79bc6d13f7402636952a02e35cf00590852b14c1e94493c552ee75f092165652e55319de898964b2271241f152593f4fb1f8b17e1d8829d74f3b8648415559ab8ff9cbe136a6fb9e50ae23d8ab6116faf8cb638ecf6c5bf25dbfcd9564a3ede6fcd861db1a4edc4ea39392ace9600f97ac818617725d02df336063a46ed664a933aaf1ec6a7f863288ff998d62f6de2bf6388b47839063109706234e51be9c2c0c9a341eceaf97a87c2c72070564c1988104dc605eaea821c7bd26cb923ad15f90021683ac22fa0e2bdfcbbd60f250455a80cbd974f583e1989b7c11cf4687c5409bb2127808168a087971835a156374366a4219b6699283685bfae2dc6ecc7598919205e838bc149d0001f08344c2f1b7059174d91339476566a2d152dc635cf5351fa79c646610b69106de1e90e6a48a8355c7bdb95d0f6336a74fe1f014ef789fcfc3ca77a9ae089267be744778e232dfe81bfe49e0d343834dc832594850cf34d0ed61842bcbb12d7b9020f6c80c30a8fed4905ea116cec92a06eadcbe2779354ac95689f5ba5d8ff96d49ba7c22e200efdfe6469c8510b00a2773800593e2b09484f7bc3b2917de7ab586debcc0d430a9c08d7a3b416042b0d337b1c8cea081a21f7eff9a1bef4b922dacd39bad15556994853cf6d6a399553df17d104e5c9388e352ed590bb5ce173c4062cb36bb068f6d12b098e01953c3a1009509236e8748280331f78c0dd20a5b942fdf93b53d8323b1a047bc31bbe71e490005c91ab68d4c606252bdec788c4750c6d49bb8eabadf0036a0cf077d7d4da3c887c2027e88ff36b9ddcb8e72ed5d351bf41f1b5d4584af1a7f59170a51ee4f42a72f9f57ac5a333cdafe8dabb89e211651de2fdc1004f241020af58768d935f1d1cfc8e86194c03e3bbc3cfd81c17f683d60b672e16aa48d7f09e9e97b8b1aa9c43f8be2d6c67eb52cc472db3de6ab60a136ca67adfd13da33d738d029fde93302449d5adeb6d47f55f580bf009581cdcf01364139078ef4261606bcd360af18be919bfdb303e6e0fe08f8ed3095557b3a7d1a8bae1970e5bc1fe6aa3c5560cb553efdd5b897b158d3a699d22100b7badbaff4cd74f5dad5b985ad074ea982df9c129992c56f46cf7bef379369d8a0442672caac4973e386874ff68558b6c2cd88708a9cf6a675e76b7c0e56af469df23c7c22c03d74f5459d94c969346e532f8f2adb00d69e37ecbf497eb969d766a9633a86dd63ef03bbbcba89130e0124bdd95e8590a855ae6837212f449a3b202a0058fd6fd2e44a6755e69c9706a338b677d79b8808e4460171e022ac92fc14434b7a3020438712a47eaf9a5f47d85bc9dd952174529fdcc09233223687c925802cf04e4051e3cfbacafa57fc9248599e30e21821e1a4e7d73ed21ee8ec4db77a6edb4b05aec12648961ef60696e7e4c87f14a1815e592d25578e438fac7c956a75be3686d95680d9efe129812a7127d8926fa3edcf5ed77cd6824d614679ab5eeaf07b341c020c1c0d55e149a4aecb673a6696cfddc27210fb9f42d7d0f6c493d1a93f8014d3d63271c3dddf00a19ea2b338132b7f05c907e0ddc6953e00cb61a79a96ee2a61860fe39d718dba11c06b5261ae6b1988203b3d2e8debf8542784cdaeeca31f22164aa4ddfa6da1d11b28d39bc0f71c695c93a2b2fe722e9d70ff1fa4e0e9af3152eafc1122a8e29a528292a015130800bc8ef11b4415316e701959311621280072829b30bfe6a73d2a32f2f235154b583d56763f39d13c8de6603b06433bc13a820947ef7130079155a4e03cb2840c12b16cb639108cedda4e2d2e8a28136be34574ae1e72a2c10dc258774a82c27c4b81b5c7b3bfe3ea81ba1c07f53185f31f773881ca95c14b529fe361520ad09225263054fe1ecb262ca80bc61f02a2b83b6afae77af42f208c5e250aeb2c6eaa81ddb675c43fe2d3af85b00d84b52db66ccf442452911b5e201c65053c3b2f4e3ae9d218c14932460302050f841ede09cb0c81c876f53f3d13dfeccb29be36a293a3f489ae820943289d75adfce279815bebeb1673c5385e094c96750fa5782d9448db4cf233527d29444784ce1d48bd9cb7ddbba0fb4de65838cad2b9a44cea9ad58ef2bebd2daba151c241556d929e6b6a31123c420d308364f8017fd00885e6857033ae6e4cf03bde8b70412932d1d44ef2f8ebe6a30812d17d5880e3b9634a0216df8e4e8a44811eded949f3aa6f7701cda8a89586ab8ae2a33e01eea296ba0b2d1cedf2802be602fa4923a56554496635b8083815b1dd8015e9becc710965d97a471af6b547978fac30d2fcd86e497f0e795d7aa7f6ee379a721b497dcdac22f8e45281fea0266c4480ef4e6f9ef3e7100f9ce073c60f9904a6a920cbba4c19b255ae1f9015948f3d0ddff8f013edfc67c1f35d97fc41202dff515c71078e42568a34a1109d903f210476134860cf93dc8e6019c29d8db7f780c92f890335c72a834cae27886ab40b1e9753b0f2e68a96e6c27a337e19a618b568467d39853316a07a4a4d913da2db38106b6302cb3f495de60fd42ebb28fe8bee41eca8a5ac6016e1d858bc3bd41903b85598eef92edef166b356b3c0cae12ceffe209dbd9504b56bc59bf07f44cb4db4abed6bc930237bfbd29e7bfc55a62f4d4a34323b134e83d5d12efe46477b2697fb4cf3bb04c86080f74b3fc11c3536741885b2af2518a4fce9de3f0912c473eebaeae1ba055a9e235ab21cabb93b13a5da21104596f8cd44085abbb5b794bd15fe227cdaa28ad9ecb3b438e20a0c8c0fe95d6129efd2c432623608694929aa24bedeb52027b8807ab19028854a9ef958ddd6061d0eb3fcb96c94e98378f4f5740a09f10f8e9cd6429a145fa520f60398695587963de5a232b657f5160ec4f2ebdc50f790996ef18e279d1aa902354573f52c382f5f88fbb433f600f398f2bacd03e634060c615d4716ae0ed64cc5820ef73ccfd0470bec4e99d30ae011b8322f40579b78bf46ed4c77690d473e6bb92668eced06a1eb8073decdd6f9a0492bf965b7d1e73872747f76cc5f4d19987f6382774ca900c046007bb875906346fe8931d787b9f2dbe667707898aefb6552f0c0fdf61d1fd17ca42adc36a051e46ec78ec73b2d93fedc466c53fbc3a6b28b105bf6d8a7186dfb37b2f9be33842f2fdd3435640c66406433c9e8bc02e05a14d8b889dcb3e3d7c3c4454d94f886e7e5c7600ac02c67e71baaef2e43525c9897acc9b498d10971abff99c6aef08233c150401e2a3af48d85db0ef205d8947cc23dd4d71dadf585e083cd670fe1249fb0e14fe0e3a2287abd9c232e25ba1a38863ad69b5345e7abbbbc1bc6810ff459cd9a586a04df54009d3c875c730a7697618b512bfa9beebf59761af7fdb4bde64a64f597c661961352947209916493ef4f339687557a00093cbd7c4f5874e86f5825da5545101553dbb8f9cfdc37c08b8df73bb5e76e566e643ab593908c786429c20062525d0d0875ad3b2cb0c89fe12329d0abd644557ec50a8055493e09fd31e522b9754053d2ede05fc1234297d02c2959e7000444aeddb993f32f5944ff2f2c5600a05d93568b4a404d362732f53deb5f9b1be52d937e05900c4a382c32be3f6e43a04cf2fe78bb89b9f46f1246a8b16a9ecb65e28a22729609246a58796884f694da448f037fc848b86dfac79d99de05e1bd0eccbf8ec1ecd8bbc31343c3e77b542af0f2d502901bded7345777b2a9907819d04ac44f2d0b0a571df7ef574f2e556acf429e893e8c012a5568d561d9d262916f2769c8097ddac4f7b4d0e02cef7e4d53eb81c7336576c531fb69c7bdcd47af91543f8324598567d7e94aac415db39248a066a69de27ec787a3d18c8f0570c4a1c51da259bf986138a90849b9282825157b0da151b95d7d8ebb507bce9a19429c57ea780dff6f45956319bf2b85a42fcad6dd559362387f50a99be0fdbf8f93fc080a3b178366353844c55a7cf4b10ac3e3c54581c8e6ba1dae2091ab62326c2496ccfa650454e4bb61e4df974324ee5d9be1b7de54b3115bc7cd3d75150e0d185796e482f4ac4f489bebc4966af4efaab82aa07d3fbf8d0a041a4c00f3441fb833249ea1bca11612209463d81e06e3bb17318342ae6372caf3cfa7c2f0caa2e30e1238865f79f93691b8d71bd689d0ea94935a8406b65d9a9d1c0a55e1dbb74bf83fe735a173ebe5c69086273ca12081a8ce0483ff582cfaa47fb5619e293523b258719e4c30dff9b613ff22817c7f15a9e35da4570042bc5aec735bdc92973283db531744ce9b6961a7b6389eb79985354eaaa0b3d8da5461b29d4441478c86f1d490256db390f6fa706eff4acae71bf0d994a4958f92d286cd66b794290b858a5474cb2422880717317dee5fa965d0eee38e17cafd993840c9f487b32110150baed261059960ed9444ec30733c2e22e0539f907ccfccdb2790ad72bd71a9fdde4c028d51014bb3d23ffc01da535bd7b303e674ad7d77cdba0c98ba8193f1327789e50a6caceea54cd06ca62ae4c0f4ada117aae7742363e76bf84da3d5d8c2b0e99fe436314aa01a9d2e7ac76bd77c09487e7478e6446537ce093bc1a458a1f6d1b81fc26b47db779a8ea50064efcb609246a5deab0374d243af6b9a11a403251925d8a156d2577702f9d3d830724c5942d100d1971fdf5ebc8a0401e4fe64c92565284fad213d9b7b9470d8222011ba13d523d17e28fd2262aedfb8b51b44e93bb64f58bd64fa9a235bf3bde6eb2f21c011c256b0790109636e3797774bf582e209ba2bfc59b50051fa111004499c1006bffe20c1b6b8c7c4c58deb1478675d75ebe818bb56eb44c43a152132d5ab3ec5d277b4b25785c69c56df0dac8b4840331cb4457b8aca7cc11f5910144e8ca40e83b0c7ffe3dac6033ad2a426fd6439aab7624cd06cffa96fe04c5cea20a822ec0460b1ebbb356c777c59b455f52bb90d799f46d9613fd6dc55022eff3834a2191588fd46d169191b8cd21bdf70f7f1403facf92d7e3eb4f12abce00a3f66af708a5ec94cf46fefdef82c1bd8bd290ebb362251ca48fc4bc3a8163ac60633e98367d891eccfc7df3e07ab6c0d79f44a64b425e624eb22a40b6f90dc34c69d5530ef7622af2d0a117f674b578c64821cfbf3a0c5c78e9d6e69abaf7e406f483d8ab27196437bdd4208a1a9d24ab3b93caec745e7083045f2471fb95526c4608a18a9dd8d0735a05439118cd6c3c5b29bbcbaf76c42fc502fefa0b244e8d3431c7588757ea133f44317a734eaca0fb2ddf552f3388726b94de197baa9505d9131c3acfe87151975d87d31276653a35f0d59fbf864525a51f0eaf88ee77b7ec78ea965f0d326c228c3210c42308863f757c691ea3bf9c494dbb4365dca806e77bca2ddd6a2fce91d63d2001c82293bec55bd086f8ab77adbb6248e57cd60df32543bcc484992503e897a82360a56bdcc68841ca1a44aebd22e478d04f836e3a16c87efb96b144a8fd0743d09b73336e4ff640243fb7e9d4467e6e2db7e1fe5c3abbdaad9ebae0d548fc3197f724ecde67e8645f73035fc215b16acc32e03bd1acf17137c3b986b356b34fc1915b1de6e2ba5928e73fba9089f2d4127eda5a4ce141b797ff4345b366e817f23ff118d16f0166e123c4d5f08a6b2e9ccd9f610cfc89cae3450b854dcf437388c236ea4d0ea6fdcc3996e541767b5c8981546093fcc1d248365b298e44b5f1e981d076defe24cf0e2fe8ade669e9c1a0c2a04313cf5c5e43c98688704132fa99be9b2922c4c80a2eadf1f1f5f19470792ef34c6a84fee7590c337ee75d5bd6aa74ec3ad06404c538a6374f10fed91346373d0069bb96309f6bab79778a1a96736c6cd8ac4c4c6f2d4fc6e50eb0b0855fbcc519c95f5252ec006f8ac6d5fdb3032e08502df65c445e2a26a85fb94d4a3b17a8b55b8f9e611c74ecb052225c31dfedceac95251b9a5a1605035618f2062aad7c84caad420a82ac575bf2d24e896d39d0b0c2528aefd7ebcc428aed1aa0669f984337265aa01a70b244178a6d7bdd03de1ce1ec66be7bad778c712dfd9cdb0f9b15fc1e99fcf13360664992f181910cdce91273bb59cd899463049fdb588b67305a6e0716328eb206f743cbdc2bbdb8fa15775e4a47273fb1a99ea5144abe3e3178e584ca56e7fe552bf2438c52176f0e2e4c7fb6f60c10929e782df79cf79f2d9be4d965d2a6051d3f09af1970fcb513aedd526673aeeffa7210d2f5e53d3e51190aad7a1cda334591264b4af518403fbf7b4f7adfa240e5abe4c057952a5233d400c9361402ff4ccbc63a9028f77f173781c991942a35c771768978a803e2f3edfda89f128141b9259511570f34d5de301a2aaaf0274174c57f45b8d8776d00021710978e2034b2c8ad416d6b83628d8b27bb9eb070906b5971187aab12e5c7aedd3070360b8b5751c7273e68b837f36df5b004f69f1c0a3ba5279dbac9b0b5361cf3abd9163973e0cc560ac408dce5b67e4e2d81760e1dd2d4ae0dd484255f881843fc646aa0c7f1fa22f09f7de007b3b4372c4a9d234699949a3f82c834eb831414951e91dd287d87b017aa6ad18f1d34aeeb0808e8b6fed41a33d30a7af5423627bb1caf390ab61f2eaea1ba19b05f2f98e4b2474668067d09706b0a2d115acf84b75d422a042a90b88a9b578de7c93de0779753a018fbf271219b4ebe65013a67ac0b3d3bd1f4a2794ec45bb5aafc6585d4ade96b50cb3c17e3984fd606ebdefacd907bf500b11047f4d1d0f71a86de27f4f5a43ff90a452b031de69f970a52adf7420309bbf76809af85d19487522c9041c7b76f850da75d990d3da62831d8f94175d412b4b3bcaed85ed18f2deb5ff10e8411bd99d16a540ce7f46fac9e61ed10505fa8e1c1c79c5e14bfb525fc62f508126cc949baed32731e022c2cd2d0e334916a9e5278c251005d11b6819b7c242d584cb99f3fe1961b116523d6ff54fe4e05d29bc05ed1a6986ff5e0f0c404e64d47bdac1439d190ef9dde005c08ba8032020bdb8768a12b3d4f931c2bb6f5e3f7905c3f904c51cd7d108e17121acd724f2b4fa9a6a698ba45b21462f4eb08af23fd5bc6adc49f1ec856469455c664b03a15321990f857de28b5a23f00598242f5c3195c10952592f53d9c3c21cb56e8b651fbc99bc62665e6f4d14ea29649c376c0b213db9fecf04d135a747e842106f0a98d84f88b4a9f24bc067ac3d34d4ef013d20c0f382ac28a7f5889a8a0f198b8f69e5744d10e8c0a81ac5f2684dd89b091f59404f6916c52b79806ae3d66071c895a904c0d3b1d6c5e7ab1d7ab514bc0efb1577791d3054b99c88ce685444c6efe5a852f8388946b799417230ecad511ebf0b1eefa12c5f371252a4d5b8b8482ec94582ea2a142b5c469fcafa4451067dbdf1cd0271221284871d1d7613b05f73d921e063b93c9c0d265383e94ee519ab2c97e7ecb0e87ebe7ce4e7b9377a4820f5801954f8b1d8c8996527264a419653c7cd7f0aa1f3af16c4f67135acba4ff79ebdb4783adfc895b4bef6b4e4a543644ab9c25a1d6ec51980d95fd3df4b81749e1a46b3b8f2fb6fb6f7d38addb590f73351bfb8fd4e5bce9448d865012278149995306e69091080bf393ea0cdebb65d31fc57c1944055403aba9b330a2f209c42f156175fac1fa2ab18c80222b513febf470ed4ca7fe4c17d921481edc371a9395385caa112d0c2329ec39394d15dbaa16dd6af219b3a5a52ea37f7106f166f3ebc79dc9f8989a1b87ab6e9f63959c57ed1b7991c1e4de52c32b17b3301f6e48177cf4a474c657014f77b6fe4a18a5492642878a4f20ef099f7cf97cd1c818e140a907ea1f4ee9c5ee38f4a4c0143d406a891b157e8a9639eefad59b04fc10f481461b59545552ab95219f7b5b75479b8de24f4643aaf13ee7f0901121f9f55ecc359b1bd7a6ae72d2f026c20786fd2b08bc6c6415d26c98d53cd133de4f970766c0aa9124dccc0d1fa0e820d7e7a8fd830278cb09e7cc7588c7b57be21e8a9cacb134f41c9359dfcc1fb23a11aa7873c8f436816231fb07a9dbe657624ca0b89164d03523acf88a2c29d7498201db09e2382f79538e3e48e0a15c0245055c33c8ce366958762641496cc1fa10cfddf7a7b74f54dd4cd78fbb9bdba420e09381a6a99bbd57e948028ae0204bd562145877b44492c55ffd6f606373fd3615f72da6d457bd496b61c84d7e7aaad8256def125f5b210d026b4e0de4cc7c8aa231b54d16751715749faedafa900ed6b5f85f211cfe367d5bc0f743816457483aae7d24d0b7a0d183bd0698fb4e009c4749b3fad5008f3ff900f5f0205563261f64637bf39e821b5c9532c3b994f4a4ce5a186ccad858c119053afcbc9e2ad17ca914c5289981aa19c30273f6ae5cc1c111b703dd369eba77c87f164e5a38a2f7b387f9378b22d94a3037a4ee554d754b6d4b026058245c2ab62aafc607737c0474241293b4e254a74da54d2306cb159060258beb2b1cd1e6b2fcacae14e32ec9b70c9d80fca55dccca4867eb8f50ecf3582c6250693a26b1d982bb9f8924488f0aceab4a3bb8d9fb745e70722ab7f2d24b0d2a6fc1994767a25f42c03daca7220231fcbfb5126caeff008d9041ac93a20f7689875247ac3a236193821ca6849fb6792a81e04abde66788b312647aa8a267ec5124a32c2b999b17e88be4123e5fcbddda4f4fbcca7c8cd96649604fd8878ada66a35c1088249d74de7e29af6613346ce81742c01dbcdfdeaa8eadaa5664ddd54a840eef48c98fb84606f7424a2dd7a048db0c656f146ca3b8633456ed9994c5ddf0701c94712102d0aaa7b30417e1caecd5ec9da8c74f6b3045b61bb61fee22f9a78ea0fadd9c4ca5fcf364709813a969a2effbfb4292bb82052f229da15591a5be831fd29ef285e74f1b69d573fb6ef32b27cf6d035ead9763b71e884ddc45faa7649d20b7acca24b64b51302d51bf59d806d802cabbae1c6b9a2cd5210a4514136cba898c2c9297e1a844ca461c4f78e40f3a02639664738f535b66aa79eb09a954a8a38d88a4d88e6f20f967452e6a6dc217909c12e90480b5e5ddcb9dbdb3f31608ad42e335906664db737d7476bb182080fa261824cdca24247a8f7ff2c388a1aa7a76fac6c35d94eae6fecf5ecdb234651d7376cbc68ab02daf08012bb01f543610d3e82d3aed0f943349350cf9c48aae15a1d604b03d39072cc8ab88965bc67012ad743422482ccf29672070b8937b6790777a90fecdcd72c42e32c91ca60f477d12125f1124651cad19d449718b0902c7730f4d7b93f2d162a01115d4fd24afab728d04fa0e287bddf3b064eb0e67296ead5a8a880e543a2647c03f6042d69ae6f2abf79bad5bc55f733c867fb49ac810ed68ee6ed6f1795a626945b9cdd821522e50b5ac5b5bb5a5b0b314a6fc857ca261a071c585c7be0f0b02bd2cbb6e1885bf07b283c072b3dd0c96bf271fd036326e2386d937083ef6e7d743356d71a61eb1a134743312fa1aefa9c05913c12c8a67b723a6e6ea0933a764144ad5070682607b9c48b21ce07fee7fb1e80d554b8efc2f7a3730c117f86a3da6378d72b5a34fd7e2218f81ae38d5ba08d476a4025baf514664b065545b8eff16efbd3c2e4085409b6dd70fd0758d709cd25087f0691fd62f02c8d74f7d2aec82bee79fe6ffe7e26d779603a2d841ac0e7a6a5e63442a6471157faffb8ed83a02e80b45fb467e8e9e3a0a917768d8f531a50476f6c514f1cb8ab0d897aad57406582423795e0f0f768ee387822774244c045314eb34f7b10f19cae5d063d263bf5116db492ec80d14f1be1f8a46683592dc37d744a9c4682ba75e4eb5fd9467a17e8550950ac3417db52f0c436d7ff5feb97f0c29995af0e0af20693b411786a8b83a9725c3f0676de338ccb9ae9072891bb5f585a8d19ddd3e4a582840a3473e78547fac8de1a65d05f0b58b8b6c11a571114214195358f1d870858a29e346c2e1f18a477182ef74e40fe77de9e736460942f365e7126297d721a70bc6cc3190f457f07d8750f9a1d7f09e85158418a73426d8bd02f6bcbc9c88669c2152cbedf556e416c408fd314e253dd3d7aeb216fee4fdd41dc764c012791fb0f956892696d826fd21abdbacf0489f0769aec8367ec6ba6dd9c116267e724d4f964f75d17dc20041c5ad47a8aa70c55c7da34cf1dab7e23f65c9ce3e9a278df335ffddc3bb2bb2a2982d0db6eaf4a28774bee745d12739097479b8b22698c909b5e1accebac08669de5cc994c15cea9cfa1920064f5c728f59fc2ee16b1c6477c17fdb5c121902494347138421e3c6e7ef970f12ea9a957e666e4264acf992bed174d16b56a04e2213601a0599dff02cffd410a83e3d49d29cf0078986cc5e3d02316ff9c1f8bab0a325ae0b8f16147db4be5bf1916a9bf37e05c7063c969b51480d1df9b60f7c7fbeaafd713cd8f0088febc676ae5c88dcef3ed1226d7f5a114bc3a99cd8921935ac40015c109ed42a41cec6487204b4281041b220d1dbfaf26ce5f6abce70700d36c1e4927a6a35295c0034c95b2dafeceeb02056fd3a8d35d25dfd74f69a3918a8f8a2c53cdf2c1750af434ef331c6d172c2340fac35feb3a501d53b268ccd5fca41fb334cb7d97b01f4f09146edea4f75505c8dd51b5f56116eea7a21f4cc59ab58948d37ae172037bfddc7c9d8efd49f64f0e810382bd2578416c29aebe45979bdfc34a48e254e3d0ff9e560c6abeb5d6a1eaedcf26cfcbf30c056700fc8b76cb25241c8345a564ab3d0c94f5e2ec231ac3cf6e267753480ee785ceae905999300447c221e7da2f8581e8b36daa9c1fc3cc813be962c8b6ba34052649f25d0a5c940ec7f241f1f5e5218c163b290b12e2be3628540f12854749879431f78be177cf441cdf8f2f71683c417d1ee6876cf5a53971f4f830c7eafe1185037a1542c85c7991c34b642b23d53a6c83d118290e7f5fd3b700ddcf0d426280e3958d0cdda5e1e66abfab3d8f5fe21d6ffee9354df68511949727be6cb168ee2d570e4e4fde815dd138146a5b9c43412f1d8910f8a555d92dcf61d248eeefeec7932793b99dd3a1097f97f49de1d392712a133b367abc08df13f74270efc6e1595e39cd3e3ec2aadfa5fcdebee126d328960eb2e9967ce90335009251052ebee8b5e2a707dc0447c79f6a5c5520270cad8b59758bcf8c9e30bc0d21ed6945d55479a73fa53dd035b5b0b2597033d139bdce208a9bc3b0b9474c60dd295ac4c5873fbe0317c1ea10044d54ee61e1824be0ad1ff22d0a21ead35fbb150ad9323388cd0fcf0daf0be1cc36dac5a81e43ad99f5698365363eef9214d8dd4f1373bd51c4a78f2e9af9f55b6e813e4ce3226adf7b257e17d47457231739c33fc3d23505135f7bdbc341803cf0d7ec6367e3a21d3e45e6db61a84224175c862330d83bcc72db29ecad042c62ab460d40081bdb4874f3cec670ebdc6df000a81d37d9118853909f5194348af3f073b7ab69749f9babf5bbadf22ace64023880d5b10f7da0f301bb30ea34d475187bc766401fd0bf78b54f4d3c1b205289083b21e41e5580ba6eb26a4941c9f265368405a80877e26c7aebc8c6580c58a963a83352ab226c909c8fac33b4edb32218406b541302a0ea15fae76e588dbfeebf2c10f68afa3145988aa52e9900a27a0eb8d6fc76a9ef8a7c2adc13775de00cc93da8b585e89834b774d365c6195970732c3f923f80b3a296d09fa8b0258027e1513654cd56663286c12e9a5d37db109e58aa6584601266d4a43fcac98a1b9fd6c62509844892bb73191cb48760010b04ed4e04f19d9af9350610957ad5395d36a00e105c2d3cbd1c8b4df17a91993199f5b5b9c8ec72ac9fdf08fb3b76873615e937ed44dd09c4b72ca9715af858c95ba37c695bce6ef201babe01f11aaa0ee8658d1797a3c86a5f6ddf900acd909930cfb3f79b727b5b4ee07500e22cb66652bdfacedcb0bc9b3d3b8c4c9a65eed14a03208a586d60a6850d91e9611b7bebfbec75bd08d98722a41725b228db61d63d01b0acdd69b34b60668758b3be37fe7710989f181f51e95ce5e2a21ef91953355758ef4059a57e5d13e6cdaf360ace99491d3efedcdad2e09ce0dd4758e2f6f11e15f509da3210f3f294","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
