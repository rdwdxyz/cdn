<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4016fcda31bb1e038ec8133909307335b65783ab808c83e12db0571d070faca163b832a50a4ac0357f5de4827d0c7ab11ad583517baf296104f735c4848dd41efbd6efdaa86a8c6a5078874a39abb2a46d3d2a38191aaae33dfe3a86ea053d3830b6c7ce1bac4915912db1c6fbc8d871955aee69b4d1fb1ccc9808a5d2b9c245a57fd06797fc211ae5c49333ff8c867b7ebc480ae3c276664c0acb8606b5e48e3622dcde05ceed35d07f2fcd35eec28a2424a2932bb73682eff2a65fdea48ef68cc9e779f35223d485e7f8330620108917d21acb200a9bb0e203b7d21084796d1fb15d85d9afa474c3f47c59220b04dfe0aa850bb35736eb440822cb20795867d376792934aae1c96f1762d4481a238cc6a07171f7d0a30309f3a273c620769a96dd88ee8bfc44efcd307436e854a89f665050b7cfca5f4f67eaf96d01c86b7d69cb8228879620882a85930ac088d1d0c1ab95e0b6a9b0c2ebfd9a7ec4719a4d7303daddc1ef82bafe21dbcc221266f3495db271092d59b512a7b2feb1bb71687d760a47cc8e5851f976f87ca4ad1f10ece92d66c928eadb40e8ca923dfd203194277b67415736ab2eb4bd521f57395de2644c05cc5a263288b79cf68bef452a8624f2eaa5e1029a29da77ef85bbde3be9b5f61dc87cd891e8dd488bcf17c31d0db34ca3755fa9f3b75ec50810abae77286123df2a65b99874250942ef7de38ffdad31c8b4323cc8859d7dc6ae4a3db088a86d7cffdc9af27ed05fd97911f2d52ca13b056e56fc73a0fcf5e2ebb55ce2eb2d700299538bcdf586691d8f43e231d1a7336ec226b50149655f68878fdb99a92d7a6df6b9f8a3c8b75c1be2bd922582f9b772f3f51cef4134b2835faef021aeef7b8927ff45c0b4fa05158a6f002dff6b08a81a66df9d14cf8e7fe47a1698a0246bdf87c42b3159dee0a0b336c8cf9e59a7ec38ccc5ad36eba4c961b09dc22d40d0edc6a50671c441be99986eff77e41788ce85a88020070d484b0c14efa3b0e87e54e9fe2d63714ac78b77b376a95ffd05739cad96a22f61901d0c60dc1421dbc89e046d266d6c0b2fe198cd5c99cb97c93415bf132ce03bfed98359d2474f09ad91e78cb6900650ad5bf844c30179406c8bb98c85367892f6d5547afaf14559595675ae5c4953429b6275d25052393dbf84e77d17131c077a4e9628a8df38105f4ea70e23c04ff1b334c08d111efed9aec110b099480926eccc72ae775f2cb8ea70f156730397b880e638b68b5101498ea5882246702a55ce0926b36c557d185de6c1db947bda6aee39a05a5f53d273c50bd8955b75f614442af25f68cb231ed86e04c82402767124d1d1f7a9a478c4c99fd87a1d72ce0beef82db75b13c6b2db34363066d88306552eddc018230fd354e0289c0b4f66cfecb436f804f1f314d62e0a529a6854d74e2d9841c1616eabecd3f524875544bf8f5ad9e8ce1e9fafe9a9fe70e87bbefbbb1ea19b5b4f7ef8affa1aa2200e2964919647056b97f5622925152b2a44ad8b465be7f77aad75382274cc73c50923a1c8a391183ba1ada3059f8531806eed80f98b90abb90f3676c7c1cfffe6699149f2822fe8cebea5c1bc45f54673b7fdaa61886241ece1c825620159aa30bbc32416dc796b63d0cdcc9045d6d219e67710fde6aa8a672aa40ad27ddd79a7160f5a5ed9617bd02fdd20569924f952caf9499fca895c15463f6b791ff5a6cba304207dbf0860525ae4ce9b39f9b63cb564cc9b87d1c441bcbc294b6a0338f91b904c6271394e9bc612a41bf6a9b109b74d8339a2bcb400c333e8cef4aac8737ae5a51fdba017a34230ec3db9a130056378c0bbcb39eb934543b6b4bc7c898260c07aed4c49708572cb1a56ed9b1f77706d4143b04da285ef440f1ae833f9e266f16eb604b0ebea47d50cddbe33a34db35b4307ac17a4dbd173cbf8937af9372916a289c1bb72312f33eb636653f1531226d514d6a73d34b65ec3fc148a9f29bf0920c56e070905169b50961c6eed1516bfa9a351b2251b2282bfae12322fa5a039497534e233460bdc6af6ca8da7fea788f368efd2263339e10c26efd049e7829b72345c18ac086d8563d00aa69bcf07c2aeac3a802565090cf67c1f48d7c26360ee42fbe4dbaced72ffa9900d2a4dccf8c2a1919c54f6f51bdd337bfa7a9c0e3942fce3627f6e168e5cc1a3a458c15792dae9d5cf13ca62a7acbe0fdd56d7893cc720c930451fb45d50bea7d2de39c0ca586a88aa1a5319dc56307603d3dcdb664dd5c688cc3003b67f2c8e647b1df0377c9185349f2824b4b4eea1e7b2613d60d0e13e5554ebb749413d40d335da851fd7c874bfe2e39f88737ebc18f13670f3cd405b674249b109d8e3b52bbbb2384fc60949fd2e27f7caf9dea9f1257c434e7beff69de266a17b294b34e5403d88da45d1db5be361a37d7d91f2e064e7a9368d9f4f39ce87bd232d88ad392344b6b3eb878a1db3a8e11852077f735ca675ca1d49168c4546ace03618e20f130bf1b6876ae6cc67ecee6dc60ffd63ba6c0c681789cd18f1e451e4984f3d2f8b9f9be5255b344f2805f11642233df84a4be3dd92354b6920691d54fc41aceb32ad0aba45e91b5d5ac41a6f24707f7c595d78345958a006791de166a7f8470ef42c30c500806d799239b6ed1513714f9337f5ecd0c4198858714e9e55c8430420bf905a149605a152ca6411d6593979689c0c9de0cf65360429a136a31eb2397cdf423dbe6c7c11cf3bd2ff2690a9f2a094472c0c19f7dfdc63cbfff7de6459637d3f97b0de2e8980d3208d125bd8578e9be0b768c46ed0e199acd6c8d35cfb16460ee7f9f33c45be489558893e1f37a031d150098afec0294c138eb5ef3d9cafab92e2283b970083075eba4f1a0f1d75ed37a6d223abec0543d774fd205802ff71885c17b1cb440ffa7018393b2d1b34ff157e8e430deb39c588dcb07be9f08ded999ccfe6a46ee3bce855e914fca54f4321024dd9868b23f3e33de7e0afa6ba260752a66ba18c76080039653dbed2746ee2eee0869236c870c2dcd2b7683f57216c2a324b7355df843cbc9eb3e1b6c6bffdb735f27335bee71d60fd9c60730f51278145c4c9a0394b37785287b3a83661e3d4c0d0d09f2bd2f79e2abd02384e80874c6d8c417a3b4c6c2e6173015b120f5bff0d555cb44e454628184c110c5c9eda005a10148246612c534430e60bfd02657fbb8a6d689396705e79b5b83963d33f8cf11f5be1aaefa1c28155af1522c511bae5cf93b0d3f57874697700d6b017f6de74bb9b8100fe4e9214d113882cd564479ead6caf33ee82a7c150a5679ca19b0d60d5f3822fc2bafec4a2a72f35368789d8d88f8593c5d2e9c988c03cd2c1136d3b4908adfb801741b121487fe204f43c23f304046e632e8bae06c40e9dac5de7f26559f93ea63bed1dc68b0defdbdb1d04e936f65ac4092eac9a02be6de7f863ce4f55b2ddf11279619ea5e324556e7b6aa78a104bc5d7411d2217fc178e9899e13f5fee36bf709a31c6e1489e36e4fb233db6daba08f8707b22a93722a8ff8aff889dc847a0a770becc2a85a9934429053cd3ac772b2b334adabe088a697e26a81ece506f40b506d8765244e2633b709bdb922eb2547c3efcb87b20c50faacae2fe6d61030763ca0ae8a9744d37baad491fbce7822d30e27674207bc38c6e3644777c6717baf096f76cdcedee46a890376471d0b016ba78a962b65c015893b045d94ef885f4c60d7f180ad7279ba5a9d24b3a10abbd44acc743a316cc5198e3f161832e969a6ec9ed4f3ef04d90aa7e4b93bda43a7729e9e3fee6fdd581f834353afec9a0d8ebac24c8751ad7b69fe02745893912021c340ed598332c31ee485e4bd54f456342f72f74e1b739beb89ff33f0676fa0f0ad4a8f0a44420987ad5e5bf49b998b6f5fa040efb4dfbde8c14333273569460989a8b998645593661fe9627954a42c6d0aa1fece2efbe0e6e961b6096fe14d949de78ea1007e7b101f166d33450a2bfedbf0c82c2211afccef4d3a58c8c3e94cbe0b8b0c8721194cfa65248143e68b9e2ae7dd7ed01710406a89c0f102d0ceffb052ed34773d5e35984785620f2470b5208da0b26fdc9b42cfab5631726e4648d58a29a3c93453f690e7f3e5f4201b76761467dec253339378aa581662b0e4ee23056bcf3a0b5bdf9c3c0885b7967bf7bbeb50769f5a2fcf4c1903e03bb4182a24e921602a3919ecfd0492ae99daef52e662e9c02a69c7d5fd8599038022f0ad7c183e023de76aacc82f52a2f3a5a0b3491645386b2474ca7043ac4686af783ba98b536683f2d8adaf7153d147d5e3351f09b4bdaff5086f4322a1acb3f14fe09cf58e96ec1f59fe24612fc857f7d4856dff1d2d4518b1aa195a705721d6dc96c94ce8fe583e0fea3775f2ec9fa12ce3d57ca25fd2ca84c7e35a045c93339c820ffac3c261a4e2ed367f5c7ccc3a1d36a73cd19cf8dfd78cbe4a0c1144145f9e1577cfd572f69bacf505f26b7ad3240e0adc7e4333ad8e3b2d4f51b6d9f11e31c3456c83815cd3cbc25b8839329c6d8ac624494d580def3ec0d6c151f96a2bde5f6fd55a025e19570ced506cb0f968b5511a1bdc9be73f86fe7639eac45e546c978d5edc4362df51d31fd2daada4a370f0118e40ba3fd5cb5e33c3e929c2dbb62efe2d2e33e2f5efd88f225c531484362b451401e28795c10336c1c6dd3708ce36a05cc817d63d3125223b2e2a9247c0cc39a338a1a435e25e431a108f7f9deddf16b20d4c13147867b85b4a7506417839d97c5b560e7b7a1e62407a4f7ed6ccdfe1a850d1b8715d653b0108c1c6c6a235a7f026eb97a8c3fd973228172ff4c30c277315370cdbf9a4832c2fc87ebd8120a026349656cf437553964a0747f7b3ea57879d4268fec06d6f2de6c3533dca246b63f568f4bdf41a3766d3b2488686546e51799de2950b949184b28e627ab999746f74e94cbcef3d39ec29965806d348f58c84607b5c307f61660aff09f10668a570ce5abb394c1a60ede2b8caeecd63b0f9a3e8e3e915572217ebf0d5845ae1b2153331c5eefdfb1f4573423c7be82bb45029b5cd183c153eb04d5afda8bc632864316103aee007abe4b2d08f9fd93f478786b03f8c1e3b04de65d09e885c8557345d82d6e959ed5062950cac2927a4972bd1af4c134a0f4487943fffebb96f9ddeef1063cf5de85e755641a27be994a99f57163a373adbbc741c4faa484268680ccef52045be1a6b35a60cde3315414b13fc332f0e3275f59bf7b1220a8f41f226b2981bd3719610af7c0e79ea784a817e7ed63a83e673d773dc7a2d577c55d9fa9fe5051646c7b1fc24ac67616c7b8958c8b5bd8184591db0633b8551d342b5686655abb18258b9f74c64fce2e40c131344575730473de856eb04cf8dd64ed39735804d6f9c6b667f2fcdc6a2627f24755d3a8ac63b5ba7076873d1c9e2f9f496e8fffef9587e72b3d0ba69129151cacaae986479eaf5919ab0d304429a119c82a9f2a5b558b154dbce95ea27da37c1cfa34de809812fb6ef1289f0fb1bfd73474b1a33c86105ec559f156be2048b46b1b5362edd80709458e550cc7c3b53208eeed935047fa8744b13a7221002625c85cd2096c8f6c9d38ca8cff17561cfab11a8a79208ef0bdbe6b1c8ceddde7f71031b65ecfcf42f06c6f10fbfcfb1864056968e3bcb66ab8e9cf196bafe13a28030dbd1bd3bd7acd38e82ecfc4ba269a8719dd97ca8b99ded5632ca7b37c1a5adcaec2ea0b16b812eb85494824eceea1166ebe34e0fdb7e4e5bf118b3f1cf9dc444ec6277b9ac9a14e2f74fff74cc4bd20af482faa2d67e6ab681d34c9634b514fb1c6fb1a806389cf16643efa15e5ace60238ad238cfb809a6c2be8af7b28b0b8602ad71cc3d0f984785c752400fdb6f79baf03f855601ae093fa285206d6e5f599cd18fd4912960d3601fccb416683ac208393958993e7fa0e8089fc20c6435bfa9f288357365095b783856f2fba9ae54ed9742a5cfd5cf839e0ca1643071bb0058ac41670980246c0ec3996152d52ea5ab47610eabf4933d9e3b3b4dc4d921c015a41d4579690a8241162e34374112ef51a88d8e3b00941176f90e7562bda8c86d0b331d5b463276c0980b9ce92b0654582c294c6c451869a5ca537099357dd1d9ee5e576ab65a955d87b8b8bdd7b418bbc205d6d8863cf5f18aca4b944f713065b918680446c85a7f05f219794f8e4b89896765a352b41db92e9357948969c4e58527924e43f1021414101bdef90507ae138098a11cac5bd3c3171e074923cdf0ece0a7b47eccd5ae619cdbd537cb56a33b00bbfc370a85330422afe9f1333e19b80066660355e8ef7fad9c171b8fb8d55d198a3bb57ca2d5693b41edf8ed19952804ebd42e2b68f44ef5c24c17aa5b88227adfbf1db98825adeb0dad57897e40b66aa0ca573ff76a6770edfe8da699f00f2f0ac986cd35b1f72f2f3eb468146b6c883be84554a0f015154b73d731ce88da073c4d9aaf1fd378774c2cc6e13013bb71a075249d4103d72155d3d47035976a56818e91653b90c36e4e021073ceedc7b37cfb2759d0c7f1aa96a0c1bab1816fe97f8b76a48cb544c895bfe465dc43c3ff510719aafacee0b191537f643d521d60643e04b6555c6e08d0951f5896905fd905c0d2745b62f1efd48f798bf2f2de8500c21fcb722516bca46fee47e1c66797a372b5f7a71c9093d3184fc0dbc8424a6e6cd45ef10b6fcb6362a7c0bae37781c638fb1523a56ed6d95d374e326eb64e982d937bc4c66ef3eff21038d963d388eb3c9026627e34bcff7651e5ff9cee437890c737e5ab8b9df153c09ace9cb6b8a02b783d8d6682ac03845a0e0477df4cde1694719ca395b00b84d523a3106bcb79ad04a5a6ecdd7cbee9089c29b8bb974fd91bfcef6d87d4a481e6fc864018f28056f8fc6073a2fb75fc97e1c1963a3b3830ae89b71a63b1cdf147c07034a6c3e310662dfb052e764353b19bd7550f35568d97fb87539652bb588ad61eb1e0b8663ee90fd02bd88100778e459e889b10bf5c7b1ee11b976f4a2380c47ee91a4878eda2fefcc6aeb9a94f492933dd5ac68b77886dc94db8420edab88fbf6c3844c29a7459d694a6b706ea508569cbf4365f725cafcbfcb9b69bee3b4e1ef8dc8fd41918c0dd79fc3277dcec9f2b36abcc953d192469fbac1ffa27b839214fe970a4f33e9fab4baaf8ac3ba20a9d38322af9f8477a136e06fd9584ee53845d1d14c75131c5bfcde3aa62f891adb1e39fe51c9437e21b6acb5bf615e574b5c520caeb94a26d5352cfe8d3a92d27669ffd90e035d63f8409299ec5d26b8391e56c84973ee033109a7a2330226dc38716ba20ae8303b1542167c2cf1de3ccda045b8a9f458efe07950121a7c7767b3c6a8e0fb4c9a6213f55961cc6a3b876589235f4529b5253d596c0f7e918179d5b75c833e96f5257613c147d94e1083a38cab41c0b593baa5d001f5d6b0042fec7d41db836ffd093bd608dabf2358acd5048756dc3edc64b4281b67c1fc0f7f03ca517aa6c44aac885a134031d4df514aa36556f2f6c18a6be64b7af21dff4e141d774d4f356526ec7dabee3f3f8558e10409a466a86f7e1517672256bb6c98c770d582457b3376d09fab6d9b402b58d7c89d74cfbe9888c75cae6b94a30f3d05f26ab4acff6bb6bc4a0da484274b7826255055c8d585cbdab6a16fe39091ee390b17baa90e22e4913f5288dc180d9474cccd711a00c6ed64624d6e79612d542f6ae238b5d77bdd948acb3c3d1602c04292e4309e4ba83fdc4cddbccf63743c83b8e496a17aed721569f5df0ab000bdbdf7bfbd42f39af1d0006c4dc9515a5c36c967dbb867951ab72f1fa060eaaa5d0633536447c719d6219c4c6e59d52faaff9b86fc4246317b489c95ef7a274fb3f1d88beb5a49aac6dfcbaba6ae752c0320844f8eafcdcf0fc36fcd353c4c6abc1650073b201d27a603febe269d3b1645ea14bc1ac328414097fde6f93f83debd4764490198291332bd113309f2ed3201268f509362a9adfc9b702b01c407f0fadcf242d040ddf918430d387114d952072f19b8cc20a5809d4fb3161914c2157c08eff4da8faacd75970c75eccca64a782b694b43a85ce05b96a86e2af9b47c508e97cde3ddf86a5afda55a567a31e279087a69e1fe227f88424e62c950b6fbad93ef76a7f467c9684a417a82e5f36f6108efb6bd3c890f1683b4a6e25cbe8872ac1d2a7a449accdc9dea920264aaab28173b80c29a65acee2aedbde343c2771be42d4ca76db39f5585264028d0d0e692f221b099b746f6743624fabd88e31f2b6ef9336b4992de14acd6a4b6026288f97e47d6f2905f05e7e39d67eedd21795f64d32f1d0af52b61202fb00019be7b649880c436fe2583886aa985c9e5913336d663e89c4132abd3bf4d6f70ae08d97a61b02995a5a1e18d2c2f02c955bb4b430dacb30cd93195d1daec5d0c19b18b506916c4150f3f772a3e206a9e20359cee0003daa1c8a2c94c4c364ab3faee6e23c4609a2c96b5776c8e366c5d8bd186f5974d46c4eae77f2f0839937c9944f9a8b2d5518dc51ec9c7914e79701ad89489c7c4cd6c566ab89bb27309baa350d0dcf69293e5d42dc7283b30cb98cdea7f2b329adab87710948d1250687665c4a52085b78f1af6ad69b3f3c261246ff67820c6e01fee9f719282483ee86472e18368fe78546ecc05021606e3beb843c6a6aae044df8f6e2c965dcdf53664cbf68f5be8aaeecd90857db12efcd1003096156c5f35cf60bf7972e30676bfb7ec28470eb980cb7589e5517aa1e4e59da276f75c2a8555b25535b40a21ddae514443e9b84635e2348114d30674542ad0e23765fdb0eaf24ae43fbd2c63e6e79a74f4755e9f48c1101884b847a998fcfd25ca105b74900ca82778dbd3cd9bb056c6629eb39373d3de838a608e3c5b150c25c5c787c64eb4e22e03c258852d9e16c0b8ec2e7fd2d0ed0bef06d3b9f430dae030d4fd6ae0a09fc47c5285ef04f3e490c57deb601a9e3ad775ac7770905b6339b882fed8cc004e98c377e4b3b2474233a95e4189927d797b196933abbf730f09a9abca3db2ac0ca69925bbdcab20505602ff7f0aef4c9d7b77f5598203c3c4b66401543b423c860ec33f76704cea9915ed514fa6aef23ccdc05c828ce3bf9a4da53ce2feb53f868aabf5563c6498c6d6db8c3e7132c529cc53604f9743d719c777079367dddc665322239893442c3e1c367f62a9ec3b035786eaf300cfb76c64319e0ffd4d72acc06a0bf1b625d6a07c2e107423f275d8599157e4f66b7fe88e2b9736e9029d562e699a8102c7a153df98bc94ae427c22d10e583e2d30775a265b5da7620fed44cf8b55342ab135d4e004311b7ca23cad0260e4813f9f0589feb315468fc9572f983819295c32eeb5dc2f3089bebe4c0faa82ade173de98f4d0952007ee33c44ba130fe5ce8b5478888e899e5a0d709b1419c1e1f4692e6ec4b2d1eb0dd084665b12f6de1904af2d6b1167c6a7a78996073961e25a8b26b56293c7f68e02b5e1d23708a45e78177cc4d86699c84df50f07ff376a427710cefd612c336026bd27a5347e5a4ac5f4a96fc1cadd43fdaa887690cf60a8f3691e31d772e472ccb96f68d3a035909c7bbe40849f8a678335d5bc15809caccee13bb73fed39e7ca6d145f991a210d13fa6792ccdcfe6db713f83b09ab893913b01e2e8a335813c3f4cf2b5a41523fcaebfca30b5aad953377f466a6b0871c2a9217141daa493e1614d1569d9d564a4d26af4f523de40c1eac5516124d040f581dfbdf90621f1543b87105c58019d2757349d893490b010139198b40040fb67f407f9f95775e010c0975a0b8b4d64c597050c3ba9b4f5ee1aaa0c0133718e025fb8468fac14bd3b8596be2463843797ba7a22f01958ab4f3940cec3d5a6cf157973c1a56783d2b729df939d6bafaeb2255b5fb0d06653113b90992ca4eea2f2814479274e71dcced01d17adcacedc9d2917a530afd7afd894511dc909b02f98890fea895bc2c78b01e62fd77be533944d1ef445347f73567a3b34661d75ec68afc1305674037b316b2199ff3d7e15af73bef2613b7e5b98a50021b6cb818269f5708f58ded419aeb4704fcc70ff2d8c8f7e3cb81e11ad18a47e89484ddb96e0632a59ab7fa4bbeb1d1e8ad2ec0ec56f2b7d6d41ad822364943ff3f2b1b0927894ef69e5e1b4c5d182aefd5d32962a96b2a1472dd83ea904e4ec11b036906156b76855275ad6e2e5822c27037a848bb87c8cae87567e3882b3cf643d2bfe97bfb4190e5e9076255eedf88764ee29c2d682526b448cb603d97fb4e6671b62c21c212eddfdcaffff0c925a0ea080448989f409b1e560b689040a10b8569187481b9a9805afa724b24a5be16d127a4cb0e4db8d51414e7430dc536d56a5c78521d0f4632b5b783a20cb6c38ae6dde54796831b2d6e818296d6c7d329dccfecfdf89e16fcc388147ee7a08fc408cd57ad24c28dacd3fac349cdeb541e33ad4ac2937453081ac5897b6338fdf535da13676afdc59041be65c965542a0537ce1332c6efc2fb55f1f07b7b0ad762deb13d17d38d1a4b2ec5fa8d81ac1092139fc9212f1cdd6e63675b96c7d5b73567a97ca562ffb5b2bbbcb53d92df1ee0050cb5a243d380f9831eccbb9d67e413b292f42a1c48b09ee6831e6844c1e9ebaa1e9695ac3277cb8f30831ab8c9bdb7697b91bc893d4a52e83b71b784d6f8044633521567cd5ecb426d6eb6efafc457ba9fe88d28da1dccf4c0a332521c67122c6ca2c5ced31c00e0d859c11524deb2dbf74d24331f73f3cb5eff6bdf28eed351a0ed40a3b6fb5c287ede511194e1edd8d9dc8c35932c98e833eb233e8d37048ccec552176f10221f27b967b916e3807d6db78a34208f1b04f2c5871bdf07d7ca2bb76095a8e2257e7b788b38d8e44f90115bd8fec6aa71e9390124f50bfae529887d3490f2393fe3e7ff222de39f52b80a841d2c4a4ad50a13fecb697e4718289d0559cdc0f16697f19adf4e3b4b89568e796348441c60b291658dabbb96c9f89536026d9e40c3f6f22e783e892c84ed7c0d1463ce096dfe16eb937a9924352020751eca181cb107b519f81cc23610b5befbcb136abf0205e35598c1b5985ad2067b977c3d95467399459f07b0f7de974ed00896264dd1938bf206c114f89eab67ef0505819ebab03cc018b0362ea6d616bac815d9559470f4000b5b99c75712d95f5684044dbae56d438b1716074037d04756dde9f7cd34db5f70b150dec3566fd0919e65c3f2aa432dafc322c6e6e9ccd445b2f3a13ef103355fcd368a71148e759d968a39b73b1a608461c0ca622d41ba2f9c8ccdf2b11bbf08841623d1be4b00e6f66af891c9da129ebc9ea582ea59b74e6bc07cd0f9ab02eff657938ea5946f6d21fdf0269bbea2125dd81081bcd01529b31d159e35726a494a01ebedd5f43571f8e06f46905a60192d9b31156bbac3a0e81ff9a94bbd46c0ab62b38438e9ea63d80cde2436d4a2dc88fb4627ecce711dd4d4c868f3f9e5784b5d007036fff8318a3d978a3d0df7593f4ed96983e507f773647bcece2d3b90f6243aa76b8b657ac4648e4654eb2572a93f8b21e52d12a647934bc81888c49ad5edff1d86603ad3ecb7fdff665bfdf2583bfa030a8ecb36f8ed74a590dc17f51bfed90c8dd3cf14fc52be462e097cfce4e7dfef4909e467745278650dec9f5019fda4b424bb36bd92e2fdcad6ffd83002e3ff71ff3ceb791d3823329651c07406a317b4ca324dc42e74a80e03503c6d7b167691a29e758aae894966005eb3b67327914899549afba3056f125f730e7afd6af1a85868215aa75986cc6f12dfc4986d4975d8d9f1d539a02e707e11e5e88ee0a86ee2650f2aecb597243c5742a907ae77604cddfb5ee748ebf32616dc839dbf9764aa9b88e9e9a04117d4618bbac0d630b9b7caf89ed80bd2566348f304300cf6ff374c6883d5f4a3c3635e853ab5961cb0bcfbc37fd36c19dbc2d5ce7df7f2f13b3d24974b769aa33cea040cecb8860b90ddbb7464ea93c3affda2260636dcf06b802816720c69b51a8b3aa79675bd6e4d8b16aae37b3d093e3c5d1fc0b846dfe6f284bb6a1a158bfebec319bb2b9956331ef46b818add126223b982496ab03544b9b42637a8b30ae9edcc920eef616ae2c09dc44ad684fd1f5d9df7209ea2b7f821433fb05e1e8c8f630c24817f38f6e670121a87e50c6844c78085438a7c796262f6b0b3073e6f05dc0d58be4f71d500b341bcae1785ca5a8ac9bbf7032f8d9df3b9ecf221a8dac430d947292e77a46c5677f95264e17d5985e575dbfec94f4662b77299c6e137840a8ebd20bbc36583eed136a7fbca18d6f65ab4e0d3a68f72ae55981ad01f68fc1053240da9b00a15c1d926c6131b160fb89d2f50ab55c30b28574b2694ea62d45661dcf1c8a56c6297dd7152e1eeb6f03731fb0c522e7ff7d127e128990b2d4c5f9b136a644a3af8913418d353cf98825ce27d978d53688551ebca953d2631f241f1ada79c05a2536797f85fa450118c571cc571ccfe27807a7fe4775ad86323a3bcd125df7e03335dd0c04cde9cc7e53c01245386f8046c3977507258b80c147707ab8605eeaf2ecd177293fff242c9ca2e5af68b8e17de7ce7a0aa9b0c539653a707de4edd05883e1e895cdca7b9b6b34e4e4fef3f9e6441f2e45f7d0a8a609cf0c504bbe8330337962db6ceeae250d27a1f70201d6f887bfb7c03248d7d7ecc8f46c87f5b0a10c51c346bba86f7313f7e67eb4462a67d8cdf77ccbe5c36f15e527bc319967d41ff1dc7cd583eebeb6d45e7f9b27515f957097cfa62c0682eb94390e0e175e4cfe2526e4c20ccdc5adae087a6589af47a7ac2e6191b28566587d85a13628c3e85a2ccc4e23414e38b89fa373a807ca1aa32b777d61799f87eaca8046ef233c417b53101efc9c99d28d9073c02ca23730d176be5f4f70d95f1ab14688bd41e59c605cac1cdfc0f53c3d74cf045086d0b3ca3f21a689e4323fb9abe00237f6647d9cc568e48f49c2f4b3e2cdfaacf551cc7205fcffe5d83783f5998ea7e48cd644b087da677a0f2534036333b67f18dca439b6e67d32affcc1aaa63f5cf569eeda737d56367889b100ab60117a63e3b11a4eed4aa9f4dcc8c72051fd86cc0e2d996f41307a0ad2a0fdfeaeb472a6965374dc4462d03cafba55403b296986041b70822c0676e4753dda90863d34aa40b670a73f7d28bea35fd4c89886128735e67f929c4a7e4b9493c2860d4c524a5cf246a1d0f1a2894ab9a369f5d290225dc2edbcfc7ebc7cf9899e161fd0add38117a95fc568b7df7f8672be1baf215aad7d22b93070672d0cb667ac3ae9992f5d3c2e1d48b91e1c8b47ffe4590665e73195dc86cca315f13e914a4d3bd147c3ec56bca17cd545e662c5a6ed1ce770a73d8e918d20a07a7656e489b4488a81ac57b1e97eaf91e51e5c6d7f18753a474dc12adac5af55828353ba82a870a158dccf23c0b31da40fd61a011ac80bc000801fbd13cc0e0c91a44b61ec23a717fed53406d247dbd8f8d7e98ba01bd973483aad77be47ea16e016cf51f1d2e75eae7a4d16dcf93232d3100e9cad4004e269698551d99b2ae945e2402cd407b130033283d2971d620330ce459347ddf45ae6ff069e762b6b022f7c102ce8ad4f91b7f1e574ef25fbd41bb1d897a18008220816f27bec3373dbb89d2594404f9f37e3973ea870ba1299d77941d49790b5b7156c5f220629eecd7303917aa08780b1bc633272e80b54a22fd31bf86e7afe64f0fbace7bdbdfb7d7a83524b21294adcd02cbadfb1dd5042feb887528edf9439fab336ffec567e0a8b7379de646205a4fe836c965f7c13b196923cf79d7456deb566c7c421428e4d698d09d91f8b0f86df1e87165942ca3f7397ad2d5e3e11f99f05b070af7e50aedbc280c518cba6d90a8741c680663654a73c287751970f271e42684c749510d96b2f6cde88aa48f4482c6a9d79cc6189178f986343507a11de12f4821715de486013b3cf3f1ece20727b1e34934195ef4e19c2350e09eb9cd3606b55fac04cb9e1ff4c4e4264fc4f6678d6ead862b09ebc4b7b6f6ac14d2868782df9fe43fcacf95e10ee2a3462116628a02ab9be5e07bbd77e2632c797d02068737a3881ca0277aea37e44383bfb5e31407ea6db2752d07e9f5062ad328b05b9cf4f53b81aa4a6a38ce4daeff92706138a5e3e963cf68fbf783559cbfdd8672be74a49648f5a858a8d5f4136bb1935ee7855d0a01c174a335f73e31f96a44e475a4f44bb2e8b4fd3d44e2af20800d493fc7aa9be9549e59cc5a63641f2855a2cd101edda036a0899b62795746db7a67a1136955f461a0f33690353987c2a068430298e38ee2e68e9bad8843fc8abe52423860777a21144bf5ef0721607707704ff229f63fc6cd76d6a65799ff49176c4e61f2d46f85782192a4b0f653942ac08c985ccf1054b700a523f4eb4141d355177bed55e46d72f43c2ef0b4a57c327c5bd6204f23a6701996cf295e7f629f50b0c3b2470cad6c70e18598ec6588be1f4634861700297190e93e9c70d24b146f808147b61b5d6d251312f2f1183603aa21d74fdc86a5802872d29bef0178c9a946efb5fccde6f194cb7cb14fa52a771d2428121ea2680a434e3fa2c8bfcb88366c6b92a549a741e3386cee30d83a548a7ce0c2ac6062ebf5e639ae62a5d1c2c3bad687f6bafd5d7bbf5767dfb599f855b2773d51ce1f5594f8479443215b1a80016b438cfd666efba921e72623033a593ed4cc9e62c585e700e9642c8f40cb4c4cae0a700b66c1205ba20c32d7af058496cde5f669c56216c4ea8e0ce4eed349eaffcce7f063e8d77b8b187d902565655bea1da5f7df1ebdd9a6f715ddc04f83f1a674196991fcb2342fb2a7995baf8f5312ed285d0c6c59b6ef56e72016a105a6f13883cc1ec3d0aeed6112955025e118668bcc88ad0bc6545cce5d3afb4d5e042c81897afed3e319ae80aa690fe679788c235ad03f2ea936d9170577ea43d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
