<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f10037b551abb04a09604ea94a386aa15c4a8baa957553272f944529b837843b1667b75cb7d141e8e92a285c406ee3ea65a623c0893e9a78304d462a69afcae7c975537cf886368121f9032ab0d12c994d7ad4edadc3294ae966e76c28f9d2a7e86f145879d5a6458a20dbe2332dde903202289b8eb7270b492d67aa743fde2865b43a7e76c0c062be28e167319f928873c406cb49777c65047fb4dee4fcc9eaef3dca6e35e95542d9bab36b06fcec78daa3b18b9ebbf6fd264bf4c013c2338f03793ccaa1fc4f05f28a35a44639da4e966d4fe71427d9469977cdd329a8c8db0e4c1c179082de08ea78ea0b40dc91fa01cf6beeb464a71ad6db553dfc28cae2336be8b00f3a773a346e0a517f84bb1c7696a602b05cea3de29414b254aa16bbc094d13706f9b5ab23c86ae1202e5a4e9cb1fbb1e87574151b4e7509763ff8c543c1f680ef326e3c50a2005a63cd36bd4691d4caa07d1b9d61e4ae691104bbb9773d28cd1590f0a78e9e856b6d12053382b7d26e065472a6df7351fc3c85cbdb1a58ca13251c87e5f530deb4acdb2e173fafa56c0970356d1ced6bfa9afd7d6195abe70470d0201c0fcc1e834532929dfae10d090f87d66e3de9607f2f80574ac92a1b9d69d05783417119b47b94f30865c76e6f68bf949cfe9418d799b7343c762fff57f3a274613dbff00aabc67b0776b12d801250ecaf255fbbf8765c96576b9faf67568a7d2367452a1ccd589983756639ceff8eafbd679763d97e1ae7bafe57ae830225bc556536e62a3c57050347fcbdbe7e5033d6f0cb6b2436616baf20bafd324faf09bb8a257fb84ebad2841ba6ca6fd397cfe55c65828a755e13c0c5874c2e026cdc570c23953b082d95947584da03cfdcb696fc846ddcb604073187c6456d2cdb83ccbc9c15ba65ec22744f79b2ce21bbd95c1dabced2417b382f326571485bf2450de932b3c8a29890a87e01741a4b7d91e18142ce91bae63f99f5216f3293b7e03ff69438a7295d80cdbb4e3dcdd11c585328317b31ad48d853967b02752aa4682d3a68ca69cfa8cf434077c41907500fd29d53e27e4a3f2f10e0097d2a370bc21144f00aa074d1489ce6bdf7a5db94179d52dfa496ddfc6b16e0fcd91973782e46bb2f928e58a6092402406cf341847fe984c2cfbae51a1a13e5128b70014b6880c08af8ab164550d831ead63c5447c40fd94e58bd059df9b9a4c3761dedebfbcbaa28db0b2cb14acd28c696e5a98f001baecd9c880418a2c8a814510b454ee12a391eca47beff912095496b63118597edc2fa5afedeaaee54db59ab92d4121e7e9fb4aa9168019d9f68d05166004d40ad40d41bced478b9fdb3094c34f08844529fc9f044447c0cfbbb281d44d18927fe6c4d9b6af15718ee1e89c7ef62778c22bcf5da2287ee36abb3688fd040cf8bdc8089e7183fc55bbe20a02e42d96fb91845f1141c211fbf01e8a563ecf5f679ed32f3ade0a0a196e5b9ea4334b271853d0c46c02e817f1d893193ed75ae4cc33acee67acf7d4a82787918df922131e65d673fd4cc2aeaf24d0c5564a91b9eee23488d4c3ba497920af2b71112250c7dc27db8b81e0501fa65c75c3010aae110c74e402f14184305eccb4f0c26e31e51c6a276d375df4e4fcd55080a9d3f853ee10093cb09f437040300703614f7ebf8f49470ab0235db2479fa615a34658ac2d84521836f28f6c4594f49141658e05d8708c1868eef40a76097dfc145477a238386c8175b79d70fc67b05f9eb395157e2463a916b941783677bf90c23ac3d14626900ec9c802a2c1e6e148af42068fa0e0a6d1f4761e31de58c38d22bbbd7f24d871869a49fe3273efa76dad08773bb2627a3b6fdd03fd1534525f570a538dce510bb1c4a418bdb02be60499c2b797bd500d2c803a35750b12278d195495da360a5c2d65b9ce6338afc228b617a4ac4fc2e7f4f1ba2a135252e05acbbb013385f20f42bb8d7e031c25e43f2e7d1403da21d9c7d8c9e2f3e5b73f9ad16aec1ebb8cf8233611234e0e74a563d6201379de89ba425566bf4aee6f7fc899efa50cad12d1e640ed0ef2a7e44ddbe1021231477bead75f5ae99cac4a9e23f4b082353eb960a02fa7f05eb4187e0d954da79b2b6c242becd4bb68d54634ae5e4815d410e82c838cd2546c65091fbd89933c660de96b4441cefd1ac902e18d9f956978c4cd42be418bf455b00aa21bbb2a0c3cf791db102465831637819a4726efcfe6a2380bf398baa89a4d200fa0c6e3ee7a9c99efc1e058f5a36bb834e813b9c662d56872de88d00eeb96e9532761631f011b877af55bf7d5112d6896408492ed92c088de4b178956975d2b541ad3c9decc6cc4805a827cd847e353212f1abddcd91a033f66ab59a934cf6f5e27778a61e5dc529edce184dae244fd8b30918a273d7199984ccf3d1a99a94d82c6a07be8fbba3fec9d439011bf63f1d5d0fcb4bcc93d31652895f697b1fa55716dba29df984cf87cf8066bfab0af5f930b0499df9fde46270f8b8123fa7df2c96746a3235931f4188222ccffd40929386cfb71d612115c1611515a98307def8528e152069ae06940a74463f1d436d4a982823ccea5a192349f79e2ffc6468c7c087b6d85e9b151eea44fd31f270f634b74bfa2a4372301672b9b1df4bef571605b70f6384293968f06a265363e9b1daa257037cf5ad06242dc3b5e25abc422027571dd06323309740ac94ea9d8572e60fe264edc95cc14de3a9e6127d9ada860f119277b85fccec0eec99a444c7f0c1a73d447761d861f6fb65a7a024538acf93b89fcab36712ae4c9217e751f7e82ce38dde4776e24893fb4807707a5d7ff4784d951f2dc35b9ac3b3818719ad74e45968064e997b3d158727378baeedaa53af200e8619a6db5dc27f013532cfca0a4317d2c0d18b95d5ccbd99a752b6063b7b943b073dc94891933bbd86049377fcd9b3a986832b77df8f4ddcc4098f01d94051b3a1cfb6859cb08eee6c86be67c249469be4e4731b15fe3ea42a14feac91cdd429267093cc1a7c5e508c652ed2b694790cc8c9f051c7f1190ae2cbd5af32a12ac3c1185d7921898720a62991e9caa3ffb0092b9f93c3908014c15c3ccf8a17ab7997aa68ebd499f5a93600f345e021e40eb4257ce1fe286f91ad61909c391a628dc63f301d9f66625a68d2498d4ea161176c8803994d0e9def73fb92ceef07477a7628a2ae48a819028a34f2084ca4a403dc9e6c52942196d8225e1b0daa7a1b70c9de8e7b77b7236ab3c6e03cb49fc728859824dd61bb1ba39170ed208679b4453f28392d848c9a906f89027d865465b3d23a653119ab17e46a06b348321c002e33af91cec702f7ea68010595e5b8f0eb54cf0c3debaeba400bbed581edb733270a711bb751cd31cc1f3b1cc2eb3475a2f59c11bc53d7de256fba66291a2932828f0a7849e51d458e0d0276f97aa11b9ff248b9d7eb4470cc4c4229ba31afd2085617ff6f428c9eb4e558f3449b25e333a6c047077e99674de809c7192a2cdc3cbcf0e35915c9d0f68dbfb3cb85b91a2ff390b24b6b216b81b73131dc7079fa084bf138a95afa4df800541fe1c9637bba76e82f16ec6351a48463bea71c31f6e68a01902d0ec1c0f1063a8d918aa09a56feab0be01a47c2e733a263ef9714d85624d873e246a5d6085736f2d095e97ae0d832dab8aec5599b9c14c68ccf756344ed3890700c53187b698cb8667f0b47346e20bfed2f22ab7d1502e387be297dedf9b271f493d026cfede39212305a8748d6231010601582c8b6fef197e53c6584ec55687580663c6474e2b0e7828b7fc66fa62524ff1f08690f94fa1e5ff040b099332ae73d3546846fa40bf5960d4dbf32e5bc16ce40460798eef6966a863fd95de953c54d7612e6d9dac32699f36f3a6e4741b28a0558aca0b8edd8b306ff3d68dbb6daf001e2e40ac01ec1462932a85ab24ee165c16371714409dbce94b94f2d14d47ea1318353a28dcb0feeb2876df0c3b7eb2fc12df4efd3f8018f9c2ceb3867f8be292f45f118a664b6d69ac7f7d08027632755d8f5b8e002b9efcfd2cdc6b739dc0eddf93c5ca87660a073a9e8b29748bbdf67874daef51a291cd5ffe3c1cb7a7dc742649eb1ef4660b9fce158b51054613678a074d639e15943c6a6828d6a731750fbc636a1859a4f128745c132ae32ca075f0259d5dcc05e429e60ddfd23a113c7b268dd76eeb6b687e4c44166c41f3c950c8d0c074d146bb2145023886c6621eebccd529ee3338f3c5135ab0b8d564728f74d461ada3c2e642fdc13be5e151adad4ba548091b6e76170e3510a0c36e2daa4644ed5e731f19c306d8d4a6e0295786708851711cf1713da1300852ff8cb92f9a57836da07c1704b20bfae9bebc9121395647706389d626e5d77074dc0d322c00a460225afbcf3f4803c4f26e50c870fa35f79d79af68805fb2f4af19cde335515af1b68c04d1feb68b8bbc1a53ce044c1b2fb73c81c5ddd362de5be825d6e59fa31b89157a8df93a4f3f3d9bdd5b02cf581534e59b28b1a1d45de36fd594f12dc98167578bdc36c4e53b5ca8f7608244abfc723d1e317229d575e9abc4abb24ae1c51f7fb9c70827dc3e7ca2d65d5a61280d256d377c3471ab3459a19a0233c289b4a8f17f9a832ee77d97266a5f1dd9f530d0c7e2ba473374533ee3c3cd744f0fdb364c0b6551ae8828e3251f0a77f0e82b4d86279db700fef42f0da1308d120f526796c9e843db20e919fc57c7e7944f7d52d6825ccd92569868624da91ee7b38c6ebe2301717ddc7a77bd0f658ea5dd653e3eca4eae4e3cdd549ca412c81d9651ba057049b35ba7e9d591f52c69a2b1355742d933b68d8e7e427e695b145f4cf81097efd34ca650332ca1e4c841ecfb8d78a2b745b91977bedc9c7215fc5ba02e5911c611a5d45f66bb04fd803fae4466b14b7fa4a54d49d6c83e349113df46c3f121fe8a75cda54d0c85a6b2ceced1e369a154aed7f4c6c6fd53e19b729bf6ee73022d4d330a492a2eba280bb9a608313424bf5d65796b0c4f85181df8e41135fa012b955850faa1937ed7f0879ed4f74c465ed932874b5586ae6c9510f44861e7266a03e9b75a4f5bb37e3ba6d36f5edd4d47c32ea565083dca34af33b16294f42aa2e0dc1409389fa9f024dbf76e63b08b01c62fcab2107133b96850029177f111f1228d4816df55474403d40035aa5d52b63abf8752827ef73c0afaaf6f639973574bbe440f75db4d549433d106a273e0edcb52c481d08cdbd67e0bb13263c54eb2b9b442b828fc91d8ac1912c71be176f67e93d4e897202fd7b816043d509b3fc15fd1ca7c2e30ee0a18effb43e026ffdbf0207657bc07a5f24c7f4c5d0a5b1574656ecc4b3ed131cdf96ed040977e3b636a3a8cadcf0e3cb200e2d52e0193f332a1605c715cbbc4ec4afdc8bc3a581ebcebd200dfa458ae640800bba42c0c897028e4ada514e0493efde53dafa9b26195da2b9d503cf9566073ae4e71a5694d87ebe25beba6a8593a458fe59e3f30cb680ff31253ef8a7166059a44340a01887e9f129407731e5dccc0852027aa83007cf96145127e4f89004c794eafcd6ef9a48ddf2a6ff54a37b4f240e2fcb14ab96872fabe71d40968f55976c581a8dfb2cf5496e5d039175445200c37eba4430ca238cede7b88fd5afc7b9f3de77980a4b61cca99d24b9e6b3a47082812109d08e23b7c2b25c18357331ed5091bdddd77826204041ac8571dcb3a7754e0a5622d27593e082e0a6edda9438f49e56a196c9bea2f21026163da6661660421d7893425f6041b997f3967f6bf909cf5b8e811560b44ff3a469ff60c2cea6701033153123ae7e70e1c5218e014c49ce16042268b6f103d01eaa7bbac4ddfb44882ef6eb83160f26b48772c0401a73e14162c6eade22ae991ff778fec24470a2519af99ad015b968ff6b582954300615d47ca6e81e611182a4767deae7b8990eaf7d6c61cb0241cb5c68787e5fcd6573c11a9ed1d678cf8ff443f45d0f1b277397b49b0ff29c55cb8bf4228b7c07ecde4deffdd5d718bc3912498e39bf2051b84f248ae7b9e4a1a87be1bfa7e2e5324d6110e984b72c64b62c857f953e33e5d468a24695d915d8edbf4bcc5469f49ed9c67bf94fcbdd224274e8953def41eed87909fd0cca26497b0ed137b54b15781d155f6cca19c2d6f04d2ee4dbf6bc7d8b12a11d8672abdc6a0acf3ffd896270c3946dde9083c6c9b0f55f38f98b8e7d8f109a3d92a5c7dc63c55dbdd1848f2d18dfe46ba6184408de38a9745750956123ea9a9efafe646150086612e9e932f4368725b33fa1d7bd3b2e4e51962196e23653189cd9bf91a3f4c44fde31768d3c39df279c94a6a61043183b1aa9bd11b893fdabaf3c67d4f640110358e6b952e931d6e31387db0e7c6733f46716b13be5ef0b04ff03a1c33f0c32ad2673561202fd6941d05256af292ff3cb0f86e9122445cc600fc805614c5a27f94f3f0548a3dbfbb7b9406daf060492fb75ae722d7d6d11104efff095507f9504b0e0c59557aabe73e8ae85d111df41fe8618f3bfbd01a8c4bd4fc9c156e74e9d9896747a0c7f9acf436c92d206fa9be798f76501de39bb6435ff62160900f0f7954e83eae519f0fc558a2808a8e5ab72ea65b860c9c2e0f2bbab070def2ca8dddb63b00f78a277cc8eb496bbd9dbaf16b2e0bebdba784129f79c37f03e470832f53ec444ded3d82d3cf339104c39981d544f30b4aeb8ba6bcf34c504664c50ac2517174c02aa8a777c684f54473dabc36f22f6ab2cea5c3bf32a0299fad6b580883fdc40ae41b493e7fec88e61715e7a83354f45977c2b3c095bf51ee00b27bad47b87d6ea65f96cf640e1f3c7f5047e879ed25ef78a8133fc5d2993d3b02161ec7544ad6c94025946144a36e9b5443fa5c308597dbd7337a2f26a5c5b18b0331c4cfba149d223ab5a02bb1404c290d88de4ca3e176ed44ba9990b6a25eed0e20fa33eccf913a4ed8f88b99acd436ad38208af094d8d3abd5630538f3189b5b27f035114075574c1f088c275d7bff3751c2f28b49dd2b6957b88ea587e87d6a052625993ee3c7a7043473efbc402a389b88d3d45501625a76328873b0bb4b928132877f54a2e9e827969570f29cb3ce66dc860ee00c87a593905a4e83ceced8b758c50173fce8919093cf62cb099d7d8870a8d6811afbe0ab76f612f5bd88d0c2660b705fa2abedd29198b0f98ecc64874725f4712e27e54b4ddd73774b7895b09ac5a4e53484ec4719da0e473458ca6c1f9d3cc52bf643c80e521908ff30d939a6318acd98908b5b5ca2cee107a0fdf91660a8b9a1f6c3265cc4e8066e6ba4206d9a47a24f55365828ecc355679fe6ea0f8481a71c0e9af5bd43fbe15fa16e8ee0887c60f01d08cf1f7496ac4b056261139052d86c618ea6793f21b3d5fccf7b9e6bd3aa1aef0d91abe07d1efc8ba06bc2a39fe3f5a9e017e80d854fec8fb3dce95b44e20b033c0f41c359b95a303776b02e880fed15935ab68d09bc07e0a490b6adc21eea5e4d901659458ed6ab5286c3534ef6b085d43c307e27e3995915ffc4f63dfabd415e818c209e06679fbff5af22681433f16390173a51ebb6b7e2f0f626022c5b712fbf518b0edb94863f9c36a1edb7e273d1fedeb3ac4d8dbd6f1f7a819362b2c30e2143e49cf6fd51f3211784b2b04c1cf05c233e09a65286ecf60111415a37ebb5986f56747416854074ad2acf5319168a2f7ed29f31d8f9c54287fbb75b7babed707354434ebc2aa41837a50978c447de65b69f8acf5a8ba0a49c46ea985fdc63d46c786a55bcc9e0f0c54bb12b7d99af94767262392bfcd7648ed0d9b912d71cd037aef47fe084d93ef371e3e778c1f1b64c5d8668e17c3e20005145544212f15776393ae24c98013208084603c8a731f204aac941f537d9509bd5f178409932722e9d03ca2edf4357994ea257db7a4055acab76d4f8d6ab45b047b39b43b428c5987f22211c348e0b78c9b4061f7936fc0dfbf9a091fd13eb4262a53f254e6c382468007248fd58ac82c8d217a36dcae919e3f4c9c0350987d8be4a4c049c9ee5044c079e252a70b3d78df6f67f9aca31a07c48d5e301d73b8a4533510494a2fef521b9aebbe7a3848ad7cb0c2212890f0c3190eaac6b5ee20ccf9b74528fd57eadb700e7c65a6474c9941f8ca7bf0837d56030a288acf48b8ec9dce09c255fe983ee1d709e369ff68cd7eaafa43ea122fe12ed40564d5129055535c2b890a009b07eada19e7fb1f13dadbd0f714fd01fea1ddaa10d550f3a8af959be909bd73586c4bcea2e93c248e53e14a669b36b8bbae48400fd3d33db97c327e65d62c5efd72d10181e5be45ca3dcf837c746a43ab4f5ba70aa1decd85bf330d357afb3705ff59381ae18f5b621e92f33efdf50e61f793721c47348e26f18ae7b4fa88c41de9958f2b9d99d1f8ae15ab13e9198ce3fa55649dbaa6d37d986f089f0d5722ef72307ebd545e0f2ebb9c2200080293b29e9f135d9d96937f78a99595f09e2e1b0f0b261b62ac9cc73b3b63ee50f14b4ac41878e61035348aa4b664348a1a38ed1a2759d3a974b034650dbf165368437b3f3add246e218e3741dfcb0c4003f3480ccaeb63a2e46fc4c93671240e161d2884e60d22e2e9253eb13625586443ec525cd562df603f8055e56c00041e54289b3cacbcc23633f116df8348cccdb03cd3fb12487e526018bf59fb06162ed68594a08e1ab9406b55503e4a8e2d60f1ef68f196040a76d6f6d3022246cb9867cc21648515508316ced2349bad77ef26f320d53fb82439c8d9399225de208b04ce1b132941959c580b7738c32fdec8aa38199b3d5f50559265d5ce7fc15b63238012d3815a2fe6d1c024c7dbf2f2544aaebee70d1d9ac0e253c1fa7dc4b3d96c89ff171520146208bc2d4fac88b50ee04c7610072563dfb0b061c584b374f20a0494af7667b08ed75bba2d2217630b8f1a438684c5272ed48c632fd8d7e4f17b438a8f706655395636d9115c3a793336c2343758324fbefe39e58d746aa84e27b243123851b33dad4fa01f6ac1853cedbf4a59f2c5e73161d2d614fb2ef3dd45904a64fb52eacf3aec8c80898314eb54a5740c726f166ddf40c3249bcfc3129327380b0edcd717197f75a516f1a62f7e22f5ed1eb972a94c07390828c0c1fd5b980a72c743f58ebd13bdc052fa995b16090fc1b785ba94ca62a6e754e3eaff78484a94f79d6b0147e6fe6bc78dc3eab20f843f97948a53f5a95f2131ccbe7be5dab76a3f18fbb889fb5a97a274ad1f5a6027f274935f9f5d931bd62593c766c6e7311a54e55850b07d1867beb519e787570b0e5ae0037c446d8d7ea5cf03becd3803529ed3d1559c86b7ad040599c328b6fc03f216607d6a1de9ef29931a08daf65d1c42d32add5b3a4b50fe2416414606c2f7e5bebd2bc8381b9e7aa8551e94645632ad87483b4a244da54c6f2e468adeba33298b53f4e7c19caec0713087cd6d5ac6fdb7fa9114a68f88c8f65b6d7b4733341bb4b3cfbfb8628984e8429842bb400e2d72aa4e6ece0c482294993140270782f0fc17b26f4924cb74d974f37b5a70af08862634d3d3a82573797edd3ec5eb424142d6446d69b576410e7460be37582bbf7b074a558e3b53f5049ff6814458f1ea0b2aa6b17586bfd57af2d1c5006c241ed359a4ab48b286e4eba9eba4354b4f0da63dcff55fe18e2c1c51d78337938cbe130b4cee4eee829323b704e9443a9fa75aeba19398a21c0bdf806b6a3853e68e3a291e9adaa8fd30b7012a4a79c52e23354a9145597c16a0be47bbfd0f8fccf7d2bafb2b333379f5c19a9839e25b948fab541ac282bedc10d78db40752092101e64ec7dd09e7a08dff0a771a4a0d93fc9693d5313bd8f735d774622dd85d7ab481b1a602b16bcbaba25c748cda8980dd031a4efbe2059cafe6821d4c6968ae173ef22d2eb1d1615797e992182c6e660a6f03f15677582fc47fc64cb0caec62ba0076294934667635e157fe30f8d7f03ea09f4b28afa8cce8ca6209d8cbdcb60db31e4782968bab2aba78912ab7bc0614a28525565e3a8db1d38b9965766a1c8f0f4731eeac87c3e3a165f897200c3491804e8ad5f05fff196a6131b9606d9645bdcadd0e07b7ca945d43ffe6450e09fd9151c68a784ebc9809623b58d773251b68591cf0507d0b5b0a62a5fa0c8cfd92e678e967e5d1cecd853d5462bc6c3d2c3742db6dd5f6c6babc86da9d1f4183418ec33e075ecea858b2d2fc74031cc760dfa9a89699f34e206438d50b5f4b5f729fcac9f3c4dbb9b63a7aea04ee83865c6c5408862b4976de34fda4d52707136668e8e2d77df6dbe973170632b43d0293e2ba9d8c19b824b2d1bf7baff5faab457edd0f0cb1a9ac14f053b79e10c10752e209c967139cd15ac1626c5815dccc23970f4c7b89aecc45245b7154d7b1ecd8fc12f7737e9c27a19c4f10b36a618c2862779d4a8dbb6cbb24a1ef3277e7f05f194674b752f816f7004e28746a5e8f91503dab97668a8de19609cbafddd997fc8e52098007e702ff273fddff46c67748961f231b2ba3068a0bcf653327d507c0281bf526eee7b5e0965ce013fbf301c3c01b6f5dfe4bd023b3d80c13e5f9b17be749239042004c09c9906305eeada9cba8433304a8635730860797d0301cc3c452ea9cabc33711c03752f6ef43a6a957245330edfc6cf60824f85aa9b8ab4f26becc2e79c83df0898d1612d75b20f4f40e1ef127d5c5817ca4f1545d84223980a0145fa72e69e2a4f59c0533445045930888aa3859c017c74a92010bd17bb043f7e6b56da3ef8ec568061fc9d9162c35f0b7d90a6a5b602fae877a8fa95a7b1ba2394db17df8338c45c533aa6c423143d1b2e142214530168b761db8aa06c59116c11da5787231701080e9b5137c8e4506f70275b1a7a671e827449b3781e90a29ec9ea683acefaa1ddb1e6c40179d2ed276a40f88d08e236efc3eade0bcf1ceab1332d16b009ec8735fceed31a45f42aac5783fe64bf96f4e92dbc1c2f3d2c917015f10b9c87a9410d22d3551323aaf9eab9a7a60adc943c56254ef1e82150620a91a481ecb4d6a645404b2f63c885043a92600f7f9f4912f76bcd28f4a149f611693e1c2af42afd1d95817ec4b94ea8422c5a58e469729b98628baf465c0546d95edc64460b1c2b8f62974e78c1be4ad8b7afcb9952fa3e2796e52bac663b0e4b3b9c152a441ddce6fa91122a88c60cdc0ef6c4316862273aca095a78b698d5c5903490235ece633fbc417975607d77586452e03feb530da44d26d237eae4d3b5a8a28b5ef18571d9614581db14ab2160cdf2b8d4e7a7d62fcffd0b3304a4ee9fd6ea6ee5a86c34d6fabbb5a9ba5033c0d689df4fda8870a2b1f16e363c80952f30f89a4e9b9744b1d935f896f8f5b0b55dd30bcc124681135f219ea97509ffec7211246c544addcf6b6e3abec1a8e27b3a7a6b1d0b27214874dfe08bc1eb3877b7d2486409425516fe4d91358f6814ec678c60dfd98a2abf55a9f81981c8db15eee68fd29b4965914d649655be3926ef43884b4d62a124f4dd3fe52f7e5f13212697fae86d2bc80ad6f7f6462595b260e6debca9c12d8ac79452e025de77ce0f5d14e243f2aada560c630851f4363b1d6d71c7526d0fd6da71b7a4c7d00d363427680e28403debb2e968461400ab75fef86c19ec3b2e8b6e1f687de50502c9e547f6e2b68d63595d87f050a358cc1320a68f572811a63a63299bf0ef5bc907b87355c23571cf4b531dda809b37a5ed415934653f4cb61132442d9866221020b2fab5b3043214affcb3268c7145913b69380b694aaf60b1d63dfd4a0307188f88febb82ba058332d7b9c2caf939b6220c242a0618085048fcf132bbfbcfa718633a6190a23adbc23ec5bb23080eea7fbafe4a050c81d0dbb51676bd84637d2f05f584679ae875ea48a4129a97972b805001fa20a65f5f946ba53b3532a5268cda74362b79149ac9542407d36cefe03aea1a444a629d8372269e87d744b55c207dc33eb23675f4bdcfbc0c92a59ca519376ad0b6e7d01c5c635f98046ce246c3a64251630da7d23508a9393551c94ab7c83b077802dcc16c00d2b30933b56768632d754be9d9144c2e18fd7f74f7efb405ca8851811e21ebc43bf8f10ab3315a7a5794935b41cdcefdea17ed21dc3c0ed5aa08b16614a7129e810ad1d524d18d5f51b16362761894fcddfcc2213f63e9de4d6c25273390e7d3968019d78029c77343f0e56f7efdaa2b29cbd1422c909f73c6ca175507aede6b683f1a1f0bcba6f97524a836b7a3a426cbb0129f87894aeb0d1424ba9ebc837213d5fe5dd4dd7e34bab05bfa6fa3178dbed7cce52dacad0c4e6a1e1001f180bed330f341f620748eb5afbb7600228a7cdf3c6426620103b77c483d7696b364e97261ed49d08647c8eccb7d1d34dd34db0abca07bf89362aec57a4f27fbefde39d1b11f41e0cc8024b19e73bf70fcf72afd622eab17c30ddd53b5a26633ba872086d877ba278fd0aced153c37429e0fdb5aaef6c5c28cd8d8219520283b0c3a8047b7dcc65639c29e521b8c2ab081fbe81dd6391aebd1c424019a4278cd72a9dd9dc5583dc156a771f39fd701ffcd40f6c2da47d03bde16c9b6640bd2e3fbb209485c6d8e4f9f82648ccad99493666695420cf0d0dc03656c469d11af653a7dcbff14d2b5952c88cb819af505bceef650c730a8954a6d7bdc0619e5f647238be4db9ebd7cb9a01fe2ac6d7c58059335b7cb073679109f20aa6ed3dd2895b6fb8bb78372964ed4ed0712ddb4f869e335398f6bcd9921c8e6ddf614888cba6a44326634246874a3a0cfdbcb343dc6758d9935e9a6519775693db832db270bd35a233842d3fd829e37fccd33a1ed8475cb016d78e73c466928b644707b99b031e3074f7ed6c25448c72db49c5b75a6eba7afef9826d416dc1f3d0b85b1dff2964b561f23458d972b702109d31fd65fd6e262da110d5a195bcb6f0867932b133cd84464a0c7e0bd847ed18cd775629ec3bca0b8d17036a0f0caf811a91041d0ba39c0cba7e0f362fcd899e9d193c3fcf0cd8535c36dba3ac16a1c03ba9c770b8df1348739893f18e36ddb42961cc54bf2e3f437386d714031068613f0629c311976d0de92b5cb833dd334048973b1f16e2a43167a95d7841d0b5d93f2cf386f26c5e5b63edae1533892ecab67d5680ca46488f3a98d091e925e1edf2869ca20a810fe9049ffb71961464cfaeb0eacff08edeaa2c4eb99640a0f006e5458371c41023c10876e097de3f258a235e776ad23bb99d7ba2b350d8808f7e5e8fee31ec15ddf91a8f1be0f9a1ec7b313cceb3c8c7e9b65e091f6c30a99aaab6c676dd3119cbedf3cb737984dfe58292e98ff8bb9862294113b38c80768475ca611994578c43df13358726219d027fbf3a99a9d6a76369e7e585f803a1c98607b5d0dd12b226b1cb426e1f8022e0f8fe35da4c5ba7c91b960e7c7c2958fe93294846627a57e5974312b33884464553a4761d8b2dbc352ac6a608658e53eae3d117a9f2f9737f71c34a37a64a838e3e5a0eb0ffb565093034743c388654612be48fdabbb10c680b8037ba076f1fccab1e30b482f2e17f7f53b345b27b866625e97965773c2bb1ea484b41b01f498ec1af4479158dcbb991ca56116ff3ff82de1274dc12df369e4969896c77672994681b2f7d923b2a24e4456e3c35862f4955bcf9188eaf97bf3f4cc565e71e1f2de6b0b48ea6f3e4498f745d9710454bc849b0f071a7069dc11a7c4fe1c60f4e5c721352b8d471dd62f34c0ae028f2efa65776faaa6932598f9f123450ddd9104b231d2d2f49df3b2df34e291a778255a950598b453f17b045b3ba7ea1615e7ac55ec922c214054dcec406bee0a10184333665e2f0ce02996df113fca20a6de68e9655614c92f389cc3ef30cc68b4250fb93c2bca73e62a6fe9d00ce059f065e67d09705b9dce2218a517c479e113618814bb38358bf28c41361d464d43ee161b1a5045507cdfb80ebba7e4cdee41756dc5fc5f7f284a5789f64a281cafdf35ae5735dec36e75bf34e2daff19761a0483188a451875ca93a2a38da781843fca66b49a2128e15f761fc21602fab32da88aad2dee297e0a748869d8d6d2b8a1ac459dc4b0d41b0b041e100b008b6fe37f8d13aa9df2cfd02ccd2cab8fddd623e3dbb8beafc38b454f4344509489bda1c886c8671a07653a7ede3580bcb2bb4334014ebc3026b8a4e45b681a00fa15cd1c074ecd9f5f51fcc7d7d2097dcad2c4346a393205be95e5ce74de809a7dce5ca585ce9687568569b1f9d4f6ccda91d35bd28b74e8bf0e57dd9da4d5d93a7a5608b25c79b95da7045b3d15dc596b6f6f77d41432deb81f7a73c13dd00ed45fc6e5107d41c76d233a5b7721fa6b787361e2e97132fbfa45fe228df9bbbd0bec31f3ba7ebd787156d0b7b3ba1d9399808daa734b8d0efccdb2621c6bffcf9edcc6e4f05968f5c91404079dbdca5219d9e38dea67c523c0380a9b2643eb89362bd5aede9be1e58a4833cce642cd4906964f71da26101f0347b308bc22f35a696f8c1114ff184bd283f50fa5c23d11616430a6996fdb379e705852677e85ab177fac906ba2aeb2ffda90a22e935ccf0114b69c9a65f1f4862a11f6f7d06376b398a5e1acd42d40258a23d44d419a741c0f7301e6563e7472cdd07dcc64c778f2f2a143912e1a1d3840d51c24286af832632ab99c97fbba4134a9436d588ee900b4809c59b1da3e2d9df2c900fc6499d9a50d344abdd514d69688d451ba25c36bb38656c85b9eb2d75012eb8c2452add015c8a3d885dcce8e4785c9a49491852ba7520ac47350b5c8f1ff2acd7e8aec0f5345aa5f072bde03751b8f6bc1e616abee7d69df9349a1577976c5ab17f8d93be83963c7e6ef23c170b60a0d1f6c3c9198d9d5d1e880cf6dec7e6b376399ab303a4e1d7b6a1ea426703996685fcd8d16a57e3da5936a24a71f102f5af72d976c74639b87d4e6af648decf8960eb43fdf81f385acf29ce847a6f22cd8b122d9c9b6b6dc01755008788140088d9d15de85f840902d9d1c6b8128f8546090fcb7491c82b193ccf88fa74045913f90d1f0efbbab69c247371ccc3b76d5e0d87c95d762c08a0b88de02975ed22359fe2d73dcd3129a8d58328e5511e2fc21ae96e00f98a6e1cad5077051e4c0190487523fe266a63a273a7a4b2b9bbe51c003997f7b539bb78cb2ae04ac3560095c3aea24cfc01c094dde46ce65b4d1c91f35e98870add51d31a072b25346baff615b5c861dc9adc01c8d8d394f4bef341c9972560477853b59d55554b0d78674fa6da05eff5bbb534c66f0f1a54768f1cf17ce8d1c6f327a116c7028a6e9c68069cf6f62ab46defd78348aac3fc8a4b10aab15474c048ca23becad88188d8bb178e954eb8b5a244fc7a63cd6ffa0960ba39bdac0aa0705a7fb31e6ea5ad4f18d70c6c55c12c6e9a35300e8481d64d94ad95eff52db8789561d8ab8be7d546a4ac0f9b40b82743ee0cc293db93eff264f8363658859bc5109413f8649362618d8782ef7ae7c8b7bd3383904112f617f603d9120b9cda16f8b11aa57177df0f2ef164fe0edaa7765c2a7b68a023a2469bd24f9a061d2fd9b8b7f72a0fcbb125cc813be6f261c720352ff05026ce96a9f87757015d43b14080738232825ab616bd186f1efff56866e42a8f4394174f54d2aa89175bcba6f6aab06829838c13b3223cd531d408c32af3f0a05d2211731147faa185172849f1a6118e34f26a65aad8e290b8a0e7fdc6ad5a16e1b3ee55abed27abf1e9450f822c916856ca771743e4662cbbf5b5bfc74657876475e3cb0c2953a1cf3d488ca09577f470547b931f4c28b0f78c7962defc43c4028feab6e7014e56fd1f3a99893557af207ad0724e07670715b70fd01b5dcd5f29b0da6cf186c6a803c2c83567a75386587cf4b0ac622a6194b17587abf605846a7154eadfd13747c8c5bce8fcc30e6ae101dfcf043171acd80c3b71ee95e26b3e786d581c8d03cf536935b34a6f70e489ff1ee3b0a17b83fb88eeb6e17f16b0f7d95057e0343a6dc1cf0259237d96a369b58daa51817c6c4f60af523d6ee1430b63fda2abcaf411e2219d02fce3c76e99ed173f895df6b9482a517233c426c3186f9b1c2c4423bcd020e4a7ac01c8e52a19e362070bee2fd9623c7ec53a123fb1aafd8338876e243fb0c66e508f1cae658e0bf874d5becb8e7d0c4023505dabedcb410a3beeb8b8e4e294a7c046dbb56fb44d0d05eb86ad40c3e29270d2863d1e3b26b52aba37a542a4dc21f16a124e41651f674e91e000cdaa7e2e3a6d40afa359d19e45f62ec774f81de161ff2c45a14a27853d7dd5ecc29d67137134ca6d53164a49ec6d5e6598ecc00279c99273123f1e9698819d3f5493d184eaf31eef44957e2632115a6407cf8e2e8e6b0ac47a0d654d9a5c2dcd5450af95a188d1feb2a8cf9266dbef57a9db67acd50973bc0717f6b86ac049fe7e69680310b78e66b7464acdb294e5c03a0330c6e14dbb8ba3a8a4ee6086e9a11c84a74c2bb16d3b8841e984b7bc8d4340e3ac4f8c1295d40768599f34121af299913638bac4d860ef22e7f522b665c94411afa3547bef3d7ae1caf54f2ed6262c1b7ee9afdff12b5e11e95c32db21d25d88756397111d83e15bb495bf32a8f1d5697c8384959d3525d389f68e088dae39a9655d0a5e7dda9ff110398c29c0277cffdb975b218a23d07b7e5ee7b278b1ca25e05875edc6d7742415f976a4657eaa6e214ee549cfc1658cd92ccfe7355328228ab4940d9389ebde2eccb3febbc2350e98b9ada30294eb8a65bf06010b4bf2898989579669364bd433035bae9c4d90a16beb86d02445559e5b707679d41052edd4b2156abec41a3b4050d7f7790348524656f42e9afddb8000c4cebde19893137fad9e7a3c2074a2a81b15b723c5c26b55da63ae274e73bd7289c427ae18164c56fbdb1c52fee9b85145111344b45fc74e680a3e61056360fdd3f809c4ea586b3a946d3cfa8f2622eb08fd3aab9e0c8b48e1a9b4f3f36e547944d62d5a1af8322c02a24fde8aa2d5ffd0e1f99a6da9c1a15fe9fd122f4a9d89e4b9d8804f05962265d7e3be7231975a612816e4622dc5b8c16dae7d55495c497b44718cdceadf9eebd75cb12b010bbce766e57fd0ee420eb51f6fdfaec7cb2436c5b25148bd9fc7dde8bc94ef7705526569f40ea17bce85efc3faf94ad09127cbfde5f62ea95b91674a5c6d0febb46d6d7008f09a6dfd02ceadd4d12e3d9f0565d992c36ffd9e996774ce8c507db7c711f41c42a6ba39b9a68274412b346916573ece20308ac11752cbab4a62dbae18ed65b6757946fcf397d6c8c468b09f7b93c083150769103c7b10ff79ac0d6c7a9a10f7d5258af0e2164f6bd051aa89f4abf54bd82fa33bc93df9bdfb696d999395b9a936cdf63b880ec005a80c4c1fe57dfa529eb1050f2ebb80da5f6db9280facd0a0d186c04052aca70a921bc195a4a443f0bee460defcf1178df18780f55391d6710968bcfd09f9b23e24e5beb6e65817f7ca206a016bc4339be70eccbdf1d1ded0ccf26ff44d896b950a1bee4e8ccd0b80bd03def957fd09e20bc0f57036430c60217c5b34e69fa156b3fbd875a6e3806e71df0811968ef277c97a004f3dc9c2f8a9e646b00117d5b6c1775f6c6c4690669f2f74934fff26f4fdf1807cf13fa668fcb62f6c98151245a8b9dde3cbb6463cbc45193877152950f9d16bd95c6889ccc069fae277a88fc926812ebb92fbb2492ef114036cb9f8e515883fd6a78ab6edd30ed82236a8aa9d1d0dd4b8d35f7520c7a2b34da6901bd718d2923aed06ce367f01948f6d1507583401992d96c13eaafc28b2896df5431ff9c3706443b528881bc4f9bc8fe01e409b20960ce1b01c250c558b7c6eca3164b045512792f29007cda05b3230eee9e0c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
