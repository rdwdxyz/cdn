<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb1903c6b3eb69c41e6697a921ec234ea7dc1252cba8bcea627781ac34ee02335b9dce545c7a9b1e67afb3d7a4632b0385e6e27ffb4ac445d723eb8fd91630d9bd79a3889ca412e92021b8b2caeffcdf067c2e902076f4b4466ba4db54f143e5c984282dc30048cbcabf75f7c4efa319d55f5b5cd76f7180737717bc7df91bd25ca97e83a54bf4b8fab11f84ffaeb32b35e8ed5674a75e89ff7ceaba3b7eadfbff09230b16ecaa5a1fbf88a0ed00ec356e540952ffff7e4e1f6d56882a0e27edb793b4020c7c21892bf29f8599b6bb2f817bcade74e8b49ae99c341007c0e3953c0308cc0b040fb7889ccb5e16d5efccf7d9ec2d24aca4f2daf2e73a01fe62b90e763d155a185ec3c326e7dc77aeb46649d60947bc6d1fb541cdbc3463c576ff3a2c3bd1d193952538f264bdc73377c1317e82b0e5e5617b415674398b0b3a2d91b47a4e895527b87628b9b1987bc7b00641a113fdeacaf1ef0e66c5f92f3cf7cc84ebedb2a4d0751e365758208cbc5bc91a3706c81b18daa857948166901b0bcb8b34eda0be0960a849853691bbe9527e521b3d4bea2a2de22d25b97768ef09a569771fbb12e8a77502e8fb5d3a841f72711ab4f7bcede9679360c9126703e162dcd0f699e27c5dd133a3707a4c99893861efe44557c50264d58fec616e02b01c5e5945ed20ccb66cc6322c33612d126c86ae0b386c4c24c9709d929c8cfb57cceb8746c92f52e982ce85d42fc9226a1f904bb18047c6e5f36a24e7861ced13b147c65119f102a6892dc9611e496c8c36d39c25e103873480010bb32953c22907e082550f25d5f69dd7a0c2e1b5d4071d2cc0f2c8c361c03252497573efc58f83682e05c73f77ba643caa145c805510be6d0d8b81fb35e284b517eacbd54b0ffc40b0bc6e702ed774c348db4e358a15ca608642fd336316ec639a55031a79d75429f0bd2da73013bf949934b699f3625cd3486b9f096cc8cae7f59b6d02be815c36b91ddabf8696e86c0cd18e3173c2ceef98565e3ddb1ad9ddcabbdbfd1ecc41cfa2cd64ed552a56c5c6995b84f0febabb412f18650d6dbfedc1d0f223bac2f745c2ab2a36c6c3d3409360254c388b64be923a597c1af3d7233a8d5e8ed6a53a57a3ab838ff0171ac5f86328bd2201b0c10214fafec5d6b279d3c285639a0cada49e466bbe61bb8175efa23702fbf6c25be33e58dd1f1b6c37b2cab744ab2d597eca4f981bc8ba0f17f84e868675908ef02bcd8062a7375f7195fa6d63737ec3ad237324bd49e12ce965bd281501565cf7ff2fd24c7de5bc45e2704687eb2b4fc32d469ee548f41aff227fedd6c5183962afec6ad647c6505c8e72e906925385b499c3ec7eb4cd660f6612bd6203aa79a9f4b26290a81057d5078645a038d2abb6fcf941238de57a203b5a394e0271fda68ec305ab84536891698f34f581891d39eedf8114ae04507c92d9b9351ea954e696be4f421b79034ea813b30490c821d69c8795e56f0de8748209bb21cb046dac3db28ecd5e742d6be9bc7eb63d7f7d54b8a3d8efe1b69371418342aea5dbf146fb42a6d9ccc35672e3b3f3a1d1c1932d3024307e909dd04e71cad7ce1641291b470fc1e6b95d149c0b2720cf1eb7421aae7811f200860f1a2c9b529497715914a91d79e428520d7584f50394b6bc627e47ec64575f07945b106f70d3c9651e31769db67ce36b0d850bf1869e856a066724090ad91c90ee9a3a8eddaf8ebe7208e549ef0dc0edfe45787e09bb0175ff92ba2ad54673a9eee69f4430d82cf3918f357d385bfbcafbe22a9d7c6e39e622e0263c2aebfea82c16c6a035fb9afa71d687d637a30f2e39b155ebdb447607f642766f9196d7f0dc296b2b921a6bed72bb2ae1ad29b206a7b0d09605c697f069856610d443d6d19b758acac3b595d4ff34b784af894b00ecfbd37293b401733202fac42f27a6abfbdd61610377b262c08d59386372d404d6faaa3d7bb5b98ad7e81ca9d22249ce408c1a430301bd287b71e6891be63ddf5052a5163b9959cc112f15f369aa08b3fc945356bfb9c19318f1143b2998ad986c1bca7266790f1206636b571557595980fcfefde1ab4a4223418ff2dc5305c99c9bc37f626176a431b80a5c1eb390e16dc84579f8ec63cae576512d3ca321aaba0caffc7f468eb3dc880e9631324cf5f8d506b7ba1d9d454017d85d6dce5b206e8432cd6cc334c6d52346f8c43c8970f694a7c03dce69fdfa037dc8f37d8d459a6702303db0c52b3dbc21dc45fce887f1a37a2a0fdbd9c67d140c75a3bbd71b01f0db669081e9a2ecae6786c120bdbf6ae1ba27f59c905813b76259f68f23b20aabfaceda40c78f1dd27d40911ced9718729e5da4c659714a4c1548e6e35dee89a13f5755a82ede0b614310a039d791202e03f3eb58d01eee96626539ea0dff91b89f832b9fd1652657129f8e4cad1cd8d868a92e839ab3d6b6abbcc3eb8a8faa02e31500b6f1b848b289fc7080b45cf5a63c166040040c3ae408ba1e22b38bc198f01f720e291f95015e9d730113af6c8ae52d20e4b1fce446504b2a62e1ba3ea3b7cb570ec3e5e12d25987312cd3cef87092d054031fcebdfe22ff1617b6fc634adaabedd9245163c5f8228d5f4866342c8f838134058acf948023865323c5921a6c83b5eeea894ee8bca87a42fd1d93666807aa6c184814ee354d01cf495777aec94d1823fb345ab77416d9d0dcb2266d013ed75d610fffa439a70b563da303ba67e548d79148e067c850ae495b6511ac0ebf3416108bb86a13671a8771ff2c5ff2e2f717ae90fe49ad54a78d033068f4affefcfd931209829261e70e7f1ed0116e5fbee22f7db91d4fd412a336292adb81eed858383b08ecc3ee625c118f79eb824311f282b7edcd2d854b585406d4148545ea9f7dac6c8444cab5893722c1a8f514194a5138f71576a425b80b94d45ce600be4d5d39e1035776a2096fc0bff142faceb47914623b1f3dd244c4cf9f8140d71ba19dbfe079c90e75e9eadc3daef56b326000e821125a1d53f25dc68e48ba558ae8694498e35d9a2859042ed52c42acc6f2767a2cced64dd895c755d70542e1acfdd46e294b46a677ff193d3179d95a01b9031778de6d68c4a555ecc588ec5a77312bf5c2329325dfed533cf32ee1caf8280caf762a406d4820580c773825a984f93fdbf8a58458e7060025a21bb64b12f5dacad53a28cbaae1f4aadabe0ffc15e620c3f1338b6cb266b3430a59dbd3c4ebc48cf376faba68b039c897cbc310d6adbaba880b49ccff8acf89a42eb521c7fc4e7fce82baaa145719cc3fdf23ebcb6d576dbe8a1e3b2747b751fb533fc98775850a4146934e6c98eba98ad291753b9f320d04300bcc5c4e461fbc3828525c661db93595c2359e1ee44800d5e797f040303d6498ad2df353aba657956634f504c277626fbcc8166ee3ff6111e7ca39d979271a4a0c15caa64ead320b584c5f5427c656d4585b4d652f9a78cf359d35387b570988bc575468db31c9dcc0b3837d3c06044448591eb929ce5996150e79ab7505883b982bb6f29a57ead997749f667e7ded496fa2faa93344bcdec315af8d4f7a7c207091db691289c5d7144a34651970105193daa6640a34828bc2d89b4d4a4df5df04061eafd5ba49b28d3c2189a9a595e33b84533a9ac9a525fc13c842df67f4549c5e77809a2d3c759a8b3e3a4ec2ba47cef2ec4941aa890cf1210c052ca3565d3fa3ca790ef8912e9e7b2406124396fa7d97b46c0fe1e69383ed28cdc1843d2f6f4498a7c25cb7951d8eb1051c3645c091f43721895d15b2d2833942cdc03876cc0af7a78defc36f9ee6bebe631a0b11da2da953c689f578007e42d50415c2b450e9c489c103e577f45ea571daf12b372fe715df5893740d604274bad33ec5d6cfb19ab3d3dcef2a3243f73d6955842255fe201f1a8fef0c4ca4439773bad9aea57c7fa615d7f858f1166dc5865105c74d06e38b1b1eab52af691eb5c9d9eb47693f99b98a08ef961f0977c769cfe1f2d8e5d6306286bbee84b3e3e052543c84ef50a10f5d876aa3adbc0dbda5fe0f49bc7ca868feae0934d7465ceea5b08f312a1a38b73b474150cbbada552af1347049fd9d5ae2fcf880f482c1b7990f2a0396bae58f3a158a319f0f3033023910afd2868c883d29027c5642778df1cb28f50bf29e464ec58f93baab3d491e9e6f70f27dad85269c0750980b2e6976e952d26cdaacc724c4222bd87dd333161e68b305e84f3a8cc20677715493f24d829cbd322cfe48f0c69003363bbbb1b619f33ba86de9e78990c472e88be06cf012c797043dd9aa68755a00f07b43fcf6380ae27c1c0cb7b202dd2d2608d855c9b7e00bbfb99505975cddefc47bdcd138d430551f48924c444bf2919d9db6affeda48b8f2b264dc86a7ea5e3527b0a4b2f3934cc274fdc5839616988ebe10d9dca3d38bca5849e2dfd931078702ef4a0cdcd332b1eb077d92996edabe540cfbc44e55c4a50fc04b570847f0cd41785397e746b816fd50e871a16230ca4a55b61422c315e4b8730958a9b90586cfb90084aa071580ce23634c68dde52562e01ef70c4062cb4cefe7c5f820f78547a1c4c820956c7135c16771cf35af2325de405a386a55dcea94db3f0a079eaa8537276e8607c3bc709d481fd2c49f7cdb3a405304f0d74b0f811327c8b9b4e07c175f0f07c9a945b1505f8cc3c32daf73241aa03a028d4bfeae21f9985adfbadb5b4d9d0a9dc8e9b376ff15b3cb94553c987f85969773c00b8c8b1ae22222f0038e07dea8447ea2e0645abe2a0190356638a8485bda3f0664b04cdbe31105c010986becdc1ccc533f783fcb0a4cce8c44f6ee107731a4a3071b71e783c5e64878b2cb862bbb99d4a0523e23c342eec27376123228ba94e44b0ed8baea7e813e55e1a8d2ea4ffccc9cf57eb59a9be16ddd3306b1501048e993c59e9a06b6509c4f8a8961b2793d049c6d83b3df85ad371c905cd52da912d08123b0b5234944b919727e2b4d88ed61cc35d37f79b6a2e802ee8d04257f107dcfbce33323758aae1c2a7a1a230b92bf8d9131630411ad37e0a1910f11a562c8012dfeaa01ee3792639af41ca08bf681d8900c176f26e62a611455194422afc45677516a6e0e8d0081b831b726d3a04f736cafb827ec89e4f1fda6454bebdae26d839818c8febb4dde4eb85d339a5f30afa2e3c6068b717a4e59408cf421e974a1e40dfd4f6337a770de4531260dd0a2c31d6e00b2e09de58e492fb0e4314a9e4b3c1e24713f2f53d9e339882fd5898ffe3456e82f9b69499e416424313a31779de26d1e5fbc2ed379b3f1e64c1d672295e21a41b89a46f571224a5c6ebfd26526523d99307cc7b57d953841305a292100f935e3874c8f957aea405c7a81863287ad627fb99c4f023fedaf9493ddde0d1b169022e730e596c04df90602d9d2dd69876566e84583c698eacaf8cc734ee30473a2ac70756519c6c9019cdfb0499be0da3cbb93f2fe62fa77757963f3c8a0b0f974d2595f7240e3c20edbfee9634ea3d8c24aa046da61ea7037efcab4fbe6160bc4ad4973a311205471618636ce1657d2f7f0f10b8b3b38836dec0b3910c4ab91952d1a484ba742034b0ff5e9a058cef38d102fb583748a7fe77b03ee48784d11cdf6cc48ace6ac36ab7d17c3eaec00912f5b9beb33ed9e637f79065116c943cc9c9e23c02c28c03369ca3d8e40ea115ec1bbf5ebc1f6652482202d8e6d52366dea32afa04a67ba71f049c8a357a14769e4db294ec4a29591508481e4711935ebc53c9e6243145fb2e25b46b620ff9e37a58fb2dcac316750074260353d9b8b86299e467040e83dc88f6af56da1985dfd3a7ba565fd905732e4003c4b1b4647f9e8eed70608a7f1fabc8872f10c123d7ff18dbf8fa438f6071b787d1b30306e9eebc92f261374ca988fafcb0c05c55432cc979a06330dea26da8cafe4c01f0351c61d7b9a32f5c188e794258eaa0b044621056d4faeb2f4b7c3c07e09d92efd146660a7bc53cd2ac54be6edbd649ed7f0161cc71421835958112267a5d1f755c297a5e1a8a2d05e6034cb4913cbc038c30f03f4e8b4683f5d780ce0fcb4a27f7e98b415968ef104fb83b77e96f863b40ce3501ff6557e6a0d5bc88f355f567e9779b8bc39054acf5bd59b2adae134d06348f5e5a3b02b83195b5400326083a719a637bfc2148c9cd1a0498cb192a5816dd0a546edba5dae8ee64109d023de8cc45cb2c3f798662b821e82e73c2f86d53bd6380d0ec3c3d35e18f3d035424eccacfcc41966c067c22a853bb633dec09e13900f776fbd7077378ada99d850ec1c12f0ffb281be3905fb40ca97e7b60787c69c772714d32b8a3191eb54aae646adb03b8dfa393afdab12c44262c81f2f9b5a5c6d9abf29476333a2b4a2fcb43474fedf1187c9f6eb26d6f5f5fb5e1bac551b04524e11ba867329d6a8a506ed77ef2d8624fcd693fd9834523aac929d2017e9cf216a03fc21aa9e86f43854008f7ab8d1286aeb98de57f109d9907ff454cbdcc1776dfa9ff40ed8924b4ebed9f69384751912481ce0b230ad893892806b91486d6af5425803d457274e8d98a4c1bd84fd89a1da1144c0a051fcead5698b8bc41dd78ceceabf7e55d1f243f9aa51bec5862b0fee73cef5b4e1cb1346b34380acf5be7c618cf934301d20054a4d4a723f4e8425afa62d02c79489fe7727a30429f67935fe6de10ee6092dfae83711475eef0c3bbad7003744c7bddbf8e5aea6b0978e344743d11dcbc2cef9a54f933761f2511ea7b32cc964d8015939de9f5eed9901eaff682b92f1fd262f3f2c5b1115d5d9d2617270e54ec0f75e9cf3ee550843080b006578480a5d433920e897a3f65923b235e16cf5b3a3a31bde2f6fbf2a1ace8f6181577ff5c8bc8d0343729ff4fa06a749d439edc52c6cb38e2097cc3fd94ff5b105900b4ab21d5504651948d63a4f9803caf7e0e868dbaf401f9b00b773230e90a7a386b6d9cdd3faa035ce71368ff0b427dba7cb3d708e6216212b042a4a08de54932256788fd9398ff06b96d265bc3af30aabd67926f12a494afc77756b1daeb0749ba60f8f3b47861d19d4e4eff3b85fdf5dfc35f12862c95ee18fbc2e013b79d11d84a3b474aee4219acdc51f843b10c9d8921f82df75182f0031fb4ed6bff056f9de1f8a9c8e3f29276177c1fed024f47c5e518ff7e97887d17d99489d32693c2b14d43ea6676bb0b7df19fb4b4cd747f3faadd8ad2457f2cff34d437174a1fb9e1af077d793926bfebdc0af0b9a3d929e9037316a439dc02e04378bd1d3df96c517c79857f446b78f671e8cc6c8ed41375c099146db6348f999b3bbcf9458aa57ca24f8b5823e9dbb60db61e8d00d922c094a3cfe069401541bd3224d84a7f108a8c0b6573e2905bdcac72014c2b640b8ce31d4dd9fa86b3278e4ac6c326ea8013c26a10e1ea67db5ebc062f46a6eb11a8b11cf1e3f11db7d2f177ebcb7805c6f36e0382bdbd6cc5d569a100c2eccc3551185ea37aa8bb1af8f620ad07b390f0f01fdb8c6e677f5080e0e0abfcf4b3e30e7579edbd0f8b7174e5d9de63d27a862a5323c6a5ab6b187a5131dd0ccc5543b37d470f922386ccf3d17932ff8068dd894fd99b9b6db946d5d42d933af06c9d8b916b23529b1a4512ad055402a8ad678cec1f4d51d22abd6abfb171fe461300656a0884d543c4d151f20a60eac62405102346d87d8c32b719eabc3358a8f175a2bf6edb7048dc61c0fccd401250ced0feb23912f0892a7859b5f97413e60202665f4bc3a15b791772a023d207704fdb62fa9ac37b3729209e14ddebd32ee494396ee9b34c50a464cb9f2264aa6937db24ac2aca5da80df1bedd5abe307e11927f52e74bb9b47840499e8bf783e105456ac8576b56406ffa16947899dce3fb38c4a7cca3f2c8ca67ac33b7cd07c7338c62e96d3878e021b8c5a179fc41bbb977929564212e682010bef4aa5eac96c4c1b53614597962a253f2d39aaf409ec954f22df4e249dfd85859c00bb0553961e8a3de167267bf731d6bf98f83f5c4b6d64123bed270059a246007d19d713dac086119716d91f1bc546fe7aecc6bd63174b74c7f3ad19dc8551aaba217dad06ada19762a6a209566abc5b9c6c7dabfb9eb0855f20f428511f6e2b0ad8f1e3cd6cea13fb72fcceb1ab93bd8e87ba1b188da68f0578df7f9fb6733850ab23c87ba205ca04acf8f0c0ff6c429520ccf499cc4ccb230b35906106ebc8cdeaa48552d53a96ed1515c9ff265f510db5aa5a4d0b6e602889a48dec48656871a32d748ff11e5f9a3e2b3bd827d6c62a8e2b28681215812de4f610dab9500f1d73bf864039ef497de1f4c4338a121fb47412f2ce5ccf018e174d8f301af433a9af6fb1c14bd6912461a5d7b0c4c62b5c8f5d0d725ab8df35128b9100ee3c5f3a2c70ab82600b8dfde17dd63eed337e46d2d2ca5418f1efedb2300121dd330df5fb369080e3ef94c402385308dc371b1bd1ee994f305fcb69f7f6a1d42643ca4ce198eca785bac9ba62d05b6ae5d98ca25cf9f25484c118b973497fa51805dcffbca3e35a7351dbaefe3d47ca87edc63ec46165b6ac2346b620f8279f4db49cb22bdd2689d34ee000f291f77e06d23e7ff1d99a19e3871f3810f2a87b39dce417501e62dec20f16cce1c17bafa633b84fdb714755333b28f80bbdd729a2b89e052b0d4c5783e37d95ae439aed77c8b5ff4b42b775e52f852e8b583bfd2caf9671ff0d314ca9aa5c02e044a725a17897976af4d33a442c3ed4964cf16bebb4b6bdde1823aefac324224c53309a57cd04b44eb3a018aa63b4cbe6f75b8e367b934a0a421bbb2a24b0624edc4166bb2bc631e7d4f18950cbbd4d9c0fb57563c88a4cecb907e991be3925682e9bf1033aacfdd6b75b99522dccade4b7e0965710b10f925ae59eb36ffb9a6f33afbbe02b45b81f6a679c8784871b94777125172ab486f24e7bc926580abec29b70a31f867d8a02ed0786f7eb3acf4ac94f8c621636702b63998fa2c37bc7857d46b2b3417450bce06258bbb14d50bed9c87898597dfd0cb3af5ce14e660c9a19b069d65d677b6d488006fc0af206f13f92694eec8ac9c04c8edd73c032e99108d110fd36a87e63d5a1ff6ceadec511d499ccadac02873594c0440fa0ec37308f6a7250fec70c9f347e637bc5fa3d70a9ce37947c6f13fb96d79438d5fa02fd8fa6dce9fd6bea718f38e36deeb4b200c07f58a7a01445a31e2dcde15082b556a11b73f4c0d5fed656abbf0817120a536c3f81752cb0903ba767563311d662ebaaf05d5ec258321c12542c6bc1e09d7ee160753767170e0287a9e1f8670df41ed799e343dee1319bb0834eaba4d4a4f20509e030560653f13adc53f3f69bbf634cad62577d30ddab5279d0ef08d919ea863223db1098654dcca2632a6967aec24e6ae49315b2634803fb565e3823255921270c40fe2f2084af4f601dcc8e974c2277f019e62ffb81376f92821e4915655750bb9a1b0a5bb7b5665075b8e948e93761d118fabdfd437341c75312c9bd0480152886c9a3e1fe30eb308811c8bde0efe908f4ee036980a6c2c6a46cc1fec0dd99bb9b91e58800f45e184f72eed675711712238bbf554daf9f6116b54f420bb54edd71da5ae418ee2a11d8823525b657e0987bd33f4fd3bdaa3db0797e5c9d4cd72b4f8c25a8c73dd5a34d70b72be2af0cf4a7004d8ad6322c5174a4f19e98dbddb899c22d7813fb34516a8342fb422ba6ddcd863b025ba44ff37a240a2b2f920f65d828cd4f6d4881782ecbc9beae5b48733ab23619992f049785fa844b4260f2d997a933e6522bcf2403d7392a83abcad493aa79ddf63f17081b6b21eea89cc280b173d79c65bd85849811e4f938fb66245c87b9395f98bfb9403fa6738c50903d3f59a7742823b595cd338d577b850c81be6f1f088466b258403a73bb776529eeae92d2520749d4368824719fdf42c21e39461eb783e329cfdf490ad8d3ed519db11e7b93024f7392f97a3c07dfde3e96a027b4dd0779f36193d4484882510f1f544da3272d25b88b8febd5a707e3878a0aeb899626070fd2285971a32654ccca2555909fd2baa0e2445c4dce62f10ab1d5e1811556312a4356718806c5526d24c7569947c7e7fac24f4bb290b25ab5daf84c540f9a7acb501b726d09e0d0d64f98381672de7d0b8dde48948d663606daebbf57362d25507cbaa355c63b6aa85c9ab7c914b1458f0edbb2cada7480ab168eec0a4ba7cf31419382daaa79ad6d53872056d9bcd4e5f83c4761ebf1b7f4c8514763472016f79b2b583699c5f35827607a5a6986093f1c62cfc3490ef2b072498076409aa323be26f47ca978030d8aff427748ecfd353c9d6cf69ed533463b4ef3704ec057b5f3197a7b0ba222aa7eeb61d3993cda7d58a922cc591b8e285992a63b8c94f9f1b1d2c7907313f7d4a2c42cece524b0e91afde295d65589598f4f419411109bb51a4514ef21a2bbd548cbf915610f0af1b64e491e91271f64505e4186b487bd11d106b392ef5da5bb84c95585bbd677ca7c5e6e782a588290f2bd7fe147c750f5d7b1242015bb9a5c2e9fc4ceaf525e37b33da93830e334f1b6d1206fd6fec9f08d43f3d4732e5ec282fbeb5cc86eff4a1d424af4fd72df96bc88cde0003d69576980064df91e8687384d9594b86862b056e0d167b5e4278fc0a55181a04f483806bc02eb5ce4013da7f91dff77fc1f1a96aa33e2674c8958a8f49e83144892150dc2d849fc02385377bc9c7978702ba518fa749363a6b2446ab07d4f16a0fb7ffe8cb494067b3c0e32a742fed9052f14a5b61753359c134921fa5fbc46c04a9529bd24165280390e7f83c4628676613e77618e4ae71d92bf1afcaf0cbdf48bb291aa5b6b01bd25e6b6bcb4d837f71b85ffe562a9c817aff40b4d3c317ce1de76f2ac202c447f9c086a55cc73d136ec2d14ca957a87ebe27ae4523ce9cc8142a5573e2c3fea06eb8b4045bc34b8ee4a1fd9ed932f33e84c8d4d5d5c5450a92bf68d87f26afae6a3d81fa6bab64df63aae8bd776782584844751ffd288f8ec1c2a766a483c1c421e868dfce16cc2748f821f1d7a2de6665d2c4f7f6619b331b8d02dff8fc2565997e75e0c955bb8dbd4a3c40a0ac93f7ebe7d0aa833d019520af45bfedf9e900e56787795c461b7cae3d6543b0367ca8305f8aa4a8daf9b88ba57afee68955900108bf27c986dcf75006dfba126e21c932afb7520b85b090769ab17ce21e7a1c658804579ce97dc1a6a97bfcfdc9f1d2348ca724789df0d91462e779347600358dfbb1fba8bed376b03458492ebc3c7df7a0df1b198b875048df3480f65c65313895d7704980378d5c1b0221a9e34d21a0bae7b48af7d3c414df03d7cbeee84736a9d4a79db4c9ff355bf0f25fef2f90a2c12d31df844dc7ebc1e79dd418ba0a63f0bbd1bb5544d1f2c94e63a0312f52a17d04992fdddd53f786ad8eca8c50bb6345a55eda6bdd8c99f396d60967af99ee04d92c8216e6becddbddc861e324f22db6566b7e06f4c777a18cf1a6064af7a775796ded40cf193d28a7808276f977c9b5fc4eec309dbd9f112c0d794f12152238717dda1889f2d37ad998478aa3bfa712b1b1994de8dce9b049992d40219b83c005c8271923ba9d039fc19c22953a73f3837e2221626e7ade82100571f77ef184d19e88c5e46a9697cf1c01ca0be863df03982d05c0fb97ac44cf96bd202bc8a80dbb59a2ecd88816f8778fe12e77a433c94d2708c188bf72e4531ef8f191a3668012620f9b1f5ed73f439decf2e74726aa59b12f92ea8f9b2eadde63dea442880d80ce741a7dea24180343e0e17c40271467324f5462e79587d0f7dc99bf14b93dfebd99c797068a9679f42ba57316e0f2a260f35af07e90f5735a0717435b3e855593dce2029bbb1afc9ea400f93a0ff31935ce1841cf82193ca6463300af6c10e046c6851cdf5596e327375e04788d670158f9af8f48b7b513a0ed711677175493b3650b0e4a33f61a3df27a3b214decbacfc26d17a868e6dc5c9abd2661d30920fc2248ca1cc70026b35e34d28c33184b30421c94ba1c3b42f2908bf4c60fcabac8135a80f57870c7a7fa2e111082558c99227c0e0520386e765cd439de7f1a42b2f5280d48f4c7a5773f1aa02bfba45ba1ab94101ed495c134a3ca673ce3028aab98d224131c03be7eb059cce2c9ea769f22ebec428b4a3e0a12f504bd4b514272f3e9d29d82e49f4f13dc234893320b9e239c9c5cf3fc2b69bce95f2ebd223db13ed2870cd25dcf858fa66a13434fbdd3df4dd4413ce1d4a7dc63bfcd0aefc1518457b6a3d720e09563ffaa3c52a5c6494eefe9223a9a866e893afcb750fc1ceeadeef38d24036c75bbade08b6e52293a391feee8b5cd6d7ac9d7f60f83d0da78d7b0d2cad8c08711ba906ae480a024d65d9400b2ae1f26b04ce7d8f3457eb70725f578a4f6914b7b69d607ae3bfd67b126af77a018706015bbd834c610ceb0c89095e0cc7dad2b0c0613f75289d029d829837d2bb6f00bf95408d4529adff3814980227f78de07b02984c910f8157a93648dff6ca2af384f6720ba2879106159cff437b00571e0fa9341dd4c55aa01d31803f31b96172b984c17241b99dbcb3575f8472029cffcb4d1da34f778e0dd42be383b8ae72f75725526791cd44c420a2b93db58f07265e94df7c27ce12d0155589e548eee0505b11a13315c8b70e9200f2e0830d1bac4cd47eadca255542e0848f127411abd037792a0126b272322e6035023682b6395be963d5a8cfc98cc2c40c23f13682253ef9a89f7952a955cffbe31c13c261cb51e99babf9bba21fccb9be70e36c9b65f8025aa46367c21256c091254c6055096eaa8c8d01fb77d8da9296cba5d20a40b723b98a4627f1292074779fc285dc101a27a7b34101ed6f7bd8c05f818026a15b87b37ced0e954c382f7a987e5bd63f3527360db209f264c053c95d38015b53889256038692bc8c36e8741e65c0093c083794b2c920b25176aa52bb6d53bbae95f51de81aee21977f7302d1f711aee45dfbbbb4f15209a9ea5a3349e7da915d5dfa0051da8ae54692968982b598d0a2353dec5ec8efb133667ef258fd413ce381a9a1fea6b3c38ac927eea5c2a47189edddaa42d2db30fd790fec40bef9fb12b9043c314ae365c0845ebc04b13a26aca4e6a4df9d9cefdb9113d4d0ab9e02ec62083e9b7ceea2314bc338b8ef3e51b4dab99fccb4312e120b47eda0ac349214f3df0a6000da6ffa4d33de52db421196664e8e4f3d013a4d0bd062250e505634534ece96da36134fac5b9398f8c308e4c6be427a844e0c1892cf50cca3c20cf6acff9daeae144df7b51ddf837f1796692c0de0d2dc74e7a02173374ca2869140502b943ff5e20639bc8ade894865a8b7d8047498cff972f0f9c8f4284d3cb97b889c2ecb3199969ee80f1c32b1c6717584949a3edc07894c4873819f42c721a9e75c6d0c4fb5d5f87cdc98f47d1e73b47755dfb16592315a9b71460ad6020a4c9e6437ecb8c2139c0ee2e91303c3603d52edf02d9b697e2036e8a980868834a67b89950bd31608cbe451e609100f7ccb57ea87f3703bcd63ad23496d398a51697acd356f85dacac0022d16cd179ca6f12f3d93f39f06e2293f410cba86454b71dd79aec455f9d30d805f5d941326b80eba556b95ee4c7b4b93ac735b7857954c4e2398534873c8659cb853612273f3453f5b4e469a3c6328797cacbca60bd7977855df0ddfc251abdca94e5cf9d665611a6365c0fb572803ef610da1f738e8c9f2fb623e242ce21122af63151602f2db60f10c35139fafc054b420ca90845af9a02dc07f5666d98be4bf885222e08e8ea7b0b939677e45b8af59e57010cb9ac0d1a816189b4a51baa048334203d1a1ab3a2fa6b4372a8a5375c22fa2bdf31bd17fb703902360bcf46634e0cb7eba64be7f29dfabab5e55bd35e5fc5772b7aec2f8593b8d29dbbd1887fe4922622d367616d837c4225696b4186e51827f2c25720f05b10c18f86819b7c8449d126c1f60e061a024b2601ec2c44a8d62f63d14f77383ad616f024b2e6f26c4aef59fc1507e79946a94b18dc76407e0401ae4126cc6f65f95b529f34d538a8c274f72650c5b296eeba69708b951660ba515c1b39afa239967f38c9a7f71766c984a12944f54a3409aa61180708f2f3e657894395b7fc38f1c75aa44ce160ce315411de07c778f8a8600e35fe616b54dbde29ce9e22201cb8373b4a380503018750ec795c6baaff7a354559c1ab104ae9550fa9d3002251515529d00ecb153f68be15c8bd21009c100ca98e191b7750f3799d1ce2437af93c1b3cccd7e9a3c6059c18cc030530813611096686bc7079e9102def51b9037d08daacd5809b7f0a434dac19881de6a8e65339d5977fd266747b89109372e4e063875ed48d800a7c9ac4b831358acff301a1fe52671cf8a6cfb1be02df6635de3add6fcf65b5d9cf8ecf7d14b8071255172d1eae426fe2c58424e4ab6fdcc797dbe3f25954c31974baf426ac24183ab3345052036a5e66e02bac107c31725edf965ccea7c811bc0eba21e039caca23404c56d4233b874781e1b485134df2f644e0aaf69b39ed02d343cd8b8e867da4748d658e947350d8c1191a6fd2985bcec1e0af9723663e5fc2d4aff58bbde3705cf5be1d66b83f967791cf8aeec5db424fae7f20042786739ef5b9b053caef3a3069ce453354fdd21ed43a5fbb2fb1bc49f8edb266e0859f299dbbe597286a828d28c8ae52b2fc3163059b159f26154da7e09ec39888e249064dc4d7666d2c1e7d707d04dbae926931079a1792256b568c474027ab0a7bc8818edf9ab539feb5610d722039f6c9a2e590fbd42bf4ddb41e9a1dbfec635c68a624c92c42db961c1878022c2e6ef1d8ede7591409564fb9145c4b6cb41b0c2be72de7bd3f2fa557c044125b92e2bf74474f2fb2c99bc5e7f29cf25de7fed7a5910042273615b96d777fc65c456245afdffefee0c1d0758462097209f465848d08a456d75ae11473c34f7dc0f03a21c09828165e172cf3cbc43453e2500c5100c61d0a1d6f850c0f5b938445938dafb1337143baa1fc3e91eb3179074d55c539b0804489cb0e908295f81e47879ea3be7f5cd7a8d61cc550a5b531d5a81d6eb01de0099cf79b4d686f0da7363179d8476c197dc090c6e4036652d57394e1f6a67a92650482f2a3fc95956298536db82d047f46fad2447265a733c18223bec86f27e6ca128e17f42cdfb5aa75edeee7fa11e40cd051a3acb4c6b360dbafe9910df1ecec1a4470b8ce6c2e7551aad6324eb623ef5625bcaa100297c3bbea1134cfcb097faf603038c026ec14ddb312409eaa64891093ccecc6789786a773b2c0a2a8cb219a75cac15e1538f1be6bb1a23451c71bd6bd85bb3fd2e5c7ee0e39aad8b7bd589ac9481120a77aa5f07a86302fcd7003e32110ac67048a27f0de039168d676b61ae456e93a43672500d5d8930f8eff1cdc6bd0db8e43a18d004838ab5f082a224f200b7dcd4c2b9aa2584be8c0e571dda2e721a8cefeba797f28a7d7f53ea98bac5766bbe1d1dd7be844225ebe79c65d88b83d24787f6cff4bc8cb6ff2f1678fafcfbdcbd91ac4f11f7389a23fcf4721a18e6647084da2604e9e5dc02bcc32aec88467afc81b89e084e5aee971bdc7feaa8c99c5b7aef974b325f852ca44da8414b9d270da1f9fe26a97ab5dd3631332b074f2ee3f3c9c11113784c7af9e5b138e073014fadbf91ed115db36f0fb8ca558a16e74c558756161216e50413aa5c542c8bfb64197f365cd7342105512689967922962bbec85a845d33046cc3024af4783eab06c6c67a92863fe0382b81a7e482902cbcddf4927d5156b5d30e3ff894d7ffc9d276b3cb2154786f38734bab7c0dd02c9a9a7cb7f1b295b8c1547e7ef16ee053b906eb1c1b247daebc76727a5b2f7015dec29632c376aaa26e9062ce52fb203f5db8be0635061ea9d03a18c5d891d6a65b3b049e961398bf7ba325821ba634372db573c26e950e08edbe0e01b54e8a7e61e9205e2838c0c1668b1f6654aa9861850670ba7699f0bff4f487a06508f8d5ac0745d96e90fbf344bfab535ca577982afa5ede6318a7c5d43971e91f96ce92d7a05e584c9ac024e0467da5371dae168928c78abeeabb3e931cdcfcde5ac892d0605f4baf318d61cf3160bddd00a2e4e643ada207e9e9913454c0e509318ecf4842e580b68340ffb75297825a469b685fb9b48f21acc21b82c74d1e4cb86cd64dbc196bd0f712ee420ad9490b32c1d11b7c8fd32411fcdfe5ff95d1ffc90e1649a5d91cd0263a9e2ffd45358545b5703b1ba40aea95d3687d4796199b9116fdf06136e6d3d3a4eeedf28bcced838b200fdcee3c43db5e66d8ce742e16c0e68e93e74c85e814e280cf488ffc484181e7d8579ce8e888f585ec4354248f9c6e0deb4fb0427291a6c2df8c1ed0244fed3ea6c2fa1712c22dfdf1aa788b3dac70b4ea11ce1b36ed7a7a7757f0e0971e26df7bb07ee8db6f3945c6d53e3b8f201b516d2dc54226e179ba0906827aebe548004b48ea5f5078704f1aa2ae4e03487260915cddeec128a5fee8fe2a1f06ce42639c79df2a3d49eab4469bdd20cae7e8d84999b0f543479269da4c6609cbcf1f42954f6e3363a048bfcc2715aea08d00d43e1497fc73b5413e53f7ca457f7789a99d79829b0a2a115e4284754a4c26df1492251cdaac971775273bf272315aa35d712e3e2baffd50e134ed6e3c21d0a24a13f02259b1b6b2ecd14bba05ef1a37ab32b3f45187552e3ff56021d9419dc0413224d84956bc8ed1bbe8ac0e6e2ec2123f182637efee99237f544d81a84f16d2d745fe06d25c346a7f881c270b7a2d7d0da27307357c10c7daa30b367e2b11d88f2d06a8550365eac49cccad6d86fce42d3910fca9a3d082f1e1073282fec95a977916ef4ef801993cdd393b565aee53d77b9128cba772ed65cb97049143df7c4d1b2429514da22f6a3908f48f9ca257f4410d5fce2297fed3a149688f4ddd65d0f0437b713df9d8c9656def9edfc89c054447b1ce126e590e0d6d60c1883573984ab6085842da6a6e5ed955d5e965eb547559e0e7b81241989fee7a73f2e4bd8948d5c5c8c070130c4579caf71587311489d576a0b700ae5a77d5409a2f92e13a0c00138dd085303f476370d47c447d412e89fb25b2967c9ab9aa4f973638c601d0750bf7da1d105f91d89c7f9f4814677f64381376260c66596bfcf1cae8159d4541c86df2db237ab5bca577b8dad4c612b2dbf298eaf68932b4b2a6d7fe1ce5f4a45129337f711003d35cff3253206e71b0e9e878383a4af3ecd170d19359734451dce2f9484e022a1e50108801c84eaf8d59ff8900d9b205b88be68c374f2b6e99acdcb0b80eef5c7df7264ccf625070b6200efdbbc4b2fb185c302141d2f87a7e5e7bb02779f8579eb8b3e6d4fd0e35c18a9438bef3471f5d0cf0f3d983f3871e150020cfa575443e040309c58fe160a53184585b017552c22e5b9a4ea932aa9277b18a666141a4fea7b755eb710ef986b045f219600266020bb776c8e1902155ff61d192f16f440ba7452fa26a94ae5abea7ad973cc5a982d8cc6fe86dc17f416a31fdab6a9080e68838cc176742f9881ab77aa9a08f8de7a7aa3b092cb1b04c386087cecf65b79bd68321e8233ef0d120f51f5719162efd6bb4997e6190bec4b720cf91ab7e7a521c43d219fa09534c62f6196ead80f83e681a6ec2f2488090a9f4ab1e6b5268b0fa3c83bf4475c64913717c0ebafad78c6c6f5fddc8a99817b8f36068183149bf8901534110fae308a2dc462f683665e9a68c4874808a019d1861bdba11de86af178dc524d8e3a2277ae90567457a16271541573e9f90dc152ffac41d97cd4c503aabb959fc07ccf3533492318e394dfe6f55cccc14dd06832fd84","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
