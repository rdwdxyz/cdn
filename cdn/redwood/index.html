<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15c5a912543226a834fca4573b2daa78b657c94e60a262ad493c69d31b13e99f885ccd6b748d88c9a5dcf088598d8925f36f19506b15a20487028fa1ce1931fb6fb9d9e5d5f4c5c095a0d5f62f160023e17262b44e7b40ad18d9787925102bffd0658f64a627838d0cbc3d224079fa461233e08668be42aa2f4e3fbe8e130274bb6fe9ad0d16017189d261d29a6c845388ca80b138e59917fa0e15795605d7c256c863aad904c70301eb8b654009b534f89ee3b56b2f65903b63abd700de6ee92232706b6dc7a11694824e3d803d40aec40132867713ec894b40455edc5533af8cfb3c1d60a0952eec99ab158548c49d22d71b7f353f5e675937c3573fbc9dbe60f0f1c7ce17406241d660e9dfe3c802aa6f53075997093adc6e2a9515159ef0414d18cc0a4432f6f91d702559b44f2c83cc5e1f22f4b5c0ab9a90f35c08cd0f10517f9002eca7662feacfb64d47e7b70356751b11e3d578af095d2e2a5621fdc0c2ea296306cecbb375acce095e0c6d6e70f2d3453c8f9d24630a9e56463f87d24e110d1f72c821d2886d268f9998ea70734b30d1417158ed398306af49944543a9eff39d057bb5383cb1ad776e47cc5d2e846bf46d40628d254cf39457b8e607f0d557c86579df0f89b972f066d9ea0487198512f514ad65c80bffa592fefc09bdce47e788b22aeb88be19ec5ab002d92107e21106187d55002a4cd26111ec02d19829f9a993ebabbcfb3d7c33c782883cf80420395f47123ab8f71113cdcf9e3640a736bcbd90ea23c09e937820d8d17ceffcf6c41d14affcfb0352281ba6425624ac778102a814b303069e3f44ed0a4a4db950f15bffc380a15b924e021d7853249fbac2603dbfa712577aa114156dfa8cebef24c4b55574b06653f6d1776eb5bb2ae7d6420ec35ab9b6f59e573a93b77c6a65dd8e8b85ba0a832f88e08a1e7028c2b400710d8a29468e713fac364ae7703ed4334142a8246e51b771c96ca1e0100cc6c6410faaa7f9c7e860263f0b24f5e72f31ed779423dc8511baf628f87e1124098035f6eff2ee04e7f292d9f76fdc1d6fca86351151bdf3735c334322b7b6179cb3503d9a7723cca7965daf52e259961cabbb242e94f1d4f8918d1c75f5353de5d9e26a46a5a8631aecbd90cc5b16b4f93bf18543dbc7e68a9d50671b039d495525cfbfb6f5679172117d727be65f67825e2c6a8cf65ec9390b3687f9569b5024c4c22616cc5b0d4ec1a38c341acf9bb3c5a9523d9c3768ec2e7d9b16b09b9f2e832c88195954036ea602ff5439ddb74bc0186f1978da6cb127892ca60b31de8cd294f3b2acec8ed4c219f4c25347ed1c27825f7b7732f874aed411e24d9ccdc16feb78bb15d0c0a034bd8f6cb0e36d35768f9a4903f7d110f2193ae1206924b02b2f4a8e17de51b7a2ed63da205344a9705d1986aa65fbba46da14f7f349edb9f69a83cc23d4f290ba799ffb2b7308dcabd93f1980529d3d325ddf1cf4f19af4d75ed5b5a286ca93229a533a024a2989f1187a9322f38e1709261765499f90be50bdeb452fb21bc223be74c0d9bb0995b26ac15723008035c0a54af56c7a9ec145505a95cbb666ebafb639553117bf80a02e9a66ec341063dcdf56e0046c0ba63a2aa19214285998e89b071fea8656b215e0c96e17c814206b9a04e75de98e14e4c53c6460281b9d49e4e7baf38261a6eb1c857226ed48176d66fafd376a9e2977db25114eedce3d87f0fa223f8874f36f75f5805649a04873bfaa8b45f194d97d42c7fb526104a8c53508a1b6393004fcab5cb968abdced9312ef81a053684452f16b19f910f53d0726ae957a0b52e9da830d5ab9b1c73802c95921ccb391ce334fedfad537eedcf2595b8082c1b4b4ecbc7955f1d33fafd12b4dc4a6ca4ad558a6470f71ca048db71663dc7ccf76fc742aeb146b32426d4467ff0f116d7e8197631cf417d41f1b16705bd10b6b6fefdd73d08ad9982ca7c0ec368fccac5d045e3a3a05e4d25f3ff6a2d63bc95f1d0acefbcd72220b3e9e804d582a2716c61bd8d12f24ee4da91e0edad1ce7232a161a386f038881cff1c15bc679770339b362719faa729b530c415aeaab8c86958046aff1afdcd87a07bd80448d7f36396bfae0872d9744bde3b9414820fb27a02d21a1c6ee2c95e537ca41f962df03ca416944f08f879697c78f43f96fceb8db65d278ee7991eec8a4d5f3648251a4b8df910dbd6cbb292d40de5fcd207c6047c0a35a25e4a9fb55bd44793a4f1b5e2ede5b35889c80277948dea47c45556c897abe3c62783f2889326a5f5edcc5a7365b073a8c59d5f26222cdf81532ab337a4b46735e53062f62749cd32ba687032d94395c56f58b50a8c9b00e6408ded5e5b6fffce0a64a6d925ce628b3e5b293f33c884dcbdcb57deb5bb08a362232f7513c4acc9b28e327e9ec4ee738827bf3180937a63850da739fd99b0d54fbc461d7ebdbc37667bb3e07a0361e91e0f274e736531c5de902a513514f49bd542b7de4a9798f75df73413c496c775bc0cca1f06201aa46857ebc32de6ec9c6b89521ab2eb96a45b994a2661469de278b7cfe58cd8dbf04966c17c342b7950bfc414cae5ff1ae0a7145be51be154aa3887fe2527bb7b19ab8467e77d6515fbc30c7c0fd681928bd743f3b65c160875584a2f225bfacafce76d339de79a967a0dbb2d1bb1f2c484827bafe128a92d76a26fe8d9619e3fc703d7dbc7bd7fd1d34afd896e2cbf649b3d0b20ad29d5407b94fe8fee9e5e000d634960cff51e70d2faf143d0ccce39e440b34be3d2d37c7a05bd22d591aaae3031262aab7d7e6ce1960c9c3ceec67e40c1a0f34b58a56a73aaebd026539e1ad0c8b18f4b73e66aee174af92525dbb11585908d38dc878055de4820230c6bef72f6a6cc6c4e1f7a2346fafa06181743411b0dd141a890322dd9ba0c99f5c5717dd514ef6ed99ed96f6f9468bc9663716d6c3f3dc1bbb95740f897cbfd65f649bededdb1710413b18f705b886edba487cc467f13ed7a2f9cb932d5a1485e8ec9bc81fb03b76786bfc70c27b03acd8b4d7b1dcaa6d58f6b90b9889ec6eb47ca65d87afb8fa77ac0997336b7800feab3255acd35a1735b69473f6d12aeac0b86e1b5ced94bae6cb459806ff9659fcdf37055b29823cd3b97df8e59d69cb8ef02367c1b125a4bf5b1407365c480355e4f74b407dbb6254daa337fe980d447ab208867e7c0f886453748d22efaf6ba27b4b61781f77802a31d423724bb01aa971fcbbe43abdc04c9e7450b9077d7ab28d2ac3990f9ab3bbefa6d3bf26b0f89a231d8719384f0a4252148c0f153540067dfc4a1398c4390c1e448c2c7023687ad6da78b2833c8e9a6571e2c31339572b2449ad1d081052f44e861629a4360d9e8b3cd486fe572a9b53cb34c3733abbdf149930ad6870849f462c216eccf015f5b79fc61e3a9a3e79c756ecc0bfde975d6ef5290282470d6b8a23173c1f4b94a6cb6ba89b610a67507b035d6049316df43cc0478ed2c60bdaece0e881ac5cf2a589297d77aafdc6cd9c2e954da0d40c787e021db3b55d49a0f1b365811fa729e32fab9119bbd080fbddd31ba4ff89fc2a0dbd93e4254d7019369deae0e59d3dcefaa6abdb2009a3ec9aa6b688352262c06028e70af42f7cf879d342769608e4f0f2bf71d71b3a39d126b4db894d163b3531ea3389722e9eac47d1cf2bd76496ada69271244cd5c0d99a6e07f33108befa3d390ff365e6fd52025509318003a58735e2b17d13671d17272a86bc33bdcf88b20115b72196d198fe12e542b216fd927aad3138dc6143fe43be25e570b9eb6afeac32906981e66c02d470d3718e0b9d1db0083fab1ba579df3eaacafe380c3c83eff9b2504b903c84a4bffea372d9cc0a3ce0bd60ad4248dbe9e09866d92c6b1414791ec4e1bfbc41b3f146af13b14d235ebc89105467221e9b9f5db8ef2f8cd645006a5abf9012b8f819ddf69aea0bfa9f325d605b7e3e05a3f78303d29e29322d41f479578cb1bc38280921788379ac0f8a30e238787f82c3d2d5b9c1778ae70e73ec6999440bfbc70190e2dfc0190e407ccb537b55bde8a6b447aeb4ff830d1030e47c82d0adf0b246b903e9cb7df4b49b7a72735ffddd413681ce71a8dee603c1fe80e686d095698abd00ed7db31647dc01e4d58a999775bef7459df2acbe9279c624ea1fa19a5524a7d1403c4a2f26973eadcc1d86b9c4cda9dffc1884a21958fb42cc2659d59174ab02eb6acb25a0c938c178a8a549aede437ff536af10fd4614ac43c34df8ad9f903db8604ca815efa738453411921a5a54e69ea87230a20c17d1f786aade9d002586ee9b23d340397a28efce18897dc23548c1a88d2954d9eb2009b95a24a2280343f1dccc3f179da41aac45c1fcd2e96455568432ec2fd8c7fdbcb1e56c2388bb005ec0d54d812b8e4746698a5abcf5ec0c9f7e27b1d0d88e5f06cf0ed713c1c4be590c004ac9b155cce8938c94c0050287e6d114f59c8cccf3ec205b07ac8b44de1258041a45d24cb358cec22f6c112f9a5e25b770dd533fd8dc9546905b55e368ccf2665dcadddd533d32a5c5bc304f2e8e6a52e576d0ad52510d1e885d00f36f479b4d4c9517070a959b15aa4c67a415111b153a77fe47a6c91159afa5a28bf3ad61ac787ac2d7dac824661822041de0791f314d929d9d1734a519a8869f1fedd7bff80f3347741d9c896348fccea134a6ea09be518f6f6c0497ae09aebf26985acab78e5bb6a5837cc578e04cc62c87ae334ab63f9b85e28ca1fa2ef42401430ac64b5f20ddb841d7cbe54070966d5e7bdcf81cb74ae292d5484a7f1b969ee8b91576e8807d34feb749ded3ee8ec95bc73c8ad7e712aab6a40794cfadf1f4f9fd5daa2037df759410f7d5bc5896975a416e4ca7829517755ca39c2e83a9ee4639ac550b6a488255db5a9dedd7927097d1502ebc534dfe5aba26753232b5849821408c1c08b05f15bd60a9bc267fd2628d7fc71992aeedac4ea4f73740ce5b81a7b5670ee6de28a35f2acc1596c863f66695cdbe2488bbc4caa5b44567a7e1617637450ffbec0ab46ff9cbf959532ad260b5f5dda12f149010dd6502decd5198429f161cce49f22d9d4b2f27a11d13da0fcf2dcd31705a245f2f55af94d291d4e07124f13c085c4438be8cdd4becd126a641dbc184e30d83c019452fffd5a0b2535bdf9172d81e43c4d9d739cc11b2ee75e1ead2d27e08a77574e7568cbb07a4a0cb42aa4cb34ceec1957de7cbb9d319b07ef89e16b4fb83b07e189421fcac05e4c0dc276c499291f1164a1f9d1d368e1c13752074a79aa78ba480682d71a553e5f982a1ae06da38c53c1701801e180702c3e62407e9b2ffb5f5902bede4f74f3daaa5593408b99ceeb31f27fc18257cbcb031f843cd3ae44325f950024e217909ed16941a1b89fad5a127efa5f1beb26e1e699fc5fa286f10f4605841a37b2f06f87ba6f27dbc69da70cbacb4299d1e1ad4d4539a09c027d806543ae40169277b468ab554803f0fbba5e8c7ca58ac829c3c251103d315dd6377edb2643d37c7642a9f73643c32db2598983951a886b8f5f6fdaf5cf400a2aa94e9e63e76ab1bd008a0cd50e33f94dc9e6ef7f260edee2027f5e4116dddceceaf9d8d8c17b127ea348dd080998402ef3d0797b1b126c6992cdf353ffd5d00355076237e2248b7539dde45bf5527617e3190dc9ad334b3d40ca0bb9a1c6b0eede6c1a51f4955fb50854b0447da2b24e27a36acc1170bf1578b4f69d2e7123c2bafc7acbf794b60db45c0817d998cd4dbf0c86a028c8ff272cb33258d6af0c64634382b20a865da1d83aebd88204fd239f4b55ebc9e84686dccd139f0dad71ebdf7eea93d9802b1eff3d7f304dc3a7e4fd1e815181ef23339add92fe6cef95daf403f9a793876143ecaa5aad9fc041d655c1d517551ffa2b0848209d3c674a38b9f9c2ef0cd46cb872f770165ffce2009669af766b603fd1d6e1969f898963881a79cd5707a497423093a57b69939715f1a37c7a223d9295f9ca894931fc81815d8edc968beefbf0a83247b93adab33a48808a38a7f41d2252d4b02fe5d274f9537f80bcd2e725dad8983cbd3da6e86608c17fc9316098a8d58f262bbfd0934724f7f0a816f5efbbbea756919dcddcd2c6574382ff0221b5a69457ab481c0942314a28fbd1641a6479d9b3e18a9fab605f513f4eb7c52aef98380c8ea13f16e115b1af3eef3887953ca4396a7263ba4d6db0450794f46fe2953af3c1f20990c7e6623136fd5ab6109e149e197e78e6a01761496b77678f5e85590d65fb6949407aadf2b09a6564b3877466cb221ab9f252a999c15d4ab51c728a339d0c74c2f69fa13d8c7599adf18284e10bd71c567908f40d5a98c489db5cf6170814052fb2d88708d4b085debc562d2d203ad252e9ff965e07c83f3164193c1d6f57c8b6ae8a901f63f60323d9dec79ee0cb1411e39199bd7b4cb21f065377d20956755fc1cc952504559c8e52c6b3ec9607805eb85627b08b4549c9d6b8c3b415ad449219e1d882685cfd901f13f9d01d262a4d9436bc2c92b9d461e0a1110730ff8788c9e796b6c2b1bd8edd29918855d8fc9f7fe30bd5fd5bf22aa869928b91a6e31ea534c3f816f695cc8e8945e9bb813d746dfe2243fc2118ec4407b56a733e69e389c4bbe2042ff8df06fbda64c53524c2012b62fdd5ada480a19f39593784f33779e84553ad2432bf9441fb9615d2c516e8844fe68e705df3f80adc57b922323231e3f010af7fda2c58559606e13f2f2913b2593fd0f842f248f8ccff15b6ee8101f3c96b7691e67a5b99840ab90bde46bd1927ec5f0d008e7d2ec1352ff4dd1db96342d1a0a797fd76194fa74ab09849f7b9dc4e1acebc9258bd7a8dd5345953c28fe993f0c88bb5d77c217ec8185b5195247781d134dca1e089441a4ea86cdb75ff512d3261b0a93cc6c2f0336f95c95c1a5fad7d8cbf9ed1c236ca2a67d66aede99f74c51e610c402dd5d4710552c02c0aabc9ea1957830dd071af7001a1b855a9d14ba58525953fcda1147c38494d8ca9ac40e9ac218ea41fa755d9e28fa870ef3285be5fe51b5e79ec1f838e5312f7f0bf12231ffaa2c4b0aa6c60e23e277b870ddfeb473d41f1683e7df8e252ded62a979c86870b66833904312c1a56b916d9fbfdda175dd970c290f16384dc17451a6ee7ed6b87cc1c24111e90250f97d52d9e0dbf9bbaf8028fbaac38e99cc687bcf2c9dc3e00fc30017c5ad8727f49d30673155848babb831e3bb66e99371a3239de2b256b2e5d70315132d04b9c5b0118eef3de7c7d3aa86f912ca68bbeef1de01028a5757d6780e434f3939dc04fcc4666bc5cec5abf15119e0ffbcd06be292adc51588d4890b6a36bf404a672c7a49417ca9c4843944ac7af2b4ef4fba944fbc0b1e8c4012c2fe3d76c4826ebdacb70fbda447d32effe5d2a89649236dd298dbda7fcc2a43d073fd3dcb4963984ef9d89f3de1641d5728e4f8c263b4b2010b0d0b53214dc77247bbd3a50116b5ab77d72c8b8229096ffd4a67c1438d98c8c676a633fab7541c019e72d08498902b80babd668b602ac1ff06f882b3bc69db40b272fc072ba93d0f7498ea5da27f9b673f6ab5d77d957a1d768219653a2e63bd04c83e714402c6f6e68d32a8c6017ec76777964f61e7d22db85065a7f62d572eda8294b83faab4954d3a6db9b27dbc7b8cc7aa5bcebdc81c035acaea83d74b5716480a3b8dbebe0a2d766a0982d092b5887236430a6563e47749642091ca56ef4e88e704a0b72546da82b00ee20592ae54a00216983f34d76ec07a44fff87df88187f285c4e083361e3e0347fb8370315511870b7632904ff3af93299292da4ab92fdc7d9e92dace19912d0baac657fd21c744662c1fbbe326afaface8e5d442abac5873ad965f76a45d39da1c3f024d3a522e96c652657654a2eebeb34bde136cd27f9ed93ffa17d4cff2a19396aa084b0b0958315979ffe6d832a9078f328026300fcc66eaeaeb7c9998a7d6addf431ba3552846a0069d906fe8d9f1a6450f8b2ad4bbaa55ee8fb3a8beda0426469f16e33127ecfacc953fc133c0c41dd4f9264749a0e99a3c11f882db58f66747d069b3d2d9236677fca8d6ee51e7505b4cf253aaad099009cee30bee71f60ce906a448fd33cb9c8ccf94d692d27704f7a126c3d00903b81a843a6dc240c3801f22d0bde21ce5cbb96f6698e26ce4ea2b2857f75d95dd56aae2ef4ff1698df0cf721e20521513457d58dd3d591aceb6252baba63df39ff9c228b04d5fc05ace742d7cd5f3656727f5ef65ef855ab16ee7c4390d65ce765db0ac8e84de666cc4bf5993a9c801213b79eedd72e6bfa6663660a671e8d68467f0dcbaa344802824427db3b67ce38237a8486c529466c9c596891d3b0fef3a31b5de3d38173eeae2f307be2742d5c8ad86b1dafb5dd105e66f7651ad7885186ddea3a652073dfcd8f0ab4cbd5d5de7503b34fb0916a898fb15764dc696e1b46d8c5467a29974c0e119366d98a77dfbfaa31f28f710e735b7cc938ff947ccc1579e8d3e83dc6782d9de570a92e55d375ede59d990457a526dfc129726d92bd0e12c14c2a6db106772237aff0971a4bdbe481f886d17d0df7194a36dc7397ff81e0dd71569b314d50e84f8cbf8a22c49b3b9f422e268bab63a202aa6c8e909ac3090dbeefbaafd8014eb5e5e11f4321b45d32547407391bf6c62d7630bc9fc4850e59903009144747c8cc654b8b769e37dcd59a4754d45ec31df08d9e56e9f1ddf33854d5f0bb396eb67a8442a19b45170845ca9142be7f5aaa91575384db03360c0d6e505ff6c8d7c2b70445cd25a5b371c27bf53aca4bbb8be98c7f7a5417fd5d3a5d89ba0185b379facdf3ff64604a5b2fc05748b4f9abd05329cd0fcc2e0815e5bff6ab8271c9840e253a3c961c941e2abc20ad334b893901d3addb1358951f61b9f839c8bbdf1333e06124dcff1b7a7caad06baadc3e71cb65115340b663067cfad9a7397a6232730853bf8777aeb38eaf733bb18c964a94ffe400be5b61a0a504a8c9a344c3351f3d8300f68105f25862eda48f524da9049cc5b71edb19ff124bee667bc11edfff8715bd19edc8c925240d8e7deb2c94003636b74575d901bac25bad1f8b1cc08e678c22107ee1c5090ef757b93c6f0aa35310dc55176439c044ef50b62e7bac3c68be09a0046420e2b3921885b3479f591d51cfdb5bd7ae62c4bcfcac9be682aa14c3de5837cafb6bb3e5035cc6899676f7dbe42288205f405a303498bccc0749d9d1a5c977f0d24e029389f2804a9bc2c521ee2d3650e8b6f1afe2ae6874381048ea6deb40b27309c020ecb14a666f7e5dff33b45b7e1f62b205758469a888df6651cfe148b67b5395598bb2d6df7e77c322af55cf080becfb9691b6c33d5f9d352bedf4b587b10f3edb92999e2c15dbd67d6f0256fbacde36ed431ad7749d4510faa66e4966ae30461dacef4ce43db905042189e1a3fc9d1871cfd6581d2bc683452a3ddfcd9d1e0a3ebed5f55721566452505546ef5d882691a48d880655225f8003029f396e605d1258d32cd7b75303e621c146a8f4392fa6f1b8be27e4c3b8e5f95a935f71177b21d544ad480e115c1257a69859d33d950f2a1518d55c2ed9ea7005ca7eb0d89213875f01553eb4c4fd352e18f9efa83a0666b77395417b91009c8409d87f5bebfa1ed09ca04a00315e3553badc3e432f4cf09499b152b6df16a7d54b23c680b9a34224722402876a9ba0171e84160a04cc91a4385a6533bf84fe353818f343920fe5195ae48e7bc61baaf55142988a23064eca453e52c0cded944c051cfa17c8df39e4a4510c0c525c687cf1822ab1d8ef2389ea0279777a520a003e28a2ac67280cc48e9c509d8280df47ea2eadb87aaab0ef93ff11c7c1ddd6c3c74883a66a328b469a1cb8f8dd5bf726a2c0bbb527dd36602163768d7519f5a61df602f515549600f3197af4a43f592b5739191a80c2dd4bb459b83cd0228186d325cb15b0ab70a6c5d9af138eaa05c36b0d6700248e778ce69d298a9c64755e7fdc97fb5ad8a9b8fcedf219ec5f2d490700833959e5dbc917958da64ddf8d27b4bd5d558da60c436b198becc4e829ecf45a37e777f0ed05f50713a5e36bd6688ffb30a9cddbae1b2b45e5b9c9d4d5eee1684ed4991e959a1e54abf776cea06b9e4dc80366c8c7f321239fc7a595763f6af38a09232dd682561fb5dda9da2a717bb60c4fea9e65c337efec27361cacbe3c7b263b859424f7a7729bb5a2bfa4bad5d6dcb282f299f3763ad36564881fde9e401a6c9f20c6b9190d55c115d8db1f9baac528544a4e658661423e45576c5c1861aca12082c1812d4d8ee2bc1801a216a2880d626a5d1c32a3f836a60ff6f360a456ce1e54ad7eeb422d4093d07c4101f16d40e3f6537bd311356604ea1eff2f47547d91703da6b9af0982995d2730c3bc6b3c47c1780e13ac7bb8e6c40053c7faf6ca85d7ccbb502908d775c40bcf0eb04e3e71927b3aa3344621f878a9a6fbd5f3db119a5e6cbe439e04f2346c62732345248c3f1148ce24d6a6a9c7e9498b2d0d70286bee3b3c8f82547b413fafd16e2ad145afa7be14b98eb01f580dcc3a65e11e331497b92af4ecc77359968d167d98cb0d95d412197a2a22a675daf6e04c5e1e2f0b8775153785458c9b2518886e8b67508a3462f2e357c5579d4eebede652a8e7f7ea675f9dc5a64baeca8d74cf7ef476fc00dedae0a338377963b0cde318c9c21d92ae55025b53aa0e4be826bcfe4746633c59d207f2f73f5c94d8f26dacf337e6fe75a1e7cffee6942152e630d1acc64e2b7313b6cd315b8244f9fb382cd9d5f7390a59c60d05cd8a05ae7db5cad0cd8a38b8049c299833903d1c840a195e1d432646eaadc80ac2e4a1d4b3e4abaf2fb30f06cdf2a5bba404f3c62aea6b42849356c6b92b14e7dc2bba99627823c9046392927af6e072d315682c57ee7f795519eea398f4ab48e5684019a4e0c177ebc82fefe8ca7b6cb67c60ddc0fd8500060c883d4063d887ac9646e35d944af16e41a52401e623bd28626b2a0fa65d7851d142d06190ba1c265328cf6aa0659177358ec1aa27fa468e7058b36a85df4efdf6ee8bb2d29f78f2611207fedef36fd4df1346f1cba2f84841c6cdbc493175d24e213d311b70e9ab897d03b6992a5d2af79dc5d25a36b8a8c2ab6d615876b1c1a1337d4910d0cfce3dc44a959e855056cea545a7b52fea44df8320f3dd140a5f4b995aa3323235efb1f408cda6343b263a01b5a04126c66edc2d19ad68ad90b5ffaad16111b2e33283fd56a346f4a6424cd0aadaaa673a3c6a7183fab59bfe1562071121155b4cb97a5d706ba70820850200208848c5dcbbb648cd00bee24b1d9d77a35dce732790302897910c0165a10b009c12c365bdae461a549a2cecdfb9e562f2011120a3ab56371f21793320ac181c16d98c5730a6b54df7f7465aa8f1e397354872137ec5d4075183ed233eede32d121c68eca5c6fa1cd708c3d40698c9db85f10d909eda9feb68b5189133d35192540ca5ff9b8f693e9b804d8bd120c2d645c8da163d7f168dd10ced12b467399412809b0979c4d8aef1bd47a2e6c150cc265b516aaa5e7b66c2f9d33661de30a5cbcb17fbd2546b4faf3483f857ca5fdf3d5f8fde525e03a6ad21e71ea377ba794aed6c6f14a6b060d2fefdab46eea86579e5cfa2e85590662bbdbc1dc3fd0731f911827e68cdd1fc641f840ad583836e69f26183f5bbec4933ba97ce35907b536aa34ad40e0882fe3f52c32d99aeb93c51da69da5bc0579c3a062e594e9db15b5357d168562b5968433238cae4af5153e72262990ae9ca880b3f17e2662acbe5f45205497da3683bd2defd0be8671cf5f65af872e96ef75c0b549d156328915d0146bd984930a5e43d3c82aabf0b93403e7ec89408fa8a78072a22a9cd5a733c740dfbcf3489253ec3cc990a13dc3720fd61cfa71c7ee08f9d3afd6ba731a90ebc4a8519e10abd4cdf65b987a1dd7011e86c3bb8b8e8087f06f784d0a40f60b346e86e5e6f56ffdfabff558535b41afa047afc06da3dd4e10082cb1f14e0fbbb965f4301ce055e57a8119727189801b2ce7914e0cef61d3134700542e547c80c94cbaf9d2f5f66801d39de20a35c67ab6d1177c3fbe161a476727a6df9adaaab56841502c46b39ad134e9e00b456b71cfcc9df2cef1bc4d63be9265e4d754a0e25be0ffd0f4c0a80181f4137301b4afe2da992ccd2e602d3e8e351f0e654d30807d479a4eed8b85a186df93126dfea6312a83eae11788eb1b481bd8a074b615af41d625790d81f3d75f2f1178578bebafebfc567d1253236c7f9e803b816d937ea3d1f9c9d2db00e7767f8e4aba679d5e3b931a14c759f0e41e11f07bf8e59aa5fc552113c28fc82b18b86e9225f926fd51030c2554f6e275807a18eb555ce993ed4713e53859836df41ccaaad4924d88a522d2e1c72dc2be0411771916379b9117757e9dda6eb684608ce324dc89c40e5c3e97e86a0a5f9eda8abbc50f4f8a6b3d91c2ee67c3debb536ceafd6c7f95e14e006bfab760882a6fb985647ba2a5c27200d32a6c19f186ece355548a3fbb9c2561b72726fa0ab5ebf6be8e747fc1a98f14384b0e5c5c888ab58279730be6e003042ec1a231147ec17210aa9751dcfb303e1f32ca2b6fb50e26d75744380cb155f6d387c31a6352e4b005cdf8db8de6516158f0594ca1ce1d8849553067c9de0261b62456dbbb763eb40a1dd357ebc7da1c437bdcb9d9aed8ac7eeceae0a372c9f40e5e76043cf0eff59639d86e4fbcc32e38e9b235d9ef2a48d71a06ad46980b8090b578a262550ad1578d8b0ad7f218efdd929e01246e8d91dcf59a7007c705c79723c4f46eb5250d67fa1a8a8b1d8e544c91ce89e3d771f4791add28e526da1a41eee6c996150cea7786a46aa96b84ff73568cd15a0c75fbfe7936b4d9cf6180bb2f8309e0cd8b22fa7444ae6b19cbf110bec57ad498918050bc285ed73fab0a84860ab53af425abbc87fc3d19713f4f764f8c08c02c8ca9c7dbc1a02127868f940d9357ff0a4962683b3f9d932447d8f920393658b20438443c1c5bded881c98de818ce81daf2d4105578f21f7c5e740228ca8ba3a4061ea7eac637ece2b81355eb30716f211a02dcefc30dff109c23b27972c7e39476a692c7e56aa1cfb37a43a25b6061b016db7deec46d757ed4706c291bc952604b8e7f8029e66ab67acacde3cf1b21689f812cafcd451575abf0a7fa259624ea29124c160fdf2018551d34c02403eba69055ba8fcf07d0919fa6c5b1a7f45318bc021f95ffef1320180670b631a978f9e163670900f81aef7fa5832f726d00b15e045bc19ac21e7fb7e220c6477e4b82e3f5b85de7bd8ae3c0f2acee1775b547a8e9f0fa9646bb7422d654d76f05e8c7499ffe15758565ae300979975e58fada457af8b13b5a589e285722b2a571ddb83a50cdba61233ee9cf2ac4890ca3ca2b929affaa34d0f137218f309ea247ffe16287fc67dddae6df26d8713859f4f23228e7ecbcb541c1507095dcdc40cbb10a02f211034a874825dc68fc53eedee012d938fe3ce8e68a5897e2c791e3802bc2686555e3ab20863331bf6e27159a04ae9dc4fea2801837c8634736a4316046198c54f874549b7705405b13b44c49c55eecdf5be36187361979ce2d11073d61657f9f14ba494b3b1e1235b8b57b96f0f484a338e6140135de00345875544463b664b23dd827346ca00ebe50bd047bae945851ac94ab826d7bbfb19e4addf45e849a2cd895e461ffc21179431d37628cb92666bceccb32706607933f965fd360ee32aaf039381c33f009f08273c1c01dbb5ad1fbd5ed7e19c255b519bdcf6ef959204019d9d2d26675e593241d50ad7674408d2907124d311b53ae94740777075a614f70dc022e3e66e00f12265757e3214a84ce6635242c04aaeba139365a9a9feec840de843b2c5b093cbf0885d2907b3e7513c7dd107d2a3c8c2ed8506633274dc3199b40cdbae15366b8e308438de7a0c9d3655e9d55fec539f7b9151f1f4ebc000b5162318e44fc2b7dc22c4c476088a1ca272b210a55df434d8369c825d375cef05932a405bf594c74be892fd9f4b994717b665aa2e2c7c1b1ffa28b68f3c5b6768ed8e33c2a5061b624648b133637cd6a13682b55b577c72291374835bbcb1655622548744e779abfb1144516de615cfb405487dcf34cfbb8ca8380d1cfe29705356aa9c6451754561dea5f2a6c8f71b3f69f8e5c5502ab6cce4f852f7f23b1d87e9d570554711e69e61f504b987b51ebdd2e50473bd4c2340338061bc0a8c1723d1be2ae86c0e6601df14e99effdfabcaac57f98609324b28633e2174f2a0559b78167eb196926829d7915f42574bc80adc51b4df29abde07c0068433132d03caf08712d0e1868baccbd347970e5b82494bc0ea7e8636329efe5ca715372926e49b47b382b3ac12c7786efc6aef9bd50578610a8da73055936f140bcdfb0bdfefd10b8edf1532465acc420a721307ce17b42a6ef614d378046d4da0416383e660f398416712a48f43446b0aea21d37bd576ed929438e1572c9b3a39ab6a0bd4ab78f4ed3318f9be12093436f9854f8984e1f0e14e3b212333867ed9d417f306e4ff613ab0a4e41c831d27657b7b29928f2de1eb09af46195eedc5f3fd73f7ed0cc5e54c25d083df294ec2c583b030dae4c5cfa46bcda3056ec2c0135682fbc2a2e0c999670aa3e0b1ae53881b253b7fa5252d2dca48cb480aa33694bbf2846dbdd6658059656399ca59d399cdd664e930fac502a317f6355e7ebf3467fad2739e4fc46c0ae5e308c8c731feed08fe4843b1bbd927f81272f2c97fb3ca23e4f979d4b5adbc99b2b448e8a507723e6a03fc2ea4c15eff943e5122c22317615bfa6f3ca6429444953b0b8f33e613a550a4304f3b913bfde190d14550bde5b19af6f2464b563758c9d37cb995638450c37db61240aa02b045297133cd480dbfb36862fbd4a4c01d3d71cf3be9f14757448161e37e24d8f9690119918baeb468c25461","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
