<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16666f18a7a7c121607f97a61c0ea8550ab97f3385ba5cd4df9614bab6eb1df491d2d10f3257e77f61a1894b5d39c10ae87ebdd0230e08ec959896ba6e629061f60fc1a0ad956f98618b9694c4e7683a3bc72f981b7f72dd1e9a8ea3addfe65ca39688bd8109b465984ce6ea873d2818bb37469f504719be6389bdf3da2dc47a0b4d40e7ed8be313f3c52ca7fdcd1fb4e7482e1c60d1908379a295189366c496f53054abec85734f60523e984aaf05002e53a71f16bf9041943976a7a44e9b0c3d0c88135f3ee4264d37b7c18de8cbbfdd90cc3ea24d780905e57c927647e2053f00f906dbc53816c7d11e0265cbd9d7d98a058e7447129591bda8cb9644bd87ebe559429f767d040cd492b58916e866a23a9239e90ef6815858c20a61913356da93217d4157d03bc470afa89cb18a99cabf50a6a4180a48f4c3013f9139093119ae3f423880bc1576bf0abd9be0a451a8949b34ab69ca7140366bb67e4f40d83b0157f3f40ffbd63b95ff3248efcd67d5745284e598fd6d92b0a7bb86ade7d858a2574ee590089a762de7a7bb2d9049c34a78c53810bd3708bd0c0dc154e34cb53307e1f62a7e1a3e0c66158fae6ce4f79c5eeee9bb31f251aa9a74973b40e29c4f574651cc66f7ca22da1a3953c0f69608831e22831ab59bad8851e21c569c47a01c34b8fb2f3046ae47d0cf6e2493a84848dd6ae85e6b55394313a3b67204b0b11e54e05f6bfbdc16f2e0027e07b774b882af402db992dffdae085b2dffeff8dcbca268039708ac21e63f57da1e0dc7badd844555f2b8e00999b1090ffe200e21bc9682aefca305f2f3374c0f0e8911dff1b2da34298d454b6d77fd5a2d2c405c6240f028efc02d848b4fb3022d960247f0aa45d825324f2623ac2df18f0174d0f55960df0b9fb2a900697ee10b72ed87a2cbcaef17710f550b9c8d7763af983bb140a51280903a28b5fd89a00baa9a83d10dfe689a256154e3a572a7f3226dc4345db3b81a1001443beaec4b6a63c03aa8539324829c831f798d4ba2e979e359529ff755dc26a08e706edb57c26f73075e51e3c076a6b4489dca3ba101bd106d0d7685ee76734563d961ded6840013c49c551fda65701735c755b0991bec0e26f2de0fb34c1d20aea83c9dc5db63613960d62cfa736e58deac921ad8672a12908ef0da2530614b8462e2222323947deb0d07f296964f7471cb8d55490d3a598938f376ac7f60df8591a233780eb07395ec01ac82b6a92d95a03815661552eb45ce32fff65f4f40422d8d1ebba7cc2c9e16fbdae80e336713e5010b5c47a34a7598f3eefbe503ca26ffcb301fa4d3c9d6898e02dc5fe495687bfc70dad4c43d7481766f5d9964c462b8bede4e54f0b4d6614bb3d3b991e28fd39a2f7ff9358109aa23686feed61fbea5e684c3d4a4badea357ba867806273387d8b34251f3732d71ec0f7cd78e622745241b6f8db6a06c0e67d0880db1cf88b465986308061f0b99ee256365fe29b608d7aaef383ab3e90c9f184d99cd9e7e2cdcd88aaa1d86afb7f2c2cb5d7ee7a0fd310011f3e19ef690e4b847255ec2752533e5ccd8817a6efd3597fa994639e4a0a20c12a0b1ce79e1b6c48cc38eb7d9e094a7ac9b47f3ecbc124133304044742e82ad12f7f477d467e59e1eebfdb06112ea3fd7c0f7f7d989c33c3d3082753b8f43d9a780000bfba131a832cc2cab336eed3266d8e25fa6b15e9ce823d7612652678011cb0d566f967fe0d751fd16b5c339e513513f8da316c0e53064b284a4b6156177c5a9e33d67948d0eb5eeb0734018a6d10165ac1fb4f34303520023d26203ff247091427fcfb6868f890b500f003b90db4bfb47ed1456eedb008c3b44d04fa243ea006d6d18e16ad97d1c1879a686bae1e96ec51059ee38e18ab6ec7dcbbeee31f28e482d3cffe80c912cf58ce288c9843b2f202572373cae67919fd377dbcbceebf1274ca10119133eab8ad20e6b8e52f046efd69c1b398e56c7c0fb84b5075b77f1158ec43d11139ff791d055879763629797855f02d42bc10a7bb3768c9ef3ea70772c2dfb37d9c920430a98eceac0b656b755f748b3e7ba37ed2e0216c3088b1969d8894c4f6181b6ff6acaacaf5686cb166983257c6c16327e261faadf09c3878df060128e8b15e60d475634681c32ac20d6247a0667930f0082bdc6d8212ab20951dc551e0eb5c2cfb2f0f3ac7062a12b5cbe8359b261ff00e14ad4ff5667fb3abb1917b937add324818e08f0e25b7767e8ff6d4283d789e6a2bf62aa10c994ee6d841d756a84620aa4587a600087f3effe73c13bb7524c21a4d9cd4eb3b662dd6020b77aa7433fc6248545caac7185a6742d0b272dcf9e8a97b6ee7655b3e7c178c42c2ce2010a7acee54a71115188019f7e791afea444e5286bc4713efc9f7698ae452cefc9773cbcc3a295f2452e8eabcad0fc79b2b8747ca5a0b08184b43e4415bdf413c6b7636b238a4ea6ac8a0db487b5009a6bc3f6537fe7ec84c84c2d1c5155f4cc6f2dc170b30dea4b1687bbb55454a2d872643ef8731ffd86e13793345690ac9c48c26a6d43185f7751be2f37905f4b666ae63928a7d8918bd7dd07d8e11c29a03a4c876ff95bb739ddf90947a580dce0882411bc168891e9627e15f2e36228f6775de8263a21fd97c555cc1db1aea8857ccc0d1ab04e063e9673ca1ff8410e69058832b4223185dcaaf5c1cedf03ba18da0056439f1d4be0323e41ac1550ff3137f3b2907aea40d2fc0663975a02b94cf6b7f8fa3b7f80c7cec339dd5250b76141fe03874e0e0681bc2a7f211b6458e3507349ec68f6f0ee07112e3ce38764f07dcfcacf85ab2034feb6f145ca26f09d846f5ae32f1228e9d32ac4ee0b982f75a28592f4e50238cec8f66078c5d97d791fc9763b0ce4f094dd068df8b71c7520cead02e2504a3098facecb911f88ed41e0d3f0cee21e592cec2807cd8246f4696d907df55a5376b41b7357b222530cad7c7e294c2189f0bb520802bd5fa0231174cda806c2a0ab60253551906263245eb8eaa6c3c1b969b5096674fa4cf97b30faa544fe7cb83376491983b6310a8557d91fa30f26da18cd1f359be5fa25d393821543dbe10e094505ee1638da2995be52aa088f5bc2d1437ed59045d2afc7491fccd2d89b0bf0ae0c45c2aca5b1819ec4735a4951f4b3b40583355cb02368c8f3cd772eabd6463825de88f0d622d7508a8a7ff908a3af1b22c124e233f5fbaa5a28212b6836f711806683442a1f4e3014ed9d121ea323814f87a28bb9844760361e6287b1133b768f1623e5bd4177c71a1b2925ba166b5e3141038293bc7ce46a021e2fa11378d6411a4085c0a87e066aa19f24673fcaf47cf657f7a679998d6924e688fe2847b3b1eb07a635b611497febc653f87bb5f1c4e7658bc2fea3c8279b0d5e0f8bc659c7b707d1cd84ad92941802bb2506183b3bf02338ecd3895112871be336e85463449dd8ec7a928060f0c186fb3289dc513a61b6191c7d733f67ee5c5feee5583b1afe8beee82ffd04893f58fe4a50c9ba0ce2f10f1986a6568a771afbdbf52727de9c00d89ffcb3c8a276a904abfa9e9eefdc5d817c60af3b2c87bacdb20c4ecc02118f6cd74103a10aeb275a92577e3e8bba17f50b2fe10394e162b4b77bcf33abcd17d1dd221dc68a36befba745a9d9a1b272e2b972e6d04e741028be0df488f32ea023931d1493781113bd4e0d8f519afe289cfc50000868508ea78d1aae6183116b21494ebc08fd895a28e3f987f6f720f5f5cfe127559d927845f86937aa115fa6e177c8ac849fe52c14e2c0f5a58920d29056589a1943aa89a3d915a3e7c13c22d6faa712327fdbf05a7ff84dc1b0558f010e1833ed284d194596569eba03ecdbdd9e59feb30a056c96d22bd9c6e3041a410597c6011f5687569747cd02c5e7ccf1a9a0adfa980a452dd8f7ced9fdaf18f31aa6af0a84aa4ae1e1074cfe2c1a2c31c1b9b5b36e33b348f1a830a01754ad3056de703f42a14946e17ce8eedfe5bcd69a76ebc8811698174dcc3e4edc874105d42c0fb4ccfe7a266051521b57278ccf9d00c4cba9d61c398f5efcd50292d3e246dec62b962b208e27be6eb7b7a81bb0ef7babfa05d933185c386023d38fe0edf272e9f986492c4ee6ee49b484d0736281da0cd6c82f8a14ea1d39b24bfa751ad49fb252909b00610eafa79761bbef5e0cb622de53bc1a9e84fa7dc1a943a6b79eb1c54783074aa33a68e9dfcd5022cbbd491991105d33c85f2591a907d3f82da8dd2f4dbef23f7242119403919fbe6b357aca31a9f27a7b0f198f6e505a457278997f4c430cfb3f737e6f9c5b7dbdbcf415996dda8d1531efd4b77da99307b8c6a568d10d408bdf2d6e93a5329aaddbe2ac8692dc04a46590480ec987016836d55ca58da97024723c60d651c31a39557448a24e815fe9dea99eab12fd3fb686921a97fa5409ee761c811b31bf97b09e51d819d11ee9072ef8660967aae73f239a08cef53cff92815e9343ddca6027a8c9d3d232161231ef6f40e350dfb825105d885dfff624ebf05eb69c7c60377a47bcb0674d6251aff758060692e819e384cd6d5756fbeb38b1230bd4943a5191e72f260ff937a08b42c67c1577ed37568fcb4af73a225d567403fd894035515422b84c3afb47d27024f2df6cd8bf710755cf40043befd2c13c570aabf81e5ef57e7beb112eb1e1cde61054e7390c1103226b725d4cdfdfcbbb1c3e9780de95c849057355d438428220dfd1aa399fccb60344dd9fb5da6554d1cd6ffb8f548cad5a3dbd61407bd5df5cf1e42594c1d320b22ae3fc2657b073fb5b7e9f614e1e57f40ac5bd7720fb9ac7d56077d06b4e934dd4e2e07b91fe75fe6690e3290bc4a5857db8f2c429650983e5fd7faa14a1adc6a2d4a3a14d67a929f7a677356e83e8597c354e7860fc75f8cb1a7c8a88def117165f42f489cf3f2ac9d406b6bc7080ac2819c6f0d9033cf206c230b30e6ed61c0e8854973fed98153d39d8075a67c2486f48a84bf94dcdd88a440f32d0a3cec82e44891de5089bb8c0598ce96ad8e17a8d575433e6e8037e59188f016aeb60fb8ef9580105bf6a15131bac3cc460cd0376a07a7342b1729334d8646eae33c36945a0b98b4b6683f8593930b75e37ae0716cd06f0721f92663bf5329ee54de360ca5e472765e7e8b15322f1f692d296156d9937eeeb1f80613ce593a8489c56be2e3ec21c5c2b9bc93f9bb93a87b61e43e6b1effa94772f15bf457b6ecc898524fac0c2e94a8558462b67feb8d294c14fc4e77195079dc19411f2db5ca016ad07a2ffdac5b42f6c992513d399eb12838dfb377e319631ba593507212b701a303195c651f1c17e45aab3074ae672fb21c775f3a6d70297f5259e3af42f44152efb901c7b02c0941cc688d1a37c53d8aaa9a069f4002f3c0d24f84ecd303d3b211378f2e60b8327ef7566908c519f2d7e6bb6f1f77afd8143b357341269659ad2bf7684ecf5ea050bde51c412e1b125466bc0e6e547cedbe4d958a1bca015a7b90a35246b0c3794ed36d8994481d6829aac10630297bbf9d15f5ef0d139614844ebf683a75b5ead83f8b7f732af3c6e68fe4ce5d9a1c56321997d485ad9cf57be7eee8008e97ef3d74c1590e0fcbbebed997010edfbb94142edfaa66c483b121963013de5e849e2f276da8d5897e2839f5127f8840ff090fc1228874fd9ff54e02cfe0a6180c0af06ffa0fcdbcba9d8fc6dbf66a0ad8d58ffb433b66dbcc503749eb0ef6aff67c7af9774e775706c160dd76b70dbab64a68c3c245b1e32ff375e8baabc65777be218bd89c648283d2adb231b53ef35e80b9dbcfc2948ce3105c3628317fc3d1f7e64ad24d253c3bd9993c297fd7b88ff34318f05a655bbba989ab2058d2172b1e44c37f92fcb041865b53c321c8e7192a7590952554692b12aaf67d669a5f4e21aaca50476447a3cf3bc615753db118ca73448051ec0f6c8a52f194d520b3fe9aab6696654cc908a1cceb92cff43345a8780351934e104d4a79dad97ee581e75abde51c681fb137ae51da5768cfad986f785b646cf319f7b9de21a9bc027e8abbdb4e1c248237f863acef73962790d3e4272f57612725707ff53a33c2a71d63573438fdd41b06f302a53f1f871063dd1e96afd5a81e10b438aef8384bee940d61e47ef67a843df8554b1eb27f2aaaac165c8c8e835a0f7b1017c4705f0012836d1bc7f4ae2425906c9258e4d428227e517016455f06527a9eebc36415acc636581d1a32fc2a9f320c3adc1797b694f856d6df569cb449e3198597268d4b48f036cfce8c4b3c63b01f2d49ff045f144dd92477dc5adc855e154a2d438c8d95010e5f7c80bc82f29b24e4c103132a41c29b552176f6dc897bfb3670222a41ce8d4628b038507003c48be54bec69d5bd7438339d59fc7eb86b449130627a44dfab072c0ebf03ca2cd6d2a9d4ff790967ec8b0af41e120e4dad5604f5907b33778a594e0eb9b595f81a3f17e6af3c2a363a053ee5d5090b96cae10f31005b4b9e6111bf90e0617b4865a1cce929a684d5d416e81d69b94c9afc9cfd000469cefda59230f0f5028b95801c9b34b645039ce9a2f0e1f6ab58d59dbfeed990400e656b43346645baf4cf16b17019ce8e436094082950ea7f0623d638a5f2c8610d5d1df5fea82fc2ca4bf6eb94ade80e68ca9134a34e0a8cead51275fec254a75901d49b6bd9a6cd14a1a909bcc0edfe06b49e42df1a423d26ca08cca15f910033a803c4588687053a4c7e17a217266ec03ac32a22f153583b3b1182cdbe1523d512049f4c075fcdc5b495c1b590c8a67932036b9842843f0ffe132d059967c72dac1d36d9fc71cbb1a78b9b0405eb749801f1a3444ec360fb8a2c6127a4a4b89f9dbd8baef77ae36261b97577b001a026aa6f36a1ba682dc6633c7c2ed0b9097ee703d208f6dbc7006fe1a6912a8761f76630b6a10469aec514522c3476d2848d248051912b7450bda9be17c45afd4055018eba878bbcdeaf3f2e13bd3147d83e402ea2fbc4a8091bad71e5492ddf14a4b2157b88d8057a898732825f80b620b84a998e1423d108351bc8bf0dfeda6e5306678e2b6d4a6acde2bfdd4e12ab95a976e208e2d6b24fb3421dcad5fc6f24a0941a6180d9e1fe20bf9214cb20517588e47c49e2655b84f4102f4cc6b2f87b86d6b9b39ae6b059001c36c1d33679b3b51bdf23c241417eba7c9f2353c6f666a53e9e6697eff4386ff5b6ee7f0c913b1c39f04b39c30dd153774267e33efb28219113e3a09038306c35dff633f2ce87ff8d1d238f90920644988c0336108176c7b06bdb64249a43811d517c1e080c297f2d636722d3ecd7e40b81e9b779a75f43312ad0ab23786cf3f98da1df2dc153c0c55d96c875b520dc177d1dcd45e1a882e28111de365b47d0a06010886fedc9323483cba4ff2e95527e3cccddb4d15a0bc33ad1562742168f0bd5bc5dfa4e606b1c07f03faafd3f9492a53c76acf0dbcaf6799388977516d0eeb07e45b5edc738cb4854b9d38227f5c40c7159e6400e1440b441f784eab4312503f5238da7ba6c072f8e769e1c953d6b862d7eb4f1c767534833010e9f145d42d827189df7c95605e771b315f4d54c697008318b067a9d88b5236d958007b6fd87bb556936e66b0d8afd388619b706e30b69605ddd1056844f874abaf1d5a380ce0dcc30e14296d01d81deb454ba1f46fd02128b1812d5a79246148b7ca6cfa09b0c3580ed445b1d599d5270b21dd115b02ef200ae7b738c32a773ed1f66bf190aa5eedb6e3979d8e738692430e312e00260ab41b9cf73b4bb4f5eec714668f2284cf4a5f0d479886850058311811055ac1918540c637feff45542fda2af0686487837d6ee32dc5991b8abd8ad44315141c2f5385450e8bfdcac68cf9e04e86614b7dbf8d173eb01540088b0f147eaa3b7009ec0ed0e6d744378a3a5e2262433013869b5d7e2ba71c3ddab75d8edfd2c5ca386bbccc42a59c56dbaec70dacc14c27725769b6d0e7c26c8c8c0ddcaf58d25d4c22ca34d975e64d9de20c381791476a14d87d26bf6fc792caa990bc0f7c4634b7b5a1d33d4bf9f21fd2c159d866192294d5cf518a7344dd28556ee848a1e057ecd18eced1f275dfe99b49b4e99b6fc69525603b6ea9ba4140e5f5cc431b8a334e20b4374656ac0fc02da2da6715790738b99f2622ea7b31e4a0d1a77461850b781377952f1cc398c4dbf3c4863ba3bca05489336d86ae39a9064d9833757d9ffa0c6dd093d5ba467698b40f161a220d0100109e11dd4d730535a694eb44258ea643fff406e128628104ac6766bb9d4b0184c056f86f57be46682e564309069f435295c8d7550f5bdff840a4ea9df50b8628db7972190a13047af9cdf1379eef13baa06a942a097f3338d8110442249f5d696e3e4f5b8b919318ca88e0b50535b19304e62b539a48b6a88a28f0f301ec758c30fe6979e90db38dc86ef291e5bba967fbac1cd91dc2e188fa273c18d3d9e95e3f29cbf8e7a6a50dc4254ecb5b7e408c67efd3d79afefd3e67f91aefb0aeeb322f1ce16494c9607d399068942c2c1ea4e2eb5ec7ae74ccbeb875d7bb7386833356c965511ff01361414b8755dc210877c6c85e0911c0548ab502ae0d4f29bc4fdbc4e0f007d516bbc523935be0ebe3749b771b29a2bdc03058699a5ec04346bac0938a7b4b4a3711212b3864ca1c1da46a7db3ebc54db064961b1c2a92cbe1c90cdd497478b0a37c78641e5b0bcf0b6357ed9a75d5cfc5adc0c382be3b4a6c5a3219b8b2979ec01adbb77d48f37be2429e12e3f101066f50ab8d612c7bb68d46d1c8846e4aa79d4ced2844e7991d2df224a0a6a1bf9080ff8cffb284dde79eaf51fe4dfbf3480c90c05ceb24177566b6b97a0bc57465488e2d6ee1c101f9e0b3e8dd1467d0302e35353af57b4f997cf1446d1a6ec2c9b9fc047685c41e99193cdabac18fb703588a134f116f191336e2d0ed915a13bce4a13f10d2ce2b6220189070d1dfe2728286e12460187b0ab3c4c22594aba093f1434990b521b85c324096a15692ff905404060d95f2c97d9b234620454c1229163264b94280044ae35404258fe15aca434afa66011491c5d23415457262dff26d226bbe83b0344e066ec93888f4023be7459da3935ccd893c5d83347f926b7fd8a42fa24a0a30703145156b26a8cf325d656db245ca96c7d5fe13dec3ad9d9dad37512136c4051da0397109091ca646aae3929a4c8c570268a80b83cbd502a9f16bd8be7f7eddc9d4f7b97bf4cbd2e0a9185e0b9c9f8c391be6ebf593a0419c69a8efce8d635137164ae80b5145d98ab1582173cfaa1d4158c4df86045e4a44206aa1103bc0e99a0d4e7a7f7e390cc980de20f30b486fce89cdeaee238a3aaaaec1bc17c32399836cfd617c58a5ef7e91533e2eaefdec8156a329338e230c652232947bccef5669aa84dd57f16adf179b90b1763b09effc5108923ab81cff4817a2640f6438e7b180ec02eb979db15b23d71c7b9ca8f0417f1543adb8425e9081f4ff87e3a9ee41c8107170f594a78044caf95c53a3e37fcdcbc1feece0bd038dab1b5276b3a8f1e5bc3ce2c6567bad6a22fe2b49b1372d7667545a66320600aa272ca2a4f9b10bbdfbcec6af27fbbe373a3f2f311bd8db77849c207f1d5400a37de0d84f1bf6c26654033a110d35e3bc802a67201fcf63775e4ca979369e82700f7913fc5cb0a23efc4883f6b590aa5ab8fb53373442a718b808520513bab6b883303a8c9457147e6f05c9b8f7978b797ffdf58d8ead4bf951a61fc3a353382f4ab4d8c8d03e8f18220819cbc6384d4ba05827a09cdae0f139a4e926ab9fd236deb5174d4d89eb39e6f94fe34484e4fd72105991dfbc0276b534c3b94c6fee46ab32d9f3596236c1a2636d3a7d95eb2374e04f446fdf8c2d9f0ffcbe0cfb151a67961016bf8c5b0480c69e610a863c3c0c45d4540718e8332694f7c1347eddde4046395a1467879eb4302400b26c78bcae178a94bf05d48667a1afb383b925414f0a3c33cce8c2c26a705b124efe50acc71782e66675ea9885c0e183d9a6eb6f0c40eb546e89ccda5108b36b9401a064dd14835dd4dfbd48fc5f943eb3881bf2d5e8afff3605053aad3df27126cef517752d1698aa7d2aab77ee015d3b0d5b8444ce33ff51708cf883644a78467bd3b4aa67bd3ec254ee33b6c6bf25eab552ff2652df307372beab0f7308a27897d2298ec11ddb3974ef0d4e36beab2f518165e6852e13ecb8f3f183d4b02ffbd4ec28000c5fd53ee36c33335885daaf8d9c38cd932ffddec066d72ac5eef0c60b1b3b1ef5b3b8a2ace5dcd904e2701ed1ebd4ad9fd37aa481b362bf22dd625d1b12028c675c850cb5fdd3e5d35626be782a1599135f9e2e11a9c685cf8bb4724c2bfb95165c54a6146856770280464175d54e04c8a557195426cb74428c5d9c6a8a2f82415f8ba2e2de8fcee54220477e4e93fdae5173d20dd92ca7176acff1cd9eff17cc8dc83668365259d0dbf877eaf3f40e3d73d9314daa5ffa8ff9160e28bd08696aa8936d99f5ecf28102196ad69be636715b2c0822fd3d1da2f520068baeb8a9a015b9e8c428c7ae5e5dd048f65f1cb9a7ee55054a896197d081d4e8a3ebe16e4fb88b8a1e86b3bb738ff3cd44d113bb96df702a3ac415cb22c3e510aa536fedae820d29f7b1025fb865504c39c55bf0f6072d748c579108f8d3ef467e890e2bf89f5826433c28f48812016461c9e03adea9260b51b048811254d579d6907e8d193713aab4dff3371ed68e59ed7e5e6eb526114f5027d3799ee6228e04e8eacdaa41d43020fdc424bd6d3af14814dd616d908cc018375982022176300a5917dd8487888c45a347528790bd8d2e636b71b7d95e5cf9bb5ad9c2032ae1c2b8a605a1025afdca32fd992889394789c42e8e2af4c5c5fb7fb2a5fec41f1ad2e8778346e1a5ffe819f2a5c24132084fd90774d2e1795808f7a048b17eaf248b9dd347f81c82fe9e7326a2f88094d3ccf57313d39011d5c8d288d21b75bfbaca75eeb6e87cd5bdfaf152eb50662d7539d5dde4481b88570fde4bfde6cbec5a35dcdf12bb7415c018da711b46c09ac807174da495611f6aa9b663932d81d504f2377375256c114ee81737cc6252902a0fc8ea708ad64642cdd3f84d59fdfc184e38b35e69e908b6d3604ca0474d8f6f6fad8231f0d89ba2ba399559cf5946559facc8fb6ad1b6cae0646918cafd38ec751f5f28b710ccf9d338a592946766a0679cc7a81e8f8635c293e84d8db81c1804fe00f94addcbdd1f64574175365c80024a412a83d24d395213158feadfbebf9a621dbc11bcd099907a2e8dd12d15f0c00fe10d51e05396f9a0d354bfb301b57cd3a73f56fa95c450bb1755e4a73cd8fccf490de6050ae6036d11001834e0492b21b20489a1399839b79ec3d8265b9368e9c1cb243bda6b9158c57d78af18fa5fe586612d1865841be457be190bf48a69b258a26006dff578daac40b9e557e591a70abffa660adc81917aac192fcde06d6f41743c6b6664501452c390c0a345b630347d87b6b392cfc6c81f5e7c1b06386563fe4b90f08dc5340fc6b29ac54cc65119a30aa46c679a1a12f1e812d81a7c8cab72c61079d1758b00cc10ac034d320b35db9e2349d5a08b8379c748f1feb4f64e1d72fe8f16d5c74ba9839fdaef2991b071f26a32963a824e6c4a42e2d8fae273eb86335702f6367afc3a391568e5b59836ca992cde1b4d8f1d9c8f02049731997ececa082f6af29bee32dddd274688ee900f15fdb431c9803ee071ea676d5594177a11de3ea9b9198abadf2fe26faeb522dc626154b2ff8d0c1aa5ca308c3eebe803b591b0357c147bba1f14d3f9780466629ab32c970b6c9b333c4563ab5cf68c574e949c08e2209e803b0ca495ab438c0ff9db79ab451e0c4e69f6c0cbd7fc7a993c3068ebeed9d0ad8633e54d5e6ecb8df68a1cddde3eb287f7df7419d54a98af3d5cdb1cee10a12a45f116d50a715031a36993d03060cf64a18489b5354bdb69ff2a1baaeca7d30d1d1ee40a8ddb167984ba13d7b3a3d4179b0f8d4c7d47d0220ad9bae5af94eee158b4967355490b773107f77762ccd731f309107000884414ead91eca5ca2d50191e96a1cb19d8d936f93211750be8ebddbbef944ebef4b60bff6754343b07b57e1b1c60639b0e4fe78a39337464cd0232e6bb72987915c581e85fad29982a6a57865889121cf52113a06941626b346cff7527b375f796396659d2740668da47615168e5ec0555abe14de23079d02cf4687f1c7cfc22387be0e68caa906b9e043ec1692dd94ec43b7220783476e40cdcc13f5a852ebb94c4e400b3372c91380633265fec1890352ecd0d97663845a1cfef354fc46d1d455d3008000296b94c511439d4c5dc64311fdb06c4f1a24f3c283fe83b48acabd962752694e7ade013a5f61564566dada80d7d81ecdde1d4e1ae48f71bf1b3586411094bac63503c2499e6a59947ada880369e2c6a75ac2ffddcf717546716fd4f25ec472fd8ff96cea5d01957f023734e5b25698d2a12d75cc75e69d36d1d1a9292c7586723777dcb1ef7afd04b1791430d64ea27e07676c9c2e8db1d1b53e5204aa09b4917e0580485a3db146511ec3b3a6c2c15c2d7e595d2f154167466650be43d029b077053765d273537703c884f812a2e20a2c3aefbc8b916ddd7ddad3b595b1b6f1b322a722a3a772fdfc8d6ebd5424e363577f49ce7a66d5baa4cfcaca174deb13f1b70417d4469ea22db2658fc4276377bfcab4910a42b4e971fbbac0bc1e7b15c0b53bc3d270c9ac8ea98d1676cfe82703a3193b2ed39cf97601becf490453dcf5829ff24e79ae3cd86ae74b3f0634c364aa996c3fd28e764ac062a8eae7068aa83d943eebebb307a787a0ec0c2285a33879ad89b5af3debbafd0401814b7a1396da49bcfd61dfcf43d9ae6d468e02e5e53a19b340bd80c82676983e024c3609c141badc061f6d68d806941aa9c07571a876265f94781c25192002c662954a35b7f1a48103aa7b46a43aeb407e0960a0b8d28a8f2d452258b329963acb073f43ff444212382f1f8d2cff3aab0967900c9ad09242592340a1970ab2335073fc0c40d0eeeee06189285dcd35082a92a5a9d022d770b79bfdc40f506284f01af4317edb91c0eeac6ee63fb149c62d0bf3a3bcb1b9ef7e701dd6906a94ae9b3085fa0684cc5202996dcc11f93e3ec23d74f66054d3fd81086dbbc5ebdf5d827e9e5273be7d188beb9a8785b57e71041b0e2855b9b2882408f4e2ff5fc60dc4b94c1be7d166c1dffdd7dc34800a2b17c3f0794998a7b9f8c437f7264393c042122b99de6c38956da4e2e2db9e3d35be33b974542ab2dc3da54de3e3d71debb90e650d1a270db563e85e408f9c46dff2205ba107d28001c0368484ff32c3635177f19e8483e62a0fa8a1f883bfbd620b7fdfc58499e0e925d156501f51da4a8276c8c5a9ac4d8726d0f349ff065850a43d284e322d1b1c6a3a689aa2cdf5538a5d10afe5073add532460ba73ca286a59d7809b9a5ec5c5075e7b613f3938e01a4f29ea0bbe8dc8d1b9777f1c1ccc6003767cab96595c8e326797e6d83711fe393b46849d62714063b45f8324178ec0b7e26136768d96a8d385df12ed1f6927de26d02edb6fca0d865a15321819f7ca458ca18de36df15803303d5484b405fdbc181171c8f3d8665e28f2dea190d72d4d696286ae8fced9c5a0ff970083f26c984090a2791c4ccdd5f860112bd01775449dadb7f97d7c24cfafb56bbaf2e0725114498f4f4cc203782c079988c4d3ec42b618845bfccaf903c1b1cef6ce49a50eeb7f9e6f4ff93085466bf7d02e3037b346397b54957b0213c20e7de1e81d72b39e8bdc82abe23de0fa286ce09d34a772c48a01eb38533824c88fe1795f47857d2049e3f49b6ce72e69f2ac2ed0737838b33922f44d02b71d56c40744bcf79c9a507c22d69624f20f6ac965f5083de0d8474dae34607e62ed00a637af6a4f88a5b5c758fa4874a59b075995dd4ed3e883b4ae3fae0f33c8753543fcd6f3b47ffa3ce0da0787bde640e27599d8ef653998b9e43d379e28a7cee959792a89234a0feb8346eff86edb146c90518b164c3a13cfe6237ecba076d391ef766ee894b76e6b184c17827e4ddc6ffc0e8186fb359edf510b47937dbf1006c02ffb54356cf3ff968ad0dae463e36dadad52bd273260455e998a280520ea4f54a103392f3a75f4974b1cf62193b58ae4057c3c7a9e67496d1aef496e7704555b8a4b920231c7fc07cf8bbc30413f7e9ce94ed90b9db3a9707f3b729ec751ca10e0c76a84a412c590a5b8100e3478d8449f1846e9d59b2645455fe1569eb19326eedf8b01e99aa5d79184aec46297f2eabb069c0cbbb277925b09e9d18e1cc37caa7d3b955f007bf093cf64e274c7085ee66ec3ebd92d7e2cc36d29b09c4735cd7532aee838df19dfaecf10a22117076c62ebd3c428d0483b1437094b3ef685d4e505cf7beb4a80d136cc8e0817bc94dfe49b8322ab3dc30c87ac00ad9d90802188a0b82663484fb1705a990051aefc2d374aea937705d28f1bd9d54520653e726c7b2dcae8d4f9d03f025d465a583de62436cc1bbc8c9777177b8b65f606478b87d655b31c72fe7533d8f2409212016c08fab2c2ae391bbcae5a2622f334d8d8b7e7d1db58e395cbcd55d5fb0bbc4749946ee3add74054414d9f422ae5b833e93b91fe782ab7eb87534f011bc1991adc1caea6ebe95f6a052ae84da924f53fda3daed6c6aef755842a8a7d4503570d3679d2cccf29131a4e6fb6d381e88563d85f14c66dac66a6af40540d94d9d0e69b6261c17eb31e9c86b12a30e61392ec8ebb636e090b58043a8b0ca7ac691b789a65ad3f87a84fe0aee07fa50f96cf7df3b7ba826ecdc9debd6c84bac0a8ef12782f8b6ff099977b27a242f1783f4fc53d29898d6a9798d6e310dbc913148590ca303ffadb6d3afc0cc878b49ad6094bdc505d441b4505ddf09813ef42a446bfd3c93cdb1e0411b3f3e360292cdd002c4b8bc8f35e10f36bc9b88287343c5474810a5a9cf83d45cd23bf733795ca07bf8ddb3f0352352ddf3996e553d900443ff46f219de5475bb43e90b67f1cdab5f2fa09406746d6dc17c94465507f890c95c51884adee45dd60c7803bf931e5418dfbd62912fcb029a982ce823c3443fc3557eaadb374ac9d2820dce9c5efa76384728bfb4e69891198f3c12231f3ede5ce50dd1afdf914c48844ab7030872b3e798ff19e1a1b42d8922cf1593f36996139efc775e9d6c0327bdc600268761b438b09d9baeab6e15a38ac3ca70181851c6730907fe29142f314143b85d1c84a243302b9d31b5ceac5d3e633991eda07f1077d2b24e13e7c4930de84509818a82465445d98f8e42f0246c35563d987ee4c08663967627bf3341ce899dc2b25a58aa97ef7b5c9c402d119d45c5c22f5ad6e7428b66e601c666905882d7e52677e67c843f589a1757ad0e4559ae011b26d6d11fb5c091b6bcc8b62c3fb7c66f036c82280868026a992ee2ed000d0ed6df998d78d66a0932abb2ab86de9dbc9849b642294817364231f9150e1505d9e0ed9076628978afd1adf38c96aabb671ea807100c98fe85e9184d74d529bfc0ab63bfb0efbbe265c5965676a305b6b30c2fd751682c1f2a203a93692e10d65c9884eb6a8f3fae565d2b39ab8454620c95ea56fe1ab2410faac91203c8fca9efbe7e640bd184158ed5107adee1d88c4dcd03e64ae47be6d6e0bffa54cea972a7908d0ddf0955fe0b05ad95a0a677558e43316f9c46a772eef4774a3590bee9718760b0e3ff9be9fc2bc1b4a1df317e4dfd03137b2ce8c7e0a66664922778df7964077716c95c5d9b2d85b2bba983a577361f8b02785d83295ec7b36a54a2c9384e81253c05cfb18e229047f9495c599ffd92408a78163273007ccc4fe304560d22b8de6a70d50869512f2de2bca2f5721a7326580b28f5b5de7e529ede6d2f465af87f8f1652b69c2a85187c950dba1ef2ce3848a14161b8fcaaa27aa23ffa3e56f1cbf4e05722aee861bdb9d99672f53543ae77315c77d14adc86f436253884eb5c8f2b8a00d9da2063f49b1aa83eff7c7d6015632685fee3a8c09dfd7eedbf9f76096cd62228370b7b7a77a09e1e1fc5f4259d48b16fe1a2d32f7cd60decc06df9a83272cefdccc97398458bf129ef8432547ffc487d374dc7acc98609cc39861749948828f24492cfdbb271d205f0994233e6433283ee7a82f61b98e102d53b5df777a962f2f855666fddaae04e4a447c28eac8610d3e1dc607cafd07454102ab033d0449c02f573c14b9c13a263eb11abf4417809a6a9e435ea6c22d52f6da2ed13582870cb9ebcc3a2be35089501266a354fc6ca20e5ca1ca525967472d30d445bb5df1e3d0008bdaec9a151e32be0a3a64f216bcbea26d93c9d94b1913939770375195cf10a3d6d598e408a4870f5eb6bd235ec3117551d911caa6a3a652db984b80e6016f478227f181f341f1c61bd887f0ace648afc60d5e771be4a22ebb5f04c67663f4d8e618df9e0198cce0850e1e3f2f70ddaff3d3db84d17b1bb4a5cb8886f41bf53e55b479b2f6e42b3b5a3d07d652576128a977029819a3314b5ff71093561587a89cffcfc6fd5a5db0c92f235ddfd34c103ad3dbc6c95f402ab99117810d527974144f531fab2ad40d53e96aaaa4f84bf7c8174b088eb0457c14775e6df6365390c685e690226e02b1e163d84e17a4b02548f763b265db97b66fcc39ca49d62767d904921e0d75327099b093bad9d9b1d178acd26a5b7ed87a7b888545513fdf1bb1e0f083527721593d6d45fc4a88f61c98b6dda35d8f9b5f44abbb982c12a1f85ba028fc7f471a376933f4e8dc54357e0dc17fadac78e1859e5f0131baabb70c129587fcb037a49ac0475e6d744dd9a8ca610d1db774b4928b2629c65ecd73a249743bbecdb468140cbf196539d69508ccf818956d6fc175abf0de3ea84ebb3bbdf8af4504b2dce657888471860f42a7148f80995e706884f67e1326a9fcf669f345b41eb3b4ad76024dd11574d84e3eecc7370ea673831b45b0a7b00d784ba0078abdc2d294c016a8bea1abc7c8a2e97da9943b50a18218c091a627031e755ae55eb3220e914881f0680774ffc84583291ed3f7887ac61350810a94e520a98baf9a139f9f7490924e5223006634d56fdf5286611ee86addd756c2922a0acecfd94afefbd764aa4c65c3465062a2a0d244c0f7ca67e431d5a412770bd23318980a922481272b6ab30f9f277ffece0a207c3becde888630bb0f13bf435a29e33b3616b08db208ef6db77432d94b4f0e822c3ef1498eecf5f668fdbed0f6e76330ade70bb23dce514ca977a352fda53c386f21c7021bbf35458aa796dec3f89a1211a9b258db4a01360fc87011702231fa6db53e7f246c23d1dff309f5cc25ce39a2367a45e25736766ec96f1c58367d29b0dcafbe07d3baa9ca0b6bb22ce55833c94e8abe3c99e07f9b184f26a32188862b9133068851a820850f0d0f48580210b0114b5001ee70c1b369fd121d6e06c694d8388a3d50e5e6e204e1e1085e5dbbcdc40815463f482ba566ef02e2ec0117f84d6abddf2dea07b2115e6ab9c9df29de16d516228e239a20c2a173a2fa9779acf54f20fe0809679e3f9d2d43b1f5cd6d67671ba8e1ac30e7e8f1309edfb9d83731f8dc9a26f7c66f3f489b1117eb930713efc9f2c8f844be5e54474702d02f949fd173dda9b01d7fa95bb9c946392f37e80e05c6fc84f640c23f6b5c55548803ef2de984885a0e27d5296e3bee5516de5c9d8fff1ec41788200666fd0f0e2ac143a5674f7d8a8c0faca64d7bde5a76a5c9898a93eff066ed2bbb812187deb49705bfb6eebc2b944f785c4c7810b1aa65e1a53fabd3d90e89cb45200d4af95f5384dcc8a17d99774","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
