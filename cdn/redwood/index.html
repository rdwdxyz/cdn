<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"baa9ecfbd0547d326f1cd48a5299e616c7388cc7bee08a4e72a853b83b6cb44745fb33d0755b4652ce895547b7ab15da9155cdb0499b61e1a77baf9d23f76fc308cf6b498c52bf977b087627aeb2fba6426edee008ea30caf6453929dab386254f37f55418253fd3726a4d5e00d1cfb694bc390af8a7467f58bd7a49d7da5aab175940ee21380b786cdf36d5a02ea1e68397cedc9c9338cc5813e0784f153d886e58dd38e9e888e593cb65da15c763649b820636907d5afc51ab65fbc2d56871e55827ded39969907981d50db2575d83a12203ba7f6fb3c87fdb1e144b1170fac9c890cf02881f679b5ba4d1878dffc93e36d97823b531cf4c9ab941d5f4936c2eb3823dd0659532a251f93a488ec524c315c05b06fe200a50c6917e9d879078351d21a8edba2a574fa4afdfd59d5c754717da8a65e2712690dcf7b996fedb33cc21a6c0d8b1cad1f4d5f46ac3495ea74929761d9b1d56c4cd1870f468008fc9e12fff5becf167b2d2443389aceb07a5d58bdd84bbf170e99fc181692d51196b83468f28543c16249fc69d3aad37ff54cd6dd66c0d7f5ad91538f359f7a40c7670708b1e4b6f0c4d258beb6fbb3f1af00191841bea764485056bf2d36879521f2665351bf08537e47078f854167401525356ff2b680c6208bbe3f54cc43c7e8091611ce0121135da3ba021ca313b0422a32c239283c0465b366f6767f77fc70799f13ccaadbba8a3803b064dfe98e9b82730ebe45eea6b3d08e5abd13587757b8637f9fe5e4bd3a776decfdb51e9bf7d2ef46cdcac3052e54a875488ee03c1a34eff6608e379aae37ebfa5abc3ed07ff27bfcc12f9dc3cf37c557c87344a1eac4a875323b47137dac0b1c0533a2dd07b6c40d59178df0119dbf83fae831636264cf13eed00333520cc6481a81d267d13d884710f475798e47d42146a7e56314a6f5b7e786a58614210ef2dae16c6fb9dc26cf8427a0962497861d48af8d47315fe86d22442c6e58b9b22d2be978c4a9e429aeb0f661db32f99fc4a02991a98f2a1d152bf2c77eb62255d6dd4c064b46db71a87645d6e3d8985743aa4527f3f81c85749d0f9407a544b832041a4b705727657a13c0a664519027c796c2155260a2401d12aadd9457f73f7aa4568d8328bc4dad925bcf32b03615e2f456aae8f9b164da04fd13c85d9f315b01bfdf5c7eacece939e3e763a717e2c10464d9b694a3a422f745674885c11ef3d7b7d309d056cca5e582e7e60798d823ead72842d54dbaba34c9bbb372d19d9a1b941166321baccc6c1b1b8dba835a83dbc4285f0868530b4c88af0e37adf31b52e8c7dbe850f654ea6637048945245d473b960b147dd83a5d91a140cbdaf3b76610c1be0a2ea7fc728268a09907dc2325cbda8bb73fa776a5375c6d655c0efc7d6ef81ec1b9b4b3c18540c387284e5e6c9289a9647617727db74d62532c0b60afe30e5b45022559b65b4dff3a2ea9a637f76074d1dfabde47b7a150809830823f7e02538c6f6fa91ce8601486f691274160131e194bff01c60647d6e552997eec58d807cca8fea66960a4b55830593ed636e2269e9dad9e4a20ec16f66fbd30de9c8dad37bef4e583d406db82217db5101acaf62f23d902f576aa113025a9a2bb3a81c176683a0d041d2c4e0d2c88399d338bd3aca5d95ccd1b8b835b27ee1bd7119822362c3e0fb22126fd0e168bb3e4a51f7a4bde71f76678f9a3c3c980a37421ddf71ef47f1e58352cc0446489c85ce6d905525521ad2c2abbd0e45dcb467f6d5ff0b67889f87ff09d93360c7b2e03f57d6488673f55edb8d681904c913b214603be6b0b96d0af37e932f42b7400fb6c54dab65c47e9c697694ee65eb6919f6440fbb0204bed2cb2855cda3f4736d622efaa8e506d94189be43d099477bdeb2dcd7188081bde615726f0ce998b99e264ef036c718d467b445fd92e34a2938dbafac14143070b634d485022e5f02c7108349c9a8cade1cb3d8d689103d11ffb2c520781736432822d285ef2307000398d069277cad113d4cc0b482e331e0e118fd28364589fd3c55a9b3fd3050b710702a373de8b286394b6801f1284d89065e9739b39c7db35baef5baca6850ba84c2ae1a64a9f642df87b983d5c4cf49efacdb9036c0c1a60b78348c8dad8a32832fca9cd8af8596c5c751ca657fb34370628dc64f9e95484fb85ec47c32f0945abb67c9c802da67525e562b86a2df8c2a02804e0cee1173a63a982cfb99950a862232bb7d6076d7ad2334a5d35cc27ac04fcaee790809594c21350feefd56a520feeb875c847e5fd9246ccad9510e1b8829fd83ea7dc29608094c4e8b848a5b6ae5c101b293a841bb656f61fbf0bac6c8b6827e2ca7342daa15fcecb6b5e238191a4aaebda142a0b645cb62dd6d97d13fe885837be06aeddb43b508c3d73e7c7696415a4b79b727045dcefff2f58ecee8ff4c4786095d372b18a295f452b3a25b1489744e5a4dc6d869e3ada2db3b40cb04c57d304e7272d40084a48beb7e73821510211c752ed51c59a47642fe8aad7555f63830c97ee81b147e4e56d7c2d8c50d7129fff5005a4220e83804ec463a33f95dfb05aa302c9dbcffc4794782e9d8cc0feb3372d9b6c6dfc95ef7728bdc29b6d74a43f1499ebe22416c1973781dd24582e4f3db2d9b01c46f63b6befdca008613f758dc0f53d7ccaf36b6efa06f055f8e393bba0d93f6df0a6f9ec7bca0df59a1ac8c32ce64ed7ddad607ae9472bd0fdb22b0af1473baf3bad2e4fb38c9ed27dc48ff637b7a3da5c337cdd1432d094515fd44ea83599cdcfe4be30635fd146aafded8bc6267ee276cfab6b86e11434508f99e04b10f1a72b7715d8bff4b6f408d2615f4041b829357b930a6e4d369d271dcae1f00d55985c80d1c0605b2d312e9a5ed6277b9aebaee3853e9cefaa72895c69640df358ec1dbf63c3b079edf300ea64cee25b51a2e69dae41e594ccae6a840f836f45643e8d7062bef5ab390309440afbdb3cb75b60b6e19c159e9c24c9f124f11a0a1201c5f0a731fcb074197a6cbd87e65a94f1c5d0842af591c2a30ff2628c34d1b987ae5dc1a54dc99da25ed5ea108b2c1d44e491b394f9ce91190a98da25f065d3335bc2dc81fa7a24dc243901e37aa2ae5cf9193d00fdc872ec634093dc508b59d99983022c301b930f8371f8abbb4256febb87c7f328e29b61df14c128df470adc52c81cef9a99b8c2ed511ae7683a3001aefd8285a25c20c465bcdd4a0583d529e2acebe2fbbb830454f7c18f5e49f2f4063755ac26a67220adc2781840c524d923f39fbbe7d0e4b0b1b6c4ec0d23dc12146f63a0af151038dc40e0bf07308635e8b6daba4e5d8f0f6fbbfe2d53773547079b3dbd1982cd96c2862290a2972096b7189d0ae0f921ec49367e7635d9c1540eb4a4a6da26884ee2a7c676676463329c9e61f3ad017fcae46b75224187a97c1939f938693e791cf48e1fcae8e067e976b5eee2b2343c515ce2e20263e0d6e991847193a395ebc54d0b93ce2a8b81897c99ac0ee94824919ad897d91bc23c2df5c256c02801c6885bb7bdceec97f4334a37856db6ed5b600b403a7c4e4cb5d0708554a9af8299a1950875bd45167ca44670506211e8148266b85caa8b2705298e52486bb29e50595ab2c4c832b0b50d2969deaa87154c6b4484f151807f429ed4159589cee9422e068441085e7f8a44bae515ea2b802ffa85d62098cb6f80e3b13284b701dc255c88b71ac929f20f01bbbaa09988905e37f432a9ce1507f6e9725397ec454d76ac269cad9b164201f1a6a1bac582634278c7eb294169515f8753a84d06b7dd75b7c00aef86908fc504cdf2eb0e0a44320351466c3e3619c15ab2f79a03023f70b5e6bc8b394ed56587f7c7d6a3ce86f13c5cd30bf851316fd6623b9b2c26ebcb80cc68119018c406e44e92df1fe19ce030503180bc53f1707246a34b5abb9c1a556710925f22e5c2794b93dae2c59626ad4878a2399472e0ac681534c2accc8176e555cbf90bbb39359ffba10dbe6405049f528693b70153e22c5b3ed8c9f2a74512b1aa403d37395ba608cb299198f98a57756a12d02fb9cba9cb4a18f4a1a227260682ead4128758d254edddedc336ec6abccfb634610230eb87ce8c1f6e4106e1372973d1d61ad47c4ab8c8a37683c5f81b5569d64dde1f36a40e6db4dab6b3f8023b86b9e79186e2e0f0e7f0300cf193205e7e8b01147d9b23d5a07ded027b0ddf5b7747d001c95f5c1a05f860628c70c21e833fc3145f4052dfc29b93bd68ef00e008845fe428324fd7728c03246fe314a8be0f56137504154021c2de733092d5ceb7764c967aa570736b17e9514d10a7420799d0d9ed5aebba6b277bc6dae8977af08ae441be499ad45c3f44d08dc63aa9a20dd67f068bf05194af25d0a27bdce8083d44d95776208d55f3df31d00fd27fe67b3300f89a3b0c92f4719d42339c539f2e68865dcbb24a54ff7030588de8ee50cf3ace1754c6e271f4c3358b95276a0f1a67ffd7638efa759675f0c178f75ffcf54317c79e3c86f84db3cad94b3c2490cd8d17e26277919e2b48129b9bc63195f140bdca3807e001ad2d7b016f777c927cf505148d0fe6c9e5b0f17541e012812f03583aec98782c0d385ee5dd6383150babca9ba64beef015c110dd0cd1fd52ad3885138d8723f0f49ec75de8a07a6c750f57e4d53457bff830ac4b68b326c7643e2ece155579ecb4e7a7bc9f6c364c5dc2bdd08af8b2be1847e6655f8577efdda11b884f854af54eab3b3dd28799f39c9604fc0912f92219871af061e755acfac253dce99dc52fa70068274afe1212193fa0acb41bc8f22348cf96c00660cf9c702d75de48d6b483518b9e2f6b2a7530c96d2bc10fc27db05621618b157e5f89da7976d9f6a0d5bad9b254073179af5939ef5ba0473a45dca8199e31e3770de37432bb9a929fbc3848f1afe9ce72e5a7547aed0528f2b92d43210a454624c4214748b6cdf2ea90e7eec3090a1d0234ae8fb1e42132a9cf494894ecc357cad2e07a8bf4d1724c5286af2be45d8461ddfcccdf158a186cc21e96a85cf92a189ec1645e7564a31610cfd65c0202fc882a00cc36684fc65d2235c6ecd1899b84dcb02ee1bd535039f724ab0b7a26efa96e38581a08fe0735c74818e1ed29a92eaff0df4cc27709c21f7ff70be9cfc7b30b5e372e8c195f16e0934bc7b0a59dc98a1a354b1f70f89688112c5d02702c04a345ece95fd6b3c26b5bb66bd3c592634b39aec6def323f2e39a3951ee00b141584effcf566d93a97ae195102d9f3ab1bd2649fdff09da8a2151d33fd3906436953c148499b7639f4396f53d772e879b641b05c5b2051cd20ecc0e0191ce2ccfb94251d4a46e5592c18d1f0d23d9c11aa13e5408ab00ed25e124e568692c3ae5767da54d160742ab434123eaeff5af477a5856a917ca902d752d8910d5c1436b325963643ba6e12c04cfda5bf9ae25a84319ddd876a97ad9a8b78cf668126d1828b0752b1343367da03077ee5ada37ded3f01b59e8d7b23423371b6fea506f50936b6401f4f781718c0b5ba70f96504270e755b452c94cfac870fba347bf7f2fdceca9150d38bbc34b7fd11dfec34a286e7f3f46a80c9642be3644b1b7d8da5f45c278a57877f7ccae97c50390df6d6a41b1daec742c866918b6e444464e60dc7fe827783c1ebe244c0dfb33500d2b0e00767f67f588fb8b862b0133fd71e771b4ca56f55f866c1b1af30c0e5c7e54a5d11f4f622395b3dc135dc355c1804d02fe331b1f172d13c898023bdf1516cb996d9fc0f3aa9205d6e6654c091713b351326552947edd89fd3fdf643ff944943f99c9b29705d996afde80492d3bac0ef61efb3663420d723eaa7912f2cd9b0a24f5e9287828a3069852c7322bd8717d79c281b1036170b07b335cb9f76a8d7aabc6f0bc25d208d3a43a4c6befbb080f8c95b4f2d0c0a6ca6cf68b5e5e8c0b83866cedb7e7cf53a002613cab926d95c20424bdb36680bdb2936110587de145b39986632c4e05eae142e71fc8ca3decc853326822338d6c0d7b323784aaa02614ea46a56c6a7d96a1742a0ddfa621e220574997190b858cf60a9ef28642bf197d1dfe9d852d761f66f65bfb38c53c64bd21248c667e527fb60e66cbe7a78230de96fa6a4d23e9d69ddf00a4ba239275414b015e043ac1a8e2077a34921d1d69e05c74677594ecb0edd5e3545bf981e8c7dc07d69d3b92030c0cb61d1f3254fca6ca4be0d11a6a033da66ae3b16238dbcac5a8353de1cf0eaf0e9993cd787d274f436da287171076bd99f3d7e3295cf06602c1554ace1bbec92dab80c353ba0079f0b26f836fd626b2f93d2c333afff5ddfdef4e2cfc07da472e6f7da0c946069562b2188ccb15d85a8f1e4ad8f31d8df421b38e801598088144f99623e1ee0708338773ca24d46d35d1c56598f0136240ccf8a3756dad948b815d3d2064b83488ea2f879e9e1de23ad64d06770d01721ddb64bb9acfd8c5892965d55d3eb59c194209c1cc03faf38d6f450ff07b4aaaf458e47c91b36f9791fc5f55aa5b9f1f6e4ee38a1a938a16b20ff896abf5848faa01b148d9109efbfd53122e19228914c47eb97672177b5d274bf0bf90b5b556288fe620b2ef02ff5c59d07f93930ed23bf68844f79ae7517d055a73ea4900e2e804d11275bc1184ed07e61cd9da8e8394ed9535e92cc6a66b1da58e173e4866f84afe8896765365d09aca39145e701753e9732711bab47263e928b3a586400b87f31e874a3c0b78e7d268b4386fbed99d77b801ab078ce1c3a1517df523ee5c33423e4c2ea9bc952cad295f510f89d3e3e9608097d337b0b2c712ee9bb6826ac709ffdd37614717201bc53f680e71f3c96cb736f2363033594db223bf7f18f82639d898c8df2c0ef6f0031a1968b26d74ae6eb0e2055557f9fde66cc3219d2629b7718e3312a2383aa9865dab453c993c1ccdf1dcfe917976f41f046593778079e7026d12bf7ec8a8ac042792e8435d85a2fd935cd903c0c6114485951dd4d3331e062acc50fcfdfdee844ee9bc09f55eba7a555ebfded2930894794295d64ed8dde3fc0638840769a4d8d94ccf74ca30e7c9d4edcd995f32fd17c41c8090920ef411c640c0103a57ce95e683cb121311a2e7383dd3fecc61b271dfff022479c73bbf4a5da656894605fc5d79514ebe095136a64e66329ca50d61bf48eb1ea7d1e0213a53577563bea3067c461d6b904573dc93ebcb16bc94f8d4fd91052c6bbd14bf860aa6145f57a428f228ecdfe8fe4d7abf1acf5970a80bd8de1bcfbb9d67dd88d185f6d564e19de3cbf38a1a5be2f5a1d906b1b414b20e848a25eb4f9cad1dc6a60551e2caf8e9b1cdff34f249e4e9735dda395a3986c047f45473966bf28c3f241718ec1f94a04fc3fb6b07167b5c3e7461a01e9cdd80bbe33c7bf381ff9bfd1cd373d0948ad622e046baa013176d949608ca9ca3877810ce15dd202fa6204ad378336085a845237c3574fdb166505e0ede193fd78bd38af36282391525ab15a34fdf693ae77e6755200b9cb57477ddd171eaf164e10e6ba40e80967bd776c5f6c8898e9165f34232957920180b12f5cc9dafa1759f6dd7456915260c0e681d902c278f132330de815e0e7d6f8ef946ecd4a1fbf923998b04f70740a854c44d6d06b9be656a6cdc0c77edb9d169a50e163dac2cfc66f5bc73c489d7973e79c85d222e1f5edc3cff994cddddd85490f1f0f7617fbad73ba63122c935bc1a0e2f09b5500a95e47db1f71d0dc7305601ef9876a753b4394ffb88fc3486f06731a4ca8d4dd1e8adcf4bf3cd5813feb257dce1f853dfc26ada415e1de82b89b8c4888bd427c6abd5269b82eed68dbcac0432db5784ef61f6df921d7f1912057f22009683ffce9faa77e7dc3cc8457baa9e54169b42f20610b9e19cbdb86556f04b342a1cad34b6c9d8e0b7c571a34ac0a1e7bca4d51c5e3f52286ceb43cf1beae4281a1116ef0588bde3ebb8487499435f4d7380a4f27fe046759a4f86b9f0d6b1f46ccdd528ab7551f79a3c9ffbc639a4f80ae4e66d08a7a89b0de76573e112000c371f4dd8b230a97667b61a909df053e50ca0ef46cecbed316c5bd385141ee0937c2ab97e5e3db222f12d4282d54b528c2f50a38bc8a63b303b82fd02e67883eb2d69ac851c039ceebe700a4779f49568e0fe87dc074d9c413f1645c6347587e89280ef5dcbd9fabe3d28e5475ccdfd935f8770a5a999499145e94309f5cbe9de0f2013e1701397b3933ed7f2fb0563a335d30fd1fe85edf02a2bc8a866677e36565d24aebf939031bdd0b5144d155a6a33e1763a783279365fc1554755c4cd9ace7dacb5f1812bfb982907656918eeaca1c8c05c8b93f9cf80d2e60c30021081bd298a1143a3d350fd612bd23cd225cb40ed72240a1a18f5f03fe9c6fbe07a1f5062274c5a5be458cdc07beb13481e7aa4188745e14459b945750e6ba89943c2f95e0be4c3a36e5b5d0193354130133beaa6df82361d096ebe33e9447be1bad66b54409e5842f50ec386e169566e01e66b3894d657424a3e53a71ac7d6e3d4b9447237a1522416bf9a1d56039d2b3fe24c5c842d707a0ca1e40eda04180ef0a32130cc5bacf5ac840d5e31781e718a0fd61549610e58cf5d047ff02c2e5a418f6b46db322a2fefeb3b20cc3b93addd02f45ddf127c1dcbf72c2532487d24be40a2a022e8eee5978ca8cbc043bee4560d1845392cb36c487c6cc0199f079f1bbbfd8a1ecb2d5595a9851c4367f7fa9065c4d7059d296247302f1ce858bf4aaf2ff376ac37ae168dffad40e2e0764501b38bbd3fd3033de434aa57e6659bbdeba337b098d38ea40c52b4b6271e988765e391bca79b98b6266e3e497be099f6900e5fc9f45d6179cf51271b0dd003bb45c5b12d0dc628086e628093c022f82d79c488701224ec3377a5c89bb99da73927b8dde5b4af1e4ec935fce4b67bc277da7ad22b21f19327e01396db241e00c48340b22e093e8a2fb2e5de2bb619bbd63002bf894f0e6dcbda59a1fcde7a8fef5453ead816246ccd195837d7b7b132119871255640afc9103c4f44c84b9f571677b68f6d46d5eedb87564bdafbe9d64b56a060fd01f03e78f62d30c5213113b718e27bd5b95639deb051138d9bae93084a58e1da929c6f499b8ca556141ecf0da041f9d2db528b01d0c7e47e8f1a3f6160775a9ec6f074b2313a52f0a1ca9f9d975023e1145cdfff916eb271fe59136a80c8f7aa54437492bdf3546cca0e74f2c7599253f9bdfd33edb8eaccab8927c32d92386ced954fa1cfef4526c15a1f0470b196e31e64c8652c07f3e07eea385b63b45e3728bc5b29afb4195df5dcb9e315752499bc007aa8fe6f096e461aa6d0dd2d806a833f3c274b28e0f175c3478d25f16d5bb14654d288c85ea136ef6b694da2093051fe91657fd8fe00129adbf662860ff61498582741a8b8b146ecf011d1161a1d1eb135c9cd0ab78137ef264db41dc036ef89047523bc7afa67bf3407c31a3338c350b731ce2f19d49c1da08c51b8df91aa79a60ba5d3281c0790ff7856bc167cbb48f25fc7c4eda44354cf9ef8e81b9fdeded21fb8b00732a8314f2711cb9607bef90cb2b60676f13148c1f04c26425c6a468c88ccaad03c7eb2e588cda5982a9cc8890e39db67825758bc9f5c8df0d8af9934220ad2ccaa4ee8cdab2aa96504558fe53ae6867ec5a285f781500228ac1cfd7afd87c3785161e018bbff7c0df79ea1e4d7136b13e09a761eff6adf5d0b1bb3946206dd605fc1b7d373432fe90e2f39b32b24b76b5ca3bcd91975ac1c8096284ef9c8065c2cd71c82dfbcca9b85cd69a989e8e1ec86cca5e4898343356a012857bf6d0ca876e84f1cdce89ed594b764d84d81eb55423d436b7fb01c8c47dc1742e63bf9f8a654a620f1029decd0fa99ce483056a0baf6986205cc04bbec498e865a1775c7424a14e4eb213a7f4ce671a1b7611ae4f4df944e38d34444268a8c94c027e87110406b2d40a66bcb3198ce3bda26d49449af4397821c93ffc9f408d6a9cff0e954a171bc62023d89d3bd3a67322b330ac5087a311fa0020399ac90a511796b0a6503bc429125fe3b3a94e08377479bb897e0b68d362d6a2fc8fab33719c5333075c0f8fe09191ace88b059fc3bc936e275b318a935fafa64a52d708a8286f8b692dff44f2275c28bd3e82600d2ab5405d0b19acbb6027d07a631c70796da04302aed0616c00eef29d5aeb8c5c395c0c0ba8e36268c3829ad7c31d5885e5bfe9557ab780362b782fe5a2035f8273ca9b8503514e40fe18851821bf9260c1058df0038553aa5af511e55b1c0dbaedf54e2240e3e4cd9ca9845610e283593d343f4e4f360b008bbe2ffb7be4583ddd08d86f65c7ced8f22765c7acd23ae3443aad28e0fb3d39179d5e28c8da38da85b725f9a05c0b49bc67c49a3ee320d5dd094df020e464dde0e31f1525d16e6501659384722783edde2b768e6c53f22896d91ab47ef9221e11445e0d381389a37e53b0d423a4fec2afbfc8f50c734a9b0f239d53129c8afbd315e329645550009ef0457dbdb1aaa38afcdaa0b1a37c90811e4e159c9a92256cb14b96ff8e59757e45e4862d9b214190d48831b81f74e7cab1fe83d5d10df8f02a29b87db2230792027a866438cc6a33e829d91da36870ffd3bdf74b3d0391a4b58e38e19fbfee89a6d3e2950389266d8e01b265fc9d170ae0a14508f0ca57dc8ff2d16a267ffc958f97b6ac3c8845fb4642d64ef626d1016a37a28ab492fc3c892b0d65cb2239bea1096d8cfc4918beced5deb5822c82a0599a0f5c16525361ea19bd9b37880e7974f08e77c7d4679660eee276ab038cfb4c4afc5c9052b972b10f408e61d7c7d44afed988082e44e7202c7f57b9bc43234175e13b11dd7e3296e4bfc12ad3708acef6b510c2831d095368373b412208d7c87ff3fcbef4e0cfb2ede79c8180b76988b7cac6b9b3dd65e808ed0a6156c87ba2d9823598589654fad0bcda43063c15640db67e1ca672ebd24af07f7e5680bcef593125854611b7647640b46b80bed9fce915319b5b5ad6792fdd7fcf4c54f9a7935d1639e4a64b66a7cc6517ef60c09d64cecf0ed2990cead6c9a9976ab82db844617f96c894daa84592818e57c1fd981aa5a65f75395215d1d7bbd7e4d505543085b5c79c0ca8177756bbef53faf6c0f926381caf271333ff32c6f20d49d68efd23639ee806f4e86df76bca892fe33eaf427295a5b4572f62507b2c37651b0a3310c1bb702c209e4763b3d5032032224ffee3b95510ccfe3b5c8fec348c30ce65c7ee63c869b9868a9068d0732fcd3b88a0219f413175c51f35a9ec1c9662c8653750d53b3c1983923e420f7a12f349a6adf9ed2fd0b7fedc440eb8371f249e69203dcaae1049a08c31c4d94bc73180ba9df19d2a9b3b4ff5f4710ebe9db1e7b9a17df40be9d5b6aa65913bc36ad8c5d65e34b7984156ef49d74c3341cfd28e44d87a08d3c04a9e82f47522eff618b53f1960ec12891cda154008b5ec4e01a751399c00b792656aee2bbfce5067275f9187c31d167bf317bf2b156e2fbbf17347866834ad678db75397857946308d1e22e50209c32ce08782eb58585fd3012889997e3d1d94e0c26c5697ab41f10b9bea8a3ee21c325a0856364424ebaf39d19e23c560614aa2fdca94eb006200f775ed109368e719540412547e8f894d1a1b2b4cd7e10f7274664759c19d17bf036ad61ffc9e33b580c1851c20c18d0be68656df5c98df116eb71c4addb600a9663de820b64f08bb00ffd8b87014ab5714606d261a32165154abb9021b46cbb633231333406a49492df13a05709ded4723c6e54be5dede039dbaa100b66b64eac359fa6d59efcccb48602650f771302ed78cbb13000185c72f2066f18e0c05749668cc05a6d8c6d807b6bb4ae801a5cd0eb3549410b075d8daad732b3a84d7612cde18604fa7039ca9caec35f8f93e6137b9fda2436672f225d976c6bba8aff26b6c7507e3ba46e5fc89d93ec6d55c6ddba3cde53802e2ba90923bdbcd7279111fb361f3244fc1e439c0bd905e8aeeefa017fa39c98bfd5114bcf96a144446eddb5ee12a0a77fbc2cc3b66b4e2c29e3dec38b4ac18b7240a9c0f000d737e79073e7b7ae98688c0ac7d3557c6589a837fee42f22db49de62e25c5d93e623a638c14f633a4c942b65e377ac4dbccc4667ec1016e1d4d9cd386cbbef37b9aea91267992d5194efeab6b1803582fefe0383ddb25c1d9014fccf9043e578ae49e6af55ab21cb6f3f80ea6529561debdea436acf6688c8f59107f447ea2d019579a0ba154950cb44b1bc6b30e437b7690c1f378c1b2f45dd1408e4966abcbe02411653e749d5ecee3cb67345654527ce9a8da8ee38b608c31718d7db0e58b601ecb41669fc98733e8c0bab735d0f29e667768d1b2374377b7380aa0bb85e9c8f16c3784e1db7822f7947769bc8b1a5934ade58d3a94d401d2aa3c46d4097f5e33dc17e69b2c3b6b3acb3f6cf953ff41985692799bd0d98f7a0ed68ab341dda301b6b49467cbb02806a76b9b7005800ea981ff0b4bcf64a37c588f01a0c31099537cf97d3b8c8e1983b534f57cbf26e29862b6b06fd3187a3427f864633d4412aae34e8ee66dcbaeec17c4bbb8e30823b3bf5f58f6b8b340c2c2cf8cb183f7b80c42f45bc344637d2b04ab82a3c8bbeb3c82920c6ff4edf2f0e99ae998c915f36bac6adca7d84b9f2417684e4b5606d87a5031b30c6945c476adc330fe6c5e76959093ed588bd5f6dd2dd5861913800ae67c651e893132ca1f1e6d1a250540d0dbf9f947c75a12df57fa74afb83811a3e19983e043e1fa99dd5874424b840b117ed3b317e9e1701e3ae9da8de8588184de6ec4a5e27dc999cfa4372eff03c7cd492a63142e7bb2b519aac564024bbc30a82f13ada2fc7e212306b7e39930dc4f6833f9130cf324e94c922940f7caf8b277e80d362a2a8423c5d79af1bf05d2117a067ee5a575f6072815cd39930f99688eda58f3fb7a20c3cf66d81edb93d90034c08a4c359c1569d9b5dfda39ac0a3028d669ff7f1d55b1bec0565507e4bd35138d556d493f8898ce02f4556300e6da5214c1cb69edc08e06cdd86fe86101699edc895aa201a7c7bcf30f677fb16f0f85ea227e3614c865ee50fa0e4c945d4d58a2146fb0dc9c2c7fd7d55a9341d6f1d1754997f2027a89d47372d36695e8f50825f7f51a5486cbdb517eefa9ec33706f198db212f728fe447a0dda3ccfdb29b6988ff0a9c45a1a061dd304cf91937aea1327fe03aa79bfc6d0729f31b8661c7dd555902091552a92f8076571ff84ea10918265b04c5631359d9a72c2e7bc427f9c6d699da0fc30abb06ffa51b0bc3892163379cfb853634ff855814042c2457282d2fb2957e2e57ae092a0d0980af0067e88bcfd12ed2761259fb4b2137c8d2e959bd36b3172f74ad9c2bb8d8ef9b6cfcaf26d281f2cedc55c4af9ea605e29d2498464f050fbcce4217f1477ae5f15d09dcfdf9a3cdb0de8a8560eb3bb561aaeacb79d4303ca649279f82389ae6ab90cb62d50e4707a1cdd8cf61eb14fef8990d86621e48cd71e632794f55e316ff5d25dc8d58d6a16797d8d3872423fa09b06340ccb106b194ba706119af7da7f646fd9daed8c7d46b8b7d85d7a91cdb342d45c269d00b7ae399f95488cd849fe69144275ae1a041824ecd95b6db2410bd36a067801f411cf9f4c49811475eefbfec1760bf05201bcd1527ff0c02d65a2ae1bb3efbd553b2f25b793ce85d383f8867dd194123178c759e3b6cb83330cf5fa538bcdc7e6e9abcfbce6fea9322d1e119ecdf6672fc82302a35b66ad36b21d2e76b51fa2c5363980ba5ca48398dae745083091b746a604c72bd428dae60cc0db08da3eadf46691bd1188f6d62061cff833a0e16f1696c32c54e778ff961488ef1c2c21dbcb9df0e84b24a3414d393384edc3eae69893eff957a3d27e72a427c06d5ac9d92e9a130298273db71e5eab3fbe241e1fefc4bb9784f636672e3542e32479505796aec8513569f133dd51d29d032b5614db8409b6bfe92646fdbe615dc223f7a345d3bd4a159b974c9a7a96853bf52fd601efb3e639837127273505989cb6c1ba2368ebadec08bd4f9a536db3b36b5c833e45352aec264e87ea9ce81fb16341598a37c9700c1698c03cc8033f97e3a90e149b075c7e353433e51fa70d3ae7aedaf5339cd00a0a8bbc10b2c98627e866fe11e30a9d4e34e8e515a246d84e48c63304ede862d70b75899d5a84dff3ce136d242051eaf1893a5496966efc83830daa05f09894635a4c7d7ad6afe36718a3b53cde1614c5fbe438c3b91a042500253fced70575c427f9c88e1be37da259e7e8bcd6cf6810b361ebf79752b3958e9a5188bc1ca08d0401bfb731dac940dcba96e1c1ffbb1e6f3734aa248025a9f8aab54ef483bb67d20c367b6c77c9d0052fcfd0fdde3f0b0ede464bdb7cbaf842074cada41a6a072eb9c10e676196fd6d8164f24ef98e5f013e424dc2c1cf36d25dd40cf4fb203c3a938b6b4cf65cebd4fc6bc32e33aff1383a86257e3b57fd7857bf1203b62464e9cf23c42791517f3e57233720cca09d2f5e58c388d871b73a6110378ee018826b8330971d857ecddbf9972e981e797d34a6ebc794892a6a571790754323324bca2aa05c060e523f3d9f94a25b80d51870183bb1aacb0a1dcd90b54769f8c9fa086338ce1f8777ddaa2f6ceb397e9b04e04c95005186a35fb4b610e3b1ced5c603f2af18c485a4c41ad0fe790e77d20a8df75410148a490a37057d11119ed5c966f504af9b830c122b660f783c21fd6444343eb5214e0520258f2220cf20491369a138dbc0f47b00b547f80126eb0a805b26b7ecb64675cb25305efb2f2ca6c9fc9c95bc241432cfb7ee2995ee0c8a2ac57cf114a2b0ce33daa8c219cd9d6de5bbf61f7244a7644ea1cf4544fe98c732095d25bc57812f54a8b17ddf33ff0b04009ef953206bd66acb4046b373fc94277707fbb4a4599451cd62e35dba684c2a2038520d46fd4397a3c41fbd1893544bff6de18c5073d1517a5141dd6e69b94b4158cc921b8d94cde80914aebacc4cdacf685abf3e8623f92837ea6aceffb153b140ca023893c82b37f18dabe030526a0220a53432c2af98db35dc005b6df51a0caf3bf44f0674de60aa52075c4af525b3bfa4803381e71c546d317992fad06bbc9fcab9ebf9cc07b67242d78f5e268d32220d0d3276b921874f381ac3234303cf6ad1506dd407d72d9fb0397c53586aac944a56dc3e3ec4c68e49fecc6de4fe2a4dcf11a89b9398d5fc8b293c9b14c6c03838895b5b3b2bbaded54c4ed065fba4e119b29c0befffe19b686d1c66f8a6135cbcb8601fac59123d00c640b4ff558ba72a480f1b360e04ff25f3f232a97e6092d0830bd6aee7157f406b41124f5403a0416516a0ee286fb9775dab980f899817a446ac2ace90e4898b23123027ca8da3f53b3d85eb67a68dba308ff2c5c24a9f97861ad63e19607e2cbc3a291fb84ea8c895c3117b7ce33b200a52167f2c8e53d11f8fb91926e71b62912e94d12fb9a00545224be5bc64ee475e78224ec4cf6e458e75e7cb69a3b310dd08f5e689caf7f757000a580474299755eac1ed72dc0b5c613297d17fe734a6632fc7981954b4e4f93506ec1cd0e1b2991d530ce4074d611e58431627d83299537d83e26fd5f08ec90cee935363656f6a91bbac02c8736e5645174d262eca8fc0df05b2f05f0df42e664c48622a26f0e4019c2a1336205ceb4b7d95952e13f761c12f3ca8c95e38258213e2e02d70648cd29091ea1cfd696b744ab64b1259490f774707f23b3c4a337a40e3df7f5547558365dbc9e8b20377078c3fdb76a7158d26ebd41341a502d184bbdaed0506f3bfef5211d5cc05ab357b1253522e384f056f5fb9b95093d5e3434da78d826073eda78832f064da5f076adb169bac4a97736fb50b72b015fe6dbc72b12bb5fca66099930418a7c9f0c393d3dbe5eebc58e33e2be620acfcc13403e02e4988e8889ac16644eb42a61467fd37f928063c97e4fe02414863e1aa21786ae11b2190f773f9e42234d43d539e4e4c7a24cfccbe86b3076e4cdbe71a9bb992772909ae9b119cd6d9bf966ca9590fa98d312938b1387134abc21fe5c6b5cd6e1868d16b89c454a3e1f07b7f42c621d460d264e2dfeff343d4667ba1d05c2ab738357db8eb0c1a5b0aab58175302bd8ff675c7c225c3f16e7652c2ccbe10b02dadf85a20178679b3fa61d652ffb33b1a2126625337c427c273d921cfb2872412679bb381a32ba55be0039476a4bc281432deaa6276345a986161d39767ac7280ca495091239e80a6b64d7947b7b2a719a5c736e86d2cd0816b366da9803e3b543658d77e2b804ce95e8fae3edbd78f5bb352e5062d41bd3006d69fff589d16a5bfdd9baafc635463ab6f242f860161969676c682ece27d38dd1e3206b98b1861c89c9babb06674a7ee2e75d53b50012a0cb74a2bd1ed373bf690b42f9052b0fd026f06541af8ec7361a886e96c1e3abe1bd429dc9018f956b1c21be1290bbfc7ae90c0dda84b472c3ee7d476e818af0bbb7ab19cc338d57f6ee04a4d635a00fd025cba7a2dfbf32b9785b772ac1ee8eeb8f9a77e3ad720e800cefaa8241822f1b704f523de87d822e43bbd9a3bda433f26fad0d9ba724c54c8c340c32f899e14d67cee60a6a587cc8e2c40496455c7052874ef4390450f942474025aedfc728c0dd49a13277b9e6a33c9eca9c8421f9d08f22f2f494f5215cd55f723f8fc98aec8c24d718a0bcef15676a166fa019492faa48075b4ffe24663973290c1a2077514cac48ad6caf87c2f2dd45572cc99954ad6e074726bad1e0638e9b5d7f285daee54c1a6ce5b37527e417bc183b732b04d5bed3017deb32d6f2d1fa313a5e5fc1f98cfb919bcbab0e69a32db0c711199168124237320b2388133ea29b127d65237b35e9fac6914ca749c4e76ccc7f4e77d3c8149772de7966a0c008ba6df7c590ae3aaffa76f44cfd1bab2101d2d9e512d5f434b8c2e7ddb2b7f3a858d07bf65bc1bac40d6267e68b197343aabe5af69cc5c4167944b47215e0d1b2b61bc085e1f4c5e00b50f4d85c74351eca03bc23c6a917ab4eeb506a39b42fb4a1a2a0272b01d6c8c5b9d6c3ff079a6ee94b42575f44568c0de857fee1e474a718ad2f8314f39fe5cbc817581e1d08785ed95df1965d76025c1bc8521a300332bb374de3d656012521b6c0b46dd5c15292828fc86b970e8e8f4629db43c4934d0c663f6a5bcd9620f95c9b113d26f8cf3ec7507c6b1d19d265004175e78f5ca250725c199b00ca6d586e202e76e5274e00571a69086523526326fc0d1bd1494c4faf2d7d690e4b621648e444c16f80c54544f15c2a8e592e5d83b483f3696ec84bdf29638d62eaaf4f680f430e0a5ad5f44acb495cf43f883a2198eb7fca59328ab5fdea9f6c49fef14c8fe9ce2237f4baecae70380261ab91a6a6ab20d38c17bd027fc94f8a8e306ee89a354fa1e2d869b54063e97f4871a9bbf6ced26f9bd82082243442e0b010324c16c4945a04a059fddc953318df00e05cc9af12c11f48c0632f607d4110f0054378b33ea1e40799dd0f32fd7730dbd473b47a0e0f18ac4d0ec8e6e8c24812c8c84e6ed12b6e453fbce5d3af0b1ebb4c274ef95b4cddc04b83f1d55c3f8dfa96b596327482d485bdbbce3e9d5a5bb491c6842f96f4ab8d6967528e58acb74d5ff77ea29bdae5aa1171ce79e738c2de6e8c697b28c76351296f168475382b343a849f77b27a3782f0a8b11e47f9565c47b297cd3cdc4f96f6428f4f1787eb0d9f47e67682785a3f6b73190008a58cc18a1cc3a3e8349851aa1059c8cac571e1564eb778ee284049da26efa1f0e58848553f09278d7b82cbb2835dbd79f664896f5c3b8b553df843cb5edd47","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
