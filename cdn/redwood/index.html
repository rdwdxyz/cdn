<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a0d845158ff36bb638cd9d12f7bcea9b2686bf4d9021a08c8f5413b47ce827d4eda84d560228dbcc4fa2c094fbc39affb89566902a74f0d38c27d94d58de3ac5b7508f53c63081a1828937b07ddb0aec07efb5b20fec52e76a4b6bbf98bfe2a4f2fac0aa972b13dab42c3f13b87d075ed683556d5d836f11bee75045b7fcd8e6541e21a37102da92835cf9a521f1c027df88c1c1e18775e0af486d0a6d4fc8e96545522eea8ae8b5ffd9ed104ac8c2a715c9bfbeb5f70453ef14e64637dcdfe816a8047a67a5ea9a65b3319bd78e9d7f99b9d11dcd4381efe7a3b9b8b50d956188cbf17989766e5228633ccff7d47fc74bf68daa297f119096fb8b2fe489b2d4089397126cebc4fedfa185a2e96b32296f7b442c494747fe19215f222e7dc11eeb691cdf9d2ed1a9788c0fcc24f8f03138645e942b84602c2a87c34903e4e328e87f86f99f1f957317aa4a6d90945b3f560eaf79e28aebc17a0580dbfe16a602186f07d1a1a030a41205f97218b0231cfa500088d59366ddace5bf3c81cf968acf5b7033cca6082e429063f06bee7aee2bdd44b9857d228af68b240d62970b5c4784bd8daf56b7d3f3f5470cf0fd6f759b02ff1cf8688e8cd869f6822fbbfac2234c4c6818fd91966c0a293b4bd8244aecfa60b725ce2281f31a86eb8977c8d84cf8d092bf18c8da09858296ec65fc55fa1370dd58ad464192e8f86532a410edd88cac773ebeba3480785c3c56203682882542e2e08434a6ac1c37e82c5fc42b2d726f672c865ed2232ab6153171178822bff9c1e2f7abdbd4d5c56a3f2ec9ba2b23c89260bcf7b84e6e72e5acc0e38eb0902e674ffe114c2efec043a7ed517ea84ba0ea408a9316953fdb3d9584c98051bc1d322b7b1eec1fa388758733049fbe8bdde3f272f34230853796f741c967446e566d8ee5643e485eb97c6dc26235a1707e0d31f777a9116e3fbef31cc6762f8e6c4d44e57776cc7ccbd08c4c78f186b11c81ca1afe9b4af922d5ae95cc8107dec204a5b3e5c9d9582cb3648d18af28c8b79feff7ac4363c0a246327d9ffe64be71b6176e54ac8057f43e00d0f052c0f9945853143bfccdeeddd1f8da9c9fa7d2d4a298bbaf039a34f83b57f33fc45f2924f5b5f353140e793bba60db7f985d839f24d71702dbc96e982b6f163aa290a157a230620875da8e2d4ce16e594d4be0d86fb75285f141227bbee58279a5bb2d6d16b03ca36668d16915a7bbd8207bd03bed8bbdfb1209f9319cc69f0051238aa754d8d67491d0f29e80e3a5eff5213fe07d29ee1ca833554a0f5992158b536e24b139926110df0afac6b76c845416c22e77774461bb03b6c7f6a4a7be225934cd17d591bc628979d02b4b436a8afc2e533c8883ad12452f9041e6fc8d9da1c5872cd0ad0a3bea5f928355522fd07486fa539cada975e63a45e7f5f5ba613fc13a727c766e492d72eba9077474464040c861672599e497ee55a0547348d2d5618ee5a728b4b3731580d724778cb02e8381c6cf7be6658e5ee898712c069c708cbfbfdbfcc3c55ed8ea014fc90ee85bed270427a336fd875bb6fe6a0814acb81e4ece68fafe4f7213053a846b430dff0e31d6709c9962ae4ad77d4236fc8ecfd708ebf9ec289b4befa10587a71828117a6614063a195807716bacf33f1dbd7974b52785e3ca430f1ba603eb0006f3193859ef16b8df074e7e702d63eaccb794f2966db0abc6709ca2177c4ff3e35f3541db342de07d0202a9b104078277768e1a48026c0fd8663aa2f8db454e0bd1348fcb4cd90e2e0354e0f6fa07336f1e0f254f6a9046a868ca12506cb155d874813f3ce19f5441953001656a00c879250b79184ebd246898658921b52c75a664863f5c3a4690784ac7fc65bc3eda3ca18ec38267a17fe8d1c305ba8a438e3b52fbf91e80dd7641beae150abcb69f904f8883affbf627bb8a79ee41935b7fbc6b8cbb9eee8a3f2c2a0f59410d03e7be6e7d4485ddd6f165eec6072621e20791fde67b19e18b8cc2d8bf59465e1d9249af06e89456db3cdf6a04ce456a82b3eae882016ca2e6fa3d3bb72288e087642da0e1ac69d21cf8d7ab336cb95e6eca290019f83ed6cc2a3e3402671712eecf7953bb8df754888e536cca7c5d0755b0c94ab0d8f60d5added053fa2ed4697905bbf4540a649f7cd1f1b8195c4b80033130b4a4794519face4b575d77516813b9292f1241e1640725f89359c33fb30f1c3b20e8e250c261daf36c22524853d034e3508f22bf3f36a587fbf3299e3c2542b2766f1b339b96043e4ee8277bf42fe1e8f43546fa32c1a43f56e7552fed1d76cb5a9eebfe9f8b2a622435f2e1274c6b6862a938d370adaad99d204619ff633c1abef4673311ac37a210faf47e18361a7db6418ff0f6378b9391031e459ecb2f9185c0e18925c1d7f51a0f09fb404056c4f74f9820d49046186445a5f3712594aa3d0750be417dceee40ddea8ee8328668d2791e9b178844d51fa74625d276f2faf10df91dff0dd5897693c9b75f568344351cd87672c6f3a48e0d5933430f1d477583cc86b1d11545c1eed772d3f163485fc4e89b28fff55c84fe31df4cb578cf736477f5b673c8601c124cf6465e4b4505705079a1348dec92865f0f840ac8344732e987e6c2f284fa02205e61c7553ca3e03183e32bc6c99d9c923fd03486dce16847d315975d8db1023ee851c6905c28f9efdf690e6bb27e89fcb7df77b26d1c657803064087a27832eb3120ea7c07476776b5cd2fe71940c07c523cbb12b907bac17227d4a33270ddd08514e0e8f64992151538949512d3eba54a64c999786f5dba04beed8ff7fb8fbb660c076e9af8a55f9cbf17594e23413f5613e600d161406df3c8e8ec9ef73cc523db06bbbd1344ebd565df191c20509076ef1caeeb6ead8f0cbcfa0a6dbb31df828265b5b317b74ad16b148ed761c3c10786a38473411f87b2de1df61b912affa1f94eb64a8515b99b42d5632a5b19d8c5fba1c7f9a2b66f23522e150ab464127b85686536d79440a21019201c06a8962f254c8e1668a98f1f9f8ada2e38340c9c3e69628023993695ef399d0f727f0daebc3fc6197254e83ea0034c3c704b3a5cbfc4064a3a06c15c9b9be43c53662a4fac001274f56d700085d27775e3f6aaaf29d1b1561703fa5b877173e971244879211a65e9701c7a7f9727aec700179a3cf1b471986b6219a5b1b8e62209e3c1ff21f1f5ab17a8aa72c0534b43084babc9e06d3dafcc5b7cf27d0582a04bafa436137e11e54d4f0a7901d3ca1819b3a0315fd8763f2d60f8b1075dacd2439b7b70ea4c6977b0e3a7904bb120f8669256dc036c1e1048c30fb8f9f70dcc87ddb673981a89cef3392c5b4c2a7eaa7491b6edb07879092f08dab546f2b81797b6cf7c7cccbdc163b9f6efa98fc521d74f596cb516f9d41c5512062313acac75da8178aaa0a0e54fe9b02f98e5295dde91362d641e66c9084e8dc0fc2673eb20b1563fa8e8331d87e60e18739772af17ac6508e0cb1082a55e67c81bbceb1d517d943bedeb6f850f1828307859f46a0ed58258e4ac0a48da9c79b380b78deaa03437fe79b4fdb45225929ffa3955daad9417636565d1bd97be41580e34bbaba0d17f716633552ad883dc1bcbdad09c786f32a56041633329be2435519ff3a4e742dc775a51500978f6cb89b3dd96c424851d2da2c5bc8fbb7b6f6a0915fea61356e242ddcbfe290ed259bcfdc9c263648ca9756bc4529c4b85c6349f5e6a2b21e56267fe1d013eaedbde3f64b0e4e140124a2e88d03c8fd3aff23d0a3e897574dfcb00436d43147e0d32ee5731ef7b62b625ddc8f5881626cf1579edbf917517e99cd331fc5379b44ad152d29d9af5d75399f3e22173aa77d9706426007c1d187fce932faa9ea7afde051fb762dfdcbc5b8496f9a968b56468413d0af74cabd73c3d37d416f876bfa762319d2da584a9fdacb040b7ef6e55f928f2f555d59910f3af51be8bc56388e42ca199ac30b36122e6a870ce7758dc1a535ea3b13c5cc8bd3d8f7de93a4cc897efddf0e885ddccc6da66959b54d0305bbf946ee986105965c0f573590b3d094816fbad07c7102f9debc2224884c8eb0b73093f596b8cb644d4619efccebbe40f7f6013f4a2aaf8d5ebd09a04c689048a1a6b9b56be600a71b85951c6b913b85e9595947ae930b999afb56ed2c5e9858396e1cb74b30250349c236e488a6109d480ba2d151bb28c2b8013e29c4f3fe647ce0de2a2ca759aa2c263d3c768d931a7d518b77f762b8e6837c88a968761e1d7e4f0c366b06df86970e9a1d661d86765d94a59fea9dc0c54c62e1137c7a8b4265e492f364b8ef5a8f290e3f2ba5089c874f40c770629dfced9ef584ffb0ad84badae710aa8e6bbfa54ce37195688aff98426e360db6b680519bd9a4b4d92276bc1e2508ee46faa42009160aa4bdadeafd1b15038125900a6a4c9c8be88c4cbc3434eac63d0020c2ae6a128b09d4b82bfcb38c21b23b2076155d642abf38882ba3bbc8b104b7ab0a1b9b3a146c32616b18af1acab36fc7d906a30a425d236fde200dff4a4d41c83f1fffd637ad2a6afe71cf2984332386851f09f095fb6546a45d9ec009d53e7fab6fce64efd4118ee059088dc22c9c77e11ef8414757922dbd796d96796ed2cb013069d087c864a2e4654cdbd7a80bc6f79558740ea6e4ab5041466ff6b62e15355d44ad957bd07ec712f32cb501b2667e04ed0b931b8048f1875655a0c9e31b8d0fe36d32a3fed7cfb16e4a10d448f01f568cdc208139ed6f25dc0e218c4c348be343886343a1a69071ae181f819834708dfd9353ecf91f357fea32b12b46b3da0fad8ae2cdb6981b408d32ed07a8cc7c46371919d7731b87312f759c2093baa1510555a02864ee7a5921b47babd4576604e41a39f201fa3af35e74a8648d41675987e7c72dc06b0d4982658f937e9b150d4185c09f29ff124fef7449ac5374f9c64d4b29390b4af1671ce563f4efef3ad24fb6fd30004f459aa97e1cc976cefbbe38b6b5ea4ce9c038bb3d56fc51a9d08d56b46d185ee6d5ef63b73c20f34db1539f770213164907c65ef8ab43854c52eacc32b5ba0e8499c990754d5d24ecc422a32cf9b44f7fb90c6a11bff6444d6423b75556048013915c8c298def3f16bf5e986ef407a0040a63047d9f3f07bc0d826f0998070a2b7089ea30b3d421e4df3c2510460cf026a42b92ddce90eb31cffd7fc4032f77fb9662c8df476339935bd3f0ede7e125f89c81785e9569ed745acf4cbb5f429511ef87dfa815d65a8a1a7070347c6c26264aa6cb97b3474fc2887eb8aec8835a752c9b17766527d3ab9d24d788c56f4dcbda4ea71a8c745115ae0d7056d4ae48b602f458ee95a5924d30b76d1e0067c714dd1587c8079cadbaa4d624835bf4599c60e372ea7a5abeab98761c7712d94589397c5db1e09e43c251101270d37029da3e79cbc38d94b8603c77bcb772e179a38419f7dda5ff9d912ae97b65f0f2e93a801c45d65398086e3b03507d434e5c98853d10a5b42011dc2f3a58e26bb650e7e158a26788e211f4c8feedc7a6347ed6fa283980573ff2b33a044e54152c04dd221d3adf863f68a089bb98cc57c9ce57d59ab9111f477ab54867a51f3340980e0d8db3d9698e76f9469bf0f4ef0628a3138a7eafc8a524750a133590ad1721ebc0e043606e9baeba0e2eda0692b09c9fe672ddf76e239ed68441f1e85fa163d96e827439efbb34e8cd3c0332f58201b5b74880cf0456b986baaa75196e630fc4b118b782075d80895a8aeb3dbfafe98208ad273bd190172dee9fad5e6324c76ea427a738e5d18d26bddc7279053d382609ad773d3d82a864448fff9f78af9d1ab74ab39d9adb5b9ba651eef855264ffc906ab4c929937c072460477d1ff2a460ec5aa09bc2d3d9874777232bc860680de275b3c752a1e78768b165e160e0da9ab0121affc04149e91d2a1b8533c31230d81c18d5cf7433ea0555ec319c8b4a2296778baa1c110acf18deab18fdc028ae746b4e4011c6d32bca3a9118c48209ed45ed84446e2192a1b89506d7231f75c1f84b58666d9b1560882adade9e27110b30297ccfd81fff05c3171c101b59c2cae854ede26f04025118ed85687b96ed6179e8240df61115f8eb9e712c97e5171a336c6580e3f611fece093aaebb2f2bd3057a614e6fea93809b58c31718c15e3fedcc6bdc2e87439fb93bc5aed115b297a514589aab37672245eb95a4793c26db7ad398702fcc0026c1d50a2eeddd53076f66ebad596d75934c59d06176173e4e40a241b9eac83bd4abc6837573839724e061590a582325cbc213e3eff4baa5a74c5b0ead9c3366a7020da5dfcc01eb9a430217ad09eb6d1f3c9e6ebe9cc1415a3b5d5de0513bd600d9f33739be348c6a4dbf4e866ba3838b4969cabe0922dfe453c77bdb614c656bae9cd008343a36b42ba9913ded7351d3f79afe95bdd9a0bce9eb5b72f8d58d6fef7ee0bee7c495810e929c7284a688737243cbac9f730cbb5cbcf0949189505f8b01311325731f245798ccb92f7d156a5c8b4a03bc66d2e0688b01b894aed722f28981e264b74f962c1886893f4c1a16c859c78dbcea06f9844f5ce4cb83449f169c6bb8b39658ff5c2e0f869e29b295803d6595c2e739a7e6ece6e708c182afdc7b93ab641207bbe199193ceb9f2f683546fa09c5742cac6c083b2aca47a0bdde1e0ab3c978907a512e516d10bcab2da24adf0a85afd07898f8ee93923911e2b0db3ef3c7d953a17fd6758f1c13190ff050fbac42dd393a23306127fc6aee14a6a4c45270bf9e6bf954fe0b74efebe5bc0f619e1c1d4bd1457d9c0547b4b5daadb7dbb068b2ada8e48889a5e8871e67855b9dedd3a0c6aac7ca12aed0e16c536ffc20fec1c957c9d26d5fd5f8fd82307a93393b2877f60a5dcfcd3f20dde4d30abc0ee7cd35660db6b40b91c3b6152015a922d44f3832ddb7a3a6d49a5e2b4f9703cf183be5434c17168dd05668f33575668c63fd5394a165eef8231f8b69229bc776403cd9a4c8d715b5357026078fbc5356fe5f55ab2d2fa0d81b1292cd8bb0f3215fc55d40be04d5853b5ce80f27044655bed193bc4b781bb830265212404796c484d9a9df4b4dec85e00a9108dcbd01aaff8048e08cd63856571bc73e4d97385515bee2b0dc4263aafa6bf4ea50ffbd84f8c25246557437c10e8342f4405cf53ae7eb7a38e2cf1ededd185a974fb8badb9308fcce34342c2bd6d489e3d56690dd9cfaeaf1e7a4b585da2cc464cac975199faa1b7d75ae1408cf797fd29a159fade07486522d90a6e0718e5411f371138c5c4141bb323e874ea41790e639088b44c1e9eae19a63174ba4448aceb683e279f7c03cd0499cdfaec4e16073e1198bce49f62e159485cdbc3f4827e434807a4db6edfcb9c1c6857c226e4c2bc1850d74a82f0a816767545322864ba5e0aa59d64df43dad715a13abc4a3223d52cdf567eb8e5e59b643f1295e185b4e9a9c240650ff662456d44e7cecec44c1f6d24c6178c36a0e819ca69540ba4d5ef558f11444a9d92a000ead3430ca3f84f4d3e049aff69fa77b96b950bd5a675436ff623c8cc0c8760b460111e2f81aedc5f8be796002591d94bd161befb7d7dceee5098f6477e4ebf4d055eeddeaab8e89bf6ab976f7bf7945de4ca072a8c9a3b36fd4a78d242af0bf104071092fb366c1a247a2249e20fef4ed316809d59fd43e43dd6f5c07322c125644db62367ee116bac53aceea1033a28315338e90d2823c905823031df1108c6af098a12657e5f0d077ea938b28a69d79e6e217a0fc9d903b071dd6e6938755c82bbba6704a108b7922801cd5328c9a2a650065592cfde313456991a9539a4eaf2f3bebc212eca12e060f8a444bea27ac885ffcec1e3830793289adbb3bb514ddd11b461b3bb8c11d0d1ebb4920c3e78a783e4c9edb768f9f555685eacae4f7ed0fc988e732fd0f1d1b9685e2ad6445eac858714f38b828d243a53a84166337d1f8c1c51ff4a863511dadc64613fe02b5d2d7d3c4665d5e0b81e563e0f8c120d8e0c1565e0fcf5727225d922ad67d352a12061ea138ef1beaa8a85110794d5357517ff6bab373c42e3b7186e0a360bb074742020b3e1855016c4fdb273a7036b85c60dbac7ae5c3b68c746a1c9141bd6cd6ef22d33986e9d92b9729a86a85eb7b10c8f09a0b0509760a3998b93f16ad6214561a215e2db7d302e32c63b367083ec57897f6e929d5601e3148f88521a530164640bb7d68e908a13edb07bca7ae9246b401b27e8ba2e361c34218325a9208ff5d264bc7098d91db7f710fcbc6375f8476b23e36467d220afda3c8683b2c88e8a22b11599df6fbd504d4e52a58c723d982b74149074bcc7f62520a55dc28fc3aa9bd1f7439db9204ce1aae111504e7ea256d10ef99ee573eacd963651431e39800d9b4f4f9a8ef9b6262f521f9a2daf1d4d4946f1d38b507fb29a8db426488aeee01e23f0ed3ae2c0762896023950ec21bb7292b8fc102d7415f0b554d11bdf1e4fc0e64518e0c1d23ce64d3839bc6d24bdab62794fa437e5a167bef16b527ce9745b7b6f7f90c4e0c29435d9b68e7f0d1adb104dc111a9da4744ca8f8e0b0a52cbf54fd19881231ac7dda25b5a91c619eb9ba9e8d9d3fc9a13dccf1873d27b8bf9e51eb70a564bc753786c6491ef3e33d78c83ddfa462d8de477c25dac08ced143617ae6b45adf38ee0461b92a3ab9967bab56c200640c3ad26cc9062dd9986f83f99b4d3d6b505883560e00edeb2dfed1425eeebb9e4bd733735d158131af8b1892a8b80bc8c23811380e764f0f6b23c804ecfb432427151d73abe8877548c1dd8b0fab55c313a95da0cc5ccba9156ea3d79230177fdd401bcf66281df44dd89211a9a2e52f5beb4447868911a93494260f580bf6737ba00d9e995bf27f50365c3e0c77ce5501eba1ea792bbe1a67bf9d4246d9f1616a87828d44cbadd0b3152f33cdedbac2ea7a56feb176f1d9c119226966ebc9d4c5db62657d0f808330c67150aa5afd274b511c9a24f279d5ef1b649e4ec4a642f6adfb2dc09152f0557e7e01844b1d10944057e3af06f9b795f79400bb5db70ec1f0d8e9472e573d84bb4c476602eb8e42ca91ff3283035f703a8e7d0abab90b3ad02765b23b51073d10c75d5ded4578fe438ffd691a2824a4bd4078e60b0d8c5c1141915d478d72a5f2b25ea88379d78a7a00990657073de1db3440a53112e284a9f57c32e65456cb6a661722cc102a43a82aa57df92cb387c75743ab841432b81bad182dde1e2823c24dece105a3ddb3a96c38fd6d2785e7cdcfe9eb2426b2ba89a7c9f8a80ea7f2a7dc2f74f39fe6e86cbf616dd6d2e9614d4bc7cb03b76f0b6604f75776ddbb59bdf5b5db9e09d04fc861845ac72c0bd0869264631b81b41760818c72d66654df1d684d8037cdbff170b25dda1f1b253fea69446404acb0a8da4507993e6ad1ad7b6a9dcc43e38c16a876d510509112e1108b4ef55b06e35287428a92e3f8072d542638d182bb237699213f25bf98c47634404cac65a138e70cadf53371967ed8185792c615342ce327baa2699bc212baa7c4e92358a13c3af8d560b0bc9787685a1b08eaa379d6ae8f1388b1a7fe82c956ef36daa0e16fd2dc58b89628f9a104ffe1c053ffcfbfd06e1d0e6ae52e3b41d9c82c6ea451ccdb224bb33f6e4ff2546acbfed0e1d7cc1b53a2a243cd3f7b420990b53619e3d07b2b6ee23cb5e0a91eb5d438ae9163a3ee4caccedcdd872866955608e2abba90abdf167062aab387d25520e521940b8ba9de662d784bd585483768b916cebbcac9e8e4422d600ba053c5ec5ee4a52a9847a93e822a72ad366706af35c997860fdc3106391661ba09896da62710cd011e414f9bf05159355bf14b6205b62461d665e59bf5d4ba1c8be175bed1bc36a5ff42bbca9dbcd0e0c1a477034e4f2bccc2f721b7f253ef8b0d156e8077bb796adc0dd82778b181fe94acaca61eab7b582b041077413546b0dab1ce065b1950862ebcc528a7c750219130e44de32095c46fda6fc0b0bca385b37cf62d87e3b53f957db6387a3dd071053d1310418deac8eed1ad5f6a95b6cf07a82e8d022a71090b07d4e81c762ae3ee87df192ad2814239897699cff8ccd42c82ddb37ef612fc38138082f3362a50eda82b87709bf82c067c839b781689076500ebb53809f0c325c7262e6c904bf2d92e31c53bb1d129af4daeb8e4348ab3e3b948fb59d30a7a1b9047ba8f4fffc8e0acfcbdb6807976617eca02da518375fa2cd22b6875bd7f34a189890ab185b24b0f541f5ede1fecc4597f4da5e00b0ad231dd95e7e68ab85682455d3fedf820f28cf39af9c06b694bca8d36a0f7f3290ff654d280c1b9eebcc125ec62289988e05dae64cab34b8375d47f5a1661e1425d1f347ecfe6b26f8749db7ade6aa965a2da0df64a9ce06e708cf032efe0178d2d1f05f84c09d9a91ad2185492bf100d9511adf4c918478fb245dc9eb05364241f2f949e40fb8e7d6005fa208a80ce721d3f2fa1ca576e2d600a8ca30b2797a866ddbcaf49db80025005877af39a3df71774048c8dbaf0674a8a5f1a7222a47d5bee27f1acc0f4d6455cef1a0dc9506162ae56df1ea0f2948205b9386e8c811bccf08d958daa446e3efc1e04d63798edade8199f2143b9d1923521f441638be5ad3fec3e5a112fd8549316f8358d53fd1fe440c3ea774d9ea0cb78b25b20793b6b7bc23e58f9bd8c2427cee2c3c4b8bcf3c0dce1705f75b56aec8264b7a32eb22a1b761e9bbe604e7c4cadf71dc6a1fd286e9d81db622486acd736457a234594fed87c5b6b7000fe0537957a802426c3a5179f23a927fe55390e61b5010f21cd9ed9c97231c06e6eec842d771ff8647eb163fd4533f557575521e1058005e83913b588529e74ef66a026984bb0bdac4e614b9eb15ec4fd862e7fc6084cf00dace0981dda489d8c6c07cea5dd4483735d405ba5cc4e36c81c874b7b99f85b20ad5e557c60b66d33608d0dfc33486f5ff4f3fc134f6786cda3f3da6e62855a783e6f0f42922042dfb9123e56af8195fc591e226cd9c828f05db15e135a54ad488820f42c1be4db2250aae3bf3bbcc71865fc002746ffaa72cfc2b6b2ea1dd82b21724b00a502aceae4d785ba1ad25ec1b81966ca8db386872f2f7a5a0f61ffc083b00926cff651926def41cc2c14f39369c7df2dbebca9d7e6c16318f67e4f5188d8e7bee610050e3fb1825f3b8edef13c15fda8f39ce777fa744766e6c844f5b27e403af11d0f0730251bd8991154d8cf760ac79b4c5908543c065f496ca01644a61deeee03350c3b36e56d884d427a304331df58398c7fabdc477d9d8b1b73d95198dfbcab5dfe89eae8f2c4d590615ed5f53b35a62f92eb9b927acc7ab23f2519f03cfb0fdb3047bef9a8bd160a1c39a1591307fe604222ed7a6f52c8a1397a36912204a48be2cdb7b044504a3af6c162e61e46d299c531dae55ae0af6ad18fc7cc36efb95f231275ab4c6dcb0d5473c723bfa4bc83bbffeebb902eff79684ab92aa7ee89b9827b5758e4b7b5c92472283bfd16c1aea63d5e79e1143b8e79494c45861ae50ca693229b3891bb54165aa1fcca6cf505e47093f5ee506c98735ff7137706846acd61d0cc30623b07ed3b91bb8c42bd9aedbf48be9e46353c4fe8b3730068c83fabdc1de0cac472ff99353b67fe6b2bcf320417eeec45f34e438890d421b5d6f71aa6be3d901fbcc0e28346aa9919f41673295d2f959658ecbaba60eedfd3fa770dd041f929b6de0797c2c8c9228f22e4b4f6095fa7c1dcf219ab499ceff00de931cad5a9a7e64511afb51a4f774c0589d14651d5159df22ca43dc6387f5abd31c6147f022db220818e8e4d8e551e9663ee2a58497579904a44ff495ff966bd02d13af25d4744351775b09c58001418de826a9b888b86d143d773c98a22af2316c0de0734b6bae0418aeb7e3c89e64bd10b98a466363f7bc6299b6ef3713f9ac1eb6cb3a349075b3835244b6199eaaaf70734f0ab0eb806f38f90c20b225cdb86cdf03ee848e5181246ddef1af288889144484d20bd55f560fcd04cee781af59cff7b50f9141d5f0f5efa980b6c589c68b24f720140087782c7d52fba96566cc33a750cdc8254435cf7b6fb9e55e94130b3537fc3b0718806d7065b74777853bd1c28e258feda6a1505afed25027a9537e5665a96cdd65f4737572ea5b05ee19dc6e9ffed3531aa3a2471712f94b236d6a83bd2e93b3a460a1270464870082c42f4824b92b318ce0155bb290311dc8ee7b30a2ba9b1478613a244469d9c6f2403b7a03989ec3d5d242a01c278c1e7c3b9c04ddd612fe89c86063e55f4da55c6a1b491b33bb5d1cfe0b6283b295b0c7944aad73381e1ab14cf0566748babbf0551f8d04f26df8c04faaa494f8703926ba811c49e6372953db6b3a8ed6c37b0f23e353ef69ce679aaf1c1e8ab5d39e4b8d9d953de13b17b871f3c1b566db0e368c704cc92fcadc88d6c2cdc099420486d906a39ead6d8627b4d226355ec6fe384f0d63be9d649f1f0ecfa408f37a2143c6757d83b44feddf919bad7ed9b9a5796207669e7fb31ce2bdd6e2edc3b9954462166de12d6389185d5fee2f7a0dedd124251d7cdbc8cd36be1e7653500d6a84aaed5b76ddee75139ab4c211b522c47264b5c0bf6a97995efd9e6f29b5739bed1696424873529b054d3718afb2cd69d61e31e65c5284b986caf108ccabb8df98ab5a8ab2cfe5ddce43a0a843a9fbf4e71958f349b1afa9d8290922f5ea05c23aa1723fecd146ad193a41a351388f2ae866c824808a18d676d9fafa857fa049a8362ff8a5ce53dd99aa7a39fd1e133797288ac581e0a7c6202a1b0548969519f01178da2c2089b87702c9989d65a874d1ef9f24b53c53729c8fed428d138d140877491d40154090499b51a924901f2e3f175fe340c6f107c67dacb66d3274665b2d4b4c524bd943c3f35d938c95b86ca3b5d59f2b8abc8fab94ba28e8a1fe67cd168740aa02425da577e0643f2b64cff9b8b923a7f034d0286e354aa631d12619383d8b53c34d6b5cfe2076aa972c4090834d2a06e3ed7d1f78cef209f8d33fbe19de29aa2f39a965eb09b6a367f5a6529f68fd5c0a7a749700b25c5c901032786e02c00550d5742e186fa3f25011b23c5695013d10a7b1bedcfc015d646590f1c546c2ecc132a6b5f453b82ee1621418b4e86188af5d1b1412614986a20c695fbc6eea626a3cb8c7f4df76a283e72e663e4c0c92e60277e95a6603d6087e3da0ebdad267c9cb6f4fef0785cc3a69d278602adbec2fa633b21e2a9f75a7bcb103622b1c181a226d1aa66e5968e012b63f44adb8197b92c3d9cb3f39c874b1ea2897eae9b61ea2a4c66127682c6d40b3697738fa5c58b655db271682510529eb3f0af33731256468b36224db34b21396a320af5c462e31ceb9d5142d8144c523d659e6bad013c895589eddbd455c59aea7108317168872ea7d98a536f6f2554304089f6cce6d8b43d0b9a448887ddf4731056e17146d2ee2762e86f5469d0e933901b484459887f4e20beba108095b4126cfa5c789d55c1f4557cc8040aef089002469c8e9b973e072b886fae018ff5f20c008431e6421664c01986c2e784dcd42c64f8ab65797f92f5f3157ee57aad9c33850fa244d08a8111784beeceb15b225ce33f018ba5cdc8ae79f9c908792c6e56decc9f9c226b3168509d31fc1a5a73dfc64de59d0d50fcac5756d8655c0bea73ed1006e69ff6fe702a7bb261c014110e17641282579814d47619e07f782a0e8895d42726fda883ff95a2861efc6645225f35ebfe2d84b771030c9575a54dad1e5edb825ac8d9df7982b8f40a831e740aef731fb5efb72c235885faee5e08ea03bb5f467118f415e531ec30ed0aab24562ba67b1a9e7fe83e3871dddbb4aca88a3676998ace4fbc0384edc128ab822553b2fd1c653c917abc7b5af78af6e2ea3219141c192b68054f9577872e3852e690027bc0007453e73006e9aeef681f57751383c5ac7f7aa01506c2a382be66920926ee166325b38a9287a2ee843f1030aadddad8420d1b0007d925d806494577a30b78ef0854484ce243b951db89ce412f1caeb80611bcfbe684fb85c4c46e94ad8ea7b6f954edaef0c4639e980741f4919dd54a37f33ac3ed45ed650ed52265938ce525bd93135f99084c546cbf7fb3033a864062d7fbeed13c81b18d3235bcdbc240341e5e822328c8ca876eefc11bcd39f1959b3579cb146ad46b1dc330ae428479562497d87f17592d77601f153211239de6a419b51dda36da452cdbf1ffb8533dc6cbb16ffa8989164c8369963013d0f34e912646572760dc62fd75c29ae7b1dc46d3003612c69a5f3e23fb8befb812fe5a46034996893d183e4414e136872eba6ec6855d5301234316600897309df3b7e07061aa28d9f8a79bd2cafd32a0605261f66a2230fc66e41607c19d2006100509ed532970954aecd617d259d9436e1de7fe1118de41e406fa3a0bcea4a62891aab0b114c6f277ae403236ea5aff675c443e1179f28bfe6fe8be7e3b8285c7645aa764b00348565791c245346539a8c5936240be75e28022c2fa0846a3da142f73a75083feea7583054079532ea792d191040085b907d9f238b5cf5eeb1601c6352cea38eff6bc030a626dc1424cfd38b7b7650c3d48ce8174f54ff048e45e2ac4e2e7a96ec56d9711e2f1ecb50716768cb190044c396a27a6857af4d33fe4f1ff7006c980d9deb87bea59181270a85ce5360474a1970ed8c1282f96b3bd6901678fbb0e99149b819a03f3127577dcbc02a1faeefc44ddf410b1f1c0db7ac9b9e68c3857362cf191132e5d058463b9f043c0b60022a0c19c93f94fd8801e6168f0680532228e91c36831444e3215678a4d4ddf87eaf009b8383390f4ab4e83e05323941526acf14b9248b4c3790a7ba99eba66045dfcb2aeff53d0520161a56c6218d016f118fca2fb973f5967bf64b01b321128a93993506c0ad2a0fb468788eaf888e99242ad9de5efdaf1f0383f2e282359502379d375bf9f5c00a48136eeda0615896a11910258433f297051aafa0470ed879f43108fa1dec1a08b2f15ce27ebf436fdd8144b91745ffeebfbe3bb45ae8cc3f38c9c60eddf5d255cd7682ebbefe9e8a4a67dc1251470d5ece2c3af1a06c32c06a2cae33c8dd96ad5f648310a37b4a2918167a4bba8877ecee520bd9a2cc32dc20619a7aaf9e097bb06deafd7060bf84a5f9a6080433d053866657f940c4f510bbb6219a024434469ce4d7bed6ce9ed6a198c5280429cd3b27441894ce686391bb26d08854fa1eb6ff14aefeff7a9e857a5a9d352efbe1be295c678e1c15577f2ba10b462624465bca7ebd72a88919628b1b42c042799fa00db9b496fa52f57c7a61b2678685615ba3ea858f5535d6ad6c0903d4bde28208c088c7248b6cb4ee10baf18c15d5bf95959325b8e953b14243daa7c1c9cc96aaa6c4827bcbece5d81df323a7ac009e74816b5fecf4ccbcbfa4474161c0f69a0e67bd134940b737a92903bee203bd16d86e01f10b574493039695c6f914d6408bcd989a29df5edafa4a8016217ce47d89d46fa3a150351e74eb5a34e73f2f407408352699a34fc1edbf30acda40ca31558d5ab1024b14cd231ffcd631e34fcea4cd972668b3239e7ce5f5d25deb213ce58668128ad36ef2f19fc278c10ead1490ec513d31bba22ed99ec2d5c3b734e4c0f9acd3f91309adc6eff0d9961dddc0a5247af9b16fa4befc8bd9695adea58fdeca877eefd556fd4db49fa06272bce6b38ee3b2a5140839df50ac777ef1cd97efb2aae1b9ac6e1f033ab1bc900c4a4b8a59bf3d2864078bd4fb4575d7167eb39abd2ee6d9d0ded711e63067b9065858fd3cb1400439547a8041b0ed4146b8419227f2f43c79f9415e169588b3318672c5de03e96dd3e9171812ff97c5e416a7f8b33448e3b8592b735993c5b769c239c2af185580a10778ae76c706600e4e701d7f72c161d20fa7b2eb7ed63308ec78c9fd38230e6b358cf029cb82f9334caeb114c75186b954c2911ca9edce3f758ef2101e89c7a4a2e15ccf138ced5548b97175a291e18d3b919882e0e124956ef3685bd3c61d5e36b9c334843de41b55ee027cc0620c6c6a62bc1efbbc65bb91d7172858d1e72aed194654d0cf4cb471ff5f8bce17a6f25c5c1d46f2466374cf6c089f5faa2475f9f13e57d166fd7966fafe9479728c764b09390598b745895a24f2ec808605445678edc851467c6cb711c424bd40fcf5a194a92b1c11a442f5828e5410678624a12fe20a5f4e8fb35f14db09251a130dac34115bd80d81a5e436e7790cedc40616efecc3a9fc2a62c8f9026eb3de49ec1d56a999e26f87b5d3757d1f9bab78efe4ef7f668be6c58aa7d2e79cce9cce71dcb801d4c8abe4d424cda168953f63cc37027434cc804ecc3ac2457c46680465d6a8ffd41af1de4c37b407313d6f326bf6cccf3f1a51f2df83b912439b1ca0b3379bf99f0e2189d134c43420d7cf87e1c79a84361b100cbbf0d95818e0f26651bdd53d3ffc98910119ceceed96216a4ec8c312b42ca83feef1640eb029e5b2ddf8e21bd8982ae7db4e11060c6c10d3710443588f79805c0b73dc4e2c4d277c3e9d45309fbe352da2ae2e096244d2ecf841c51e8b2793033b7499278ee92898f305874f905115daf250790bec998d8a38faa4a72a007c11fb6cab99b75512bab6f5fb76b83feeaa64ae4477ca4bcea062cf620c966129d46d247f47e3204f3eb1df09bff0e0fd267f85a21364a7c289b7a0b4ffd8c8314e0b830244a64757f2c735e7cfe2baf34d1d0dee9f3a778f88a11e9610f180c2a47d3447782c586a9ebe34b070e3de56467ac47bef1be8ef20598c2d6263832c8dcd4b8d1111a348c48e299a1bc945d382bd30d438d9a06b40db34066f1b1d6181933c43c6ce1c4dc7337183a9179423ea0920bf995ebf1d92bdc17e537c5c8934071643cab676c8201131413cdff5391ba2cebe78a05c66bef4d0197cfdeda19e5c4f19755b18028e1bd164d4463d74c2323eca00187915693e89e70284fcb622c3633fbc4de276a526f07e537443681cc173bb83ea6abcd51719bfcd882b2d6755c991d9f491e42a91e53e3abcad668a038ee5cc954caf3595d5b4cef70ff38e80f5dca80970bfbd0c0ba71406c1289bc64656df2ccb791a9022904d3385de2de06fb490048ab2a76ecdce6e06026515e3376c1099fb44e63deefc0fe5db99091b7c9a9edddab2ce47833b63b55cebbfa3beb9ce54655a2231651f3c3724c180fdf7168bf69daedc1307c9d493ce234b5b7000c9fa0779de64adfcdee009df6db28f262bc4cc959de48a03dd4fdce41d9202c1578339a10b4284e483fcade4bef5ec0b1882c79ccf7cacfbc03bdaf595b867c3443c28673ec41869798e0b52ed55375711b3bd38b28ba764fed6f05f971ec2eb036dc545cdcd14b1823a398b13da1dd2105c683379dbae542cc89adf039455fd32de3578a95bca17c4e057fb88a5cabc21aeffcf137e493848421775fdd0a2fecf0b7a26d111d75f744fa8c606e13aab8d9ef54a6024ed511136afa3eb828c7bf563f9b457ddfa7d197ff4c824a9282da6401095ad57ea8e6eaef69dd4f27173f1b0468362d68ddecc23fe3add495ebbbc93742b126cbcdd3d07bf26ce1c42926391307ec855e2fee4148b8d614274283ece8b8c3a9c617a421a8a2d784e8ff717f4e2e021367f02d4b8761cba65b4ff28eb5a0006a1a40d8577a4e40b35999f0faca93a843d98d4110dec24b6e70b0082f1583e5c96ea355db79bf63a0f117b0e835a90b5703a9665546fdeee5e5a815edf4cebeaf451ad36a1db747f8b72c63bdb9f0d08a5ba2af17d3575b8704aecab0d526cef18447b23d5afdbeef00e84d45753e4c2c9855c8f503eb3f5a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
