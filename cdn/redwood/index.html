<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4679768f661084dc8225970e96331bf6d638a99a5109bd3c4cf13c594a78f1e515f940eb2ff650396ae490acf50a6ed06829256df530b84f7eeffeaf62a0cf98a26c71c82d8054018fe4b45909579f16d8d1e9226ffbc1c3c955e11b4a35f6d45629049184fa1019d70ee522149c58a35ad839a0314a1255b6ebcc4b0cb555dae408036f0ffa2b2bcb1d0f0ba968392052eab52c7e52637195ca280e30e97ed4eb9be4909002c99d69fbebe3de0f95245246f485947eab037dab36886dbd1841b21bb09c13531d213e077208c0fe95856275734d34e6e231aaf9a4b1923ee631fe1581b7a4f8083ae63cdfef87cd239ab6dea950f625352a4ae44a8dfb987bf9762d6c2c1de1b5380644f481193aee7f15dec6aa16a38d384f80e9773de9b61309970a7f0d0733ca9a7120883a88e6b2d1a5e52d1919d48c8de22ba74303c02d4f31223d8bfd864ea8c870fef6a24171e73f9c00ab3f78a5d1de59647e1e38030105fc53f9b7f03686af229341227ff176a92ff191a7840b793a1cfaa5c7ee9798ee646593043147bf32213e5f4c2da73d443967ed2287acfc9985d736e629fdeb51d68c9241f768b92afc6bc3a18fa79b4c6b30dc8272847207a260721c96c4a7df45345a215fb5eb4438329f5f6b22aed236b762730fac3e9d2a419dbc3f707f5920bb3b2579e314bb5f03c49b970ebc68fe5136cf3582150d4580fdcbfe7f1f306929239c5d66aa513dddd5347c15b82ad2018e242ea55ac2c19f27fc24e4f40cbd1b32d518f04792a31711827a0a5befe9ae730e513bbe6f97c66038b414e9325053b5e831d796373452f9d945b283af9f6f194a23418b34b7d5dddd4ab7727a6016abae936d59a91d1327974017872daab2ec1c43fc6d039d030cd92fc6d1e1a204aa80ed9b3210c7a442218a5c6c56a60fea1f73d987011aeb6e963710f7cdd30d15c0f3f087a9ae5d1b8e9827118b8ec7e786425e951a06f60454c6fd90c6f1518e3b49beffca85efae78e7d239c3616a1542c4a937999cf572dbe170f4cc64c66b05882895670636f5e375910fd478fa5a7924d60af0a3e9bfd07870b5c99e0585784151b589648fc99d2b7eb040d17b1aac8f68d2164ed856ef4ec006188b1d2f539b2a07113ff2a78c251b50ef16db5d3163598fbc5d74bb85fb46fe1a041d429a55c1b3d65023c5be784ffc5e5bcae8bc0dcfcbc58c3e79a68d9d33ad817c0e6fcc70ebd2d37d4a0ffee5fc9e406f8dcdeb475555d75f8587dad4421334f78dda7564a9ee63f7025f4b133478131f3f18b967b6d5581b1bb2693219788c3e556433d86d57db5cfc8270350de844f289f63415ead01b6640de0bf43550e519ed24a598556b1bf9e3a07e74101ac8cb0cb2737c857799b44c423633fca8addd6c3d27fdeb82599d3d7fa99737c0dd84451eaefb6a8f2100de933d5e7b4d161697003f6e6e5decd905a468cf70da0eef4b5e1cbb43c851f4171c2e63d06eb371221fa506882d29baec0e50429975aa0687a1bd670bf2ee500862c3f58418691ee216fd790ea3329679220f5957519560e436dbc057c6420eed2e02cb2de7ef158ccda7d19ef10215a3550d15acd05dfe513af507ea2da260a70a065bcbe3a5ae0a2c80d2a589f82f87007685bbc32a1d1e86622e7470eb3d2e86263dd3fdd9110323908b7aeb6812975ad5e857b781ee63a0f25c729b7f9ccce1a2f0e1966b8bc8436c13257a1c6fa0a17f5889f422e50af6f4d84488779c089053d5e94da57cba6a82f0edc7a7133a6e4c07d293b7f42f0222d1ac6c99896fedbc428c17ac7b512ad018cf3bc3f0b443917b585c051ceb09c6af7c5cad3bebb3b2ee2e008365be3a93f19b7f283c2129e6efd6231597fff5a359cd6ec925dddab7b1f356754655ddb8c8ab6473e75ec16fbdfae70d5c41dcf77b6e22f8f44f7b502a423afa2888d570d748c1042b3f670bc3774e1de44036ad1ea4dd3f95d0966a1226169613785ed0c59a92eaf5c29059e6459244c92a73f09326fc897eca4f41fbe2f4f498073857fe60b49c7a17c9a36e881f58b0a4968a49ad3f0a213f1731fc744aa926667a13fe8379d2f507032257231883938b1f83be9cc014ab06fed125562cb5edbcc262e22f83b968040441974b72574888a946d8486c0521b9ea633929b291b6ce5e8c1fbcc3bc33c808152c868a5025754a433c102fa14e8860dd47c017e72d1c0d0df6b37dff011cdd290fefe385cb7b9f63d9ffdc31109a537c9c4d52b22fc867111c5cd7d0d95dc2539d00098e02b75901ae527349ceadeab021ee3b4e4f238b56a5e308a0ca645c5f56f955e7681f0a2b64b11879ecbde0eb8e8ec1030cd582d336d84411fd85590dce7d8f0eb54225ae52879658a842c1f069c0f64c68b6fffacfddd3dbccebac8c008fd5e0e618620fd94c412aebbdee84bb2b3f5f34df389b3036d12f4da9c6ad43f9eceb33a411b9ec34c8561a2f0fbf18d1de2e023e32badb163de22c2559ee9cde355b520a7b7b45435300ba6ac4df58b9816f797d2b6402ca470289c5275bc1123126c4d5b35443b43e0d576cdd3db070d24020e8a7389546b29e96df3712f9a94d5b82ddba7e16bbb21ab357c78724f80a707b4be499fb90ea899df117467a64910e59c1f907e68bb28c06c20925dcc02addbfe2c2072a0a3470a5e5e694a19ff719d1c38d9f5dadaeccb3ac4a493389d19e405872816fa3581e446d2f8e9366dfea982a504e6a7f19d1cbfbd91614823497eafdd6f83b552517bf7b739c992703cb86330f7c6ab84e1852ffcb7b9796f39db7c64d0ca22e4077643ce6a60cb4d87332f5f5b2fa7c5bd7f99bf1cfff23969999d389d3353e490037ffbccf323107089eadb5a72c3c8ba833d70da651283e1b94de9b7a84f212931a845617c23ea621099e850bb187eca02f63f35b96fb1494de00557e6ffad2d090a1bd8b2357d695276c71279e54a0959bd591c18a78a9e44b125161fc8ef73b6b608c66595d1ab7d48a83cd7a8ae17b3c5f6c8b9b723d44bd187548881fc3d1578035f7604ebcb401a03092d64a344ad13d8ed773802c4671ea6c1976da54cef652aedf43e4857e7ddbb39aa27580bdcf35aa8aa724da985734092c71cf45ef51c8a8895c0251f1d8ca005acd8e588a729145d9d12e29f89c93294322dc6721bcbe6e38757a0e5f3434e570081e0e4657990bc70886e0473cf1c23d7c9622e47d385c6e28c9761f8a53fc61e3cb738de04b48678492259818e40faf85f427d10f1472c008686ae28d9772f061c5f78260e2e50426e4a806c5a0414de5bcc367fc79f74353ed5c6250dd7d17754139f7fcf7ad453599df5e90b26812532bc6a820dcb4eceb443df5e126d9005b2c74622575631ab791141709502b569988ee7c99dabece0ee00892b53acb5b9ef2de26db6c6d6d5762fb940e2b679014b1e258ff874a52c32bd03ad0d11a5ad3a85ce866534fc972e07ff7633c3715339cc43d8ab32df4c58a344823410278e9507fcc616d7e1998cd248688d17a0dd1087052621d906e0b45a909c36f56be5da4ea6cbb7f75dc2338a3046b42cdb95471de5788ad2c06ee2670f667e87b951de41bc8b1b9112837f592c08094cddfb10dc1eae2e01651b073569a12a62aedc497259a2f3632a4d168bbd00b3e61f45704302d463d76ea54bf84c0807be566db2cdf0d7a6a70dc9b6d0d933c24522c0a569e6354c26067f7959d556e1a22d6f038013a2393d05e036eb9d788683d43688b38083bde9d040df030df106c69fb993bf7858d2802b65105f9eb3af51dd9666a5ff3f90c92bbd9f089a2164ba74b1d54fbbac618b59c940c0c01812970a00a818b89c42a5fdad6b36c4319541b050780dba486cf14545efeb0b6fbabaf919d9290a76b950d12f344485082a13f234f72da7a31682b5938423714be1a972fc7fff92cfa4ca5679010d6a74732cc92141096628d94a8cc7c6c37cc66aa8661d1cbe9886ec2c63c4f3eaaba2115b54144bad8a9dff530bb780c703cb92e8bb45e672fe95bdc5054ae6b691c2145f8b4ef3e565085d47403224f8d60a11024267fd7b41a02856cfcc7f1621d69956ded12759f6ca3c1c8fc2f4a974d2005f1075bc0e5348297d705030dccf419c77c3c924bc704f42786a57d6db0c3a493b17cb1de2894628578a0784a1413268daee7815b918725d0960e44c11706ffca465b03c500ebf68f2974cda8517007245d2c1db3244c507ee12d860c29972ab7eb824befc5dd6b846b85d07751b03d6e9cf24422fe82d4f92ef646f948139cc364f49008b8b03286f65fbaccf0b2b697bb5b507843c791b72bd18d06043a778d0de28111143937010054cebbb7d27bb8da31d18baf9dd6ea4ab9baf7f112bd5a4939a84d8e7c937cf6eefbc7ad04af427d38f68f60c0ac3c5ba332698ed3a854873baaa2cd5ac1f62b2295eb37f21c381c5cd10d87ecf50f274ee688fb3d75ecd90bf9a505f4777a52d5a192509bde2a0cdca55819e4c58aba685394f17112dbfdf3c0193a2b3bef06ded6efeaa05fe794a9ea50422f7155f8a0bef180f4cf6d82d121b4af5d3be4610ac11d239426a5fd55d747846ba65203b7edf6988f3ba9c98580ba158a22a2d0d4cf5e2733744e62dd4cb97840dd8aabd4fffa438b903d38249fe12b0c3a05c6037bb6309b6fe5a70eaf3a9a96248a40cbd555b265557d109d5da39307e39e3cd0dbda635a49e0390196c304ff74c4c4aeec92d7ab2a931322a1413f252c2856bd35b4277d68cb6a1153538228338cf105cd8fee366e8775d66950a075cd2727a80fd8d9c6e7a83efd90a753d8a12f1a5ef5974203aa70901d978a54bee5915773a1056dd6802134470429acdfdfd082245229e28437a368c70e69b37f84aba1ba2f5570785bdc68d27399fd9416bbae17674ded453dc140fcdcc88022018447af54c935e8a83c9675776e2bd610490991fd5bb6f9f488328f84d94a1659e679b3d8476b2ec78e3345fcd0954ef88ccd65b8f12b19ab52b7aabd10b478953d33119d43029bd33a4032f16475523306ea5bdcf2207eb22de1ebd1c7e931e30ef19080bb25e4021dddf5abe8ea20cc93a093a7e34f07610f540da89dc75471288fe725762711f0b045e43ee41aeac0cfd6995b33a58479942f05d68ad650f010faff1264f48675264efa5b52eceea7540ed7adddc93f2ff4d17c88568dc9cd0c9f0583e63232848a52d6814ee2d0aa14a660bde9c6bc23136a2f03ee902b17d07366567a9659722be0a94206bf525ceff5eb90a83e70e7895f473e45a6e2e7b3e3032bdc11e150b7500f68e516cd23d5b8855c752cc3bd8ca807fd765c4d7b8f4e80dd97bc7e4dc2f4440fa704667e47f9d63d194e339c50fd9554077137afca1968ad21690764bfb9bdbc0578e46c53e787b556f4103b1fbccfde074c1353ad5da968814b36593575becf2c47b1e6b0d413329802d03e34e570b3fe3447ab10698b14e6759e4d26186d791ef7aeb4a730824c25100429a06949e7011dd5a3018a4e7df94a88bddaf5631f87c358f92db40ec0915a5d856683bc4432e3923ef53d3de3a5ff18d40f0da84db48d6aa66b6c6920a17b90db89c310aa3e1cb28fde467821e2b601e21798ca82c785ce133064d20df2a7a89642f8fe4f3af4de776f01e7a9daa76a4b2b56a67208ce83a7815cc9d50fd2242e937046fcc558292cbaa435b44e9668217241ef248fa4145f2b354f48d49250ab5b2670fe5b0dd9ecfd48b762b922e9cbf8aafd696032ed7130ffe31362f4e8632a26d8a6aa8818e54c389197e09d111b6d0bf2c1909262dae6c4b1e709982cbfaa90a4761607d49a9301793b64f56ff4850b8462b6b640da2028d1c9b27d89743ee1db76e00692dc192e2ab4b5642dc8fe5880aa01a92848da0806421e9762158c9952bf82859ae0667af9c41497938adcfdc0299f61767729b4e7e8e76df13ba67cbc14c2e215f9600885ce72f27e33c73b1a4557bc0bc195189887bf2482fe457ca46c32c34e5d95f1072d929bedd7b9e5efd014c8d8dde05b01565c7f38968c0a63821030559b1ec4eb5aab4b9c0ebdc496f59855574decae05cdfd157fbfa253e915d9829e7ecc678737dee032bb5d47695e1f75615e88201f4045076e81564165735d866073abc1e579c6e739e63c6590f2257717e2b4df33fbdaa862b0759017bed30a70ff7b41100c9445285480548825de11d7b49a734ec2d3c753d77daeb46a4d23bbb86c24bfc8c95e388cb9c891f094d14b1e33e852f358a7c23e5b8ba0981a20d1e225fc242b3f15650958e53d0ad4f2fbbd6dae3dc27860307ef852daac58434429a9bc360e28db68e76601679231a8d73e8b7b720fb84f6a6fb99bc003da853fe1aa82ee3f47ac445476538131373e09266ba6f17358c381c5368254002ffc1952201e23e73a02bc7bc630ea44d4802b0b5f285dfcff046ce07cfa4c39e89045b96ea2e3a775b07f79ac71074f17b75aef600ff1fa86d74b0c87f7ac1d5ad74e16209011427e272cffbdabc2ee4f9ef668800fc7f783935e6b9bce4619a4017eae90621edf3ff38cad84ddc79614ff3a0cb622b3c2692089d747d25d4b14ac4323ceaf5f0b9ca1f54fff9b1411f81ba7dd880b1dc173b0b4afc394e28a706b7b4a4ab85caf2e195a200220ee1ced56478446f04836e85255e240a7f7bf74000ea78739293e2e45ab626f1c279d5fd0646dabb51c309446975b59c63c993ac2026f932ad8cfc93d6ed5c446ef6781c85ca2bf299a21804ff5998bd927fad53a8bb8e44ba67c360b84f9f589a4517fba4ddaba907b2f8d3a23c2ad538db679ec147a2ab5844cf30dd86e23fba6836c8d81e1583b785d9c1f1d66f1ed6e9028c7a86337c53d4bacf79bfb8e37bf4007af2cc66710460a0db2da03d95c4b4f6ba39824e960090a11f4268cc7b5cd6a8cce676f46d554ec2b0ff5a445e0ddb9a99e2ee3a6432f57cb1f3780c9bf30b26ce5e8990c382eff42048deae30529f8c75229c9ad7b7ddc208bced1809f1f3c86287ba5be553463e8618279b1add24f45db45f0641103a687f7c2b56023f64abaa4a3c4ad75e1bb04ed6e2fc33909fc89212d23745f38ed5133cdad27324a6367ed8cf58d4e5087ba7505962eb0a4801e28ad6ee81f7061cd8dc0811dca2706ba8a1941560ada76351fd94bd0fe9683e570a72578ecaee44490ce510db4f92c7bf75dd9f4f8b4e4527ba3e70ed1ac3bdafce2ea40c38444e26edbd57dbca17f78e24195e17e8048dde9dac0b273b84b5ce9837c93d5ce7b82f0f46fef81bbc43d37dd91c0613ccbb0b3fd5c08ee5cc0b5b75ef62a305a425fda66c7d7f541aa9fdc7401dc0f8b93cbae08d7d9354bf3542aeef4147d22ee064b14a6b9c798da70f55949fcdd9988cf49f2869e80661ea9057058b653fa95b22fb1ebb39da113a440675d558a23621c9477622fe6a3dd9ea30bf6a5ed6330f524fdc0eed069e16e4b9d048b55bd8010861c72a0fe8aa426bd6fbb3c5506c8807766690280c6ebdb942da6253a327f4674b6982344719cc56f674033fd7de2a400640d2ea500e4d08dd6d811c58ec283ac969424d725dde4cd09a34ffe88fa4ecbcc003f9419a628d95a88e74a182d51e89eb7a3c583fecc1498550306e114942109084c5fd113b646539a022456f8fbc691cd91a5297c5474730c91cd2a17b8b7d2fb09cea5ddddf350b326ef9947010feee595236d09edbb2fa0ba1e401a84782c76cbddd8ff1044666bbef021587ab8cd0c3510b5cf62c222fda8e542c98325b99ecd65720afdccbd85211fe46bd821c35c4f635e98549e7fcab4948d6fd33a3b66398d37e63bb85d95fa552d1b7544342a4506f3c26885cddbcb4af9fad2c379a5074487c30feb12b00a444f4d42d1feb91cf4cbd60acd694241ba24500da4320b0bc5c9c23052d39a163163ea1f35f7d96738d7ddc139a16347537940f3526ee1321b4be77897f54d2a6e814a89d201920ce4ac0122cdb0f799b218f07149feffe38ceaf7e46b7b28a37078b9366f1c92a237ab63e8c71b9404fdadf0acc7a59ba4348f9b536311e24f842d8ef1cd73e836bcf064a06080e49db745de6090681b0c7f03e90ab48de4c2e6fe2970c9b27a20d0128ecbaeb30f1f6bd20e4ee5e473a1d9f8a41c0a777d837420c9e69d73635b0a78678721d70eef9eedff2c9dbe62f8e3315fdea342919645316b203dbc971173e3ee87cb533f21a422545f31aa47f6f9fcc40ea9170ac035a9ac52b19f86cb331e1fc6750659bdc80392110af4141d607dce673c1841024d2d8f1811926c0a175be8df9ccc0d5f1709907d5bebf75a33d4032db5b323a2d2504208c1339d214d10a677b02e7702ff2eb996a9614853104816d121844eac50bc5f7460c10dfa01351a76ce12b10ea03fcab315f066c2e6bd8ac00fd4916d7471d1308d62dd8c272effa8436cd88de60d88d18acad711dd048b2fe362274118491d5b8e0f761ad38c20fd97d793e571f13eddaea2197e9c869d30ae8ebd76ac56d7aeb24df78e247dcdddf7e412125bea822ec327ed3574176ada2da0ba37b91eb6d0cb753a879dab6564ddf0d3ecb0ae0b5a6bd547f26152b601521ee021f09369783276310c340e39374a7e82f5685eeb78ddf45cd5348b6a456da942c55788349658b6fe1db1baaf85cc57b28e72cf36508dbea2a3335b968372bdbbb2d7422d05431daccfef1e710b225964589d7c6fb678b6489019d5522ab8c6b4f5ecba8c35f1111250fb5f44c70382d7977ee646a5770eba1309aff10b7ac1730ce08bd093ac6bce179038f39af734a419a385c618aaa560c8afd091eabccd5f2d4451514879acdc427980a970d34807de0f7534b3fdc494cb4dabf3650ac79933e9f7f88c30993cd1e25390a92fa674b7b96b24b1e7a62a2fe88b974878edbad2b3dcf1771c3749936742283d9fa3dd21758b323478000c5e32cfef78e790e98cfc6db2c1adc60fcd7789f1f07e3ab9f4667c554c2a390c3526d9470f9662ab7b6374de3a7906aa2a96b31e10e79733af29c889c0f3b6656d4da3ca977b98e7d4861c791ca00decf1cf54e37445ae00b78d5f01c6c2d771108321ff9fe82e33f2c313ac449aacf69d6e3e5fa41e917da2ebc6cdabc0639b5c9d90f00fd637330b0efdc402cb96ce3fbdb350f88a1551f12a677ab29e770b2a6b86bfec93fc5ef36678b72c8f4ea47bd5fb75e13b8607ff78a15d9ee3098d4f7e01509b3dff280415c4d1a4a8ab3ab933cd4ae63345fe7febace3cf661143b5047223221b84da14060573e4c6e564b0740781aabcd09ea6f3e2a563360b3d40f098e46ea363b9a3d5d81cb88feb94e0d1e7c93f9d693b422af5b6eba10289fabccb9f5c0aa29457ba2cca965acbdd73bf3c3a08d8b4c169a32876e52225a22195d285a6ebf5052f731334f53c94480988ff3caaaefb5535249cd3918d941cc0ade8978cdba42385f7a94f4580ffc30fa0b1d697d40626048016ba2ac50f755577d5265ef1420aee5260a96cb01d5d5c1b0492a8b0b784b616ddc20810251ea1550d76af8b17d7b5c7f474e364be7141f53cfb0e14e229661e1283b2c20c5cc11baf5dd8f032db9bc64fcf543727384de0dd8f68a7bc43e7a4592f68cbf9e6854e32b7e1490fcaf8692bd675a4b2e3da8297e23787f7d2faacb10b86d7726b51ebd9f8595f24dc7dc172fab15829930c5fee7824447283187e67c9a39b708c5b9888ee506dc89c23985d4a83d977a0e51a633c69be5affeabe3b8ebc0a4f55c32424aeb802912d8e47b01686903b2a078c07a0a4706f70a8e6df2d4e45e598ee78c642b9e6f306311c0bd191790bc6b147fc757b223bc81989a5752db7454891c0513744c8f7a2cd3c1f33b19e33c8832f860f9174ed89f469ef9378f22c88a12d4a2f9590757b34af81de3c06713c60d3bc6aa8e687bb67535d00a09a9a683b0a4ddb7859c6a9846649f54bd3aa26417f0e4d6029ed3a1e1d73c12d9814f1526e47263c47ffd8da9f478b4f4a038041151486bd6891b80b5a8a8e81d7d7f8ccc35b3f732c1ad96bfa6c8691dffa92fa3e557e24900c78f0121f479afab251a9a4359d0f618163a2daadffd00c96dddd60ffea89529960526b03dd00281eda330d96da79e37c50cabc8c6f73dc07760b14793c0c6d1d9e22eb549a9b143e36ac8009505f3480a7f53d0fea99a43f65306672ba3a2cb089f6a48d35d7e5c5d7d82e924d74ba54cfc65ba3a059d8af0c7f79584ed1f406b37ba93ce535bf17a8524c6e4fc8eee38799b3345df86821b184c394b5362a9cf50627e4f1abeb152d0121728312168f00beadb01c716af7d914b857f5bba208bd76aed1caaf6a92f9df5013311e3a472a9d4c1bcc908b2eba198f0ea17b720b1180b68c25766f918c2f54945b3963002174e7101e6e13677ae52105faf846623c8195eeb022ccc7d41a7b142a0bfe32b44df2994c9dd2c8fa3402e40ba4c901b6b9abbd039a8227a5e1ac88152a6ef02dc0ea995b3c2f5e93f18b9f038ec62ffb198c2c78a51d653fd1ab2ff8a4cd38f15249867d2400b40f054b36b8ce1d9283e160913b15e68674e2c9239d220ba2631eae69d81be20fb05e03440701e8e056fcbe367c9b705771a75bf5c9949c45cb2ea3816ddbbc7b6f44576a64935735a1cd9d33d63f155b1027225a5f6ace26f4899bebf1b90284108a27ddcd30ea773a058134af1557e9aa8336ad8c315e3cd176df0bcf5fdfa100461a7d25d503adc8435867c4067e77a808f99e77eb3a99601b3bf10b1b6911a44adb4a7452633de44bc08649335ec2424f6e862ea5283cf39832b426f85862a8b4e5ad0449cfec50a9d295f575766c9a5903b44d8d2e0137fcc5200f70b4228a19a979aa4dcab4722da40a76b41aaeec731d7214e7c62bdee6176bbc4457997b5cbac1d6ffd84cb386302fcb4812d463d69dcc2d27c4a647a73da59725dbcdd57f6a12a4a8230e463dcf56fcc3fdcec85042c1f37c2c61e51008270a0b35e39f28c457b59e882fdff11553ed8cf7f76bf4a8164ef03a56835079f37638c821494ec0806858f1cf03f850c3789379a70872b635269aed703a57659c2691caaff20273d5164de953545ef1beccd4d8ff63ce0d573d4a8ca88becaba19ffa562966e4bece9a0b0842d19a14c9d4ced42ac8965891e9ab5a47fe8761f93f2db1dbd6ec03f1a894c3b7a074747bbb02e0b67f329716e1f2291065def55804e822e398b2bd100891dbf414ed2fae54c0921b7b14965755c45e0bd0646e57d7ffd652c959eb8a4db8aad00117122b9cd2ef8d90c15a569c081ed7e6cff01dc4ec221e13806acf78ca539f3bd9e9f179efdfa30182b65a619e271c78672cc9bded5167078ce8cd9aa4c16f496b7bef8a0b81180c92572df1c7763a97eb6089727be318815afd3e8256e22cce6d8078a960b529fcea6d3bd17fbc8d97e4ecd1f6e9d19dc6f10fdc77d5f8c5d72458bf56c5bbd0844880a7d7c147f7fee375d695664e70a144cd6f07d34dfd8c7d6d13d6147a48f52ae9d15231535898086bed2c8c3171d34c6f3334340ceb5f7719b42817a3186b3376ceb61eb6ca0e0353c0783d51c15ad3c198b38055c7c57602612498cd2b23e64cb0a9631c14ae8d3a1bd5f8c69d68dffd0dc6f4b12c102ce0b54754b0365c12df423f31ef2e9136eddfd3757c0678e3615e48973fc0752e7d6f0662ef0a7d046425ddb3b96e2dfbe9e9e67cf39191fb75ffeaebcbb28c0a66ef020ee6a0eb2c78447dca4eeaf10cce4e79111fb56bc43ad065d137e94cad9d0228f3e9cec42e1a752c5376e18a913eb498b54be7fe6a551cad97a5fdb4e051d1a7c5712d620a4e96dcdeb1603dec6b79684f51350d1bba04d34e7b16ed99abe60d207bb958171b2817336a165edde4c9bd2bed18b73dc61b16d8187c55dfb5da6236a4fa7bcc3278dc89385624374c44e104d9f7ffe1aefe24121d59fa77e8aec804b89975be860c9f6b41710bf0a0938fa79fd09fe866145d9ca124e42e59333308308df71db6cd64ae77ca6a0c73de9cf23b2db06ed693c837d15cd0f1936b052820b31acb86e33df1fe103cb8385eda523799b6545334d1a9cbc4e06092d919cacce84553313ac1197d6ceb2eaf807318d6d83337b626e9fe6d12d76b8fc45320712dd9d67272d0f07cac242591faa8617ce5cb7cb78fdff93f6f6efddd12a2867511c1db357c622b4adb4d020aa193e56c7f22f47af21ddb0559be0d2cd9101eeb37f687f8c36543a781f61d4a5a2c5b05d67f9db884d8fff09b6ae93b4f24f8c662bd8c771fce0e8a6995bf5d90445ef6fb285030c34a72a3db8cceb281cbbcd3e3c07257faa3604f6d58ebb94a1dccea98117015a850c2dc3f12af8e54b66c880d438c5de0b0dcb2ef2b6612dd38b6616705828059f1c41481bed416e85560e5ebfe7b2aef17c8d7c8142c19a875d18b69e0a3ce70bbf67048c61ceaf0b2163b8683b79fe169819dc8647b3c400ff8c240dfc7b08ae51b396c0a7111ed447cf842d4a72e332777481e93613a01b6e46d09194a3eb7dc2e2167e9b5d57e96c8d36d58d2c2fe14afab28ff1330bde7b77797ccfb9f6f642413e124e7b517883a5e654527e1b7a95d3958cfbcce0ea99b1b4d01edd1d8d3074062e4f5f7563257e225dc70c7df9857f87d8aa2e966da89a0eee747a4e65dad2318c7b5ad4dd0f032ff26c319a587a9401d9f0dcf239428bc5c50917b87f86c538f0a40b5b546d3d78e8b304a65ca8ac5bc78c3e5772bc8e7f951dea2771b3e9035a2ec875c91e197eb376f47b401cf3663207d8cb4dc3de5321bf36038011df782a0a8b2018727d0a3c74473b4629dab658214f0e20192598ddf52eae0e2f9b00fd7e374c04ef08c358145400029c45c8c571471d80143f1b2f1ab7dd304be0893feef751177c4f003f37b5fc5bb3bb1bb8533e0649fe9be6958a52f5789ea5c93a6444d107dd87708cf29f9d197183979fedb737b5e53156af1140d399828c42a9c13b8273cb1d919b25c3344e250b529f83c9ad029763ee9b27d06b4ac11c28357c7eac809e214d3b13ce02d4b61e19bb2f24b467fe1c7749901e8371061567a58f3db57a8af74b0d7612b3ace6e1fb2c2aa560940119e676fe39e4e66b0f984e1e86639ef9d8ee6ed192f96b295a615c236dac0cd2ed79f27129b12f566319a43f62a6c5d3337d84f4b002593815bd27f6e93a4074576692cebfaa84e330bbe0d0970d144700481582261bbfb274563a9e571fd3fe251948f1de66490946fe89a4a321b450e4bd53e77339eb06f75d1f90caa7ee9c341f476b50615ac64464978de4dee45ed5ef4ae880971406d3507074b2450b4f5be6750b42f14ba18bd0734ff12a08d010dfaab443311a57bbfd4c37b91ebc5b0db9e44df1e00a55134037fc224e7c38caa66c9b889cb7940e141c2123b2bd08fa2ce929f18599232326aed8081b0a80fc7799d93e2ced3249ce50afd73d89c12279d0b3b92a2573f5e8d9ae52b8438bfcb381884b40f1d074c8f517d4bad33d313a9db1734c2dd4104e5ec42cd5ef29ec35d24b6216c32cd254616e4253b18924ebf9395f3b94b3367bc78af16180073269da3c9e247476c8077bc4deed85829f99cb46ad7b7febfb6332872ed1c62f106f0cf32696516ddb7a21fc200385cc2611d0101101bd788a54f54340a2a04846695d3920f6bc17fa69a68f67de422beb79cbeaeea2db6ea2ebc09b54f344617cb8e63451081f9e1df87557b23d0f2457a0a869587a941e9bb78704a160b7b4887e18af15eaf80649525e74b71aad58a9a0f831172638654c88eb2bea19c624ba13f0451d6ae6730adec67c4d33c6e7c3bf46f5d988ed0f0cafefd5f6944726cd6b51d217ead2300f611a9155c3b0f7651e73117ab151e649dfd34aca103c1b7a210f78013113299b312ac8e6ae195da9f625692e72d0225fb5825b8a26d03ee93ee723c7e42c2e0da631507a1a093bbeee59f1613f7369c97e21ee8c2c3182c5611200cae1fd195b3dd0b3619adbeceec19b01a86bfe1b6451501a17d9176dbb13612d142243b2521089d451dd4d6cd0117c64f9b478f5225c17a02d97172ee73be771e165b87e5107f307e3dc9b78a5bb1be2deeef156ced1ec99361c903e5ef542e30e716bb7ad35eb88bf8c99cc9d3ec3cca315fd391d77ab78bc898cf49688aabf3d89c9bc9097bc0554e86e7740f1de4f3b4013051d1ed0bd485b04912f5556d9dc48bede24176b1612b441664fc95cb6eb1c5a5f69c4a380d35890600bb12efb0e8f450b786f15ef76a9eecf3c58c8287b98d092b273e7651b868ee5e6f3918e96caf4b360aec376910b1205e50a7beb24a3e990f57f3a2554d5feb951aaa53330d40636055717d807bfcd98ddcae6e553804b692ce167768b57f080424bbdd852fb90387a5335abfe3725984b9353a840b3addd4f6b0e6d7470caaf4c5ebc0ef500dbf959b4ab60d114c4d49fbb72f3964a267cc9890e95166431b6bd8060696514460661224cab23500fae4cbbe7e9d28014133615f72d7e33e298d6ebdd0440facbe77fdbeace96a0e45d942016d47f0ce246b3d186a5fd63ef6f2942e6ba49c03be57b9394722e7b1a0f305803557e4c61c26bc3c9e7288a84ef008ee9bdaea2c2cd80bce1c2eb533581565f84c35bd4c17b1c14d5cb66564d6a0ba7d599c94e774497291f3955f8d364951681a1095c18fad8825cad7b89c6e5d1b491c7cf2908f8e2c4b005bfac045a9e63c7e4d4407f5311741026cd9e2df14ab7185a9eb55729520cdcd46ee9b33b6c183e24b0049448c801aca86201509d6815010aa53c6983f570d3f2257d2744d77c31b053382c1aaeeecd4e467c10a37bb30342c9e60ee00aae57a365a8c385b5a89267f4c133800a33de130b87d60bcdc11c481c2b0451272bcdbda752a8a02468c39bc5574f5e16043a9878dc923345f93a8c061b6189534dc48ecb3c0ae05a2408ec852410dfe53af5701a3949edd02b44d68e017848df325af3f33128b376dd030a00513039932496ec3c6dcd441f4c5e9a35a61dd5c05ddf49fcf185469e9b2931331d8d2f5a2202088a4e1bd6e5ad9bb8840bdb785152fce1c7bdc6e384dceaa4d2fc6a0d7ee83f3c61b4f41af21a390bc7f376ef175a62d514e1c2fe7a60170270b8d661908b2623897db910c3b1beaf2af430de75849fb6c4389644ad2efaee66c72d84ecad06d63e28decfc19280b0021d8c6806dd0658f95b7b463eae570861e5933eaee16c92ce33b942ecf052ca08c7f86bb27188715259f5d4f167e7717df974af6adea9a380405900eaab52cab5de596c09182aa96040dc6e46c1896a4ccafe93daf488f1570240c2688e538e4de1510143ea6923b7e9c247c1709e341aef964c85511c6b5fd9579fc377f27a5d8d3e8e6acb44160c35dc0c58ba83f689d2a101d9e41f6e46634d9c6753048013dcf0aa6fbd17a8b1fa49b6999041c095f6d590f5948b18b93dd82d3ad8a1eec32b1ae49e923de62213ddc77d2969fae6de9d4ae7804a7f32f72fe9298cd9a9878b9de711e69a48fd2ccc7c4fc876dd4c52479adcde3148c68854b81a2fa8a4a06f3a2006e75f826c01d44455e7960ab4cdd26609dd9ae2ea01797650c82fbf294d9a8b6f6531bc461089dac3f54116531579a877ca832cd6a669fb0339efaf5b7e9e3169a8123ecc14b14a7781949ef6968fe58178ee85265afd94368a81e5230e6965f0bd0744c22bdf55829fa22c36a9d48ec2ae29435d80ac37eeb846be9a840a6917549626594ceea6c6e19cafb8886f05f76219dd3f84ad6f5232a425a62707dfc5dd4d7ccf32b06f1a7029c03fd562020c67c36636c1e9023ab3b852babfbd4d7d8cfc874f176a7a9e6d78a56d05dc79a36db0abf87cc545990cfa51b936738e9233c32c79b3981af22236fa9d115cf26fb220985694324606f568f37a72731c59249ff56302f41db2ac9a42462aa95619fdc58ff3d65bab502ff86e429e064a5f7a4d989e33fc37c17da22b784402a75e01a4730505e4adbd360767eec98bf5b08675924697c76aa6794383663ec860b4ab6112a2cc74fe12439450a286f22893e3ec90f3040ed64ad34d961b1679d5268791d78e1b8b6ba7e2508c0ea716b7bd99c6e8eace2f66524d6c81ba1a77b72fbae37aae2457c4fa0312dc31e8bba3bf6d7ecc3326f354234e27bcabfd92c5718fdde78d2e302b313f3ed4d7f35f04e4441aef9f8d4fe622248997034693495dd8268d9fd8083b200751ad3e1e1a42003ce1e365fdf3c10f3dbe22c23e1d8572aa645393a22362f7e6e89d3c2bfdc06cc965c0f0731b16d74459f57f9b1b7896889bd2bc96650086ba9f8bf99b76fa10268c694c7c61fcbc46a77e9abcd453c4cd0348fc39ed4f2bbb88cc35a93e0228c64ce7c543e3246ffde08fe4c7c458b052fd7be5aa8cefb32cd6cdaba85aa6579dd43ff61d54ba581cbcfd618ec8d5c91c5c91291cd73a5c19b821f9b6b626b4b10465f9b46e2cf8c615c98753c10641fa4da531fcda22984bdad6e250fa99ce579964d4a4c86dfaa35b7bd60c8e27e1d0fd9fcafbac0b999c591a5472f7b78aa78235d18aa1848743837e0fb5a65e597fdab76ca8244754a992d0eb8d90be65f70ddd0091f719e49ccb004d5be4917d78c861b60c6112de6e428639c35fbd0d91edd8207651f72dd020ccafde94f834fef0281c2037624d982acc1ebf0af40953513b608e9a0e752d301bba8df9436a4454655da408f809c25d4828242c8df492975271b56f9113c6470265affbd3e9356534cc12ae290a49374e81d1b7011c8d10d06629c8d70eacc099a84cf0bafeea7c8dd45efe922f3662b91be9b5510fdb100f4d7181489ede47d12f1e30512bf036108fbfe1db4f70e8d9589791673e0ae24a0d904b65b2b15f4918785f7eab1efd36bf35f27ee5c55a1d9ac03f4e4545c7c0ecd1ea481c7aa286b8d33aaaae6d6f0bca8b6ab658be65fd0ef8aa4e04e783b23f5b99afa6cbf5fe3950a36cc58c45c316bbe4e0d9a5e9014b725a12dd7d73fc9c02b416b1716622b173755676e5db3f82ee9e99710d7deff753aecd17ddde5a9c61573eca2e6a9b80cced445bb6be8ed68ec2ed4516b0bc7de0a4089bb0a8c6e063223ae0ad9d98f429c53a0b2611433c8bf23aa2054106eb1b9ef81c5b3b0ff91d293455928172e6caa4e339de7e65dd15670a2ba5d27622caba21af51d6d3f69af648adf89c2d6a20a1898f366dad4fca72862825cc3d4d6a46355014dc5a7fa7a3abc4eb3417fc527a685082ea2bb389b5ee4aad60d8eb35a3519cebc207ce424fd87aaa009b82f38f7a613e3e807539aef48094faf4477cb413bbf980345e249278d18df4c07244738a04f69c313b67cac64981a6445d248bcc0fcee006b315427c971390ee7969c7932bb95a86f821c3964a53965f92cb5fceeb18b793ae63be7e9a3f479fbf0e3c7312b8eb5189efeffe5c1bbdb931640a4c3a59b54442525c8ca5f866e8e7bf753d77d40d54b4abe7cd2d133734b5751d832cef01a99758ae98cb5b4201438b6d4e1f87b8ff94ab1c327395bf754bfd98d83f32f162cf7222079feb9525a647efd5fa6631ccc5d6c4d83fda193dd25928cf8c159e101f4f875c041d92409388a76e03547803b882d63390a9d995a028663ad22b99361c72b32fd5b98045ad07a72c24ac47abd508694ae8a4694db8b2d8b7a81f45492c60d530868b3618d3acbb45eb478b960fe09491a7b6a881bdb8809adfeae7b140f93d0bc4e49b7cf875dead27f49c6a9d33e786b5f0c930114e8e913fe13c881993fa0af0f54e9a1ddca83961905b4256a3798aa8ce4dad00d721b293b4427dd054282b8f9fa2d5956a5faa6fda6b923d061cbee15426ab4c25f178bd8a8f771f11436c3c7d3e260c24c62a8edba69aa0bac6e37fa8ff92049b02e11a0c55edc2c7ac3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
