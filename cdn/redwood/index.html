<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e37550d6a00589ab7c17ff011d1c97cb06cb5d6e8c4a431899a223c2a3d6347117de612f031dcf10412d5de7961eec7e0739b76e6b999a2583fbb6b9d76817f54ee7d33995d05fe422e6c8237645b79f9e6dab739f6bdf0e9acc65851c2de4fb2932821aafe6ee4bef626174a9a25ad549d749ba1b33b1c9e2d603c01ccbb64087cc185b5fb5fa732b887c6f683a38c11f948f63c499859c610046b606f8e7925d5baab09b15802dbd48b2b90c14991c23c3752c44e7a23d0f498d0e8640649f7bd91cf1405ef96170f8b60d735d1c8a423a588c03a7246f7e3afaf35fa083b2ff8c4c4f349815500d4ac8eb7751e374e1429bcbb40fede7bf515e77cf7aa11bb3572a082df339e119a3bd2033ea708656cef25845567ef905fd5c761c27b4036d147a4a544629dfa099924838f996229d27cf95d8ab2cd4815a9013c913c5a606d73166d3ec21489af940e196dea18385f2d7c6e37a45ea7d0d61470618d24600d9b02b2fef30a3e49601fa67acd614c7c1bb0afac1bb981aa112392adde8e1c1e8f84d9b08bf4e10d6a7c9c87e87510ff6de9da2b41de4f0570f16c763465ca2b2a04ec80f6c51129b31adf8fd0ab0ff9bb33b64307d5895a3ff8bafd50649ef2baaaef1bdf7b64040ff494585982ad814e6ce8e0fe9b02145bf918312027cec165f73d3dd99bb810f7a8d907cd06db1cb44fb55bab0150d5aafc3315787b3f4daa8bcf3d0ffd14c657af4b800ad9efb8a49df955a92ec99550fc0831c4f50f8be84f5a3f0c359e1214706626abdcc013bc64415e28402232950fb83543815aad285621af573de194cee73ac2bb137c6b9ca70711d2ce0979770783dfd8c45a10ac6739c5456f3349b328243ff3e53a0ba2ee5e8d8cc519a9b7a1f4c8d65f438f355c346f3011fa2e562c47188ea68436b21d4ac20b270da99ee3594d16c3e3d4ca7846ae1b1f38f79c75f59d51619357406e92e45847eeaac41173873ee54aaebf2de6ccb19687a9c3d14dfc998956a056638b1b8c552cc3ef1c0c1420c60af6d49a5852ef3d4ac80765e8d5a86f0b87bbb4311cd9bff397156e34acab01a2a099cc68686e144b7e632ee8b251b95bcc4344b9637fea685602cc694ce2ed760c00328a6b692b16614e5e0d4f74757b608faeb4ee63696c8ec3aefe4502658a7a8999439dea0d35e0d0a298cabbbacf4e15077d70c461f8f2157af9f29cbb9590aa3fddf056a74cb811012723bb11447040b780ac8fb7028356217cb63cbba26a941ed9bf5181798202b0f2e5c765541ec89a18f9d00c8bf3f856488ea0e69316a005f44ee5cb299b08ac809941095ae3282588271037001e64498997809d2e27e3919269349c4298f919044b30ce31361dab8b38bde6da7c37b982aba8ba60dcd692091442237fd8cb6cb47cb24acd6bf1398c421f4654dab28cb99ca8e7f365b7b42acc3093636872e888bba32639fa38d2bac3e6f7bc19dfb0a566606bd2d1f3d6e8e1c9c786aea119f5544d77d72a20c748620b29fc7e94ed0da4e4c4a412cfdd87741cbe51540104e0abe100132e41b2b95420da2a69a188158163ecca90851b84ee945be4e6051ebc9c1be98976e028dc13a4c1e747f1b471c92009a8e0cff18f3835714825aa44ceffd2b6d2cc14ce1c2ffa86d80b70219732b162523898ace5d33ec70d468e8e71a15f8db48767390daef1fa8b8464b1b4901f2e0f2f7a49f1555c483fd3ec1bbfe90ff4f2f0faa6fa9dfd924c96df389b624185c0057868d885815fc40d1629dea83555d26296b8e355bb429258dd94e5f2339fda90c7182d15f30ee2c53618a5a4486a96fb04d1e403c3552475bcfd53593505bad17eb06a58ca24d8f0501cbf5e10d9adeee92573a2dcecc1442936e803aefccf33f259d792f133b60d0081cbd3649de0e54b202ab986ea9e88a3719b8a3bf61775cd25c16ac2733092f98c1fe3df87ae0cb461df233046793c0966c6c5c5c96fbda0af7700d3aae855232eeac6e4f9a87ffbcd8576893d1a1330f7d2432cd0cbe826830f67abe6f310edffedc16c0d93d59b25adecf2338fe18af4a54bf94b289c9a8a5f41263964caf2cc4410940000d8b4b75856cee13713c856031e2afbc2270fc665a22f60a4b473a4c71777942ec01b8d2c33ed0267682a9eb4db935df37ad30e28639b21c64b2afa2c777cfbcf84b8617f9fbc15895bdd9342aebebcafcd6a6996bac591db62e0730873fa59702839623fc924d0a44443d7e96954f91c360097de0785a6379c830499e09faf22299aaf5df2fdbfa1212b5e95b33e80674f113bb8890a3256da9c0fcea86a5a55d93919bae7f02a87e083f295600a76d005ac2f9e45959191aedcea02379b9fcb0db894232319634d07d7014dea995028e4b0013de837f96f52cff33e5e1f639396e4bd51fa0a3afb63dbecaed8d7b9a4c40616d8c454b00d80ec32f65df5dcf6aa9aa08b1a63fd92d8f6ba21089520d78a6c48ef0122f62540a9b983c868f4393ff5810523766a349bd5bec8f46f7613aa2654a2a47cfc80841c261801bbf0b3fa1695ae6a56e3e25984eff11358e0a7085ba5c5f39b2747c92a4a90a1525aadb96fa7b7e3258fb24a8aa2bb64cc3a93803038dbb7bef66db6992f99ee16cce85094e92441ac6aceec849ebae909e6da6b87c2f5274b72333546d4bbb83025470b170c1f73e652e761a1c1c622e90b2868f7e5bec5646af4a75c9c48603351dd39656874be176547420043bb023e5397c46faa9bff5bc97746cd16d9d4d758be11bec32f45326f400758d290d85c8b11283c9e97ab54a4c94ea52f3492776d886cdcbbb653f05e272c68f99d3e7287f2b0aa567fe9778a4b5122a95a7688db4bf36c9c4fcfc4044e9d4ebb931f048623ac52e60add628d73aad578302e0d85f5fc36a9c72b85b2eed1a5080ff263b6bbab2fe879e01b726b72d36ec00a7056c0ec481b740d69493ce440bb030905dfa0062267049b8ce68354a8f371704ba1c6e2d69102b31e55866e89d12f808622b9cca90b6cce6df9e90e2d6bce400bb1164f81684c1d0ddf57e6fc9c25edc865e6bb709575005cac39aaf276acdb72fbeecd5985ec0b283577f175a2aabcb876ab17a03b118747dd8bdcb9d545b041e40fda622d401d98db8e87ad487e5dbe78bdeb18f35739f3d4abd0c55f24304df02108d9e763bc00c3611c0e50fd84fba70773af579739b7ad621fe3f00df22cca4e7dfd1cc70b507f50f06297e40de1e2777976ebbebeafe8a24762bb7713ae92e21487abb5e171c3eef9738a4f37353230ccd7fb07960fada5e7029e534267a4c0e545c1d1c583296135c73fb01eb57062bb85175223f7909f43b72c0a20144b2b10805dd1af11ccdd2a1b5625de97ac72ba9a6a1d2eb04855af9616d124584a0bacc741cfb3bff64c2763f0efc8cd19ab1786468b96b4196c52a04b2b9a0e2a6439125dd5258dad5ed8d5b30af20324b10b3951f5f35b539d291237005e22763eac24bd888eb793cf6452ea0ba277163d5f811ad04b651d16feccc2b7d52e0586dd7fc07b71aa9be64aa2ec3fbf15976c55c3fedb5853638b033d3722aaf5b0ac1cc6314e06430c7bbd7cc024cca934fdf99a443669936b4a41114e96661cc22580706e47e756d1cd0ebb53e62be65b5bf09d72584b2aed3e8b3e2b138f519e37816c91afd74ef1a818f7b8ec9eccaa9ece16654d29cf3a752dc886e16792c64546510937dd8db4d2f55e57f0af163e374febdc2e7ea6817fb5eaa9056309164ab363d1a8b82fa67bfe4a3c855a1152a4d422ea0b871a78430a0b9c0209a48afc8902f45e5509ec413e84be0b4224dad5efdb7c35e2d73c81e90fa2ce93ecb0176e809da75f6dbd62e50c9e7a69bb4c596b0fb1b3eedee963882f8f0d7306d74230c693856348dcaa5e5fa9a8ad3d391335178aa5747f4a31e3147aa2258ae4c6afce45df4723df612c0d22beb51f86f36da376f1577275869795d426221705676958bddf4d5e7d25d6c7c720db78c19191d67d47a87367c7fdf60740de468c76f4c4dcbcedee0f61b9ca284b2ebba3b8823b3c7a328a1ee9481bc594db6355f88da4686ea9d5da7f05a1f08d645d4136e9acc8d0084a951a21fb2722f1ac5307dc5d18cc794dfea21db49ab950af528bc05fa8b3f97cd43c8791f2fa48139d1607f67193ee60c77709a4ba34e70ecdfab9ce47b81d9460cd96b99f193dbb32b8b7dbc84840b8d74b63daa1abeec7bf7ba6de79dcfbf1c589b3b46e9ceb78baa6cca1db371750da44cdc281a0bbb97c60fafd334e90d22f3ba651c226b50a7d18adad24cc7a429360266e27d7041cf4d8f65a4434c537b6ef172814b750784637e00e268e6ea83373d8d7a4d89360777aeefeef4d9ca0ef4e7a78e3f4dc849aeefa4c8247fdd9e0141246a9c846fe9bdbd1e119f8414f6ca250cc4f593559f49f210835ee35a20212e1f262bf76e0b20ef35b7dc9fd365867db6be4c5a8a359c9204c26f28e54e7cd127e9a13cd49905e5f00f63bfcd33fdc0911f48ae46997dae540d11ddb8b71287785d266de7c896dace2b2423a407874dd11822080e030f2a3dbc06536d7c8c7a3cca04d80a670dbbb4484085c80858a87a9345c66bd8729e39369dc03fafa6bc895a0ea5a03c0066b43f32ad0b1edbad10b40e05c89487ca65bfe9e80ce534e70fde0c216b2e5ede2a897fdc55ff4cc31d3dfcec0e2e01e3a87234c8817b6a7e3cc8d029cb6b607be5d930fa36a50f4ce039f7c6e87bd2f249abfa751a2448bde998b5a9422892621415e263c8938ae31aecaff637adddc2c4d7a22c2504c597f78c8c0853d24bc3413d6f93708df0266060e56798fa7d8821e96e3605a7ea08f797f58f2f42986aeef933a701bc65ae12bc128663ab3d180438d732b3567a1a520729d2be00317fcafbf4ff50a64d4e18d2d9a9c63698538c1f764436396976394b3e7b83415e6448bc95918dd1aff601d135a81b0fab8d11a7ced9b2900fcc41956acd0844a1ee1ad218bd2bbce4e9fed868f95b6e2aa80473c51a3980ef8854553e472ea69d4ce0efd32f6800882aa249d238396c9629295b19f3009df20fe7e2f0823b36663de29907fb16c040cc474df89e5f98d7ba45c79e917cea8e8dae0846766fc2b7315464720f23541f385fc7263bf80383f2cbea9c967579a18eaa4c030ee1330803d48f70c31882d360dae0ba3436316412cd4b4b583f42a8897e59fe00d72b656b43bd4a0771f3026ec274744e1fb098f8604c3a100b5de91945927f5e1b2c2afae05da8a0aeed78ddef29d46c0d067e110f810fb84dcf752dcf81d4e7ef38cb6aaa5bd00fb52894a2a310a8736584116812eb3e5f3c0e560d972da7ea1931fd6416f7dc19de7fc887a9233bb647fa91fa4d3407bd10110f8f59845ef43b814d21f274987f7a5abcd10ff4c5a30e6b7934094f1dbd1266665ec0f25667b28afa088c9a82a3e120310d3f9a1fa8e39603737de3144741c35021276a2914b9894debc619dd9b19c319f6c57595898c239e598783056b763b4028048525abe218df7426bf160a2fecac64857ff3477ce335f61e6705c2c54e377bab063631a3d3b16062903b763a82a056e8802e21b42d7def5f0560bcfc8cbc48c04a54f08942dc30d867582bf0ebdff31fdd44c8ab6a0febc39c9423e3d9f9d48c458c64303d10dbd38c0a2f037a22fd2b2cb40cee8bbd88b06a924cf33211e194d0875960b91d3e5af550a706f078c074749be2a9f6183ebe1327b1745d8fe280310d3e2f2616304c508788b00dbddc749b53ea57d6fb167e1996499ab34e251197e37ce250ef9d3c5c8a3c60a95b223c6eeed311df6ab7bce5f83ace43c29c57168cb1dc6950cf7473ab6aa6543b280b85b4bf9702755a1940d0aff8c4fb1b9f769dfbb40ec8952ace346c9da5c75161efb3497f5eb49c41ae10c24aba51cb028db1bf8e544d60f1a3a5910089c2cce057d9e6d1f3a4245419a468680a648fd97cfdddeb330e4c6bf9f299f7211d52f0beed43304c44a7e7697cf3345819236349bae759c92962b7fe3cf326cd2c5a434bd320bd3a2f36059a9cc2b4ed8b6be6a7b85d65115065fdf9fb81b10846ff6d76fc29ee9c1fe8274b5344ca0f03ffa3b2fbd7fdc0d4987cbf319c45caf7bd1ffa7a12873867b687c677af51b88786f4517f0c3fe1e2443bdae61087fad04f42d75038a05f2756c33655bca156e33debf30bf47667645bfd0484c2abe9bcef674bd55d8ad0fe3418e9d186637b46148d30d43901942a3a71eee13af26398aa45547d9a764d115af860756ef38b6d62bf4ce7f0939e8406a0ef08e4ecb273c6f6221041cf8963ccb19b67655118101f4bee97d387f068eba8654f48474458fdad8a81b66c7c51f1b411eabe636c8e38a33ec7d833f0ab991f2168f935c7a407075d5f8bc0cbd43077c1ee6ac8eb9cebf03474e50c709204da0e9cdab0736c9f508ead4e972d16e722cf6aa98d6a996c65acd53729274db5056cf11c469fb32b2bc5ab263b7d6e7192465d2fcfced07c974dbe9f8fb64b22c94861ecf081ec8691dd718d152faa58a8adb9dd410afa35a98a1013082ed6c785414df7d74106e6b7a43e056d9e69ebee7887e42b48f4978e46473962beb7d8c984b61119c64dc884fa5ff9448721377895e84be6aeb817f72a9ebe121c4857b09fb38fd61bab37585a45da7f0340b2a09dd890790642d07e17d54cc3473be6b3ba0fbc98beeffd1ea0fdc79274af299766f87797fef8cbcaf4469004902c94a44d236b04d41a8362033bd8944b5ec6abb05350a66b30a87e852e2c43708e39dc39c582117b65aa2ab220d6f61386753f953ca0621f10f0ca65736ed66367a39dc7ce8513b3a0b2df83bf8f7c45a28e139d32813ab5cad5a64a399a6280450679d3e431d9eaf9041ab52ace1459942fe33d3d116c20c3a6b6d06c5dfe61914362230e50d3eb775a94ac3fcd37c19c133ac9a74780eb079d9b2927bc5bc46b56139697f374fdd06ce948f9d8e49ef43481ce064bc5813f43c92ea20629b84ae6202d6545608379035d56189f957c09f8d01c8d43055f4889124020fb58c949ef04b0e1b3dccbcc52f579c01eef9e98ae9196569e44a072c7d682a1edbf145329aeb4c9cccb9a6978df6a88e77465354192cc5a9a98400a9371913826facc30d123fa9a1fe635a97a57f2a869dfbcaac90bab57b6ad9e3f8be0ce3380db33ed2171d07ef606b73027a8f6399b675f2b2feb23bd30d9e186eabf2c4627184d59d65cd94346504865f13bf859d9ba35d6163e4710fc0e7f907ea64a2791416e757f75b65f74b578a2740fda0d719257a31b775bfda7bf5d96dfd5f7cdb12d05287da0df4847ce4a27656a3298587e47e426e93917a23a9fc95ae673358a48936850be4ae71b77b7bce37a63c9b9f724a8d4a4e24e4fa8106d8bfcc80bba4896c391acff8716f68d6d6bb0964d7baca1a25afa02e30d8ead94bffa3e0ec046e15522357556254a4d947e986f24cda4609a49773189d5564e14991ec0b6e21abb8103d20c46838f8bab105826d053b1b26b4a56e774132e4c6dc0806e2516eb8d684392aafc8e65c7e8dcd60089600829913693f6f093e6f8618a6e70b7ce12d7626a864668b0689a7d94908fd85f3a9cfa47ce5a735ba0ae74d679faa8ce23269afaeb3f4fe32394c529e603bffb486a421d736cc718ee09536298c99567f3e53511fb4fddbad9f83f1e207e4e064e2167c95d3ec449f8b1875f4f934402db8fe76781c181c061a310e94f9b31ddfb8ee2e9ec765778eaebba09c0f9d95705adf01973452fde858181538f6922b42ee3bb81b6394810620b6ba7cd082a21cd295ea1095da8fd5c12b000092a4e4f6e1413596a2b535067b843b3ad1ada3e831a03318eea2fc4e92b895d3aef677ec6a7c1ea51595e0fa314446f899ac66cb5c7ed6d3cc8d47bca7a78f0ca044d14350fa29d4f259e07b2bb6d23131a12969e15833295be40f18b7312301fbbbcfb2653432f769f9a854bf03d2d2e5af7f8de67d35c0ec720c9e932ce7aa37d6090740083376708a25b5272a84a7ef212ac88dcc97309f9d61811c2554af00b50d05f421c234149309fd591c02e785e4d85aeeb670d0e998729a7efcb4a799b1622de322e635a5884c460f9def8cdc24d06850aea143cd80f36e32d3bc55c42790fbbd91b83f37be73e233d188c70ae9715c377b308de0e34d915cd1759103cdafaf4784b3ca444f48cde9d90c66ec330943c26f6afe372a66e0b1151d029904f4e23b99593be4bfd937b80889ce413e59dc8e987fa7d159c7605c115ddfbc67ceee2f79d03f9499c40f4988d01708bbd7b31efdab6bb320842ef6b84f056efea1c2c9acdca2fa25cc13017be92943d0fc0fa57a589bbb01e4bd05c53036d1b7b8fa2c9a6f3c2574803c5c268685c3ba7deb2e08c2bc35b876cc38216f6c35bc10468c402a495daf0f122352230bd9518c80135a1702d0cf8a8ba3343a09b3d692eddd5b6eea509d2379fa79153049cc3669462504ca962782360981b783a0be7d1a3fb64d4f2eb2679ccf50e817a543d1ca7da2ecc87a8a96d872365076326b55ca2bfe4477b1749bf07b70f227a43755f2886892972a422ba5a8693ecb4d45b360ee96a58c427a7ea705776fe57debd2c5703e3efc0401955e7063abadc49b957c1023e78f69dfadb82ed7bb6e2c666858998f92b263d689d515b98052e29aeefd2f54a2e2c759bcf87921aeb366affe7b32deac57489a987d2166356fde1beb76a950191331bf2fb24789b1c59fb5571d898a095edc8fa1bf7db02925274c70519dadc9daf298061e0ba46f68248f69490cb5ecd45abbd2862e63ea3b39c6e96eeb24ee23807dac0769abe3a01e878a4a2f95596514f9735d0b41e672efa8a51f3a05da3324ead8f10488595192b4364105771a8caa57f6f9027ae29fc5aac1a48c35e6b41e79c63f725c826be8abfab36f29f242413fe9cc7564110322ad7b8e9acbbd73aed5904dbb94cc77225a93858609b9aa34d18cc69970e3dfdee21634386adf9b23c586701df759b85c09c0d114d87399554f5b81899d0604b8d43c4b2dee27be6093fcd91a36a7c2c89c0156786652b7d8c2a4396b42b2c6dc039ee9f35ffa98495da4d157b1c1bd6f8ce015520ba2e2dc6c06f58d1e11c0be3ce30536e9a9afb43091996c164c10604743378644c727ac020af9a85dea2798e0cbd9e80e0502c7ca543a09fc79757b1574b51123d2ed88742f193631d290652034495c51078544d768c243b26a625749d9f79f374cf4133bec1bfd88146e5ae02f16269082587fa966661fee9ac2cdf1d1bb96890269bec0e0144d17021aee4ebedda5bbcd1faedec5f4ce6765d6191fb7d6bbcc81ee404b72a98483e127b987d37362674e1d8e1ed41f7976df227e51041020f5a504d05b10806c9c53bd6a78bc6bf2f34acc32fefc59fcec1cf4f386502b273ea6b639bd4b76417537fbb899e7a6db9e339f89bfa65d05fb22240ba963a262d7c00385bf835e71db6adbb63854574ec6652114016b4d5a2f1acdf5b34fa6d5de19e069aaf2a030b3afb52fb6ac070578c27b8b0f6de60a369326de3a4ce5067b3b69340fd6ce3f95b5ef0b757837779c32d41bd63beebf4200bbd576d4c18b0d5c33996ac8653b9b5f67cd0549b1c51373edf895c2e3ab94a97a9a7108b79878059891ecdb22f45897362ee97e80e96f43d799c399a4893f32745b265343e178794f431cccb6e460ef3dc62be46449e993c895d134cb3f2104b0fd26344c3b1642a1ddeabed8a0af9dfb6b242a4488c95c8887363069a37d055a043d02bc4e0d680d95596f6c857a9d5f635ee31cab48106d2487a831d0242b7ce15b6d264988ba24a01f10b85874d2d1106aa91d973a8cad0c529ca8cca908ef1090b48c6e50fca7f23cedbcf9ef9247e23bd7c167b71077be97a6509ae84d48348df6bfc320225e55f924c238b91d44f4390011ea31c8edc035befa7a2a897f9578c7d45025074fc15fc9ca6698faeaf615bf7232e7915168a5dee548281f52975443428b5d8d510f394a28d0bf81b03304ff1777fd2ecccaea4e81812117e52675f2aebc1912fea90eb3791da2a79b4a5ae2d41be6b65f64902654d0f90d158eb1d869bded1a31ee5960c26d86ecd3bbdce7d367b1d97b5e0f44e1f671a48cb6ab8aef1a06ec34c003cbbb6e01be5aeb7930de59a49bd7ef5f197203405e520d837528eee5666111dca632614d73130224905717be70991a23320f432921e3332010d6004905a2e820aa3d21a10b5768ffb87549cb21bcd2556f5aacb4470c9bedbeec8714c7ffacc44c99a495c56a6d80636728e7eb546eb5840e49d65632df3b990b2df9afadd1f332047afdd4e89c574a2da1cb3b9678dc89a914c60481e8850f504d337f38abb19efcac9b5f8ed157c2d44c51e2fe01942930a85c975c9649e08314af23cc42f1e99b442a5aa305341bc96740a7c40a0e1088c49c05de983953c981028a7bbfc2deb419af84158b5232f4072adeba7d03de53e3cfb4aa87c5f9561c8d5f46b8dc1fd766ba5136b72ae8717f2315e77f35ca6862106f945a81dab76c49d870863e14ded5aabd062af369752c0ca5e22aa3808dba602e0ed6b9149d880f358e7b42e488c10d12c0a0ec2b6df60de408c7e0617bfad54fe592a6a5dc3193120ce9f228f0431f339c5ac46ec6c5090bb28d06a00716fbb496be98c01fcc042fe11d282d8f5f4f413e9ef20c8daf4628503e32e1eb2ba6c0322893549e04bc84e5b2b5ae3d91c7c33fa1d1e2133aa42e4d7bf5b7df54ca4e3991f39ab262bf92f614a5c9c3ab7314e68b0d660044114fc41f060b05ddb33c5e6b6775a394114cf1468b507cea6326419a7a559ac9affd829b4f0dc75f2f2e2a57e34ea7bbad40fd8a77e7993915ad286ec653ddfd98e773ed62d88eba8611aeedcefaa0ff41b878eab27547301afad7a7138e6fc2a09c04346e7bfb8494a0780e626865a7d6dae2646b01c988e3ea3fba41b63ddb6f6fab34093b1673b827cc2cbda47c38cbb1fe9727e64f011cdbe3ed38f23a826ff2e8c6232cb76db7c94053bba1fa9dfde44cc9bcfedb695ea690a6c22a320b3deb6bb3ca7ef0f5c4acdaa657455ead13265af48dfea3592d931e44118b2f339b59cd319b64ba808678f8ee301a633848887dd26f2b70d3e1d2bef5c587b7e1904a04e03d81a4d0e09c567a8d8478c0980d1c15d60d169b183d7c502947d431615f889316fe288f4a75a129a7c1ac823620761471fd5ca7a92b7991bae43ad12e64fb0c76823779e2d30d1345ec465086767c940b7e2d305315443df6fc0ba8602d3a05a53f1bc31a638389c47a6d74134ab1be4f95fce7fb301ffb751c11194ef088d829b7dee07f66cacf49681ffecbfd2902c9273fb09a7934fdeee57c9eb3254c02a1d459ba050d58d323a4294a379e1be46da8ac10f539183b92f86a73ba638688d55fc2e6a08814f06fd4b778164ac567e6769ed3f8785d1d18ad58ee78976cee4b94ac99345b62ae40846af6f9a11424753b3bca2f66a9e51d448ed1e35a7867f83cd0f8c1bcc9fa0a2405bad3f52bccf2c3472ddbce184e065488521d865c196ae4eca198a90b3f781e1496d5bd1e648a3b3e425da418b2e66315de568d5492ec371421ec30a9ae35d541814d51fc76ec67006a53721d05db0ba14fb52d82ce384cc8f78683099e7d1700431792863f28d872a098d585df6d03aa2da7666e682498060d6ee8298fb044b4a016d62560316294bacf27bd2fe4ab92598d19f1c48bb943b7318145c943ff79ab98b9f0129062ee755ce1408f58c960d05dca5c0e56e8c2eb154dd8dc55103bb9570d50a4f30b834e39adb041e253e34a61b91ee5945606822e987d364c92767118775b176566127cc4a3ddb9c030b4c131aed63e08fface746dcf0373e2fcb6b0a249fa48bb69ed060b2f6cb058c0ec79e4b04e4ce7d7b8ccb3ee1632524bd017707dbc2d0659aab30ace9972f305e1755a3623fd4fc5755bb155cc2dcfb06c1a15b8da373fb1638ab095838b11f7cfffb7671d1f032e2ffc311b1a623e1999a7fa1dfa932d5a377bc760f9ebfa0bcf1d10fd82cfc3840ac56d3fb592b9d8c87e4377f1099a92b96e7f2f5940c79d80b8ff4f00c59e5bc48289be4dc173856aa5db26c567e8e590c302b5379b80ec0848629e1f4bf8a89e4329b7da4def13f8a385ffd2c554cbf4cf1f082f1ca54b74d8bf17911720fa747c4391f8862682e2693233243145ffa421af9aac358eb48ef20d449ba188d5adaeaa032ae5dabed01c1bdf31f421c76256cb8d32a77af5bfbd0cfd94b5ad10dabf37ac94668318b46c88c1f0bcbfd2ee5c54d76c2eeedb2070235c41b216c5315b2206771da12e91d985670c65cd2329c28a093cc4c7071b776bc6f64b0f7298759eb447623b33368086267028a10857ad4eed208c66cdf69e026a6fd3f6ff42fabd3011693b0744acd28e6e9dc9ef1d33d446276e986c76d59089c4b7805a833d93dd97e4a1a22dd6b298e484c9872e0c1c84e32efd5b52e5bd33014d3de9debb8cfc8ddbef78372628e685f822238b3f119e5adf1a01ce0ad6830771a73e059cd01f6f7d71b3a8204ef701d543e65065240b31b76c0bc72127f71b80f514bfb06773d0a294009fa138f3cd5d9bb9a1bfbb9b81b9272c26272e29017ed097083f49a41a33141ce5b46efef1020fd8cb9ef9b632304eb3e5f8fa93b248286fe4bbde1603addc3c0d2bed450d82ee14adcba284e0dcaff82c26dfa825d83bc86c28975de66ad8f978421a2d61a5fd6551fe1c4428f95562ac9ee71d8b08a576c2e61710845cdee4241c7c3cd81c6977e3f90f3d8b05ee302aa825f4523f476a7603ce431f947c4b864b583287adb2fb12a8277094168a5d139611582473f80623fa78cbece63be276a966fc932b71a98bc003a865e940e47d8ba90342a2821c7b94904fbf15c93a6c6899308a7f08ca626558bc64293b489f620bdc4e6baefa5b0d412f400f8298fcdea346d450126e1a72f567e0e47ee1368b183714075991b10baec250309b531522025ac0d741bc16ed354cdd9753f9ae40ab9165658a60b578a22b4fb7d622e516a7d1480991023f61cec128ee4eed11c105546b217919cfcc47e766b506eb9c107e3adc184817dd434d1bde7b392f06a4dde682b3be8a397068b07d4d1d063620cef2884365d97731259d1447e76349a6594a97f45e4dcb2acad99b440ff064093634d22ba24cc166978d3e024271810a615a64e56483010b508f7483bbf34d89011addc749b124a5bb801470495c9d7af6b846f2b47c9a7919649e6c89f84802e8ba416fd13a21452831dcd7443b77ad5fa3191f677ca131d17b962f039c222266d1f8d7b6d7dc268c7591c29bf1a8c77dd005040c9f9812ea967394438c731ae363ae8a03892003be9d945ea4f03613ad6af49c25ecaae9ef7221e1a0dad246ab76139372ebd16f64ebb0cdb26ce5debdf6a7ce0e3096396aa8e9e9796f1cdcc936293e31d0851be6d4421160686c1308aeb8c10d370e004293d45113ab17b3c8bf822057e53e4317708e38fac0e30b7803d8cd86b1e073a4de304c99afd8256547319b2eba792a6a172ce1d469359b3e7b4e560ff3b16041ad32f3a6338741e1c3dcdb8dd94423eb103dff3967acd1be06f5e252083ba237d902b2f672cff98ebea256bee4eb796074bb253d464bc8719829a9d29aa0ffe361f62bf72b8d4cd8c22816ff458cc70aa0d5ab2d6e24b47c73b1635ae82fa09486afbbaf4c7ee1b420010a8565dd0538d5f86a20180fbcc466daa6bdcdb60d6ea6a03a0e1be3ea8aabc52dee08799ada0f93533eda3fec29b48d046552f7282d61d3606ab1e573ce06648aa73c00987e91fce2193c94de76eaba3958a08c53adf99c19b3b04a907b2fed8bcdd08e24c384571b62679ae49145f54522a474126e5cdfbb74799dcd0cd6082909e2713d8242c357bdc26de1140f7962f6f28d3e2768a5faf06232645afd155db90655e13f133bee72b797f6ee8fd7e0512e33a6dde778b8de627ca21fd60f442088003948a0cca90bac60f02e435f40490bf53d84f3c0fa3fd2c5aea10fd9978170d1312beeef47aef38ae347cb5af4792ea9a001679323bed0a68b3624b6fe68af04faa807128330b0fd38484e0e5c62123d18ede65c32fa41d6ebbbe4c2d0f34726ba8470732e16f18512ec8ede44fb1cf7ac22b74946174e1ecf1c09840ed639a95076b803adaf4cadf02c08b0e8cc4283b2620f7e0359438dd5272926246cda876db52924247edc2886742bde9d404c97d98472b8e4ac9453b7cc195ad6fb579d58366202afa8f5613cb7b45e039f9760bb0f246e432b401235fdc69b4c15cd53c39214dab6ad05f4b9711cb24b256de8fed4bc72c5a996d8e386d9869f3984473bfa5fa3dfef2a1674e6279e65dd16588d879dc9e2e5950a3424cde3852183d81eae08bd994de0df75e5c1be1f42d112dbc283744df564c914ede923a08a6cc2feb22fda9a55fa3c82159c34a5f328bd7b22946c51b48aeb9534abadec93afb255df81516511292707eb7a6fb570c3521851117a3dec0f8d1fdffc0e71c4df9d291f13216df51b1b923cb0cd288c97587fe5b1da56591ba174100588250ba09f57484ff2d199d0c77650cf4777a4961d556a21b2f28df8be33a87c39032d17db7da60071713bd866c1c7d1cf99629931a80e2e643f02409455adc23114b0ab8e4741bd37f234018e4a10016d8903a67f65a616d368fe891e645b9e881febd92982fc2ef55dcfe6eaa14b76370b456ef59d9596e0d3b1155183c11f718928fbd89396eea9bda699783fdaadefe208ff35728c1c39c9afa8d86c77ff28f24018737be1cbc90402cc855636c306fcb89c7fee7f7f42376cc59ee6f928c09698997bc3b91560056f53cd8e6b7bdf12380a5cb071c5e52768dbe93e439d9a6c6c8df768ada1ff376e5ec907dfcc54bf2690b6ca8c39c3389a3bb40f6a91ea6f924fafd958402493ed708302f300d418c7ea664f439cb34885e5999abe4279da2312262187c81f54d5102c1d98763c21b191efa34661e23a36dcc2338dfc5a42ffe677da66f9b12e540034966737930d217cf660adcd87f208a90d9610aa155b8114d735dd181cf8e2c34c947b6f1c68073d6a81ebc6dc00f70b3e97e8af8e521edc899570823de5b2a77ecebf650b15a18631952846293c84e7446a31fa0795b59dae74f919b4779582c2cf9aa94ca9c8726273faae9727c6e963a683642e477f7a06de2a4c9be2d20800815ed62acf6e2a278908aa2e5f07389371f1236348068c0f5d3cababb663374be7bbe803bfbc4554a4e976fadd5f3e155c1e0528a502109709d40dd0a1b27714d1911b16ebd088567ac87e68a2b96ab9791acd8c578c098d3b7d8ad0647583ae816a7a28375078aa11f095a59408b36b0904c657bac81de60b35022b198b72369f93f78158d847c98eef09c4f05440cf505e8333222909e0f66b7729dba3068090d920dffbae3b6af52194d03a80fd6ade61d6d9770978fa530a7ec2b6709ba4beda3b3bb242bcbae57215a4fc8e37072a45007fdee12eee925b97fe523e2af757874d8f57eb07014f27ebe918f189cccc0498cb75a918b8ef0ceb8c360028ad20af43d66fd674efa6ef3e34416e291225633c9a0f1fbb63ecd2911ec65580e32eceb3ce7882871ddefb14d5410ada5c39ef2c9b41bc3c94a19d74676b2af4d23336980b6506efbdbc5a9164cde5eb9e2b5fde866faa46cc45f99cc3768e7036b065b17dd72ba498abb98c435edc66926070904dcdf26a9c37441d471777a7ee71f51f7d1996546340b505c6656b5957353d516fb786f522940db847c3e8b1d6236d2bfb226f4cb42c57c158d69eb9d71a0f1533c6d2ed2273c38fa34e1b9a94911a4ee1e3ca472bbf988be98e63b58c4c212e606a8e799bfb7d474d59fd8f08c663260dad10c9a9abb65052288c398194f807f0edb5e8fc5ebfbd0319501f7cc82d40ed94606ac991a940c2c7d6569bdfd8c15802e262e13b8036f56119afb230fd6f44f9a140b5df75e0fb73348ec022fcc3a9f343ed6222bcbac3c738c627135ee883653726c2546b4c1aba05346ba9d3d00ed51d907be20f4eadb6c7934fbb70a71af8a8c00f7b1f1f27a0d0ab56e261a0db1b8e422b0ab97346cc6edda17c397940f4dab31d4d922d98613812f3dd37c90df9164ba65d46cc38287f7bdff73d4c0647c956e80f1888ebeecd80c8a83e565ed6fd744d8c9a81a5be9db76f815d1cd72c0ee93f89603ffc1585674cbb94a27c2e402d45b55a23763be056668b2f3a6fb5084d8e751e656827d292d43243f57bcd401f3299112c4adf9c29b45b684e5748d7d89d8f224e1a4fa33bd5003734a4e21286f651219ef0b1d23edbe77f990082e3d257ee8956005cdc7bb1ab8dedab0bc892100df30e9abfc021ea292ecf231b8bf72e8a55f1a6827ad9a0463d82df2b864b3bd71a88540596ad8ca5d6b74bf74ce5c35bd91a96039d047e263b63b478809a463986ce11532b10dbd743d45c7b8d32f74b0ff8ea3053c1b0a0b987e2e9cd1c7fbbf426e9d3768c0b43a03b241ea776b0efe97d4278b64d490c22d909cf7aee3e54bf4ab50adfe5c7ec451fdf769da5eb0ec27f3df4fddaa1ec2bf413b27750a25f62d3382d7f73d2d620bea7580456f63e9d268fa4900bcdee25347a33dedffa7b935da8d92590686e6810d2c42f1daaee08329dcf4383b7d226d9607b19da9f0f649903738bfc7ed1bab843aebbdc0854a968718d768fb2ecfb9c748555e88b0bcf367076402492f50234df558e22da3997e2739b9b6271fc7ed32fc73348e13a7b8757f92d5d572bb459dbd718ef224aea5737ba75dd2d5f49f47f93bef4f592c0f779936fe3921bf1e11bc80ff0583a72cad725110021881ec2d0f5f671367ce7c222b9fcbab073c43b155eb56d3ebff93fa6d2003b890085f20a4411d8893cb9fc78a95d9f952545467f1a67e467d223067e312726e07cf7b869d04b6cf3468578092d8685226314fa96c83df0630b44ddc0e9a1228e19bbbd7ed5ec3a8806d1ff6f62b2c1cd9cdd84aa00bf05471fecf65c8a15d7779fb1397e49cc6bcd2b97cece9deec41bc7d9916d8db2a9f2130e8f959cc4169f8763a9d8eccc7201e9365b5e2acb7e4fb5ae2a69b3a8f3c2bac42ae1767a58ee36442954310749a0b747c81e8fcd662e47d86217cd7751357ce4d85cdbd247c4baa433ded3aec9e9a71f529dd18d8bf8661ebf4453e63b8b1d0797f44e2ef8f85fc5751ee5a0634cd61652c13049632858564aa3f54014256b1b3c97f23537996a8bf71dbae569092d6061e20bd7cfd40cc4b118ad5179aafcdf7ddf18826102318d68aaa332b005e7f19555c64ede5f681785e7b8a25bc77cf8dbf9cf64d09b5bc12836978a1fae682d78bf03a505e19b6b7bca728ea0410bbd2b9519440e3828f314dfbca2e3c249815ec8a8aa59dcb88dae0e727c54b8d7a133d740ad8595f009eb02a7fef714f2d26474fcc8fc3afc8a7b48ace6b4328abf6844c69dc86b76d5625b4421e351b4e463e4d79804427f5e55ea80f6c5df22fbca76e5b4c3453f0737517a1ec726da7f930ed0a10e5f1dcd9e8779391d76bf5a359e7b376853ccf694f91d680203a5fdaf4554dc9ec87b3193ddb7fa989f85a315cf511d0715d7b34ae88c5483a821df08e5edd379520210849deb7594be0b8db238e00fa3c3c8dafcc125883e1d5875ba5ff296bf6c1e9c9c0f75d1cebe7dd70485ea8e385fc7df985fd0a108064794991908a68a80225b78840115e9812369fd076f20c3ab8f1c5743650d40ce771930a2ed818410cdf79d088b81044a2337cf547c5b785073c7e31c885f4969915e7c9241e2c44b77883c8783e705accad5f93d9d4b196bae2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
