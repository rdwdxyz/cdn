<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f872049ad73e7f10de8d61210db4024ab610ee945b4b3d108736adf6bb04cce08551c181f3733e9e7e01a60ffee9a30bf8ed49fa18fc9434eafd940802faa9aaa8a29e3e5f3052d9857638d21cae7bd34358ed5e8e1c2313be3305596c0d945101469dab0ebfadc93152262fbd30e1c086e6523c1087c09f353765a7f6eab10482d65f070ec1e0371c4257e7374acc9d7f5b44ec2cfce133863b4ed81b89d8b1a4f455b79519a294ede957fb0d7d3689a6307b4a085e537b63b2963f8c48c90ccc3d1849a8b6a6e89e86e8b95067d8559b3db3ad0f31cc4f42a7d17c550086685a6a1defa7554d36f65b00575c8a9c7d58fae781e7d3a62864c26db3eeb9e698d41559cfcead99f2b05654bf0800b8d119bc22a573d4f8acdd8fb2e099fe141778d524bc96a96afb6c706e1fd70c36e8361330b3a4ab087bcbd645a740891232ba1166ba8ea20d2b0d86e34f5b9ee769e9a9e2ea8d29680af30b50af88fcbaff8700d024b178e1fba101c75b892c42c3dcc58df92b0110f5d9db898f7d1e3fa654ee1c4ddc8238678d5a28b171ad0cb10124f8a42c3873886c6096d721e9e0a1068d86f5b79b812df72a1f4b75eab9a2d10c3f524eec94818870ab14fdab14325393f2665e26f73ea5aa8a3ad51502818394db4e362310e2db98232f4e55b0b0fff75f98bdb505693061308876398a2103a543fece6f029e46645c234979da6cfda142236813ff80b4d5857e0518744a28b10b414d0060e6c278cb10e2d6003721259feb644c0bd566efbc9d84f5a6f3ad40dba21241180bca52dcef78b49787ee3211aedc25d30f16cead7e83041cefae6eace73e9faebf499c35a794b34aff7ad442bc0ab018866212bc15fcc584bf52b205c021e4162ec1f19f2b2b2ac3088a732069670261ea8a611c6e677f3ed364cce6d9fa5f6ac8fa8d4105d0c4ad3d7b2acdb6c810a093bf0bca170feb54e8098f087610d2f5ac6df500f7faddc3f8c075b4ffb14d9fe0d722e0a7cce1e2354e73754eac3fbfda9cfc6556cdedc76eb0d3a21c420dc9004b0e66503ea94911754c6d68e9f9afa4f4cfdd9cbbdb4f79fb3ddf5f5f55533cb10f3d0620b81d83f348916417943ea7590c10de63c370677e1fdd929f059c9ec17a54eef0f7f72bd72f93c56d823e6070b3d103b4372b7cd3ebeaccf6806d74cd70c44bf9b32168c0e1a1e1ba237b56d400a2f0a8bf94316d668569c4dd04459dcf040621299d24ab52e47a78400a50c3347c0047196d68a970024f16f9b200cec1a13c80e6e1dddcd20a85050bae13f3bce1e93a2ab52b9c1a9c722fc69505f27d5c9680b5190dcc01be8a5c1751f1917285ca60eb09bb358f3f1c5794335cbf184f9696261961427d5da02d96aacaebd12aaed180dade01ac86cf6879902b686ba598473d18aeb6b2be989a4b91760bf606a0d62a3dbd49ff762d4cbae9b8a2200d9ac23ac4f67cf1289ff0a28ee11dbdf9f24a6495f97141ac26a14fb1c5b8b06e7f84596229d8e426cda6d5638baee322aba1f2eecfc3a6662b8dbf3c2e6bd57ad54d7bc879e459f25b76335aa65f70cd3d89253483b928a01d09734f41f2bb6fe900c4eb0c8fd4d8de86a9087451022420e9c7937cb947e6643a8cfc8ae68a7bff868c910bd1ec71e683c6a25e7c7cb40ac4babd43f78526f467b382b90c7e7287af4bb0eed4980ce6a128d39344a091d73723ffcc7300fb5ec3c0586c86cfb5b509ac85550dea4f1f863547cabd27bf63002def7ff5a3f47fa60a508b4db70ae3cba161e8806e1cece900b9128db1347d85866b511ea498ffccff3cb9ca767f09d8e388980828294b8d08438cf748b3ee5455bb8883caadc23330fcdf53b81b3117d0966d5369fec57724fc7e9228c94c6972fd7938b7e64dda7f3df83b37035757fd04fb83fe64459b2bda34c224ce2dc1212972e7fca51896e3cbc1fedd8b50d85e1678b37d861d9bbb9f551b15334a92f1b53733470487d54403124155f62c4bd71bee3f28f1d2fd344ac0e8faa3259dee09686bf7fffa2e0eac1cc265977d2ced9bedee7d42dfb19e0c135697742e9696ca2db45e6fa3221da8d203e18ce5aae3c237abecaf7056f2cc51f9e2f16f18a727ee99a1d4393ba9deb6212a364995f2fb46d576d3cd7b55d38c909f884392d2acbf4423c33aadfefc6d13706602b48e4b9f9f3000eb03c8c7f9e10f2889e2fe3af2f34ff8ef0269e0f3424ae7425e98f5cc3a29e4777ebc69278b9f6452012c738718b7af6eba68b5e72a979983126d2a3627e19af08396901067777ff1a9cceffffef8fc5dab00165a26f0ac05a23406e517dfd110f6917c27ed291856ebbffec74669e8825f9e8d9facb582465bf7f43f5860ef0278e6c1d6a5e9c98944531d9676942b710b03b6d24a493cb8dfe88f3e4d97331a34d39e0b6fec91a26ce8332e28b7f9e9e1e196f91034fde68e89b767cfa9b5a0a046d96382c6cddedfd2c9a36dc124ce90b330d9c3500238d5089e25445169d1d6985b34740e168921ecb0ae3cf1f79b33f445f8f4465c20cb807e6a9ac92ed209d42b90ff67eff9df5dd531ff6f50429598c0369e303db8e9a706b2d603edaeb92dc7726e99f994141732692dd3fe716905dd13419f6b58c02f027f312d3342048ec5cba55a0d93fb6eed7e8dc4b9cbfa132f24d991afacba56d7836075cc9ef80284889ae3976bee3240a6b1b345cbaa923e1a2a35b6796315f10c142094a6865645a7292498c0d9776994a63acde55f6d8bbbe91b08f5ab7306fd84059d218d1c30afc63f6b42f7f3b1e93fb26b081684c105eb699760eefc141ab7c54c23923c22f3f97c28a5c084655c16cf94009c56bc827b6b8047cbf474c1f24f77e7b88d92cdea1ca0e4eae4ccb4aad0348482c33fe2922d803e18b3db29da5524ab01cfbf8c1d8472b64a5739881337e725cdfd6a35b18c44c78666c3f9ad87a4b5b1f7739a92f684bfa626847bc167650ace646c8d0f13ac0278a4972e9daf335517c68a968b022c412e719e1238a51fa8f3c0da5abaec49e38d0d8727c99ad2b4f50ee414b3b174a2a2f5edbb4d6480ddfad6bcee5f11ecbb3865c236c35cdc2e6ad9b2ddf15c25a5607c65b1d0cc64c7af691bcc4a49a182c8080f3f31465ed892f59e51e7f0d2322d473b309c8c96bf45e27e1e55894a06ca0e7c76adfcc4d1093ad2210cd7a9e5d45f9f46fd49ba3a9ae1c24264d9144304e1480ac49c740092ff16f2999c8d704f772e7dbaf70767d66b233304eac37ec2a53484b337d3e16b366ad68917d97e1b10e2d5637f7958b1e2564f004faebdaaf4986d39dc9b0090dc62522c69edfbbbc45e42343c5667a62b3e0bf44c92f0ca9974d27a29967c8629bb1878d24351a90256d326cb7290af42c34fbcf55e526c9905010a1eea7429ada254018564f97b6215ecdbafb3531b4055adec18706f4d7d72afbf7b386f475e5b98748e8aeaef1d64832a53be46cf4b4f6e9bbfe632c1c7daf8aa57447ed4b5722d9237dfe1d030dbf5370cfb8b74ad76b4a950591e855107b02c545e20d486e20ae201796f873206dbb8ebf39c0dbf667d89ec6cc66d5c06ebdf6d487397b741586bc98bc31f8e0cb65310ce56b4faff567470fe3c45985019a07206056d850e060e75432de3509664f2c5b5df9e046e234fe844ff9201361bb598ac27be460a7170c6aa4ff669abeb710db4c092c678e4646c9700a36da7ff4706ddcfbe5002ec41b66b56bed8ba8e431c1d325ebf8aa29255b988f81660ab58528d54738687e8db21e32761b0856a57d9300aa3c03dfcee768756f37140bbceb760092db3e54be99efedf8dca4340833c0452dd11bbd723d5d9c7edfec5bf65c84ef0ccc8a1bf76de0b923a924dc196a140e06f3c7d332d68dcf57e87e8ec39878e9c7e2ee7c0fdaf29280012e04d3e892a2c9c0e59e622a525bc8afcc7ff1e9fa28a4c830f663947f5d8fff8709152480aadea28a541feffe6d8c915da36fac57adab49984a5b1c51684c03d78338f5901cb3323e4eb9f4aeb888b2ce790e141187edb7fbffe88ced2f2016d10ef6bdb65cc459d5358cde07d39ab5acdb3ebc89a23da2fb76b644d474547e4435698c5ec71ab25d547afffe522d3564e31926457c233f62d4778b9348c02ca54ea49200d25413af6a058f80386c6a8d3b2e20591e3f35b5715506996369d6e6bc8f7e1fdad58a328ac5803a5d951b49d321ba211ff46d277141fa5a0febad8bb47a7df2c9ddbfc2694b45f52b7537f15847c1a6a51bdeb683488041f9f9a43926661d9598d52d69d6907c7ce766e11a5883aa5a55a70a23efd9d60168ab3781ffa580376acedab31bbbdfef24e887f0ec50d9d4014469f5561826cc9b43209214c951220b3e99d018efcf78d38f5237a62471653f98cd0ec97dfe6bde8c405132436999c4860fae7d743226705de9c9f5161944d4bf14b4d71293de1faeec86df0dcf0eaf229ed8dd4ad792943049d91a2a1f03c975b30d3a1ead00467527b0f260445d29a67d4be0d7ea9350773ada9c5022a3b553b1fe0113c2ce552bec9e7fc6a5db5a584fe58970f8d2aa1905b4800bd26f450188b63deb25b76fad638fc1c6ec1093a0f936fe477200cecf7647a13d9be5c37c6d1fe1abb186653daedec91b59f733a7bcfeb76a3ba7d7f372d07c5b7ff88a3b53017af88858157b264dbbc7bc9ce8d244b0f7201b5d5addbce1fc45be0b5d094c17bedb6ca0041572fb5ce3a2db69018ed3f484c86170702fdad48e260031917582ff156f7211a3fbfa6c15badbe73de789a6bdccb48a4195fa3c59e982473b852a87db0a786467db830c5823643fce0684af59b9fef7f096b7635caa52a42ae5adae87ecd7e44747109c267ef88d5d22cf5f51991bd9c36c6a10a43cf65bf5d1f4b37aebc8b4a1939718e5b3e3b9ba369ebd683e1c9ff751439d7fbecb30948076588fc5268dd78d03f87a434250df3ec6ae519685d3f7182f9fbbafaeb32d52dbd2df895f237ef9ba5aff6c106d78dd64786c2e58434a90fc8a52a9b7cb1ec8f5ffefccb11c4ea92df6b7cfbe8855009b82e402eb7bf425bcfc0b49738b7919888e1d76159a644f86e3933e13de8863e3e40a98efbc78a47271d007f927fb01cc5e0d9672189b51d2502664a4717c94e1702a971cc9249b116dbb99155aee1ccf629fb1981706d424c23d64453d534daa2bf7ceda921ab6ebfd0d33b5e6d5ef35971b65e1e1ec2c38bddf275db09223e81e7367dfa45e21ffadcfa17e79eebca53116428738572de330b03dd83b573a021a6cc717e5ca4478184ff6e115688b9a54702b25beeff7c1da9312ea7a49a019e8984d6f30c4449813eb5a4cb3e582213089387f7a23fe9eaa1912cb2ac1940c3ae1e9439d99e7cd9a7f1b4c16b6e543b749783067342ecd2530da35c4a4409ba3913276830b8f8749d208c86a837298c8f654cb8f30f44f2f00201413bca88fd625d3055e2c6c48590a3a31bc872afc32dedb6e426fa4ab2aa7a403b5f89c891a3c86f88632bfa417ec067827b9ec21a23a7d89654d9ba6d4b3ad730ce12b6295a831f0c6a0736f2bac80184d9fad94c57eda7dbed34bd5dc61e712b42d32601f192c2b3b66f280e2b35a4f2c059a0af75a5135448b9bd118e411b82ba046e3e6ea26c967a795ee90f6b9af223214d1f2072d4dd9d946c645729b83bbb00adc7604ddbeaf91c973549d13f39f5d0c5b01d9d03df6c3a7cadfd5a74115d2bdedc8838d475348a6944e77df6ef0f9bc6bfaca283cdeb595810d755cd67be8a6445080f728b92957e7d8c8e35cda04ec2b19d0f66a0bc532727c39d8abbadc24cc186264f6706ff75fa96c7894c34c510e7cdcfe4c6f64c575d26d73aa18cf02ad68b4665b6ed50e5d05cc5b5b2c3368692bfc9c1afd5815828130108b53e57c870063c904826bccd70a01c2d436f8495bf1cca2ba313da39fe6d64d41bf60876594adbfa68616f75ae0560c5787fa8cefab72a1b7ceb30102e8c700a77c500a6a198a07557fdeccbed6e959fb3811e8ad003ae44ad02d34f9ae9d6d672bc20d4f32a7ddf49b334b47e9d01fe7de4c472c6ffda01f2b1d893b4e521d706f6470e229bcdf984759b577de38960fee68afdbc86f1815ba88ad08e391cc97c357e1a24eba132c659845c521af7622a11e60c01bfb294a3bbc1b95f25d9818fcefd6e1fec82b056263cfb2c5e3517fb10ddf66607820245ce086646c2577cebc93d4d03ff44c57dbf1aa27031156f8ae1b223fd5e9676712f7a1d9325007e43f03411968e2de9ef1f8f9ce66f922c3ff7c9f741c715312a8f9f3a89ba267586cee62f623d70d5f7c68fae505aa61dec06e8ffc9514c65310fbc7d9de2dcd6589ec876b685602c61ecce721cc22d8b723c7aba963147fd40490b7a7b1d056a128cb0b45f73d3c5550e05ea0114102aa3d12ff511d2fa0fc8953a43cd5e8119dde4f6fc786507b0cc36214877ac21b7c0dc64e70c22085b77f6959496bb73274e4575e8edcf228afabb3a33ecb708524cfbbad45a88527bf45a7193cf0f84f8811866d8dcd994df5e50e05710004f0cabfb2807563261cdb8f82d2a94ccd651a357fc36ab4c203c90c7ebc4e33c6912a03f54d2bfabfec4d6e6e6b2e150dfb032ff5862c6f71ebf030aaa7fa9a5577f6f1c7d83ca12f4ede4b5388a4b0817f8adcf8184097cc96013bcdea730372fbc6697dc17cb5c3982a01dcf4713e1e11f85136af0fac7ae810542dcb70145000b0f82061b0b4731ab57dd1d730bd37e11a4af68a2e1112a6ef40989cda74cae8681c57a47556aaa1ef48123c6c2ed4818018486d393a17066a95bf0b963b5d173ce42b3146971b623a100e1b94a75e8f35fdd04f16768c66755081e7fab0f06c681c13703c451e89a6847a94ca764bde4a24e612d66272b8ca9362dba6bbf7c04341cf6e879fa99962c2d4e4051414d727366ca695ac8324b91fdc99e63fb84094de2b0e86982c0ae2aaf2f92c0a38665810cc92fde58956781ee36901eef37df0353589d5d57e2ff95460f37cc084664bd254aed42eb146d9d992e118790655ba890f9c7e752c9744956d2a0de876ab36302cd30269a80ba532db971a0c11ccf6b09921175e405a9941bf0a8575b8d9389f51c4cf42da9cea2fb2b85b0b7d73f18b0290c81be114317613c1542834b45455e28e4aaa3129c8a57e91e9913d9074e780617dd8e144b67b9e8161d3ac565d525d1cf25db6a6ae24190656bcd511f8060e5d68a68d2841112a839101778661e11f14b66603aecf09260ea483fc562fb9a4d44c1a48f0ac395d27f7fc39cfdb7a758ea5267abcb0cda1d3a1d0e4594b19d59c7991041b52ac3f2e75ee6d1b944f79182cc12066fb475baefd001d3abcdb4dde99754b683e8c097bc31ceebe1d936e247359f1201a409e7d34e260d1d8db788ba46756528e93b4bb427bb9e2bf5497dbfbd055cc29a6b699ee8110d2d4e5f62c191fa30aed6b97056dcc1ef2178abcd67dbc1aded799b89d5114a2772717482447aba6f9735ae90649a7e0344d883b45bd298d3c7e7eff1a8daf75c2b199d3e94f54cdefa737baf8bfb8ebe63d49816385853e40bb5aa2fb705a231d9dee80fbcd23915f290345ed999ebe83057360ff1f5127ed32f76f616cce31426c74c1a95486e5d7c1e1916abb28761c5920a31a42be7d517b2d862f9bfad7b38e6044a604f208cfac99afc0a21d31de3222893a7531fffc5b91ca8efc7dd6b5d2f31d322b747d3b4a9fc403ba56cd1ad265d19ae7858029011b7f7af3d85f384baeef6f0a840796713e701819edf846986fc7c8ff4888d2a1e60fbba328c06d5ffb0a4cd2cd94ee092cf12c2a85bcb55a0d66724eaafba9ab9feb34b91eede9e038a9688c1266c5cb7ea2b66cf6e8e088b089a0c154b1983ae71b48d3c38785842a562a55e9d8aa827cd3d285b71416b861b06928fcb73fcf117dafca19f5f27f8a661a651818ff52964aa601f334bcd186af9427dd62fcf91ca0cbef3cc4f2444432d3028ed386d71982af41cf50d3d046b3468ff3103a9ea552e12795d2a736fc05cf1d78afbc10409b2c10dae31c1f7d10aa647d721ff4e2ced068b0c98004e9863be54b2d4bce61437c954954d6cf9486af52108592748123d437c4160af6d8010f96de4e2044eb6b487993b1f75ba1dcb3cb736818623bb177294e314bb97851fa4e9cd32b27fc8058d6a9b0e4a3294835c02e1598d749db66c28f80e0bb8844f0ac09ab52d717b890ce1aee81e777caf00409e43c6b844e6dfac458cc6a5ae82830e46db28084450b781dc55188e333ef9b2122b48c385ffe8cb047f56e72b4ac6d568620c349d27033f351da74f824b48db0772c95c3191525a9ae9c148a7a69189df01ed5e1bb663e6af5b44647c862e9b8a64ca57aba91afd141131f499bd3ee28462cc2f36fb3203e7434e3c593e8b9bdc3ad0c0392b4a078aeab996ad407a5e8049f41aace71c8814cad0269fe006979795fd3212daf0090b796051e585c6964f113ab6eee9e160e35979feb4719e962e748b634d3f58317ce9d666c12a516441a90fa93ab15ca6ffb998b0c37e102890bfc9cc48dd5dc93095683593b403d40df469b90246238f5adc475eaec19b90ab56820f233271b6db1acb84833540b187041524b73aa7d800a3857d605b4bdbc270f23e3cb2ccf8979f2a08ac9f870b5b18918e1753ff778ca27b0c6d056736c78759665526ed62548f832f3b322d4570da0afc613cc6a39b518dd5099d30d6fa8d8ef744d0d0fa983e98619d469ed6e7ea40984d401152cc24b4515e371fb7645d8797f56a2afc29c0d7d9c1e4c899012a39e737a380c0f69466ca796caf03df480bb48cb3c575973fd79b9770cf3813fc2bff6d7b2970ec6182b06fe8f8a57114078e92d2fc4d73e1df6f2edabbd5287796003c33d8ff388509ce5cecbab7174d905c5b902cae8b00225cdbf94c80ee2e6f3b3fe5a0337d66010ad09e1cd0aa44d4c017c8c6860203e113ce19c946f2d28c474f2d530648be5e9d891a1701c93739a13a6bc41ecd2f98c44bed233ecac279b7c69f9576d1f1b6b5e903741e1d75c7b97bb0a700d46203ddef1dd8cd70751ce268aff1602b4fbe0ec8ed6420ed16edcc46059e7ca6c2a26e2cf003e27518db93b28eb2cd65e93f334a569ee77c1037c8a13446ece58beb61d197f90b6329ae5aa2d1324ec1c8d5ea2a40a1d4ec8ae37d23b31094905c8dd2c12d8b075bd0762f45efd17c8fe2dfffe2b4e580ef5a0d768ef84eccf6f3c318d751bbb196bab0e74e262ec10930533b131c34118e5ca407b76238c7f6fcd5e632ebf817698db3f1b994016ede1d800dfcba89f48391a0e95a6f8cf07d7e814446d02cff0255aa367f77cf3d5b5c36b5d9b34c2d59c181360a60c8d224f6f0ef664e0b7416e0a170adde0c88c5731708ce27f914ba3cba266bd0d9d94f8167c347ea4a9811702a346a372f992d31e8226d37464e952005cf4fbe47455a58dcd9cc407f509d70b3fe16a96c60fc87aaf956e0a8cdce362a63f8db401f3fb46a7bcbdbbbd5c664720dbe47b90cd949da3029bc6f6a433894e8a27a74631dc7732d635a91592a66e4827869a9729797ab182b4cb13fb77b1c555cce31a64ab6a4a65f1907c606f69a84a2d82cac0f995bd18e5cb7e92c9cbdb9d4a2e5461784cdd3b8ca8dd60e125467e0a37b79f04af61102093eca75fb4109f89aef3aa1c3074f00f0b675bdbdfa6c413e0b6e5478fcc9a1c22b936f00466b210c75257265975e85b445add04adebaa3bb6cf5750de1bc1815bd1d5a674363cfa22df96fe18a7ae95c9ef7c71bd9411336e275bd3a88b1ad641973853d5504efdd37e67897005c59fde5c6b17ab3ed1bd765d06ad8bd760f3f3a20e17c7c4342a585f69dc25ed2c203e0d0c6ac96555dcfbe86c5c9b8e7b65173ee7100806be5f142b685a51b5916b2822d01f11333f68fc230c592c9b72377346ace15a032d2d463a1cf6f469f7513d3970f5c0e36e17ea7d2692dc2e2f3630b1f67597a130418a8a3b0618cb953cba4caffbb24d88c65bfe209fcb79ce95f28ecb77700cf917c629d7c1c227fbc533c93872e415c625745c5cf82a8b99c3bd96b767519ae073e2b5af641faf28eee4ae9d2819bac2e67cb940c5ed4808e65ca563f8ab7372a17479395841ce29896393e8ba9875a99abee658ad012c427bf8d7d24f43cdcd4fd5b97cddd29e662308a9ea0dbff1d55ff74c74370eb076656e4e8a5a3869ec1decf3767c02bb3b730479398a7dee233ba8f5bc7c79de11ff85507c901acdd62b23836ee12cf5fc5182eb2287561e3ad00ad8a200108ff116ed84cfdcf7e58141331eb16f58ab2cae071cec2b6abe1ca7780a186d18c7b7839440461f76a9c87689af4261aafb83ead31e6ce378cef20ad87b6f66999ff677207a81e1d9b89ea018147f467d77a65ebce6bdd90c99531c82081ab45e08b91b28fa1ad480548abe9b69fe8af1842c781948af2d1f55399e9bce13de743fc7c67a13ae3657a52b33638eb192c9ea87b372a7e14ecb72bfc4983522f900bf2db36475f8841bb6d66716b02566063676dad9e4934ac65c7bc413e9e2e7bfed069f7d9e859fb76f50edc2acfc2c4ccadaae5588945cd5ade2b7ce83a37fa2f743664dee8a4a7ecb05fd7a37f8a875309ba1e7171a80d72db224dde0e6db90012734bd8e583bf9717aef3fdefbf03597c7c90bc33acf80c6380533428211859d33f15494e1faaedb1fb03ad27658f480c40632723c82b284a295dd65039211e04f160f15c08d604db70089e84ff479127a692a646757768871f873f7ad6294a955376671e653760da7643dcb619d42ec296aad13d235e216820b72d7ec5113ba4bebfafaa85e8790c36f656ab8d900d610d6ed6efd42ead61466b450c8f35540a5ada77e2898f20590f3b4866e1e92fc0609a0e062ac07f3d5ebb4a9c1297307751052736f0ed8b6caf0a3fc607cebbe168dd617bb93cd3aeaef3c22ebf103e61c2b5b8d7ca839d423b1325cb6424f5d61342573082e82663b2ddf29155ddb2c486e866d2235d0443d9e511998e5de8017dbd3e2523526b437ff54b3bd86c8d42da9df219f91c425fb2630da53882f6cb64802d6288b0095d7c268b0a52575dd2b3af4a93c0bba1c10932831efc6a6be1df340d96bcb95520d58d4a64192647f482427fa4de2ef1029deaf5a1da9242d844cf926537db83760c7215053e296b13670dc73fd376d47bb3b35e9d351edb6a9f2cfaeae9b154fadb5b73276e3876aa3ff99750a277873bc75028075f602b21b6a1437c3a54c1aac79242dce7174ee0e4d56fdef75f306af8cc46286919f2bac5cf60b1ffbc9b0c045fd18e3bfd061f0ed4b1a49d12dd1d9698595a38923e0e54e3e782d73e886f2dc8f310830e4827328197a9dd141ccbc2f6f3d23acbdbbdfcdfeab8f03fabdee4313bc0b67abbca47155ee1b7c66d5cfdd6354849f944c89c7b8f62f8c762a4fd24572d22e396aeafb3a61218f10556d98a1fad79a242e60c1353b53cc9b383dbc6bb973fd4b132dcb3758538ca694bd39df4e35d9d1cb8fd34fb0cbce76e67fef5bc777be91463b279a3e404ab8f4e800e5207051e8b173603eea5527f71fd34248f7b02c1ea31f70a13410cff5411f374ad1c2c64f5154adff9198c0482e1d0df70f679e7e6197d1bba70c75d54388b5c1e639b41bf299a99cc4c366a48172aaabd0b433b93737c88e21f06ac20e633107438ce71ee6abb06f991b361e54f6fc2f5cb3cbb0f8b6ab761279b7dc9eb9b8ef3d4add2782778b248de81246ae649cd122bd8c8f07d03156857fa56b87166139dddeafce74c506c875e4fdd8dc25573fe2a6f6ff98f12b70c8c5f56bea6370d31382ee2eebb38403a032fac77351a9f893499260f02e5082071709ac8ec2df03167d617143b0d4a16365af735ebacc382f5828089581a57888de562a22c9f666b7fa94845a6aa917d9204d2348045e2e6983ddf33f180d61aa0090594f79ba72a82f0d56c72c6212e03ae96f7aecff99c119284c6b8cc967eec05dd7f67f1d61e62508ba9314fb1fc1421f92d9459d47608b3c8e4828f120852ec3a0ba3e887625a08584876e1d6910c62aa3bec97d27fffaebd4148c4322e4d19c3f0f5be86c658a05c50567a075d071f92b91cee4eb90ddf7f8bce9bdc9d6be9f4c174c13bb3578bcc74bab82fa928b1500ce9d4ac817d35bd41649654005477c104232fc0664f3dc6817668627bec5c38a2b92de89bc02a8b9235ef22907a3c873befd88130e776660f54c6191e8c4ea802e05143fb3d79ff2fd702422d73bcbb4eaf4f61bdb6e90be15485492aebf816c34a6654b31fdccae1c1119a9c90f8503f9c9e88095f8f5f93169d4c279485c49156501e3c95f6c4dffa77569e54bf27531e824ccd1d73db847df978694b5dfaa97b041f6238f7a8ac59f7f053d56774c589641fb3732a7b790dab4d90940c2e3937414e2957c61e6471c2cb453958f0378b5f0ed1e21138dbac6c805c001f7b62b80b7d8ac386e24bbb25066f0c93e62cd46f6b2eafaf0db3e79048406d04c63a648c0d436feb9aacc2ee94ff1f1fd9670e6c2105729bd4bcb56315d58b5220d46f877ca420cdd70cb29b9e6d20a8766b5b45d8f88b0e99396d38cda633b3b4adcc14d83232f427efd5b657434d997282feebac8705f0a6e73d3ecf192efd1d8f362596f1169d55517520330233224291092a2c881a95a344b09d4773739fb233b3588d32482a5b5c90670327ae59343c8fc024bef8960ddcf021a10a49c0dca5a60fcfb5b49147ebd456adb61784bbebabac84d502c3d033a426c00f757d5f4f67c4fd87b1bb1f95d75b2e4530c2678afa8a01d9f6b02c4cb308aa575becc9b473ca6770c57f8c84e3daca6d5a68bb153833aa35c484cc5cf44e2f25e6a5aac3e87c878ffed70ffbbfb9d275a3ddaeac4cc2c2a210d16d838ff965a986237003f154be19c9c1d7fa62ca104bed1e0d3ebe8e5726909fbba1f6ccefb0f71be9420664dbe56735014d694cf420ee332ab38c566cd0dde3da48897171d358dbc1d37de4e0d9c1067975ba1888eedf262b5a0a704d8af64b3ca7f57e477cfcca05485bd0a1bad3cd098d92666a825d5385177f1d20615dbbc87ff02768005627d87b49fe523ad2f68c09b1a5ae07c6507b9a84b9e15848cd7fec99336dd7d01f0dd71876a0194e6d56ab26f4329234a3dd734ae6b8a74c34482f2ee03ad772ab90a04ae69b6f770c2903a8ebd21bda21815a9e507385c4ba1ea855ad45f9564193fabf90bfd5f4e427a3bf5944541ac4c4c09df9914879c38d38c7736f076b07e53ad17aebf8f52b0d73f96bbd15a1e6e4a5e8ad7f43452fe8d92c626f839db477063da95e00cb38634e47f0ae19d5d9efafdec94f7e824d415565b0d6d245016bd48bfb136ab112cf492221cf5132bfa1faf288a15f7f3e2660f59e35ff5bcde1a74b3bba9dc792c5b4576da45fe1cd563d8ea4df2373b8725d3113ed1fdb231fdc823f50542d2012ed60c09d2229fc8a3a5905200a92ed7d3f620b21c0662e211854489cf08299331928cdb1f77e6a64572195e0770d70dc5292d5bcda150d48aa9bf51f8ae06f31d136452702bc1079b701ac8b9f0837930a7895f101721696dca399c28ae17241fb18041b0fcd417596b0648d749163acb4b775742f8c89366f7921b36694bcb60478b207736c6279143ca56e3fac2f0b40bc5f68f5fa5ad6b813c5141b0a62fbbbbcf72bb37d94e8ffd23e518d5e1b12a0f6a931ade1e62269accd8f1aafec21626743cc17e1a932b30a83a12230c3344511e8acc39a6833ca3a68854124b1ed0b7a178c504ed003bcd30181708cc133575908f3f85384999791d7111ce04dd32dee992e0aa6ad868f3e3252e69a653a2184ba142460a0e9ab950e8a011c851c6d81617eeea740b64278b616d24a5d1e8938b360a0194e8ee33a9d2586658babe5d594c8b8b8b90ff4a532db47aba0bc0c7f282f08f28155dc0292ef94c6f8bc8c1d7834c9b4a3421661a6d85139abb7a548ba61ef6b03a8d70d848bffce7e4ba05662fb0c4580547e2a186928ea2f21e45f1e85b8fdc5a7799f835bc466a05f6e08cd625419da53b898469191e9747615d0d291adc2eef61fafedc7b1a80432ec28cd0c95f9ac4dc2d1e3642af15f77223ba7fef270ce067f1ca1d64f0d79b7d20513b4e9a7d7696d7822db05cac3ec4ecfb38b6edb9be2676f5d4e4646687eab7cf3fe755e82658c2bdb742e35fc3b22f5ae23ee7fd62ccbcda31f218d8a37b930c938918d10990a2fe3b3f65481f8d206985372a19176cbd2d8b2be51969234067f741b2466f55c80ff68fef64ba814f54e65298d7668f440ecbd1feffe4e4fc5865bec8ca4280c7679a479aa99edf13174362c71f9575fa0ca18cf6575f1ba307d21d213019c5d9466a1d27be52ef727e83da0d8f2e3109d5396bbb84061ae12b519b0ed197612003e9da26617fe56fb53a1aef18a00eb8b8f1063246083a9e205b8458ee81699f533e6e5b11c6b47cef182edc960b458bb8c85d3bc1de2cf4b10ee364551c7e18ed422554a7b593e47fc52cc347246afa4dc4c47ce4c0142824acc5701dc75c586c79902ee23599eb21feb85e54cdbad98002183dbc36c6e689b62f6ebe615ea3ae8b4f0b007a46d9075e64e042e9812efec96e80cdde66d156e7aba4a6b7eb8be93f3721e125d854bc65b26e9a6e4537e3451ee2a43b30795d47b4b70dbc0529851c8844de54574461f6b25c2b1bde8c2d9cc825f49f2afb7c04f04a536377482afc0ac943dae1571937058b16bc9dcdc5bdedd659dbd16b6ddd444a98e0f35c788bd4feb0eb7d248fcd7a0e13b55d56591210ebdeb99baaa3a00240bc7cc1a4fd6d0230f1ac3b09e8b6248c2c03aa69118751ac961988c61f2626dd648df124d7846d614295c517c7a10f674ecc12635ca556df75f58c799daca003c788f55291515df0377b2618004c663516716c8575ac90f67fbabb9ab543c5b73d8f04ae6d8894a622c2f3376201943508fe7de1b3818fe8fe0a06a8f3bc74d084f34552d4b1fd6a23616c6212f5cc8db65d93459e806f81bcc89c5fe9324a7048ae60328e1b416398a9310e24c29d6814d9b960c04fae678587861551061d6ae87191ac8f2be7b97a0da96d5fa715eba328c215e80a56817c16eef20249891395491f0548c346bc27d9b34b7d7951b86264cf29351d2b3e2b9fccd67c8a273824b73986cb4aa85efdc8d3aaee496f84c4cd0761cf903519a6632631b19382c319a8433df9c210d37871766c9029a96f307ab122378085f636d5c3081eef730d015a6077e64b1171f06923ec8ccc7d9f4ec33e546da8230661f8059a18e3d92fc229117d3cb8f8544b6acfb86d90b68d84fb6b5fa7d8af0dc2c6e0279a7c40ce6abad016957dc449d864794f8a275128ee0d67031366211270047e8ad4e0b265cf7e23e9c1bbb4afed5f61a9abfa610b9d2184f2e08ce8f0317e351875a1320d87e94c2e23568980950377afd234dccb89224d82036365eacac496af83d57177541ce7202c34c3c22780627946d93753bd0ae6517c9433f940fb674a3c1931febfcd2eb425fdc93a904134018d170223323d4da034f36034eb300ee9b18210145c26959aca210e61026e17272e11b32a37fb072a46657cdc222182d778fb85c406a0ff025099b9cef3dc3577cf8d4f082737d0c2b0e6f52ba1823b143248e606819a87f6c26b2b8a8c0df53b1ffde8986b6b95b74599bc1db69a650971ee881a7ddc3af04ef8547a3f547ea0b7d1fee74163f6d8ca603cac4de90701695b3f3997fa3696e7fed4e61e7361741286269ae8108c419573e114f905b234ef84cc1f211cd70db2d5c0cf5d887d45b1d959836e54ca3a598901e0c2930d03afffb8b1c02a7ddd4a5f0875c41054754734d079f859d90642df1d7896aa7007bfb0d59be73c4c843e10ac4ffecfd2c6b6ced7d461a8e2a425f3ef112d802b8256414e6645a7cb38f21fea75e07067f3afae129b79086a9aa3e362e82b6cdd9ee7d44a66bf1fec6aad53f26c938899558c1ddb7ca0217d288c2ad79e7648241fe65d3e84475000f91422824113de37309b2d24d84552fd2056517e4acea7207e4336af696dd9cad2ebdc27405386186bb2c48295897263e6a8905c462e5479d605b6f6dc563cb08c68080c0c1f5575d7d2e4ed0636a309fefa40b5460ff38cabe144a98882eff7f166f9f388624edb4b70e63e1a75fa70138d6790cef4a64584b7fd6e5692441f8abcb9c849da156d6e7221ab2c68c900643ac1e25305500debb14a66bffa3d4cf029884b547ccbd86bb659d832ae3bcd0302ae4468855cceeefd5318faa5bf884cedd6d7bef77a6942b62d0d00faf60c3950e4a5a78d502d45577288ffcffa5bf6f1f17009757a3f845ab5dfc308581676fc2c5904c1a37958c52b7b3308866f2130949ccf0b1fe79348bfa5d160992f0fb4ced57f3bd9d7b0a2640a69da77dbf48369a933b25679ba2f769553f3f2e0faf8820626f350d161fcb0ff73c0af0b63dd239fb9e0a47a82d192fca36eb2de79549b008bac6e82f377392aa4d968ecaafcc37dc8a20d1ec0461b633a084ea5bb5dc755fd6fc1e8492b28c2934d962f42e7f631a049ef80320013a193ba06ba47485b8d2073270197d3ef45ac16ecb70cc5dd0b41bfd6dd428e47ebc3f5efaea7e8d13b3f36aad4285c0a4c4713929087061eb7fb67b5a725ec2b050ea285b0de63c95950d63e3e4c3955cd302989b2754931bff61f60c6910047498820d2a9ecf6293341c56c6fd9a7f6da7874f8d3f45992c2e08dd49db13c3cc5e07355243cc7ab45df413ed3cdb9ab3a614f4e78080d5761f8769a327ed75541dc913cd602d68da41471e6c7fdaec57bc4ae386d6a5656f613010740d45d1dcb0fdba8a84a7752f8e088afeb873eb064171771156ebf46bafc687c314a8fdb7f99199aecad72d9c6893c7a658f93edcc5094db650361b1d331a3a6e975e98d3fff462feb99cf279c9308b084701f5b2e4616d1053379b5bdb7020359bb336cb0be5dfddd7c5313c7222ef521e5731907034e00a742939a236a0ab596a7ccce7a299374adf56d697df2d2d92d0a7ecb923004cca25e193f1e992b4edde5218a11a563d340e2e5e4110ca64a244f42db726b5427f50066b4b3220621e44dce768b1732e58da32324c8aebd7fba35c63f79343801dab00bce83555194fa3289e6f7d0de0cbc71330049173c4d9f1690707e22f8627b0f54b6762a7e98ee6f0c18cdfc0d00f3f50d5dd2242e26f051f0fd84e3acf9a378f1c735062440bb064399f04580e20789077b71ea0b28e3234e92970dc0f91f2e44a058fea95d1e9e0f297a53f086380ae411b1157db24b7926374e1a77d02a88cfbdf440d2cac831638ced79ebbff9f475b591f9a58f750ec4d23d61c4dd7063edafc1c6e8c3e28ba63d0723d612d0a3b2ed9f6092b8cdbeecbd014ed3c137734a1d1557c5542ce30bf56855f218aa86f79b5d30e8b801492a44ee6186d9620a186dafa6fa288d58cf846a3a29bbbb6780c4e6216f5a6ea66e11af8e22aff67ad1aeed2148c0ed3093fde3c3155a7abd5098795068384d9ebcba10f2c448892af28b83ec4fa444a6adaccb05044c7cec75f3dcbbb97a9d48e5e43b5ac3d26e652746397b7c21735b094655eb5f88817febd8528e8dbae173984c9a1810ed7dec20d251e74cd799054a31414192ad6883d92bab50dbbecb9439f5b89bee3a953ed5673efcd66b5b29baea5d070fb37a8b157882822590fb0ab5915f97d4b4d93e789f991e44ab5fc700ca9a1a0fa83e0d94a97eac1901eec2ea106ea401e74eb9f6909bc92073b7ea640c00557e9d99026f4e9474c29a0a502c49062bb197fdf2bd5ec8ec2fc001e1b14d0aed99891db3ec9e699818","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
