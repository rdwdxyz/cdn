<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbcee1b2535261079be96b5ecf25bfb70deb93307528619b0f3f48c815163fb6cff391c092f8976cf8808be610887f3da8318f1d47b4868e54656708747668077c0acce4d088682735334f1820e4e9f5405e330f303313839f3827cd7c4771576abd962a1dcfbddc10a17836b10eeadf1cd74ffa65dbe4dd1077f75ec6df92c485b531dfb4740d2ec2e168f202d00d72d8c8fa655614e70752374fd1b63afa07deebc0f5f3e7a73174f8a976620e6aaff56f6c118dac18418606172dcf8c1941a804e0a6c773134cada289aee24bbec8fd38c96364c95d99b004811e2ec8b0a544175799c7dd0d2748cef04bbe88d3b88060452801e65c153ba037583f8f2f0b8491c4014f83e3853bfed32861284920a9e5664374b19e864f864894ec54ab457a7eccfe7ed6684d038d03615669c4ed334df398f8f8133bd5d5d5f3c9cdefcf9d471bfd86f2e51b7e64a2cefe82c8ffe3b426818ed20dccf810ae8f19569ace53659547f076c5dae4adcdca589f3cf751c8af982b8bf6f8dd9e4ce49be4d53001894742150de67a04b1202be4fd013db6f385a5925a12318d2f4fab454f431207bd83ee122b9bcbfd84acc504fb58247ab907c76d358d1b1271e9ff2d2f0f919f2d84993a24493b6286d9c5effac6f91ff380ba63469c4a073bbb4de1daffb7f6c1ef4112fb8485f5146c45c92b5b143e7433ea28ff275954bf36e1ab56c1455a1673d71d6d1b442bf0a89665cabff531be3452998a044dabfee48f527cd78b7fda338cf6941b212448461c337bfa4420e7cb66c1e249267979916b162914f214d96fdae93b54e9f3ce64075490b187f838327fdd0b405a1908a5581ca7176cd2c5b0d5875753d794ed7def7a0b9a587dd7536a07e6c5b09ca66d0a8445d174675f416b8ccc142c419a934ecd2e5ad175cd4104a726b3b1bafa3a2f6fc54112ca41bf5ba42290834e99fea956547c2b2433891eeb2f49c13d3c63ae5866a5825e41a9d77fedc1d67b1757f2400effbe310caf830039f62005f3cc69474d38201fe07ebb1fab11d3b49f4636186cf8e9b3a2d95debe38ba24edd28173d2fbecd9a5fe05bf67e48861d79e1280da86ee3ab175d3e473a1a0d89e759aedb02a77962665529e8f164c2ed896b10fe4ddbc7a296c5ab54c849c078ac9decf742836ffe32e87cfa3b9873389d105dfd5705514490b2f3b589ee78d94be816aa02b6bb29bfa2f3d89f36f0422f633b336910197cfd1c21d714e99e67f5ec57bd7ae739bb869b0a17eaa3c54847c9bb9db4f6264d527048aff3a948def9a4a12f9e741d25230cedad53d770a8a4f84a346f403f59b735bef790cbf11e3d4160670a6175a1ed714465a62ff65c6b633909372aa020d88b05ecc751fc2f752d91a4ef8d43bbb3723e190294c281f83fb7db098e3eda271d147c01b53495ca9567d88bd89e04318a97001fe24c8e9cccaac0d707b64fa1a5b43d12ac9b9670280e05a6f9f831a5ad064af51785b14bec42739cc4845fc362d83d8880a14127315f1a6c7541d9ee71e6f1e40dcffec02b8cce4d68fa3bb080d24b01062d3cb9035af21f874961f807e82ee30ca2fe7ca48d9efc1aa7ba8bb904d527b0d8385648a671c0b59147d45d2e7f3424dad7d498c52c8b7c9b9ab9ea4207941afbca09ef91efb965d2e9437e11c8e8720661b69ab233995ba59de8b1938de880c4bc4a6de3c25c603fc4b0dd6e1c8bdd382c5a974dd558c467a8de93bc7db8844c8069dbbed7e0b6bf044b1506b016b12066cc8afbd64c1d95ffdf013fb9459e6eadac09ceb3e3bfb21ef3a3fe861df970625ec24d51c03ea6dbb7821f7c2480f7601bcf38095d40c22cabd05d02c7fc0737f919c91023c373b3ef0c9d0204c354e3cfc32d15f1f28c12308d0da110e0bd57c4464ed05bed72204583759668878b9d7f7d88071594f50d2d4c3404fead991c7c9c0ecd3583bf09bbed27029a521ae86155f49054a664ede1f171cb8e65323a3efa6912121d4274a62a0386e4a774fcede022772f0e2d147131fc39a9f01e8906b3641fa1ea6196ddbf451d090149d45b72ff1773baeb543b0c262de226c000f25c8ccb34d92cbac59c1f1e2121350afbcd1f4570f1313968aef9c05b65a08fae015a1998e8a8a79ae402bd2ce79c9e2edde7c1d3936098c976dc085447bb206a9ecdcd4cebea060b1947c477b882d8046119f3a29b799fb031b59971f0fe02863ca6c2226aa4c9c14af920264d97684ca9f87ee8d3178187e3fc56e6bc77b500075b99817f3b135e6dcd1edb9dc02bdfc2aedb5f0eb4802cc2fa3149ce7a0ae2ac2a8739036c56e62e97bf707a5f9a332a2d8cc7642b5364ec574ff11a4c89694bc4eb8bdc527dccab1968c45d23d7706eb3a72e87e373e07e2123d110c58d6b6fb6365c41bb32e1a750f74d04df04f1130be691b4eff47283facf5c25d844dbc955695d8fe6137671d31b6c21c38bf1fce09c521592d283d447ddb1d245dbd65321a39e8d7a531d4e8c09f5bd63e5e60830348e9078e49c1a34b322fed884350152b1c487a2be7a97afd83375c27b2f3280814c10f8976092f5853186f1ebb09a1db4ba14bc72f38702aaf03fc3b27ff7b025fba9011a2dfe102533d1c65cddb4cb069e4f759652a1f508065e8ccd75c6c393e07c4965d6a31ff1e8c7ac54c1f7aea6c30703c35ff2178e315801bac5821c7c40578eed9dab353fff95e507c06e7bc8dbcac25ad137389e90886c8129ded8bee96a427f3fc4ff269c75612050c7ef31c76c8daac153ff7dc8e1554fcd7cf609b987aa6517260f64bc19fd4dc7928b38ddd957bfa5392fc558555767b16ec0361fda5ee7404762106eb09a74a9195d7881bb08a4f5bce3df25bb803b34a7129d651ab543b018e7a9f939400a6de47c9754896759e9d1ed29fbcedca852d41663d25840a00e5196691b27eea96840b0de3cb2214435a6d2fa6c7c3b7a58a15199a0f2f98a34f5fbd74a2f15b2856885c61cf01538eddcb2a675dd8a9b5d3529dde9730ca35b0595c725da04ef5aa545b7d8e4fbb2da1e92c8a249b8bd8c7af8ad601b7e8897bd96fb714e4ac03d736713626a71aff7b70e21b16631de789a40fb6a5eccaa88efcc0127ca136daf74e8ec8e3b187473682f19f64a5c3b7d9dff8b6b6a52352c0eda265c7907eb37bd7c2bc18dedb4ae4114fe70ee86c2c0e328953fa8b2b9f9b80819f046c54b2df990983f1fcc805fda80b88a3c8d10761f262538aaa754f3ce966f144691627b2fd34b837ff202231bf4b8f27a378ae400f6dce1ec7ffc8028ee528dde97a92f1d8cb5cdb7c283d11426899d9a8901a0b9d18637ba6a4be92405b79b34c3c9d6bb973b449336e6265341afc951bb6fd36da6e6ef4974daaa82e04ba54a8c7b269d5f23e56b49aa336541c492756ae4374c57833ce018ec2ba321b14508674649da78fc276bc5e47429bc2a9dc3dd5fd15f3e3b67ecb11e4af1ce9a5bdc470cca95aadd8d5268d295f87816450237448d5faa1ca563dcadfe24fd5ee921304463a1e3af3b887d7e847c07155fd55e3cffe9188ef103a527f9f20707c2b774451e154ee492f4d1fa99a08d25bfff15e57df4e34cb8258f8c7bfb38fd96af7bb0bb7ce4e8c8d17527accd1f020d1a1019517a489699c0fa33151e5bbd575561289daf848690764d85591607ad6ddb6ff13dec54616eed5da20ade20ea169e78cb785d1e00af9a140be7316d024b9c17debfc0e55ea966bbe96afad16237cded5aca2d75091c180a486bfce268f3f39a58d2a523ca3e57086f7c04a52d10e7aa8b0257334f7b06a4f221dbf00c3bd3e9a2519b63b5533a392c1ba509485e9827ff9aec153d1e370a78d3fa27b069b7e84ea7f924d70f2b323729966f8c34b0d0689cc7caa15ea851a0f305b8a98d767e55cda2d285d76d064cfb11ad5141dff0de0d6fa81a9d9d9d3e7bc883a273189149d584c5f32e2b7f8931df771280bfb73a5f5a2f2b4b511b4e7512c217a78f0acbe894bf35d0f897989420177f346ade7ad440c0f27aa05fde7476aa48a34eba54c91ab033afda3826656f1e7f8a320e96f21065b4c37b9e95d4ddddb8ab04369cfc02cefc6f88ce4a8472ffbd264ee9693fa6a92065983d50582993aa4b4b3c9c4b995ba9c9d7c47515b6fca5b61075789f7829e197dd5e6d61999b1b3954c7ecd311dca2d9bebedbd6031d242a4416754ecf5732f97c87383ee08e0ac34c4a9da16fb68122154c7d05b58d14776d132566b427c98bf1d9748a5496adfd176fc7375f56c8b0dca8e90dbcc82d93853ac7597303c04867677549ed297a9b42a168e857f73968d6d1e91d2d2f447031fe258fb3fd759317faf028be984835743073c2c4af73bcd6998d8ad40c04586661f7e2fa8e17ed6ff8951b3b8bb82f66cda9e5ed5a07a97ecd6edf2e13f4829c4ac4517bd51cb899c3af04bcfcae97253a5486eee9a0bd7401c4a283ae5aaf0241b68cd7e7383a093ce2ca6978a5baf3b6903e9d2cb2c55028e377bbafc9e674b064440d62e0add2cdd442cc1fbe15263c0c8ac01848e76e8d67786575bc683ac5dce147f16e0dd693bef880c94b056a82653d79062c10a89ccd799d52e6fe9e9100378c09c25131162999c1178a71031af388ae7dbc9717f268447fac9cf77eec5b74e8290f2318ba65794941cbd31882948383bda6d99f03ae8a304d8077de4c8d65a0cb940922b3305c7d4f75b22921a4f966c33fe25900e9db09cbd7700a52e798bc681e6be8a7da2f1dbcd11a43bb20643ef3ba3f36819021b724665727288658b9c3418e12ad06d038a36deeb8699b860bd2cd976b1c1be04043cac291b3544268e7747292cf70f700bf077b6b929cf1424d2f0833fba26aa380cd42b7a451eebb84f66fa28153897d9ed0f175771535c07a43e25f2a0d8166750a993560decac189b2e58ca7663f7952b897f573568ca52d94f838e41b8f4fd1a6112a1fab38770c9ef9bd2acfee34cfef9a780bb5e32b065c8f0a75050ccba742f6c5c5774dc9f13771a4e449686ab88271d89138f28f1053b141ec2cdba2781fa19ef911b7939b3c5b7e1adf0bc123bd838028cf996f11cbabb330ee42f7e730a1f176cf834c418c6708a2fca85de9d3100489801e195653b309bf0f0ff78cabfa879d392bdcf1a5d49b4f1e2e1417d711f8daca68e2d7c2399d3e4d175c40bf7a80c2bd0bb2e4e5e1a8a2dcc8dda1ca1ceb8d4efa34294f9815aae1fcc9e65cff142ca156683fe041ac7a7f3505ad6721a715b74c62643717ae6d4fe28ba033ca9d723af813a9fc8aec14b8d880cb6f6fe042dcc91aff733efaae9aa6a2846bb93e6c549643922c5d30c813bcbb7666225656b57a33be5d685417338067efee0f846617ccf58f84413c6854d06e068a48ec0d70e5b219c4fa6736b553f7805a32e4fd709397feaf88ae15d58e5fdd31142b463e1b4f3809c3c21f08af551a7c550ac27373c7cd1a9a4fa1f1d1d720adbc42cb60fe5f4f349e4224d8834f04c015103cbe1b774fb434220a4599cf377ff1610b18d650eea1b9b69dedc8a4dadf342b030822001fad17823fe2929ef55e9a78df2ae385b6da4fd73e515775eb10f5622f45681ac29b580b4ad924d4368984423f3361c2f64a290814d0d08c36fa255a70adf33e66eeb810ed942864eee036b4eb8889e4dfcceb25a9db30bdfe795147aa7e9b930873a0eba0c8931b6c8526ca9bf1ca11688569d14d932af1b35461783e3b332ae734b39d5618ee7ff9d631db14afbd58d3b603c4791336f20d8fd1c55ac057255d842c3bf5f2f5ca40fde61cd72cbf5b93788a84f5817d0b78b6fa982dbb7e8a556a0ee8d6851655cd9a27960d3b79dfbeabb2f51b1bd710635f47e97cbf550ff4461940258811959e6a8d4262575dc001cb72da699492ba708c4b70f32fb6fc1dca87c8890fc1cfa6a0bbff5bae7ceac27905d5d0e973bd21107702a034674f6d1f4f011a874d0a9bd453db1e8f32d628b2f07e7a7e933eba4e303669c620fce78bc8cd49f01d06ce6e3426085b9a2d2e997a6a0f881052d6f5346522b5c1ff275a5abf201db546b5bd050363bc9036aad1c3f6fd12201e44e52446ab2681e5e8ede4a115949fe2aa3767414d5533fa84fc0b1a1c6e56a4a27d345dbbecde1e30ad332f29ee5140c5a0737a7bda46f9d752c9b18eb983108221a5a2f63fbc08eaea967661a4798cfda066872ecf70432b6e0352d59c0633f55a14d6832f59a476612f9f244090da4fb6e890067fccb45425b6e2d5f1c70026e2aa927c8bec070ae21a783583eb70c2eca1cc657543270f7e0b4b527ab64113d05d5f9aec5a7d5c2d32bc368cc5f2e01ce720de2b65e91218d61505198711ec680bb292b52438d48e380f9a6421defc27f49b97837f3c76e32a28ed0f0e00264109a344f99eac37d12dd714fb4c7c32837b2cf64a5c47067454cd25ff8bb078dfeeb1c36e8a4efb9ab43a6c82d662c18fda438c5413a5e0f31dcd2d1e20cf4340cd407ab5ab54e1b1801c2483f9e0d196fe929164aa25860c227d7a46c71307c9477b0b0c6993f952a6640bfb9d22060b1c2ae2e8d6b0091dd32a513a767626b9427a85f51420cb8e9cb2d354228345da20662f512aaf97b90fac20320cb68ce41b925e368dd7937fca686226f99a0b4371412ebaa1621029c14375244de196d2020843f781e2cf54c4da0d66cf73b40af14313236d475378e706c5cdf0676009de6ffaec1fe8988f26936352301a4a2a81f4dc5fae5475e954a1683a263574c5af8675656f727ce9f942e7d84fd99c9e0af81100b88defa11495647280c5bc4c3e3b22860ee6ac0d0d3fe63b4e7a9c05e07791a430d6946b0f00f960a47a675555748853acf554cb01b215dc202c5b3d4867c57b73ad3524876614fadf4ddb43b69cbf7d7f38c965ae44fbc7a5816a37da0a5a3a98a2c77ce13978056fcbaf71176e4eef8e1b428d60b1eca3f109f24fc668e61b09c7dec83b53688e1b58ab01f3fe93b46295375fca7f9480d409957d4706a7784d166f73c9e1bdbb8aca60e3451bc9bb72e6ab415b7b87e0b5c70379e61354efacc9991fb5c518837d58602cf2dc381b65d1738a52cdc384996bf0f4a7b370c3fd7e425ea05c3f369cf9131ae7f902d9cd56e484af6a8ab18b5df5757cf619f96e34eaba82f755976a2c29f90a7b7dda169e16262a3a459b628a68783b7db22660830d3708cac8e53e31d2deb968de5e9cb987c70a60d61af9a7fcd637d2b929c5f3328cf8d3c8d1cafb152659a4d591d594e16b09cb2e2abfd5b63859e408afbc1eceb85c1e0cd9b42c42dce9227d718c6b3220a64fce475bf206cc774cf4c2fb4ccce5fc0b92ee4e05731c1efa58c685f8d70a1884083a9f1c1fb98d5dcdd8d718904d77d5f9b98142cf297ac643da87b0d6e97bd34bb9e837a61f15519e826ea2d7fb01c1139101a09ae331eabde430ff653c442b9684bcce81b9924268e54b1925cd3dc836f58a42a88244b431c6a0fca1ff1624ceb87a6b25ea81caf27582814e572c6cb7138e10134ed04e3536ffe14438629bd379b6ea67857504f536ac6d571c69d915e5b657e34104844126f16f55bb5adf9f3d883b05620b20e4244c264d4fd75c2bef45fc4be89dc326eba901ac1aad8117a4a04e240abe607247752ccf2ebd0e7162cb52b48d5d7a2c361e895e3eb3a567779650d84c9953e2506eed7562f5d7348f57a50d0f51c997533e0e76d10eeee6bda096dc0df6c3ebc5137ff3d4576d914f301c3e5f74d2612d2dab0654ef89d7a2bd1aded03a828c8c47e841cb10704ba65595e475f6fae64a647f916a317a9daf5cdaf1afea895fea111936cc8bdccb926e52acbeb82931287e9c88f809731514c6b5a2abeee3561aafe147c97f18a7bde44a5330c82921a83b7b67c1b2a7badbbb02bb64ac1fb72e34611200459142be92ae3732c91aa8382ded7eba4ed6c9f3c3c8d9706fe713282ec8097532a10f151fd4f3f8c8eeefbb0846cf42d51ad7c337ae78f55d83655609fbd279ccf97aca2cb45df5d7bb99b37c2337c4fd255b28c611e97214d024ac2ad9cc0c1f9d1684a492ef42ae40033d97dc1f0c6fdc8ae844779bd670350eef319fb02ef43b29e18301ee76cff980e5dc04e9441725d3c0d8b75b679311756ae639dd4aca0e753b60ce238a8392de2d51b65f1514ff98bf45b7b120787cedc35ceb5c050afad9f7cd49ff99ee4e267e2b4fc2c2ee9129bc63465dcd1b8704f447dc796a693b88a4226e4e3a524a310ee79f5bd29930a0d1cc5269d28726e569d569ed2e1507d0d81aa1dbcd96a31c33e6f2e4fd013afd5b1efe9a843d2e4160c5c137d89b2609c7a4ea0188ba68af0806d2802d5ccd8cba96f930f4b65b06d9d41f71c42750583470071da85d14d413e8ad4f4c8f33927c7f9e5a5afa19f4a68a290c99acc94ea3f4f88fff66c2b80fdfca8f3c2513fee809e7f421ca0c992f5136b754585b12bd726b071ee49c0e5dd3e378eb577d4bdcc53aee38a8956ade0c4254118184d10b2ac03c59aa658327a2fd7d55203006dcfabb31c140523607c83a97c12c9bfa4b5492094c4c7406a2832ea68a43c89e926b779fa6863ecc449000fd52054e2841d82329def33daa10a9212746b77e5c1a0cc94324b244fdd100141a0091aac2cc54c4b4e71e21567042c1562b62d3907b50cb3c12625a64715a39b4315ddca5e61ad927055cc1c1c0a1247b5ade6e7b290ea2110e4ef9d6b80710501fb60bac6f1ab01dcba189e0c53209cdfd0bb01da6448b0be2743c11cc509189c1c492c7ad27a337bad2a90d0ec14c850729fb0bcceb09571560c02c9676641849c554af03adf94bf7ca546f04dc115bbceed10b0c2645097f4725efdaca3771363baf9bebe31e9b776339df87ed20458204d1a12fb2f7ba92255964ada83e8ed1046509dcc97e8b8a33b389f54f43593ae6e83404e02ac7a66befb4768a33106936f8874d6934a5c81e8f6042a8ef6a4d38c195eb04510cfaf1efd43418c371e93d4830b9db622446702120227d6eb21787d7421be6d01d142a7df744e6e906651448b5c2fc6fc842c863acc56714f7ebab04768596917968736493395f0746a49e6f9fb62c2fb3a7caa1e20ea6ee3b210c47522dfc35d34cf94795dbaa8e39e4a9a1eb4ca8adc56e229223495a0769dc62987a9faef0379a1a19f5783d88a68f61debfd112b807a868e6ab637b40237820b00cde42cb1c76f613f3d6be9fc25fd4121e6ce9c0d82ca9bc613a3ab979c82fb5751aeccb7ed583043e18425f8b2f01c07fb614297d5fd147a9ea25b18e53d8cd87fb947f1a42856bf5c6e30bd746857fcbf7090efb302033694d7388ffb7b9a5340659c3b92bffe210891d4c3ffbb5fdade368ba1e9f38cd6d05ab4410e5f4b27debfcdf85d5db7a2b781653194da35392c432cf43095cfb4578eebf84315c15781d64587b11bf44416368e46f280017e6629f87ea8dc55415819a942be1597f9e668d79547c6ec7ac4c6d63c0e4f41dc341d504fb94470b5b2b53eb2095f4f15be70aff24929fd662232d0b1e4f2d01d53c007947476be04142b6973f312ba361b01877f8111b51130c3883ec750cc6a85931f809e89314000cecc70e1a2b08c83f008f66c91a262be77ddaadf73118a92f1485341fef2d97b21d2630fa0895c082b6204849cfa630a2d0e6ce1d66f4fb8e883766ed38796dc97ae442edbc270fac7e34ec450ec156b32841c230d8ec7456b22e2d3a30a8034ea8467ca5a896ca963cb71a287ca3915942db5464f5d16949905e9e6c73c3d22d2a0e4cd7df2442a0034e754b888162149173e35cff36db72fe33a3a2e25ee5905d622f47671ff9d17a64d4872e2ed226a40d545c4c22e4b184f2ce0746b7e4979a91894493c8ba77a470ae3b34bf08c6af286c050b1d054ae212f9f2b98a5183b1045e6a6edc7fea9fcbde4929e1dcb402d39b45151c0ef94ab9a42a81654af4dd22ac2ac064d93b4a3f80b3455d44efb23919553a975e1e1f55f95b8d36c72aead044b0e349a39b45dbdb9e64c99e6640244ceb2fe38244d0250bb261c3e28fece6d1964df1f07c242bb28c06f8c176720e7e1dff808f2e7c9981f68c1540da8cfc7607c9692408a47ef5d57c95d4c9a8d0d1d4f854cc5715e681e1c8ae8af418ed230ec2a5eab32a8b6fe9f3e2cb28401c4a0043aad6998aae2bb0ba917f579c3f9a3e82e7df3f8b6a400c50d0563e2cef60a01a0fbdb5c63723f22c9bde36853313151fdea62f377862ab22fc2281dcec855fff3f7a2ca14bd0d0d0d5bdfa815b0f9352dd53d68f7a0c382a100fd1160d79115d9be1cbe2bd8836c34c4dc71a6a3aa9f9e1ca59d761d0a012d390c8cc6dddec2427993db67d2eae08964fc01e74d5b45ad9c6fdfa23fd89030c27b18342f1a493f123c8f1f7ef1f28891a4a2dc0be9bed8b4305aeec94ace2f1e53c814b67bf8ebf08bc17c5b65b98ed8c97579cbda7285f75c40bd54106b810219f371daa89125b070b3deda3799190bfde37b236d1d5536f6ecd0847aa647c406636345be6389d678d6ba3c916096a192fa8df34b04914cb4ce675b86d363f4c86a84c6a191b6c59a099ef7febb19bc40592b2bc71cbb058e9bd4793c6fdeec1c21eebcdc08bcd243ff179666a852bb918d055222f0ed61f22454d6affdcd3a480f4a54385876c249c20410b928a3b4b2ae162722defe87a2a0e5078dd9fd782f0e6fe4c60b4319e3a353054c4bd331e233dc6736665fc9f30c7f4ce8feeb664281642626daa0caaa2d3031cf65effb8d846fad2b7081e119e715bab7ba7197c16bd6248ac0e1c48e1c6364ce1694d0a930f9831a8f5ba667e5ec0ce6b68a10af861bf5161f3d58e576a11cfbdba334ea4e653c5e903df4612242760686cfbc1c399c904ceea3524543568f1fb019513a5df4360bb2e945c35cd42c06051877887c491b9c639fda6fb94bda86708ed459238202d68c43b096e8f5046d741771e870991fc6498dadf1ce5df7c6b6cf3aa5a208f59c34b8e72205c2b80e9b30d8afd299c9ba71bb964e1af2e4d56a811908630c0793526c974297a2ed9d79058c538e0c530ce1655ed3c11fec95dc7fa1681aca43bb4d6ccd60167411bf1dcb231725d5f4928ba8db6a1860c8f31f2cec0f67508b4a28b8aee6b6018cdf130e2281570eeebe7126e0c927ef72fbac5887467d5c6080f88e2012116d567d5ac076ca51454adc2935cb51faefc08eba4362eb5c20a375cd5f13c8773383301adad9ed43dbc60d60bf517d395d85b85a62769849340b295eed9b7baf3f91e19e409e4a779649c145fa89c6112c82f0c38be46db09aa76a6b641e6e6fe04ece44efff88dc8ea1e7f6ec0096f33bc95903d98e36af90246b359626aa46d0bcb7fd03022b6b6c08ddaa8686cf053ea727e49c92c070c5140aa813b8255ae48129ee3bd9498c44bc9ce24c9531352313c66a99f9989c6a8b5a3ba679b58ef72fbcf84b5491ed43294e5b5c28970da619d82c6ef89c01a9ea510e14df2ba3c67b79c284ab2d040f60453934c7ab334758b741db60e1f7c2b3ef2714d2a9c01b0ede807c999b30c3e1a3dd06bafb2b38b75cdf0730ec88c0984076fd1878653e12d4e5d166ccbec32d2af38d7f9be3d2cb4d8c84c8c8b11a95b17a98b5d4bcc5fe781aba33c92428662f26afad873e5992671df388481c976c874f058f2e1f52bf9512616d94680bf92213947cb84fca635a00da6c9bc1572afb135ffb06fc1d4de2d45b2e259e694c3cf624069e4767ed8847408ff546bce42ee48dde1ed7e16ef446587e79b74652f9c06eebe8221492f93dd6955d860f35b526eb5b38106bab1f2726ce01e2551c8c97fef045121c385b25d705b09e175881b386eb824992df3557aaa6ac205ba63e0fb86e1d88af0a69f1259a043d080bd9acb622b9034350402cf385d5a52c854d23a13f2189ef330feae601e8ee063051876fdb71359da3603c04d0f1012881923d3c673378677c64301bf69b70fc769a92ada6979fc4d0d3a6ad36342f16566fa7ceb224165543ee3ef3c75b41c21cffa06a10aaa45a0fda1b8ad9da76929b2bac9de338378f0f381a33e42add46bc6db27c715a868d5fe0b2f614d895da9f4ded3b407a7adec55dac6bb0cc32178307a6cdfd4103419d195f73ef951b09fac0cdb97bde3863194e0096df4730d6dfb30bd1321cbb4ae92bbaf96593a7dce250f28b56edd0ebce6b25f134ab5b9a76a0e5a2d352e8e299c683f6b2727852bcdddd3dfee94af0dd83d0d67e38218ee2e8d4dc9f167d4538c3d16005f13dd2f556ffebf12f70cd43152a790f51e346ecc6be0964184435050e65ff753127d15d9695b9a8b7739bd0b016a92811489ef31bb641cac07aa14285fef4bc04cb3792607f81cc7e6611ebddf7f0a1f9680ea26667c73d3d4621ac9f279507f94f6c32deccef53e71ac1cc7bc435d40689bfc509e2ac641303b05e0a0c29ee0ecb42f728e140dd53012b11e951134e684376188753d1c9ecf2ff9b8b75139397ab3aa147c3ac0813a5ae6b128bdc2d9e9f6244e7931b2574486250bd01f29708869d073d86c29fe0b0b3735e15bb21a67ae2043401aa1a7e17fb5ef7572abdbf379490a5a664a381489d82801ef4c5024c1d693156a88e27857ac08e30d0d5397716c7844e967a5b1c3012243d8c4105355c7edcec887c6a442619da698b8a792f3049f0d5448e0840bbdd0338dc058060ca2e08422490502a3728a17a5d71e4ede74b78d5b50b6352150125e5507c03667edbe3fd1ed1fa83a6cab8be2b9416b48820a545c25b0ce3b86ac2d01035c3a20625ccbbd84629f5e89669d4bf591ded49a111e7da366bf135c2d81d47a5f2024f8ecebdbd84ebf018d3117468808ec142948e981b6523b43ac183a9c46666192f0348720de7814200b279f0c5574fbae5bda2d203236fc89433944dacce12be6d5b1d27c2406ac71d78da36eb2379b0b1f6a8bbf45bb40e3929b9a2f3d4443d25d50da862e494ff90a9eb29aa78655767748b7bbe7aae570d07bedd7d6f01dc7d3ebefd524e0f4ef84eb1c3cd644c916e4c7feaa561489673a81b6f7e3ace22ea029627d1d54aa5df1d8e39c9855e19ab8f08a9ba3574afacdc7fcee27cc997a9d3ec0a81d1b5dfd52e26d501829f062407f33c145d6fb452d483761e2e46d37d075801e9dd5e52fb138a4f7a1b4b6cd96737ce06d08300899a4c383c3a2f75a7665535b7171f5fb4818f178a79619e93ea77f683e013dee24d32f59f2b849047b90a6f9f831784fd28de410ddf159202bf6d5f399a4857ac6cfac3dece562a53cc2af857baf10aa9c1754e3302b00a7782cea530bdaa8682a868d6977dfa61fd229416b69a13c78184f3045b3978bb56bacf6af0cc6d99bfb55576dbb704d9edaad917c0a811088a2672992b305c177600f8442d5d195485b1ca230213bbd51d647cb2d81c485d05ce384dff4c317152226a453f521e14fdbc7afb2291866a263934e54adb80ff53f90267cc61f81c09070a10b752fa2a8f202a7a8f7dc99b262c777b560a8f25bb0ba51e167a5c58f7b03428c6ef5d7763c0d9c680c489b7ece7958531bf3d2986758a8f76d697d54928d7b00bef2b385fcac9773d1c64f4d7bbbedeb9952407221ac5af7f25e7966290050670190db903349767b87f5103d614829ba59fb15e0a3d5a96a4ab97c702fd31d016c6aa6c1c00239770b154fc8e104c4274f1e460de3cccde867722bb5a35ab41c648c686f9473a1d8d1014b238d61affef8264e04c126a82851fb5384839920c7196d7ca7bcd3b0cb45c515764f17f5a8f5ebce8b2f7e4a391b47f455b167a0d27888b74f8e03d5a8fa84c4010451e7f42ab2e5329c29d13ff9f03b984e7d3fdae11bbd8f6d92efcb3680b3e3c6299ca474579b849c4420e8543e69b60114f26d999a8aedff204bb9b18669814cad500a457b8edd04746f97ec576fd1cd64ab92a5c268f7b1029924c52db64c97f8d4516cce3867ba3e21ede4656b47476bee7d383fb8ba065faa10eaf266a6c13f3fde9880dd3de569bdbb2e1ead80c469b45a66519ebb1c7f25759880c12aa05710ec3d701e456bc6399441d04ad9e6f791e1bbe959a801a14eaf7d04e2c237431c38194bbf577824a498c4fcaef42663e65caa7265b5e3eb339db0a20674720c2d7d9ef43909a758c2fb21337f8b45a41aad894e003a008da941c8b369f74ae2d429f1dec61d648895ea96d9d4a9d89a557c94b42963956cc180d2e3b3a4a9330d53150f77c3a2ffcd4f0b0b0d32a41b8d1a9141c304e803713805b90f044749b628bb399d6d2ae62ed858cdd5646720aafffbba28fe18341ee2ffabb48b98b056aa7441e6e09a0653d3e870fd8d2631aff794b8f0ee2cbc1225d9bc4f1152e55fcde662a82db049655d3dea935a28b7f05825c56ad279a70817a183464f67fec15316993d6108cfb1f7510f7bf61fad808a5d701d4b545bd140cff32ae58aaee5126da6bc669a1914f105770d4aecfd2c81bdb22f42ffa59551735ffd4eeb99221fe06908c34a7c2a40854fbf3d9cc5d3339793fb51002b2003cc13e84c1e202168c76aa371cce55264bb4963eb3607a11ed866d6f9bd5823c865995b0b29d787788378cb30fef47dcc8f3612a5a2ba6e14bb54650f3d837470744ceb45d2734d224f6709143531f20a78fa3f473f70e2a6477107abadd80ad56508a5d233aaa06490f1a8a35769587576dd08006596a69e3032f72446db0c7d30725d2a296126bf30e2e9c4f13b505185c8aaa65f4ece891ac41e199d5c12900a6c3a5d6c382637c391275e9dcd8b405423e63350c58654375a624176372ad115b3851dc716c6cfd19ea4bda5ca26fba2e4957eb6a18c330e28632fa0b2b18c674aed834f4cfb7851d50231f56ef0d648b159dfd04564f1418c4277425197fc0ca9e76b4f2199c541fcd10b00a1b8f697a21aa8c63a5cb530e36fb8b25e094bc316671641c5476b88426f0292ddf044bd14c03a6834a0619c25d7e221c9e5a15078757951ab468cc9bcba64cbf906fb1ea3b4d44a63c5dfbb3464c40b2baaeb4a1f29d9b0d215906e8a4110e1ac383c63e92e7aaa04b954cbc030ca2bdbf7ea7196c94e38ca742d286c37a68e04d2b2daf6db1680a04f9432880329c8b32bca7aaa78350b08df36e36c0e5d67a25d935fdae48b6d97ababb131be0df2eff55bbc719c995971485cc231e4f1bb92ecdefcd33d583b55c345c3816bdf629ba4029dc27af9b96fd7def14c4ac0540bb1193d898be52a4eafa51c6df8029aa0cef4341a727942da0191d0ca6ff59b2cf9b4dbcaad22ab2fc78352e290be1647910bbc15af5d3713d211930c883bc33e95062258236de20a8f01eafdd2b1b1092cf692356de19accf8c1eb3b2e13f4c8dc8e11f9599ae3e91008d577b0c7bd058139fedee8082f7c56b6d27dc41d82418fb4543e3d74e5ebe508970699b2b08d6597b3795bbbf5921439da0feb7f5e780d3363755ed97486bdb1670235df1eadc3775d8a77339fdc19fdc7788f0f85a4b30c689ba4fc77ab7f7a6d0d857499da16da1746c2664f3f9cb9b4642490de391a1ffd7b9bf5431f936fbd570117c2c7f28728964553cbf3c39b9ac4330a4f363c8d7389e326eed993db781857adedb8bca2f92346a7bc91537196b233ec43c75f3504ca630eaa8e24dbbb0d7522301b228fff71187ad02af7127d6217cff68c8694deaa031561ceec0cd9c67ca0c4fc7411d634f17d2901e289abd1f8e04c7cc4d4948607b516c7f25f4f1a4e342f2341a182ce0ce4ce5fdf94afd8710de0786ec0454e879decb6f32a98ac0210c966fb04a2aba88477680467dac72b487f84ecc4c1746961e294aa886dca75067e0b43c4616c8e087bfcb9b4971205237ecd23ad8187915123d13d203becf4734fb04f14857e50d175168559ce693e320221cf7420348e99e7014a027186dd3991e8d570f8953b62f84f3839eab6ed888868d178e63d3e679379555a7457d26dbbc98d5dc8d68623bfd8e4d068f93da74d783d5ea9a13d353aeeed8a9ff04be6765c1a6eaa7113b5a5f5974e8563bb5c76841b24bd6b10e2245be4d88af9b8054ff246085f721447c8404ec2bec44ce9fc3347ff3d7224840a7af13fa461a1872b11de5a4537ab5840babe4bad03bb240cbc3fbd2751de45b70034c35a36be3b89d2fb93e8507a41ce04c4d21ec9d07848e04927d79544db09510814256023d6871f07ce430a07b5e1015fe133678f2d1451068ca84b517838bac2fe8c79163ed6f5a6405cf36f51aea1236790b2daa2759a727e5f6a2da9116834b8721650acbe324ea6ef390968c5f429b3267d5c50701fe1a099442f1459399c60e1e636c4d8a2775892ad30850532b49286da6b7afba49034d5d6d160555fac8fc53c6177e69341dc7d2dec4d532b614eaee1db60b2a492010978e0625ddd6de3fa46b0774d504e5e1db2aaba2d1cb5a3cd17a5c710629bae1d065cd5d8992b26162da33e92a485b02c5b231048fd066059bd36487f3c8c71375f3c55a32db5fb1cd8c7478d7473e97f6a6981c7a51a5867b94cedd041e572ae8712daf9d06ea8fe9efdbadd17a14768f8f2e0689d37a5e8c15c5c991f7f597f3c1d2cadc2373b8d9469078e3d69f8ec9142aa93dbc46d1faa5ff1cd34c7ee9d2beb48c1d23423a3e795988ef07f8d56c73339da5cb519c96548bb68e1c0c2f50e40ee339f1cb3da4b19105dae0e41c8a98c9095cc9a3cbf90d3ae52df2ce1222b780f20e84791f8b7596708ca127cb3c9ca4a47e22619afbb17693a7a3b27a75731044e84811afa493fa74725c7257bc0a81a8a309a3dfba4cd230e8ee52a3755de94664d336cdf876b498d745c643862b2d1918c231bebee482cb9efa91cc8623260e092ee09a2bc88167bec6b800d8d31d96975b964ccd4881b8c5ff4e752773883cf0c898192a84f2be2fbbc5a1a581be43a61ef468f022f26a1fc5ab509c1ad88d51e0b83297b214c8de36fdae446a534c5713dd7b693601faea6d39b94a66f3923e98e0b317fb3c988049b3fe3289d83db52da05cebb769e7a02229caa634b350ef0bc175341b86b5707f59c3bdbdb456d07741b1e0d5c0cdd7e705b1148802229d925407989328b5669e323b946d3ff165ceaa58e590be46d4783c2861c2b5eb337f6a696bf305ba46f2fe0cb6ca1ee8a516de9699097c561eae8da7a3df62de29f6ca16a35c6d16ed1b8b1d36f64752816891b24a70324c826083baea90d8575d0f01a8c53066ef2cd5c15ce9acd5c8141321ee2f34ac80f956759d3e544fe79cf33e6bf6f819fc48416d85abba5d5736568e98f75f5f0b03539a96d2cea71233fda373e9ca29a66b1dd83a3e20802c9ce23d6f42874cbdc228c3fd1ecff2b8ff37b173146d0c6843b5a0daed4d6c9118c0dbf82bda12313b6f1410957c27c85f5804b39dc366bc2b6911274a55e9850dc29925a84ed4cd42c2f75fcde3a443e850be546fad9d961d131dfc41a8e83e745a06c0b78777002d8cb26d21a8ab7916c43466edf7913c7757f3f1843c5a76df7633eced6d719888598dedb0e2e90a07290f9c1e5b603518758a605d5cbcfa1440d3dcd54648c5ed0701f3a3912c2b625436485721db5d2e23cff7a8ed10ab73f127ff718805af972f674a91da6b4f89671ae6563cbdd1f680b52d5a1e644fba978aa084654b3e5cee88d653f114026ac3434533998ec5afddebee064b2d06b6a51d8d3c4a67f9d459f4e34d1bc0083ad0dcf033ab9a1847950b4e7626fd0242ab16472d09445906d1db510287f48640128a56a99467f959f436bb9042ceaeec609ca2f65cdaa96155049c8fc64ac2f068a086c5ac2d399b2c6a23b99ce5d87865fa456ee0442e8225876a09a56ca8a1eb188a4fee8c1507ab04c1359186e5f039d2fa687f3130517833433bac74ca4e79339a1c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
