<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34d6c6978b4bae5198bfa70eafe19a0a84072690e4d81731b93b467d693b420ab5cf77b684c3c8676c367f185c6b9404eda37729677637dd3f7a5eea9380ed02c32869a3ceea3afcd17ba5f83e158aac97a47296a3a3cc24fe3b2d78f98b2a3e73d722f71dd7773bc9254a6dc7bc18c45818bde7068c514d68c493239e410df0e8a436393cdbf254205ba97c9522a9dab57cbe4db6043127404ef8d9afa217a3bd6f8421d57800efe7acfd349942b62bbd785c743d9ff8f8f6b01810186f894b51dd57c8e6d57becd1df4815bebfffbb3d0d89586be5d557bfb0a176798dd386942090243ab7cbbe2b2a2a1c4f6ea38b66aa01a2f5bb1ad25e186d9483021e2432b37905a417f3eaa83fab049de08a6f2301e4dba71675e7634e6eb0569bfaec9ad620cf51c40c29408319ec27ea599d4e722adff83ad545c49a3ebba85e1db2c607a6151b3a3d12ad189dc3b1df99a8731e06f46a9aeff65bdf76c26ba3ce8d42bdc0eb26b4a3546d803ea72237f06ef45a3d16f6515e51e14e3a68b0f13fc6277cada70ae699ef924cfee9514f451944deff0e64f2bb7be246a3f986a264bad09119810ff3045007322080d402bd11ec841b16138f1337296d4f24e5914dbbbd9e5ad3af3849b5beda6e2385578e355e9e7d77b49c8600163bc54575729236f3ca8128a02f5ba8fec6fbe62c0f0c07fc07e3645b6410804d2e35d513b8703039ff78741a82e774692c8d8a772f3d917534de3db9f0fc61385e70a0cbf79bd1a2d35e447fc665b8e0f61d707dd6176913814ff4d5d56f2c05835ac28865a9df9e3ab35e736795f955c7ee6dfef8ee0c925b2586fe5da9c0a9f2c835d4fad8843a9392dbbb6bc9f594b60ba5edc1c825bd8cea53b42c9e1b8055fa248b5e00225d76b1c0be1e80bbc14b1b3f08ab49f82367d48191c057669ee6d6a968c9572410103f000febef8a1436dd9a02208e12806f575d9a1443827a1a29a23c3ee4c571e1b725705f1b1d92f7c1fac485a3af88e706c5905c84cf8a230095b2040a336b3e200335a9bcd89695bf93206cb0f04fbbcf42c85eafe3e9e61000f49b76ce40e3d0a75581444291736b42edfc5868e9f153095e849c075df5f57c0cca4414d472065d5b675d60c03a87bfe6b6cd0a5cf2af4ca984e595e68c444ce17836694d542c22f1e57f3be2399425cbeaddba30f4b2e53bf423ca8c8f2e7a51ec6cb92ba62204766ed4971d2f43b4d3a13ca8a61fcd8620f3376bc02101b53b304e9ec3aa95da2f363d14687d08de495bc5f0521c6d49486bf20d0bf6085fa2088c015e9bfc8fd1b744e6467201777f0166718ce1c8f86606fd6042586a44a28b385b1abca36c37a937e3555bb240bfa5acf606a420f1b755f007b88081d9fb0b4dcf9ce0ba6068076c3c2338ecb36d11106f0e0d684b343c5ee39c235e05d99cde0e526c5359e785434f74450b2f91622603e8f58a79f51224cb898996e4881d5f5232e406fa65c49dc5ae53a7340c16c41cf2ea86b158cd3179807310fc995907b850c0978fc3e25034c4ee9e3e4cd76fd29a2770e0a66d1569b053a701a9f003d4c12d15445d9bde212944ff2def3be3a3aaec44f6edfd9ec66e3006713cb9d1c7d51cf42e8c90ec8903bc41ba38509dedbf380c3a61168ade81b4fc3b8f3f3163b947b7a3e818ee7b01deba088014b8473e1fc26005144a29bc2a7f578026af6bb6fd5dea9b4db2ae6f547a661cf8b3ef2a64ff14a000e30cfef1d4fbcd8a757eff00886b107cded622819b6a4a2a75fdef5e1197a6d8e6f2d5fcb3421b22c87522edfe70c4a5551b792aeb06c789334ec2b6b93c5d0c14137268308bad788bf3bbb617f4a630611dd9f69d1fb1e7a47bec411c49db0c4884ed4d41ef951ac7708aef9f110351589e6e16dda83ad049b223e2882c21bafbbf07e39378353c808740949fccdd24003147b38031a5872acdc0e0cd29a8659142c976b31fd4f82e8cfb39f90ec3f981db02d0ef116d096ce98cfc4fae18d5bc1779245dafab8fa76fe25315ad7f89fc02e898795d7838b8329ae0dacfc89c2363a308356a5743c42b13bf993875d5d5ad1a3d81c131c7dd8b8a00b6930555463de157e227dc613e7a084bf47bf3ed8660b3067c46d637af0e69dc2107db41e1f0569d3192a83068a3ef2d25b881adb91e027cde6b0500433400ea6bc0f722cad47c08efc5afda9cbb0547b25fbd79af5a17e62acdc38d4da86f24cd0b3358da84c43e15a76c6d5051d6109bbf4335fdd07ea30ba87b2471105fc787113355efcbe74980e8e84d4aa0249a17b38a6fe1fd741694a65f53b521b4c57239b6c6782406e244b9ccaddfb5846738fd77f0db42f77d8f4f1ebc08ebccba5283f9e4fcafca8bbf38a3be4139853d39d66ed6239cba5c124515d1124cc2a763ee985176d9bc94a8afa8a7bebbcf75280eea2c467faad80fd3ff4ad543781ed5d49223d9d1f45ebdf0b1bb47aca2685efc9cbf291e53abe9b3fd4938cecfddfe9f7d53ab39fbf1e239a9c6ec983eb532f929a6ee759faa0d61337c6db5ebba9f7253878a8bf878d80c4690f89b49c76784f253dad2e3e2548c7e16f83afe4242f35fb11c555855dbaa0f0200fe37cc146aa0b6adb8eda4f45e98a7b928461220556d95b0cf480f0b3f93cacaedb3b40216e78a03c730ed62a871f2e3406e111ad5977f2b21e17dfd683f92f4164c0e06905af8211fb1b5df167437562126c47c651c65b85c9f48de9dc5f80a51aead0cf5d7576715f4cd5ee278de72fa69c974434a15c967dfa40a2001571fb645a1307439895d83d4e692006800afecd340da14bbe31cfb02c2cec94e81754830c313093864576bb46c42207b250c1e7a426bf4999c9dc9f904bce52a4db7b11dfafe3e8fac10f77dd6cc15501c6686c1d9e01cb9e5f168e9fbd75ea5aa2c74db9013c9c848dc6e3cd13a4187856173e4c9570ef0f4ed332b4319bd270968d745c439414ff9c3cbbf13ff381e5c633ae8e55fd954ea297fb097a00b718147537ecefc4884b6fc68ded0d35cd0b6a70ebe577d4fdf3fc712c6743e30211467d83af631ec85bd8e257b4633fbe4ce9f515aa38e149331f5e71e3159880349a44146bf35a6230469e4abb0aa1839f864583f5bb0466b97546d9d52e04ede36451b34ea7bd185549b63b479d76e92b29e4ebee667e57fcdaadb7cffbaea7c1afb431575918943a1ab08c9ac23c46cfca7ffbe9bef2a0d986768a8867f2d59bcc5519080125e28e6a26302d6d75705a699ef61223017270ed2b52d14c384483b46f96ddc0f0847a8490cb0a6216118efed313c7fdfed7013995b5a271f040d8a0878d469d22abc827b3a89f3b9ceeef7d74ddba43bc192187cf3852193ff8696ed22d07f271839dd06eafb71d6bcdc74282af1a35b4d3b9899ae8f5b0ac8160eea9a3748d0717e468cd3dfef40fcf069a0f4796f5fec8d37d478e2a7c5c1b1dfe0648f4ff59dea95cb79c15964bd015118daa0c4f373702bd19a3a5aff46c32f167a48415a11e4ea5963ab90853056562503724df5211ae0810cc9ac109eee8b9dfeafe30866b9ea99820c6fe59c27329c90651f1d5ebd4160a0ec844cf437f48db16e1bff86745bce553d130af33988d5ae8bed6f8eafffb30004607053431bcb2f4ebb89c2753b85b07e6ca11dd77c7571ffd654e1bef8b077cf0311de0c32a0184fb8879a0c7395b0c038cfb950333553bb5346a7319f5ee35064bf36a0e9849125a808d228a5c523f914ab3df9eca3fe51fe37934fa61342104e66cb1fc0a46c2544066f54d294ced9ae2815222ecbc0bf9d13ed147749f3c6aadad6e8e4731f815bffb1f0aef93e56ee3bd7d23c43275e97513b542aa47021f1835f59b3cf0f8dd1d7fb022f3c1a9c9fe9606544aff1a69679bd29390b0b6e7044bcfbaf7f57aeeeebeb51a98553745c5ca9c68a6475df5d33a5194b1355f0f826099fa5235614b8ece09d3a91c171e2a40035b975f941e43ed4fcd3a48b1ef19cbcf19fb398bd8b4d3731b57e7b5effd322008bd9f1ccd05b41f3f204d46bbe51bc17ea531829dd3aa7289b80aeb3de89e3df603f7eb69795ed449f8563ef1ffc340940f27677258e6c4373131463b72f21ea88dd3069631d58c1c7d104bbff7577ec93a708ad5ba2008f9b65224fae05cd2438c242a1f87765e46d4c2702ad6a931fd308c37cd6a9d4287b0365b65ad85115b5dcbb4992bb4aa9958eef9536ad988e996b0c9cc2aef3b2a31823df441ac02521fec4cface8075559af636d66e255fbd1a32eda02614696190e318067e1c25d6752a900a59482586f69c591eecc5b5952e8a81c62c8920a6e6e4b95c478007ec7bab0e2ed1e0f1cd5e75e45f56f4ff0135387b7de27f48fb26ece9ec8274ada6dfa054a7e2432db3d9c23636a085becdda4eb6ef83530a1b4310879ce96fd60e80d4abd3e2266d01198b7eb2652307b175072578e5e5f0a2c6177e532c15bd550b9b27992a65704de2144e63747ef2e644610500a9b8ccab92ee5625b39f24c58eedc9b118ba5d0d0b1ac93b6be078009e09a8bf4cf080227ca7ce7702749b687ca8fe3270277703664d678452101a9ec770abdb9cde33e731af0d660d4e101a063c5f6081c63f51115a2f944d812700378438250e2ca295afefa62222fd2152a72a868842e9a4af2d0ecb5b3db803eb6c66d917e4ab878174403c30d0f1110fa825fc41e276830e36c4f49cd2bfc9b6af1171e89ce8d8e30674f4600198deb827f474e4333d401ec4ce69b539858d679b941b67527d3c5295dcb7ea7ec3ef5e7ae5ab1fefc70ca0f128cc4a08b668cf720883cbe86db2ec4cc2dfd8676f5a76438c896a7533c054889d9e644c90a68a92f457899be0f0224961efedc8449e4d94afde908f7aa82e260381608b5d3f3247a161660fd01de29f1e62428c6bfe9d43aa409c2a00e4499ca94b79656cc9163b8b7adf5cd45b4d436186196cb919f27bffc04016c3665b9cc91350f0c884800cf28c4ba9288a9afac74a8fe1db4acaadf6c9918c16598dab26f592b1f9da44e4d92ec5b421cfad74ec15a63b6a5c2840844cb39f3b447ed64c67c21e0c73e91e24f9337ac416f68849bb286cf3884487331ee9c57703a1bbd457cfcfb25fd532cdaa6cd76cbb7296c0284a3079a8b5b0b8c3951f0b021c68b21b2cc8b609780077adce6cd9b2fd426e3a54396248dc2035b60c84c0664146f5e82ff41b02b5111010afcfadd1ac1f8ed21a9a0c2a2abc92d96d3333263aa806b3991ce7695009bf164decc0a5670eedb83cb375ed03179f70ec47ecf796e73e5c5876e90a8465cb0451df19da67bbb67bee2f0505508eccfa1475d36ebe7dc6af9cd03817cf1c88a5844ea04ec9ab8db4fe82a2a660975c13d3319de46dc700e986f9e1a761df5f8a48a4f58a4082e319f03e1fb393bb1108fa20952a95cb09f3bb8c1d33c267a23b739ac072b4141a6c43b7f578bd841554d0c57d343c4543219a1ef945fb96bffe90aa6146ffee8892e4bd9d26dc4990a3087f6053b41f90c7f45903d9bd351948ee7f2a817015f4972300890ee2c10ac3cf40b3c0ea300660c9d6634b42c66e29bb7b80fbcd48222c7552da7829987bcd2514e5ecf358b710893b0bf75b6af60464cda61e5363822d180fe73b9189ea0a48d911c757d2a79a4554473c71ebe2d0de2c0c80cece42840dbb34b450e160ff81f6bb9377805b6c1083515af6dfc2fdfe5aade44154e52255ecafc83d1628389551c8400fc4565ffcffc144fc4cd9c776afda7c6c149800642f1c66ec472e554a6e616a03f7392c234076c62b413fb0b9287cd57f5d6d0833a6bae51800d32da2f1b099eed895282299b8d710cf220cec9b7b825d07cc2a306be143ac7097850404066f4bbd9113def48df73c4a1e81a9a6961b590ec1de102fe365eb207008f33ae09f68ec1df39f2979c47cce2364467d9cf8360ab802ef32634369e78b920b0a3d822884bef9d6d46c7c508498863e8276fee7a133c75c8f61e7784f1cd5f8afc4f3514c3b6c38fc5a02f667ba6a71815118be14c424d6e21dfeb2b235c71ede9adcd191ad010c07c8aab13323735bbbb79f79b10721d168442596eade065237a5fca946f67232330186493fa3c6ee96d87f3009a1ac52f6ec43864afe73cbc1639f30e7b49c53f70e142c7cd86980a765c3c45daa4e32d1d4ece656fc1cc4a52bfd0c9f9c1bea98f651ce85f5c7f3c17ee814601706d27a44e35f823a9d2857cff7816451b58ea8f905f45c5d79d3619749a66fbabf8bcb99d6c2e0b9432e3070463639b91c7dee5fb62ff643d3e23a035e1bf994a4757b8182abafcd4332525afd75198d7ae58f9d8e76f9f094a47157a9d82724249122fcd98496ef8c3d2146d5a14e87ccb93ae0478f87b7fbe9eef5116e8dc48c06ec1157ba505e2061f8380279ff11ab5a4d0fec0977ea1346b7871b1b6b9104dd84058720532a755f63a27233a3ebb9ae39ffa0587caa4071892d8727d8bce74195d9de2b081fb78499179481c7619f1edad7452b236f7e85a11b9c1e0e002e0230b5cfd49beb1e6512a34872a9d7e96cf1e81cfcb75385f3aab5d944a9d7f83c577d6e7badea3b930ac2435ce2dc31fe3c941db1fad59d84ecfdc94818d62d653dbcc7b1a9160e618130a7cfdf9dd42e3fe3119fdf14d5c2f1f3542370e8a743e9207ee83ec7a2228a2511e9735d57c070b5e9e416682eb9fd83a60fa7012df6f09dc0f63542dea697959d1bd641dd0cbe371026660fac65b719193e4c401564bbf76a319f22b780f98bd18ca82ab356508d6ed27734c6d3aa95433b37ca8c35f98846af9dd5b8ce9ff34cfa289251ded998ae3086c45ccf26d6f1469e36c86bb3e398d895e1313e8b5ddc10b9f5c052ea036df063516f1fc7ea1598a1bb294d08a0c733c5f681b06f8d2b30acab91335223c435ceac3524510efe992645aa1cbc91d4fa79667662448bb4c7d9fd637abf35fa958465f927167644122a735e8a7442d7248e72d743716d9f00917ac4eeb2e315c38a68f855ab030c9d0009f1ef3f22b9d36b2734103fdbabe4a1993b85b4f8c5c0f46d1bd7c67f418dcb0598f119737bb9dc2a75b243a2bc044c51efb05d7835c595ed03c53cd4f6188f4fdd90361003db3c07da7e8a20f118f6d12b2a698aa4aa8145e60aaa4107b2cd22cdb750bee23b2ae0ae67747f5b8432b57e164b6a9bf53ff7fa6116841b1e2b1cea7826e478350b9adea7d412c21e22f8fdade7c33f114cf383be75b3e18f605f889c74d98bd2b6cca1fb0700db916df6867ab7fff6b720f046b774fbe7c26c79ca82abaa67a47ad5695eafc94c49d6df766df3ff060068408f1d9389fc14b9218cdd9ad8bd85503c2ad9fea404ee08d0ff9861f1759ad1eea1c69e7715885541a5c56fddaa237a67dbc0ca5dffe883075baa998331a38e00086ef2b9f1c228e17e8025d4bb64f99b4200e62cefe481f431adaec512935c59610d323ca2872d4e17fd952b7cdea26df073abaa4c6650e9b60a00f5d6812cd0552654b2e4cfddf0a6ce8330e0a5d905864f9d9a521fb2029cc9a27c6f127d6b4c90616946e7df4f6a0f2173568b565621f333310e71d1cac7a37e52dbeb43722b0eebbd049425c571ae3c2898aa842a44686e86f4201b423f8e615a10b919840697e8f4ae2a428d7eb98ba8b0a468192cd26704f525cec9782eb30f44eecab84f34b209049072c7698c0bc6626d4691aac7bd646a8e5140c7c1949be44cfb96948df43980754934498e2fd731b57d6c571ba4df9c5a0bdd3b5a617c5d2a21ab359d9b930b1e6da49416bd1a12012b9483afa66ab71d383ad7572af525eff08d68ee040909ef7351c11034d2f3168f3f260c403e3d6d4959f9e960cfd3667e116766b7f549af64534882a0a74bd6ad0bbde65e427d1c8b893bb181e1cc2a423aef1d638a8f95c4b9a40c01966f807abc05381f8a85b0424f36b0a4763a78de01638581915b0e594c9ebf5ab12039965993367589275f57f6be7c34c2fdb3eca8bd7e7cb90e815bfd9737841bfc457a3665726535604fed4398a18b4a2e390ad8d66af8db0590d9683c9ff9776a6d3c03c41c494c3ee4743b996df0f5429a5a0e8c162210d6ded2b1c9a2284e674c73275483210bba7c85e298b3fbea2b4182b6a2f865c72a5959641661bcfaebae3fac80268e800e1b3bebbba588a29a893984a4ca2a162cc8a1f7dd0b3ce485143ad6fa2c258f53cd67d1f3d339ee2388608cbf371db7fbd03912b0c661478d63e018919ef534b990ba995b203202425a133a8f54df79c240f9910ba49395ef57f921bb5157f023114b67ce50c8c7955e1c3a03378588441ff7b5a42ba9cf1024b60def17d48c4b9c922a7fd17c4d62300e666254adae158c6c627d137c558eb749a187eecc4ccb3f3a68ffb8ba2e1681d7e1d98df01b68e470ed99548f7fd650d6233fc4268d94b6675b5ca1270d9212f840dd3f2ab2f96946527bfd68da9e8eb82b7c5bfa831ebd470af5e8643339f4c51eaae80d7a18060690f5866c3ff27c49867fb89f998c4437f8af75f86bf1c91d781b489d580e07c42a4e16ee9c258d523e75680e08f04d047c77f0262bfecdac9c942be0c5c8291e0049a60b64ddc51470540a856916b1a28b4dcfb6bc8dc179c7ffb815e12bb681bb3bbcf0de9bccd5ae1357d1625affc3cf4a052e6b89a0c050cb1c243ef8d8e463f5d26af9e38b57aaa9dd92b8961e837d51598a97c81146b65b76e14a36d4b735cb8d10d503127a2db5a7b21e0f06089d0e2f5984ab80b16b7c85718a1d730b9c2b19bf40ce7c4937d49480a8a383b4b134f94c8d595532ac78cbb50e188637370c2f66b43c80296f090c116825f3328a761fe09f0ed7614f8a2cfa2a8e0fb4b9325c3f83b13a2848aafb0faec712770ee2d7ecd381922935625247b61c025c4b2ae2ddef0f2ff78178213b34b2193f1007de8acbe4ca3673f315dbda24a1d61671d7c20348ccfc6d068006dde23bced4bb5555ed02dfbccd7a1c8233b1a290a890b458af831ed48afdc04504b294cc4b8bf480d724cb936d8e5b99b1198de5356e0ec2677d95d7423d3263a7c8fa5f9ed8f3cc67461a954d09fc182e50f3b57f937c5d2c4786a2c678904049c8acbd30bfd7b57431a1c61416c0249d8f836ed2a06d60591ecb4f9c6159f1ffe31c5523a2172c48fb0a37422eb1ef580c3ff82270652ced5b9e20483fc6e9b358b31302d3195aed293bcafdc45e540c0df5ffcc8638385843a94e3b68bc968035ce163ca8a508ad26f7b2dce5dda7ca2b41f55e04a88ca3163875de5f8602f797da9f75a5e718e7c5192787b81933375ced96501df67c0593ad300e458370681bc0905dd57c2867511b3f0d311c9b4c718df0a971ed029ab521e55ba25c5637d23497b611d09c394d51f9e0b2d7f07a80f419383d629e444425a16882214a6d51f28c87e4afbf83abdef5b3f2bcfd29dc1f4620ffb348195409c1ae9477b700976a4087df9c719ed1eaec7b4dddc84a5d63b6bc8d4126fcb2eb20044367d10607136421f4fa416ade3db4f14e588b60565ccf8bd1061d0d2903d3bcc1ed862c20c8da68d4c50db2f11cc4fdf2669dcf9d87bde405d89a04b9f45f1bb36056cca2184e9c43eb6a159029d42a18a580caf6dc835874fc8adf7e192546ecd68be570fd3b59f96913188e183c923ecb539e806b404ca6719bb5a59d531bbb8fc1ca608c91a0bb2b8a28cbfe9e7032f3d724a8c0a5a3b6c7bb2f0087176e82ed22ed24a100f513a735181f07ef3775f9f21e6c1ce2d87513f216908937ee3fc41e7f5875f97a472666b9dcf4475b63470b11669843c046ef86eac4c6e1830d7d4d7cfce6bbd7a074e75a02010edbc1490b2ce5da6976d1dd124e124bdd3065747cc23561376e4f75163649f5d58bb8140669f64b787ce4ec3a9c741452fc2ba15ec3c591c04d9a1568825af786a95c94e39ae8216d359b1afee77b68e87825505ab49452c06dc5daaacf713271ed0f2f408caf064ae0487ad89eb93082e99de220d00b1544fb3764d49a3603e7757b38dc08ed20bf2702fe70bd8564c329eb8a00246ccad9f68dbe93f9b5cc9955ec4b85b868279269030994965958d74f685b3a56801a51b6734f20dad5b8a6dc571bdbc92899d51a2fb9b34f2c97437f47d1a02f3c71b5f1c943c5a86193c0049aae22d9700586fb262714fa6c03166a6eaa489208f9938b5973612b5bf568a20dea4432784363dc78d6736ee068b17d53f9ee898e08e04b1cf8b5e01e31131b309330fa4b1590d43fa93ee73cb2a81195e894ef8a1cdd19a919820890cdd59308be29967644d10f0f6ff3326a6acb134bb47130020d5dcdb06e1a7c99da7ff59fbde8466a1af40ed1382c75fddf2375da992b220663152a8bf6f645573761f2b5989bcb979bff0c0c8b0b500ba02f6898b2242205185c66f5af08d351250438d04b4a00f817711913db32e176ef1d925ed23b8a6b7340df4d4c7fb5763e952fbfc41390cd783913277f780a2d72b39189a30a3683dee1b77d907432bf36912e050ece31591283c3fd5405312d584f7f3e0aac2ebfb6138e4edb9dc6499d96737621fbc9d9b333459c3042a1ae2863ca899660cdd1cd8432ef6619c37d689f75cbe40bf5b7573faeb823f30cb6e9f12d23b50594b03e83cb8224d282342cb0763f6280d8ab7a9d8dbc11f8f402ff10e448c6af90c483fe9336cfd95723a724b2341928b40a1b7f751b50a6380f38d23289120e9e748245bc53304a778c37ccde289f4d50070599dea1da87cd8d2ef436b72a472e7b45f475aef0c7544bf206c8c3252392f0a48048a8d38268ff07344236c5aafd2873bc43779cbbb61dff742b231662054f5a9afd3ddbc256f70c686f846a4e28cb20ba66148a387ea3d49be1380035918bd5acab02742f076816ddeb1f67d70167f6685670e33b2472482c32fb2cb1b888278f5211379af0e8760c9c605560e73a5268f3c751b430ee6a5d41679d0f009c48d0b72d8518f5b14da1d0600f008ee2059285cfebcf5e80c6f568a792b4088d8627d1f2b2ce6e0091398117cf50435ce9e5603f01cf836cee272ac3284b3f0da586582779b5b13e81580500d2a9cc3918d04f41c5396949a2270cefc9653be104ea07a7fc8f994fa250b0fca41bdbb4c5c03df7300cfd8bb5ea0b7e9b5e6dd7ca9b5de73492b4568522c35a88db611201bed6f2d25b53f6592df7f284ea66fb32632fa69c55df84d53c06548e042667266da1b80ccc976d81a85b7a2baf36ba4a04ad98c05d194dfe2d12a35ee1e694b183c45e3cb49e892cc345c21ba17221c67771080b4397b41ee3b72b5d88f882082485a99dd58b04a0d8601ab8a443c7b8de49f807ace7989b93edda89ef4eb37a68b24be64db35c9ca52c48c49fbbfd5f1a738aae9ec662cba0a1ddd5d76e5b85fee0a959203e9727c4a7cdb6429e02279412b777992c1199c5ecb5c9d7422b2b41ca9b5b09bf52b27224add149331d23026db687d3fbc5a752e19c8f39ffb4600eccf5355757815c84ce52ce1e743e62faf2dd41386b25dd9cc5ef0932648955ebf118f5db4b5ae5069d69a1fd52b3b8c3eb9c1753193e42d195285e70b04800c10e2b5c7a8b1db535924a3e7af09c5d18377711a378b1cd0a46370e4b15015c20e4e156bdf7f6ab43aeec8fe86b5b5f2698d9384315e266948d638c812909eb2738158ffeafa304e3275a0168973d5f0dbfc1651600811057f4bb018d0ec28fdf30e9ae5524f857b5e9749d975811a568e8040bddf6827c12e72ac691b14f4bbb31759c075e512d50d9b20a1fd2559ff8f8c72337c7418dd39c42d76376ab94bfbcda2aeae916e43d0f0fb3d531ad8e2a9daeda7be28f721e68ceadb755dee21d5c79752cd0c1229e816fd7cad4dec79c322dff12d4dcd17425c4ccfcb24c5e46b8ccb4d7d6a712e01cb3c827b1135287b075d4872547fab1bac5fe3268c8453ef644b46948ad0aea4a0ea3fa0ae8b4e52e9d3d857f75f7edf000aad0d6feb725e9f7435429b60313c63dfa91d18d3d31dde8078669aae613837018f9e9586cab6c7ea37e0d0f3795ff2ab5db88e324815666f1028750a48d71716cbd836bde80372f561d4533c3bf481ee52c2d5d035971f93572e0084357b661e4e4cfb675a274570708bb9622a95adefc1888831adf02f714b07a8ab2a30260141f99417b7f4ab617ab610158900cbbf088ec0f761f130aa0468660b6e5f66fab3989ae38f3fe4720000c850d23bbb4bf4dff2b5fa660eb1dc85ddf177e48daf92dd506ffe7a591f52894b8cae61477bf73269e19b9720e72d423194b358937758a1b040d76d2a5931b83323e6e8c700374c6cf76a0111d0c6e5f41d73cde635e2df8edccf57952cee5181508075d1ac7df619184a417e143222026f094cb2962ac28fe956d276e834d23157000daa1ab729bd20541617146644c647ae07bd117c42164e392e3b366eca4a76a9e7299df8f3b2831780fc54ae64391e61f4840ff7f8899af7007cc181a8710d6813530ac04e329772d1ba8be8b4dfe0a9e1b1fdc973a28677e2b11c8b4899269cde62b61858965060c649f334aa1c93e67f0b9c0e8c9b86c627e3104b449ec6213c2e4983055d33ec0fba276a6a87754f0122e92bdca59173bcff035a43221e45dac9f22385f4ff6863a4862514feeac7b46c9ffac264c97afa6fcec60beaed44b0d23b96a4a1d93560787410fb2f4e127b86bd07da97648cb7804ef979da8117cc1deb08d28189482dd251e5abb1014e6edb0e1b40986799e21a6b8a75eec32aaf4191e76d525467ea6708fa301982f30d768a895222fdf8105a47c42f57b9db0d45f59ba9766b17e4ff55a17813ca3fb59608209909463849d75e71302a4596c7a0064c4635eeef497d39a6950d0a219fbc2d651fd894a66e239da11c9b144202b185517876f1c9008f2862e4d17275c2ba3bc02e556dc6de1aadc945df01d9e3018c074ac9b5128c600aef790c9353abe2865a4fdb1e67fd6c31acecb0b664529984de82aef56e42404d3f46bcbbbf94d7268ddb39be47a26f261b281fcd0de3d6f9a705d6dc9b31b8b2ac9f737cb2a72b9e344edde0029a8ae5633fcf286bad8c31232d1c577d341ad66258ed24726b7be8e51b4b3c1dd006462a0620dc6133290654799ebafab7a9ad8bf03a3072017b93f051eece4d893d3a9d8da4de0ab16e83e730d4a3d6c3d0257d9229870cab3de22ed796eb26f5936a81bc4ae413288c0ed2c8d2c67d86cef30c542ce64f5c7bad3e2de5798f7904ac5d5f68b821a62be9554ff53847ed77d6da7f0b76baa1dcbb33aa36f48acc896ede885c57cf23edaec5a6720ea4e2c9b1d24df7c16d67e629192034e8ae239797fe60e5d23d868b10df6d59f2f46b9a6b24ab38d84b7ca96f30085d166f56a7944bc5c7d49a147a51fcb486c525985c42ccee07fbf1b776a4f0c72a1ea56cc41a986ee0fb254894a5745aafc475210719d020c4451b43282e2228b3ea12bd557a9f3bfd40e05fea88e0f5400728e9054d0d4fca70229ef6f279eaa70feef239b1b44adbfb8e18b285bd47a22fdfad082ac46829e4a744f626d7df6e97058c2078c81f6989e98135410e6603eaa38b32bb8bec3c0465ea53d4a9a8404991a33f0abc7d3705de63eada1504f4874651d117d3f4aa10d113c667154a523da04fa9847ed045c4b5d339075635955ed388796a1f1160107cf7f93fa792e0d9ad8e6009bb4e190d3f7d6b239fcef13e1d1d2b5d8d0e27c9712b6132489ff817dae58aaed115dbf19890f7a6135ef81fae90cee29cb604f759304f10b33d26fe125ccf5467266968771dea3d4c52c104f1f9bd2c82bb64e2e5cdde12adf7545e313ae2cec873f10ab84fb2c6193d10f90c88ef088398c498fdca1c745faa60d4dd9eaf62c3bbbe2556a0fa3d78350e88640dcfe848ad0df381e8677db68f34a4f20ab9494775d25957ea940916ecf22b6ff15d9b83ad15a1031606d556fab2d72260093156e0caa33334147f4592d0b8fbe76312efb534469eaea37f27199a0e6d79f40fb9489eff51ef5d24d68fb63344febfd2b64683b6d1a54d9c9ff41892403d22f573a9683f318c37054ce6c996fcc4bb14d469613a45ec005e83ef35a355823269c79f418ee3f5ecec3eef53813ae70243247ab66350d6bba6431928683ae5b7138c06fe4f5a036d3007f8a351192bf67b16e2b2ecb16ee9cd2abbee81b7eb841423c6073f06f2035286fedcecad64d41ed0c6ceb2ddb001a49283e91277c95a5ddd3f6cf161d578bd32899a49045bb22b74b7c1a1d40457c0cc5e717322a46a51170baaf9c4fbc005a3c9b291f1c3fccecae406eecba286b64f12d7444fcddf31e3459a084877f3b030d3b298042df32cbc48465666c4d4cf589d6944725e2b6d05a5e592499afb7740385740b2e90b65456bf5f8c16ed84d40f9d9fa12d9de7ab272183c0f6a137d8bb1cf2b39b6a974c93b859c7631681209f162bef52b0c73716c2525df9f5ab3cc2ddafc3b62dcb45d8135eececde0b0f4b397a315a3fcd2efbbdceaf2e91d6debaafa1be7f5337200b755be4fe0c24dba243fbdc876c0a8e5c67f03b108c38e6060dc0657751d629441ea450654e4263b95b9aadb650203526ce6ecc9f2d96c1aa4e52c5c00e0239d1f8555fdaeeae27706a05451862dd94e27de635621478bb25d054d6b87932e2dc719642330406b5793012208d7ec38e9d8c82ab242ced9501086234c12f9640b1a92c67693abf1aaf5b759eb7dee8df55d5fbce73c5e1dc1a96e47c5f04ececc67f976b8161438dcc5ac9e18eb764b414f502a9fbdbc63ad8b3a8bd0c98cb3521a32e16308478250ed589fd7138830a61621771615e6a5d754e5dab956e28667d7c30d36cb4882e4a54ce1ddc87656996ff9f039c2b84e44427e9c07615ec6d508561c6f9fabc129e37ae1aa750ecb52e02626457b46ff8447f44d49390cba34fe1d62dd764ed584e89807975ce326dbac55f5b37e7d7017d1e6b88a045ce983ecd364f3977f89894baf18c62401d5e58d011b4a6451c57051e06b1688507ee02b53d8d1de27cc9e18d4d4db28ca0ec6a9319724dde0cbaa5ee45d342af54f4b77fbba28ab884a15dcc07cd344a8e27f3cdbbd7a7fab8731915556d2d1c6c5d56ae0c6bd7299fce650ce1e757615f7caf194603df6daa7652fa6daf685dfbc490f2f2e13db9ae4a4c0762175be45a5ecbb1e8758d3023775bbc73f4d400806eecda3e4f0d425f56dfe55ed15befe29fec79be03b5a2352242d74584c70f27e214cbdbf46f8808d84ef297332bad0528246a603d644dc9c75b18ee827ba7752826d0525f485ecbf647f79584a11c87d01dba941db94ef2df244b95081377eaa22264ed316b2ddb870838b14ddae48a247ff1512e04626c2e8c45af16395f50adae5d2ec7fd37d149491f3e626e4e56f171e781e6aa21fdea21ad32b750e88dd14f1d77af7fe518deb2f752b748fd022078e0ae2c72f7a24a1c8d496d77d54d8b459042facf7dee016a61706cc6bdc7704ae1ea951a1ada45e97c82eb9a41e014f90f34a10a237750bd5286404b6e706eb028aa25433cea1cd41ce34b03d9e6ea149d59e7e3aa826deb88e21bbffcf8e1bcbfb576d04081a57d4d8724cb0205b00cafdafca49cbf1972cd796a909a3074b3a44671ab2e3154ad2d6eb607708aba4715eb06a2b68d13d89478c79fde902e5991c6f0d168c9ee2289be81d0d5811f9671bb233f3096cf5e2feedf9a2830efa2d6592e8051851aa9f639cb21718c1592c4ec02d03d08ae3c0f766f84ab601a5bba7cdec59ef4089037d9cd32e8d53661e25856e3deffc51e73840df99ee2836630d06994de2bbec2906d30f48a41773f36c542dc4f12c2753537dc62f1e33e28eee259beb17dcf88b700f769e45af9d4ab0ded2438b238da6105a7d9a511ebda173f8e3f063f5cd88f18deb7fa6ea580234e10e461b59789d939baf67c08055ed8852fd9e9a2ad77acbe9203e3f1f40be0ae28aec19240eca073c90cd87d754489d51e14457bcd3ad2edbc1a39f2b7bcf5b7a7fcfb1c19614b7ba7e70c76df34623fbb3d6eb4c027d646ed85b6f0b4ec26beda961fcfb33b3213f06e7c082c77d6d1b975813602dc75ba5c3bef06f33600613598f1b613dccaf2ca9904f058cf85373104549ffea3571af1da6443967cca2880304e4cdb37c838c5804159f44524275864ee0bf56dc2fa73a8f40058d497f3ad085d418b87d922b4378d6a2555a16789542b056f8151b554162790d473506ff391a82b5b19b4639ec8e92098eae35a9250fa02ab56eab693e386edd8ad7f84429a8fb15e282a76028f7f807f39a308161e763563d993f26d18c019921376c8b1eb4adfcb3a7e0ff0223d2c3e742fcf4ccac4454f7e60709d0b9050a7e72cfe5b16b67439236eac731e2ea9b87cf63635d51859bbc7fa11399ad581bdef987fe4b8d15f3c2a6a0b13ba5cb0893316254d6d74065def2274f14903a7daa589da925988cc9bbbe3b0fb8ff9b217bef8141e9c8abd8a58fdcc7b254c3f3526f02f8bcb9624661c12e5831341fdd596ba409b9bad49d0cb8c8c4106675568a9f72d76e6ece4cd9620b371f6e77b8d8f424c49d6d78fb33862b07d9197cb79b581511814f2bbce9e801de45f6493808f781944706b0787e988d02de0ad91d4aba1b944dbb692e440187202f08477e950d6f8d6a63a997f9c27c571123b3778a3083263b071f63ab831426baa309fe9a4498ad53d3bf1d4c9e3a15ed3e62a6b847eb80dafcbac6be0fd0823307820af423e64548b2637d5bd963fd5563ab8da42c26b3110a25d1e93c297d5a7e157ac4cf301cd006351f3ee1078295b23fbe1af3667fedcd89afa0fe72d524a2ba59d197ccb1bbc057f8b5cbd129175c03a42ee3946a81bee922a1e6422fa47dbed88db91de4c19949c1d54892f6570e0a4e72e52dd2a20d89f5c9eb899ad2952c880577c8aa012de3694abb9ceda6f0bd27fe3a96a594e284f09ef3194708e9b18c65746e63297ec11f8d8f638b1c89d590639fccaa023c751d759e9537a4056f601cff849cfd2efcf7a37e433f022ba4a4db67a16d9eea6e0fe00ef9357a6c056af00f32672fd46575d585ef860f746677b0199ccc0e1b806070b023adfa7ab5fc2e2ab85fc3bf878a97567a467d3ac30437005e0c7e13fd08a122200dad6c32628550bc15bc62164946512f310848b0083467a2bd2fd8f4ee790200710b0f3ddbc9eff622036425fc39d99964da576997ebef8593281f0bd43dbcf39d95db8f7562a863699bf2bbd426a20acf60ab8f624ab445fcddb04c718ab0ace8512785ed06e3c50925477fa505bd14a7798cb415e0b06fbaa45df2d97a94a38fe9d62bf6336e8ff62e0f31010b95d6b8c536395b953a3abb0dab911ff834b26e26245c5dbdf5ce27c62d4705e36f0553d7f7431292e1a9239359add0916383c043eb77fb7e1bd8335a09b2ce8699ee85c9b63648d05b35681873cf34466f3f48613b6a5e5899e71faa54b296d386fd7c054feab3c86f91f4c6da1246a28603268a56796e7caca901513c826af7313320e67ed10765c6056b27d391c4d02f3555f8b1a959bf7a799671f0cdcb18e830dcd19b74e35a08f05bd0080f140bce32af655aa9b665602dcbc96cd4d54c052e634d32f2cc809c0f1491a5fd98be277e216d4a11bb10895c83d7cf34f171a8cd126a87167109de3a03ac73a552ad546649e4f96a4362b03e5a13d897b0e8d35035daece98163a98bc7415f63d94adb5f864c96c7f674831c136a6c786615c05e70d9d1523f433d305676f082e82be2f99682cf8418970f5a5dfd69047455997a952bac87b44cb9098953947bf41e99ad925e533aeace08a1592f9053ee76baaf58909b63e62fa1740c2ccd332d0e9eb13299f8dd3d09107d7fadfd59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
