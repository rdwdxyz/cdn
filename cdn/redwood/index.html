<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79b6d5eb1a0eaf2e9be5acf8872af6035a9e45aa633c2100e72574da58a227ad6550989bc710b079fe850cce8fc0695b26a2440aa148f55d01f1d548f1267453ebd9d4642462dacfcb38bb0c95e618f8932bbf8d3d37e5b95f80a6c9bcc97434627bc7c41ca4d4568517fe9770db02a974d53309641db77169e078ecea5ea034598f1afff23694971f2d0a6bcf0e42002993541f5d85a406086519fd2609a2bec2db39b97d8b0115d39b54b7aff08751ca038bf4fa37221a650af381b563e0119580268992a51bb8563d519288432a729dae5dcc4b6d17ec274939939df9f52b58c7f44ed8bee854b2089331ab3b6d9a95c444c74f0b3a868522c3959957e4ad256f878707b1165277d308a72d204645c7864ea7ec5b91a3a70e253520cf4edccf2707fd3518cda3f013e966d5bf1ee3a83eaee902bcf69e95ea94fe55fe39f1c7fba6e669a0d7db467e8d122645ce39895fca786b9406a2dffd4ffe2d8ee6766561550c382c96e000cb2463fa7ada780a1dfb0e20d65f8e5f054408ebeef4f9b89d1148d8bc4968e1d6e2443710ebec6bef0c6a3e8bb96ccb0ac7165c1b3f43c31aa2cfc792a8070a6ca11a19170332c67e2dee10cd79f2be255760564c3762f1a8c5c40395d0fba2c56064eabd4d07289d4e7f98d5fdd4ad5d5473adbd3a9c97cf3c158e9301cd615feb457aae14b635e447664515091a63083336999a575b71c03879839fdd10c35c0a4c3469a33f78784696b88c679a4dbc11e43ea8de9d7e15ae9729da9ff7edf63d7745cbeb0ae2bbde2778c8c245befdb00e8cfbd52e0a680c1ede7bca18461aff393ea62a93a6701c98e0932420241c45449e2e3351f46ab3bd990a35f6174ed05260eee8d31a1a3ebd222da4513db02ef230256f15793af7ec2cb725ff6f39a67f594a5c14130cc5f650b932a88349a1bd8b279e77920b09b185781336810dee071592608e0a8fe89aed402b095e0c5be94b897f430ddaf55d4cea62f61800cf5f4a5624a1bc46ff8fcce11e93ba6d764209ba9f5d1c7fdebf3fcce8f206b8606b99fc7dabd1410e6737c74fb2fd5941cf3596ba0609a2c6db5f8757212060d6bcfa5e1aa16a94ba72ada1fdf308c0e4617ed9d245d99ddafd91d23c25129b82bbd4a9351ad77a89195ba6cd7b65263327d39a35fb39eeb60779a2692dfb2ddd883b1dd5826e790a6457cfd88d4aa014b27c2cccab28f44390cba40b7ed21ac2e664943581abbd0a35ca11236496f49f7b060908fe9be32d5909680f9669ebcbb4520e0655b94bdc8949a192617a0b81f4462a660c06be899275ff480804470b8cde28fff7da9615e528177ce9c4042db1ee90c44e49acb9cc9b7e5119f2fcc0bae4290a7ca313b1b27ee37d374f6cafbb7aec185e4240cb5c690a6abd2d0608f892ca35ae0b2675b108deb24a97ac70ebfb6af64e99b7aeba0808e8fead11df1d82aa6fff1a76a78744438f5026ba60ef03677fcd87fc054c13e492ac0b02e2f3fff860a7bb8fa6cd25259abba825ee3ef0fc863539d30f6f3b98c07eb0fa66b8b51d6f42801742e9b9ec86a68b4e0177f31b0d6edd9325c614500cb359f341663011629f0d8061d46d4f72177b49be00d5502dcafc9e8e7b34fbbff8ae48b918e91154fe78540f5b8f43c1febac2e31754b8ae60209be68523ceb6fdadf9ea5fd2c99d279125a8d7b855bd26179ce38926d9ebef7d36722d1408e7ce82a88c7845cd1ae3a01516fcc67e6bf95286fca9a6b84b8acd3138da2a1387d851f9fde65c8d0fb29084e8b34a389fdf7a4fd004fe3fdcf563a727f6c835f05ed151dc2eba47a1437c2b023a5347f842c648840d67ad844671a0d68c50d5e649a96e58031d1a7b4a6fb4f34aed5903a18f9471ef9c2b0854fe506fbc4e96d46fe72f3cf1ed0b810c4628d30fa400b06bb716a97f003547f6fd547734404b9c2f4070cc88ecf46185fd08994804c20033dc7395a73df4355e6247ee7a12b34d61bcef84e5698fe032a49ffadf0e00a7984851b169dd218c5f5dc8fa5393b49137961f0866b17b9430dc8dfb7f96e6b3dfce8d8cb277b8fdd55631f02b9f608fccba08348279c3ecd85abb97870755a6dd7e7e17e0cdefd5588892e23c71578461c0fbccc3b580d4852b9dbf5e52e20d8d3601772408fad17440e20fd86d69f5589f5724c057563ec44872ba0cac1db58a581fb96aada36e54a1a243b8c10d69fbf155a2f5d16faefc207552801d757dc21b416ae4e7736cf3662fae0046d84ac1bf70d77305a56559f7cff8d55491d618a0517d1c555929edcf3194fa54e8483608a985cf88dfafbbde28a6f86abf8a71e59f69bab844d07f13c4b97081feedf252a933a77eac6c8fafdd135e11803b1edf8fd351b41b28fdd9d69c1ce8aaf50d45ee724640df260ac78858adcd7d69e5523cbbe448178f3121ffc400ff9a1a49e6e4339876d399c529ee955801f95ba9206a3f31c878bf6616df6a60536a6eee09656502642a5f11cf6bb635843cc8a267584b62de32556f8bcf45b3b3e072bcabaa8f2ff95f5b7912749b75592df470045cf89c70da0bc5a3fe4938989da4e744c63133a9ecbfffb65d3a805e4834c0a470572c4f0748d611e365bb4e5223f58ce79252154aa2af1ec1e092b64841a5cf858e261b9ee0e756ddc3669f514079a75ee5b23ed8410e0c091fdc238c806f473ea31a7393fa06d3a220e299b7f380ef6cf3052abf0eac056b66107fb3e55270b75c5fcd7e7d49bd66eb1373aa1129f73a4ef14efc0171f4e4cb078cc58c868119111bc5fadb15c41718055649e7444b5d358357a1aa759d299eb4e7025e38110cc50900f21369f6d47faffa5bd6d32c2a22dbac0ed07625af390119fb46888a434529e67ae39a69d3e81a3af223dc617c71abb841d42f18a1d6f6e5fb1b2734fdb27a671975c45dd863122d770ca09a0af630643fca66fe5fafab3486d86db554cb43bf3ff9cab38071987232efeaa43b701c2c67d4741914e24c20a84e5c9de848da4c2c14edba1cdfd085f2d1d5b1f1026a08687ec09417391141a0ef27e1807d463900476e04ff7bca6efcf62eea0e0587a0a8646370454b37b606bc2675b960362425b4d19f631f8cee8deaf565e8cb419e1425051b98719cc200a3a132b9985727e2bb2616aed84d8856bb0d971d5a894c3bc69f25584284de3acc3b02cb1db40b1d623ad0b0dd59af6e1331f086c3a02af1fb6dd1c6d3998703ebc5ac6cf0955d2038cbaf972ec2c86d619cec84d0e2ee624897f507397b00b7b694e8a28201da225dfe33b83eff213307863e2ea0ec6da1eea65ec5cac12267cce425926913c08fdef47b9ad085071685d629778502581c8246e080a80315e6a58565ff330130515976e6c46bd584ff0ab145cd32bc2e722d06dff3e19ecb03dce896119adfdc649dcb55544238d7e038e7af730bee57a3fac32f7481d027123186788df23ed8ce77c4bf36a2f03652a8546f252f751e17146007e23d3af974a5878513f0bfec66d86d87d955412f566f6e2340f4a3fa05132e5b5b08328fb4d619e4ecedd4382ddc7e4dc4d1af847ee57ba935511751c14025f73182f5a2688551d06ce7b1afc39dfe95438a604bd0ba63a88d6e24d00da0b2392c01f5b4652c8d6b2d4146304d831cca5b04ade32546e459038e3efd9def968f246aa7254d05098bd19f5b6b31e67e728a07aa3ae1d4873b572e9294c1362083de171564169c61e9f9a1631944159aa04dbb7f60825430550a4c7464ffbdddd4297f4318334a2a54c53364b2b41687367632708175530b4d12e3bbaa400d212ec1b529c977dd2acbe60e27150217d73e1338fcd745a7b1d239ae85a04198c1a87e3067dad6f8e51fac7598524cf20667f2239a594209a90f33460465ef69a94afe8e892252062469cb57c18817c8eb01ca72ce50ee60869229ca48c879238856e2f9b614a6b296f0c251f6de351c86047e8da697e54c13a8051c785dcd1b1efbab91f43d1759b63994a0107faa8eba6def99f08b2d24a67669ecba42139423a4646209bb2c96d2cf22ff040383569ba5dd572b260b006b71e77f640d1df66dd52d625c49bef1fa4c8a5870e79cc9a50a35ebce73aca47f1ef1a96ee08bd07c9a773162f9974b9047fca6a5e784978a37a8cd994dc73fbc79b04b89b81ff04d93dbdcffbe14ccb6ca67b93684182ccb95ae6e0ccaedd79809b6a16a57a4fa7544ccc4f8321b827656da6352d4877e87270062062f358c8bba51000d9d64815dd60345095d23ff800960a17cb894fee4e812d62b149743cee7f9c274702363b04daf415b10bdbe5863048c514d3b0197b284d5e3ff4889dbb6de8a63d6da2169c44d825e039e83ededc59d7808f2e4afdcfa070ed3dfb2f5660249cc96bfe3d8f7930c6d51da066f62c2da61143be37f5f65f627367afac85b4c6b22b180ddc0e62532413db06e1bfbdf298a15203a98dd2dfab16e66d6d8188fc74710025e05df52d8be9dd7f4a16df5e7eda504073183c20fb568263b5b321b390b05461b66947f121f2951628b1670e27e565b794303acf673a6e91c49634954316f3b3cd38792b5873e5dc7ffcb06aec16cf1eefeb6ac56386de321fd69abce1c68001f37aa5726aaa8d4bc1563459453f1fc063bea1beb765b746e1c74c56828fda3076d37ef8603b00d09621ca9f500516c63626f36ff42209acafd203707070c70dc80d7d076847bbd0f4d2113f226ff995dbd0fe29dc312737904ca7bfb40e24a1d51b85f650340004e4fc727cb0095fdac9f7d352927919a8a4c2d0c7053fff514822805f8462c14e3b69940d99e2f2b165172308c33c740f954be0e743d77ac5b33d16e5013f89b4ce0e0ee0a7317f32fbc8a13c729c2dec68d022f62540452b18cc51b7d409f390a0f8d59363fa0840dcf30d565da7bf393dbcfea62d08de7552eaf7e0d6efb3ebfbc04997db9f12d0b7bbcede033ab438d3b1c46e60152197911877fbfc0a04d86a35da2206d061159c88e23d2c5f09d9481dff40310cca36c4c4821484c98a74576e64c579c243823df131572d497a4f183f49e2193adbc00ba12e38243a9383f925522bcd2f7a07d34b6db6e6559a8dce5fc4bd36aa9d750ce544daa6ccf7aab8a7c20431f4d632273d9d32ce4b040c5db0023ed3c5ade0d28c4556460e6c36db20b1ad3f4a05a23883f43edace94db422b7569bb3fffce278ff2fca0ed4256a71a14f97d52a72375ab51997c74ea529651eb69c3b146cd73ee5bb0123081f9bcddb80037d79a2ad040ddfb81f5af3c63c72bb79bc919494f4aafa8200554ba8b7f489e78324edeb7024a612faf196736e632898f044ea832bff9b8473eff2c6d3e830aeb037e8e8e4f93e7d2b388ee667458ba2b394d80f0b3e8788ca6136cc54d7cc83d076c60f0b1b09851139384f365a253c3f079074073ad72c52dd1e3aeccde42dc60be5dd24406865c01fa851981b9ec490e649a95b0fbe0455ccac4e6d9e454648b3dfff524f212333afa47257a15d6de32a314282028b83f575cd0f6b99e8b60712ef25409e34a0712a52c6fb04b56c80bf6614c090b5f3ce9af0db27bd3e2b06d8a293c60d0ef227ff31e2e7b1af832f72a0a6b8ffcb7167d249df82031bcdbbbf847f5dbc9039d1ef9f7d6a5f030f8f750d3afbd559658f211f0a5c7e8812c86f9797936c9c88f4297bc7f64533b189d22912b6214eb1d049aafbdbeb2cb8545885f7c2ad052df204310195147b12175809f3152251815322817507a420f6e4e6a80b0c083d91f5ed1adca768740195a9b1afef7d0fbb08603f62983436ec95e53d18382980ef372242f3a8738deb02a801887dd921acacfc0cc40899bcd88bd5316b3ba698225a0d62999578b1c1b96ad79ec03245d6c3c78324b740ba8530c76286f5184a52c39325e4d645eafd00cf70e71543e337ab2c11aad848b6097d0da2f5f31704cb1c795c607e8721805b2dd7bf368fdec7cf69f0084db6cd28a07545ee269c583f3c46a0a56ef9a2775a9c6126b6636ec99ffae7383f2821cc60aa6c44610ed66d235be7b7b16019d6a5dd1149c23cbf636b8b1a10498f33ace6b6a8a76adacee0df8938daa7f9cafbb81b36361ceb234b890d36f2c6d45a122a53638c526460090aaadb57c280b8deb5856982b665898b6444be432eebfc4f6cb1eaf7833f932f9de3c685138d9a6a900b4ed2c23b74294a00a082935b5001735177ee173b00d657c73f6688f9e080d093edddfe1e0f4b434ef5a974a7fbc60d40d34440726c7c6ad758865b67390e551a707b8f2c67bd332ff1695407cc107a5d72f080f3f8e184ff6a9885ea5144c8008f8582048b5a97e71fb5c989544040c5d495478ab15c498cd1d0f43a82d896eb5181501cea53432937ef675c1293e2ccdf31350f9730336a928eacbccdb78895b90325176d634119645e4ea9ed43ef64f0a3bce66db8fd46496f25438eb055d3a467bffe0ef8403687673def50144643d61ba9ac0377da050808b47f5a6653e96095e1915272e3a67242ba08c3a1b69d31f1a8b8f26b123ef39f4b5157ab7fbd1698d3cc945ac032cee864b4ef7cf64fd51906df22ebba688ef0b439638eddb3d3f2d540a3155c8ee430660f958087d8f8a3a935335702586c9a48efca1c62b1d7512d33ea24e4f091554003aa1c5ee18e978d817c0f6f84c7ccf9f01bbc7844c95b800d643487266cc56cbda0c00347e213873c24b41c695344fec92503813e043808505ce73558a10f0243feea5ddcd5913dbba45faf3f8efc131ae8f8151815ffb214638658f1838fbf996e35cc8ef9cffa86e4910981ddfb7e411fbd211a277eb1e6b45372ddbfb129407b26c54ebfcbaf84cd36994b701f85477bfa0e2f9a4b31d8ce0fa89d1f2312803568ee7018207466241c2803d48f4b63d6376e1f1eb582899f050d22c32732e2cee0264f6ad143facbe572e5eb0562b3da2b7d17ecaf232dba4da6c95abfb5ddecefdd88a54dfafcecfcae3c5c913a1f52fcf6c58412e1d3d2afec236d68c84e12bb15b64576fb850fee5657dbb4ff61a2b61502ff4e6d15407db96061ca78ab4794dddff3686cb9785b2c63eff35b2ae7ecc6ff067627f9811ed9af4a537b75159b2d06048242895c3700d17e63ad82192fa1dd6696c4fa94311797735629c7ee6e12b8aebae94f6e81a248f24df9f0c9cdddb38ff27225f4bd94325385c73215f7634966b61866cb502bdd60bcd2a0d0bfe138724776b51730bef7e4d60babdd037723bc96f4ab5ca5d60f814e8a9f49a96a2dae6ce1fd8bea288eb43a7a810e851246e28ed4e82abf3f1de49cde501c28d951864f2a8d2ec77199c403df58a47ad81f97e9bae0c4baf49222ced0d04cd1169b07d838bec571be8bd94d0d9597cfb4af8d66750516d2a9d73e97d0757a41e3f069b4fd20295a162ef0b5637e84dcfdae33a602f54162dbe908860c6c9d010dbaf6f9c3dccfdd06e5f7062e5b743f4c08da0f0078878d1a86c2363771ad314a96641b858f9d1a1855802890bd48980e217a9112418cf4ce021aacbdac042bfa75d5d0ea8255a092be5184578f79b3bf2dad88a10f7eeb20ab6a79a7642f8c23c3cae24c560ef5bd342b07fe4ef10b7fe4f981f0d5e099b1fbf1846421a0a46fbb18560c819807250a1a3bd03b23803f27a2387f8e4efd45f70803fde992852f42ac373da84f62706140f9a61cff313fde422d0f3e24c29eecfc881ddfe1c0a61d3ede91666d440c090837b0c5040390202f75646b9b02c8c8fd0392f422a8ea467536cabe73f90a08155bef10483b8afc3c764104a3bf45a0a697417a6f8e70ba76f1080a6c5139941b918d92706ed1e8c1db709594f4e1c70dea243a69c07cb5c7cb48b9821f568f8557175dd820ac295c2c78144f9fa8a76d67a6ed9c3954c6264bbf077b44c10cc5586e8734a3a1c33e75bbba8d82359e386a5dc0c6c62bf38ec2c81370a0b160c185e2decc2d7f4d2727d5513e9a349c105fd5aa29ef9621465c4f9e709f9e67022ac4edebe8a4fab9e4a98fec33850af98ba6c2dfb6b15414489177db17292dc66f934fde8fb4adc51b61d67344528243683a4e4431683b72a9c9174c13ad79d6d164c6f30a47b6e3b09692f04756356f94c133b59d451cc3b3e4051054704c0e901e097e2fac0192d9126288893faf35f5a5c95571f6fb27238da4af89c31ee185bc0eba2d6c15d5648a1fe5c663924a3693a7f1e01bc078aebf9ef0a9892f51a5db812ea3939f00974013de05c55df94c85bfede7f0c7beabd7249e41f75f9448940502edb193f146be1b9654dbbc308b17c85f4bb6f402dc27d80996afa5927eb7ac4f5e83a0c6a99e5ff865b0923844300da6ea347baf8dbb9ad2e0bd30a0df2b0d833120d07291dace9e8968c247959205282fbc349a932b4d39bba206f012b68d9bf87efa06e3092c8ee330651549b59a0b4e9ec082152ef90089f72d2911cd99dc6fa318c8ec1330b70c774e2c14a083a64c81159441cda261040d4bc64801a483b934d8148609957f93459aab848292f76f5d257ed761bbed2b148e146b8035f0dd41cd881fbd38b903abbf95772c8bf6ec18467ebda54140ec3e3c5437038b04662b8d3698258f5e0412abdeb30596e3a1df11a303f83f8749232ed9c041146fdf449ccbbc868bc95faaf09d9675a1624577ad0b28ee0808754f12aba44d57f16c609d45aba35a669c7d534b19891ea3f9c80d4c559d8315f26805753864cd45c0065529419e01a8c7515ee0e6c1f3ae3dc4ff64e4cb505dbc4ffca487ca0f1cb00b74194656f98361faec617a7543d2c024463f5fdabff20749bf368b23ee29c13e61a53c3432591bd772e994e62027d701a42abeeac747ab87d62394ab34552bdb32159036f0d625f340c6b5415a1f5b92506117bf183198a90ac883b0a4009ccc48cedbbbdcbda968d50056287050107445d122547123abc414857ec032fc6ef2c867ec5504ddef1791bf5a2c52ac7c91de6ff438a75ef6d7814fcbf857862c7753a7adbf696e9ea07a8d6a32c1d3ce965bd3d3c414ef643e8fe1afd6ab626d2753e203bff392d1f055aae5e891f640df2df9d4d4a69a728964fcd7ccbcd10bfe62cc6d82893275efacfc3c298055d794adac473f5654ca71b4358f9e3d2f26f257d6b53bacc3517c032ab09b116bdd379662aaab3d931d46e00d4112201b51e5012096bb3715296c25f4d5d73a618bcabdefcfd3761db6cf11d43d730f24ae8627e5eed2f7e434b7ce19355c090e2bc2c717e1ddc4a9327da925e8f1d0e421a3cc548b0249e5c6e72af8bc435ffb57ed60b11c3395839760bc689dc4e8488eede56397dab6adda0c3a800dfc17d70eb92c46a9e4e52c6b08bfdd09edcc05e7ec27007c14ac49a787c710bca0a11631bd2da807b09ce322500dee05b1243516577a1aa38e468b1a8a4866ee94fc5632b34ee7d2b26808dc4b65966057cee4c0445981aaf35d27186b7a589fb553df371a5f746209717f54314a8b6f7ad2a72b5ea94f07eab342c3e4f7ff04492e0064b4719ec13b6ea3283767f3323b045e5b14335f422f01113a39c9e2517b761da5ba63698c280f379048800532511e76aba05b9f2d6dfe2943134e17e460e4735cf5252d4776d9717381d74eb8a560e54c0cf1690e35421308dda29a716c9ff06663f945332e1295321a530729b96fc497e8d0d18cb496a5ffafe037ba44cf5f93806ae824ae6c3a8a45065f976999d550ca9f39ea46c149c2270738d8848566e37f9c93bf65c8912e0e443c1f6cbaa196563093457bfbc99d38311a5e35df4a3546cd5a1493626a4a056010c82b58071d0f954ed33d3efd49b481fed94f2eaa93bddf2dd9fd172f62244c9dccea1f727207ab017203e70566e1f4442b41452716e2ebce4849ba67779a8d5db4cca10b1969bea9d1b3fa25ce2440e3380cb7ee8b32eaf95337dc3f711205dab812ce02b260ec2cbe4bd5c8610eb90aeeb4a45a4434c85ae71f7b51037ce64eba8edcf0e6211737823fe27598c6baa8bebd5c7b56f87be9338bee9c3dfe92adef8d13104c06d68c8fffebb24181a5dbabb03c76302aee5625c9a4c5d5537c144882b44a8ece30bf0afbb612c1e889b3ada9cadcdb7c6818d24c3befdf40c9fded27e8988a5ac75ed7bae56f2856b36054e81cf15fea97a732dae66c19c646c1b3b8700b30992dedae3afb54b60512874d3b4c0a85bf6537a878b0fc9617ad3e6a62f17737795e6ffd46ebf731e092d0cb008732409b873f912f850fd73f5ff42b072cc4dfea8ae87bf89bddb4a1bfc56aaf0cfabf5b2fc7cf68104057cafe8d6dfa15c05c8f0912ca6e9abeb75ca4a6273482e776010fc8c04a62578d4f16ba00744c2f74980d63a2f6cf7fb2ba759a7d89aa193051d1776b7ce5b084472cc8d8cca63bf6dafaab99a23d682ded0853e7a040b8616aa80190684af094a92fddc56436a91288204c1d4288a99bee1d9ee219f8d76182219c90ab95a444092c3a49b002778912845e73c50322c0c0212f6a1d85a4bd27ff7478f0de66c703016762e1d7004ba2c71355061033683207cf288386b26d7fef0dd30a1a881ab91649242b36e02a463330ac1dbe9276f1cd3357197d735b08e874a28b84f61283deedd9cedde4bdd8c05ce88712fbfd31487d2456aaff9c9dde9de0729d044418f7513e21c32cc86ea42be7b3f9e208db70dd20d02ccfcc9ee232c951cf80d0f58ad5ce0bc29cac36aee4b7788eea16561a40cddf715e2dd5e040879d9247c218a273dc69dcef4f18accb1360b0908a738c6eeb380cae84d44a347939e61b338bd48aa04c256f815094d1e6b969f74e615af1ae3fcb628361921c6d48ad1639776034f6484c4b64b7e27a464241292ae01d2cb2c4a99062af93591bd172d218bc4fa8e415f1f021d342f2be69cd46719e4afb2bf3a0ef5bc08af63e95c3871cdfff62591a2eacce595e4a963ba5300b540ff8d2db1f3ead1d28bb40b540896e4d725bff21b0385c5738a4a3c235aad0a4f5233ebe0cc11e34a9388e11083432ea114adfac4ae2ad8ac909bfbf4dc8af6850d7ab13c8c33a0c72162131b0474e8dd2a0a6942bc337976620a3883573560ca847ed6714b77024a97010fc323548382ff608253fd6571bafdd0bc3390e9f08f1fd37d837e3070af7fad7964b55a31edee27062f208d0f13ddb089f3f2474a7ab1c7c2aa346d558a9a294bcf2725f789d11e65858d27d0ceba53e79d314c935582cfd11f7de537d0a08af2a47f53a287583d13e3f1d53e69ae82549247d939a7c57559781a872fbff554a108a7313e5fbb9a8cff590671637b3e48deeb03a4914366facfa37a5e585e0c7db06a29cda46a284d5a57174868c7fdf6e190d4e7c8d7948a49bc801e36f986b4e4e152681af50cc9a55b782a35746c4e3eff7d4cccb30fc990add31c5de307e05b1111b2b9b72ff48efa40392f48cf828fa694de896b3386d45c17f7bd3b1fe550e4f1d208b9188047a865800e63e32d8b6ee0a0dcb3a1345ece71a151e64ab24f64cc2ae9376f7a5e0405b67a8c89c4eeb43cc21bb82a69cd8aff9b46bd9b99b932a7ff8f8c370333b743233d9fbf480c6b89b9c95618f7efa4039666a69c900e48d9ebba3a4eee0f11002e7fa22151bda037cc909da8415d85d9944aad3bc2ead56d4274f45eb06cb95ad4f6f478a8cebc0299211c0d3bfe6b547b25347d5c48980c5c6c64de1896fdf5c077f72fe23a0c80640236c8763cc4c83ec5ba735cdd7730fa15555a8d3ddbed246ba1fc82b3f5361cd2c59dd7f585ff47e061e11312957d236f2e79b78468b6c2671c316400d30d6dbc511b454e62df0b0d77a4d6f85f0e50ee8986d3160688d1ceb486f977cee1dfb39e294f0fdefc5484766caa47df5b5ba31f77fac7af7d65b9e8be0ae088b815db85c50972e95464c9c2e15cce06e20e705991c5f5578bddea85fc59e003741435724b9e7b0fb33f148456dba1a9239bcf184a72561bcfec6668bfdc7aae93332d75e4ea17d66c3d0326d48590892201981c89a502fd1f86625c70ef022f7f7be5d376140c1eb7df349ed4c83819a79ffe69a65c4f143eb18185b15d1f488473c4d763c0b3f7845ad15971d77a4c5ce0cf8b26f316f07747cb7c1d11981fb484a5e6596a2704555b7418645de0708f655f2193b0d42e545e4f8ca068c0595bce23ddb25bfdb287908ba6a50f7dc9b4935563a24352f1801a92bc7426a2ea70215c641bc823059007776298516e5423c448c88b457c25dfa9fe65c04b3cc5c3b2f9ca34e2cadf29c4ba11e2ae72d2d12a820059df84ba37084d3637a533879243eff4e8c2f050f9b2f1a8ec44e71ed8e2d85b929e780e3beeaae9823188aea28839a782ce0d17b2a63f6b62d4cee100f431747b9d4136757a0266eedd063e881a532cc47e01607286417383681ef64a784adf0488ef6b08824f30764c4040f970d59a5243407734c50716bc7e4eec9405728865332eaec01005402cd4d369f638f80a67d92a3eda60ec944aa110978f229b6d0f63a43900e272ec3ab2ad02651073751368683b60cea72bc6cba1b3817ad310dd5d871ffc0053ff2c11fe840e28cfecf6c0a6d7a8e2cc2fef42c79cfb0a52ec05a66c36946b2f7b486b52ad8673f103648213d0f54f22c47d50039b57730305a1cef96c2da21f967a49ad5a6fc34cc758f33c37a304e0dfc9e71a34df3be38d8351b7b8c3f1e0e63c365646810c6f93f15e31c623a226dbc729d204bc39ae8b22fd31d2ed18ee3ba1de710a8e480b569fb094dd0fd3b33722d5dc696245336ecdbe8d1b8f50dd417c00632ea33eef8566b6bb9dfd6dde8e10fde4b1664cb50ef68e9b0554aa67703b93ecd90569d1011c4adcd6d25d737db712973e010ed3db8e224e8e74b995d8aae80108d80427b2f9dbc17269609b1ea623ca6d7d1c019c10dc823d5fc2491a8d0191cf2beb2c8bc856c8c680f403d6f0925328d3211b857d5ce7a2cfe5ba4ddcb42d7933c479e7343d67f51a6faa61e11984fb439007c566ada5301f3fa1facc88d29cb8ad4a2a248e078bd7fc864a2c25a27a4d95096476786f4beba50bbdd519f6edceb1cccd6946f7bc0414afff09ae338e72871da2e8926441c368671a7c443fbdde38580be658656678687512af079824eb0759363314580b19f328b57be760dba0649ff688bf190722569dd84481d1916b480f57ef0077f62d0b28a53e9119c74312fe93a3001290b0e14008e80f34e88d04d06d5c8d8c4c2bfbbca263bf947545082ada90ae20649d11a5fc9e42257385faf71ad96a0e991f3c23417d862d60100371729a99ab23e4e194dfe11a52de453444251d0d0a1e93cdbdef67a5f4d6e74e3bc8600305af1d621ef06d2cc04962889598a810f203dcc2749390e68005d0d81150bed77d79eba2d70c9c99614ccdaa29ed311ded75f53e487ecf93c050a4c62987d00060f628ebedcd7714a9c806d1f97ff658d530be78c6cb3fc61015076f79d1da356397bba58470a2ebcd7ef34a9d7a677fabe2f5baf1f76c9a4e63f3a67bbfab320c5b893ad388f7dd785d498bfe2f180fd5b2b01923f41e2eacd7c359fa4cab23dba0d2c734247b361a3f838c9e9966003bb32e48f5c867a15b6e67bae305b723dd0b0cfc715bbae5a4d6e4339a19d66b02b719381793db9cd173928b1edda33cd64f69a53920d806a6faec11e058199b24a8ccc2ff5c01a7b85da7a5c9cf88edf22130122ff762ef1146ce0c3042f598815c463d6f66c110caf6f7d3b1cd8602b390fda87c6f311b20e9ccbdd9b87ecacb0bac26d85e1e603c080ce30ed3e65903301f0d10a074d9c494468b4b89d6bba5806b6d52266c7d81179d48f0f7ac608b40e73cfee3ade8ba34b6017dc3b4fb5e8ed66910cfefdb4ea5edc64b7c2c3a6674152622f9701ea18f9f44ff48363fa56d66b0476ea8f2bb920d51cff22eaebc6fe3d90d712d5a23b10270f73c0b62e4e4bb43c6a0ba01c559aa1e973d2484d221c418b116235099826198bb5f3d2c7faad3406b2f79ba97a916c64f5158cf86cfddc7ec1323551e3bb06a43f6e6e50f56f89d0feda1bcccdf102ad971e5020fca5d892104ba87a2af2d27d98b4411c1da4154b4f0c61a3c1a06f280f8753e94a0432db1138f0dff114de382ae8d4794084f25c82c4d41751a67713a88d950bd07952e00dfa435e6950ea56bf3a8fc27fd83a15de862e7dd12cf8f5e8b03457eae4335bf782c98ba953cfdef824488d5a928ebf94c4773ba2ab6b816cba2086062ab8b4b570e2af4eab7e3c33bd5d9a89f1f5cef51114e584507ebbb0824231c4fa6e73e51020ab08b735b0e4ab8933651a8b0c80bad81b63c6aebf68c849cba61ae646fb32b76a4fe38a1c03ebdb8d28c8246f7406cadf5aaa42a42065417d1844e117c8de8aa205d2e19bebc8174e09172730b7ef613269b62fed1ec7cb1b8ac303371d598cd3da7ddcf0a2d352849e7556fe50401ae10f5e98bb95001fa2f4f35ebd08fdd314e81db9bff0d9ef81abfca859e574fd9b79e0b54d87b66d4c0391fa35494230c18a7f68a3034264eb04cc8301e853edfe74b857b6e204c8780b15432936be6f28b89a4f4552ec73b69fb5906eb39145c5a3b6ad075b1a90c72f0f51da9b8949df86a01aac468c70d3fc0f9ed56d6502d7f3ea43f37ae5c45834f5ee010ce2ce957accd0f52a3b095bfc85ec87f80d43b6bb419cef8236a996111878223b8064d080a1ab1db8ec8fa1d74af3a011ed7c3f44ae841f3b0c79fb3cfdd26d933650a895e96deef98413b0ca855677af5b63bc81304d2e75aa2856ade8d3cfaba0f7090b9c5be6947b07c69b1ed1da5563f93ffa7eec3cdf9ba6d34d16ad902f16021550b321371f6d7602d4197e2bdb8851c7392a1348d5bd2f9e9ac33c000e84d6e3458e38b6ddbcf9f3e7dafc68dcac585f5065f4f5f1ea5cbb1e5021c10b00ea96bdaa7d35da284fdce19355d8558ba1c3fb2e0332c0236a4f9744c41c285224f7c5f38aeb2a53c04c8ef28d3492595547363adf1e051e735bd2b44e72b9a7e7cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
