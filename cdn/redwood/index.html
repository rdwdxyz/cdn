<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9853c33ecbd6f48694f69e8882c00931cab1368f768bb85a0f2af453d2a5b1d569db1f5610436e1ce20d8983db5a4299fa8bef131a45c2fff6a2259e3310095f672870fb6e774ccbd884149a353686dbb278d711e91ac9e27c59b420046a60635c1daafc9cf69deb24cf6fc137411f75fdfe1fd5654f7e6ddf9fd0647e7c7bd25382b60d85ddcba655c86232b867057d8394b9909da947fbf51cc6515b110580c564ea1debb73c83c47137ff43ec6ef6d8a41babe8195be71eecbe07e3bdd032035345d705d5b6654b314aeea951f5ce5df3471dd13adf5953d6adac99c048cbec68a654ca7a6aef76d5293e5da3beaf007cdd8df1833d3e4be98048bdf920afc2874488a047ce2a1ad78b96278d0464de4e9f3fe81c55a64047004ef4d4c673684f0205d51f863318337f7adcd5eb7a32c7edf9f428a9832c1b5f5e1e1c997f7e8025df9cf0817d44ca466248ee52ba182914e9b33b1ca49d25440fa4812b2dbb839394d1b30b0f7395785b450fce7f417fa7073ea717b45a984a8210ed447cfd5b052b579284d68a8ddd13b829896e64ccb25364e906e02199da170ecce5e38ab6132fe6d230c3f6e3799c6696beff98fdd054e94c325857e2087caa2ea5ea382096edd3c1bb6d29cfcbc8e14dc946a668439396a303b201e516e7085fbb6a0146d8a59b1fb94d3e6c1c0d6efb739f5abf2ee704dcc6b4010b7d31bd2bb66c529d12ce9ad8a61ba5fa3ec131185e50c00374d39144757277456c52ee2615dac8910cee22eb97fec3174b9075a501712c340dcf0b0f6a0b8a3b36691d326e02e073848044defa90100829ccd3f2e352de87f896eaade36c7a14574b9898e398433932eedc684463e335ef3b3b64e526680ff14e6a1652c16d5c6b29bd27a68de73c5e4468c36edcdab5647b224cf75c930b281b75fac344bdd9ada22afff79590c12e23b52761478c39949e47c94efd7029e2be4887848b3b5e1548048126c057082a5ff2e91631fe3dc13d36ff04934f93830965a71f0d3492f8629cc8824aca182dc0ed4c864e5269d36cce7e93b9b45d599950c94c2166fb8d57bc9f249b812d63cf38a2bcf04e595244c09952e4fc5ba1a82d4e307ef4c7e1905d8d8bddee30de94b86bb73bcfd77b1e2f13642db4ec63c3a101e81825e128654029dc75e345316bbfee17a11ece246d7bd93e8bdf01caef4afbf830ea281f253b2f808e2ead093cd8fd07489ada1fc18b709275555ae0aa64080b19847e22802222de90daa06e6af9abcbe20c3fea3bfa7986c8dfce2186f18ce6f84b73930ced99d648ee69ab29ecda3c43576319da52465f0e096ad3a7bb504e757ae09b6942d72159c097a79f7c3edab2b84c2fa0905f1401a27d81e1f5c0c30e16f4ad1190f1a83b05f755a87926ba2d92ee4a5483fd475d154818b8613bb6fea3f2318a4aa8a02aa4142feb2232b855c94b2fadf2715c45cd0af2cc7dcfd63505f3082e5cf6a72e5c64853bab4bd02d16f988118640ad3da972988e5cd3eb7f372b848adf3fbe8192dd1a0abf38ed3a2609a6de17207cbdac472b034f7745d5cbbcdb66f23a9e4a2c9dcd3584e5ab6339235cf4482b926161cddcc320f404d11f043f5c85884175967ca9deb25509dface286541cc778e9ee4697dc6c7e637d2484b5164250a66377a54ba89403199a9f74762d857f9644eaaedeacce97546b1d67d992f13d39ed28f3d7831cbe4481bcb135d7208f0d7f171e2fe1c0e8cd95b68f51d581137f8b8dbc92a5b4c752ccdbed14948bf70f42e1c16f6c5400e26d10be529baa916b4358f1c4222b2797767f50589ff119770867b09f148d8e356b4f94d74d2f5a5ecfbd04a219a7cdf11fc6ba233c64095a5225bd72e45464b63ee662b24c42fab35aad99e7777a3db27a7f34e2c25ad4a4a0464c09670265f6172838e8755015241371b41edf34e463cb87f48ac982adae20b5f517d5783dbb368dfc017d55527ec4bbe9ad79703aaaa18b8c15b008ea0e48ac3e584ed141dffe55af0a906becb428469736caa29682b21261fe81913eeef77634a195ef1947dce3e08de54091928fc5e3829a682ff1afc8038c616cbe2b5aa2d73657adc68730ec4390e6752ed3cb5fe1b1609e9b4ebef375027d967c94257a4ff9720088a5e990d3e30d9487b59b67fdafca97c8d21b0aa6465b57f053d499d14cb2382e370e7e6b05f0f0f164e67cb41550564d1f1a944840178330f066d906f440269b20d9da8138d6cec6a389d722ec94986db956d37e625716c4cc30d3c44fbe6af49a11f1ce6808feb596c1e0cb6bebfe895c5e3b359fa602fb29579ce11c1c86d1cb65a9913fc2e01b084af76684271c1f1e00477bc6554b6f262245ed437c9973c910868d760957f0c08c75a651b8f114f1f9495ac6df43835dd7d447c36e862f9849fd47d2cc87734939ad1818cef82804cae561c0adece3f8d5374d528d7ccce9c73a1f30ece69bd3c595991a4e176d628b610f47ef406ad8c76cfd660a228a42eb246d8ce116cf834df052bffe031e060f6276a1f76272a68e91161902f2599493a4dfe8185240e986da0b7c4a6c49d3756c2b8e2df4cc0c2268f2acf9446e9528b004ab0baaa430a03e4905e6306cfd90fd6cc9932ae51098e8a467eda83a52b784b762da6e92070f816c19a75433a2445b90ae4e6ea4a3debe871861acce48d66dc0764297106998c8107118254a508cda9fc3899aab933afa0398b6c2a2c16a1f342ea78701f2af8b1ce125eaf8f4653ae59390544be172e829668730cbdb26a71a80f845ccc824b6e3a9c70e8a2718e893ec502c8e5bb394f118f49bb03581dd624068d9b3b14fd70245c7beb2bb631642b3800ac569aa547c890eefb3863cbc6507c50f4b27dcae96bb5505243b8c5cdc24a55d81049eee989aed89660be3f0a12c4a68581b6461665c3d282de62520932d568b375d9d742c7ee2f74117f01dcbf40a6717c0f3cb7ea65644b02c5a600c26ee2dce752eb94edcc6f5c77c10e29960ecd62eef2024683da95eeff65431de0d990881823fc48065d14fd7b0819af689f129dde7c56da43a713f60830a6c4a6fcce1b6be53118f17332eec1feede4dae77808b28b192079b52ca0a7ac59b81fc42c2ebc346aa1d5f48f0c201795a586b7467cf83588fe9a83396e0d8959a4c279a0ea2f6e004f94e597106821283d059475c285a58e261306c651f76db854d3ae78842a5928e488ada2851e6d6bc95fb58543c305ddb09a1da07daff7846d8cacee3c9235c6bff3286c5f77767e96c6ea4a1552d0ed43670af40d096b3b964f10760a6518687f5f76d0ae4e459b63c9b8956f9fd10eda786a5afa784ad32fb28d4562c955518ab2049ed90ee2fb3b102e16d3348e780a2d58da14914f5df2798680267e3c6603786a4e3d09e5d99adaa44f69e845065c03c96349850bb9dc79830c411c7fee7941b41f8a79a86715ff1ba543303f6005d409f482afd1b23a4e7a08c1c3fa950abcc7cf219381b4f06530e034d83f86ae59b130d1f6d079740ce2de7a2d8b07ff63091f09c4fd35cce8617b0f6b66d40f422362986b2030852c3a188969bff09aab3a41422e837f771965611356c3071e9c4daec1bacf81605a061c76ea261c5abf19052af4117ff09dee6c93697b3d8c715e950a742d0026421846641eb675b7fe70146137e3dc82d87ec19755b8ebb1badffcd98620ad42ba8f4ac444f623c1b482ffb95ed15534a84e69485cef37df1229e8136bafad358437e2328ee770b47da3593b2085b1bb3a6fb0f9702ab2bddb1f0cfca136b964bd93e2383451364d033b4ae8f2b23ac6a9ad710ba220d102767320c8897d88fe0adca5c022ac326d55d040ca75d79af7f8f3807d4f51a6efecde1fe1564ca8799742963ae635d0f54890a116a8cefbf57bf68f10716efb7fb9cad5e6bcc1d086b4862fbd2d8733c4d423f68975fc43453d3ae87cc3790c474975ff66cd6c9fc47856ee92698445359a23f09045e9e7e7f7f63f2eb93b71af72f6b700ad1ae8bcd367a81677985f14fb8e0daf017e62bee5f1f4f4e52198e0b6f178652ddcdde5d2bc2f26789dc82ff210137b1af2b1ec8d97b6fefbcb8d92561a5b0f239a16e8aaba1c89bee304db07dd47c6f83f7fd2038e2fdd93aedebe2d052a636abc6505f48e0d6870c0ce477cd6afcc8c5da03299a3d2cf723d36143202d995d54c64d52eac13813f04ae2d5a91aafc3d34ac2ffa7ff849e051509ef758f5ea5d58f584b0d9a4283426581812fb494cb5355051777c8732b587c8b94228164131ecab0282eff3bdaea1c3e183b6a087e3d756c1718a11ef044d7225cad426f1cb36ad9f13ca614a384ca2a08b1d45a3dded3923caabb2ad2e46212fb2bebe89d239b718ac7fb9646969b1d7a49b625650c1a5e47c9011b30ac798282674f19b8e404a11de5b2c108adb771397d018f3d361cd9ff22c3f59adabcb4fdd54e999f32de8e393b00e7f7643f6c16f02676707672b65140a9559dbd84efccf209987f4b3c1bab0a61e9238e8e93228e56a73b3ca9b9c47810297cd58491f96788c792325dbf3ff0bc14d46ca1f09d1a1abf24ef35c020e215adedb5dcff95ded4e88ca682b163e470b4cf71e7058398288aa2a411da5f2ceb61697ea89fef603b112e93693097db54e37ef52e5dcda006db9f390d7b8ac03113f54dbee0c0214730d6421d794712033ecdc14580d68b1fdfe13b6598e3c500bcc579df38482f40cdee2a85abcad3a59fe7dab6465107820166a100f84835947f6e4e6c57ecb20537f0df5d34de077b24afc0639bb260a72d92a99516e3a575ed5c9ea51fa08d18d518165b3cfd93a0a20028f1cfca3057fdfdb8478c6cf46151693b869455042986a5f8e83a4ef8695925b9b7e77c4dea13f54cbe1c7cc0252f944a91fc8c2f052d7960ad9deeed4bc0e9f47a623a6926fac7a6acf5af9b6e5a1c73a1f1e2795091284a7f076219d3337ce5888887855118e89b0f7df210aa6c02596794997c18493e035a5ba0306d305fe2c2d3a5663c04d4e7267a2571ee7518033daac40f5267142916dcf1252ee8a6a365e2e19213c312e1dcc24854efae246027d301e7f180394bb20b03a7841634164b786f00d40c30d4fc27eb858e2e49404a3047fcd949476f3c5c72078e126297cec4ca4946f83b9d3133b56bd9c544c76f701225e560c6d3602dd6598ecff2dca0807fbe4f74d870248464ab8dc6164baf9ece7cae1e4b822defb32ef1342c4413af4e0aeaff8471b44bc62b1f8811c048ba6dea18c2c50fc8683cdbfa1f240ed5620e03469d8cb8a76be8e0c47604244d61d2c004fae71b0d959be5d4ea196c3d0f9cbdf5231ceb1816f7f766fdd0974fc4b8dd221a9a963101efe361c4382c9d56db8db7c970175ca25c563eadf1eaae42b92528a5eb9c8182bce888ed421161cd8a5b4d8ad0419979c025722fe028c2c8586b8f1e7855285a71acf466939c96527e7ac772ffbac2502e32d1ecc10fb33a0950758884b7d527bc56796938d46ae381b9e5406065ea112c95363efa7ddc99679468f5f02c24a6e106e9ab05492fd16dd2d15824e8c9489666ffd769242c2e9e7a662549810c5264dfad728c58c0ba23636435e9c965e493072b59da4fad076700c650b7fd651c42af5779cd23249c9840195cd77357137c3d7379b16297f10ab36a166a1752ec677ccb118855285eba2aaa987eb2e03a1cab33b2e9b46105c4a23168313c568964b86999b083aaa7b42d6f426ddce0538ae336fa76da60f7977b2188a3a7c34612cb2beae035de9c58d6e8ec4ca41abecb28f47bd7c25f6833b7dfd3d6e8292ac58ff6a2c7933066149c1d47079bb4bec8ba9dce7d0972a21b4fc758e1a819aae59a8c9639be5a9a041e90653c94c734ecc2ad885d32fcf1412a98c001784afeea2afcc645073c7d37d413562fdfe2d94dd9dfb4e18526f539bca20b3e5357ffbed68808a967943354950270f02d9cffa01931940fbd10ddaa2718c7b340e595c76a0a36b2bf0678ec11d770815f4bda674b1ae436c56b93473f24d5c07ae2f9d168b4be085d41b4ba3f26bd5d196c9962c538204dae7a9bdd6e474744c291140bf8089b837c25421f9971b436ed51d3da79364d2bcb705ab741165279d172ea3e2de4678953128fc7f977ffe3cfdbe36ecfa7744753ef6f984ba3d52d26f53794a303543fbb46a0d99075ca95d782fcd6efedb7a1eb0fe75a1b6b563b9486c32008c2d48f0a89a466ac08cf8abdd4b752c4da12d5febb4709c21d579d9f958973561d8cc196f3f9b3487a4b1ae6f931a6a807a514fd75e8404aacbe629bcf3a1192822bb028f46d14a4c57e4c2e5a664cbccd6d6b7febc09ce6e6dd14a0bab3beaca5b73ab8ff4f24b5a2812c82e02d251fea1e6006e76370b06c492336525cffb14fd52cf2f717bc75a8161c00a5b708f61278d9cc30ceb89d5b995ddbe1d9fa76a36fee79a84aa309b7f840831e8f00b9bfb9dc91288ceaf724358e28a661dd0f33391e7f696f9c010b1ad18f99c5dbac8b682c5076f36b1220a6e02068ba4e5446b2fa4c728a2fdd798ce95ae96869a971da5526b229c844dc894688f426acd1ad4f9e90df82cf0c0fffa95d05c84d62274c66f21da146b563b7fce1c6a2d98f63773e9961c1eb0720fd34ef8a060cb38f3172a9e71beca45b84e541a395986e4ea4889bc419a71b175fba9d9854a73838a5ea62a72f85868f3bbc95df8c3d06544ad5b116713a30b0f11836313bd1c84265d659835dbb12f8cc5c99d36a8c9efea1d700b65f8b6192062d5662d8eb31ab6cd0a0e970d96275661ff59fa74b031de4e23cd5bda82fcf2cf3849257e1e114499688461c5b99c54de08a43443ce5d4f535eee33eb0721aa4e3279d5776cfdc95beed3fe387e549c7f3e3413cad6f9abf585a06199c0d9135348fe48185b167893130b24f1d07c81f85533a1b8c454f972922aefb8e7974c8cae98185962de37640bb39227d13d6fc266fb421e568470bf040bd244f938f15092744ab5e5d3f903cb59665a1a2a7fed376f41276b25c1dadebbbd7cb2bb3cd3669e5c63b42ec0202f7003a193c7d3ef95b348cdf8b817fdd51c9eae913a41ff7176b10e609a0ae62c3f31b459a4f2085ab0e551a78dd245a94637c67e0f58bbaad5138b349da3fb28550b4186538265f15e7ed580a075eecb472f97f6230bf6ae429553c1ca579a9ad04788c7d3f1adf34a130d9d1316175e769bd3bd2007b58101703eec9c1c1b37c9eb82e667173cbffec65eee88d2c6d113723b37f97e023170a57d999d89a95bf9d509cb594ef5592daaa29c5a2ee65abef2cd8a821288dda5404bd3a4de413c97f07aca04aff8659cbf4b662a85626741c20c02827b53f07c51e7c824a24f2da2968eb0286e8d222d951e48a2558dbdfe2f899c7d56f1aac1325b83bdc7876b9aec131cb6538b82d1ee7bed20f113b394b171b3ebeca9e3b242d5bc42a25db36dfdea0489ce5df0832b3a1f671a253190d8f5121d52baeaafbd9c87b73ac77d7ebb297299e230244619af5f72cc922e0bf9e4f4becbf146843b15d494209b7c948c28d3699efc5c774c4fa078c7b3e34c3a9f077dda80239d5ac052b9a8cc10ca4aee30e6a8bae8c32c1d569d86c75e7fe20d0bb52ca15a9c6443fb7eca7566d6de28a5d78d0759b5fbcd9353ff906f0cef834d636154ef16c1a8986ef99ec9e4bf227c7759a2d55c4c05873dd9a4e8c6aaf96798b0bee4d0712c959d32f3078033a686d31285b9d8b7c4c8ff0efec605d9f1228a90528967d1e2e7696559fc47e58962bfd8e625a1ab34ca85de905f0c674df4b6ad27243b0c1c7dd532542bf4be788561786012ff42f96dd8f0efdc7e4278a5d8f927804daf0e55f23b26c01830b38e537624f7a7d45e3ccd86d29eadaddd4e866612d31639de378535eb1f0a19bd6d53e831bda142cf294b3cf78ef7a11e26282ca8f760b1955c8321ba3832a76bcb90749eccfa1fcffb5fdb2a65ecd8e0aa3ef86ddf144f681bae94c50f88f99c7448d610d7d3cad236a486740cc15ee136445bc4bfb391fb4de530a6ceebc8fcd269a9e129efcf08ed016037516bff724eb5ed399a8d5d505dea2f91620fad0c3df41e93ea64d38ee030d711aec1ab59ff7965ea1e0172345146cb82480d6e94f291293c340bdabb0a3d1f0f64c6cf776f59a056fc59dfe4328763030230866a21df4f45cc3a543a8f26a8464a8f6caf1c34ceb3c87a635e6564886c4dfe699f0172e0265e10bd1a1b1b17b5b1ab5a25830b454dba0bc09e335de994ea8b34ea11d71a532c8786c83b1c713bfba0b606e268c4f0622396bd2ecea85bdc9816bfa15fe7470b834e98b56e2d8039fcb9214122c9bb32ae0c70afa2da50f70fc5bed3a5f1703c2005e0e0c9286de71d5fe69290b6540af74d43581998bf6eb638bb78693fc7ee78ca351ec5ad70842952dda0c3fc3ec823251d96b9a9d1f52698af363c308be25c682e8557189c55e2b7049ab163452d5fe2a63313ab920d41e09c1e404ca08e25b6beb60fb28527123a0651fc0eb8879f94d85eddd74f18b03715fa42799bd054906ef6f98f568eea28b96781a9c02a09964d72f3edb80f989b028364c68b226c25fdaa12f49073a5fed6ef9480f3f3459768c25800a062c427274794b2a31ae82a0f600ebdf92c7ccb1a454b5d84c90d021d3d52dda9b074f075de5253536b8be54696ebd60f802f75a2c0b6b51ea61eda4b12be8973688c81e0b057d3879b2d128e021ebc67b96a37fc7707256da682a7346a79a4d637c90f79770c6d1653bb5291a0102888b58d6c9d5d85b9b46bee0845736bec07c49e0900d00b1a94a8f62595bfe8e956625ca22504b1fce85f3093581e18d74e249892b5d2b4d8026d8f7e49ff97446c69efa34bcc03b01382c43c17e11e3c99be78cb7df55b0e82eae7936d716b301a177b288053ca4f9719f375a9d49a1ac3fa75b854d9473ab29b81e36ccb0671550167f3319c4d47c4a35e8657bb1b8a15fc4b7c7e75e76c264487b5665fb1c315b1e293237b60e31e26d829afcebb12e7f2e4add14c2134719e60aa8b2fc5de69545567f368cbc4afbfafc68781af2772277dcf22da1cb2ec04b6111b1c8af448e64eca088453ee92792d084be18626bcf1556d9a2ff3c3bdb021b3c2fa008759579b04e844c6ecfc854c28d10e4ca84a2df036402d2dfa85c3a3b9059e35300b1f5433c453497738381e08c6608ddd6a03627ce8644b00457e5c71cc2b7031c7d3ea205f6c3cba476920bd0e98e2e6da47f3e834bf923204637c195a4cb4fbbc01382bd5580d42d5f3d9f9afbd014e224377dee1b5e834a93c43fb994ac683fa350e2566080d394372ea2f3ff6c7c00122fa9d6fa6db4f6ee97a672c1a3a1eebefbc492e79305957e8e1003e8ff2c1ab01e02cbc19f25a2fa0f0fe9e167deae3857ef3cd57099cf16f7b45137e665a1bc6deba7c11c75ac49533251c6e6034acd35048097924f3fd3d36ef6fd6347b217ca9f45866e05949177edf7a704d394514984633bd5e1c5e3bce809f7cfb7f1fba23322fa077b4eba046a3b39a0d8c2020991bbfa098a4fb3a0907339291735a96d6ed10c52b905a37805120a798d0e692a10c6a3d4a243e63fbaee04b28adc5f6c3ce319d84856adbc13baea6d1212fcd375b06b14821c3cd9991ab9c0f295665dba92f2f6d70ded58e5b0bf98f982358120ded075b80c70c27a244c78b5c9602d2c5c6e393854d3ae27c66c165c699293a4276e560b5e106806be0b7b9946ef6808974d1f12b03127ea359f4375190c2fc9e6a6e7dec7576f8f20f5c16a0c5beb475d0a5568e8b1066ca81f7608de1312289dcfafd30544fca6c2109a484c96e2a75acd0ce6fef07eccee20c9e70bba0022d36c0b619fce31b69a2511c21f5a71743f4e46a31cc57910af08af00dc672ee2671e9205c3fcbd4995697e69c7f28df158fbeded1987f92706716837429d1cae204d7ead3fe936c37e1308a0c7e77d0d55e849fdd299b55f2e1b744f341350074c0a0bad418c584ea46d1dabe97a243f709956b042d24688e25482594d774135e02e0df3402e0758348ea1f5b7ae99d8b79b8492bdf9e9fcec9253d29455eb2ea91b3f66f074afd99beabafe23c948a8f05dd0e8aacde2b32876aa5acc97e2859e6f3a935c19e0be90298958d8c5a5e5b1df006785a3713ffd9fa7004499d03827f567dfea4cda3a5a8eb738ff37f9612d22f2000521c1371a58f84a42a1450f5940f72b788b2cc14fd60340cd3cdc8175f1b85dfbff1bf5bbf659a5921140df435febbd6ba370f8a4ef902a2d9acbe312a8e422877a2cc3655817ae6740d4f6e329ad90a3b80c71803c5a510687d26062afbb0cc4b67adde522706bb180e8ef43164e58c726d2386156692e83ca7dc07f44489b1abc028656b1e22c9f39dffc183efaef4c2bdb9768c776c52f855a9ad7e72b1b2fd7e4578708326533b65af44b0fafd744825e94cfa3976ddbbc43f16657fb1043cc55c9715e376b16686714f5f8e17c52d6920b04a68693d07ecdebf63177070dc8b55e947e0ee3d548ae3c2d3f2e45e01454ac5da103a498a4211ce214a636547bce48909f34a3fb029b3723bc024f6d749ed0b076f8b1f1673ceb8e2d1725a0de322df8765f63a3c780b4948c676f1eae1374bfe33bd3ab7bebf821d15374beb35592f37500c66f93ca85bebcf561c9556602280c43131e005fbe2f28e24fffce617583b8330e50ef877b1bba53d89d08cb51aa4d33f44b440870d053f1b007fa74696e6d8112f9cf8803e8aff55c465291dcd1face5ad51a0db1364d1d9d1f56d545166f2a905fd1c4fca247487a229334aed96bf19b8cacce68dbf67bb08b55051ca4ecae4099316c467a377fb9ec088ecb3800b8027da42fa19b95240db033c9888c155df0a197c9db9014f755f8332bc58fb27641d36ff547be2fed14e72c773430a6d6f1ae4ffc1a07795fbd180bca8bce3ad4e5b6a8c16e3b01ffbcaf419a5fa13e2b639e78b9a8226fed9386198cb26f4471510a6b179bf18e8d51546938645cc9944ebd96feb4eef96df9e7a868d70a953f074cfe38bf73732335a3a4baa77a8216dda6c80df42bc16abd063ef657d2a2e304c59683bf24c55d7433ae6aec861b4667094efe6b25348995cc88c41746d60b4520cbe2ccdab60a70d60a41cff853bd9bba0f3bef7167f39a8b26ff1ef100c4a4d57b23742c241128dd46997bd5a7677525e2a7786450caa0c3904c8c023a63ea1cc7bfc0e7b2c0341722c1ae6fec1939b86326027810a8f87dcf8c586c28ec4c6b013e6aa30d4af2422d088bc1256cd24b89d663c70e6c2166019994eb87024cfef87d766fee7a9fb0f48265a1eb65f5a44220c21997e5524abfd60f3d1592c32a73e763705dd31e22820add8bc3a606259d5531f07887238c1a44ab80dbacf825521f59d0233428121e6dd6446d835adb368c100b788a9852bb941b6b8cf4148981bded9bc09e2a3c4c8bc83df796d47eb889755ef908ad39e658e2a912916f63f73dcb3ae89432e7f913ffebdbc7512315486e978cc9274dd81a696ec2b1326c6415f093a9c5c9ab50160fb1d8773eb8652c8bd4769851c5f08f853ec76785ec85e352ae9f69766eff3b106c969da1def81dabb7735ed7d32579577144caf76d3cf8bc851213a03bdc649f5e95038186ccbc18a621099406c7da1e3a21e88b6b520105bad3fa5cb099568cacaf450e917a44f2f3f519d342c35e7d91d7f3c8d80f8992cc54707064da8e6f13bebc73b3bbf6089cf74c060aa44293604281dd1258dd1401858ef57b21e1f4692e7df669b665548e8aa22bb9b3f4e53c3dbbc221605533db4c24a661176539d5bcb640202cea23428dcf9bb8a19e5529c11f1ebf91959b6de8bce1cecd395a18f08817b933367fa51f4a6bce3248bc6236688721dd2e9ad96aac52e7846186ab0e02c978dc94f510f3d8b72ce6a73c1664b9fdb8c6c923ae1f162dc2d53d49190443cd907d73a358e6500d94709c3c1d70bea1b6c1da3c6ee16d59deac8aedec211ece4e3bdc8d03c8364f046215b142c92aa8dc7f05fd612069facedf4626d0d7d6e368a82221fd44575cc31a8cc5daec244390f12edd7143e2e49ef7e1de4b96dfed065b722058818931f11f14889ffe6f7fcdcc468e6c924ba384927ae2feb5e1aa92d9d55513326f457ddfa859134c6761468c43af676736c43719df43f0178a41341127e8e1ed31b743ab059b8da8e06706861080b15b8b4308f147b415cf057e1d0ba8e43def83d7d42199e64a831d9905c1a2aaf532d8a3f23b6633007c888e63b5b4092dbcb8fce91c36c9f055e9d99c1826a01142ce4afaa920fac01068308fc274aa3a9da3c2fe38559c33679fa16070bd8d81e62d9155f93d817a9dc0f770402c49b43fcc7e377a1736464e0ed6c7e93ebb0df67e9ed0f4a4a5cc048025caa4b85e66a8c8c5d67519afd41a49e8e5addb1b671437c7615f2604793381120d308310e4f293f374b1ecca95aa4a6897a24b4d0726bf8747cbb34835b99ddb992607b9ac5726af8d0b8e45abe8573b21e8935b3e9107a75750c7a8ec3812caff298dd87d2d348f3035a4e794b12d8c22dfda888332c4261c071ef09e7b7dec23d95aeaddffbc29ab1a125242a8d4819ec4e68220728a795e5587628a4a3e363ce2a72622e1531fca1aa41ee6d74764c7aa162128da104676dce8b346783d9efb54de751fd0a925a2ec876690fe08396a001afb5390d410321f667a079f62274cee1957c130007d2792523c8c6ef36feefb92153a230d8877fe6b287edea1acfa690b5b8d87b40fe2183a23a0e3aa5e20acd52108f63f8d3a124729961842b10d12887abdcab6a26a13e0607d1e6c3f3e9e16651fbdb8dcf08fe5546126d42ff264fd205f93771d0464f43dd6c9b1a185c2e5c0886c62db85f91c18704ba72031b9ba7eadd309fa31638171c972a00b11a595ab5beb6d69401c4c68a1ca3ac5ddb68b6cb79c52577eba4e8cdd71133294505b2ede2d2011ed43b5c762c15386fff9d2fcbf38e7f06d4f35ac81d8229fe52275ccc7fd6b56792003c6e18027f727b3c51e76febfcb16fecfa162cc07f445923ebb5a49f3099907bf74fa89be40e7e993211b93e12b747bfa1fdb240fcec5c0a04bef6768907e740900d4bc3cbddb07b4af6418de805a53b2b449f736d493c3c971730f2a1d7d99edd8ec41c23ea9c194d79cea123e9cc782ee81d7b2640f635dd77ca7e35c4735d4d6d250240c09248a5cad07616b01071121cba63b569840c4516da7621215ec81b53374e5dcbd009bed7cd2260e06145299bd74069c6ffbefd4e1757d16a4f281c43e3d7204dd0109d1053dd5eaa3ade3455ed674c33a5dc718e854abb3f72b7072cf34df3e3415fc39d89a2d547458eb289428246f33603f90d69cfd93fb1ce50456d74fb29b0a4b26937f8ad98882dbd340ed89d7e45e741ab87c8d8189c8116d3271f36f528a7bd18a7673a6230cf9a05c3712a95a4cd2fb4c0f57bed52127f939adb141bcf2feed6f322b6672336de89264c203304bed7437e7060b7d03fa154d5eedc6213c5b9b2efb16cd23109e5b95351fa77d582d032c518a55165fab018d2c2d27fae8c4de5db26857136c1cd0369f475d68cc995e0275be8c88eb55707f4dd512bde7956f71bd7ca23c98683e12d25d4354ba50c447a997158982c6740d3906e6a261e1d6c42ef92aaf3135941b09ed031dd451fb51d31b717b44e9169a04ac85dc7ed22ef5abf2947964ba51257514340e3aad3c5e43fbc8640a6391d60fd3100f4ec499788d56c8adfb46c391215f3110fe8650f38fc7473e1a1a25d73e89b58dafb1d222289d0524a70a9592f9fd91ae28678480242ca08572534018c2f7d0e1ef628a61ea3259deddbbd0c3df0b9439e0514aeca8db7369bd1acaacf386d45e1d32d7ac0debedec4a8e9d583a5bf170d48680c6276d082b5c37fdb0fd9eb5d15be24556045abb737bdf6a52f6e2b6c877ec02a07d985476f5676ad1587d5cd2ae6f6ec225d6ce750d80661413980e1ad7e363a588e29ba8c1ce89874ff8b3ac308de23f3a921d1b37b203df5726b749e3cb6d9e3cf2ea34222d63d363d2157a427497ff136ce2cd25622dc5d2c116311419c0c50345e545433937303becc420e72aee4b0d581bf79b63c6911b1e22f2659e58438452f17562ce9c3d9d8ddc6697e0407bfbc75516199a1811bcbc1afdfefd825bb784ab62f30dcf6e265a01bf7905b991aafc9f4f9f8915595beb30285793b1a72e92669e66727196285845187ca8888a2c1465b2f0a0fcc913fae0aaf5ca46f07fd5c59e35a8071aee72ef53acdba8d5263cc26d3ee289168d63d12993c77fdccb02b04f1acd2aa9ca27d2149bb02eb2bb67b726913ba3602c3352b77238e6e12b9680fe289bee6b7c03c719d55ee21214865d49338b8521a7f621153cd724f0499598ce226f719c817a3aa44fd3ebe4f7d1b1c247bf870feda7dff42d72d6d38f94a4b97621e5d3f46c6aebc8e4516786cf3baefdf9c81be874445bfcb5b790c8583842c1361f1a3b1162e19330fba2e70beb29aea064d965aa5d9274c13759991ba27aefb9f18714e40c8ef3d74ffc72ad06b0de1961a784f0654df60a2a56a6eafd5a0f1188a0a1198a1a9173e23fee17f66bf29c90fab8c846bd816084d15d6e641ff14dc01fa31e0f0f858876a20704cbe59024a702771bf429ac3de71b59913c9ced269692dd410f4a8c05d1e34ef3abc156f51aac4896208f20ba92969f0ff8cb3841168d2e14540ba5082ab8f9589925296c82e7890eafc17ece4eaf539b74c374cf603eccc55a2ec91a61cfc522594418666914ff8c7321f2a3704cfc63d521266a9377989abe318ee37e9543a8557fa530bab24bbfa1f2b29b465067162ddb155bc424773f35180eda06bafa046f40f0ba384618883b70704f87f51fe8c3493741e77666d76565b168f01cd0fb2b70e69e8be193f28e650bb201c46fccc2d9d232a2c0a938e2d61546b30ce3376ba7422696c3e1180cdb34cece9613ad6a0ffad822cf095b1b500f89a8d9b7dd08f5e588fac222e52a38d3bf85e4f9e962578edfc1d394a0658e34780dd7ab4d8ce5d582fbed69d33b80feff0c00aaa543c6bdb3270fe68455835cbe54020ebee2c45df5392d53ec3df89fe0fa556095e7aacd70c43785753aabeeec5e17edfdd8e24111d1f0c94a3f7da629c8ccd154384a3abb32e9343320d8bd7dc6d7e197d6c7ed278e736d237032c032f76d480dd5d54a1422767cce5a7d82e5b25c467b35877b5a0755c00ac8743781be8e0d202488629ced13cf1e33097201ac6f4810145d4a14837776de2bf9120081084d593719c8984a510037a20622e6b26fd50e6e1dae4ec4e72d27ac9ce18862e7499b59b9921e44024ed1ed87a0ff2783e0224aa0bd4489a8946c5f450c878d20cf2d6aa53604ff240a5c1ace41192110f4f708c7d67edbcf96bbde6ae7bb1c3608b1e10b7141766da733f46246fac2707701b413120fe2e7c99d7a173e64a37d69138fb3b20a97c79f45ede974a3e4eac57e51a3102daae94e49ab59bf19a762b2a02f7e2787f3586ae166f88b90857d9247b621a2c8814ab78e0aa1a043179c33bf8fadaac61a38a07494027159fe27d46cfe6f52611d4c44528278bc29a8fa9ff1327eb7913b2c9745cf741f3093699dabc16ea40d1cf1e9ad6263a589a6f811923059ae97982dd5aaa35bda4103c4467509e6e3b702f3679ec80821f574c2e5e4054183c928f7ad5d614cc555e45b86035f78af66f04f508c7841bf704a468b1d98d46a48cba288df0aaf0c94380c588ce0de25d6177f39aca9e0262436e4a0de97dbee8fed58dd56b51da33481fda57e579bd5094a62237c65197a864a7931a51d432eb9db1875b881537159b0570287d57b07b307e076b3c284b8e998b1254956fd74447f91030b05269a4c9779e2f6ba62f4a93ad348e2353d2785208463a5bea13c3ba35609a29b4dfb28b7b51c4f6ee0f9204e316501b1c9e2fa5238c84dd4711a6ddc0324b90e838c4ab47a3f87a012f26b7355ebe2f1de8c32ef5b92043d8cb8fb04813650f683806c7fdc2885591a04503d6fbb900b154f9d4fb2dfe557b10c0ac90750e43c1cba3a13b19a555ba581bf3ba7ed7f3f5a9d0e2cbe627a34f0a4a715bd261212669572cba67773a4e88dbdbe1deff751d6ed5bfcf6a01bf55f255f8176fb83df8bd22d59aef1cd5d4247613779a40a534768f52f4c45df20b580d10cb91cd4887211c4187dbf0a2efb3baccc8f6687c9200e8479213fccb6d85a04e3b5b59ac59b5f30b15f3277ba5f438478b09518b323d7097bce7cebb75eba4c27e675f12e2ab67afe8f82028b8016bd2c92cc7ae494f2eb8644ec6e088bc1aa5cb48976977f94e42784e51debff3d6eeab7775befa5bfb5e508457f69afb890dff7bf1bc5326102d11a5fbbc3dba8d4d62972aaa310e464611bf8e3b7ec7785180b10e8a3992bc07f87ba0133b925bb659ebf3859cec60d111371bc97c69dcbd7d017ecabf6c22b1cc7b5e3dd4b962ebfca7130e1e702fc4a60d3dac181521132295204a1c0fb672da48ca387822ba7d0c2aec3e4a2b9e23985b9109d3da8e8a44fa177b96384712184723e45926624513f58be1601314d43aad370c50fa12fe089ddc337641682a720eb1aec83240027c7ebffe04a9cddfaf55fbb6172b3947427dcbd70748f3a18392edd97ce39da8964ff376c494c133b9e898d0f9af539194b726d24893e27a8e748bd810702ee60c1a2e456326d36cfc75bc6c1fc0222ae5bd5e45f563a9f2ff0469d6e07d16b4d7700600f62f7c5a76fdddce46e3dfba7acaeb208ee1fc91ab9c4e79c6ca8639765c32a0b39d922006c0ce38e2f303415396c97d7597a2ad0c773d21f52764196e3061b46237d58724890372c636e1368f07e68d439833e5335630d6362f46ac39181082e905700f429ab002f8c822e17bc630af98b25a42f8a04b00895c405f004481af977eec0c48fe34810a7ce475e392167ce59deff0483306ac1302d07ea0e2e1c9c55d7b78c2a9223d0aa21f8881a5f0d7379484f2aedd297961e2be95c49b3341845aff4fc7e3feaaf5b95356afcff47a3259d384ba36dc6d96b6b31c75d2993bfa501f103dd7af4903cb5e6e7b38a9e7670a0c2aa800bd3d2f2de164575442d31e0a518f4ff8f044bebda96925aab4659e989f5e4389d415506705616ebda494a66853d16bc75e9618d3b0ec2bcdcc0bbd06a064a83597380a83a765f19c22b6d7f1d8dadda4e7fe6aa45349fc5cf9e0cdaa19f1f468d651ea9b9ad9b0e9b4661b98e370d9d4553cbe2dcf8a564ddf9c58d35a60d240d74eeac08cab6f967302813950ea3bd55e8cb6a3994944726f035a3ec90c072156e4d6536228c036295eba0b66792663338b6204ab8c16d4cdcf89fc0f7070643ee3b1f09b407dd51ee69eb7f242ed4c0dc8b072b59de4bc1996e62f022a1cc6bb76a2371ed7c91e7f1ad1710f11a486ccbea4b4d74f04779938bca7ad22151b15296e84182531ad0450bf99fb6cfba3434e2ba7a68fd1e40425593cb1826637c9cb1de0dc268e890bb8bad361cb488b8cf1f61f0c015c5dd49174e6483e33d3cce799b623cbfb03f3a7c44c056d0da520bafa8fedaae067272e612dbfc98056fa7864fcf4f2604bb555794c1c7e7e3f6e7ea8690fff00e351dd2879bdbd6f4d22627ecebdd8e564e1dab2e75c513d8491f1e325a776a83d357dde00545e1ac16bddc94ed200def71fe35883bc924f36a652054ddf58bdd2f49a1e488cba1c277ec3b5980c5298d1735fa587f8c18dbfa32c741511e262bc240644ab900c43776743986e1e21d8926a5c3902f837146c54650355e70c89e40ba6bc7b17ccb18cd42a52eb6e57566d6d2fe0cacac7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
