<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6958fca44064423476e14bad91cbcc5def5c93462c00636b71fb7287fedc26499d147f0caf3cc9a64c3d4c9166462000d7cfb9deafc83ac0d571fd06fef9c18e6eee79281654de1745c9cc16c56eb609864aa468fc80e39ee998b4a5428bb71543837e1a36692d464c9a23ac10559f5efe0a310de89e36e9168b8f298d6200e4240538101c752126c6f8b4ff5ed515dc8e0bc8204b81e2c612c92c89b3f287034f60ee1ed2d4542b03f6aa62548f7b442a148801d4ad7bb2ce7e52f6c81c7a3698235ebf2cadba49ecccbcb3a7031eeda7937b7f410b7a9be42e3110fe23a44b9ca36c4c78056f54c3cfcde137844371b6c1c3cc6eb2185bfbb7e1b06acab8e8017efa1779088c8c22fbeb1d24a0f94f8ea3c52f0db36934461723c2e1b924bca3bd310f622b5c90bb3a881023f1ca037dc0fc9e811e531beafa4af7a3edebeba10d2ae291ede022b1c77e5bd2d01754e773749f99907229a316af4b0bc840596bf8381991401f558ab6bb5b7f34bc7e6e54b52d9d9630c948d043ae79dfc7db1d444ed4e5f84883dc6f9792b11b7c3fb4e448e8c8075a5e08e83b72df38c5fa5da365785be1579e19b8fca088c23830edb3d30a4c61537c7fb7011d734a1d7972a246ef2ca634a0c0cc290db5d3d2965bc114c149d9931c7899a8ce90d8012956e1d3ab26f7850bb41b4570f4064b281527351dc803275559319e882cfe8c4753f8cf94b51b2f609b2c7b73597fd275a5222ff8bf9553063625ef9240fedc6d2d08eedbeccdfd1a932c597730d99b610478f0ccf62d29ecdc62bbce7f9aa0293cadb57bda025d9013d5d0123809758aa35e1f268f8437dc3ccfb8a4312636f6bbad94b754341f3323d449b16947eb9a919f551e7c6d02891c30455c8c466cc4038d1f933d0549578605a2c9cd3113addc9c7fb46ea4396162071bebc41d9e5fc2a8e81e94bf0694d50e98e2e7bb4a3f18e36c3355fdaa926ab359131de51404148d9118e0f3eb47e81294adeb3cdeee46d73bea6db8a97ab3dfae9c5ef6271707bfcf776867f8b27edcb9a0ab6b400b224166f5f12e8ed6edbb74642c03e029863b90be405c7cdb66260646788c5c092b254d4766735575782db6dfb11cf699eb4cdf63c31b1627bb4a590a0d368f127a69de346b15f1c27535fddac727c5c3df13cfc404609e8bb3836b55d94f2621e3b18f67e5ecbe84e5ea718f02f73957813d13d32d88d55cbdae5abb1b5e0d37dc88301261a4435ee706b4078dc90a389aecb92df187365a95f475993a1286da5154ff68663245b3fd03dc5d6fcf2743e2af3d9ac437f34b861309977380d50720bdb49be0775918ca374f8324302c6e74e877a8da10bbe50ba49ea580c552e3d0715df52bedaba9b90be75d9da243cad550e9dc57785e2d5aaf6289ae66b349b5c18a294fddc141cdc7dd140415121f0fd6c079778ba3fc9fa0d511748ad37ffb6bc30f545ee98f6eda776642ccc9b7d65663fc4c366cbf6121d17b18cd6603e7ce97fda932508000348e1a0b4d801cab95f2c881dc35d75a277f2b8fce56c28e818ce443c2a46f083dbae912a5ad28dcd746ad06008dd50b7da025c0a724cc87309e5763c62a51d1fba7e9634681ad41359dabc92b921f3e793b28a3ae1509ad743ab93229776c4b073cb1cf7ab450aea8a744adfa5271bd0830df8f22d661a4dfd3fb9b94ea1655de1b49cd6c49ae27e084ae8fadd25d03a20c212e3b8df086caf060e88ee2dc5a90588d78502e0161bfe4cf89846b76e729315fa238660a52597452b27a38b557b6a7902778227cd1d30d037945c03986ed22d45781a16c7c7f06f6acfca1d0b21a706ff1437d76ab79962d9af4b5877e2b0f2240f368bbbafcaae82587a7d723825c45f9d60ba676cbb9cb4e2416c9c02748f2664d39a16ba4fbfce8ce46243536038aae3df58f3ef1598b42920f0abc4c2a48e986e0c2408f7240ed9416fd2378c78dabe7e90aa42ca6bf8d5bb82b761759a04919273809de354d06f79e626c9c5a10c81502be6349025e7623d33d6e65115c93d3827d295e6fa2aa40d1d4ecb7636dad40ee1ca3ad093b25a7e7e39e197c9db52075b59f197bdceafb28320ee461e838a7ed1954f1f86662b19c9a5d13fcfb6259098d58b268b3f6ca7bb7025ac4026f6bdca4ae883f44b4f3b55927710d202810f767a221ef869301f4e1b6f138d795b30647e1fab38b9f4afc0240ad587238d3509a1d83e59cc029c443289f4a1f08c043cd7c92bf2b75335b1e3c8a9e90a76ac5653fa3077e967fc762c86ebe9c1fbec8f0ad311d66c528ed9a7b632ea9035a280accb22ea93eda8edb7910b542cb4f5e41d5325323375cdf60f9762f4051763cbfb6d07ec579fd904c52dcfcaedbcd7f0830cff47be8667a4b6f8da66e96c5fe5cf0ea39c1536f550aefa4e1a16eabd3d648620f15f792694a13eec38c8e38536bd1b182f701c67767c7d9635b57bd84d2d0e4138f079a52fc8a27264cee56e8815800c1335a81f6960f92ab1cfa8313707f0c1c1591f85428fe37176d6ab35579fa737ad21f350f4a2726842e96ce1d20a53ec4b8421951a70afb1dd655df6638caf36c33a39d64f3fdab1558e9e4f182884c478047b062871b5a5b4cf8cdba3f32ccbc38c3108294be50d79983bf3b0edbbc2362f8b91ba2201643c9f316f9e1c50c651b3004307dca3b782b6bb56e693105eff1f3d0421103fe583e8dacdd137becce2d9ab806f94b986b5bfc9cf09f9fc5bd5900400ac5c69bb7824853bfb10b772b6df8abc12fc5880e3673899b991a0a79ef785625e339134f79007137679294ce8c38cbed97d19cddabb892abf14274d7c11284950703c5a99b8db47d62662aa8e422add940b434cb19cb6c006e7229311c8af6278d28e747a763e7434c5592fa990a59cafc2f30b2342b6dc30985be76006864d561d47c31adf5f6d2ad7901cb0ee693f9bb47dfb6ab745fabd1a742b46513fecac896d4aa834a928daaf23a0f631bd55258c215e0e536de1dec28fe796c838e42c066dafae1742b6070c702041ae5df8437d96739598c4df8b5cb89c3a3c7b48b2c0eee4e7a27a1e43ddb658f3cb8d852f655de2f5f7810408b7b2416758524bf21d6c792d6f146eba9d8111ed8ec71cd040d62aa2899dfb51d072f4384069982845dacf29aa9425459e5006f1c5b0c77beffe20cac6b6a2afb1aeaa86f7e9e5c5cd5e9872359a4f8bc809d6d2351ecac4ff64e22277848fc3862f6158498bbc43a9cb259ad6842697010fb88363da88c501f533e8d4c161c0803feb4ca4bdaa8aa9985e00e576ab84a1b6c2698194f9b76e81941e254ffbdca4ec13315d15f72ae8c6a48fc1ca05426fc4e2c247aefa1143ccfa019704f40cebb1ae35badb549bcf09337e5425ba244ebdc9ce697ad7bbe9dedf8ff55561a2bd3deece29484c194718031dffca3c5e2f1a53402c6b2046409a5e6d681570c2e307c3b6437d2db0843e0964a52b1e0bee02ea467ac0972f50967e71e4ad40beb4df171c2057335cd9ca2dbe219e5588d79c0a8f7d407585443711937b82dadde1641eb33ff4c8722e18d9c35469077fe7c9eb877b63dfd8c4d270d7a92985f2bafdbf7d32841df679295f5fed2c7e74df1cadb6bda11587bfe0583ba9d8e7dea424103ca467c804699157391159c3e1ab33ddf8645c04b90bc7b1e2179eb5440201cb6c1de61c85f59e6a6529e0fc60cac31fb5d4704cb7803e7cab85c1245ea20e092b7d100526b912ac607d382b20334267247cbf77cd56c1acb79d1ee4ca7dd88ac5a0a7a426b44e19399ef6759b72ef8aa6f0c69629cc6b91a12813dab6a44cc4a5e224758f3f7d76eacc07536b06b332b1dfa717510f53db5a0a394095ccc854f541fb5579e2e796d26f4367b10ccc6b515efd0737a87dedac36048e4ff5e4f29e3ebf637a11f021ff2a5d534bd0911560234ad14c0ecb62b73cf08b7e6140c6169e5b42ee600d4b9ebde3e66c557782809e2aeca7d713bd0e1df7f46b2caa38dfbb7e05bbaefc7fa6abb16f61ece63fc23bec2a0c8e37d70af49054d60fd93e2f19d2ad6118e7cb6f261966fc6fda300946f5a1eec949e56e3f8137106c50a4b1d8604d0bc6d4038dabc8beef9beb840fa3e6f86348dead611434fb92ae02ae1d45e62620b7639e389b6c76f45fdbd9f2a25b757058e261e1ed26c285464516b25255a40267b48aa0336f20149bd7f16f20c4bb862d8e7b9494bbbf433f3f1a911ddca4a2546a368b4b1cfa4efeff594bf295b02bf6cfbaffc802dbc55f3a8e6c0fbe325eb1dc116c8eeeb693fc6c4415c742a8c3251d32160dbb3fa73b9ace1ba6365bc334564fda206c1eb0d534f00757686d08260d54324df5098c8a413ecf353c28e89dad3f45cb671e7f938be9c9f2d3aca7ed5c7f85dfa66ced63f47fb663b1b2102f62ccbf9aedbaa020769dc69f9ae74b0b9945691f6ca3d9f85a62edadabc5a84a2d801a91bc72c6bab389512126dc56b7af3fbc2d47fefa6e74260afc3a20b99019f425f432fde47e0aca10ae6d2391f78d13508aed08be456c81375b3be90dfcfa9facce459d72cb22ad622b4a38f9469d9aa90c7815dca8f39ca2b1ba68abf986ec430a9fc8cd85cde03e79e4c7945693fa248a93ae6085482996e74ddb5d8c09c9912bae0693e83bc000e8ac843639a7ab9e0b895b14e36cbee1c3746fd0dc038aec100671ee9eb738e2c36da30a776c0bf2a948f2bb22155a6700002ef8cf12656eebd3e41ad564fbe40622d1c39e8c2ba6a86aab9871162511c0faff6e53b037e1077ade1afbd0d618dfbb342a96ac950ac33585a4af552575a3b4fd9bd9f4bc5dc2ee4840d363976497a661cb6bdc5f04e9261e6e00037538b5da38524cf2739ec3d0a463dba436246202785f672b4f80142c5d3b0320f3796c556210b8c91eb8c29665bc7d05170c333d924321f88ffe0c739b98751a9aef327f471f42ef500f8e6cd2e628256014c63e00df791720fe51ecfe77ea2019b23e2fd37bc6131088cce7c540c88136499f9dae1a497be26286087c4c2c96f083b9c92ee5d0564e949a65149d8246f81553cff3db263a503165c500ec56953e91a3b8ea36b1a4b103b0c1b92f501b6ee262a19fcd555f5044d6d12b6daffc14eafa8f7078c8a47a3e0d51a1095a7fe583e9bd14b7daba6e857e838b5cba6077302a48c3426c75da856f2320bd036574f1c49bf12277fb658324710f51eb123d79d2d92cdf7368538100ab1cfeb1fb4b177d4c28d3588583cf82e82a5362b0c6799cc863eea5a8fff936aada0853768b912651a5b59f9d40d949c2434c2b680997c3c6a868bfb437b198f228abe9e1016211583eb89fcd64a31854977d97afa0fc5cbcb41eef21293d9bd5e3d0ce6b5ad748b5913250aef893c89789ab2dd4349d426a955318497654465e5e1f6895011a13ca96a62a1c4154bcfada5b12b66f757ae9e128a11ef984b1bf1ddcbe819407d2a687b475e6a64040940bdc68a5be8cb04d17fac0f6e2b0787cbf3a3751fa9142b5b8fdb3a65fcd4c87d01a733c96ddda87b4a0da3b75cd0b23365b888882b81c56a3ca81afdcd4d35c2b91d98c5d6f85a6d8dbd91253d93e2f83699f3c35aac5015c09e01115f7c8c040ed693054be5047241af61589dbf2467b5f66f85c3a0f316b6d338b65661c9b6a52341b8585d370a96d9fec571212c8228575e2c5d543d447c8fc561810df3789a88a0efeadc7f8220b9741ebd54762c244c9217f36fb718f6d33efdaa286a3c60f22fd7830e0deb7d06c0e9a088b5d2ce399fee91eeafd308f31a6a3534de22ec13961c51be6d0121458c87a21b251c863db69a991815c0c51581a90f8159889e4712ab1e7652f1efbcd6312a593198dc9fcfa28bd1f028f64e403a31a4cea04687f5b532bf85638f00dff6f7dbca10b3a236beaa541f0dad7c64c157dcdd44032a1bc82353cf22bac3c02ff3259049cabd8d847c58e3fe55a0132ff5acb19422992683aa6d0874622b42eb0a7c5b0c7a96d9932d26a4300dfc10846409adb3f9a62f0300b41402b511fe59b34b9264ccbb7447f7c1a767af8c2d69eb14272d4805cda0ac3e9f65d375deee89d068f943adcdf4a7d7f78ece06facf5b0af9f0f0f7fb6a3e248f24525994162a464e812c9b18d070463af7839d5100e6019ea5466ee863a0f059820090308fabf7fd4a6ab172df4a748ee5307998376356ef7ed09594fa299a59b64a75a3ca44ac1f4e90226a0c315f4fb41f7a6d03a75f765332c056515951e5f19651feeeea0b1bdee135c07851ceded715f4a2cc7ba455137cdf0cf1a0ad4ce39c5806f4269eecd6195e8e9aca046e70832099e5689259a8ff3dcee957eb84e8950501aaaf8ffe34c3a19c041c4511d4b51b4151a5c2d3b9925ea69428f7f1b2bb55fb19eeb92ccd0221fa076cda6c79c84e4d67de4e591bacde91fb4b181316876d02f0e501fb35ddb5ee100f848bb26ea0194acb863a0412100cf2ced0cae9a2be5961f0dc582d717fd1cccec6d584e7df33fd1afa25395c810de41fdc7139d5f61c9ebf2f57757376ccd6eb714e38d3f6f59d836f85bef024f38f5ddf0fed20bfcdae1fafa14c9d95410017b3e19f0a8f5673793c4e14b9b5fcad0952d6f59d1ca116e7c4e256d04e71eacab1e161ab4808396e56b6e5ce42cdefc96fc19991f71bab74c92de76f435dbfab222ac3517a1e78a562c8938e831efe316ad87b748827074cd910b5e4b9c0a7fac059eaa9c9f72e0895d00069ea5bcce0a690aca8b6c7e1d93b7f9a9d235f890e623f407fdb2d452d6913e99c21df632777eadfbd55b85a5e391053575a2291ab00e2852684ae8f2e8eea4d722e1f2d9446ecd97d86b56b39de05140993a9fcba04e6ce4bd64c79d9f76390becb3db74468db2f85af41ad51f9e607ab4cd2224835f70d1b025feb4b3709e775c088e96090ca128587e335ef6b5b536fce6eb562d19f07159dbaa8f8f1f099b52075a99d9de7b16008629ef45bfe21e8bc15cf9d027e45d3f68122ca77bdd466ce2bc6344b30ad58bce99cb48ff2196a512dbd35daa3f0ec1d4409bfe9cf76cacaf668dc25dd70af2259999ba59055a404ccba39a5e499e5b68057e26e1086cb4907a7286f51109afa4cab386fccfef1589c4cbbc84745f7a386961589dd220a11d5c0ef382d8348b8988db7b752a16700c01acecee7efa4ff284047e22bb1efa2fb9d526d04f70f1fd1f486b6d78360d7e0edc36af45533e7826f6db9d7817584118cdfdfde6c40f43b162753d48920a29151d226de0aa547b45f9af79736efe559c8bc19e148f2099f2f2f88b07a341f39058872277ab9f4b72bec6b022dc4d6567397a3b0e2a51df81078cb5c6b665f6ebbdf1c6671a4e4bd20de215c8bb8e78b7151323b68ad168d24569c65a807e7ae322939147ea5c764b0d2246a85b4a05b903fd31df5d58bdde66a7901d697b466bdcacb8d0acd5bbfdb3fe451b206332573b8992f8a332164e64f53572560b5a468abbbe978944d9e0f775422f6203a362a0d61cdc0167b04dce51be64147ba87a208928291340e730f19a36699668a723af8872d828c57cbf7a95ee07b9a95abd0e94f3b70a81ba0248d81cf3a4822a2ecf599b7c70116debb28f338ed1eb6bca549961dfd2914fd5578fafad2036c700033104da35f838d7cf23342a8752b8d8e8130f732fa47e6a72343efa593129b440eeb323f89d672ab84529e4c20562d008ff1769c451bda5c2eaac493b4a372305e69722c747607bd0651516f4ccea60fc9b3939051487edfd3965bba52dabd03d6935cb36988840a6ce00e1a1f16ac9af2e85719e225171d4b053195934914f25f2d816cbc83392768020fd7f6a9e6f859b3a79ca99928d53b686676c301f29b823bd2970cd8e37d17c773132ff8bffddb576eb2e2ed16fb49a7eb48703c8cb89b2954386b569fb76019e23d0d7a8df548b5bd4dea17d28a56fa114c37497dc8840272fc3abbbc1a335c19c1f6d85555933256fa971e571577d334b8601481bb28826640076fa52a80da8b52324e267cc1dac7471983fef3f19957c9d9e9fe2f0599b0ad2f914a6c916845a78a1dc5afa3f099941c2f66e754d9a076a48c25cd6092ec419d82b18b4ce6fa1b137ff58a7c1e090de58eb12469909355b9283f672ba62495f6a74dd650b726e38013980da13f4feb3a0304b2ef0ecbbdcef1912a9eded3055cb7a9449c7e17884f1f518de3bc457150e8bc5c3db7223340102c4323f637adf61b065aeb7023789e19b8604acb9dd993d01544514585efe91b79e263843eb94caa10eb1f97aba87a41982b55b6ca4b1a80ae4f4f17dd2c3116629d354118274b240933a4319b26958e62758bb2c3697cac2e2df197955725863f54a9aece67b51080cad67f38d8b800fa3acce0731a480000a1ccad25b1702b1566ee109610b269764b791be3c0b62f018e4492d78f5227a26ac63ba0c99b0c574e518ed92fab78fabd3b7734292625138183860d322992871e9df45520b98b49f8095f3eaacc485bb990b4abbb4e8af5d900500216d1d4d022eef873f12e5866158ddfd01acd96d525ff64c9a99a3e0cbb9c96fe38e3c6ca026b0a17e9dda8aa947253baaf7c4f215e42bc91d021ae6bb2d1333a235ef8ab97dbcf8012391f01578dde1ddda355740019e8f3ad6f4b0efcd98294fc20ecc61e2b670c1f37361a5eac6983ae2443b140a8165e1daddadcec3d0137f07b8eb69b5d2b1a829b9eec727f2471ae4502a3ce1567458c275a6dbc3a2e581e5c41ac5cfa42cfa3967ce652333bcf7013572379bc636fc1940f45cae0cb194a7f6f2304d9557a0329a15ceee17b29ec04d22676650c4592bae6845029036d0b5770d292f7e4d207b21bf133baa2cc799e125f7a0ec169457b37d0c145f33bf3739ccc3b202f08d69ff32f2e1e945f65d17b71c1e1900e2f40ecdef69ed8ef3340252fb8e8e849ff26899878d8534c918dc825bf393024eb8781a8f7ff8e4f30158c45f33c43bb413fdaa9c3bd04af43915a439eda2b9bb7068891c16ee9765f65e7cdfdb6e81d5aa2596a594e637353a13429cfba8cf485ff3d7d71ffc6953f6c253164a699b9f942769270e9d4142eff987845cba8f95d25aee61160bbd6cf898e844ed8402f69afafdc80fc630de5a403410ffb56d9627c36a1ef2acb39e1f5ce8fd3899c3f139ba70919399250e9292b1756e14ff249d5099a5fc831d26a675a757b0ba300197baf2e0fee3c5dc277cbe915f780f2e9c37a731731bf6198a1ef7beee5a3c8dcc86e3d9b9cb74ca9fc892aeabcbd477112813fe18cc3ea571c303727408983a8b57ee6052b980859936a57dd6712835ca75eb547b836be1e77b701c7a707faa051fd457a26f478e81203141cafba6fd8afa8bebbb8046828244249577205da8bfbfdf16273da22f6b1efbca68bbeef9b40d5fb857f11fb7a1cd31194bbfbc7f06472501d6a116b768ccff67ff2f390c9f7ea3d518649263209241c491aebe90951f1c0438b967e08af885c50e4a0e41976e25e07ba0c40f0fab60909f45fa5617e05782ba77e3df3013dd7c13279dfc8da32ef1e4ea6a42b8709134939b36b3e072491ae9efee5b0f297c3063e533aa73f0a0ed81d70411f17fa59f44860ed4800a791c37da33f61f8d4629acec29754b27a8832bd335dc8d204c7e6f32a0367930b0aec9c32eb865611eab78aac9927b279d645bf66f1453cfbc269f3d102e12d69ba14ba3834ce2f706a0483ecbc40735ff3d25236f5df4593d81f815017d416dced7e2c9cd6eb07d0cb5d26305a8fcc62f8b83674a79416b0866f54b21d44eca2ce0f2959842b83f8f85af291f96f6238dbf7cd7f648bc93c5733caf4347c9688371fba604a649c12503d2d4ae6f0e123c0c9ac616aa2303f8fd27e57af23d52030c2c25fa7ce73ed16361e6a093716545663339c283bb27ab52595e9e99626a22b46b89bb330102629468052dc149dc5cc24d5944e7896b644e05435f81ab215bf7f657abaf23f46eb0018909849ec80707098950aac8ba42a71a7c155a4e737dca21380f449b94cd2b64e3e266520e21b89b9693a34b338935c2996882a2cbec36eff5ce14a38977656a95b3cc444fec2eca121dc9de89f61cfd84c013ab8397e9b825c5a6ee89eaf0d5b5544baa26266df4a5cf0e26c4172dcea4fe05edf11f51bc76d8a5a8640043d6dad0820316d7ee7ce9893c4a0eed99230bd0f27c53303b3b13500cc9ef58e88d2c3eab7a13a2e90b796076d6cb8dbafd6fb7d3a80ea46206e1e178f64f3c38b2c571e45007f74ad63b583738b1543360c4ce3d62e8edffd90ec009107c78b946d5c13f21b7bb752ec1d01c6d5324de3e08f8824500bb5156eae25b76930e25c1306907cfe670a529369572b55f2dd6d425574959157b551daf1cc925b96444329e6c4209a42777f6ced11aba5c8dcf91ce101b16c1eaf853097d7610df9856c493354b05a237171654317651a82232d52ed4e43005d4088e1108b6cc3d6962a71daa9e20cf90fcc362593c932f7830f235d40177871f3f3f08d67127fd816982810a53d52778760c5ca67f87125ee9c9af77adf7b633e3feea29891fda06ebf28af7b81c84dd2cb686f7081474a393a6fb437b3599ff5903f089d7600f0f201647e8fdfc6f417c516728d9184424a568df9c45126e92a142931ee22bb84603379de3de5bd4c04c8704b6fe6b46ab9e871233d4bbf2b1d866e0b17412c966a15577bb935162c3f80ce7970dba7c966afcbe8fbdc3556b4403d967828497024bba5c49ce8ddb146f141e51c7123a351df9d5686e3da2037684f8f2e409c6b8248c9bf3fdc9220b3c4eedf91862504ee3773d4be97f8696e05554000392e34eec402fbbda8ed6b26d68cd3bc3db49a0f048a2aa5b14742ec5d8b8c27f3e728f2f0dc48257c2a53588e6bf77df3ddcb14424f102bcb0493a5fd008eed4d17f7ac7e8d47b93eda88da3a80cd1cf7d6dc9dfaf66f161ab76e8c32db6e4670f417e10fd76cb3e9dcd0d1a332fe8dc75f869e9e25234124c63f498497ba03c45502b06c30db8069c23f8e4b5db82a2658c05a30226f1a4026851791be57f810cfc311068013d5334e21acf06bf2de9fc8bb379c1b24cb4013720f1ae6e0978a10b31e42ccbb3a0d7457ad97898b7c36d4bce95ce5d30996932743d373da8d50c1c48f031f2e5b323643b3b25e67a1a5fbd9b381e5c7fbed9ccc307cfb4b6c9f80a94e19c6a27e4c3840142af94528658183da861ba385af4c28e6a038e17b8acb7457a3da869121db33178e28f4956fc644ae8b28e224edc4e69d2054546fd5099b866a112df30cd37af93d0b27820bb4fa1f45e495d445fea441a4f6d1455a7b3876c60ad30571ba2b799126ac88d0afdf7625abb9592252f0f5f72a696a187d20b16380b6c36e1e27dfed238fb8e1649ef79e3008c62ba89133ff943ba07cdb55321c4f37de1019379818944dcef0125e660ab087f0be0351641fcec00e935e8ee7ba9cab9ee429cd59f0bdf3e9cb838bf020b3b21a66d27c8d9ad006a010c18685ff934bf834fb0fb8761f06e6f2be67d642f933d8a44f3de5510a8e3d6116fee58477506fe3bd2ad512d37ca987ca23354ab4ee4f502330b0dd5ea41f0e563c003d511f26a64ee9fbbf5c3c2d2d250c89ff6bd5b0f83f5e441eb4f9cd0ef64e4509b2b1276da5ec40f53395d2c9ff1d68785b9adc0d526139599bb36bf296a1039b60a65d7455eddfbb7332f57dc32de6b669abf9889bf3c057c37094ea6a3e08dfc1652e1a95de6b3047b62739a30f337eed5a97c509d792dde144ac6a2ded8e529374778103da14df395d18a5fc7d5684ff39eb00917e9669745da0bc47f62b401ca8e27a16343d51070e5f4d4c82c0860b292789c78dc6ab72953bcd75ae6808913ba97b808aa1ff8e09331349ceee3dacc8e780b66af911b27ea3d3a16fafb6f09d99b085dbd8fe260fc7d7fed96e55dd7e34e457b056494bc315e752acaba78f286ed983fddabc9bb8392f4e9e21d2f84a1a1777d4a76c9fab5066b01592d55a067cbe4a30469b171226b25a0418ef87cabfa99a0851ffe2f485615dc43617fb893985eddf74b6945787ea4e018ee0ab603328edba06a49d5e63ffad7b0f7afc58bd55af528236c7f221057e79cee85e443d19ff744aacfd74cbe896ad505ed733bcb1329fad16972d1adb89996fa023014aaf205ecc1653de6f3c3a22a886dbc0e2d943f65c5b2aed59609f67a590376b0cce7de60420aa4c8c63252294b6f3ef417794013c2efc191dc45b85523d013eec56e11b624dbc2ef8db19071267ffb66ceae780a6c833018e4fa6aa391c441c074db3b40be8ab433bdff3b9390040393361532763956d5e541e7bd99460f86087acb366c8cc68a6a1a1e67388e393d610a3d2f6dce7e64249620fdc9e2961414feb511f9647a85fd28e3aa3b70c3be5888e9d72e6b8c8296e66387a1210437e4ad2e743f93be38ab9bc2ef404fe945ff6496570289616cf5e92fd05606af6688facee9d58e09a83a23e41cd2f259d045530720134945a411ffad85b4ae1882e1655a996c6ba11316ae0f501a50ea92ca1c13ef86dbe11aa2cf5aa7fcde52c2035a2eae9c1faba3c0e33eb0028fd994ed67ed28c51ff957e3a3682c2de3e3c025ae0af3d3a1dbd9c3c3f8bf69212ae580ada8b6a08407b0b6400ad08cd9caeaf18628b0137b59662d78d5e381cccedd2a626fd2884a581949534217c42745321421d4b39fc84947d47dcdc0414d1e8bd5fe17f79ef64f8c9fa4ced5df445b5a74b126a663689854845b6d2f35038257d212be7eb47b73daf6b7034d3ebdde60f2f621ae0d95a2c97d6dc93d512ee57cd3f37886fdd639dce3d92c6666b944e73ec264696dd00a44edc87ef7c0a03e29376b09580c7604e0c186d4bf367c104eeb2a815213aa121f8645761ac2afc66fd06b0f140eae654916c8112b0a20b5395bdb781801f835ec06bba8e8ec8da00bf9f442f849899f37a74d6399f5660878050c9ff5cde7869b93f2bab71fb2d09afa22bad22e3ede5d02669bf9bd4352d8c878bf9a33684b9da8de7e2562ab6248773fcc28970b337624bf8f3316ce60b26d6e498d2b7a82d10bea34cf9a9f2bd7977a9daae243f9348a1b5f18d57c20135fc3d42bf366336839798d3f8e7bb1c99392749eda7046f2eebc30fb0864de26712b25a391f359db3e260e70fc39779ab4aa84007ed7d4f67c4f0be0333fcdad5c6052b7ad186172a632afae6c31f6394615c8d99ed927e842103c7417b8c784a3ab63d20cb04ebf7898c20f2e5987cd9a30cb22d91b237d2e05c928bdf403a9fc0795eaa9abadfb8b56f7c10374cac22c330c074f88e07a0eda5f30415b828368053a74af56c4e5f3b69123079c10c3458966e21e9333e0e6c36b20f7b5ffd9f212776ed0af49d8fd8ab3409a787d9e8b82b876f0cf4484c321ebefec9f5275a2f5a78c5c101491963e3e0177e721d8fa64e9a557ecd052f2ef6af87704b1523e647661b657cb131e7d39d0e8116f7fde0d257a1defd397f635adf07368d6253a828454de919b9af3d06bcac39c5ef4a64fcf8c150062bcdbea61dc2b40086d642da43e70df4031dac195b2805d011ded41c40372553cae8d49e6539e1382effecfd102bb08b49eb2871814fae77006370c15ab46e54a267e1bd464c15a60ee8bd1fad2e0372a60c8cbc0e21e931156a9c148d4e618c2a70ebbd8e48d4e7145f4ac9e786d69edb3345ffe9811799b58aca509465e31ebd0ccd5c9a7480dcf68da33a97747a36b312b93858deefbdcab5a64605fe684adc1fb4f21156602bb0ef7945a8ca1e55c408956832e27a4e9ae3b07e9da7482a7baec20dae6356cf79325c91a8e314286cfe9671a4f9239bc7da3373f9d319b538e13ba2eb2622b07fa1c138dac267dad41b9e5e2a6a01a94ef89d8e9c7ac86c1b5ae447dc37e6c982d2b1c214d9a0f3ffec5f38d2238f3eab8f9be9522523071dd0f20974b1a67d851ac61b5ab96c20201520c795e93f8bf3b608472136fcbb9d73ad941d35f554da632f7a7bbd5cd6245adb695b3498662bfafb19b2295d09a12f8f488f0457370198d68a409dcbc83c562cf65ccf8a612eef8937d78b796b9864da5132f23f1233a8f9da41fb99541073dc5631dacce0f34284f577261c896f62189e505df8547ffa3faf45aa093a7b3f8e4ad36c294b5da9a224d91b5cf35fab5a78f7629f9e5ffedf3c0f82a9c0c5855a2dad8f29a3fe344ad0fc7a9742db80c49bdc8b061f93b8e38ff50d237e1d45539ebd9401f2bbf317e58f49c340cd2a08dda804d92b78f19e1fae49b8f0439fa8be28cd125971125baf1a9a35cfa2cdc8c2f1d7d55c15433b31819baee9374ab38ef91536b3543dd190e9e761819bf35b1768e82574d16d666234d582d7ae3a50b7737a49a6224c2fa76605007579bd3c7cbe0319e2ccc0143be58345a759a4389c497084f9149c53c49d634fe85ddad306f0703f4b3bfb5312c27abde8bd5faac6bb1b3ace47708d4d1f3ce0ac54e86d1fc740a343980851a9e02cb3d9dd690fd774d8e01d12b6d45a52d315457eb18c09c41a64656d564a1a2730ffaf4bbf21f177a5f92c51f8d818a61d985cfa928ff48e5018e8a8a10e51c847dc716c4761b5d63111d5d620147066e969d4967843237f403e9b9bab08477f1cb9dc3b86465af414f9f54b4e48cac589f16445f762638e3d8b24395fb62564124fc099a47dbbd38edf2a3645e266079391a17717a0cecb342cd9c79f0522a1c1b659f50bfb40ea9aa90a235cc85bea861199dc4cd0cce6560b7e863f5b927a382dfcca6cbdbf3a060000daed055a401277fb9a88bf496e9bc237ae68ee7d9fb407fcba351163c2a3c97a47b3b6bb783743671be42b8891ce6ea23952da3dabeb56d23c282b06f90adc5a9287240b91f29910205323031ef4392640c5a1e8f0c234496a80ed942c17758da142c260080d99f9534f31ec9fe86b1021d0f42cc87bb3c7300b8a776ba50e4fe82ed3ab0415ec3ca2e0996e5e43b24a6148863ecfdb0c306eeae98a4525c13e1519f74b2e84e0a3fd412af5140de03d2ebb5a77f22f0a5c75a282e95416e1d0f7448e1440011a4b091f29c7e65be58a5d6efe59e8549105c1a977cef75ea713b0f480b32c1591126f72c7362808db7c10c99ef5001620556e9e6c266bedec59055b1aa3d6089bb47c6a17d078a41697d92e899ab96af81cc67a9ead5fe93ab52fbec5e0d12c1d2cbda6a9f330ec74ba2e67f78229b09712e241fe8a493333b3df10f4f73e73b48ff201c8e6a08eb746caec213f133d4a0bb3a77aeb38c628b4a4acbddd6ba150a49f83fbcf7daf011212711c0c15cb35bf57e02152c2deeb20066b60c76f079d1d42c392a2b3b89df0f62e8914a958df47f18433a82874eae3f5926ee4a89ad6c5bc8a629b29a6827d3b2e3edde3ff873c4049f546d529df245a5cb725238feb370723f2a8dabab4cb749d8d6eac5035f2d70f6b43914e7bea8ae4b8c714ea6a8e5c2fe062fa9297cce08c6c03027f15b98e5fb1301d1db72973b015fdd066cc58a9de07e72511f5f2dfa96d2d9a50cd8899b7a3d37e94066a727cfeb5fa0908087ee15a6de775d6b4fae7fadbfeb813ce30f9280698e42a23529f3e3cd047ddeb5af5debf42de014be6f11ab9237c42707ce5c09cf6911f8a188ae85866ffd83349c8545d767260da5b20af67e5d97132271e583e73ad8610a328c134a88e46388384b65d5d95898df1602c9f26a0c21606643cf51897fa06c4ce7bb2419e9ac3430543a7ab8b957951f3804814042cce6c9efa289a40c044401f80c6a3d242522c131424151f4a25c157328050a3f2ca807ac6185a09ac49770d21c74f6fa492f3a6947d2f5fea81bb50cc4a215a18020d29ac9b8dea2039c26169dbe3e27ae24f731b0f265e70db99857ef874abe733e65eb1857b95c3f5a678dceed7af93fe93fc486009543247458fdb1d5c92ca7cf1402b0a1c7d218bd8ed720a734a05b756e4a0dea36a7625a391796053f723b61763ca6e0a2065e96aeec70880cacbeb6f18bb57a1f1d50cce6b3612e4369f4956363f8db122b7156d39b8eea8bc9c1a861f866f341c54d908f802ba17f3085626d701c4bc77e066600a76c866771b517fe81780909788f7a480558ea7556a739bc50f1cb642075aeff8f1b5950d17bc8e47f4924445e9dbe1d24cac8b236639b0de09e3d91c1d2a72e82d66527ac2879ef6d2e4959d6ebf1f816b909853e720e762500439d10a2caf50dd96ba6c742dd0b276be3f9146d32251810ca8dbd3c7bf8acf4134600909d3d0f6bbb88ba2ba25867d06ebe4366cd71af5724f115e61623a0f6b2258df3320699068379162784bd1439aec4b0bd5a88d6869a6d0fb56368bff095bc6aa84567f8b8d7363adbab9a44a16500e15290b494f9b0d762aa67aba8287d11495522ee952bbebe9a140a231afe19e85ec9f11f421cdd818eef8000b1de965d9903ba2da36b76048b236b910681c3aecbacea3a2c4b29c3414f37c91a8d1bdfb72a46bb40536dcd99c65b44314d64ac1a3824b6a0655fb781a5ce3c574ab2dbfceb8791eb6235f4a9eb42a0fa770ca00a62a36f5d040046c1f40f55333e3512dcfa7c282f67b425bd014b3de98188257b6e83ec02d5f3d9f04877495ba9db854e4ee7028dd2a2d9eb22a974584b0c2b00d50b5ae446d60f9e2f1a008b1b3918d6489a6c78cf04bb0142c91c8253da1158989433d1651505e50b4b84273270be48991de520d83e68114121950519bad044ef3f277eb530d2ae68b3edeef8fc62d3bfd1dda7072a7dc968b37ca1b87c0d4fa2e0c788018347d372585ebbed1247fe6aa6f62bc830a01eb7c8f40a97b9e07de222e23df41f0d264156aeaa989927b65a9b1f8325e2552dcc9c8d8e2ded7f2be74ab143424d1cf7f050e9fb29b4e9eec6b0fe7f250bdc70e4084f7aff2cb167be87c63184d1d70259db8c1ce4624b67e4124d69320dd2e27f3863e66b17999729453fae5f93f34929db3b7ca9e4cc896d4fa7748075af25c105e54f41ebb501fb31056ca1828ff8cdf6ffe841316afb475e3476a0c4e46fa4751be67a318cc7f978475bb903637f2c48756c6fbd9d7cf87bfa6a88ab78d402d5bfca0eeb278d78ae2592e39c13eb162b416cce5534c87b0f43ebc2385cd1751333e6ab572cbf6cdf1f8f806a962203d01353af08bb6e01fd6acd5b784f66fd03cca56babfa4329b06e5adaaf835adb7fa17b4bb4a029e3101d9f25f3163caf5da9301486c989401215a718cf9b17f93043aa8b89ee7c32a113f5c20971ed1acfa4fd1239e9961f19a1ee197ff4588d149870f0fa3bb8cccb6abcfa864e9d851d0630ee57f1e4a2b52f516444e6330f44f460a08e617f3001949d98dc2be967c4218360efb5d4e6b00b38d2cde7578be80e9a86a6b1c78226d715b678270c69580ca1708c47919560bd720ec2c0e5da08ee48179a33a35534c11c152a31f79054d1a8fbd8a7be45070abc9b59379a15467937a85d82f23875af5c1fd0035c67d425ae4dfd966d03bf58c07356214f38af59ee36444728c0c1a55a574ff5378a8badd08aad50a170032856274ddbc3c6db53ef45091caa4b21bb49a2b5e388120e62cfa961f543749fc6d0cd1adfa48ba79ee6f48d02124047645dc5bd2a85841fea83c4773138508e3bfe089e46bb029ff2af08f23528f4a5673b5ce8a39639cebe52cad1d0ebbb107b917968c4b535b1e484b282ce774fb095ddb824afdf39dd476582e33116202f337cc93c4275dd6cda26654feaa1257b779baa52a7ba3578c5f9cb5b4e9071caa10d6179a3ec4bdb95cacd29a18cc7ce3123f26b6035e44b5438a950a908e57fe420f93e8ec6712f95affbde16b37f762bf61c37e28d163368ae5e585b2026c7699841ace9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
