<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a79389295ac525cc5c3b8b6c415b6f9779c521898dda45bacbbd4655cbb72be50b8f7c97200a8b13e29c8566b7bcf0f44526991dba6f0609bbf17b18893582b4033b15f5626b868d0ba0ee3fa5691bd97452bbd8e32df0140dff795b71bd24ddfc47acf4602557206f2fcff6965987bf95f1ffeb9ca1e5ff37593b17a131fe0e24fc9c01f994fcb243ceda289623ccf88b458bdffcd87839de426cc1a56595705ee20f041a97d8089054ae7511016accb48121a6af50d4d410623158acf44706eccaa700230582b910784141cc18af4cdc2b35fdfcea17c8e914e95abb3b658f715abee5ebaa3a90c69190ecde73e3a54929dc82fd6ab1fdabde536afb5f0013eed573e2eea9eeb26179d165d152f722b040a078e83b3ff1f1ab2186c4fb6ecf7c05b1ff1dae4b9882fec231bfa6f9ae5b7e99bde3e4286c0d20a6d543a9dc0866e634de0e4e60032159452c4b582216720347c724a15f208b0b6b6f50b846d7e8fbb17e96288dc976598b01b4eda4c3a108b2a5fdcc729bb07e8f13f0c9eccdb61e99a15653042eedf3f71cad3b2a2f4f8276d02b005c3cba3666601925b37d02c58ad2e48ffae7c642bc985dce6c83f56e41694986c3c76c88a9a3cbc140876d44be3a08e89e6f3708f8c3708d5108e9888605c63fb4f48fe70bf53216c6d5489286df2375675392eaa1c42e077a04fd68ed3d8437b93b1480938c6f2b278cab4c30368af84cc014b7b088a919cba38261803ba6639fbd5d5c361e8c522669382996e0936b3a3039b59a8e46cb23c894a9428da307e741cdde5f0e05f32a2a863ac2f3683f14681e925f0e0e9b2aa5716e6b54a2e514386d30efa04aa7ce7f8e7dbac84654e779046435d0cc6659399d8df91120e691c6359bcfff5a8972c8f3fce71a600bf138114233f305d9049654dd2bc25c191df032c48fdb262dcd695f098e54f3c58cfc205d13e036997fa5a6ca049b58076c3d605e042b67da9946a412014df6d41a542fa41859f911830fa5d8bc17f9cda0330a70770452a0cc7d47cdcb610c69de5d6a0bf79fbc5c0c5f2ce84a950d860b38822bdb52f785c5c58235a157f2befe7d45ef7d467e2dcd35886104fe8a43d18cca2ec2e103279523f0a7a0132fef6eb8fd506d09e993767cc3c6250df23efce30b1da873b9dd2ccc5494770659a63566682e38840c64abc6a3ff48fb5add9c6033cc536a313965d7847df656a1437faccf3cfe87587fb701fb244ac307eb6ae38b473197c0e95acd36f5c9d7fb6d9f3fe394a718455eecb5d61c4a2e67cc2b4e2c2a96395fb7231b9c2a911d5e9041887f67d5e6542181e7e6d00da4918371a475a7013256eac78dd95f1232403f9993ab5a29d755a18c5371735753472d71ca9e24fe8392732e3b567f6f0db0baba0a0632ab24996e6795b8e0d931d119028a3c0391407a176170a24d3c48ac3a3195684876bb0c9cfb3d000beda14a9801235a79a7bd10dbdfccb1ca301aa90563a2b53dc44cd45fedce877c15ee08af1ae00c119e8f2971621d09af944e1134d35b707e9349c84684de23ded743a19179f776d65b9691ec3a58c16c71e222cc50ebd0613b55592fb0e56c1f900ff33c9ee404bfdbd55b3a887bc19422c24281793d5c07117c11d7695979ed74942722544ac43f7160a24eb0ada78f6ad1f1f25d5d89dde3f029e120fce36cd2d804665b338ecf6040d1e5f753f11a56a12d0574bbb9a72b4ea91bec0f9a2ab42e0ae6b629e4c9cabf4aac5dbd524a242e9c3962a55f0d347e5603eefb03a4fea60e4e6ce298fb20b7722040429d92e583b87dc097108f45401ebb3576cf1e46f88872906bff64dee372b03cd1c7eece795613b5de12f6a9607749a52176b3297b3ebcb005b18bc322dd50923d24acd3da6bbd9f011eb9f456d7c1fae42d995068b1d081df626b8da6bdb3114fb86ea6c5efbe5ba7870c0e41d10b9f379760b11b30156efdcc4c94ba2ae734dd85302eed1c96a230e34a1e1991e81622d58df333df548161f5687d6d3a86f1d91a2dc504a075c2b774bf7f4144a099a71225b8f55e1fc718c0e11eece218838a26d13967f85830ce7e54c6beaa84ceb156ba5ba30469019d4e1a57de9de0042ec9dcefc16cbe2d95bed8e141990bb9948711b684976352f2a527de8cb1fbab0aa6049be7f0b32e59905dd58b1093270c56aab5fa1633cc8f699635d79263cd775317d0ca10129150c55bef1a60e808ec97d91c23074c6b1e01b99bb0f84e10d341440ac34013e943de6e781fab16841dff72303ad36643f3927ce55b05f672bb54fd6d4509743e805bd3c9a55199dae0d46b943cb01151021bf03d5cf45e92345e52c677e4a83e403afe74fdae8775122fa1b2fdd4021f36356506b31299aeaa535093a3837ff9d58c44ca57537dac308474d944326305a7f152b35e515bf15dc80f3c1d137c8abf075cc5a1d7fc0994e17bdb1fbc2cef5281977a8b2492a7a1432ddcce8e37a6a7c801cae65ffd90af4315d66bf0c9482086b0d5a059758f928a79815f3ce6cbeb37045555ac6411b2535c2da807aa34fa3df4189f2f0d147fb78af3d2f231645ba527c1a3351b16e1315af7559f22ff8f9972e82fa186b1c3591b1930880f89fffc9b28bd0c0433216a86fe687be1632561a2d8661b81442331f715b600f4ed7b442c9d2e2c8fa0b3efadf37d5a372fb8ed59e2cec3b9b50914df429114b0273526e9899767fe27a9e5795e17a51bf1d22b5fda2d92bb3f31eeffd44a7c9a73802e79408749a4bc8e1542471bf37f36a1829decc7eb95c5d3c8e2ca8216e67f5d586f3d6a2ba284d11550c7b1d3c78870e3b4b3b87911e8dd4c82b109c4105d489f350b817809400ab8ceee1c474f2f3be2e4b9d7d4703e12b2b05719fe73d787d832fae10107602c9e22ae7ade81e6c5348c307357b3453c009851d57a4795c395bb856ce37937f35c6712b1dfefddf6b044e8ced1f0b4b068972a507cf66685e88e2a92c1ba2695fe0f4bb441fd496d931d18b85e91ffe05ea0ff0fdb43140f2522b2d868421a7dea8f9e7a79b411fb49185670ae211a6424b7cb03b2ad3e582b6275d0cc7486055be36d815f5f65b052a6dafbf62078cda8b04f58f97eb6337419cb174096af28bff911c81836b919a7ea2d5766ea43b6631e7e807674c1eeef8b2e693d0c5c88bdd7591d204ed4ec33084caa861baf072d74a469c395cc83c95a05dd1734d29704c6852522fad44b826e81c50fe6dd3ed1cc22a8dcf8c3437e3891ad11d55417eae69e1a88d9a20413a117cfc05856644fcce69495a28932972adaa714dc2c97f046d623d4a446a8d190ffb253e2c8cbecba4fef553a6f491dbb98d857456fae5b38a07f3f808f782929d619cf233d8cdd5cbd13bee201dd4ef8c6ddf7d511223a9432e41589b8f24ef70375dc6ce95ea6acce8c99bd6695dd9fc7c817477a6536817e8597193e6a3079c2b0fbd515e300b628687d456400b064d1eece1d4630f7f2fc72d36e1295d8e8841efdb8cf60c5bb38516829efe548a080b46d4430020081aa889501a4ed92ec64f16515afb3737464f5f82ab49558398092f9c045c849933d4513e597d8a7db6b2027ef437a16909c48ae8806263566b6b62d4caaefb4025f39483e5248e71e7bbdef93f94a99d04d82fe914ed1ff6ed0e2501f1931f2703b65a930040d1d55215f7d597f194ba7e05898f3a6201abd4d1aebfa984ed7251a6578060c344a5d996af7aeb713d37d08a7e6295bae247a65ffb03feb37fa4a898b2597f4de2318816060e36269334fa7e3e2745466d683d684e970a86414d24ade7779ef05001e1ade5f2a3d1f3ecef447b6525fced61d86a5ce5e5a7b028617b7844c533008286062e9edb62c1ea789ab93e9b87ce073ab9f0fc569d97647d7b1b085f9e76e9ffa1fd244611c42be2dcf46aec0376e7321ee52c5b63c053c197354bd69d5cbb30cd38fc6fbbefef99a9928c10f6c83f718135653ccc4f1e5deb1493efcc3e15647334955fbbab6cdd4b033ad14ff47fda472ea385d87037794c39a0c81743b8d168e58c7b7dac82dda7cae931ba66bdc650b1c01aeddc6bbf761d41903db0b9826d5ddeeb5c7107ce7f0e05e453d9c15b2375148fb902d90554cb1832be14f01b57b8e8a308d695d568aa56d630dc0d6fe79d81b8bfdd61f0e0d6096889ad6fc2ba46b04f01d810b75a4b41209ee9f7c65470328d41499e884cb14935fd56548ab843c832c00bd24447e7f840e47c8c1259082b0d6a70f5cb3f44c31eb7b3b7f5cbbec54e69eed577b7cdd6633e3371078eab8bdd4d0f78e6c99bbfd7db5c2e0eeb1e50640b6e1de44827e314bcce268569bed94381900e6ebd330540451c4d0522bf8f1f2d6ada168de7ee4a1113c0c4882997f6190010aa048f3e8c0dfa5155812d2c701a54a1e8df78bdee197a66ce982cc3a05613b515d127d22bfcd2e1628f714b50f34b2b1007f35ce4c4f1edd1ac3c52321c42470dd263d0f27f35847e594aa54797aed62f5b16aeb27287cf692552c0699333790709fcf0139e3abd125072ec8230eaa21716ea761cb2cd47912a423d0fea51285a4d977b43c0ff050a90ccf423a54be9e1c08c994396f50419cc635fad4ebf197f10a0b3cd7496c549ec534cac3b35c12e9f187e84444180e28b4b79c3f0feb3fe1c2b474c573b797a53ed5acb074598f3ec405be1c8d6ddd05e2d8b3e2ff2d82f1003fc0e185a90ccde7bf933da8ef52230650a3e5a34b43244284fb7cf2dd5d3ce04f0a5add6639a2e1df4bb3d9480dfe27f76f6d11f90d0571a5d673c36a7a1eec46486671fe278ff8f419dc931e5867f757a6e9669d2110074a71521a1f587e400ad38b5c69b319d9062813a941fea2673d98d1a04f00107102c5bf7c75a6327ca784c527fd7fd3777b570e4be44e977136b1734896319d7040ce3452f550926fadc734f1fe6cb16f655cf3547843391f12434a040b45e98e955af87cb7fa0cbe2feace1ae03ba7ec7d29ffff2739a6f55461f0e2fe310bee6e127f13056f47fc52165d00c80c6997ad4f9f974fa4fa0e8ddab0ced1ca0089971304d30d61893c8841c2c19dc5944416efd923efc6b869f3d9bd83fa62d248cef3bbd949c4d942a81cca4f2881f50345e06a73e8c465f7938ebd65890c02dcdddf5cb4191b88dbc1c30b8a6f3766df6adb4b4265bdeff57620511dbefc1f911e52116234fddff9f1ad9b3e0a5c0bd79a3e2632dad487d18870b19d255c16593274e839c6b8093517dbdb788f143ae4774197c948c669ed413252c6116a390dfa2773a5ff1aba4370bff486c2edd849c77f9b84a20eb78c4525692f4017ec3c9e2772aeece449d1cccbc60fb70daf3cff8e7ad3c738fb7c0e90bce4a23f52a6685d581292ffaba85b98234fbf9a7e63169918954b24e00f0de96f6d049a61f6ce6d5914aec8a0f66041995b3de0e6f314aee67fd01a8dac25b8014e1c9d7c58871c0056955ed9fa6b3ccf26655af7049d19a1234fc57ab451dfd655bbf10a7f949d080632227096d365e540ca5629bdcda7106ba196bbdff03855da9fe2e3c176da6587e20e08790dbe12de6484f2e4195795e2cf3b4ed4c918f4043ebb323684b9df6f51b2fbe45ee533020586a96d3f31d0a2b809bff487c4fde389dc6934ca13f141e168a9ff40ac8bf14264e5bbd278a09de98f261b5220ff7b5e8e368bc2670e7e7d47fc1c98d0d5e5c6ccf9821b859992147593a764ad160062e9a8845bb3a4c49c51ee25459122d4bbed2a120e67e19852bd83b1e784f5c9c5b214de54256785abae22a7931816fbd113d33645d9d29075d20a684e93ec95c00b1e83aa87a2b28e9c4c499d2af5693450d9ebf2d4a3cce95fa68cbc9a47a713fe57dcf5a3ec4c4e7f11842cc7672aaf0b96a45f48aea6ae12fa6b019fdae467093f7c12aca156b5077476073f401e1cb925b8badab81b94652202fce2015496cee77cc2e2ef209eb1ead5a347de27959d4fe0040ffe6b06468276b0dcc2817604530fa50ad1c9660fc9ec5602c331179238481d315ca03ab7992b9820af79c44a00c1ac9af38a0cf0666507966ce40509fecd24864fa4414c376d371f3497a62ecd8f27d92e50bf7d3070e5402d1c9ac9299d920253d7f031a6cfa6ef180c44bf315fd1cd8a7ea526e914e2638abea60d21d1fb4f6674121a34dd0d25fa3e62aa5dd67dd888c66e46089cd85c4659828fc014837a76cb040bdb1e1c2364efb51cee7ab94bdc01c8d618b30f97c1994332506ec1b0f81c0caad85817e3f47f9870eb4ec9cba38a1666f8fc7d886c1447a8eb462232111017aafd9eafa4c4488b5cdb7f93c8afc7caeae3d10498c9e0375b4b68b55cb5465051bc46b8715fccc5bc865590467851f46cace5ad552cf2c93dd27b351d428b514d340f20dfa3fac6a299a22c9a32479444386deca608acd02da1b2d4f53588dd7589d26f3fe4c867c81d52079961aa746d52540e5a373ab765e4377b0b5ab128f599ce6a666f7141d3cb83f82f05182ecf53740d805d59181ff3ac858cd87b151d925ba8fc66d177279e69ea7325c08e698e0638aeba87beaf942ca6a13d407d417e82103c8a97009ff352ccfb7e9c066f50fd3b1d9aa906e981cb28c5456dbbd6c20e3933324b46d0d23fd28f1edaf5971a1fef245529dbcfc06f9d055faeed6ab89960653d155410fcf0aae7980fc98da85256e2e009e2481d0a337b71a70f90db9694d8c67a6ffff974dff4b058a358810ce11a006b7ad46b96b03468a38605c01520407ad163e443b49893f4889b0d4a41e215aa20cae24c64432c42e2be4f4150ac58ca5f8b92c42a8e033c32e89a08cc15235a61b4738e1a83cc32b7c58c80eb406ef7a820e01ed11d9f90587eb37fc363cca3c703c8545fffea8747bce984ad1e3353ac0367af471971137f9de3850171a767dd7f665b37b3acc3ab9014b71e2d2595af19200d611ca2c7a53f452fb64206400792e4e441e6b4b4294bd8a7c083504fbbd982f9c5b265d8fcc3d9b90a4d13453045007668962a8924169fb91aac3e533b0469c9a140f0e7ae73c57e5378bece186bc5d08cb53af408e5d84201fd3732e4d62b770c6521de9a5d45acbe5c448caac9caf15b5cd4c701e04ee69bf22a63c250e75a3ef8c90f0b5f8858220aae1c029a490eea19a80181bcad84ebc6c383b9f29da567f7d5a1791293baa6f8d6009e46cce819f2455235a27e7335ea36b1776de99fbfc957e9c45649536cb5cac762d2a941a24ab62c41ebe143677b0f584af8ebe774b9258677bb6c5be42727d94a7a0c7e92abc40e3eb18510bfaee95459a9a6c4efd8c6ac221889095794dbb6f5df1ae5e6ed41e3477af7dfd569907afb83a00e660e5fe5e8779cbfabd028365badcb131f95dd9b4918ddda2ba90ef45c5c3227bfa3c62866404980d4251e275d6f67867dcf13735d7942341727b704c3811c3b8110fa40094da2d05223fca30a17fee674014b6f95741de3d09137e538347453af65666d33a69f9f2328d1a251edc625a1ef6b34a81a7ed694b1482b579053fd9b0160602f42e857d40d7087bacf37c72d179d62948a03cec1ca387f5e589ed110a4ad74f928c80d0938ae4d8b812722e2b0872bf675ec438fdc450c72144f74d8f2834be7210bf70c5fa9153f8b162c5f3f7c4440424b7d3a55925008e96d602c4c15797a40d961bf99427bf92f75fea2da72251cf2c272590d36f72e79ef5944bd056343215cbe36d66818ea7eddd4574289bd362204aeaf7903b4d55c84b6b0c44bac7d4c5765a52c34373b0749ca8e667270f2281bdd7244d5bc4df6141c68936e715f81bb3bfee6c2bad5e683fd3d1108b2b501ea2404605a9deb33a5bdf3a8f84961d4524ec49d8e1edd26134e9013cb2b70120be3a5450f4515f754cc71c653b3ffb6311e836066a2f9b02418ca14b9a10cf7c1121a7e03a6185c90e6f848de6e05d49148ed24471a6beab40842f63939c8054840d38ece7dd384bd7d146dc978bf2fe2a28cf6a31fb9e7de7246e46ea40ed13e28a838f5dab111d1aa759a59e7fca4c2c4730dc4766c1b873fd1217ffa818529d0d5456cad0f2b60d7f1cc1a8f03521e6f21b5e98e38c5fcfbdde3a129279c167b7735f22d7d6bc94ebb13a1756458156947b752b54fa23cdac0bd8c9ef7e45f268bc7def09ef9934d5b1e8a6dcae8c429b8c7e766321bd8337e6a4a6e682aa7d4d0fc7c13cbcba46d2ae15e3ed56158bce9c7d0284cba4b341044586f4eda9bc5d4fb7d734eb03de09d3f138ce988dc5c43aae783d8f16a58ecf4f1b75e40e556ee1cf67a7484c9c56d0cfea86efcc1d9fe443385d1dbea4e3b99675a357f536cab36d6e71ea137d91dfe10d79be23c20bd4dbadea3851c4fc73812788fbc4a5dbc15462ccd4d237be7561bbdb0f12f6cbe9864c1af7dbf10f037b01810fd0265d0701fe605e41149f50743c2de8e1e98aca45dbadf18e4ef578c483199745e919a49ca5209d1653cf392142c0c2a4d34c0f6906fe15a03f3751405593555efa4667020c5d5269c63ab03ef502c93e7ff7d52ad63fa8ef63b5feb7fcd7f360a885c4e340bef8eb6a73e2f11016a48b38d879ea90f83c89374a5fafeb016aebc52ce7b4e79826f501b7a1e52763794c7902e7c179ef01f41ba0d8cf0407e6bc83c891769533a8bedbaf3fade02e8d4e2bdb883cc4d8322dac3f8c8896c2a161032e78a595d708d635d9adaac9e0f251642fb9096103adfdc32085b0cca5b5ca2fa3fde715ae1dccb6f2b9472bd5875787d663f5a93da951132f67ee849d9404c3119f472470bb2e73c890d6b55a060831aaf49458964539655da7d496d33f18dd0bd933b2eb832089e84d6668234687a536373f4839a2bd88fdabf2e362db5bbe9d43c805f0eed51d8b49ded139e7ee8df9841286d7b8598e2718235a0b5c192bd2e1c970185b5f9ccec057dce75b02102c9ce35e40c64fe07ef43765b186dc2e3f428f8d1fa4ad555d8676f184c3b575755be5258515fb5c080780d37b6b11c36ae80e19ababc363857ecdd484cd3b1942436ed3bebd4ac739767ee85283b8aeda02b4aae213a33f6f72b3dc3d581af04d7aa7f6e91203bda77573ec833e93fcea96fd562d8f54df5b3f9516eeedab5cf7cba241934d2534ed8827376e0fb8eaf6d291d3eac92839d077281acc5ef2f506fbaa5475093b8ad6206e03a8841509b14bf56b2d0712bec807c41cb94405b3e25710b98051989da6f7f1b696dc6aa4d1cf1bece46de5bf55ef09a8c15b4e4576181e184f7ceb99c86d1a628f42039c2ee89a0d070814b87bc132765588a396fd9be052f2566e65b3234fcdda823631fb49c21646e51b861999abf2dda3b82fe95ba41291a513569d993406b3785077056f11a3fd58031f8e7caf7daf80f2fdb711169008a2c840493b91ee2f204af198fbf97182644de2f9c33deb6364ffae45b6e8bfb5c66574e13d4dacb95322259e8e5070a795ed17ac948d3aebc3de173e2b842ce85370c809208984b7b8924f89af4c9d6661b93ae0bec53dc06a096078c112f3b54bc6d8f66ed94befa0404b40d77e776ea99e7339511c36c8a59920ac411950338ce32286a6441fe25d65f8aa164f78fa9d0adc1141cb5ce58e5196213b89845aca509d502b0a1b73e98cb2036558ea22eaa2eb3937cd3e148ff00f20beb47a95c9286d00040bad19b34cee427186da6d25b9b712ee714b409d8bb4234fedaa8253a382768108167d3f72ebfca0aed12d58a630c9e28cf834217059bd7fc5f1058ace5b3e539694ac57714faab05be42d73b6730114c826d65ac1fb4bde8aecf6bea81932f376af7c9bb63c2c68ded9a952ec3e58904d27e4fbecf4e7782dd8f87c8073064ae24b6954f2a546b53ec3bb4633fc5c2c4d6c47108dc9ba7485990e00cf420b52b0069a2589f00be0fbaad8a8d9a00e0290c6eb0f43e746bdb3151405338ecaefdc406992fd61189e4cbb118fdb0e8a983c51f1e5e5d995df77c7d6eed1f34b21113cd01482eff1b030cc5edb220491afa95465c909f0b76a3786491b01da82370e6a3c3c29c732bd471d6155bdba02b08f09bcbdfae4d5b54f9f74bc082887336e7e2b0f0819fd14c363d7d418c8c5d7c38d5a715beb3b833bda607115c0a8b4de34946f18ea7024d9885ed8410ef4cc922e526ac4716714203cf271dc2c5bcfca399c2a54d0e955e49625fb9cf8df6071781bb02c33006a78ebe4b1d3b9e4154e0fd76676cd610970477762f2dd4987edf4a515ed9beace2c6e1b03a9836e60e74522554bade0ce89409c6d287ba0c68aef8c8dcc8702a7b423ec05167466fdc9023c3420100881c4d96d37c295b9ba012213a33e387fb71696bd0a3c405bc4f01cae8685853224b47d10451234841ab55f92bb6005e807d4826542aadf0e0498051f88319d65c42e2abadb4e9ad5235482c4c2a35e885321f00fa3f91d51b3e1fca9e08cc47ebd37f532f9390dfdd0889895148e6a6dd703f8a8fbac62aeffde82e48c10bac47cca31438ce2bddbbf7ea3dabef623d887d2b8678d8d0a7a890e05fa38e712b3d87e15f8bc1d480a78a2625fb87842f43fd75d130ffc631ab2c9b567fe01203e9576c2c7f9f05423ba91cf254fd2ac7cd3d1c1d8e6cab3ca4e10b29f68dacc318585d87ca76d0e5c454cfea04e873afd52d89ecd42217e56b0c7131d47b1dcf2a7869b9c42d41a7d2fd6bdf6d251bfb7ae4bc3ca1338eadfd2b0a3a667dc332a9eb0b362e88fe02a7a6c327e9d3a15a538152093df12d7ce5deeaca4e432aa37f1bca9fbf0a418169d092971e65c20949fd314714c048a6985931cf910cd0cab639c417763cf0f6e48f4f58fa672eddd146ab511ebe238205d4a3d049568f917dc76bf91164f8dfcfcf374be87cfe88596c79de02e6377ee1a276a5839fa2383dc1ad0ab10c2a95072f5a058097a36c0172b51102d757d07d812fa662fa24934f18a3318d7489ac30b3a0742ad53975f70c6759cd18d73315559a5ea413d39ab9747f9682257343a245f437aa2c6bdffb30645a1373d0bea50659e257f239f1647ca9ac135cbf63f09dc1511bfcf86cc56384f802b37a6c0461696623135d1426134f845c23667845f66cc5cbcb945e68359724e819bb1a922e9f9c6c086437ddc4017fc96845b5793860d034d8be0b2d0c6da6eb57e9593949a0545c95fc34b6247e1dd567dd18c8f55001bb09a918206a1dc64f313c154ac81cfafe7899265f7ae4aa7f26009e769b7a80c0864f53b9968a65fccce93f0029ef40c3d1f83c68571bcb1cd0f52726669e3a1d2d2e31ba460631f78eaa68941a62d1f82a4ecde75cfe09598daeb9ecfe0598fb94bd896577f37d863c600d5bade86b2d1c42c7511d95ddd117993e237b3350b61e655e4e9ac0c5e84617543476acc5f5fbf3d09ed4378d75d25ecc716b3a8d02a0ba6884f7d45567310d3f49ab91baea487916a7a67a711493d2ffaf5e6dcae9b8906cc282112d481069fe948a146ad5462ee2c4ef223b11fb6560deb778b93b3983a865f429cdfcdf5f0f642f52b8bfb2408221c51ed4478454426df2a2bade97f49243100d3e26848d7f9e2a64461cc7844796b55a6ae3537705a1eb430d099e8161278892785829605e92d96631f943622751687e6188b26e973e1eaf01289951522e57330b6b8cff6947569cb45bf24d23b02c5450d8a5718969751cbb98434c3fd49eea31638a17a15bf5612dff257e425e8b6b3f73b8a6e6ffd18114ed89430b72122b17da950cf4908c034163936e9c5ed2bb63e0ad58309ae7f166b451c9e9be81deb7d917461124f5323293aff23e753059ff9c00375754d20c0f558a0e1bfc0aee1dec4681613cac7f3fafb09e3eb184cd4d5ad02c4df75a231ad83d2efbf871be71386c0927f4d955b45fdc655d62ff996048aa11789b5a8cc412979f820bb1a59fcb5e28c76eae4d75c6fc46c6141ef56c3de4071eb1d76894a17c6581d54e9c5d045950838cbe781f928a1a12bfa086c3a6c3732d763c19ecdac03a6869c9f81bb34552d993eeb6db519b74b9f61462bc869cbaa2d29ef29f0214173b7b818e5f84a5aa177222daa75b75dd3c226cc639def99e4e94bc936f63da40408a7b0f458558f96d77b7c50f61d0d08b831826126b9a60425ea19b0f7c6680278fbc7d0222a6ba1a6a019e14dd05601012cded66ca1299b2ccc7f543ac40923434ec9b2f63d3ed6bc4bfde15f4666001653613ef406aa608361b71f437be45c2d88a56c9405fa276d4f3d67a0d1cb6c7d0e20b9abe363cd34d372f30b90827f16453173046c0fe8aa2db534411161171edcb9b4c40a06b646d63d6ba8b303abd8fbd6c09514d7391ff7d90b2d0ce9d82ca7749b57eac79d68aad7adb5b40516be6df03ce6f4ff525291dea44d75dd940ebfb10b7e68a77caeaea8daaf0d49c9d214ccc950599922d4677c2659db205da2c6584e5af7b4370fdf227cb0b849304bfaed29af7adf76e355027abea3adb1a7546a1104c9f26197871264cd74b53ebb1d8775a81384015c36f0c50e6459cd870062135e87bbda935a62fc9c5ef523b4461843f9d2d00955f4b60ac42da13c0d3fdc79e7c17e6fa5cfc8067f533a22c6c06e87f2d1f3450ecc9c278a38c77c85404b4bf59c24d10cd12c2bb54ebf2f97d695cd16715573757722e474f02ea17a2ff7dec37f9ddb489c2ed486bf6eed1739f01f41fdd42482fcd7945cca4f8a899e83257a9dd4c685dfbd26c5e6a4d8fe950d5a2f4c6418f8b1f031312b49666008f432b63d8d2030354e2f74bcd1f9f7b10be570573bd502274578abee3088f112cd07f2b0838d1ecf33246995ed5e3557eea600dd8a3843cb0a895bfd1dc72b3181d57512f5a61aa24b32186b70cb27f74e5573099b8861c1c4b1e04c9b6a939317cfcca18f1bc719284579cdb5284d2533cd2b1092870d342362d26e9c37601a12bbd1266fdb3b8669f8e2e0f53567f794891812acc40b4ada3d6fb4ce4c9b4d93a17a816eafa38d9aa0859c7fef01970913d0995990b3deacc3ea011ea25f9594df2ff919bb6bfadf8fbdb8adda0b1eee7269f5d22a5572fe1b23a43c00fdb97e1aba3b7d2138b5145a57044b67c8f8f89230893fc5035885dc5631b7f9960998ddbf4fe06a1d1960e421527716602e3caaeddbdfdf74494f2065e0e2a127b0995ebf4d563bd4826e0613d2307f16a7fd74672eefaee1cd37a7286f54ccc88430c52735a7eac4ff6a9df6e88fd3f00deccc4bc63519f04603f3737ea79704cff839fae129a2222ea9897f580d43d94b5f88878efef8f55fa84fa611a0f2ea554da45f3fb9e29311fbafce42ae9b17280df1036c08b2222ec4e0eae0f28a5f6aa754ec69fbe11341d131300d5fb7199ee61af97906929b39e8b921dbf929d274537e20c21cb42ef790b4a8c6f3a7993ec1d9c09ce4e47effd710fd03dfc203d976c42721c7c1c26080d614c5ebda0feb7fdfb936631b983a32913e28a33816653c9850f03e7cd91c98bad27ae78e4b6ada9e38ceaea356472c931eb3dfb837aa878cc7aea019a35e7d3fac9e02939429a9826d72ab62e3ee7c65902030dcca2c5374800856bf2700ea6a921244b2f6c4f024216d087b13fabe4938df16c723245ac17085016d6249443eaa3a638e17cfdb898dea9fa71d199b2dc821f94eece1772ce21c6f754abc2e2629f0aaacf296dffc23d8c33357c48ee13e8456a87b42b1d7e78338aa54786d2edda9df605b4c7b81499cccd19745755355642dcfa506dbbed1a0599dd6c0a7c8686640c217b3ebc81bd1c376966a708de298651a518ad74b72d3f3dbc9f26e00e899814c7b026e72e6902edb44716fdf3bf129a9a5eb6f89a704724c000121b554398f113bfe0d5860e6670fc572e68038f3cfa5b8d05727325bb8372e69ff4c4352a28a8fa6973dd7c7a0e6d061c27e0d3745e3bdeb28f3ad4e60ccf3f14788fc7cea7e94546023b5aaac083454e7a684a32e429584860108e280e82b92131e6e3f943aa41e0e34bb3d608d7147611b4d4315832e62676e93fd684ff1c49fee4a75bf4b54b8d11b82b602acf96447af111a9edd9c74c40555ad3ac1c092a32843fa834849cf4face47677324b7a6648780b7103ece51bc5d7311381e06e5f2699e8eadd692c3377a4cd84868d8bb5b4b812478733f1926a85204361d97b6eb6d1b254806995cde47a45dcbf215fccd72ac56e36d0c4933ee1688ca3e55429ed14c3530f152bbe65f564918b97a95f2e26c21635127955d01cc3facebc14458351e944dcdd2775ad59612b227352c22e1bf8300914acd14fb605ce9f5876d5ec73357d7aace5c232a2d69432c43361ca1293af964c13757e76f5461b58b636bcb03b96483aa21c6bb9236cc25f405bc1b816bcee70027bd14ae4b5ce70e3f448f9e30f4be8a33c86323a79c77589f0aacf05f726fade9c0d2e8bc5a4eb688de45e98fd66da4b302a92c580a620238deef4e48af8f45e6d914eb7748d4bd14d1fe6c403763800b8cc685dce607d5fc726442ec2bf31b720fcbdb9201cc212b8adfe392ba42536044421f68a7da951a34aca427800fba59018982b14bcc921aef2708dc7ff4d0679bd0668ed33ef310e3a4c9f6ebc65c0b77ba4f4892ed83637cecaa43a686f8ce1f177d040068d1a55081692691a72bf125c318958ff57551481e89e6ac2630a91e17105ca7604a791c0c78bc5e19d61b9af0598b8b388c8a41b927b991ceb911514bde5a930310e1f1d2223886278489dc9c467036101ec8396ac54da7248718395664604b0296d7a70164d1c6e9abf40a3d0646373c784fec65bdd4794a702ed5d1e69d5a187c986be02ce51b1bfdca6f805811ce1f2d401b2591ee0ac398f90e1d5de8276ad61ada8bcab40380a80fb8c3ded510c64d4d17bc6febe9ebd172c4ed6cc37bd8040a3ec623dc88cd24f003a1e0544724084f5d7b01db0be62232d51dc9aa111847898d2b2e0843fc81ab840e8bc0ae9bb60611e2ea8d3d9b1bea93aa91898e7372a89afc280b4599dd96111e00abb553ebdcb4cf0bb4fa1ab2370e8dd1ffd01fb6b1babb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
