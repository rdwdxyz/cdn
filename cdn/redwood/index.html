<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a7ea7c1c54434af16c271ddd8273f8278e8598330badfe9aeeb979bb44d05603094ccd3dc0fca72a83914ac032a3eb78773316fd92b24708e06b2b76ceeb8e601f5b7a1bad64005bd2396503c0b7dc0eb96cdddd4a282793a11d7bd3c99674c0dce5beb2bcc816393cc05f06e90ee15dd7362fc449f687e547cfac08164c373c8772e7b4892098686a2abb69b45d57b20aaf3d278fd8553013d73931f6b2341975d498ab52acc8d521bad18916296d1b169700a373de61ff0797a17543b2eabc0cd5a7a12d254ffb04cf579a07665c4e94b4daf474bf1f49a966733ca6b1b40c3b15cc4a7edf465f008557ba6cf7c90f3d2f5dee58f1171f1f5a672d92504f241ec1a7071f8632c6ba56cffda4e326a9b6c042f17e3e743eed675be30cac4026168652507141e2e2299330633b8e07e8fbc529e6e9fe4aaeb1fdd4700715ba5deb96626c17464efef81dafc0bbbd46095054883548fdca0c82bb718847bba817f78c30b779aef6c586f8a7d1bf8ef4c9bc627b46833614ae40981bfd95f90b9c7d6e203e9f4b602b928196aa94ef199d769274f194fbf5a8a7a6bc8d9906c6487803419e4ddfa2d6f2c1ea2a03d24a9bbea32b62d0694596bcb2431959e72bc1676ed2d03a454b54a17a6e77f4b68b943bf66cee68680bd978c263bebd1f760fb5f235b06d5a2f79ba51dbf5358db9138961f5182c38f04b25e3f205b12a571440a8868b9b3141bccc143f377189a107e9f5dcb1b18f776202aec2f37d3df74761dd4ac1819881ca940e53b3d504c3a00fca024ce1bf3b414adbdcbaeecff0a8e739a2c157ea31ff1710658f428c94a571b9fd912fe1a4438a390b87c869efcecab49a2a9817c8ecb5027ed50cb4a232bce1dabe97b2d3edf90cb6c80d80984749a810936ae1cc7c49130b54e7666a771ababced4cb51f2749705bb61116167851f3e63aa7f7f9d62264703e5604ccab5bf4767a562f36cb5de0a8bd78d59a556a6041a3ad7f2a49141d61d598d5f3e328d6df57b17063442073ee7e5fefd45746de53806f4c3c11883d2e0629585f5790f57cd6cfc6f634fa81b6dc7eb100ffb9cc454fb451e9930b56cc8aa5daa84a6451efcdbd3a2d590c4f4a75a9666d6911a843713e3964ed64dd4f0e772658069ea351aa8db8b72f34f18d6610ddea4aa0b71ef2c14bea888f1361322df854d671c9f8a531424c92135fe57dad68afc03f2340611e398a82d305d30945a60abca813cdfb5dd5c80bacf2ea8996eb0071370cc8c5f9d9985a6e8d16020d7181545056115e287ca79d6b5f37be43eb8dfa23bdac2dcb62a09a2f8ead8dc758ba2402ff28b3f0c3091a0984759084549763fb1bd508300b1caed50e78bea3d54731b31bf19ea57d834951a42c7bcb961598e0fc80ac1919e64a0e9825332df2d14ff9a38990800b5d24e3ea8d86e0d734aa047a46506ccbed996e8031e7528b668fadaa2622da47ce2c37eb501a4b4f0d55ae36383685c37908642e9e67b53b0839bac1de9b0d04f91028b9fbf87f0d9d78a21bed2be0f34bec42a2ebdf39611e8089c7ddd25a06ea770076abab97bff277e89a83ad0f7a562e4252002b69f57e1f075fdee4692e455f4f5c7d4333af9c2556721cd27c4a6ffe862806fb87864cb3e82f9e04aefef7e0dd1689cad5f1f05a4d65bc719cffc87ce5b9e6923ddcecda45a64f3a29c899757d9a0841824ea2c6752a69123e5add407e0c1f9faf22d8a6ba2c58187269d798ff13b95fc4d64d6f16b79582fe5c981f2daf499043956ae7f87b63a2527653b3d51a89211a90c66747b3a5e3be2d17a0fb7c230ec1c8dfacd07927f54df4bb22cd4e8fd63fea08328786b9e993983a0e1c04a74aead55a405004514b4de353ab9ee175504c347ca4bc0047797f2fe0ed83f66fdd52fe25563f5e30cf4f70b9fa265cb75b845f7a98f11424f7b41d16ac5b051d6cf96d96c05bad0a472863d139bb8591acaf14ad04e1b3b5593aa6b1821c22ecdb2c22b32059f1e87efe749b36eba9e845198d2a597ab9b026558e695b338916aa08d043f23fab78ca80f06f3826b2af1e831507e6563d462298d43941377330a7854d7feb29b68492f50fb66b92d761c49d3f4359184b09a4d8e87487246292481acfadfa77ca6dd7f2e1fddcc23093c430f48561e8a6a59b5db27639990b664560a614996fbb2fa8d29af66bf8275fa66141bb982e8218bb0069db0dd3aec965e8c1e35ed0a01857bbc6601947f5d47a39ee1bfa4fcac1c3660bed88caba4cdb0808266b01b6e5e3826fec50fbb0654447e01a2e04c8b3616a87851cfabd955c53662607f68a6deeb57f60bdb007cdf9bae0f604c0a76b37b20385a029cf35d75ba74c83bc3d78427669c4112b49d07d7cb1e7d74eb7fc4dc8ee240cd1d0b6c058e40586b615cd8078b9b6f7bce49ea625a16a0e9a0c45f7771fccb1536cdc60e6b35cb8e6b562b305676604493466df0864e6318d13628f32fed82807519c937fce3680cb8f7a2b5fa80f17f40f13f303b8e0e7480c7bfb2fb5cb9db53f0b926ae6752e828c60766a823aa134029828e679889bd17a297fbae0d9bb83e4d0c0a83867634049fd4fd3ad733b7533c01c035dac8093155c0f04e207865f6af1b7cbfd844468212d4ef2ceecf08cda3a4608cf3446ba2100667f8c562aa2035c2c3bb401e608309df4a179921ff5fb6b8fbb11c2e139c234f4eb0ccd325a56e7fd20dca21a4bce59785f9c0fe0fb9f32547e7df5fbcac12ae3b806a84c7cea17626a13b13af4cd468d8da97b7662d255ae99a99d34530b4a875af5d64ff0822a7705cef3dd674419203e4c5d9433ddb891bbd395510bcf67e3edd92d51880c587ea7a82fc0a6a7157a7c03a79425ca6b72f11a175eea6fccd0decf9b7982ec5c3d50f8bd3fc251ff54ad085d0d267b6a1838dc6583f2aa5aa1cbce5f7abaa669acbe81b31a32b30909aacc275af0381483a275d4ad2f07b246e1ae863d143ae850db76adc3dc78a73788d5d36367c21da330bead2c787d81f752f3c7798d240dc80a7d5c320c4a82552556dc76cba63b91fc5ec907d310e846d6955a536b5394332572290aab0551e883c4734a31ec73e64281467e256c5dee900e48a956579bd484591c4f2569738d9690f1646bb023efddcb157bedc193cc471fa9e10a092a452a4483272a021cedc4e8643dd5e587170c947b18dabae61ea69f53add40a8368e0712d16d1f57f4c4f51c88d518aeb0146c4f337fac488a2e33add07d1ccc84bb6841a36aab0843bc47aa992497e5a5bc97c2e3da8603c1476998d48a3dc539ae47eb12f9bb2242c2d33a7109b35d1d917a477f698d8abc640e3e3dc3ef984e1cdd21cec5ff3091d348ef7e700c6e75e73bffd83864920238345a3d7d0a9b3e8c090df2ee11d7cc8ccb96ed259aa8ac295e673fe3e6a0a94e536091f445a67cc8eb993ea9ed2d6f18e024291167e1dcd1ef64f66c5f5a8189d4ab9e0a7a5a24a383fd28e862d9c6c433903b01dd66df5c57ee57cba4b0869c03fa1e9f9b4e24bdeaecf45aed233d4628f520746da26fb7ad560e48a4fe831ee205b5c6709480cbca3fbc7e8eccb63dfcbcd9611b08db9afd85a09b8d435de247ee13001713a8164b742879f94d430069c619fae6d6b1840a5f2e0b31ccd053f5ca40c2e21d247b9e6ce61356b9f8746ad227c5003c26709e7d9d03c8f002a364dcf66187c701f7369f6f8f89515b1d5b968ecae6edf88b8af2edec25614cbd03129b3043819a95d98420fe8e62f846ed276a4502d164ffa4d2c8bc423dd03f9eaf4072f4eb8a7904c9d306b223da0b70b1e0406261ae647d91f331c8e1ef7f427fef172485942ec298a2622e30c63e51eb2e6e028dcb3d3d95bde329fa904fe9955cf21b73d06ca59fef8ae1cdcaeb9033e4b6298e3d4da97b53174ef11e74b12cdf502f77fd7b14d018a3af8550381b7c7ff637cf5b5466df2c170fcb6008a634137e5c72484dfbc9e4e6da02e3626fdf84a5b9a0168fb5ad8d7483ae1129964405d8b681bdbaeb26c805147af945394c4d5567fc209e9fdcfd5c8e9256d8459a77412d7b6fab4c581c3995f02d9a4eced0e74d21bbefa3e365ebc88b915d89245f0ee5c8ca5d514c59466da8c0fcf988c84101a09a475fd5e9cbc387b8a1964355f260d404c28a0cdc6358a96ade5966b22239399c5334c817b55bdb650d252909166768f143b7494e7a34fc218ec8ae43128f57b6831991f9ba99614e245b8f83158ecb82efef25117102fdfce7f2aacf53482e425a094a88469f04dbcd05e57c9341c242900048757a907ed73e7a30f5f0b947a3868d91f5e6a449802344abdf2e262f3973ea476af52468d75d5142debb14f91b8476e1f1e5154017b6cdc792f0711ce1ff0d45552b4be108975ca45a617687cede7a6de376763ddaabe73b5f7eae58eac3868d83b45ac7f8bc34aa7619d3fdffc72363fe54447a2c79bb7eede0b6cbbdf4e6d0d8697e8c91b7eeb1373148e258b8c13e5a7c65f1cc454f613fe03409da37a50ad679a37dcdace928d591722547b91b7aa5e0d836dfbbe92b11287c54195c35325973e10062e4f34adf6aa9b46178baeb2cfa87a76bcd7c0fb60e1b746c41df0db6f2c6e2b711a3153fd7904274eeca1126901b5f1c395aff93537cd2bce7bb88b525d35b7349121b0a5692ea1cb39deb25c7f3f76575eafc945a175ef860385cff8b22cae31309696e1cc8115fa028d703053a83fa3120d04e6e71ce3079669f97d5278faf4b8476a5b053ba6fd2e696905b9d3fad17c5b76fcae8c2eaca6f94102a663927ad58d64ca4570a2299371ff1fdfcba1ba9985dbd6b9b1ca15d1ae075ec00addc4669778a456f4c2e1457e4d417cc78fa260bfd3eea027c4eb696c0c69074674fcefdb218452d8de00c4e5a3fec95718992b92ba7f6ccf880b83d2e3e7dca44339efc551a73d931a6a3425b7da5cfc99bcc1899fd1bc1820acea3c85cba3989cd62ac63f9dc7c2efe72641a18c2a15ec6795bf2b6e4bd918a6dd8f7506c84bd18848d6bf692d51197faf48cff6733551c172403d69e27e07e31643858752ae152d6b6dc0489ffab347ad7b39e116bd4f644dce314692b0d8ea10801a6bfdc9e4eee4e7dcb218081f4a0c5e9d9721e175cf3655498a9beb2f334bbd8231933cc0526f54c0ce59659acbd0d4d4fdad4818c38753f44c3a0ec07c84abaae4396f1047f2db0869eeefa3037261aca08f278b6a42729e97cda67166917b02f8996e64aeab1bcf6b8ae40705debe234e575fe1a3c46b88469ec053e8044b213ac49e6e2bacf96b5bfb7d0eda2ffed5051cc319a4b9895e09781c9b861d7fc4ecd4f2b6ce35afc6c0e8c40ed39df00b52051e59fd2c6191db0b3fb318e225dfb5a7ddae77c8a65ca752cb285617329be65ac20bf11c53eac97f2e370a4c1041b9454462903e09e13bd9c1d60288f4f15998de899efef6c96d252220be9c6d81843c859d0d52203e1fd30c972e7044ee45bdfb1ea5c7261b6dfd37ab9c75023f4675d267888d4adbd0a0addb3151bd4f394de9bf5f452fd716cf585c79d2e3ab36849011f7f7d7f6ad82e5026802b14b07d02f6cdaa2e6d8d89a5a0e4788e4d2edc743bdbe50e9d3c8059a41b9298fff36f5fa74c22c9c7d5754ac4b0bb2b93e1a6f93ec1f30918fc64c525641e192190be92df4085f6134025d61d829442c0f0957f35dab1229a4aeb85a50f1b8e9f6ef4904d45e7678cdfe8eb7b786f1c18814c412340e145bea7f4af38c063625dcd92e7d13361681ffcd10f84b74f7786b0124ad9238b5c6450096465b1a4bd8aa1881c7b92e7bbf814129d3dfdcd626a4da9731f14fe60a49d3f0124ff41a011d890bcd70e07ab5549057a2ebd6b6520b7d9a445e290aa91557f55e3e6e6a122f7f417ce839853e7f4a5a1ed63fda29d0fee5964b402b363a7b1be63a2dca41355433789e6ada507fc0080bc0da25d5de608f6268ca59833d3392c45f905d1aed5cc69a00cdf358c86bb0e157c6a9d6318f851efa08b3247600e71ea4365df9788a1bd47301679d77bb1b1b6f2258c6549c6cc8d10e8ecdf67193a2ae70b69b0c1c6683aef2f35f0c5d33e6d179438198ae6e3d25b544d2aca5eadfcd6060af8d370bf7949a48ed9ddc0b4617637d989bfd4dfdb2335e6417b0c81cd042431449f76c6687df97473fa02004b4f0f9874804cce981adc04ec07e4997bd71502224f0e8b040872662397d6d33ee3fa4a9262c5f4a8c656d57ac6d0a1c0750299a562f711035524707d9d847e81ca4d78fa33ce42c32dff47b2f1653c1ab020773864b3baeea469ba9b6627c03f9833ca9a32cdb11fb2287fbcf15dbee25f421eaf9d00f7667a3919c60ab599f9022ea4aad2617649f68436bb135f4df775bccea00b2ba9934d5dea51d835c90e2fbcca7f7ab6873c63d6a20997f8d409c7f77eea592a1f525a5993677720802cfb3de3079b0ce318669167f98c8b06388075c4c69719dde27348db7268764e15478df681aa67b08fc4e0939995aefba1d453b1ed435e63c58fa0c389123fa23301d748a1c89e8a01d71144fb558dae95ac0fdc04558c77b2bb10dedeb1d48bc7513012a3531f9be7f3d37b6533b8384eadb2ee966791ffc0f377b3fa1721531cdddfeb8964fedf33b1cac4fc34bfeaa299327d8b0b37d1e17ffa4727c671d4af1c6a27034c91ee374ce3b5f7643a252920b5c7718e0b9783824bd1299edcd29a1e81893be6d5af0ef5e6705536812a39483a44bf4b504279d9743a910603f15ec0715adbd88bc69c5d236cd16ef6c49a35cc18c408ef9abedfa4e95cff00d318ed485fa0f5ddca4af5345343c849a12429c063c9595637542e85fe5e73e82b942936f0448d259285846ed32535abfbc5248c19e960af92e8294e73651827ea853bdc99bcd9ed051cb19b3c6daa2d7e39b83ca1d4b8a82d4a97b11ba84d63dc8ddd839b51c6d328692748163de4ece178347bfbeaf0f55720103205b212c266abb33e4ba5133ebec1f2d0833a25a1cc8e02c13be6b833a5c0db88f3906e7fa4e32e23a32d9e9b8b641e417f5d43aa0caaa4c796acbff0aece6488b65b462e5fac9eb294b2415abdeec8b324aca550234161bd775d7b6fb9e39268f01cd0ec73d725941a11665fd928e65dcbde86e41735ccae61bcf08b736cc3a72021139be5ff127e91243ed7c5037cffea6f2c617db2afd5c651eb30ba352504cc1ddf7d962a29ba7f52a6b997692a27da116732afe2e7cc03de2272985f6e9d4826dd5e7831f2e216f5a93447d9686e257e43a353652db378468f0dc66d8081043e0f975daa6a94f1577ef2d864fb9280fd18c9a305f972b4b20e2840c860ea912c10ab94e1037821fe055869a86d95fe8defb7afee0ee3244afddf2b9357426ccc3316a095a25032033b7ccb425dc21a724b0f6ff19df25bd2ac7bc925be7d9a05873dbfd7dfcb3c115b13cc89a9d3ed8c69ef6824a94dd42e90440217ed62a40d273f61d11687adefd0a5344a954923dce7d5792a964303658c5b2393a2370e42a911625c2a43cc31fa79700b8ead0e26c6d59a6b59310d536132af2e4c9cfecc37b89845a8711b7996c6735b2a5e2b014b0adfc14ea94417f0202262b31378f0df6714aff94049a07d22224ae7a45a9af2d86fad86c8f498696937d67f9f9145c6182975acdeac08361348c474583a2f648168eed5effd3764b667c790cb479bf3f063fd4c425925362666df07c7407b3e52436423fec508c2920fe05dcd70b87d7ddbd0e5927df07388df0a6bd7c8b62556a3bf70b99d3bc029fd2a85652420c55d363296026c2d6bab5de1047c5c450d859b309ca1cd8a2506b9c3d2d58c5ac62a406f920af9969314d4df1d76609f6f8374cea589508201d9769a2250d3acdad572cb302ccf024990dec206e58abc20a3a1a4c720ac1fe998aab8ada56404db6d6afca13e4d1eece53889e84f4274ea94ac23c9420b7fb342d98788eab9394a4c6bf0992784612bfabb6e69db5a13b618197f7cbc27a90137324265d902ef03e2dfb532bf211d0477cfcb1a4894135efd385ac171a05872869e026cb5ab8b0e35fde015f216ff1e7ac16ab2127630183e037b2ca371775e07ce9ca9b47dba4964b47cbbba39448aed121db6234a87393642370fc5ccf38bb930cff47d6a9eb06c01051b0ed083a689c013362b81e13db1e4b781290a08246c79fab81a3c3eadf1c9478958de11aa59c6ccbe2fd01925c38b6762799fafc4aeb24b82707a621d8d55749b2e7ec407d4e42bcc7b508e1a77870cca7e0cab7a7287e88284f532c3f28723828e82ac7ed78ed9ba3f9541aa9867b19bdb40524c5da65f6d9536cdff7d29c5f86117bb97d9c05097e6c64bef225993b299f8e4cbb7e708082c5572412ba5af9718f5c19749c87f67da93e69b99cba7e750685887bc1d403ff97b8b3ca143ad994df029359ddb5df0f9d4c8a64d08328e8c975c2bdf9ba7d9f21b1cb0350d50876c00c654421a0da2ba1e57267714020ca05d99cb651a796d8e9464f85f793dd000a94c2eea8183a2de8ce3ed00e88032231484fd787e3c03d65505cb148df8069aa18ef527d2c2dbd171490986fc3197f84671ef754834d451556d668bb83560f8cd608549769564c4ed5926ebbc7d4530a9ffba3206ad797fc0c20aa3be756339d0308cf41e3025f3feaec108de2ed29e2debbe90028cb8d22b28c6d79602f6a7d80c6d81563940dca2cb3d4222cb9564c8c5a2b8358b5112ed21d7680e582686c730033fc44ffe129a5956c5688673c504747b5c3854c7d9b3206f8a3dae5a72757165c4de25778b43656ac3460fea185455f32415fc4ab3a4134078c0794c6bf82b45f4e35254e98213cee331bb8d12d95ecca0e22d01c8a9a6c50d2e3606de4d351b89fff33737fd84ae60985aa5f20846779fdf1689f6babd958e7720a7ea497f958f496f18f4b15e09b3f61ba76608260012f1cb3781bb8443acb4b178880701d30e2fddeb37c442e5f43a4ad0aaff212ecd03a5fa42e05be07a7da5953799770a13c52efa2608ea9204a6e9c87b1fe62efbf0bacbe3dbd4a8ec52949df03224cabea10ed7ce69b3107ce1786215c378102292110c719ae7f80ac4af14b53bed2d1202321a883318b0267a8e6ac1219b479ad1eca7ed854ad6487e8f2b0a6718fb6f35b70b007d94e1418e955201baa1e7aefd907245e731041808eb89f39229e094d2bc652cda921c124b43e4a41ee5c03d0f8cf3647a21d32dddd0019b1ba3171b44aae895dbcc45380b7826620cc59726c5888c3379a7d5c50c35b4e0e6544049117c3d97c9700ce71532b8cbd83b63d6de2849b38c6e488043fa9fb2d29028fddc1ec47450ea0dc5f55cfb189056f152d89c64ce73eb90e2d03770f3103246863f2620288de20d7a45f587054ff12575f840b26225f60041cd6f9f33ed224601c244b715e33c2107903ca87cd52f629c7c7f9e497179ae6a08f553ee13ebf248bf94ef1a13eed3728434921b904c9f74d8486e15e77d34027015080d9c735cbbdabf44ce595a2156bcdcc9047526eec7a704bdc377d9fd9d1417cf09612c0cc0202e6e48f10ab9a01f4331ba9222979a6869107f2b3aca6f829dbeb6b57e2eebca812b27c9532d383caa0755c512cbef45e6b8619a2bf0506be8453846e41152db6f5af145a105e14cd94153c5640dc5866ff500e85b5a9c9d45bf1489346df1e82a0af31ebcf975dc58bb1995c922dfbac7773b0bbd2359014a2608812072ad0d877abc90fd30c1ad383b6c63eb54c77ba974d4729afedbe016d6a8bb0dc0866bcb65fc09595c43a01019569c000f126356685a51335f44251ce13ef0fe6d42db4a450f7a5f800d19202ddabb6c7b61721881d67a7b18fe7be416b55e50cb35edb0a2115f1b492749e7a9a1c20404e77c584301048f2e174f85438b4a644ec00d5e1f3e96aeef1bceb4e6084d32271dff5ab6edc0c3693ca288510687f3aa2aa4a5a291c1b33412d38105820aed5dc11b2169dcf6574eaa8eec03ed281598ba8d02cb0e4c88bf7cbc56a50632c222d0406442958744fafd001ccdeea9ffd4714414dc85a6ac2604284a66f8c9d89f21d90f13cc19bdddbcc57a9b0c029d8e7f6d5f02fc0795b9550ed5c7b7de8e75893c9a0c8cca176dc8e040ebf77fa1ddb65c67f8417fa7da8cfe3a784ac4447bcb249c344e34ae69c39f94f443eb823b7ea073fb6a0fd20678ee9a7c8c5f143350c726b9eb40be733db84c83965a1702123ec5a039780cd37009e51bf283a611beda965c6a29173d1994de6748351409da9cb990ad1913f7e785e46946640c21e182120c83b148bec1c58b85ffbdb0ed351a4f329d56feb1ad634a5b4fd8ed2a7d0c1b9ded3547952ef1ab4a0d19934bcc4236ebc9f05cb85ad8abe0c4245e41691a54462967291ad63c252f5f778f5a106de1569e3ef07a35f7a48b88fcad6f860b8a4b835376b60aa48e356f573e6a4993d12d6a322f92ae8882424a0eb1370cd36941f1b21528c39b18762ebd37527aac60502be257748d7bdad15233ec5e422b45c3df065e996fb899f5ed24317b09c351b75bb2db4104bf3bdaf7372a487d0f652c3f814fab5dd6c7d5f6f756b67617447760eb329eca603adaf3ac91cfb473ff8b953c2361dec0fdb83e9b70ebdce98f58f8b2bfbe639b744a67db22dfe46e29bd5d14faa1b5f834939eb046544a924e703418f6c0ef871ffbd5a0ae085865f2e03640f35b56d9068bdd280cb9d7d9497248d16785d09004551a28ae706b497de32853e2a5ec0dda6ab581c5d53c67f1597928e874c1f02f228e1a8a4ea22a8b997b7ee20aed6daf04054a985944d9ebfb36d529c5468b6a7e01709c9317ba94aa0cd08c338cc5e9e6733674aff67c33c960f608d76afc2db113f9b8bf20663be163c4d4797029917d0940a1ecdeaebf962782b5abb68c030e2575a5ba106c17c0a3049d6810fb1436a7123ee0d02d634500891be4daafe46e3c5a9558c84eff25a3ba5ac1b2640514d58f493f597be2625c9fc23126d7f67ce00bce397a4c22ebed76a4a6877e19f11aecf395e7ce43bf2d539252631f5e770200990b4c57f9346a6aaa3f540ea72b14832471c6b0b1418a827fe54beab9b04499a156810a9606a8010b74863d165db4e7efbd2b5e63c19ba805e7ad8c458aff76852c1785a9a7f1707a60f3c682edfe9fa60d4240f1a10bc9b2a77a934d28ece10df36478fb7b26b582e2517a63e20fb6be75e0eb4ffd6a3dbe667eeea05ddef10564f7f38442b5703b90aee399b1548435a544198cb7e706f6709001e4738cf27518108054977a32652be65cfa59ea1f02cd88b7b920cdf8a63f62b8bb8cc9f15846ef0b5519aee06fc86b35985265651d2cac988c6376fb93d426dac741c8613a17cff44577f7aadc742e2d4074903e41056f3d0dcd40a372d346ae33bcf5d53d7b51c18c07cd4410f2e32b552c6282552bd104f75d06499bbe04e04889c778e99a0a0007ddddf02b2234805171e593a339cda417dec3c6b38bdf8f081fa2e6d21a2717242a8e463e0be502acecd9b2d676dd17d1841a59e400b97b757ec8bb65debbee26fc7c43d4b6ead6e7e152811ad09b03424c946d6fc492ef081fa49c449f54c2ee24a767204c3ae333c2e9cb61a3fa47a08633776d863552fbe188ed72410b0bd64c4569ee7ba0cd32901529b605c79af74db06a7084d9c9ae8fe66a2dc2ecf15ca41ee0926810d4f39ba2ab14f93b819f52201f56ddfbf245f970de359fd0bafb0452b70cbaa86df38380c28ecda2708d577583102a1e9fe2a58c7ef802a082205021eee6f552b40307c9855b141b2c567ce63a65f1d642f2ba162cacf1a8d41da39146313b16a2ac969ebbdd3dc052001fb2015c6b2c99c2acbcdcb0d3ecfcdd806b87dbb686ff37e68ec067060ff6c2a95cc9c0641913eb5446fe36b321aecc42ec350f619375bddf538e2ae1de8e120190254afbde64c443e3324c91f9f26add33ba0b68e4350a09867871e63596685377d2cd8a5b087214d445be12bc10ec93cc6b277118dddb43aba6b831b56b31890241ce2772727cc9dfe159e650ece83e71e2dccadf92e6aa0813da86cb8e288c785542a1ec393aa7b0817ca050f79817950f4d3474711fbb7a23905149febe18c2bd2e1f2a942ba21e85a0281505d8f162b85340877eedea031759cece3a53d826681f381c5eeaf0b5b49f0ae530cd95724c30a1a2379492d925fbfdaf93c1ac799a45e2e602095ed40f8e884471337085ed8408c89f988ca5c086b119ae29fde52ebd4b784c7a1b14ec678d22cf84532f3490bc4b1423f532b945fd73435ded7470ebf6857d2730cb724de0db3043aa0b27c12f425b2c4ef81cf297457d9dc561161cc35748ee3793d311b0ebf6427b057ddb86e900c48004cc986dd7a309d917e2d2154fddca80a980705d458664524ebaf2d8d25c6dc5cbcc84c9fadf735d7936f9adfbb75bca34b282daf5a4f070f897b1911607cc30ae4fab946f37cf699fe846d6c1b7e82850d6ddbc5dcd8b6ff1903055915ef2ff3a2b96acb7664393813641f2a8bb32f27e1d10be6efec691f3a7ee7df0125435e8a906190111d4d60bbb134d970a23ac9ce339df156fa4cb930b7f5f4a3fa4ccf52b7b8ae9eb83e2a54b8f8ea9d0cf01003921c4f5ed5170acebd0f48f846d8f16a3252e1d86622963e0ee2ebf7a18fcd89831502951e8b17fc5cf1fd26f401f1fa2ff605845cd817dae9ff1f0185ed1464ee4947871f4c7db29e18f30910fdecb59869f9460e93514a9ef8cdccf18b183502c6e12d5447dfa33164bdb48f4892eb893987d7cc39c7919f06feeed812f5226513efac0e8d1f875312e97f15f4b269cc5baa5756ba5f878f645e4ca744c083abc4cbc6acd1e585bc09a97ba6007bf0c78d4c76f35017a06970127bf0959234305c7fb4d7d8d715acb2421b7babd932d266c52b51e2951b2f2a5ab29cc18cc81b01f9f063e6bd90c1ad2f0be84bbae8bf285828b03fef44a925e646ebc4df64e441f2b25f38ae473136b8c9451703d5d85b034d8305a1c035cc4473201623e9b1cf91c44e8411ca6f66a9b5c7e7d1d6a265c77360e40a5f7a0b273b0f989245b47aa14a0638b83e08c278360b7777967bdeac4c358779c96502753ab097e021691ce5d87b439dfd6ec9c011ff3cac4ecf2c873dabf78b7340828a3024bc5bc1c7b017cef71ccfe9ba9db2bfa5ae8bbce9a848c95e889a03f89d610c627990881578ae1325e2470aced38e4f153985c5a770fbf03daeedaa5f7a3e0476ef21ca2aa24039970b01bc7addae45437a51e6d486292d3a3b484512c9c58e834dd735a9e8158bbda21324507956835601429539af0ce91934631c6754e3952fa49ea393d92facf4e4b205a3acecdca43458ee8b8081a6fd5503781492a1e69261b26de8c35dc2d7932b7c612004f6aa837588644fcc39b6c7a40a921ff1217482f642f72f143b9b93d7698b770998c48d93ffd86f00ddd4ddb4f688b1ba6ed99a99894115f5f096ac529b4ad5565e8870f26158e756a35f36f4e736ae4e2c219de330dd08b6745123ca277d73cf654f229a820ee987905afa1a956ce9333f09fa832a97804b33532cc9367cf196297a211395a5ed09b56fbfabdfea9a31efe7b58e15f13e274ccf7c9a547cb036c9cb6912fb4a772361cb402cbe100fc92478cf3faa696c41f4f4dc30f6d5203b8628fc222721ccd8d4f19d517e974041d3f2f81f7e9cc86f819a57e4bd2dc9aba11913bea9d4a25ef977b85d1f2deccea3596f223640deab4671ad942825b1a0396195ab315e9977978d954d78b3854fcb4d22ba87c453c13cbf987f8cb9572050e012803c1eb5404ad82030326fd2a23ebe5707356781476e667ea6a2853f83a0399a460882e789b38a8c8d3c30db128cc24ced414d7674bb396deee5b6210afa6e331afc63953d913d283dade8cc61beb3d65df58fd00f9e57eb1efecef18ff96f0233cdec5610b1bec08e2b6afd4b53d6b8cb0f89944eb4e173c50523554fc31de59bd0cc2a2e81bcb0001b136c04f434f03fb25da8885c1c97c40842821090717752e2d9894d4ffc5146094309e6f622ad8a2799891749484c58674214b69c518570ee4b280c446d32439cdc18f2d1b584ef4f47fa4a8eaee753080241e31140df3d53dce85b3a10aed7e19895fd29d0a17ebadbf8adec37a35281759204d8b9c28516ac2da81868c20300ad97ecb432b53a84713f1c5f2aaf90c99d2a8ad6ec78b9870804ff03958768ab4bddce33ee12acb4164b78294e1d92a8ba15d2c5ac000dbe0898b14ea3d56530c0824dac3f5aa7ba30eaf252f1084e5223fc15b276789a256523d6074e961aebda89198c2dc5b857a93cfff1ff669699042e898a6e4bcd51188220b9beb6005ad0ae7064ca4be5324e67c04bace55ee49be88ef5a86238037aa8e3c6381e678e363b197c8fc066a447a7a5e3cba3841991b4f3c352d7de313b95e5d51163d94337dc70538261b44a762a043f82cfaf91d12df5f2908fa46a749f8ce9d4855634dcb06a6efa93bf09e5e83207f3ce6bc1fa12326afaa2aa8aabb8da267607d471d7a9d5b2fa5222ea5b6a46df686f6807b328ed308ef0fc25f778dc1fda0e2403d40fde1092e0aad75906ae716db36c31a651a2f96e68c80f654305abc136d220de05c9eaf1c2d597a556e3ff0769e9494e7b746b391d97a4ee2f5a59a6072d8e205d8a58ff7abf3f25f9a0c206fa939cb9d96703720110003e6b399531208cad20a2b88e9cb52be943d777c21fd408313778100173ceb35da9c4f0c5d03b165ece190345ade3506c2154065b30b8d48e07cd0d353a97721b6b074253059feff41982dd88e484c1e2095fb38e3a1f12e85fdace798ab22cb1ba563ff8dfffb2717f417eec04ed771c86a33861f5619a960812cf6b4e14895755ab9a02d664c7a429548096de256a7fe0566f7b4be1b71e1fa01bce55416ed5eb8b9a23af754f72fd27d353ce909493900b6460d39ee557a418c41b7baec6f4689525fd2a0f02175f93a8fe3d26ffa81fc19500d97c26073fbb8e4e2ef0e2057a4b333d08ccff888b26f96a9c74231557e146d95171b7f00546fa5f1fcda154992d60a008e21fb19ad3d50aef60a2ccd65e9858023017754241ec1216499cd92e4af41ef1937ab17cbd6da62b9704f7e0584d0edb9ca8b0e902bcc9ca29772957e9271cfe52aaa9352b3ec038ac3de2ecbed03eea150d919fea46d727d28e5224e461128f61b172c8f47d29f84e03140762d2f1ee847cd0aef6340934315390b020f83493f13540ffb556a706b6f38a847fe481b77ad3d454340acdb2751910d65d06b1e2380aa8e002aab96c310968f1c37435590074a9023e99fb1dea53c21a3c8035200b04b55a082e58cbdb08b3236f3a6797bea23f0099e01662bce4eac3a5caf1b6cccda07f37ec0fd4818976133c986229f6b81c036554155a53072b5a5a009c2fb4b5c72d75d7ce1c1950d25ec339db31666cece1993b546523e390d92a4bca2e8b3ce952d686552a45e1172fcf924c2d172ea100e03220c333eecb3ecb0338b2490d6e898374ffcb220679ade394851876f86f71f8f66460cca824d1bb0c9cd507826b0088d380011d23562a2788baff3cf9b6b8366ca7fd0d24d592c3107475d1ac28fe67edce4672b9e797c8672014ed476971887f2269d7ef50ac1c0c2ad54c96f44d6c1fa49a03515876f30127f98ca69caa42c60517e8936938a7819e99801d4789b4ab25c92cc15768205cd97a14b706f60035612092492d20411df055143fdf683538def9326600e1961681e72f628fab1eed63e7b58a88eaa556ed0ecda669fef0110109173f87b6c0fdda48c38c376b85dec2057a59f052701d490012eb16e283899e39888da5b378879a049fc67fe9a5937d153a6c188c06213f92c211793b06873957e606e1c74ac2d0970881a2d5785e6089519a53554bbc3d1745f987a34d003bfb291d37055914e49fdaffe1ed6b23ff959aa800a0556dfa8fbba146812d7df5ac5c1cfebab2c62ba35087f74acfd66827375c18178736b286ffe872d3bbc32fbd4f5a40f64f74c43ef358d89b974bebe16335f94d44a520bdedda12b32266be61491efce83ff99e024c5e90f0935dd8af4db65b7e1769b4b796acd48ef10a8baf7ab00f4b8d3d2ca1c282a737103533a6871ad34f2bf9f2a1725f28abbc9a99612aeddc00f2386fcd38ba6fdca707d025d3ea08bd74247fccfc8a87907876a2bc5f01f6df181dc03033efee890d6974af07d9b4927a393e860e5610972687610c14d732535646c3a49a2c9638e021d5710e4107a78f9b5ff9d1b143d9742a92ca69080aeb8e5e8c40101e49fe554c247ac02eab95351c761853170b07e46503f98d11b9ccae56db72284b772586fd63c220077a08fa21c99c71b392c47cd534ea9e6c479d2a6a5b579ba02403a0813d5ad279fd6e621be37124b38c6417b275ee7d6546686f31f87d6ce1ce6086897962262db22684c7d1cc08edcda31b651167e2b3595bb987afe14a85c816567535af7073a32af79c23889cc2389e7a3f8ed033cde0de2e02eadb4ba806fdd8006390849df165c7ed20e4bbc422fc2a457dab59bc36ce3261bda259f9b7b56bf8c8381ac6b53e40f70f44f3c075c8a9a22ab01263e5efcd8a10c46de6a90514f0674e58f6c46161ddb9d5a82e406eda8377380522147d24e4c7da858a1456fd57364031a488aef9029f5275c4bc091a0dfffd8b8f5f8ebe9eac9c6f3dbe0aa619732e14a6b093c011aaf280006d17a99d5437d44bbefa4799ee96bc1a3974035f5606db159973bd43561b5dd1b3891fabcc1654fa84185ca0d2f252f17bcc3f98deb7bd6a2afe76416b59448cb0bfff9db02c9bf61f7ac45e42a9559785efe615aed6893f3509cf7cbfc56bf003b288d25790a7fe3c31b71e40e7adda26fd59c37c4e3b799ca3ddb4899b48f987cc9a0e8207202e6d2f079d90f1f8903afc92845593b59b0095525a5192760480db5b77db7b5cc0748af430c3026e946c9d8b71fbad486c417741992151b3e1e0dc4c57257e53183fc9d1e017cdd19c34e1a47206fba0a3eba32040290a59421e14ae593b92409aebda706f1abbcf5af3ddd5c71269619db926cf7ac50b7a85c12551260527dd78a1156e0c2ad8178ee0f6bd2f4b23fd2f0ed3cd2a3d940f815ef1ccebeb040f700c3a0d5c6c5101effc258b119db2a6763dc154f26768d0a8467bb253ad60e11e1489d84ab28d3feeb9eba087842906ace9bbf2b86fd848ccf3c2d5a389a8e72cb64f26d575ac126f3ec01ee28a95b650f83508f8b92295a48533e4eb5f4980e8d8e37872c5bb969e462e6473ab7424d63586d5b9b16cdd8979c925f4e6418111e3f02bd4d8700898e6588b5cd0dead85cc90224ef0232eaa377725e1c1b7343278d7e246d5215442e9c5c3a732bbcb056e57e3930a77495acaefd04c7ee80925bb5aec2d8b6f12f814ed2c5e45822fe91de607887809601d1c5fe822eae5450c8771186a508e058601567a8a7939e051a34c76ab43d02a9129ee15a0667e38a24e752fa644c221d88374bb885f3640238b87e871b9955d8bd11eb8ad120675cefcf356218d7d8077f4643c90a6d3f8dc54379228cce5b194849167d87a42363adc44949e4a7d9193502675487377f1e5a435377eb1d9135481e70d2ddf56573383d73e5e2d8c42f5f1f84a2b7c47836747cce92c1fca96f69679f3f0d7e7b3a231eb6aa55985c9869554534e2fefb921cf38b5fbf0e786289b704e6574fd4d3e48391dbacd2f275138b695c5bdffdb5738e9d355c751c1cccb678b521a90d66adc0817fb096a96c833d58db9e95dcce6a89da0e49d964e0a60614055e845a4386fd8b7109750203e95bbbfc241f8b2f18b619364be39cbe0036a8a59eb991b7b95d55b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
