<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51302c50bc7b8c7f6bd7b3ab4758470e6174242ca5e4a745e198586e6d1f6fc488e5ffdad3ce8c102a9c6117510b3ef46b5e1c4d0c0a02ae274e8c6e16b22ec861dae6001c90eec2a215925c56a04b85b6cbd13352bfd95356d725f70cfc7faa46f557d317bc2be117e5220128ba4c2208af1acf800e62a6483dddec4b2a32816f7c2e415f53bfd96d63dec2376dbc5ce01c4681b0ede58f5cfef72683609f04ee3359b058f6e6df717465424d795203df9b4d7c52e2a4aba7924763ddcfbd70fbec1f537ced4c45f2614ce018d494290d77e18de64267bdb8586657c22b853fe331ee7751f441136902f8f96af857ccc48be837c7a467c8a27fda86bee07c9f014f5ee9e0620605e8b8859ecdbb9b6be8fa42fcff1930723903179d171d22379d3fd5a84e766fefcd2fa06227de014b248adeca5aafe937f340de89b3230364d7f7ae7a15a961b0951b814c7aec30727106f801b6138ccbe9bae92908135ce3f4f7a6e92a1247151a58f857e53ef74c2e61e5e43121f25240da1a99c3dc4f05f91901d1478b0e5e1075d2850102d61a0169f834ed52b519eafd519d081c943dd3187d53da12da13139b0531f844032b49de1d202e01b91720dd4ce05369dfba28d92b6b1abead4f354bcc90769cffb33017d8564898955a291407b4dca7d50d14d755a9267fc537083ad2d6744c413f7d5b02bf67390780a8ccedd2f2531c522ca01cf986eadc5cfd10574f64c28a30f107c299f08baaffc2c89925ec2d4f0e1d3db410b7aa620808875174a26976e1fc4bcda903f9de7a821f065899bd2a2cad644b9003db900d4874f247c4eb507f16f60efe961d4c783f4a1b0cbbeb810d0e2913049175f64995c9fe27dc85d40179742f0a56f533c0c997d50546706db81783be9e01399f6869c1cf8a88e5321f72379074277d6df0972a4217dc8ed37e2374b46ff711d7c6c3980f08e88f6d30cfb3e47020abc6c28e53e3faf900ed51e0d2c5d31d983e38cc237682ae40df0ebf4ae9f82324965a385a2b6cdf13b485b3a74f0310c1b459f91ffd1fcd541c2a6f3a9a113f682371cbee1446814d0ffb7f0394283498c86a384afb6b0aa11e7f607dfc3873ee3a4298df18803fef412dacf10ea1411cd46eb7e17e65c2cd69054216f8687b134dc09594fb068089be5959cf31813fd992fea565fba328c3d3883254a105bd5210e2903f4f168352d005e6d4696d859653c04b5fb0bdfafc715ad580602871135ad8da0ce26e4ee2875a4c94f3d29f07ef6a510fd73c8b7955bb2bba028add99175f31e28bee4f6cccf19dd33ff77078cf0872f4ea9f582529d077bb77c9d5a03e6e25805a0a8be39a600b9fb96972520d1276f0cafe319fe974ecfce01fa13f113a7487de7185ea2ed48daf670727ab7be5d76d85fe5127aac7943302becaf436102e1c30932fa3294c71cba3eae8aa83f062dc51f3642b7848948e5388ab5b13f80e317448df1c4c5c2b80dda0e928d74b16ac8eddc6ffeb214f8698f29a85ed9115cad3571856058392c747ebfe1c0e424b66eb903e9abedeff43cf95807371d48ed7bff9000a0bd55c51dbb2d72f67bd3ff2801d5e32cd47c49da203c3a9cd922e6d240c8e4ef6ba26f506f1446b74acf3e1d357e2aca05e0be2e1136eb16eee7685a42f2a84b574c93580f652e19f190bebfbc0e27ea618742a15f356c9c4d1599caa2ffa0f45da65e4ebaa652d515f906d3585fd49be3a4b7a30dcb50f701a40039d38ac237ecbb6ae7a09c446c5df1dd77fa14f636a1877f5e5e4ceb986e09ade67627a75132513215727823e92a28a18c0b9fbf58679cfc854f5efd9532814980f50ece4ec85c8de3cfad4167a98892f4d4573079776d44239fa4b1b8e6288e0af5d222e6db98cd6bc9172d0554c1d41fc6199cb98d92230bb0487353722524c43b4155e70329e74f771a353fca9d92eb8c1188060c25f08099eae9ce27fb473c0d475bcbb3353407ccb8869287bf4c165277fd34c13bafcaffa4d1aaf0c29cc313910ba2f59a9b9c9cc142a5b5f6ad20615f1b30e91b9f4b51d3a3e0ab94fa0135e08e4610215ee544948e6b4a9d4c2ea4d3af553ca89fc3f57e758798b0530b24656ccbf275929e20cdbd7a32a427243bd8fe7cd24415b809d5a3002af58b01f74f82c4b30baa70eff40b8306ad3793d5043524ef22db267f75346293e548fc7679288d14f911ce332245e2dadbb6835ff5b539d405b228d82daa75c2f3572d0380f0ec83c57964ecbe4e6afd37b106717cfdea240eb1a07551701af9dfaa26f1ab644b2a54a0c235d8293790da02879748b7f3bb2650229f785fe6abd2c11ca372b5ef02c73467a52c15fa22c5e3665740ef85b3128530b751b70d970e879bb8866873e5e8eb1b46bae6d9eb79f8dc9e6bc7be8fe7c8e6d6347b48e5cf4f81ee4c1f60ff05cb566babcd69832f0e68082113ffb35a0fc54f033776b0196e7e5aa21b58a1a4edf0be06e982254d34f005606d1833237898c5d77149e7e47f1da4044c385dd36fe72bc827dcd1e2eaba6d12760a7ff33462f5684ba2c83eb28193805504e0a7821419b147c95dc8ee7cf43273063fd86eccf3e57aab50fda450720f0dd1f52903387319189f2cac2606c43d0c4a1123f88d15d5cf9c55525a079f4f0a82b53333e206dcb4b2291f4f226518e8de74b3cc9fa32c5f985292dbbdfa6a17581a26287dac378c8b84cb7079600b3ccbffa22a1b59889001cc5298f8c84f92b4145a88881b8f935e7fa7473f17ba5415c1ce7a9b7667468eb20e24ba89fad45411b671141d352dadc2c51ba5adf5d3b91fd226965295a956bcedd3ce46a0a8380a2d158437f59d130ea89c8d31f4996565dd102d541295616c7762677edaeeb33d4d4b02af8fc4b571149fbfa67bba486fdf77d6db3096f66c3cd57cce49e1321f5a54633ecae2c404e3300476c5457926a62eb6e8d434e3fa2346ade63006feebcd5351f691554fd60cdd721ce0ada406c01f94a1fe37b4b146f5c6b964b1f934e3dcba6de4750ffb0840ddac8ad508afd0eed735202fc938bb67a4083732d57ae9938cb8e5129ab2add0321943fb1953fa278e1fa2bff5123c007a056319933ce519345fae2b5d0ca9df6b737db161ae953b5824010f9a67f7d3fe230d859da914e2da42419e1c53ee43b6282d376a971d6be8bc4845ee6c23def8113677cee6190daffaa67616c3731c40a1d7facea94303adba90f932efa06b7f73f0b602d144b19719d4d51ef2599d1362e2c15158604e642c5601e0174076f8120fdad4a7b8d1af5380b098a467d5667f07c3ea272f4449de18561128fba1ea61dab54a661bb4d311908482dff4f0101476cedd66aaeceff50c3a626799f22caf4a5fe9e22f165d1a4b1e5799d5140a3bf504ba5141bca7944900fea82c8c9d3b26971efabc6ee93bd0e9f573797c7131fc7a8adc431a0437c83bd08dc217fb13d04ae15fccd40410f6b121ad1735874ba91e017754ffd3f7f3e3db0e931f27a2d76c0e25c5d8d0ea4abdc01784b49da2826a9a72c47b1b285414341c1e9fb01e38cbe2c7ec516bc8807dc8c4b7ff3c4a2aec693d3ad047592f73477a1fdaa11c8523cf2a40b85e8ae8c8478b4e75a4386c77df2464d1b3cd8f7c7f3d1346bf83db1926df7e979cae71b56af305705866340320817f3a595ffa05c9a37c412e62d691415ca064e7678311a22010ace730638dbdc5848d3fa38aca590c48d41ebff3a2a2301621fc112627560274e2f2d1f300ca0eaf516a294d5fd2008c02d65db4846c6f4392757cff293d12e1b95e9b0ee75e32adb8591b869cd280ea6c7a022909f3c335f50771c2617e4f7ede603aa9a491d5efcee53f24ae3203792b413807755f2b8bc09ad4e90479e52b1b09f6259ad1b8e94f39d0c21bc7daf23b769a858562a417e4c63c6c564dc6a41e08d6d3eb69e89f02b8833d583ba4cd75639fa42c59bae9f3d17fd6e4d363f900099437ac9077d0e9876efb5718e7a0885f164b4ce08a9cc3f6f73f392690c48d33bf374b36f61e6ce2abb437eaf36d6338e44f96fe9344a828c5ff36d9a3074f83c75e92fcfb79069b07a29221700cab8651eeece669e229691b9bcf88e6ee920d9e4697d243bc62d0b03af86890aea2f20da43ad33164f3977d1261e629e567a63b633dbfb6d7c9fbc9334d7b53f4221f799825caf7d592485efdb8d4373451c27338b46a2e79d1c9718fec17780bdec6f95c9e985980d9b95d5f3bd813d6fd2155dfae87e3a03f97eb9e1d2ed5f8136288fa9965340ada035faba921b014402066cbf5235c3daef03249a4abc26becd2e90955461c034bce37a37cc832d88eed09600e8b145177e1fd13e784afd48d3fc2bdceb8e74944865930e70e25ff9aaec4867b38d6603aa1a6e30f2911ae90728f63ed7c4d06eb2590f5dc95a84dd27df566a8e6eeb1863bf26ac3794fb63c3abcb774f82d7642d81eec8f4a4fa5d7e07ea3161fca6063d065490266c5ca5995a73dfb74119edef17987227b0a6f95340520cac4e29fec6d8fe241e329c69d84046cad450a542b0e31171255d628585f0c96d7978faa931aad63aed42d2c57dbb62802fd77df0efcd7769cffdda650d1d2019668fb64546ade313afb216fb559628ef10ca3f34c0cebf246df5d59b30d1ea23da30486b6ade1c5a6f0fb070801875902cfc2e28b5b998dea3138be94c3ddd4760d489504fb193e5e070f496c9cd5124ee978f8528ed12b000d74cd9c3387d5eccf96e8b1e762a6b6b4a61af2f3b9035d17be51fa4b8f082572c1faa9d7272191999a66f2cffbfa56485d91ea31c7d5827faccae72913ea722e89c502cecd0612af1cd55bc002e521ad2efd4379b89d0fc46bc21204a2fc1a2dfa1e86d0f50f6674a737d0d920e8e8d862668a88af333697b7184fd77e02000b181df3236f0e164127c9177347ac4b9c54991d21fb34cc96b00ebdf9efa2c08723c649944b87c370ca7a318f26b83ee3f796a9db0ee23d5e9d7a72462790afbc536b42bade90f8c42b69aaa27d3d97c971a6a835f63add995ec7bc6ae5d499e6ff2bbbab788ac2b9bac2a8fc797e23d5bd6d17ca7db844054bf683a1298ad9464d2a541c58c3acc7c8d75d8d4067d79a949016ce299e906548bae1d5d6ed8f84da23d6a04b6b9f49fa8a3663611ebd17aeb358c2d713db437f3f6d9980c34e89211cefe719841aae9e3586e73c323c2571377c2e988bdc1b802e9ee0dbb58b6dcb1f508a566985fd5e2a532e72eac7099c341639d6a4294fc7ef1164f4e0e7c6e77acc3b6682bdb3bfd464c1b86885eac878e81095f46e195f49c47261663861074c4e9e773943f540fe38d9008ce9265c5eb9a804e90e521d1d192e7b55557f9d9fd3eaa1ca4ad480406e0548e80d8316103786d3a41000dde4a75faf962de20fd78bc6095f5378ce449bc6aa9d883d62ad3f3e9bbe9b38571d11fdaa980b71a74fe04255ecd1b4b5289192121a43aa55f34ea111831637278588eaa83fa144c0808ba3dc0e4c628c79f4b742542add726c0ac83e9a2843f511e59fbf3291bf9791b9afe64b3e8d8a0669437f62f88b3fa887d99651e9489cf1349126f742facedd09afcb56d6ad6e99fa1304249d73e22a3b8a9f653ad9b50b866541938807c10171d1ba9788c5e18a0566c29d6c0026225f4a997c5ec46d7a6f588c9307a8a361f2c518f69dd504ee36f22b93d3eca1ff7de8894aa01f335ac6ad75df71cacfbdbdf57ea2591c70479e1a7b44b7ddac3256ce8d362bbe793b2cb0f75d9086c0aa67a05be28be504d61215e4fa3e1d7c3f6eae955858b4a0c698849a932b33352ea9112c820157cd769b36731e6083ecf45ff627d5e2687b3e6f182597e212e929e9e5aa3776291719ee68e4cb9f14289083c6f5250dc3b41008ad61bde5fe7434ddb0861bfeb110b81c0036c0bb6f24b28d1ead45a9bbd1d5da570f584e9ff9dbb1ce36bb7df35888cacbc3ec6660b9fb403dfbda107211b2488508749a4d95936f95dfdeb1eaf3500ff62981d08e1bff9e99e17f057d0fbe999cd6f9abb677347dec0a56bf29e2e1fbaef63863beac88c2e54a58265bb71d63974db6d20fd4604e92e73d77aacb9dde5654cf5603cd648bbe3a2a4fca6ff5c79e4bf8d9e0c5d8cd96d5a6fd92cc989a36ffe4e5262d03d59b8d842b4af279d392c4d265a0f8ffcd20799f85df2c566c229863fa97f1905255e583b0a10b2c491c3c19d13b64ff91e4401e3612d5b80937dab7548e6ecdf9e9303cc8930c4536c5985ce5b7cbd7c26bec3d84c647f4ff10822c91ec71cf32bda1d1e163d0305186b125d8c051286ec4e9cb408b9c7f1352731e3ef37127fb0cb6c14e982357a2101f5e2ad568ab3daa9a9ab846b2458a555dedace327dcd866c46946dda8b11cfc84b0e22aa7b66ce6e3df718416fab3b0871a0aecdd84a99ee0b7ade4d3df0dbf2b3cc216a13baf153dc9de5e555dfd36065d694faa998f08fc054e162d61decdefd13aea9cf93b885875a6e3a44283929f5aea894b8d22ff54f710b3e141e657429955922ce04751e66f04e8160e2ad94781118aa5dea9a6099362205b8ca3e44ef307e34e5b541d1b782a9c03e818b4b3930d33661d4a472dc9c05215da31bcebe3bdb0637926e6fb4c55736168b42fcad0fe5102f982a7efb7de0cb31514824048229ab0d68365abc0bf2803af6d83ba140b205d7e6725fe89800b0b68ae53adfc2239dd30b2406a700d95fb55617e8d9d1853126bcb028e5ccf858fc218725d25539461d595691bc26d8857708129f35aefeb9e340fdeac97ee68a2f7c04ecee216fb72cc71ab7fb2d39b33180f7f6894704d14d6f8cab4e19673b02a2663e45111420e1fd5036905b2249e6d516488a5cb35ae1e92128941a6bde2d7985edf0178226704b8ef1586508a1cc998047495f16aae3111e6f641df81b75d7e15d5b36aab2f1b731593db77a0f5d4b65905ebfe54414782818c9d0610784548a2341af6fa5f3b9491a946374ac17463ee61e75b99dbf4f8a4d97b08cdddd97c40e4cdde8d4553be54e8c9a7050f39850ac5724e2f9ce5de0bf7a43e15bafdcee695f65b0f0ac125f46183f8299a563846425248dec17f4935841cc6c7fe2de216de9c9fb7f856b8725b2321099675a9b0cca6b187042dea23318ce03c7266124c19e50ddedc31ec380200094320284459e7c20eb39aafa7113713333823aad24a29ac1a6619b2f00763bcdb4b3ab079b386fcf65bcf1843b96a649b5b72e8332c2e85f6a4047da30f3074d1d394991309633396ef2f28b0dc5eac3af794b3138767e06cfb24ef91578a4b15dea9eaa09db3944c4b34908c664bac0026913573890ff0cf1b5360af41f2882d5cee4a3bf130603317533914c8be162685f21e09a4f022d2e8cf084dc35e3440148bc2e2f94d500695062e480194cc3e1c01b000aae2c9e284d9dda51eb81dc56c9907be403592956f32f0eba35852c414b2ac03912cf53fa3a3aaae9e2afc3406a4b48d7522d358dde37aa37712fe1f72357f86200f80e0699796641a3e98d05f7908b6e6d01b5f31528b5c041f2e6e0c8df00c16790b2eb784b1c908364c15f22f49a5ce744d0601c87d819574cb58b967dbdee50eacbdcee830de649ce9ec5dfeb885035ae6f0479195fee73c75303090c9a3105e4164544285638ff9696ba42f320697ee81527a843f96ada318096fd47525b7db49df7d366e71c51fa3b3b7710074596668e188edf1b026106426e41192aa1d545c5ed402af5abe3dc3b58954ca6eb54e4a3f757f34898bdac0a13c21a31be6142a9aa1f2ad774ff9b8be338e89bbe203b4d788a89001d219226c93643ac53acbb1c738e0734c772a25821a1f2cc43e3c78b78ccf232574b6817a0b422af4394654cd95bd78a907b8c1ab38f1d279b3b9e009f6eb111562ef2b11594526412fdc5d7e5687cd9f64b4144a6fb55d62caa16de0c3ef4ba55ce8568fc95c7c45b9451579714e9502fd7347d2d8924c54d9b89609bde0342cc7835f947d435fe37b3238a5b93849091f961e7a64edc41c94dbcfacd01753075f4ca88bebedf32ab3d2561a22c29e02f12110fede24be955fea889df717bfeabf480bce435c8ade54ad48f3ff2e974c3b70a3e3b2f707b2ecaa4a89561cbe4dc59754dd3c77f005b8707b9939dbb1f0cc7eecaf242a41fa8afea1dea0bc2789cdbbb2f38c59e0ce792f1f795d3c5379be8db614c671918f59c78666e8c2500dc3189faf9a932db56673ec3c6983e4f729a625fd3596cffdfeecf7dc6108e03dad2040cef3349a0350bf3437fcde39844540de7decb33d7b9a638963d91b30286d4490b4f8adab506fbd2f81cd37a70a9fa2346e97d6e8205874a710ef73421d5e92b9b2b776077947944acd4404f9da719d1150ec4790650075f5bcdb1ba360b9dbab14cbd909d21389580da19d48ff43a150c7c649a4c48a5bbe846a0c79f626d305748fe397952155cdc9f1b129539e49b184e5c22f8f5a369b765711085ab2df6b5ceaefe5a485ef79ef6e4f33a61a0e265b8eb70a8cb546d8c4bd165a40fd6f709d6dd7074daa5b084099cecabf4f82193194bc0949024180d3a378ec7bc91d73e46109078a386a39315f8662cdd9d565ba2fc91bf6af0c66a5fe95512b96bdd81fcf5b0d153c77d0c9052098cc4773f7a32ad079df5c77b6a33b6dad4873e33e76a1a1a9456467c534ddeffee0d112166a7e60ea479a8cde0fe3e4bbfbca616605938d7bfdfb82e4e12968a95f50d680b669f712a65451d71a4c53527d051e63065dabe5f9048f98d3fa829765599b0c5023187036f7aa3377e49408f5dea6a45a8239370c3b97277aadd92eccd207b0ce9d3e7523b3d3ee7d07c4d1a9f6842c6d6319bc46f5fd4586333e98485732cc697fae784ff2fd96399c2ac4bbf25d1045a84ca1b91313c576b4b10d2e2734bb2de5a1d4507ecc5b422811cd06ee804eece4fb58da99c10e49039a5f0e6fc191909ec0466e1cc3e3bba5b437984825e30eb3584fac29c969d4deed29b179b082423cabcb02950d6717423d08276f4e57fac5683fae5528e71eafcd4e7287f202bff4b7a9aa76bdf42aadc66b046e84461ed2b184327af636f36a7a464b4ec4c5185b72c3902483674aaf88954dce14f6b51bcb0f94249d8b0b99607046e711c3f9c5e52586d83b40d94ceb7c8e43ae1c9c7ebc55d7f450875ba0b61818f804f54934fb724e79a3c42bad6f7ff8021813458b6ff5555fd901c1a92686dc3957809b7a93bdf077d24be7ec786e7b0ee9c2fda6e83b124fb7a18637e8f5b4f35a891c7e602899a8eb929c57741a73037b601abbee700b5ea37a83e1c3f2445e256e6eb56cf900cf00a6bc0c735c777424b8c45c991264d7b356f4fc79a7b008fecba45f6c6c14a1217b67cc3ee4f86ee4771e6917e1043c21908df33928ab0c52032eb83096458f4dd738a5a9d624c1834b671bb73fc60ccc4ee05281ab750cd851a3d2e62343c4bd9ca8168f3e67c66b8f9fcf4cca2425ace7f9b7559859e9e2d0a3308651454bfbd08a382f18b9b8fd1d08e03b8cab59ba6891f61a701be97680e3f6c0697a3d780007c6a4a1d0ab9f4808ac7dc2adf6043d4375bd3cc927077b1b27a8377733486f8393eb0f95f7c52f5bffaa50c45bdea0986ac6f80f2ca144361a47f3157e10996c4be934791294cf876a9f157fc29458fcb47cab5c70a6afd1ed9549319c33aee31d717b5bd6de96a94a7377689991d52f822557ef446cb93c4fea1ef41e3927b7153fdcb3c7b5cd3b99b1c2b7054f35022101799e04f0eb9dc61395c0e477318997fc4cf1a063faad9133c4c169fa71434a270ec9ee19f86f16369e2cf2fff561610a5391131d177d1a13aae76671c22ac82775e81f6c91d5bb7931eaafe746e0217e43008222f801d2b00a2b7af03788c062b3b065103e303dfeb0085a217c4222f15f49fa974bcb01ac6fde4864071514b63730ab88444d7578156c099b20d715b7353e95edf627293c5a9e46bcbf65678e7750fa5faf1c0b1d961d2fe116d5598aa770b38bc46076e858d9280e92018fcb1eade4c503ec3aaabcd3c12ddf68df6c5d27e6834ede2b0f9fbcc09f71c7c24ead7f576362e2e1f424fa75b965c59f3212604d50e8700f50df85570e3eb23dd9b598ee6ba6e1168677a729886b92f79ebe37007b5f41a2e003e2f560c7d126ccd10df82732e57ab951c7383c19eda3dddec5474e44adf9b964007a1c6e27d319b1d83ba739c66ee276570e7564657e4b82eb961ca9cccd6afd155c08a95304f85971509a9296d04cf1456f2544cad01b6b38fdb874ebb32c57df5f6ad0bc31b390d979020718659220c1dfa4eed5450e8626a503f46167e4494c345be04a61b6a128fe67fc51d8c2f5404fb6ce710045f232a6961bcdecd159ee786a22da547f5dad516f21cbc19e0695d9c61ad7a68be7d8f217e1c970c8360e9cfa51424e63fe32d6d7d8e6274537f8bb95ea36dc0f80e674805f37431b759a9b2dc97fabe9ecaa4a0fc591a5c01c98f9b76d53aee232bf4c927e717d1a4a37d5f3a7726ae3867249817fc3108cb3552bed07987bc6a11553e1af5dd27504481bac65d838aff60a0bcc3623c4712956e2cf01140173a9db756c6478d639934973100a16c529a650a256f40e926ab531547f1ce32a2bbacd705095bbfcb360179f63a9af6b10bda82924f302594f852b7f8e2d0e80c838e73d264a07667e7f65d5be2cc0923d088d6f621ec56adc70945dfd96f92f6a975fbecbe699f85a0eccdf116d62292288fd8c94beae79c364b36c80b5c513a4da201359bb923547bef3c6f46646fdba31c587070d26e6a1e6877352717dca1eefe3ff6b97bfcefae47256f953476a356547cb7b88ced32e954ada3d0d70595e379155b2b90e2be1a3b1a5deae76e97256c18cc70ae21761587495cf2027ab41b050fad47bfffbc4c1ae4495433cfb682ba16b910e6bcc7a1a5227309675e22624ddf007ea9e085fbed0a7c4eab4f9bf0324e24997d1f60087cf8765db55be02d6ec882105eb948d7df0ab01d8bfd61ffbcb4d9ac2ba3b8a6d61ab1f465b3e176ad7a8fd7594ea4279a3576df02aa2ec9dd26d09e1a4ab62cc682e9df80669533a609ac361deff2c49c4b868041e79f85a50a7f3b6101bdaa4ba2a4f4b55ee7f3ff36a060055fae80e54e3f9c16d3fc05f2609234882ceb7b166f3c84d1ec79c069c541fca222895d84e58eca603c8eff32e4428c7790142b0a4dcdea8c55b6b55e7c6dc6cdc36a8fd2230632f9e59cf82cf348518bb1e54ab25114e66d037ebda04e70c4cabb90776128b8d82f7367181a51f35d334b43a86a0ec5757663aadef225bdca32f7c6a40181996e47b33f37bc39576fef23bbf870bce7508dcb723f7269f88ad366fd3f9971fc3d2c59cd5d0b9511c88b1ad2ffe9ad371ac1e0eefc526dcfbd96b0fc909846ed51a546e8ad70fec6e1cc3762eced7836360ed3f7fad959c791ed8a3e824dd1de46285e8bd0d0e0c9a3439c61d2cd63da5431d84374cc2d4cee3fbf0028b574dc103e1ab4eb57e032fc75178581737d9c9dd417cd2be430c88dd0076458dd5dc03f2336866d40955b4a51ae0e41d6605e38eb7cd74b1a794b2d837206bdf615a3ef6a1a919b04b8869f73699f10973b953a4d6892aece44011064adaf8bbc64227859191bb18022a3f0c0105152f4094c6461cff2d1b876ce431cb7eac6e9ec92e2577d344bf20ae4824fa2ffb0a0ebea4228a0b38779466636adf4af77c365f6e6dcf635c6c24e6879739b67338ddf4b0b6aecf0d740f6eb1cd94af16c19c57c6c92297aeb38bb16d2030c4d07344ea12057a8ea76e00e6b65238b25e7fe26a5761a40d1e344f05460e5361d50f8d4ed2cd3ab1290e5539b356b775b1c34d32e28465f2370a22d1de70c405dde6ced8242570ee0b426071072b8538ebe9ff58bf2f885900d83c3881280305d3532079ad7e7629be79f2e97bdd05286b4007fa2751eb730b21a66037bb1d74c579d68b730b3284529b3114d9b96229224229b625f93eb535c65d97523636f2f02ad19c29a4481e84dc5e9d5636058a7c7b62a3b66cc5fe406599a4c8194391685ea1971b73f8a85671cc8b6eaf3959525958e7d01cfb57cd7afc7c4432501c4a5fac7e4d6566b21fb3bd1619645ed666732ce88a2ae67e492b297c22d76155b6b110fddc08b0682ee6ce348e012814581f383d18bb7228c8da6c848a77ac712ab456544906fca58a24ebcbfa1279e2b9e3fe79b2bbae412b80fb4ad19b79f3ce2ca7a749ad163a4ee8b8cfc60275c4ced32ad7d3aeeaea00e824e6c004cfd530a641ebc97fe91806baf918acb61d95f12aa93e12a469ec8fa7ca938544719a0fc9e2375ecf3c5bab0906710c6acf8a8981b661c64c0509ec05061601115be5c9fc3a45013416db9c2490e039acdbd4d9def6554f1564b0b5a41cd9738e685852749152f2adfe92edaee8d17c9a4ead696c8a6f9f3d8267b4e7dfe74b1cb6ace4850fe5c211dd6357c3f6926f21b12a61a629ae105c7044f9d9ca0d1767466b66d0626a60f7004e5d6b1e5f0cf093b0144a7738d8bfe8d14d730dbbecf36f1efe960a8c208dcf462e2a451bfdf8cc05b558a7f0b1a69b471ec27977a59e9258a0cad6889dcf25e58949b21ef590bcb3c6505e3e968cc662d4cd519bb95dcdbd0f50d40a4a6276fe4de988f212ba5d1f3233b06afcdb9a28cc3786459678251b2f7f2ab119a2624b814a59ad575ec2f6c549c2a82fa18a6d41b9e16bacfa75e7acff5863a5a6ac20e9e55a803c32a0355b8abc7e2e6f39e531da9300ad580f270828057417a6accccf5a0fa42f3c725d26ca9693f045143b49f50ff909728dbac32da127a43669972901cb12b29cf9b268a348f2a07ce4b6f15be17a7abc5b0a6c7922bd9e76cab373b15c7b17323d9a54785311e8e5e3d0f218fa939bb6b32f22cfb16acf98da47fbca39d403ca3c1cfc4320bd49f734000f1f6a5231711b48adebe7bbf9b2d4bf1bce9224d637d617e84e3dd92c24bf631a864b30703cb4bae97b4416f5dba95aa1ae8064091023a01f399591b06a573edc421c42a20b27a92844ddfc684dfb313745b1bcdf79a3cae5f84110cb11040e66aa70b2afcd9a35dd0ea65182b67944a2db0591a3e225118ab71e3d6c411c00de5de3d2b5b8fe7ff530b715b2aa7fb1703ab5f2e69fdbac01976e13b1d64f19f89c4e81a86e1b3a86ba16806639c38c69232d42daf68f5241e53cefb228d5fcff860c729c9762d5ef06847ee61585a2e29b6a4c0d980a38d60c09c9591f5b8c8d01bba141c0fc3bbbe0936cbb982fd2e5b92efc102aa8816cc37e58bc24615c586a3217fb6c8b235aa0c4edaa7a32405270332c2e94d98e045fb89c3b0ccd7bb6e77c6317bc9f06e9a8bfebb13892cb8722bdb589afe4867038834ebfc74015ae8c1da3b982f3be4b600b088153a4fb2a8ac8401c53f53103ab7c4089fdb4aa4b81b402b324ee786fafa3943b4f17a438bb33e7cf5b02d661977fe399cf9f10988fc3c2e3351a146d5ef93f8135589f6129b19981a277a6085d6c40faf497a2c01d708ed2751f12d5f37181e64280575346e19735be792f4ced94695656943ef8b363ab02179c189eace2c322a21383766f12bdb97543c6df60eae50ce89f1f6523cefde403b9e346ed2d07cf89bfcd320f9786e5094001b1c7483556061e2b91a5ed6561020318241e2f7875840ff89678a822dcf8e9adb35dd9f83677e9015b4499b11963a9e09538f8c75e9135fa0de13f77a30dd3addfcd5506f19e28180e2c85fa6173b2e4d2b67d01d890aac7da4bfc2f71f3a8c287ad83a664593b7749ffe298b7dc75454af90f504b8be8ab7464f4936b98d6ca3b59fe33d49890527e9251deceb092296fe199cb8b7572d9c7bae968d64d5c02001d8a6d2fadab036663693d7bd69447eade8e90133844271d3a65b66e0141772f14c4cad16a01280b352431c7e4a83d0e2e080b59cf1dff676403af60746e8594f550273a6d8872c52f4ae7b551d0372b37ad00214137c4cb8786dfb411d91e96d91b1a62f914d7aad1afd72aed2d442e287ac1f5e6b3c02b5f61421a6de40f66e8e98d095dc2ba2d41f0b362f20d4f80378581538385a8f980e897ecf3d81c2e196305600865365b6fc06f27b651130f4c91477ace00179b5cfeef7af03ac861991cb64c245cc19652d1645b8cc28ee40b7d3cb24605d95287639341ba257babd0cc748039b4230821bd0141b6a1a14f2ba0a9cc9f4e60f02b5a7a93d0d031d0d2aaa8e3256fb4017871d91b2052513ff0e9b73e4c18a0166278699557caa338a55b563942bec4183c4278bf679f9b07fad2dbb6078e8de4ff52b2eefe3c7477df7ad5184d8fad22c6dbcf66bb9c2d1ea668adcfece2e7ae61bbb5997a0b6372051ca1588040dd6cd2aef7c8c0927326023cc18654fb893eb8a55294494aefff60fc2af8744301d1f99583e8d398bd8c2b304e2e8a8ce116a4950805bdc571fa30169f633b839ce6d4ad532d4f4370039addada305d2c6ba8a2ccbffd7b9e7c90278fc846ca9f64502ffa197fe7df5ebfcc4c28b12cc471fe544003b91108a5a8da27e47beb7a6d754f9fa9e432a13eefd67004ec056e9909c125b073bf4b50e6de615681375cb220014c382efe90faf18d6107b2844c21c008623a3a9488b40702eafe53a6192fb1b4f5f71bc8d026734da786043ff1e2d2f4dffb496d9d9a867afa0787e5a690304df18f9bfc85b515b5b728466387747ba957109f9195b35b5fa9cad18ce5d6bfa18b50d4a91a1b5edd1df32059faa57a46226639f32336f8933c45010ff4c92a59a7b711a321e5c21331ea647a5e8c777ee6a95d7aba9b3e35234cd0123f37423bd260f1d31a5ff4b066dbaac3b7a032307694a45ac7b757a1b146c91fd092cb6bb0e6ccc2b44cd288cb01caee565991700d20e4460fb71903994b5bca1500ad760ff2f1c170cf4a47be7290277a7bdaac2aa522b6a0397fcd706e000186ad4fb73c1a3c7be6e7bfd1f9585b4e0804071abbcb15393111c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
