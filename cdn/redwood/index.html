<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"043fddb5b27c0769c6ca0a79b22dd57f082ccd4bb355ff7a8371be375ad14e524f531f65b44b043605477b54650f945abf8228ae8b45fded0a58974053cd63267b762cbca6aa2a5535d6188d8012319cb73c6301f753ae45e88d40d7cbea2380cf8aa71da8223ad5dc81a6381b2c005a7bb3e22db48493a8d7b3cdd2a09568ea9cc16a2b4dd5bbec50d6b60fa5686b0c6074d9857cc82a7038ed92897d3dfc5771915ec09ea8db4e570b2bafe490bfbaf09eb39c68db5738de4c4cf36069e992504e85002b76505a85d82c4e2b2b9e48e1a34cf3eb18969a38728f00ac63b880a12a0f921a6499496bcf62d0febe909dbea98372d6c5458dc261f836de9869be31cbc190b86607239720d9c5d451067db8cc37a925ccea36e6c7d485ddfa00f56c9ba16696a4ab4d213b09ed8eb745b8abe77644479ac6775ba4fc556a3a5228f62943515ad8a327fe81c21aec5de8f921fd9ce1e1280dcac39d6cf992855741942741692cb6180f86eeeab411de9e66d41a289993eb933574f5d50d422377f0243fcffa9e45a795b22066ffd5c3ad92ac508485f12da6923c866091247732b01722cdcd45ced35b4bcc8b537525300c135404fd72c5f44f457be1508233fe5aa635ba920c9dd53224733a4ba2dff263da1b7b193b43f3cabe66024048e5c7da8bd42bfce3cdc1ba69d4a8de8d00e551681ef105b0ee8ee7677452c645b5b17a1fd8af3b3034db28b6dcadd2e3994f38dec11a618a5db5de4d0859bdd1968529c00619c1b46982d798c6f8f38b33e2b98687fff821adae864a867de76f099efcdc87c9f2adb38d2302942f58e538a55d7bdbe523fc693078b2a2e229f1125686fef17a01037ee7a433d561cc90298390af68f5c7d132f4592b8e85fa3d6765ed11dd539f588fdb3ac03fff1ee0af744eac5e67a4a3516335b69d827a7f438a86932582c6eb115dac077a82fe336f0a6407a109394549a269ce1d67c69f40e899e772bbdefb50c2cd10d2fefca0b1e2ec21dfb47accfc027f4753e5bd72e7d974eeb13062ab2386fce97cdc74a6996974889ef0e9b3e8c18756250a205905e92051f81770a3c6e04600b5def39ea0bdd82369b344f41ecf88162018a03f8805267f15610f7043655eb3995c5495425ee5fbafd00e67cbc9b796fc4437bad73edd556ef69e47127413130aab71dac917cadafd50987aeb094333d8cfac43a359591ce4c24eb07eef0a672959bb8c083bf60eab90bb9b7437a5979383217349e730500bb7808b5f617fd459a8649c832a52f97749effa3859280736d7492527dff40bd1e3d9f478ad6622879ca810a714325b48d36986c291ac60819c65b1a271359d1b2819ab936546f21cad875f99e705b0d1e0c637033818be4d561bd9e75a7ba29c58654b4c779137e9c91f1ec20181df522a666d44890f810eccf6b43d12c8b644def0ac8367ed34c76f506d37d3b0ed5949246dd96a155e407ce15e2a573fe1fe5cbeba2f81e77b9a086d1161959bf6d4efeb0b271feb4ba879584cd3945aa2d5b8d5766a3fe4ed46f083a842ab6bca55d1a480143159fbbaa10e8d15075dc2ce24ac8411a978488d1bddb8bf9e150737d0239edac2de0d1f3de956772d601173c35982f5d76b3e377b280f97054d406bd8ea00c2d53f9c154c02d59d988a65dea6da633e69ffdc8ddf3a72df56cbf448636a78159e4a5a64ccbd579438c1f1e18d3e2487d321a69b7cdc242c65f9a0211878cf9c59329edd72b67fc77f690609a74e99a7b29072ef80adc37fd259696e1acf458b689d838406e4878c6fabd8572d04fe905f396e5f7586c8cf96a98ff0e9cb19430d3d9a27b99fa51399acc055121ea56ea3248bf1a020ed2314c5d751388c534ec0e35859b7c9250bdd1aa0fb23a6b2c5169ff588b94e0f1066e01c55de423ca3de76dc32c0257d18fb3edcc24a3cf13d81b56e81c572ccaa095c887853677de4b17c0e85d400a938ea1f43cf74b1f2197eba8362c4c9d74c25a96187c8017f22c7ac036a02f9da85abb55d6f74bc015f7dc3f74198674e606ac3ab026099d72548c2578ac3591278412e6f20038ec51b429a5dfbb51d07b6238d78458bf8c5be1a1c18eb80871c9c64c6477334d25545b2d7e86e4ba31c7e941610885b889656f1ec37cea33b1efbf74026a66aeb8f0729cc653f3cc29b0a9715614cd591222bd513dece73b8bf060cbbe2b1d8630f28fd18814f84e4a9deb2e70228f0f53acf7c170773294662a68565b785dbc3b4290201b4e0f320446ebd30d15f5e822939869df8c30975caa80cf8475691e0cfdee0794c2ec76d93f78b88a0ded54261f0b69ff820c0f47cfe6e527bc2af5ae143cad2b41c7bf917882ecefeb0febd596186cdc4b1207f8e57be9144eae33db5e766cd0c07261a2d4ed43d635a19f751e5fe2cde106448446964c5f62e33a080919ddbcce1cef2922581bed4a8c2e80fceaf324bd0ba53305d9e6c6313f6f2a018cfe0257b16e994bc71a0c36c5a0cb5bd328d229c9dbd207d100ab52654771cfd7bdc51691facbe71748067d4d2d8ab2ffec34c053b50c0f07615acf36b9edc1e52d3f890465bf4c2ac4fa634bbfca7e591fee7f09f5ddc2555f3c7fe74d871c48876832f82290b6846a01fc146017712e0a610405c61f481622e172ddc60d9760a7295addd7d0f3b170797914a858366ff54769c328a2a1bf232b6d1a3e60dda995e35ad539c793aa71e18053bdc1a3b32e4b2d7ee8f41486bc2ff24507829f30e8bae2c2c6952f7cb478266f26f642648a988d03a8b15fa2a9120201837d88326be417b8ae788660a0010099d6f0bdbe966d47fdfd4d79c556675c4dd75d4b13ee96db977feaaa7a252dfe263cc5d83e33da287c9d8ffdb9e32d1947f907651ba14abc3071964003ce47c42c785b4d0ebc152fd46221855f590e63095e9d40679212f7c020eacd1a1b335c83acf659e445d92e2a9a3dca56e27021a570164231d3eaacc5b4047742bf9418d9fe1581bf1161a6115c6131f77a66837f64b4c1b11ef83696adf676904f43254ca5233ce72113bc6d707458e6d86132b6f0b169653b3dea3ee44c71fbc599c7fc93d6a97642e3e593b9c198fe503c61a86e640c75f8631555dece21e9294726e7b65461f2b0f63ac432a09a6a4bfabff82e53c2740762758b1ca30020425be2b3f4309817202170e01390e8b6de8d4454b675f1e1e97522543e07a8e46eabfc08978399196d5f244b2e3627ced9a028f2e7d1943fe79dc69cbb6fbcb1c31cb0080c79d1f7ffbeaeaf7639d8cf9f6a34ead3282aa6a1f8c022fb39746eee0c72d0f35c72948bd5ebb96c6ffb98b1486aff955c3c9ecb6c476a255004f6c0c56dccfc40d3cf3696343c13da21a4afde93784863cf9ff681af7045ab5f344a7639ee96d9dd1ce77bacf9afe2dfffff73e2ac8d2db41566cba826f279bf48c22e0c9bdf43a82523ca7c4bc69a976f46f5bba8c6955c7f5705177dd54b56743b2e1cec0472e4d87037dc07d2ccf3f1108bf6795a3411e1bb7ef6d8c49567b014e2b589d08be356bf3a6e66de49973c29a5a0de1987fd610a8f614a4c0262639d0461f3bfcfe0d6b553d3e3675cd3364cc66b47f93c90fd4c2fa0dcc5620c503511f04763edf7673232dc10eaa8903807f9915123f876cf41700f3d790bbb3f86e85788de51cae7e530fc4184836ba0c5bbf74a266a7d47c41038c5347bc72bc852d86f494c22dbfe365b11e78a137630cd803438c0e3335ce8aba4fdd197cd5b53d65734db57a56b673e74c12329982db518ce00b397c9a41286077bba6420a2b06827fdc2be639ffb78d7ce83238c8129a3f10d304a729577b0fb15f850b90ee7f43e52d8f02b0f7c7b777d75e5e54aac0f95fe0325c12adbf84067ec8d2acc4b52e2cca44c00e6cc61b750944e8954b12e7ff993820113615a9732af49f6fe87eae989599ebc16ff60680bab460f8f2051b3b44b055a3829c09eb76ff03a0484e5046584488ad3f3c358464871e6d0a2bb953f3ebc8f46dd37a420d851fabb3a8d1f334a6ee1965354e66f69df8a1fef66fa1e4a7b86207fdf3e50de2091ad18ef5f7a5014eced3a170606229cbd0304560211f71cc6b806941bee6565bc83b9d6aaadc33c6bc06fd5f15a1efe34243f45da48861f84d9b75e637d0646f1a1d1664c7dbefb914cb68b0e784c210627e54555b95bf3e5e5018f3ed8f0169f6cef8412520888197646fce57322d7dd80b0a1a4f21609a11606effed79f6ecd007910ba97e08860d0a9883360048fb6b73011598dcfcfe39198a092c69ac96fb34f34150c5e61abf86402a749a68013c0541691b9060aff7413ce540aceb9d6e8ead84d5d679a9c1fdcee512645e047517445a3ec97cc2678bf38216fbc650c7a9177d429d8ee0912318839091d736c8357947c45cbaea10f75092e5b71355fb62bd782c5bf44f9e4fe545f88fef25b998af9908966d6a8b427e1e4e201407f43d4bcd7e56dd9812bcf507f586d3b27cddf30d7edaf439672cb8adfaf1ca671ab744f53f847e6a74ddb303f1f7f2173ac83d1c13b4272a820f29bbab27298ccb2833e62aa54dd662181cc7dd95a6628514c09d03ec0482b13cabfead3f696250f3480056bc541e2613fd779a8ce8ef16d07619a12129784238f19fb4040f5d1faf1b765dc64a1da801b671461ba41a74176aef501dfd2ae0abdcce4c6801d76647b69ab533dd28550986560953c5015aaebbaedc5e216e434a615b8216c51b651fa409c598d5a11171fbeaaca1e0d2f00edfe5c3273f47dc96150a95e4e7e5b7f3a4e9f80cf8e0114374ad658634177e9e80ecc9db5104768bf9d75887acf407d3f682dbd18f05c192798b98cc85eedba2afcb9797c8106f6ebafd54c73a5f796cec2d153b3c8778a72ef869837b343022007f8f186f223579d68d528fa8fe28d0f58774867ef50c940416269d2859cf2963c6bb61858fd0f19a2e07dc3b130fd81945337285fd97a015f469909207def8169f470bd876491155f95635d01889c1f64525f182301c9aa37fdfcec9bf521202c36e1a2629306211f1f468c88b5917a760932fb3f80b7242f1cc531459fd2c88f0acf96816035b9f118bfde1643cdc20223986e65690414787c71161d2382f36e1a9e9ffab80bc082c3a2cd513c1193d2ca6afa31da9143b193ac00978754617c0ef69d2bf48c06d17d63643ac38f6aca49a4096e276a34756367e747b025cef3edc1f90d0338b433ec69b6807789a59d51259baa8843c7cb93168126ff42b6b3c06b62a07f738d44f1ab80505696b5ba0c87c70bfd6bb9cc97f818eacbff0fdeb620585ab67d603f8d57096e0b38ea574cf11cdb69766441832ec687fb79b7b9394eb0da0ca2bf85dd9fc9ae25a302d52483e977138a96110f1434107a6609903fa47a530fc658a71669841e7bd17d03c9da0d00772d9512f2c1650574897b378999d165ba9bee79bf95ef922688c2ba33a6345a66de825f98da0b18f381d45a1a437ad8e4a5d380761912da43aea1d166a26508b3193235bb865a81d65e940415948262ae06b03e418a57575f08212d1c7250da84d94c0de1da33d6bfafffd30134ee4cf300f647d203ef243cc9732b553ad8ae532c98a23b48dada08a88dc1a2d8547e9e1c0ffd242206e23484465d2d74dcdc78a349dfefe7a2ce9e67b001489f32677a039170a9f9ec93bbd93d6984a55e500facedc3cc0883af0bc42626c4473b99d5998784b55e09e03237d091e6d9987ea1d30cb8dc2a03515e242a1c5ec519eaece1caef045a03d4286e7739cd6ea9306b1f5e2d12a90f419465a7044c86ae87a0df792fd15b0fed1040cfc74695d82bba22f05f38b42a8361ac4f76255e6b6b37f2d05d5e391140438ea24c50258fc647dc52906aeee806496b6cf675d49a97f35fe5ce2fb7fff87584d2c6b0c55450f8dbf771ee8829c84034b102378f7a8dcc2cdd7cf9eea1b07d54957c928a02d1315e5cc34652018569bb87642b41e359fa1e99eceb33ffdea4935e3c5fe4dd14e91ed41e658fc8023a7524ef0b32438669e5615efecd3f4d1eb91f736fbff350de6e3105ab8271b0ae5d77662247af15999caf02fff43e80ed400e29600e9b68eb3fb2414f826cbaa8bf243eba24d5d32a8924782a3f3f486470bad31fc822531f04bdbe2c5cdd178989159baeac49f3830609c1aa4a8540bb657d28d6b4dcbedc0cded576bf1d948c326203dd09966ece5203c153354c7aeaaa39cd4c8c9b9c07da6d80c82064ffa4227ebc16298159b75c297687dfdf50a7cbc118d45ae47a467e3359291d07daf893a3087d3ec22bf363e2db05cdfe34e8cc0cc7243dce316b64997538ffa16a51cc82167478570fc232e7d22186a402e599d995ae49f4ecd86c071a715c4cbf6ce8cd40acca5f2d17c11cef4d864570aba372ea38ba661b4255b66b96f245d952e03960892e4a8253a523b9806a833d3f14d06f121e4c05dc08ecfc5b34f87da113605095186bcef3e945d5d1cc685b4737e5d83a33f472ef333fbe002bf25292d17aa2999f3a82e06de4f7974feff59cebaf498889cc451541b9a02232702a8f25760e43dfe5e4bd056dd7ca38d7e93067c0a86fa85fbe3218d82448f23ebebcbfd207ab5006ffb632f8d178e3f35fb0d7a11a8cf46e958a7bcb33b421600c23551776b58535eb16bf6612c11778c016203ac18f067a9156ebecc121aafd1b907fc0771009d737ca871727ba6c3f01916ffa6a7d35c2f8906c3728f5298e64c568239f9c0e1168cfd5003c503bf595fa572e32623d7e5980e1d791962c3fe642370f5a2c8f8fe0475b543d267c0ba3625156599e86338894a208e1cd8937efda1f6c1d2b139495c6972333c9ae4948b5f71684385923351a71ab1c369e65614eeada0f1887cf2908ec16e2fe387ddb7069c19f7656891fc9f0f925f8cfd45b7e3853b3b55051d988a1f0f071dd8f9f0a5ec526554c46f6d9f85a64e3c1f6a5acd8541672a77cc255475e6cf02ce8af6512a9a1c006a3f533325c61775f493bfc9408a0b0d1781aa09b605e369bb5135478830276ec52932407f8413145e97d6af68ae000c3c917dfd15765f5b14d7b268f914a960b5f5afeb95dc71953d930ec94a7de5f42f0e54914b0b0f65d0e10677e9365cda78c99d3b0d4575858ceb7d959ba99802bb6df6ff65ca31c68ba199effbb6c573ce72e8463b3bcc797d7d336ca916317e1129d4124a799d8e5539c3ff7e91181d4775d7053055b856f1024e44c29ba583999fcdd74d3f2167bad32fdbbe5205eaaa76cdb734a7e07f095a1002f59d70628543ed9c4923090157ca83332b10c8ec4df0a3fe37c70890b1f9ef1592595769eae9c5365f3dd006330517997ce05812da566644b7e462b66c8cb43bd45b8b1a7ed7ab71f9f3ff68af9b7f499ce9baffc638c7067151424678a0293811ac6584d146238c58ac2a6a1bf3e7e59fa89b9d89d6066a11bd6e6781f03d62fdfcc05d95b45feb8ffd50101a8e5507093f6658dfed8139417fe36ff4ccb9f6c9315b7142ed0c348c40c7f26fb70ffa320a1587d59800d62c800f20cd157dcc93c0b16030e4fa13bb0aa66818310b67cd216f032d650564f54cb2404e55d472b81bfa519bc76a43b4d5ecb4284f09cc58ed4f704dc48c4e8cb411855536262627772a7a4a1698f68706be81f2642b558c49bed730f32b36ec07d2d19d2d315d253b4683995f47a5eba767873e5b113db64f5c6d43bb12419a7c90ab610566c28f8f3deb7b1995a0e9f467dd06d9ca719c07e4ea5cbeac7be44aa178a935d43bad1d477ac34782c777aa47d7b223d70947060fca3fe32d7a0d752b0b8ca73a3e34107040f16270dfabaa1bf0d56d238c3ddacb53d2ac8e136fe3f358a93e1e944a422f60c4ea1a4abdf0350d7fdb674b984be7f41a4d6cd7a09bc009208d2cd685bba2d435db629ecb04df0ef13f68951d4da8433c7f1df24b5a39cd3f057b09f33682677ba653a2c70883b7f5c22806f346c5055fd2c3985cae735bb0d1711fdc6947e6f239f2951e9d45a6b78ad9fa58c6396750d8606cbd6af922395efea2501c887907d4c6e08d2613d097226b174b68e609c673e60d3a9a0b2cd0691b4b0ddebc564efbebfe6d23d856a42448e43f73c6445759c4b01927de42ba77bb7f87728cc78f1ad51275f362f6454057c80bfcc4f875aa31bae7bc0b87fa5bac9c56b009592ce590f318700335d15369df9e4f6ad753c5b76f10497b6b514fb2cd16b125818884eb37529fdecfdd7ba207889c481cd8f1c2da2c8edbf90e2754c5733bb9a63ca4fbb7effe3aa9887757d03349ae69908ce30e23066837686cf7429705aa57cf489b5051dafc4324c19a11fe26948fd015687f71848135aabf9136d0d4a04b19bfa6390cd028a7c3107fa5982125f1b7a0143ad2a9e6aac7216b9a7bd188d49dcfa6da022e3abeb2a1c03d8d1f13543dccb28b6c44cccc9127973316a5420c386c6b1cceee1b575ab928e699030ebca0eb2fa407f5e13d52f2bff4efa0f50fbd44ed6a98c6625bf26b9900df74d5d0c7663932ed1813dfff378a298f66e605d06f91832a2e99c4812069e980a642fe6b2d852d4ecc7971d78737ba78955012436d7516d5d5e49ff691e290a11de5dcb808362c7cd614666f8dce7e48fc992dca9590c78927e763e3af5f907725c91cfd833eb64a795e3c41acc0fc50361b18e1b9984b783aaa4b956cbc7aa8158f6bdbd77e96b352e8d871ad1623c53fd139990f20d68dc83a5674e21ed5123917547de088703a863cdfad9682723cb303d8d142e013a7a3d9be72f7ef64f4d33f710ff3c3cfd5402053cd15a5258b289733e9420465a259f1c4c998179630f43799fb603a6d7bd38158fe5cfc6a383d127c01d3b1af8a8f8b31885655e6c0eb11a91142ee3019204e0de47eb49d0c7323b43f6a59ac03f0975be5755adbb0dce191d0433fc44bed508343644ee99882d93225b6626e62dd7243b4da611f678a92b403b9283bab4da5bbeee23fd87e2388a6a328de6d528ae0ab68f281876bbcf49010e89cf3485d10d295d05f4fee5e69d88bbb8c0bc4bb8533dacb225aba6f8ce69ae4470c05f3e10f72c94f02566d6fe50b7d42bb6338233594f60554cf44c08e1e810f07175414e999ed4db2355894185a8a3fa804b24d9646acb5cebae7e0775db84ddbbaa63ef9a2fa8cd18b6e3d19d1ca9e3fcc77288f58e8ff5b5774ac832d9e7404cba0daa998e0552d77348e20e6ddccf4964632b504e01d502698d7a551c680c2edc12a4793f06357a96bb7b9d4b16e225b4caf6f6884cbf04de0e75afacb27ffd6300fec9be49309caba7b42cc022fa43831a7c5fb7c722db57e82f8a725eb6524d2a319655251aec686dd6b967a41807560fec920306e3b9452ddce27f612994bb9ab7ac107495f3623ba531708a35e9c5b8afb419df52afa96daebe0150df5130bedb1d72f1698d1db899aa1fc6613a8bb2821e26cb406d9d2f2f97f718965c04263a6f94e0634c6a11abe15edd7967e777260dc0320cf711281800a649378a4d8e2236614430425de65e59d671c400a8ec0802d0eff7803ce8485e54d5101e875b2f4dab4344fa4558096d73292f3b4f639dac161eb9ccdb7e77250c47cd2a7bda105ca7cdb230a7903aa0c7c90b7170ff5f27756ecbd9bd85dc6a5517003e1ef2b15742ad9bad2f14cd350bc9d09cb7a68f0e33ad9da67b2b2ea03070506f7e64eeb27afd5f66286e24a9c601067ec3f9e7baf2b9dda5374a797df9b6e12c06a7e936fcba8a47709773611bfa4afbf2748f037131ee5596c4d6ea90b7186505b50a6803d7c921e52f93692d8514c5af28f1cebabe532c2a1103407da2d6633a69843f40d98f563a53fe3959fc5d88d6c7d2db297064ed5e410cbfe747416a77875511998d49a6fa8636bc37902e396d90584683ab8696782a6c04544723feb9862afada8ecb7b55602b68664d6bd49b753a829082d7bfa37e1f2e5c4111a4faa83ad03b8aa7ff29d8f0736f4c12250e781abe5080081f4274d3b02dd490684805303da5c76562715f07443110ad2501f1c84990b806132e38776280bedcd90310aa7472c8ce26e5395edf6909fa216ab62ab1f32ab516ed4bc8bcb7b43bf92cb3c7af2bd9164e0de696cee87587bfc54abe67c82ad507a2092a7c35d71f1c43c9af470a8c4cd80421d57258d60bb930ad508fe6daf6f72fec92f6744bb9622ae7a569cb60c0afb05bec4d35c6abc198081a93f29ecae215d60cf11eb649e5813365f4d809648bb50bd4f62c50ce1dac8045b73e828de8110a42a67c101aa3a3af52df73ea00ee2908f907d4019612cf803c994875610d50d99c4bb8e5bb02669add2cbfbecab6563a18197efb198e393b0d7ec3c4c67294e3682ab1ae8d8b6ac074b9e2ba1783a65228cb9f2ae4fd2a749af9d2a85ddaf620fab1621863e532c889a6c33157e2a3e6e85f346f944896ee7c3f8e793df4c3662532a5a5c067cae2b33ccc2c140dba5824d936505b6e5d5c6c6358b9e8016287eb2f7e686472809a3c9f871d52d8f317a3412b3a51e773eb4c2cff0786ecf0b76b527732b1c7034452546af9e0d545b4487c990f944723a9c104041a5d948fe6a8e8cb2f4d5061372ef615dd99c38194b5d14da9ceb7d6d9476aec47304b6d9dd9168cc6f91f981fa8ab472374cee36e76fff5a3c61c313ff8e4be0eda7aa09880489bae93de91a1ca9753dce143499d669e05a746637e09b88c8280a7144821b474d33e866fe373b1f99f2e7cf9e8f6f730f67bf08f5e7424f16a9e8ddac8c37738edc1379c09e6213bc066d5c78a036832f14655b78578c840d1cd66dd6e359894faee440101e3739262eac23406c1fe5e5372a484ab9adab8bcdbfbe4c8fa306303be2a42cbd341ecb2e4c9287de4b25f7cbbb749815690a9ed6185ea0c24a6fa02571a1633c53b4d64d547c8fd649ba26d08d1383b03fe18d8c34d77f961986b26802b9082a9a1b1728c4173b221e1c0f937171e773e6c626d2bc66ac478d624948e095f1bb798ed594cf5b1d4e2ab96378b60f4c5b783cc276074ecb6e3abaf035546348922f64f9c0561810cf5c62bb8682e810123f231f9446f98a088da17a9bb5ff09bf222f06be0161695c89ea536aa3b511c0987118348b9ed7be5188f8fe781b4add62ef7c4e18aee4c9d4e139dcd5ad39cffbb9f9faaec45bb8bad0baab99c76540bf3a38e14e2e5f3db30717f9831adff57f20493c71c6ffd141d28bb422715100597dc76b171deae8d24e9749ba117b0dac161ce0f93b329fa4844b08c2e470b8f9a668a2892040bd8403aedc6a5ec980c1e5e027d78377a7100dfe21a1c32c20ae1f1e74ce4bcef6bb1394354cc1d17b81fab64b0b4b8f457507baa4a8b0dac5c53c725cb02b3a3ee40846ee3a2e833f59dbe86082eb473d9b37b911a1c9609a51a2e82f25fec9717795eab01de7e7059df716e1526e8cf4aa70d4112601370d6b8f80fc63c934291b6337fcc696a07d27579f2e5f79855e161c5d44808036fdaec8f46478d9540cbb1b4f4de66853d4cb6a8d065fae15094c7dae6a64ec5aa7394571c2e71416e72ab4b492a212c1093b1be26e58848f94d4b12f4f3673a42fb879ffdd1c8a24ca906702fcb954c07bd75809fa7b31f9d9db4bc3e8c0bdfb281d56902d1a25b4183d39b2d3a8e3154b374dcda264b544ae8d9fc07e78a96a28ec2740d8951551e8d98c6ceda0139bf685bb7a1cb8beea44fb6b8270bafa7bbd003f6be052ece94851c4aa599e481c77698b6068d90db30f47b37cd2a623792f2a96976e6468924e492ee5cd57610cdabdc7813ec62d13884e6533c3cc4a9df58cdd851a18134581e471eed5baee406d78ca3a6c578e43ef56e70001d33b012b99a67b0093d9be279b17a27a41025cdc22ee1fa8e49df28e9908ef5e7545d0c6068b1b0b992764656772ecbbd8a66afc0fe19f9424837c2c337b2b810de313098dc4592aeecf403ccb625fb981fa09f18fe511932ee4abf2e1bd6a5e806e0a7eea0da6a6a21aa9943eade79c3af8c77b20dd8e5d0b7a4bc20ce73806516fa6591740f6ca6dc62660c088cf2bdd70679d375c15ee3e6abb3fd3bdbc75a5f66bb6602c816a4f4478ab28024cb40c18414427c3493b7c5ecfc1e42069002fedb8e79878c7a066cc142c492c4c975e1524c195fbbed62e33e18ceef9b1c7767fe654bcd9f4eece7341f6c478a86618081839fead41cf31c43835d16dce85ea4eb1227581524a51966da5eb7458c3fd87ce6fa6eade22dd3b3106565f010bd98cf4b2aab6bdbfce246b80d0d925f0b8c49074a57759b8f5eea72064af9db31a62d002de24c784ac6f9d7bcca090cd25c199ec6512f9f146bf6ec021fe45108c00a7431ed6a23b6322c571927f5533aecb7150205b288a5822f271791ff2ff6ad7aab459c146d5ed3f315bf80d07fcb223c5677238042e9e389baa9064fa2e7ae38507fc0ff151c2455e2ddd7727031b848f927bfb9c3e34ed1a756c8b37a5b455e7ae20f2f5cdf8bd1de5dbccc55ee73bf34daac9655dbab37d364146fa1aafda915d356c81725d1cbf50e4253cdbe8d6372cbbc65013ac2f056c0ca06f14f67d406336c646ee2eaac815374c2d6b778b9bf6a6616eaa4f807c490cb549e918e0d651b495895d8ef3a1b93caa45fd7cdd9d8530059fdfac06dfdbf754d304ad7b3cb44ae160bcc60e8f64919fd718cb0b42d465898d527e5e71c78ce7ba2f76a2dcb79881a0b695dca3ff2f43fd685c807cbec1eaabe32e4d59688d33ab7c608320fedc507a550636a7ab4901002e1473736da0c3d4538f5aa7422167f09fcdd3772d271bfa300a68e99ab3145ee0d531ea699e31c631a80093421c8b5e8a7e794ae7f95dd8faa4d36de7d07719157c3605ce0fe32fe160eba9b062d4f61d8248e594c94e0717385800bb31c73c59a288e4bf5ef59f63737cbeb31ce0b143f005cdfaac8a569ff9fa360ca335e7afc2b15573a11386d87c8d9cf31152c69fd7772192738ea5c37a1797aae249e2ba70b87e18458eef0d9a1cd505db240ea810e38ec89ce058e466c302ad49d5a1f7c6f5dfb78de7ffb01f65c7bddd98e9d976b412a4356be6621b1e1818399886bd9ee57a37b84ac26958a4c09ccd533d7e21036a7cb10fc93d8f9131335e9f6b073f16e4ed841134273db01b33775f30345159f2ee65ce5be53c9bddc7db29f06a3b9a98214b2ed2060237994e4812991dc15155bfe6c83a89efd32884d6c4282f143c9be4f515e3c3ddd78fca134da5c2b4f86ee2ce2f5651185afad7abb0513ff0d56a3f3a06235e1c7cfd31a9914e4092791f781965e27fe3920c4ed6368b2fc3bc72ec0a82043ce77fbaf64df700378906acba1bc142c8d88f5b9d048039d21f7aef841cfe4059da1eb251476191c2ab22da7bf0610b36106a3d8a3c9cb766bbd5f89dd46dcc6150d0aa5b67ea00a9669efc4d4f75037eaa624ac6e7096ccc9581a00b313f13c134af28f0cea40f7228e68ce6fc36fe23a5cb02a3025f36eef4802b9f101d93a4db9797b7b80334d79d6c478444f8fae2e830d03e0c603162ee0eb28c9ca7dad54d73e6fa176f64b4f094c2ecf0021403e1d89e23ebaa657554ef8040aab0c3cc56e5c85ffbafd63389a488b304fa31f9f2786b3d60404f100f95f3a3e0d0148e35788244001cce40debb562b03459f86c83c44b3bfe41d3aa283acbf96ef932b50f3f1a0cab3768b43177adeb046bbb1f469c9ba531615cda4d8c79e7e36caa766d7a7e98045a0f012007a80c82309ee2cc4962310dc4da9296f935a219deda475ae5d9adeec99741f15fa3787126b70f2210d817522d55e5c4b3b601e6147122e9fc6b2c56375e5719f4b299684c762579bca28340bfdcc10b9781870b7ff1cfbdd54ff58184642331ecd80a016218bec42f066c3d04efbfc6226fd6f39e23c691d687741ab32b321f7789666bb0b0ad5d107b92f0b4b8173c7f1bfa7441dd9750562cfd298af69a8920b89323769a0c0f9014d9b7f5fa80e098dafee74fc6227d4a37dac3a4566e13a19de0c788917e2b000212bb955ff52ad9d234f27d65cfea217b21cc7bf3010ad7e7271831b43da8ed70fed5d9910711739aeaee22e2d0b81a0a14cd5fab7154bbe0cb835244699d4dbc6ee9c2a8598883fb3f75d5192e177d0e30aca90ba21f61e5cb97b16982e210c693475a1a7abdf5897676ac0caeec7adeb4ed3cd78cd70e80b7812e18fe4db3612d55c89a68f5d417c72aba6a3b3ff76d0eeac158f4bfc24fff696802a0d980d6d2be9205136f66747255f996c17ab18885dfb138c5bd5e08733d4f0d46a022cc7fe9c03644cb9d75263a96e598d0fd6d83b32a33b317fc4c647376a1bf4e4af4058c363e51098c8b43197572561dd46b3bbea1e79f97b2316431ee7fb145d45a959a77fcdce12cfb30098290794360c4f16ae0a04a4f3c82d6a2bf256df6d76938f55fb4054bf11df4e35704525eb998d9d55782a3a3f82aba1fe1bbf39d26818c7f2e2177a169a8b3a22d3a64f68610b9a65df3e0fdd42bae2990e03be4be11f457d7172a4c3ea45e5d767ff6f51b11e6c99de2b4d93f43b777bddebfc575787f479d3c7c98a7f070a39dfde76fdaa6c6ed257b249c625a702704defffd4fff622e5333f03214e0e732e2bf2751a36be69e46cc4eb2d14feba133cb8d5e9e5184f7852a578d6d4e71907895c892d2bb90cfed8faf267cfc85730aaa5d3881154466cca43efb69692c7fc7d674fb1fbc414cd797c61a2232741a1a5759ea9b7b8f82e4cf5c2ff68abcd0f20af97874b29730f1320bcd6b6c8f2e4732ff991a24feea082ef62a21a424f6762f33623855cd75860546a35b10bb8792d5823260a7fd607f1129a14b6746ae793903d01386f61ec81bbe20ba4e8fb280d5a417083db87a4508d8c995f2cbefab1ce33dca05afa38ac9cbba72e0f6b57ceb01cc11cab1c2e8677076f58a74b559f503ea7e15eb2697d111a18484a5858b397b9ba3dae190f49a3791b8ee6cff7cba16d2bd84548ccaffa3ccbee1795a30f47b3e2935150530c8f686c966e7b12b287847eec23a1d6ef1bef0e7e38777bdc01100d739ff178746f992e8a0bf2e469481c45acac6c145666df7917a00bc7f6de75301240c791117b964c28726dc1e84d6093fad17b0e7d606fcd1a795f0ba0445cf97fd7aaae9341ee8efb81c9b436570f705c40a5a3c8514d80087667a14ae6638b98976af016e2ac73713d60ca1f5915ca15fc5f2bb6dcc746da0281f411bcbbb214ff062d7e2d7dd3d7983c94803ef0235a45d783160ec14344f8a6297e4cdacda40e5c8a8d7306298e1b1674f01ee4648ddf6c1bafed70d5b5e8c1251bac9160d2d9495a9dd34eca32608057d70a112191d3b65fad2d096acd2cfdd5beee523c4b4fdcb148ca05d3efe56d63ac8aa8fc9e2e53f91cb3bc4908ff570dfac54c6717c885edc0a95785ec63d6c7b3f0bf3bf09c385cd8277741fc25cc58bbe1880a7565754347803be539ddc96940f8613491800a5a8a0f4495081ef6b28e68d0f422678c39fa140ea18be52d242ff6d757c342e029c74032a68f728c3afc60f2f9cbbf0e2c23ff24a00a615061720e3cc3e22383863b62bd1a33b4808292ca89481b0d4aa1b033718444790269bd83f64de581ad2262a9df4171258398ba779f0ed53f43764ba92a75662f782bf62befd8c3d6b4090c837a2de2cc3515b29cc8b257172180e5274b376632778f08061220a34797a5324f3b08e424a95e38d919cd638aea6ccc6206970b50619c482bec8fe164132b8bf41e60a84263876f49b0aa6c6bcea31714e79db862517d7feb500c00c95bb41a0cd033793e8bbaaf8cbb01bb3db394a7e1112328ab1768f6896c30b40209575575e3ec0577b7b5b2a1af6b44ff7d5f60a3d8e4d679ff4da73fe960eba8cbe94214169158b18fe341c099900c209de202dce4280b6b2ecd6ccea74a85d9a2f4c160210950671df4a23d8627e8733fab143d6b524b7d0d7666e730d35e865cc11e62f9cfd93c91d1bd43903a2ce12cc263fbbf2033e5bf3de7e4f50908dcefe98a75cd7e36004de6a835d89c856d92cc819a0bd1b958528fed7aa599fd57b54960c62aa88231b7850845648097d49c53ab045905dea90d60c1e3b7fac933731b6a6a46b5e8b286edd1d5aa8b1e76842718e661ccb425b84d73ad3909afdd583269daa0daef753573f8682608815dde9697fd180aa2e8e016e34ccc7970d0eeba5259ab269fcaef2365ed1f64a91f1da697404a9d1b16a104e29baea3b2467f0de938fd5c006138d0faf6f600d5454795a43b3d55d9e6a33d697a89b3aa9c6ac8b8897d1621ba2d9c20b69c83432c763c760d8e95e96185ac97b3e9e7c7eddaa107efb37478a385d1fc111114324c764d6a31e6b3c83d2b1e2287592ac509d1b1d2f19ca459d71b63ad0ff60fedaf5e8d4ff4dcb0e18465eaffa18aa4369e467c5b93038f637d42cad6ef0e85b7dbf5880c76ef75c7a0c0b1a0b0a93e8559e2d94cd699f062e192a62a28ea6d63b2e41279351dcb84c3e9b124dcadbe61456ca170854dc82f06e19b8fa6f72413b84bbe53ba86c1c72217c73d06fa8aabd490810d8bb396853fea86c66b54dfe6913de8d855216fcc64b7afb645bc690f7e6c831014389270642ee40c509e3e76b515a1de957be2d1c5b4928e9252e52f88cee54c3e24b95d23e047e882f6087c0cc5f3949747898d8da409deb6ef65fc4a4d5ce117cb8f977f2c89eb8a2121b8569aa1736a32039ece1a9a32bc77f86fd5a332e97947116eb8d0613ffbdb7e3feca41624e374882d012b4ce428afb014dfe02b514aa1cdda44afc1ea99669692ac4df5e7ae7fc8611c691077b1691154347e1cd80a917224c4e8d10158793b72655b70ed892a61ea348e975906bea20c9bfca6c8e30643f08d3c6f9325aaa1c15b26cd9180176e8116820ec1381a9e04973cf409efcce2732f60149464f37038b02109ea3ba2483cda59d3ef4ba2e55ac4fbca0e38c4564cc4737b2eca4d1f3ae649caedfdb8d646455f2aeca9c117d9c95b221018d60f31126ac19ceab35d12492dfc5f4c604674acecbb1a6e18823f3bd1bacf0d1d14d3bc62007724e355a26258a51c9e5058ded5fd424062a5b8070395018763b7e0a4668247d2a373c1ed350cba09b8a33c51820955dd67e66eed11de3ec1b3c88d8f830d3971ecd5a528f4cc49e0de750bd3ad760b609de232b8b091c07511d677153ec6cc8e27278feb2b2f9cc2769ddd31814c9bd9e5a3fd0acb89c1c8dca2e3595ee495848ee24f85ad67a170cea9ad66b1dbdbe4000f7f14ce601e359dd272444bc64c98404b2753738ce43ee41b683dffa30e35afcc494f7fcd57ebbe02def84d2097d91d08822878a3fb4960620cec3be4e617b2f7c72616e9afc47bc7c23f937e02ddde69c3ff3299b2b215982904f230f37d0f62aad099100c2f21ecbf6a48f0b6778b3846db5ca0cdfaad9eff6b4fa121f6a2d88bdfd4907d195891510da61718e7de8f0eb35961348e239bc004decdad0b463bd9a0155fdad2e9c1bb4ac7c009a5e60043220951c67dc1d0066d574a15b6bd4f385f1968fcb5a469e9cadf618c0ad44d33b92f136942c1ce26cb5240d022789b509b024de994172f55928a1bdd9e04d7042c3f09c70970077d8ab7efdade8a0af25424c5c4e75f89d4c2dba7e176ee6b1b9558e111a8c5faffdd1d3ba76af6ddd24b7203ce1a69bb9055b72587efefc862defa484b0d6950847a2b7b998299ec340daf3fc064d35d9ebb1806a62de2e1815dab1950e2bf46af6aa2847c73667408357a7abf2e0113a12835e81b12861b721096995db359c5e1fc18b650500ac69a2cbfc83bd4371ef60f259a12a94c2ba622928c1a1d07d0e3a9e6b82da1fbb7c2e2d2b288bfab8494de0553014d1fc031eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
