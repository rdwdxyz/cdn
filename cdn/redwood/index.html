<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1a4e4e90effa680a4df6eb708226b918ba20012ea37a9ad012642aba663f8d50876f976a5287bfdf3102969533e2d6cb0a2a958b0b2c46d168ad8083e357b5b91f9a37267918fac9001b2f1e42af173bd69e1cadb0c0b340df21c78604270493e6e493bb3c47d0b43d00602762d2d4b08dcf83a0bebb96e0892abfcd7a8b92053a07a28c272feb83ba0ac9bde7e968c1c11acb7428d5c631bc0b78a6f9b2e5b9586682082c36cdcdb106a5b82bc93d703a2f5b4d0886b402e3873f7b33d4480bf9e56d987468eee2f32102e9c432cef2b6342e5db5e0dfb7b68e61641c5eed409c1e2ad815661398c7b122a9afcc48bf8ec591fa8dc4db80a55d01b06cdc88bc4e3cb260116ecc47ac00f0449f50d577f55fe1cd0846b601f128e38cbf9e57fd4c8f5ff2a661ae7f571bd30ff3fd25617fdbc83febc40ec2057138b6f2afcf508c5e035521ac73a33c2462664be8efbe91dc8a6bb5059d4873388610e14daa7935c68525398c622100503c93cce6c938dff6833882d08f5a8f731f5c116b51a480d83f6bf26fcd674ce0e8b507910c87e219de3e2d92c3295a8c53c374e130cfc38a16dc0208f442e2ead15165f6a084f245f3495d9de8b676a75205cdec277ba5967e62c78a3334352c2f78ed4ba8f1214247c6519de0a5a6f0950f68ce355e43ea2a446c890df2072f8781c9654e2e7a68fd9d6ab8dca0998c76300a232f628a8b817b5d64f7990fe724b127e00566a8a9fe3582835d0b963850f1d7bb0f222624f42e26cd9099e27b77f9330e89e117e6fac5f9a216652335a090a4a9159d4d9e32d87ca4efadbbb32be45d3ce8fd667582fb8ae9cd027d6ad38a18bdb96bf8482d890557dc9f84aef0a10ea017441fe60bb7b87d36bb7273b8d242b19cea49ab6728434531da809526debbe6e39812d10df1da3e92293911d3448997369bd786af56bf59d5394f414f8b74d7a65ad8ee7265da842fde44c6a46229adec37d6850e5cacbfe268d3bd7c88fc9b3f2fdb8918b6972331360d3dcd4b55f4f870f5892fa81604b6232609f4688ad01feb0b990126adca54bf4a340810fea4585d31af1ea72013316653a661c7317c413fda0e630b726ea3fa99d971257cc2e3e15862f4cc7f1e734a655d6a03f9910952f9a56b369bd84fecc3b8de1d2f5bdac86a876e1a3da13ce9255e4b67300c023a43d7951a048bbb8d913366ebfeb6e5532150e1cae7f0581ec636f4125dd683de0e320fa7b98a40efb0cdbcdf60952c4584040697e12b0e39f5f45af0cb7cb62d0e6b9c97393af65db3febde194b8e7b21447e330b56aae3d23c82503f9b98b0affc738211a3e467d849e807178a0e6a55589219395088e4bd148e2134bad7341b9759612cfd794229e29f00dba82e5a9bb9e9531ac8b247ed55d0d5204ecc787b2541b76ca4a4c0b05987aaacdff553503d89b0e7e3c104aae8474f14b5822ef5382f39cbe48d3192ed052b8d979bc8eeaf211fe4be47746e825c5cd4f85b6242ec1702f055919999422e6fe09811f43a9057579d302181cf16e3213ab8c01090687866199b5547351dedcb3dfa754f694b65b96cf85677d82cca90126b00be9eebd3d1bb2ed36040ebaf396b632ad3aa26f32813a660d69e63681f47428fe6abf2cd8efc4d31926cc130b4e8ebd12a887888d0b6ad49c4762fde16645263d7d446d90d52f22a5e15dbf48895bf2774fa89ddc69455de2f8a2b8a97287654a1a6d772af8a5b08a592880bdb99d9c9e2d6d24881e1ce9d5269bb5e84aec5dd04bd4e1564ea6691d89fe4256737ac6c89f61c80bf70ccfd5e13ea60f1983bfb297ea6167fd0ef3f2fd3c98cf9d31e3c5844482d65bf7446e45ed11d190afbacb344725e74beb802325f31a915e437e3516c5f3f44d56b3ddf1a1ec8e8e3ab19269b29ac707147f64581e235572ffaf74613db8248b8184d0862bdd2a04d91b58fc9eb312c588db36dfe0f03b5c8aa20939c74a270b9a98d12efd797d5ada0494f6a1394b0742f98b43362db78689a1b6e7acc02ad011f6af6014370b889f7ba0b1431a90f6d3f37d880f9c65a12f0525c820394f9fe33124fe3d21788affb8bee6d457996844fcd8e3ddffd6143f0ed757f57b3609307cf6b086741b7e47def0153f62bef68f97722f217e55720a259cc25aa07763371f2444c1698d2980c5658088f0bb8a8ca227d72a31dbb219deb1e9fe74c3852b418bea15a8447a40fc7d08d4d3282674e96d08ed31bb2e92522501af5adb3a7de5dcc0a7fb46d65618b9ac60dd8b5bd484bdd49a1257631668e9eb2f5da7daea923436c008f1fc9f4350d2c8473f0cfebe5c58dbba776ba9379bd8ff8826bca9e43b1fffa513c1191598c95d176eea4eaab3b4c5dbaad76e3e1c3865a216ad38bfa0a64feea05550e7df5666d24ed9dc591e6de4a1f9b639973e0a1af0a1de877ec11458660754c886c6434799d77816c6ed6d1140e20eea07e65f3d6bf9ab6b468bea8ef1bd22a225dfe1d37c311d5765dde907c520def4fe74ded767cf9e4e2e7927b89cd56f4c9e6dedb7d1cd78bbefc991f1d4afa40f5026be28315b0acf8536ab0c1af9f807324b4357333ff86d6d2fe8cb73c3b20420f3eb2f27ddf1d49441ee390f1414606fe14dd9c0f85e4555ba87b3567412529b5dc84be6dd8682827438a6f58f7f02c880b176ba394c10c0341956660612d1800cf7c63fee54a635946fb6c1fb7d17d08264c1a7e69c4e4c71e421e39d8ac7be88fffbcfc4d17623221fb0de4cfdb8137bc00c96044fbffbfc5856629a8fbf6310f1eb06a67e52e643f5bfacac6ef762b21a88425d84f6a466d416f105714d492ce469a54970e89e43f030f1e29438c25a0f22bbb58eab6e366520a4e833ce1c5f662bbb9997d35dbd4780b59f830dde209855c5c7353f6242534c2362d9b4006dd06276810f728d1e80597d3c995785abf3e289a4c8f41a25d58c4128063aaa3ac49b7613171e7143be3700e4a75c7dbe11d29a01e47f9bfcc874b0fc96c9925b81ec1c3cb009207b074031faf4abe159908f8f607f095c4e8875cf4ccc2cfbba23870301e3572f02cb27cdb812ea4d80228d7fa61e1c9aedd555e164364052b8b83256773de03e24b6d00107b23797589b55eeb46a5d2e8241cd6703258a473b3c3dccd331e56eea74be700a34edd6a9215c8eccef1d2ad881fe1a02b8976fa0090f4c5d5198f095178c30aab968f4bc7ba858cbaec893b86d7ccd5c9df3ce76d093075ad8c730e6c21eb8d84d2c14124c9ebb78f81301ce3a3b4eb8c95415d046e1978e4efc7f14460e5f9f8f52d792c74ddd86a66bcae298227e52365e19a2b3d93c4f274d9a8c3babbc7b8f84f215f1518f3e42418d4f39c1022badefe74f61cf9dea856be5efd94f65b77dfda87f979a207953451d2b0af39c71412711414caccaba1ed3a2f37aa47a579904f303d93a2c02e9d086465dc76a58959f38d8eaca10e89499074c36d15f161688e675f9c5c1b39cde41faa8fdbf62de57678050e85f4758d07fa536166a88a20909cb9ce5cda7ec20e44850ae0d7a094f1dc522f19004a8298341c5df2e56b92f94836c5e0272ad173c031b0f8591814138bc1e7aa76b1e8cfffb9e6dfb017ed0accaa2207650fa0636b1f17f865fa258d8918b6bdfa3f1e0dd63ce387e66e77db1b7da3156fe1ac4781250c28b3de1d96f23c1e39bcd968b6d954d140e63c440ab0f0f7d25b811c1a15a348a1b35bd43626fc175f40a6de6b0b1620bae568014c8fb614e4d226386675ada0fef6d0461e8f03877abdab2645da9ada8505cbf2356d7000cbdc0538850ef322359670cda5c5115eb8e62e365e5cb10458b30f5cf598c39e0dc64b26fbdbbce622c2ac07e81ebf75c90471b84b15d65b0c2dd1b937fd7b8a104b28ff5ccc900a94c1fcdc454f3d3cd3a1dc26ad25f1176d29af4c06ce4b36b972f25e1fab323bb58f506a502036dd1acd0507650e1131b6ca34008131c39e5e0085cbfba3a051bb0f396cd47a725e8e07800df63d6fea244832d8130a8e2e8712decfff280e0924863fc3f57d41fd536a0f7414f704afc6f642e8f3f261c052f17ff6cd6f7bb53db53050625c76813fd47d000121b3b94d21b35b4f44e73f341beefb1001c1d9210f36740bfb113c00b06e07d067662797895b173cb06b617262194be0dc78109c0d98a36600b6d20f1ce7c6309668d7067772be749558100c44cf6403a8dc6027ab7f6e4ad4a6c42dd7d31e187dec1aa6ee974359320702396468d332a85e77cf8cfff1729bad40d57b8bb9ad1183be3db90512b6d0ecfcf3059b4a004d4cf76510e0f5cc17fbef09b4d88314c17e0987b506b5ce415944cc9bb19ec122a61b9b9857f883aaae4fe2b9e75e63a6b6dd487c1d52ef2d9d2bca5a8fc8cbd7e92f93df86d9be2eeec0a3a3c502b309f68c9bea887bb9f302b0078ca6aaf152d94723314749e59ba8c30cd04fa1fc4dff170747795b0c45af2df7508af07f9007f65de831952172227b2629ace38e0acce2c2e247303b0c65f1d4de2881b72036eabddc00631e8a9287528ff70e3dcb5d26022fac3898935c825c9aedfbc6cd62685cac0e2d5c03b5bd9871af487cc4ec586ce5abed51961709cbdb14d58ad9f5e632c9adfe52438f71a47a6c9efef5d8a28829f54070cb0fa577d1dfe342b4f8e7a2f2921fb6a3585107edf4472c909f4d25da76226a47e42945ce70be0f5d34b2855128668b87df779b7c76c2b5602f070a5e59a679d79351bfd160b1f3b3280eb606a12ac150a086454aaa59bf99a763afaf2ac0352963b384f186175a4fd911728bda42b4a2f76a448bb04fa06eedf79b242f5717626b948f6df1d9401d92813bf256f2650976627faafc3092b289c3ffc19f86692439d1b355cf5e7d9e51b447bd95612b372aa195fe026256b7089b20b60475032e7cab4a6ee5fc158e211e7954f76423144bb41400742429424be5d6712fa33c83276cbf159663a330a2947aa93a7b531d5667a9caebec85063078bdcdc784f547fba56d1af2d0bba1c0cc828fc99e64de1ba418b9407be987f3be209d2bfac0f882d285bb0a9f7ede54040bf7819796f1d28cad337429fe63e1c0c8c4811ebe53b36dd3c92b106b0a7de8fdf8548697ab353cc16cca058a4214fd6bd32bd77c7118c753bf205410930f953f646b84a210151d4f7e05c2cbb5090a60ec1a3239b1e6df8d0c42cf2c7976303ad58e5cf79812e6c2609d8421f930a6f6b5743e09132cf90270caa0f598cd3254fabab5518bcd0c1e5043b410b28513926fc0dc510e7f9db23b7b35f558e2ca726369e1766621bb70db4a13e6eef28f2a79c1ce9a42e050e4216d0f84c605919fb5d9148349f684a9cf84a5d2b29833a0e3c881dda3ce66884eb9952f3867e04e709afa85cfd27ceff0ebc4668c1c3c8390fae8d0f76defdec5dbe33f95d5da4fea4f97ea8b0437207d35a6dd143a326fa10870536485460220a9d61e8f8f92cf9b9abc6a993a23a337a78965fb626b861d5134d724c6dfe24278f8e49de9538e055e6a08ef49d9d8da47a8d8f083045d8c7a8e2e660e87b050bbbd079dde91f9b3811c0dff0bd946a511cf6996aba452ced2ef88ecd7986ed4687e874c314f86813a1bde98b599695d341b0f1a0fe953e0164734ca34107c07bc1db17f1fa9c391e7ffe1643d702b95e47ed8b7d1c2766222d928c3d6d5cac11db6d67f5faaff88766bc2d96b966bda00084a42dca366b341a6491e96de9e973055b5fb9261790416f50f45c4780dcd6950d0ac5518b756b1257b5f2789e44d58d16d8f2bc6dfb50228f971cb4d5f432afd378bd0e6c7ff02c5479818ddef8ac97ccda524e1791aa63a3bb216961bd918004d1628e46d086e56a70927f7000cb65e241938fc45ae9fdcecc0b0ed0bfde9496f9a4438d293635ba5f173e269da9e520dd4d469e33acc45f281a536d6731866d4df9b987f0c93e1709b02738ffe2bf9ad918573840c11ed8bc7a702a4fcb999a55d332b450690bddfe45717dcd678b47242fbad42b23e586b99f343c2c604c550f760c9f05a938f6a47f5c9152561bc5211623e6f6e33947c3e9dee5bb9993dd8a6f5ffbae88e70f9ea346d1868c9b6c905139e861f43112d6f6bf5ebcb0961fb0ae9cfdae0d8c54692a7e4e8a725072f7246473d950c1385719effcffc3ead1f65b43bb100d88f81f4f2cc907e3760586ab79aa2b1a8c537d9043560708a22e2a0ab3fefae9a4175808cc73c9631246fc6ef7fe91438f6c224a4ca00dfe2d1177c7d50fadd1c4ce0fd8a4c3048b8fbae5d3a9e71641bb9476f85428922ceaef48bf05cdd09da3bdf45c99f6ede4f890e7840fc58129216ea9a0c5891f7c49f738890b0b098b9070f08cd43e17e3b4f95da86f55badc44a626d1d7e15ae747277bcce7a9a92166ed5f1db0843fdc156d02a680645176b63b4ff0838781ca3fc3524e97367f2112aab59742411d5c2c2af20184d9f6b893fbce4c49418f573b8c8097bd1142c313c9d90f6239cf3288c711524956482b5b4ff9b7c9afaac44f9244457646263d11d2c7a76fa41fe187402126bc5c658dac804e3a03387cf3e9483b0c4350450e97c20efe1fb9312e40fcccf0430a94f55ccd593e0b631b37480379209a61d6e6c9ec41606f9006ea7403ae83b839c0e5bfbecb35d1e1e0cf70e668dce88865761326c20782b0102f20aed51623a2bc7dcdcf54b8665b2aa8d8348a72e848a380625e985e2bec00a15d1adabceb4ffc538ef949b7ae72fa123b70e2ef56f648f983d5e8d9e4f36795ef03a8b2957738598ba897ccff27a969373a0c707c8759022cbc32c70439a31bd6ef91b39c081ddda59c77c1f70617855fab4bf5d95aa12f2c7bf50c5a1902c07331606a7d2bd28065cdb84fc4e270edd983c80fc8735766e4ecd4085c74131150f3d77e684c2b52a79dd2144ec5bb2dbb60c4ec1fc61cb469c98c9a7ea66d53e4fe53841e79d8b60a6aed5498f15e9aea9245f0e460bc8c62b072a8e1695261b8ad80df29a67ba1d39c606fef6d4396ba4afbdf1087356b5f66d3e39f1f258fbc5cda2210a062a5dc915d4615ee266b19d625897cd9e9e0399ffa9ef18f282f43f07fc56f20418ff22ec5c8dd8c97962be6a2c8db123f2f4da2a3ef55d44e60d8e76eece5ad3df8bad9a81b54488f68fff9b433789ba3ac0879210b8e91b074e2eac514ca9f2315813c2fdc5bda966637d38733cde67e0677fec4680d09c37fc185b7dec21f719c43be37018a7f17bc93797d72b834387dd44db43d41fc9994c5b57bbfb987fede720530a5fcd1d585241bc4a02f36fb40a5071c94217039eec5d5a28b7b375ee84cf0a0946b0283c35903cbaba5597ccff2bd529475bef90242ad5af496a7611a4bf1ed334abfde9cff509d4c2bdca16df9ecd84979d66ffb8a3318990208403a77437a0cd704f748ee1134b1198b2c7e8214fe3ef259db2c140b7c1d59b0ce543106063a2d8986158ba88a7e1b11ac0f45a0ea43c5a344a86b820a337bbd4ececf71fae091c686e33d38efa985a21829a07b0d03e75e785cd06889590a5656d90e06922800985bd7b2790ed59ed067648ea806e04a1b5c2215fdfc0635b52ee4c8c9fbe2696245e6c6a3f933ae708e8fdd12ef0f8722e187c2fb475f0336257acda34876f1ee6b2c5d32b6e18b8c3af43f7f17701bf07454ff49d9527cea17a5c73d0b2e7133c5bb3b4afe14a34ebaf29cd79ed2b0a1eb14a5a5d47e4d32a091f7d897020b5a9984daa4be58a2e3dc4476d3ff6d66ccee0b827cd78cc8941d8b4ad29f6786bc0343080066cbb13d000ccddeb213b8e0d478b2dce4813f39231c5ee711db496c0c41ac51e3dade93661012b720db60cb4b6182c8c204f1d3279f6d3aeeb7b3308b0e839020ec204f3be9354780492672b3006cd1b4a8691c84247b6799dda4046f74f77ab55ee3ab44583ea9a51a775fd1438b82cd6cfbf6b539d8b4ff802098fce774edd12382149e6a6c54ab731504a42b7fce2d0583dbd0eb7ed5a2cf97948fc8d5e01f7ff2d54905c9070d228d6b0593f7d079977b3dbba370271b36dcc7f1f693612847a180b75119654328495ae8078a13872b89dbf385d36ad503c7c893a902ce338285f85118369aea0fd8a73bc3b2edac9c1d5beb0eee0683f0bb2c668604e1f7579d6cd51dae7ff5fd63b9a1d856ff224c6aa947c993715c552d0bb79a5eb98c2fcf1ab1e83e1e14edd44fe2de91c8528abb90bad38e0d21493f0304e9bf7c1a6db8d95e826d5d257a69bac29d696a3f4b9f5030d1c204a96ee1e831878fb93f1ebc7da2299ec102f25adccf4a379a266701d05754b4c0cbf9eef3867d36c9de955c669bbc68bdffe48b680b8cf850d02ba3447b99fa7ecc54892f5f5770f3d6c40f480e4366871fbcbb5e66789f59bf3de3fccdd138464c2a60a9664dfd0bae3c453e58f0d51b754b8a66f0a344e2592a419f2ae2a59d8bcd1332515e708f8da0b4b67a4bc9ec70c60a185ecb1b78730790607649e427d2cfcfbdf01f55f99b572af9aa4afe807bdedff6e733b88c12753e59eef7f0e19e52b995d90e2f3f2e585c5c37ef74d6f1dbe9d00fbfb8591ea415c3ca94e23af77fd3408fae7129ff0727432b004c4da6a3ed1b9dc7b1d13880bc83a3e9c85fba15b33314fac0560a5db2b1ebbad8783bc14af8e60a13a2ffcb62adf9fb3e357cb0834ff67d00ccaec9e300f78ff416a16d63962351ef253f911925fb44a9364338be6e11d393d8b740d67708c0364e43dd6259ac91817ff237780acdd03ec9433694620343b144ca23f60ead0e0aa6cabda8f2d3daaf176e42d5eada32c38106f882997b051c1383357695ec227c89db94c253039dc90de02f10cde7232a7a2f821b8b7d19af04d4d131a05a9f9724c0302f07bf26a86dbb3719dee79239095ec6ebf5b132a595b2f56ef5cca133d9a1b5a18bdc15c574b15f8535e8e5a328527887f329b6e647d22d50fb5c51f687edd006d8aaf63ec77bb73975c6ccc10ad97c8455a5fd576721b19e49dd594d57abdd15baa822cda45e9f8378839c814e11475a3375960ff17eb24d5d1c5ddadde98d85093039a2d47a96b660eeecb6460e4b936bde781f181f61ef6d36bbe29532b92cf05bc2b778e0b89e429126b37e655be04ebdc946ad510e36bff7fee53e8b6f03f538f35b160d6314cdacb0716720c501373371ad59dd1a25aab8e84b1c3a6dd9fa7d1f9a8c181354276e38bcaffdf6a673f58e38e5fb2bd5361937936fe82fa785d5b7aa3b592cb2fc96a58f1a317647abdcb48ec16dc58fadb7aa4796ce106b6383de326bc24ee371807f39e0dd884f32a7c2998ab4aa91990b181c11570508c7347df34208e88f4b4ba0b133bafa347e4714a8f8cc829a950f0e7c3c731c92f512dc0a4e2ad1f6d63d54c1208cda45d214bbe32eb1e8b773b1b83a964ebf1a56c3457da45a0a5c4917b5b10fe363251a295fea2b2686cb05287fa531535105424ce0a1ec8e6cc62bff4f796cb3fafbb06da3e24a2390055670edae6f605e8ad51311d7da2fe0594ff248a23016902f6f472955297786f3842a9a9845da5db8aa53b1ba8c789b8c88d85538a87fd9068a63e2975bb1e3392e7094e1fc5f8c73f8dd16b71033c3025e9c810188469046d784bdc23a30e9532353bcca0bfc56119d4568f24cf5dc3b6dedeaee1fe7066a6a01dbb3a9c2eb3f8037f3fe54ac86a2966f1742f0e72b5c4048c62ec8aeb8ce37d1eeb38fdda7189d7d2a28f361a7c0886d9f587add67303d88192ac486bc1347ee62b1426dfab7650d25de88642db6414771956abc040102c279da359f350e8241b7e2e9e0d4fbc3e3964aa24414b19af00ddf5b3474b2d7bb6b05b4b6d7483b8a07dd3612e93a0a7de72f2e887b32f2d68d17f3334cb1acf4836a5cbd6143b0f7a1025abf33644dddab261ed77f2fec8e89be7c1c73e05a235d4e252ca956dad99c3579904bb7a1c73fdaedc801cae4db55e8064bac1bf8517c1d7386b20e103a6fd4ccc5dce106b21b4ac324325eb4a2ea8ad179b9d55896b16d5b2a95872db451f8ab35ec80b14f394476c5825a35d328c25fd3ff96cd89a263c88155dc32a876f8b9837f4fabba3a986856d06f05e2ccb134f6b1741e54e1b06baf2ec89d7a1e554294d86e8a03e65e0d076596d38dc30d95603df61d7decf082ec44bf8546eec276838e790cfddf05084ff59b48a825ea0ca6acebeb5bf362430c61252b804c273023174b7c84218ef7f2a2b4c9d791626f21545999c41fc9916df86bf48a5776cc4abeb3c73194474d436eb12bca55e7b95d2a0b765ec1f4ab53b76b97b5e9aeb509e78de088f8545070b05cdd91a38ee58600d0cb8ac95d5998702ee8ffe46896e1be74de4a9d2626323899862297d3eb7bb75ac6fbd7ad46cab4031c694357b792353a238dffc389174d431ef5b789f88bed4c52401c1e2d68d076a9a8f3d4c289ab44f7b5d888443b9d85e820c2212504a034641c6f329e56dc0f3822128b44d399a32a4723f587bfba58d1bde0252368e28b6fdd9616f15c391fc8b607c59404c8ae0cd211df3f99ba7ccbb9ee864439ade39caf2e98979aa37bc0696fd8e69a9d6f2d63f71da2cce6089c96eed333c0ca226ab85541d4f528dd97a4a30641e0f77f5746dbad49403d4698458e31a1e8d99a5ea181d1da6046fa8553e7e9e44042ba93c19e646f1955914fc0085560dbfade0db6d8f865feecdc7b532b24d3669b88b0d6235e1a044f7bdf97245c1d8d7d5eadd71dc147a08426760df4f203e6a63ad45a470a5d5729d0545e4f8a3c78845eb5a58084a7e04321d1beaf9f5d3964bc5c5c0f8af2732380abea163f7086846c3d66503b4712fcd688efd341f62f83e2e9f85fae65cfdb8a1742daf53acc3ebb1c7077066b0e50996e97b0902dbd17308178aaaad6ff9d20126d1af465319e05b3694be352ed82387bcfb37aa32ed8cdbfa4975afc6e754379b6a5e599fbf33952f59b393367045d6f2729781dd5e0418e76aa3597397f939a3db1f0e787f1e77e85e8d16b144e34dc11c35f0dca24aa516aac23ace2c7333fb5a8c1a3bf3c7bf48def7bc062b8079f6ba9b063ecba85d1e1945801b2ba1aef9ca58a356ea15c0992351ab70fa853679a57a4276542c55412d3e4a8abc7031555b2de181a3ad956dc823b477b674b5da6347d2f7caed6931bdd2762967cda21e476e6ffe388865d183cdb714e22270762956338fc0c358ff1573683bb9707ed9327c585512b07e2993c272c35c74ab4719490a129aab188a46970b2eb02f55c1d04e9c1c43218ff7a34e0dcd75d5a482a450676c7b148fa55f0ec0298ce06d34c4ce43f1ad466fb95b49537f263ce31daef460e14163cf1a9f9bbebb1d3bf2a6ba96784c5f1feeb88d042914998f72d5852ae3b7e93153dbfae3e1de3f7ba806ba2dcabc3037a1d832b6fc83ecdba4bff9c4c15c011f1d9984b33e705e32745f36d1837e4d6b1bd22d022e9094d52b8f99401e27207423bc3d026beb18e977cbd01dd8ae68bf2f91c5c9f42dea8852725f042e1735b5ffd39a6c29d0d448e943067c74cc4cbf5899d3b40091009d0328f2108aaf73277cea138d3b1c2bc923777123359e00e780290944d9ac86a40743c4dff64ac0962bf40c2a01b1c2070fb2c4fa3612bf56dcc0ad0c046403d9d77b898d5b25899096f3bd0163a3f013eef91c518bd186f520ba242d8a25c6ee8d19516d4a7a602ab5973f82d69e9580f17087d9d832c5cffe9958066a3a048cb0f70a1740ad349d499982c49863b1fde828a3a754a2628ce012f12a0ad9bb6b07ae859e3e9aa9a274b84c58e9b68520c4a0d93b8a1250fa8556f09bebee1af7b64c0c47d34b53f9e39c9f9e146b7d0a80482711a26b9b1298b2c70adb4f5d3c82d3f43b8533ebc6d6957ee3d375c64beb6cf8e6726aa8f6d30da0681a3434aa2125868f3ab7fe826dfe6a9070fc78e7360eb6ded1c551b5b2a1f0177853923e45f725f9cd255a9c0ad60bd0bc2eead0c5ee27293b7b27db29a1fa91777168847bb2395d87eeefeee6e34ce9380f144ddbdccfa8d6067f5a4f2f1ae31a5f7650e5900e314625ba257c9394c801fa23bb4cdf496f4ef85be6f13b426ae07fbbb8cde8eea576a0a0514df7e39c847f13ee60d4bd0c72400a50822af81f29022d07ed5213d8a29d09689cb961d8fcc9efe5dfdd5f9ba0a944c1cfba4da04946fc8b0b364a6fdd3d1ef4dd9d420578dff4b90c67dbc1001b8e046b81cf2caf8c419b49362c04ddc07197247511c901a3453aae68226cb01b1356c12003b7d14ed312c5e99965609dd5dd09653ffd41a8fb321f6152d380c5e45ad04142653e7e2729f7cd9d01bc9b56da1ae98a37efd7cc346dd86cd23a36e8f8bd05b0177f38ec37844e4beb49713bd0734c3bf1704e9fac1184dbf269999eb85c5ef76c5c7b0474e4e836d972cf1ef15e422a1478b0a0225a5c7cbe07291e75b6ebe787d541386d443e3a5365a148450a9c53eb9c7cca788c954f9f1d854c4c1c824df3a8dcd0d97776ba78aea7ac1cf629eecdd5c47a2c5a6c7bf4193697ec4e62601d845831f0b0d18b15c47113469ad0753b53a46920c5748b550662ef50fe23462c9141c0405031b8ecbe1246e3c96c018cfc8bce371fcfe0bf1b05f688fd94d81da5419adb99f0fd1bdf48e669c8ac2b7763875b51e193b095d6f119d3dc081f65c4b229fa57da578cc2fe9df48036056c8706f2b6a6e5cc4382372441082640976410e08a08050218c892fbcb2c8fcc48e4ffccd558eba32d47b949616231bd45fd0a41d9259994074d84bbcd556b80fdbdc56fb7743be7c9ddfb8f91a2d1cf6747022a8b3694b890e0568c94ec4448e53caa4a8beabaacad44340491f951484d65d661e1399ef917fd8fb0a678f08ede98142957f7ce3c1bb10663af21c33af8ceec0478422c76c63aeb2df0eede823469f1276e8d72288baaa642c8bad8f361c0599aae087e26b8f773db5d7663bfda4266b330bfd7777aa4ac7373e12fccd14b7a54000d6284edce8caf0be83b8289dccf1d587f2c1ed01ae61f3175e5d71cf5f2a04e70fb07f167e19202af1b77ded042d24eb96f2c1922b305da6ae5d27f2261c1bcec720c39e3fb21b90256a0b6c35d33fb2bd5af704650941e0feac77045011e86588d71fc36ca18284f1dc55467fa6611ba009fdf908a8cc373a03fa7c255033baedc28aa855af62759764c5de667e1a07ef09feeff13ef2f7c762e06a249e1de5d9ab89608b40689dd31f9abfcaf84dfb5d903a788232c9461870cf58cedecc7d70042156a27933000b3b31be007435c854cc75f2abee68fd3d032c3998622a656b874e8e8bf4b9c417a16a655cdce8a23a6dcd8d3bdad951beb5440fee8927e831951a391198f7f228635ae0e5cc891e25e5059fb5a8b29d6e196eb8d3fb89ae43394ad910641c473e1a021b8bc6c1b81304b2eec8799d2e7b8185b914cda428e342dc2eb030e2859962cb256472a5add18d50a4ec370dc1de3737d7643105595174a5cf3aa835dddb0e0a1cf0bb450f57e8c6ee6ca3946a827141b58a0d1288d0cdc459510b09c1086764d5b49e35cfea0997d03fc70591b710284ec99840df998e5155d893defb188b2c726d1221007a1fa45fbd48d6644b4546d486395d653e07742869a93bbcba37557b9a781ed89da93e3fb6093cb3ee31b80b0916098298d9ada719b9a27fd0e55448ca556c271ff0d31eb379d9af607925f02f0664847b450772fb464209a846594074669025bbfd273b3192ea54b6b1365e0e109077b910c4eee70f194db2112e6ec2a4f710283173081f3c36cce0d733381e33f64c172d533d743730c78b064076b2ac1db9b5e7f03c097785f470872ef2640c1cc9507da9bc721a2088780c8a3aa2f8c06fed10977994cfa46d0b1b226d40716e366265cb7f8db1bb4dd9e9fc2896569a25bf050b0654cca8cd00e813b890ca08631fa3a181cb17b870567131a5c9e3fe887ef881d9f32a2e5797420eb531e71bab3de6871be5da898e588ebeeb480f586618c64fb0f035c376eda023b5b799c73ff785010dd71d919e59889d871532c98bd72c75b02e871e479c0bf9bc07fbd2eeca640b7ac0d7053948d0a99454cea32e8b30f145ae494c5e02d749bb8e3d06cede4e3b3cb06b5020506aae4c89282e84bfd9c561857ccf43fc502c52092bdd67b765d73fd4ebb3b55d663c3f62aa5abdbfaa0a8ed1a06ce1d182712e7ec154f432485b7f345a9f5fcdbafce0e45db60b10665b0ffa095cbff95cc2751fa2ba90128c59582fea99932904e29adcab6a1716ad9054ef4b9974ebbc68020490142dee3be43a188abdbc9e7d215d57cf3034121d02a431612a6bc80dd79933552b2845b5fdfc209963165e05047616f2b952b81bf74322835c984e5192c5302ed5e95a2939ac9b04ba370609a81e521651ae099d2e428c9089f661366da47e8c91bc8e65fd0278d1c6662ac5422b4bdfcba0917101188808fc0d3e52e31a69a88ab3bcd84b428e05d2ddb3c66dec94fc0b29123c9bd217a103ece8017b877875fd419a32fe70fa93e9a5368398c95abc11c1f9c7f078ac64d8c28671fe7cc2401e8591b955fb8b786c80b8fa77872d7a93f961690788203c06c9dc36f3c30a93792c57ce3638d36807bc450fb3d29ca5a865edb9b3cdc670daf0421123b81040a8cc6de67cf054ba049dd25d857800717f0e4c17acbe6733d8e68298b21206fdd212a23a1051a6b83ab09e4ed7589b2bb2d48850b7fb55e1408b772075b3779d11ea3309c83c7cb74f812797e95ceef1df4b7f54e51f44ae89076cd9ba337a30ab196b9409f0f3808831fc3bab2d707492ef2512a45bf97f0458241f83caa7a407653047fae99fafad1556463c21602a274897983a6c39b8b32445970328ddb93f10a5d1b411c37fdc39e3659ee0e784bc077facfc916f4c9a269b63c35e0bcf630a00861e7b732c683adf83c16cc445078a98d1eb91ef6acd7bc6c30600909c14e702ac47119394ab2ad71d1c3ffd94033b04e75c3e55ca1aa75fb18e3491321c67866ad29f6f2573e2637aa3857d3ce833ad71103181c5a6e421a4e1ded842eababd7cf94aa07655ff81bd44b9a81c18e3e17d335dbd4136b9808325ebfddecfccb1c71d98209c33c6ac26b636081054995f9eda464fa723b086374ca2f9381877256653003ea7d8585ce623b52c277ddde0b3f4c5fc9009b1ea7c75b571c315a87fd6d0fba2fabd05aabcee3a4f32690c6f1f55353b5532283de30b730c1d9a8051d16ab6d50d6fd5aed761569a97678181461bec57598caff15cc8a363cc0653b1c34378c3a0f2835e7a981a7018eea1c20cb73a6c436a303100ebdf465deb5509cc67cabe5f019d9f50ce1b393d47999da0c58ad9c9526dad7524a4a07e700dd779a8580d971a5af6441c5102df6116c138f5328c6bd05c03a28665fd37b50b22dab611185360ffc4469bdde97e8945135c0bf73da7b3b4fdc3f3916634cd40fb80915a8a2136fa9fb460c02a3227b8bec6e7db4bf287402fe29c87ac243a9fdcc0aa638a09df778db55c66394452c94653c3ca536a3ee3941efe1277806f79423f7b39c42263f71d78e417dddb6e326919e61cdeb8746b568643dfe682e46ba594a57a82f8865c1b7c83f519b6db7dafdfd94b27aebeac549628ba19f1f55a271aca0549ab091c789ef74c659d14d539938cb5e27568bd0823a2103c94498373bdfee18deb4d91833c9081fc51ffe26d676346d267ce9e63293084e397227e53b3371749d18f2f087a01a877cc966c040e18922d875ceabb4799b61b7e5c6e711cdabf0be0bcd4dabb623d3576c19c14be6fd36849acb8294798ec6bea6fe4cfc8460cc646755ca7adf2adaf7f8b4d2edd26742fcea0cb14b73981da64f91373c5905d26a02c585ef2c81991fb5d8513fc703caf982566b013a27ff3f6779707e2d57572eebd84ffacb0a0deeb84bde2eb4bb62e89911b889c2c95a18237add0be4958db16f6cea762de9f0239af2914c7b81b37dabd7b2c8a01034b0faeec8bc6f2f868fe58aa569cc31632f1037a62bc2931f9f80e34441bf0dca44f02a194a7d2443f625a3bcedf15fd69842c0fc22fc16665234d9599f64865081e53962fe39acffe2da4ef53b09897054d37bbc115fd34e666b0d9089d3715eacbf6e263f26f82ca7c84cc41085127001eb26d319195c26280b4ee61fd5e3a315922965e4b16349e6abee6d122672bc44b23a79a1b004ecb453f0d0b2d9a9424bca69ce92741b2dec37a913c1ad2d44b59bb13a1aac56089e874a959f96ba8c0c9f58ff8a8bca2cfad09cff2c5d801d69e0590d3f69627e8f6656e0b8b1a64be69296f18103e64881b5d32d4dec54c7aea037ac3888997e711d2192849e7a27d35660dcbf6b787477ceac7019212abdf0df1bc150441c1641ff712f06c3e9a5c6a9f75ef8744f4289b25c3c859b5565a303e534bda5dd5dde950f35a23380603b1807db833c0062b6563412bf412509e5485eba61fb6ee706b65a04ce50d3a9dfb9734815f90a289f16909207627f12bbd487113e6174424e962d76c939d279e78ec62b306d44229aca46f12cf3dce5926316a92198a50be88671fc763edce20b2310c39a62b68ba523ddb231382f8ff0de7291b0a0fc0c003e9f8fddfbc28cda6ad67845810bbbcb766be2e54f981f671672d73a910b1b6352f50e52d8fd25d6c61a2d88244638630c93813dc62ce98406d271419bec1a55e293f6ceb1eca6549d733acd65129cd39203af6c71538553bafb21e3877e5797aa3059c6fb90d1a82b741165f6e1d40d6064535c72c12ff6aeda6413844f022d109b9e67d038d76f8796ead21563db355f1b0818d0f2389f871d3c0ed8d4d3bb39621c40a0cd4f6530f2e017c1cf935cb9021e4e6631feb0eab3602fb0127baa7858b7f7ca25baec45756d84d736ab3224c2c2e97bd5b016e84ee95a9c7bd2903aca2fc575d0caeb6a6d4e5070f2a9dfb397da41e0e62f2faf7a058d9480f5c1bd7a894c1711024e5e778c924028cc8321073b076fa68970f56291df977e808413d96cf6a82dbc3ef4c9148159325ae93b87c1d1a4af85bfc75f5fcdf5e7fc562e5bcbf7cf3a612937b140ccadd3643351f7d338fa736002f6b4c390432141c4525d920726435482501c143a0e2443e0157575cb6f8ba20a8d555b135614c862c9f7a2804d8097165ea824c63d2e92f59f490033487039823a9316bf085103f98cff2622f7aa10480ee4626fa2a61f81b63fd86eeb059f57e0236b23576c07901db89923e2c715bc37f64163d602a1cca5f218d669c30e50f73f86746f6c19b7c5ff9ccc1a29354054c546e453e8a790b175ca5d0c7b987608b1c6f68f7ae2c4d9223095f42a2d6544bcadee6e82345ac027970265a575f41835e81b2e63d12c22e879044b167475208f5974577b02d8ca26993a7d9291de73e962b3a770ceb0583483d3636b12ab65722e47b5c6a3b41a85c9e1abcff17b153869465a793932fe5047cc58bcfed5dfce14852a56f2d615ad96049acdcdfd211af6be744d146e49b6dde1cf6f88100b4531f035c6c2a903d7a9a06ccc441437617e006ee0e7b946f7dd0eeef4ddd16e3ed9c4cf7798dfd44cb773dcc203fa5f34ecbcce58087f6f3098667e9826cb6d6bb4d93c4e144dc15ea0013287eb0e0318bf1c095e9f6ad6fce8f53d31ac0c5657618af33af4ffc26d8f09bb584300958e00c2ae0f25aaa487050fc98628a0e6aa4d33477fe534c94e874c56c900d900f20c09f7b38f1027d4120038ea9de43e6534ab3225103e38ac5ed3396831c640ef75158af6ae6cff033d2f8b852dd3edae96637286ef65d7cea474e8c2a2918835d4bfae8a2af2e6045abb423a12182e14a71d60ea547e34415f50dc852db0bce06bdbbb2b6f45e5362c96077062b13f98","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
