<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0697e91e7e4d8d3cb3c7239f652898fc8ccc9960de72ba4adf60f4b85d80830d282bc9c7d8d44ce69838f8065bb4d53df02a5a5d60e7fcb21bdaca8fe95fd93330bd39dc3f33451e76974f4bc52fab09b8dc1a5c24ea768a06724a04bb7519b239a1b1dd8e4af9441e9b66cbe91163c17524796c5c04a12355b823a8fcdfacf02bc889f6a537b5542985e3136b03e6cc1882d0c8727dede49bac2f0b2a5b164ef269426c896397bd112a94e8eb57d9108abf1757e9f8e5bd18f0083acbaa1d34f14ce7d691b10991782c3500f866907cb62ed68d00254fa108676d2d81dc9ab3cd6163fd923b79d40b03f1e8409723927a058b882f1949b315b3f231407cb873d1af7740003916538b69664e168fd866e41ca34fbfe45c4da7415038493a9d41d1251af2d711fa2a55d3ca68453de720cf66d9b8f7594f35d0cc23a0b94c621fe2503e9db5ee2126fb2811413410a5055b985ccc47f67fab13f5aa8e96aa1f7ccfec6b54056926cd10a0387af5c60074667e58515150e909fb626e4aba5ae3782364175f8cf1df79048768d203e5de9c045eba7c12043e06a075b6b6ddf967cf295cc7fd56ea6edc5857a579f36be8cf7fdd7574f269a5c791ebfe890265ab2ea394bdaa973d13dc2625e04005b91d8cf7c30989e33a151b7b84debf20663ebeb0922b3df4172a4c245a28f8f8714022f07ae060c708e364d080b9f486261b628b07fcefc3033f6363370d15d59ec0bd039de9a18624863799f13b1ab7d76596459682ee56c45de6a17fa5360231bfe1e2a468fa80f72eeca9e0b8fcc4b2a16f44d2f5c3741a8220d5a2abe926b0a22dc5f7ab91c28d5d684214e4c1eaa33a9243bb101018e5e5e4011d676e8b50169e7d44e2a7d7915257fd4a5056d5d4d13aa8de46d87b3d776f42fc221af5fc1c5869ea7a21da4d311af5ba25165589925ee6c4a45072b19c93769c47e3b44b9285836e582422720ed5c405e9aa03ed178a1603ebd81c871be6a5a1dade8ddaa9ee040481978e8c4ccd51e40d3160c3137645c856cdbb29a1bb48e7000d6628961ca0cdf7aa21112bc34e1127537b1cef1aa95602f525ec5b5dea9f45e52106be8096a47cadaa4c532a2de71e44e9b559b7785b0572978416b36e12b2a23ac39e5486a77a6d53ad4836af5d8e0fb0cf98a382bce33fafa493e0891e71b8721dd220c823cd0c19fbb4aa2b719eaedd6619703094a5626e45616b77774a41f8f3027abf6a38957e4c8e1296d6702b613f4f486831c3fa615a42bd4e3c1c6b74e09462c0beaa049ff3e70a084d7fd2676bd0534cf0b0018fe7281cad637f2297d26a735046db6e4849b7c63579e8a25d52a4b8a7da69b20aa5668f25213a05e99362ecf234ac02b03d3674e7d7b9937bded45fd9495e26ce58bd1d956f95ef12007d35d14060efab221aaf4f122e3a921cfb305adcca4b43fc814895e358fc9729025634ff7668a99db80996c88a124d9ed887991af6924d49a39966fe61311d3a89df6e5e8a403a8e5e67a705da46f3860ca62a8f306c353f9663bfbb58c8a61d36a768f10b2bf57acc3a3ea44238ff9f683fc9f6dacfbe450982a33ed1112d56c0b4340e3366382ba293d970d0d5212af17a657508f6f8514e464e2a5f43af197bd7f002d3a2e66588986671a63c2d82cc17c57fa33d82603bb4efd5cf8400ee7dd97c66f5483d9e0fa3b9d2635ae4a41d62f64035a5d2659d3991724d65f3a89267b11a62173fb9d788205ef9623d43dfdb5ea75307f29669721d6aadef9129fc28416d13632c0da371e64226e50e5cae4e94da803fb785ff9f42beac52a58d186de318c6236d2294df39f5a144153a3a5df4a82731c11ac4872a08eca49405060c5f74bac4997955b15f68251f00353c1de132929fb82995145c88a2b24f964f3a44b9658da8c03e4dba4196bf50c4884ab0d72a4fd67951aa6d230759612d286958a826f66f8c9824765c3245f06233759169fc029181c5d7848034b747697c6f1a66b4799ef23a32ad9bda2f36f41eb4c6a06fc2b95488a28070081f9aba8842c2e0cf2231a0a1526f613ba22de8bcde0d45707a8a116d26455aacc27ab6e3d822d89ae53740c8c91b088597e3d6e4b2e1df578d03d7b0aeb8001294eea723e8cc8c2e7dc00ca6d9d7b39f5d869a29f36458fd1a8a367416b997de98b9b941cfc40e0a50668fdc37e9fb2fa959286c424fda70aa47f2165a4c28ff68d1bccf4e8b6acfc6e8b63cd23bd245f34e247d4397ccebb2eb119b73ac301ab428c5d11b9592aa6e851e64c9f44da191af2b14f38e09e11b160359503973c0c5704e388c8d8e036e7e780f2b3ead9e4948dddf860aa862ecdc9a9b6149bdb4624f83e59f32010b55f6264dc2fb503c2f51de5eb3c571bdbda08fe415744ca48f6cf342098a460fdd165c10aa63169862ee40e0c2b460652b7c4e3e10f8eb5eda116fb9fb291f11e643b982acc1d066032edc168501558e592c565506e7cf18962523591ca9c8d8f3f69e61a03119504055a55ff4dfde285cd0c2985bd6656d772b2e70c1bd308632add5c81f5e257e38bc7abb0cbddf0249c0deef166bdb9f28c7a50b1054a5f0ca3d6148d6fa478a871a3d37fdf49e8f202a5ffe2e2fcb596b55d9ea4a75b1df63d2d0a77c804aba203602e3f26a1ddf2073d289fcb27cc9e8cf6474e38d17d5e6a89d47c3eeb176490727d1dce27b2dfd5da803c76ffc8c5922cd0586efc1b00f8ee71ef3a254984ddd555bd3e740b6d0a53121e5553f0363cc10cb7dac85c8c393ae29367685ba9055b0eaedc39b4d1a6172c7f597e0a2cdc76ab930cb6df939c8823cc4605c25c4688602142e3b8539205c90824958a0fc02f6ae936b583377b9e4c743bf29ec6d4c330e96af811a84dabb2c68d8d6e9e3c961f05bd51db364cb66dcab15605b8e7a97ec1e607d630b21942f57295eb103c0e2e99a6d5f5fa68123808e0f9da59783e12f95b774b24c1713ef448e0312b2a09ec1df3ccb3c44bc5f5e7c451ed7738ba434b8bdd3dacf178fa4892414d81c5f87ccbb54f3b303c3bba35005dcd19933287b8bbceb7e8bde6300462420f8a2af3f4c96c7c2ec4d61a05a66bb52df526212793d69854eb94fed7e1c4e5fc7c12b47581cc075943c417901f1298e51aa2ee3270457d767be117be1e0cf9e1cc37bb7b1be5ff57cf687f8b09bdda90f02dbbc09edb78bc0491be503937be66350e4761d18f6abc0a1ac87cb3503e53db5079ae75e34b1f7ab50b0ca3b359f31501be07966c4b723d3fd1863e7c55521852013b3f947224e7ea054ae577ba7cdf2c6d8199cb5df02e55d65f95e21ed067baa6f944798a84f7e3272034ca1bceee5dbfde5af4cb13edd555df158446cce6cc842923da3459b3c31dc0ca0c6b9a06cd4a19311a319f12218b8755a89a1ca48f89db9da58cb43922d6b96d2f095c3e7df89d63dd683ad89df2ecf643d68f97a43aed7f45150161d2e5cb2a9ada004cf73795926126163dd7362ebdc08d5ae952d48c66d92f98fa17757f006c10e062b050f86b54b214e68851ed6f04e731a661ed39495d040cc8d3d125ef3e2f896a33122f8ac39e3c71b53e27cfb61af849f2451e1d22b6485ad5ed76dd40296fb069d73929485255957e1dd45e299b1893e2f19a56ec21099d9b372fbdce70e07ec8fecc464e8aadde3e5ad1f39161daf2f1c1ad5e670536ab6520adef47694135082429cccb46523d9b9f4411f4c7a310140a19eeacd5517e43e2c878dc42c5d865e2e925fa6317a7a7711c139fbd0b9bc5c6e6ae934c73021ca4b633fb53140e99c7c7f749a4f19fb1aae59e9b85f35358c79d42633f25dce32041ee7390294fedf6bdcb3210530f39bf74726625d2d0b094659bcf538a215cd9c9f9a2de6318562a56f00174bcd5b69f4fcc9faca38c4798a35dce0bf725be5ebbcdfa61424ba4840abdbc4aa56f501f8c33a417451538c5fc0b7f020b75b8a3342c27d6274fe24d15a85b3d56c6e5deb678a9e4f6617d9ccc2f9fa99d4da7a0ba4f1cd98880a1dd68e9646c4915e46a819ce21c0bc8e8ac744bd57636c4af2234158d32f8d90d9dc19e86ad1ea8e54e97e6ce24f578b2d8bfd54230e2e1425fd2f0c5ddfdae9a65a402abd838b8242f4a6b225eed601bfc33f1cc8ee3c189252d15fd58d18fdc7735e4eb4f630c00e951c9537b7bd35beae767faaba0ca7c0ef4b2018d2a34ed799fe3eda320c81e172ef118925f33d5275f8b2c60d3ab52f9773d483b3d45b4d37a45f3e7ec0d53960e25bebb5f72a2453e5ec72d7f04383490f47921cff28425c741f523ac88feeb0b082ae7ac0cd7841321c40d305d8af483506623a6e96947ecbde0d5363b2ab71685d6ef339572644d3cbe47f51f0a081045c21596374936348ec6b2a2c776754eca4c0fbfdda9a73d67aa0c96c3a33e3cf32344a0ef4579a1a2abd33d5b94ddd55aa4dd32a6e4ed14773a4ae5a97c12bd00e7c1456f22624d7e0cee68cce37e4ae4914941a90b3951b11ca703db5e23b56a8e4b837cb77c48ae4abb0453eaf34220625620ac90239c5c3964491b6fa928c12fec9135f223af67c26e220ed5296bfae0973b04b89ae49440a8284e05dff23a85c66681d2a0d56d48fda80c55be450ab1aecec814a8ec30c5cc8d2a86012549188f0cc2f901e735b8468358ec5716d5e5793924db22230ff27ed91a8917c776a02985df3b4ca53d85b42e7e12455061d019900206297988f8060bd91bc8228de0789aa1b5295d532c066a0f59c5db81bebedaf1f972b8d4a30e7b029c457d015572275b8cbce29c2a317176466cb263530c5461ccd440628a155e876bb52b28de0373a969de2909151ccb2329d9c24d6e25e779717c286def1c6d258444f6bddbb4b92dab14a144f6de944cd0c47d32b8c89784fd34294313993c25f87907377cfb15f5dfc301c83820b5e25e1a82d889cadeb55c24cc7ffc5da2ae9c7f092edf323e878a1df4e889de225fce82568f3c02d7ce686d633e5e107204f5ce5de786776f524bdd6476c886ac535f8ff840d41447beb0ebd39735a58a4c79c98e00350cb64ed72b91fd51c133daae1515bdf23e5505b298299af5511718a3982830fc05487bed832b2c101fdb1ad7ea29c7f75fdf6342341d932d970caffd5b4e792e0b50fc1f9a89cb4ea02a1f536ede727674f0295121bb26daec5efde0bb927790a19acfca3a7c5f2e1d796f17bc1db02c83ad08c1edeb21e8fb720d4dde0d65701cda7c2cdbfbbf0b551a09cdabd00889ace2b324b1a5ab8306e6fb31ab22eeb258cb0dbe69d4bff7425c83e80f02a7b854ee0bafe9e890484cdae279b094582b17f840c055b2160bbf20b4aa619f1ff34aa9f9705295104aa5352acdde6ad14c04e0c315abdd4bc1fbaffda38e4c76bd49e030dfc9175b01e0f818f6fc90f3471c1f14eb9331d044de254e43a1c9ba30b4ed3a58d772405cf807a2d454645afd1bf115ac1236e69ec81a7dafba129f5d13d97904310d4b35c3f6284892de9989a7eb10ead4a1435e31ef35f993bde02a49c4f8dd8346379a6f542154700804131dc827ef0b7f849b838a1fbda2d658b38cf433c8cf991253d499ebb77a1dc6dfbeaf22e70d9cd2310958670c7199bf5c366b335f729f8b4be336f3a8f9f9529e709a2c78818592458042dbc4ce939e84e1c91b0bed08182b3b78e47cb6cec8d135f8d5a1c02da59053aa78bf317d684de4e739b18476683781d3b4bd29ee4e0d381962787f16244a41f4fa775a4c2034942b9acd7a91b98181e111eb9e2626ab4b8db6c36644a0e2374abc681e83a061c5ab3ef4b0b113b08c56be048b2a8b419040be83eb612ea168b5dd7587939c98bb1f964ba4f7523c6d4ff217fae83b5623b1cb91b38a6673be333a08e6070ad6d72e3d1507c5b18a62a1d74a85628e3ea7626a74d3d60159a7b33462eacdb476eb06f5ed59a9c8f795599439e022c26abaf695279caed11a0469a36daa9bf694229afddc300e69a796158f9e0b7bf14ac3d8b77021949f96e80695c9010cbe3cb98ea477399445cb8fdb986fb7296d0bf5eab59e6b5ac37d6c83298f975d67feaffec89e4285b2c9239e101a2db9a6fe173dc4f035242eb4d263c7bfbb24ede6de8bf9df58b3df6c4af3c434f3496166cb7b142ae9d32beffaf5b18c9d86d7d2007e0bac68326db7f3cc50df7f0efd9e85b2e1eee0d42794e0b198ea1453cf01855ee6f319fb9100d0134aaef8a4857676de5aafabf8009677cb6cd93c0f61c49559f615e3aaaafbe9d2531db7f042a32fb09289e2b2f11aeba1d7dee2ba3c67ebd1c764113507278f7e6849829af978dcfae24771e67b0635808c0ab7effdca90accd1b347868866cfc4c1f85f4f083c2f063458e78b1c45112dfafafd4dedf93dc5f0dc3ed1d5e1b61c75c3cb0b3202232e54581bae97023b6a9d4564d5633efba103032ee5d7d8b06f3226d5e995809cb8ea408f0996dc1a4dbe3692863d84fd772187a5f67d27da327f70e23311d4046a0d3f192e62d8361ad799a53237c624742186dd648749a3ebe274678db389fe45929bb92db5e9a3f5a88faf9644785d13fdd7eb98e83caeaf3191f92048b61bb7eb4e3b5d98211daf578d4e363186c2cd1d35dd72094a4d036f3ec86ea1c3e1d74b2502b54ee3dd5eeb2bd42c3de70159f0d21f291febed05c6997f50ea785ecd926ec2a412e7fb8f2bdfa0d622c567cf31c57af709f76644a7acebf4dab395a48f42992bce1eaec5776340c23b3b45434a555c08c9754fa055d4a589cc6a2aa002b0e934d52950528f0e54f2356b43837d202da06622205e8a262cb0d8f4cc4ff1a97a305807a124f9b484ad2a616feade955555635eaf4050f1351e796a59d2500c541bcd609de790cfe36fae8442ee1de41dcfc4837b787acefb3fc7f9e338a50c1822801bc6d65b44f9ae28c7d6d04d2447fcc3471f859750f998a78a4662f4a0738b4a63d78b6ea9fb9792ca51fa3bee96df1eed0f7bd91887c2bbcb5f311605eb23daa6a4d65917fff10bbd76a7a06bb8c373ea10527eb9dcfb1d0f73db2a6327b8999a3398c50d313a2c92a8ef1f814040c8e018e036d93ca365030577f87bfb2beafa1eee6648382b0dd760fb7ccc12ecb02c883248b903b03760c5523627c4c2a6fe165bd29c84ddb36db093ddbef17be92481895628383cf9414b9d21dadd0b2f6e2e6d0aadc430ebf924736ab02e6cbf7235b1c5730f3c3cc807a4c739b8801507dea81aaf47cf769a2dd8ee8d4da969688817519bf24d9c54be8cf574ba0079a03ed434d593e87266040454f9cce4b82bb4d1007fbef50f3f23b88e675c933c05323509e4cd303ff107d5ebc3fc3aa3081ae0f4964b37599eb9098c195fb4f22d662e8796d36a58ffa25b418bff0db4c5bb290c6e8c12612f7d686971f6065d2a1cb4ae1898e0161802f1132d6033c716efe1601e8f7dc87616d37b0c7466091781c4342b328c65a8ed286d8f456490dbd5121acedcb3cc1be29bbbe034a13f23a709275f351c5113afdd289129858b06ab7fbc309dd1c8cbdf6ce4e18d9e9fe95c45dbbfc007d9c0d04e543c8e012cfb2259a87817d086c3b651b16b4af6b71e3126dac28a4359ad6a71605a2f1d13e97a8f692a988f9dd2565ce7cc2f854bd069cf420c67ee52395f1090c66981a4e29e633b0b30cdaf5a60dc3e4e9194f69a971ba556ae105ab56a59b80e0eaee706ae76e93803f0656f474c12f5f844af8e9bd51ccbe96519f8edd9537b0ab1010ae69ee01ce0d5f125e73299768cf095065e1447d5d304a513b592e696790ce5690254782aa23e683566f73c9124bdc2e596fe71053b8f10ac918e840dff676e98a6799210f32f52483871bd5bb054eaed0ac1653a39bc1ce9eb70f7d70bd30030fa4c5174afef8df56ee9288c725ecc33e5c6e4c575b77bb8d011588f9d445ed4a9cf6273c0151e35409bb1ba422e4ca4bb853bd9080f045e887a5a189f0548a7bba96754244d069577ec246a40db421f9c8d575f87348ae4550cfaa051b09fe402f17a0c22f1cfd06a028a60d01d52ea4062fd64fb00f782f9f0b202a7be42bd2f3afadf1ecfca5f8010bd73485359f1768943a54613072a2d0454a0587d01fd2d2c29e63a85931a338e3ec5a7ff8331b1642657b29f9042f07bf1588956b40d4580546b74bdb02065cbbdad69e6c936734ffa396570454e067ec927189fa57a011f20d0416c518cfbe6fb5d21c219f889f9d739bf77e162b7a1d0b9b1dc1de7adcbba68ed9774f8dfdada2d5926c10d95d35be6a22f2d41bd1bdc1d840da8b2899dfc615b7b7bf364d015843c787d317e7f6af2357cdfe5270a625dfd4c6b14e6c5fadd7e665934908ab3e36835ad5815016f4df243303f7dc42d9c05e746327417477b9317c2217e1f27f28291eedf0998ee8e2ad9f253d3ede468dd17af04455f0564731e0aaaffd1e25df0765c26977159c23d342a7a2f654b0ba6546ecd35e9bc11ac30a5d373c497c3b9d03afb997ee6336de51998af1cda75852010e572391382945bb0c7c9a27a4d5efa31de073da5b66ddc1b38727fdf875a3c51bc41f13170bad523d5c6bb8e67bc66d8c23ccdb322071f5b3a533a4c93007700647a39f50ad36d92ec6d45bd6e5628a63cf5855db9635e94de9c75cae16ec7fda9db19328f3c90e8a2ef444b7a2e8eca3b97e0a27831400c8e70a710b694ff8ed329b346c460aea3b5228bd9723d501343de5b2021eaff59d29c5aed33814edf299612b84e0d0c70c0d129972893b2f12d0144689cd942bb1cc3610a3a344a341af5f02581613e9aac2594e9f1904c4dbf7deffb7bdd2389e35b88026273c50bd3957d5aa5b079723707858bcee226ba6c2dafe69b4db593e794eb271eb99e25b55de1f8bc0cb3291db38731dcb72a3e7514689e2dd6efc7aba7d093f6b78d5754f9f4288c1359e7fd236c62dc65be030ad3c92541b6d8a8c56e903426453e6124a4b3a4d8c845aabb1431abcf20f6082aacd01140e1424b92c7d90031d095bec23f28fd3ec3d1eac56561fb3b0a2e922c7c759bff759188d793639de86b56ee9ed84fc3cc16e1b083d84eca29ddbea411462373071877a0190284e2a269a534218e5fa6ab4f17acc39c90cae6061ec775fcdd3fe8b4c142931a64e9c1851a117f01531099214910e46623abc959dc200cbdb32032f4079488f155d06633622a826ff8380daf0ba1a537a9693bd370796a7f3d29c5c758129be75ad66aec96c5e25c292fc152b2ff93ffdf522c864208515353c66f9f8c419c7ca103ce60471e41f4909b9f8346d2f5b7f3860b25dc63727adc0d877127981a9ef0aae6fd4b33b49deb8f1f8f379260f24e47ed497b80c9320a685daa78a0f4492860c927ca8d97b5d028a11acd4d696d56b8ddc36decc203b37b7e39f86886ba297af8dc6e3454f25ced9af906e92ad05164d61bf66ba7485b873385069fd3e8542e7831ad06eaf380cce09587643ed49a1e86a4e958a8652f29305e4c4883ee26e071bc3e51def01696894b709443c2e3071d3e0a1b1cd3ec541a699211ea5194587310ff71aeadb5285a1ce31cddb43b018c403451c9473e2f42a402db474a983229ad1c2d40e2353c30595fe1f0819e99c703692efc571132fb278d77d0187d8c4a1018ca1a76ab4e6216c36a177f18b66b456a52b2c653a3c2734df9e5e8f77ac38fb9fc2cb02cb53789bf17311d2fdc1ea9af51eb8c7ceae4527c53b803eb77bb89036dbc92ce29eccb2b4f24e55901639de95d9d686d424bbe27b00a073a368ea02abab286327ad51aa81418b58531fd080b65ca41fce4582bbcbe6c7e3e775a9fa4c9904a05ff08cbadc4bea322299e10b91117c61a4fc8c40d3fec80698f922979859bb169b1a32d226bcf3226508d943e7e0b54d686ee0a60f21e12a0208f54a14fb54087cfb808c1dafd71840bb992723b24402aa29eebd125f909a0e0ddda65d90b111e0c27e70efcbf616df3ba70f824011d9eafa579ef40ba4463bfcd485a97d54c956bc6bc63d39bd4ccc29100f2e69f94a33210dd8b15153e6ef8ea8a4e15b56ed942ffbb21ed0a1060ba27b83dc263660f31340b85203a154a210e693117b3f3bd38b1c35e5793c59e87c0b75e55eb01bd98577a7d4e0737e21bd6dff82bf5306fdb9fcf0faeac3eaacdcdb2617a87309a4b5768e31bc5d1c697e52ebd69ee9d73b48a662ba7b6d131294a8f93ff0bd6e04982e06e76c083f531697a85acc87b7a3c87573b5d30ea2d48cb0390c5a2806cdade19e87d90f38562b71e5dad412fe86ef9e55168cfd49a03b52a04d80a09d4111a324196e0077d2a71c4ad29fe543dd26f6eb17f89d3fafdb4c2dd83c17f2f86c26ab897f6a7a596921da9899e002590053b7a699a51f33d0839b3651595dff23e7fbd9a7e334935ea1a9a751d246e17d28cbe8b53adbe766ebf287c53d8f4ad0178b0f38eb026c04c919e6ace9a2b0a76bccf5bdb4316994b875e971aa2c7f0f14d94e77b9fc0fe328eda3fe4a7b8ece8cee372c9b5e8ade41ab45c905bcff323140dba9db1934f99c7d2ef7c2022606e76557951ea44a2a84de2931b9e9e61c6d0d0ff7fd056bf5ce9f9c2adde56306197adcf4fb17fb06bbdc95e5e6928b5080a60b625d06666fda29ebbe15ce6a4ac1e049e67e0fcf46256060631a0ef3d995741414bfacca39608764d67a78993a1c20f3018638872c8320e62ca4013ea2de22cd3d573989ac50f50b64f561f92af5f34aaca1b7d227bb989aa70c8d695d27170fd38a7e7ec3eff871295419fab5863480f975a379eabca77d38b0d42fe224c25bd9de8580d9db9b9cfddf08dc77296e6817d0cd5ad7317637e11c066e9d4f2f0c7df5cd92a1bcc1dca30e98a4b96a4d4166152c8abaffb2b4eb0563bb2663dc38326d56e170b1dac5cf4e4502bf29855ca5d9e65d647d4e0532a462b5e91a6e4a623cb404ba5e6a47bfe5b6d0cdfef68cdf7032f564be2fd9d7a1024a373d31643c8f987a2ed1cf4b4e0a7d076e56d9afa533f664c59bc77224614a5d4066363dbbf81cf4aa03411ca8b9ac8225742fd7ee2a31ed8a7e1e1884c19effb17c117a1e411a7daa9e0af51d1933e2a59850d1093adf4bde64faf12a99340665459468b16457a190d2464288ff82bd87bd8e19e9848110f79595eccaab0aef9153f8f1d5f98c6248032dae743d2d634ea3bb48d1ab43dd65612f4e43f5d5003ca1ce8422f8814d6e1325e680e0e0860f09d8ba6c2c7db9b907c960b3a212dff3f5772e6e496a72c3f07e2ff75ebf4cbc3ed23a53a6f9f932dacab57d9f613999aaf4defe315034deeb39e25efe3208fd7d7c7a72432a61f82f66dbba9e4bcf64da2bd5b3dab39d555eb37fb3d236a276fe3b7d4a842be841a9168866066255739ff2374819984e2cf09917a732ad0dd18a48f971984a3923768d64bb3c57624a109124e347f5f8bb01157a04d7c4a28fb6cfd2a3ffd7062ac5007c5316f0ad55e97c3f62a45d8582805174d841ab2f27f109b7fb61e3f9967847079b1ed0ac93b8bbbfbf46c0a9bb693a6f37cfa13d2475304d7decbb8c0a68663118b9fb7fb0ffdc27ec51edeeef132261e198943c0a97b7b264d7ddefc7b844326009e3f9a220ea361d5d9db0cedbf8570420d1f99a7a02969b13cc5660b76e4e0baef5ab9a1efe686857ac09e380ce845611d50526b394a1974eb3b1457578382ac616bb0484be75aeb3e18a33e44c8b90e21b393d7f9fe3b3d6efb107356555e6aff67c20a244cb2a6297b1a0a9c616862fed5b5e6d819da6d33c0fed357e473f7d36f164065c03c335818800fde02eef646b1a95a2af8d5c75bfd0ead14bc5de321c0a424a78aacc5d9d873b727df95f0b32a03291cea16f7811d59403aa473ceee5d212ac4554ea115ed5dbc18f706118b4b88636ff591ce4833915ebc9115792d84f7008ae0f82da8c32370d9fae45d532d46252cbec754c889a66d29397311e6e01d1d5131de4f506d0c31e68e0b02caf24719513374e132c82bd51185c403ec4881b170d8faddb2db4572cd91730a24948262d76bfc963ed5059a91a2411dc3f5c854a990c3734f9f7576ef629a92fe3ecfb01d4af719ddf6870bea939adf205f7cf8e7a91a4f70afbf8041e82e764b8dad9adf40403485417423a6c46ef1cced839237081258fde26e3afe3a8cf69651f6e9ea48115172c5bd6f8fc9bea9fbeb14167988a9b28aaed7768aa4e697a4403b4b3daba4fd6fe8a4b301a4463e57c56d836a5d8acbf4795d83882f64a7d09e6b6e46a2b824eb5a64e2e24d34f3727d0b3170d9b5f41913375887874e38fc2cf64eb88cb15c66062952fd88320dbb7737d6d95528967de1a8eea0f032f278123cb792c7f2b9ead3882e74d5135d124bb7b40a59ddcb11b06e08247ec90d7cfadf3a03d1dd9a940c34f90ba903008aeefd519e94aec57c57876427d76e5d5d4300273487afd76b86aec760dfabd2fd9e3a332bd6dbcf474b2b937203ccf49854bb784c1b5a14f300fd3a48274811af5b642659feef16ff5fc87fcaa839b32c1c03d03b7dcf35c37312c69b3d679b1e46b490707c09834125f1cb4251a9b0b30fb77466a5ef4e18c59f600b80e5822ebe9abf4144e404b13d6cc8d1a4121ebcf62079b4c99f8086a6454629d62d9cae69a895c81b9c76b569c0356dbbcf31d18980109c287dc9f7af2c9bdc3f78c94c5c769af5345ab44e4a6e0219932c7643915c662a0642a21d43f3d354af34ef97fe86bc9dcff94a44878e6233299e7c8280bc044b2793708f7c2f8bbd7b0f432e0eda61eb192833674a21bad6b5c9ad342cfea9da9ec43d3cd19722ff51697917cdf6b06e9d65d7d27f5f327c187537ab5ead8d02393a1605d77b7bc375028525eb307364b6546776d194f120f6a80c79faabfec21d8e9a02865435c38cd1249e3af61fef34a5cb4cbcf5888e3b87db8b1c48c28007157d87ad3ed36671f78862e7d661f727f40602c70606c76811ae573b566d38efec1acb70f0007215461174ff40016a7458b299b1c4090d836130de0b882410ef4a58541ffb439d8aa3036bccf3704086551f1cdd87b586685a450d27e25a11544d703a17ecb5072c83db5d320673481acfa58c6fb69e17adf8fa78c91b60204130b8aa8af542d4ef895b8541fa1203a256a1c35ff99911e891abf21924aacd017fd4db1e86b6547e5793882c6b21f59c6786791d136decfa51ef13d26c99c07e5cd0179870096b048dcf0f99a270e92a4d293637d2533abb3f5b44c05203caa9e85e0713dc0e1ab45b6e445b4bf28b019d3fc7c09381748e60b4c5851e57fd28eed5e3ac5eb591d2bde3c5d0cf7c24917c9e6940e1c3ceec0f213f7dd3ed176b1686b04e24f054058d10a63fb81d1948c50087acbac6d6c5010adeb7091686396a41990ad1abccfc1b32a2abe187586a24730826419c7d95667051219d8025834a70b8f556bf9ae36f1f8238cf76ba22fd3538c7d5ea12da84c629d5c7b7db1197999b947082c35376e29ba4fbb7e1182aede9794f50a71c87c499b18f04aa08c11813b840f42de2145b6922696a1bc4a541268902d8059c051a6f84df22d3b0e0fb03b00daea8714611638135f5455a4583d4d3e86a084163a6495bd1561f2289e8b9cbdb4769e24dd8b615a5da7b8c85e804ade6c0b8017b07d18b874ac57c42c9a1b6c9298ff20fe5e2a9e08ca41057c9314c87ce659f6143bafc81975b0ad2a6bd0a2d12c2c5629ba703983f4f65930252b6e22f5445babe7ae50d23edb14a04e660e3734284e87b32c72fe638662a94890645d428336a664a873205f658a374e802ef21306c0803a8c0c53a19e362d0bc336c20d7d617f6dabcf81c6690dfc13f53161e16f1a78ef7a0b3d40964e33b6112ce196fa14790ebf50287bd21087c4257c5455dd55cc972e947ac624c9f09d3b19fa86af7e24848cf3f91824fff179e9b5ccceaa3849aa01a1224bdbb27c6c6e740abc848aaddb9789db0eca58b3c4dd2c2994ab8776a1fe788ce983241b0b64da8210e47f75c4d9893c3a29992e5617cb0b10df56207d812d46f55af5dcb6e47f63e2ccfe0d0a49af320fbb965277b2af40d498af9a4853eb230bb70c68fba9b1c21b90fdcd5a98662f85e9938d63335eea64f4b13fbc4f7f89758f6387be2181f5dd14af2e8cd11ba2c44f2a9b77417b51acd2c6a7f5252c643580aef9a5ef7beee0cf1ef6c1b71ecdc732edb7728efac1da2ef4f6df97f0de4ca1d0869a1840d6d9e2266cc898314a47705517eef5244ef2fc4370676a90b52b1af1eb1ec840473a338c2aa5632bf5fa6afeb7d47730d70cba8dd5933036d44206ed807ba0a86b245af610b094e70d78cf09f4b210bf41565b90652a779f6ee6aae0c9ee8f14a9889617206d308b3857f10a66192e113faecdc1e095e27e5c1d58a0a7fcff9a0b36574af5e211a522a4dba52a53e8269df53ee564ce444f929768663b6c480eff5bc86bb01839c3f127454c6f9701ac857f072c4760c4289974a289ddf938e8b2f55e4924e59d182c6feb4ae6d2fb600bd4beb91b89f96e91bcf2d83e1e0653a8da5e9160fcac6a715d63b4f9ce1e84109ea3cd9a5c3d32d1dd760e1821b7ecf43f3f438f3b5263d36b057558a810bfa9a623b53881d2e1dcc5b22a0693bf0ac966469ada92b98befc4c266de0337cabae7f614996e0c58c1b837f5f757ee81895d8af3c793f8790c41ee3e4bab34e6f09771a6972a8bc60844b2442e161dfef499954d7674d7d659b08cadc1aae4621a5295a5e1ac161cf3c513e9ad791f41445e9255f027d2afb5ab887052c30a7840b19612c6decd12a7c106e7cadf5d04bf482d7a9c5471244badc5cf4c10a9c3f5dc86a7177e28c2dee9954b92dcba4be8424c63f19f5b31c4d32a3c304cccf59f13ab3b7aecfed24d43d04af3fa06c9854cce093b4d0e7d1cdd372597fea0c5c355a903cf0b42a9a40a73c2527f377a0ebc171414cb4bb7155080b2882f7a1f032256ce392776918fcd658f100a5b7a531b4b9c13dee4351c48ad8054e2dc1834658dcbbeff66f76c5723febf5f2ae58d8fabb5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
