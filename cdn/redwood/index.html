<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af80bfef8062d32649ff8b0306fb08b5fda0e1fb3eacff8d0a898926986159c9306877a235d719f4ebb159858368cf94ebc20b75222134ea953bb32b4280a8701d822b51bd79b367e300034291977da3fd3e99f8b4aa0b44ebe5afa7a19ad22ec9414bc66f535595781b7372826f07aa8334c5e6022733e16503a8efde60e8b1fa7b7f79d64c433599790542641327796078f441f2791fd952654cb8a516f4da068586eade987b2e6a87607660919ef613c859ae71ca89de26a609d853f1a00884c007b491a89fc52b5137061b0a4c538a5350b5e593b35d88ca8bbb8b4364802d9fd31d643c963ed544cba38fe0bf212ba8b3cd421770a8af034760eeac3859c1cff6c60ff1cc62c366b8a5a4a1cb7e01002d7afe1a9f1e8eb659abd3fa11c7ce58eb161c1a3efd3ad8f54c7043c82e0cc670753d55518dbcef9dcfaa5408383c4df7745a0c4f3e0980f69adc35052ae8483eb03274104c2584ee572fc57d685b3271bd61958a05891e493927b43e01c6193ab9f2ff03c72024c2c6d599cb0b508071a3cd1b2b80a20ddb4c5e31d05873e47008b9399b4297de5d42181979d8d7dd79d44df0352ff6b4d3a30ce930adc4309efd9854029274470e8c05d1dbac22336f664947521e8da9fe54d4219444b836b93780d59a11b23054b0bc92a9a6b8295979fe4ad5645ad4b21060fe1a2bbe6ea403c8ac3ac0ad41c1658210c6144f5dad7256bc08d1aa711a5ba00ecf5fa0a9b7385a18e6801d1c3594bc5b4af88f302a2555e74ae357203db9ece6e05bbbb37e9b9b106388aa67cb00422c2a19037db3d6923cb1c7649d728888910e8cad75f8afbba33af5c5e53f8babdbd38685d7ac7530c888efb27e387b460cd91ec657a98fc04ec0b1df63f5fea2a3d61e1ce117561f6398192fc72ed2a5f81844b632914b06187f6cb596f193264ebdc2c4805e5c3caaaaad189e93cd3ef0c60025d62ebdc78522bce7d5e8ec8d77de514935f6c92f21ac2bfa40b69f4e661140402ea237c03da43ec69438fe09b503b767ca413875e034811e2ac99b9102cac2893dabee0021ab50c335fd14ce129c198f544e5a9755f75a1ae9e6bf2bc23913173711372ca997bc343d534fc01b94a1cd275ce15e2d68716f2b7568ab676773e621e2ed2e09d869182d6e0191a95ba6fbb89893f64e88c64042010ea99acc7db68f3cb4edac7aae46131bfaf09d375c44a470cf09cefbcb59f85bf5097205f23ebf0984fbe27cb24af37ba475cb97e206601ff2b1c0e291d1847c892e40396d061643f4f6adb92a06955d6904243a36dd17ec8fd4f75bd3b5ee23f3c37722d6d8a2dc093e24f4f3211aeeb910c33b129838fb801de75d777a503e18ac7ae430d2c59d34ff77acc700dd522a45f7240997130c14ad84a5a6504ba246916fb094e710403f9b231d10d6d1a0b017db59ff06ce36816aca407172bd94031745521d20d3bd02886f2d1951bf28a5aa30770e4d55e62af73179c09a9376452ba91edaf79ae6e4151c69bf7a1fc6c8983100cab6971f122ceab8225c35232ca8ad4b737222df687f5cd2d97b519501f0c4137c9bc31c308d6b1aa438cdfdd94a509ef0fd8ec3a9e1836604540cf5ed16362638d089d84b64b9c7afab06ebbe656ac1a4cc982aba63359e9bf4baffd1c3cb5c880762de9e6f05aa91a8eab101e5c541c108e6641efd31dea93bfda79266435486c32dd618e5625313904890ceb83af91b5989f55e81cd896868ee48ba9c150a2886847ed851a9bf04059b7e85c6af6c13e1cf6614307f6bc0d3a07fe7183115624970f98a9728245cfc567b0601783d7bbab730f06cdf5efc4ebdc1f89dfbf6073c593334dea9bc4844d37bfc75a8a97401ac3f9ddc39a7e63c9d310f67101c59e6009aa89f2ef7de5750d7518afaacc9c3d4eab27154b3567aa042856a7d9e41623b57194e38ce4b3daa5fe592d317ad3accc5fd8fd2a48d5ba865ad8172cbec628b8af05f5dae4ea8bc46d72ed8889e7e27285a269931617d9ddb0d6658babaed98189dffdae6f01e92e38d33bcc290bbbd2c555b88f563ad2fe562d6ca1d2a6f45c6aaae9154024e5359a8691fc48587665472c18e6cd383f92da42328373f1e53a17a0c4f0217370ac2b57585fbbc3c93ffccdc92affdd34da887c5996771a5610edb9a31270bd3c576348058af0dcecff1395865d0bb63a41d37b26a630cbd0c65e612e944506cee3b09a81924891df48a4b39e3c06993a528f4869de47f7cba70c849542ba215c8531129aa8e008cab39be7f085b5a272834898f7f6d731bf9dde9e69275163d1c504b4b61799450e3e1fb59755ef8b991ca12f175886efb1cdc933decfbbc38957c56fe3c8b2663c0f6fa975eeb8ba1613b3b432f3a36341fb756ef1f5f66a7b3c1ea55a5ecc22f8a85fc29e704939f1abf04a4788742b3459fd2bffc9aa03dc17c42c43e0f03dd1a1b16cc1e6b3b13f7b2f626e0ebd602ba14396bec863e1349072e2e2d06a425856851085af826aff0792157e80d7983dea1417722ea3d6bee3360b97f2e7f5c9adca48f26dab2b3a5c2a8497aa3f936e62051e9d90d185aa2c37934137748e31ce5e898d38a549dc262e649441fc10b1bb6379f2b9bdef01a2ab3988caf9e30f2a7ae5a8042a4084faf6028892ac7ca5b4829bf23c026ef7fea8ff09a106b6a697c62eedb619c8a9fa91fc85da4356ba953420f5f5d3581e7e3fd178a723e94b6ff3a134bfc953e28bad7c9aa9981dbe9e61c902ef110a48c5181dd5759269d9d28ebab43f09a8b9e47254f8d2614bab2dbe218abbf3101bd47e28201c0ae5cf2bd3cbb57c1be28442c1c1728dba93d4cddfe101750d7936814498d5e1ae3bde52c9665fdf0b5d5801f59d4d4f23e60c88417c11e6f2e63e701c860d7a80ce7c1f3b7dd23850ee39139d74136c52d1b2de3d15ce3aa7dd430cb7b5e26364e3c8b7ee0194b974b485cd27b0b8f3e7d2f9e7dcab9ceee322b4de24c93a87721adec3e8295ff824bdac40f7bc59453115bf8fad55b3fa98cebfaa53a1943937ad53c5aee67a146baafd697b38bd52672133e73619e695ccdc50b618df2712d0e27d5808f1adab8fad62f6d99cdfbde379379f6e0f47e54464f8fde1705e3a466ebc272b58371b7ceed1a5c2900dce06464b7c8f9e39f298c211c4f4a3e37fb53c4736f2d6d4edea2fe1d318a7937b63bc44688c0e85b3b3348fc2af4dd351c3af3b2580139ba93900919071f0d6a9eb3f9b8388ea9df990606ba541810be307bc05c99478e7529c70b4ba8344ceeb1e989bf9c571194cf756e61cf730847a30990c6b9c81985c2189538db8730a8505b84c294a68e61e5bcc72438d29b931f628cfbb9af2b07f52eb36f2ab19270ba07d251b09c88eda431e6fe258e4bbcedbca618ef726e5d73d24f18d155069229c94437c563acebb5895be28e51f5cf56b8fd77df485c5820acc4690ffdbbeaaf614b012385f6c6154f8dd62d9f61b33394879951f3b3cea803a02be879a93dd9afc64c5fae3b2cc86b965a8bb75fa1939c4110600391de148a9c2f03217516ff9cdda39712a317e4d08fc2289246684c5f4e0bb60be387d714fb3d640b0a278d17ed8fdfa01f0e913ca554059fa8a926cab895f00f296536b994ca16ced54a10987bfbac004297c396efb214a0d74051f298010f9d73979e40d43a022001af8da6fe4557d0b1fc27c5929c59b20391719761a69cf509792d096c3c51517845d8e3ba852437f731428da28b851b34be60fbe39c47f09bb9040a9867cf2d4e93e486c641efc6b9acd27cc766e69d5f1dbc5e40ac1b4d4ec211ac06f197a80dd3947593eaa693ebacff60e0f91d29cf51cbc96653d1a31b032b17873f081f4ca38746c48bb49879806e2fd164262451d6ff625936982d4ee7449500d41155a6c15112c732059b02fe074afef60ac18dbef509730f9c0cf3bca8a6b540379b1adc3db2f9dc478648869e81774a30bcffc7bc8dcae07776676c28124dba986fed80abc0d47bff058d51e8885cf1b88dfd9ebabac39cf752f04f7cb8f4d849daf2a3577ae3d6d913a53eb4bc819c273aa2c5dcf63e7dd65fd192c2c1def50d37573e483d9f895bdcce023fef95932014b218d0b1ae69595ba12ee523c3ab43a2ff39a463f022a287c5dd8a9b6cff1cf7632b2b50f662157ff038737568cdd4f13338021220d42223420a78940581b7b2b410d1f121b9cf3415379cdb9f38f5b0a335c6dbf0833c62bd5029fbb8567d866dafb4439ed8c110a5e569a2bcd8746ab3cbc671964308b66dd9c597521e1bb6d86adbc595df165fb40344b7ad74a8269005cae4ad32583bff4b8c01253e5402843cd1781f60de9a304814f9536a305811cbb719eabca14572ae183ad7645800df11b341aef2fd21acbc0d07d5b413d7bc8bffd09c5ec128c6801a71386b3d01aaca5ec56b698b41ff66ab92265b16c55464b4e11e890499e447c363634eb251dddd37107ca74f01a3297f5d4520924ac0730da2d30bb37e4a28a5159d68f34f9801bc8a5a2d33d6ade09d074c5ca54b76d0c8b960a7d06fc3254bbfed5a87447ab290caf19df592d3aec7737945059bceee2a11c63d5183f9b292d8b0eef52cfe41017909e343532349b728d1c73806e4f0880acd8c7ade6e18c469a03ac0aa26505f63719b4b6013b6159a5c036385fe231f533b7670ef86f35583224436859d23036f497101bc0c1b255c7dd9d9f00d2476efb27a50e74c74802129c0ac33ff779599ec82d94dc61121bfae069b715cb8904c00bd35fec49cbd98e1bc7d1e7558b83dad24bfa863c646eb0ea89a58f55ad5708cd7787333dc38d790946aa166fbc50857ecd5b411195d4306cb1c316723c9f80c9c9e364f589031072a222651a973724f1d0d608ea732688aa861ce2299f09093b044bd42f2bd8ca204d04748aee15bb3794f5b1d170ddc3f8c3b61925bc79ad25d41d7148778494bb49e330af66a4cf1d7b3df2d795fdfb6915ba4c06c907ed5c8dac746249e4ee7d785b64276e108bc02a4be3063cbba559cd93eafd9cb11390f655757812c3d91e5340d6d61172e29ffceb37d6b042cac2d6740f9e16f4a76e885c8eeb5e1acc93ef9c5f042b4b6e69ed890b4f251c48d2ed881422236906f1ade14ac5e2267e1ff6fb1b8b4b688b801418c61c6ea9e49f1bb25ddea89cc0244fc371c460acf9aaf6fd7399ee7c52ce3e3cc7480e2d2018e9988d0bdcdc293604f83a301be084625e6f6c63f92f0ea41a16c4f82cd091727645c3b8041a95a4dd88cb2cb10cd7601234d9ca860a03d41d6c6bb100e20fe4ccf43be512c445dc271751afd83113be0400df031182d8aca37168fadc7cf94535f54c657fd92065079c251c09b833330e388794e821fe0c3f6aea65b3128dbcf9ccd212abf3d947414b8f8db03a368e6ae006d04a36233a596d881ed3dee00fcfd0b8f88be6c5d0fef2a099559b4d528b0c8a41ad092606db1aa8f0301ad65ccd4e9dcfdc1d525b6636fc8edab2a0eeba0df3faa0f05bf56d7705bfe54e10c53ac975c87d63249eb5e2d48698f6b103644cfe0497a56847a4da56fcfc270e001a693e59a1e83c8e97b1562b397b1ce65df9cc9cf32a12e7010c28a5e0a65860ee6ac9b0152dd982d15baf276188d6742e917f0644131b357e8bb12750d8547732d772371639c11b637752fe21344d4e5789b507c05f6bdb5bc5892bb871c75b4104397d64b499d6d8479b217940e647d30bf3fed9096e40f0ba54f17eaa73d30324817dc26e09e802c2fb391b0f40d31c71829dcd37978a42cfc7735e6788c248a788e684faf73c825ace8e25d42076728f12a08730fd127efafd4eb537ef080ab08b9b3850c005af696ea295a9bc883ef7779d70f078c4185c5b3424ab7af6e5de944b8f93815b072c6f57636a4932c7c40f85ae78bd5dea4ff83aa2203908cebed87d9542315ffdfa59232f2131b9bedff7bcd95cf3b9b0647ecbfd55a0cd49aefd5ae206a9c2281233d1d8f5d5517b772e5da4be5d750f5c7156dfd0c1d9cf1424948d35b1731831f19f0342b90add6e8dbe2b5f1154322c87a9c1307840f57797bcfb5440fbe5dd9add62acbc145050997c6399d7f4db953187f6292762405c45f20287715bca9e09548054e534723ea0a8ccfdef53239771c2429bc4146a8d772a70deea843e0f5dcc00489189e80bd465c11ac92e3aab7eae672517232fd76daac6d51c131e4121dc821362392cd1ab957966e596d6b8efdf637866c6adab21ac47d09d4be3b2e405441de347e0147b4005c0bed077adba52b71f8dda78c354a23cb04b4b1baed696a93c1fdd3e7127c64f63a1ecd51b9ef7184eb515dec5d93008cc93a0b3f68a6b433c10da83b1c7a74d90fd702d6af2cba23c731dc4366af9593cdf759a553e1912f4533c5cba4436c0e3c98b9cd67a6c6b9ffb2ae9e96b9d55a8592b8695828c9231d895ca3831404a974dacab77d618fbb012d11c332c1266a645d09c8064535b3a05de961a442544878cd7a232597d5d8b53a944afdec97d76e26673265182e1e3b20b464a2e0cfa3042f48e6a5f57f56ad4eb274545f70ca06b58928099a49374a869569b218e029f300baa21399134beca14485a26564116275051daa09b5f71bb97938adf732c3e66419a9b23b4c8337b9ca463e8533c4396d80e40a2c6c1d65952a4d79bee05b5c10e1b182a707831991da881762bd9748afbbd14e6520daef7f88c2e311cb53d01c7431db14c0f6539bdc05707edbb3f75ca264cb6673a7bb4d2206a926d61ab4aab9962ed54af9eb73a5ac656e2b8562c3009f713cd3e1546fd41ea1c9123af0a5ea9b9a22ad539544135e949639bf2d05a79aa6ed1f4e9e0fd6537c240201c287b9bb17a5ed61cb64c9671847ef21a24024a48bb48c656e565644278489faaac9911a8c1fa00c791b3209d03d6aee3f0170e7b4af4bf2aa96283e78537760edc583e858486c7f61f7e826c9bafa56f529063abaf5d44914e69784f47d67321db65ad1b87f45453c574cacea15aee21edefe65bf14d4cf90ec1e5c54797ab18e1c23df6bbe4be4e1d1a8f95ef355a022e12519282827375db8d8924cc90f377051d2e86952648b20b15d0a77e62a0d742b863813f33f45180ffb125637ab8f6088fa545bb9a1e33fc2540a1b781159e4837cad469a2fcc7d82555eb941240f525350c0843a6cdd1969a9fb49a81e43a914c52d95b3f78c28ae397e47f815bbd7d60396084a942b8639c56e5e2efc7c65fd8f638d8a320f56d0b7728d3de62e3fd12ca1035dedbcca31a53957a30be94639df0baa8df2e9920348aebff4ebc8cdb57ae808dd5154c1f501187add23ec46c6a96c6471e571516326194a590ed0ac221c2cc93d7db601a9abeb4f5080ea8c284d2f1f7afe3086d780f828a436a6357a198b64dd3c1d8a7daf622a4fed6fb5b89db97c673a9fd377078c8134812c7b333251a187d89811de3b1696f729f6aa728cd461bb31dbb9793b043ed4c5782f6c4456a636f7c2a5d17f782ea24e3b452dd10077f7973893efe14bace06ed91641e37cfa217b2ebb593cf34f04e389e616c2f57bc007883861f5bb82ed3d2d6761d9a251e36a40006d6bb9ae59821f5c278c76f8a428faf7a4fc8c415010110c25c402cb1a774c2938c6da23549e9def5f59a6271ab9b247e617b1b6bccf58386790ec17e3629a88e4f2ae6732c4d1c41ac188c62630cd6a824fb638a1c862eba023b89341e173ca1ea957f3573c7f1b32f496d97105df6eac313af1bdd25b7b3f320d574b7ea80f4573b10bf82e6e63e9976de73951d4d1c629122d3efa9d57e29debf97ac1086e3973565822ce8b454ef1f4e5575709ee76b9e5ec4d3aa5dbc3310f32b550b3419c4acd0683d62faee10764635df3899e937b55b42b5634a1cc1ac4516a744599ddaf1f02673dcd7f067e681f0176bb1480fb06d533879aaffed820489463e03eb87e2234a97f6d04094ef0145fd9a4c6ff6ca9555534405ab4eddb79281532911ff1aea74bb7f69d28a14bca52bc5e228c9340791148dca04d76b56688f0d0c3895376169e829a40dfaef8bfa8c83847fd13d5440a9798e548cff3b8fca8947a0780fb014b4dbe93312d97ee363a8dcb993e4e3896572528209a16fde3e5aab8b07d5c8f69dff8e78f041abdd5c2c3c3d6b7f3430a1513fad4ccb5e513974a07f84a1b86a1c5c0b5f57d829d717ac332397789881652d11be5cce057c3329d0b6faba5745d0f762212dab4c7fbc26f08e2e3900ce21529b695c8ad80587f0393a64c89343cc22701d6b93118a2a24f895d4a25430101e1565ea6c8c0524503970475bfb4c498a5c957c12630ab1230b94f65bdf9434c163e194d4a13581b29a9a8627cbaaf7c861816dc102f37667ba8df0b8da0b8a589122e8339e37e92142270633505ab0aed954784fe1041e90af516ffd972e80d93d6421c1a008e2f4d092d104b8405ff0f2d770a21e3c22af6d6a961ef67ce5b95e84f357f2933328393bc4bd8511436cc83fb7cfc8ec7fd1f3148afafadd7797f12291b6db0886c6a2e0462b5ff58f3c797f88132da51efe45af816ced3181990b9f7cec6fffa11c71cbfb50678b54ddd9f7e91df755be3c1acc2e609a5ab0e197324b10747f22e85daed21e1af518ed63438ca5848dd85f0ffb363937a8cab342240412ec40031719e0cb02da7e848d32537b6180d4dd8eaf0d6e52d21c0df0b32a30a973c2313c0e3ad3dd0263c96990c19514d8622b17e762b23eb02ebddc390070a2a2e337ee7099702d1938537aea650b70433310cf464af15cb11d35581ccb7b21fb2753c5a014e7dccb0455bdc280f0ea73634e6ee48246b6184c034899f21e74dc44cb4a412a1171775b5e4a8d9656889cacb2e9ce829abfaf77011325f9d3adc409fe61496ee5816104c936cc174fb615b44082c7c8661bcc172067ae2d78d2d70d575b464946a08c59d6cbe168bd7828d529f0f2d46fca271dbaf8f299395e3ef13d568a12f2aac4fb97b9feac36c765c92580e1ac640722504ed8323c960c979620fcda80d1a6cfa14a9bb1536739d73a40d90bee33b02273c1833594239bc9f86df4ed982f2fb926a0abc6b3a53800bfe4bf34cba611b55c9d6ce3aed8ac2d7a993746337ac27c37d80a9ced85b0fbaed114e8f33caf2c692b770c33f61495bd9a11633dcc3e5851c1386048da4a70211d1ce05f23006752948c6927d21d16bffef541ea234ead90ccae4fe3362c97f05385be8aaadd8a1b0dca1091b9b12823275752ca2a7fc7fa6ed58c4ef5a8a22e5726761ab3eb6c8369a857bcfc8dac01cf7d7180ceaaa29cfc454dbc6568f3532b21fbba037a6cf8c673fbf2f51331ba1fd5184e653ee2d7a403d869f2e793c148d8c951eaf9baa5ff30f2c051c520197ad306347cec7db83097fa83a33818e5b65bba4e302f884015064eb2b2bbb7542fbac0c749031d3b286ee50d76da7f495dc96d29f257f14b7461f0e04bcbd0ea456a497d5a681839353460df01dfc28b18bdd104fcde00c0a5eedfdbb3187f467953b39eef9a09478a94e25bc668192097f1ca4e9f867b5b7c528cd7d91c59c8303c788cc5202be3979205c7dc16d55f78b4bdeded07c5b40db6de72048511fe558c14daccd19b67d8a2aead56828276bd82af3ea28a7e1bbc08abcd5b27d2a2188d086641e4685c864bcd4d95889f47350fc447a53fabf3f642204b198b5c6b64c6d98602747877b91a8bbe61d10c09c42302abde849bf621a7c1c98d8082ddc1814db75b49360ad227bede70b1186042a8a5189e2b23eb3ae73ea0e6b394fcdf9c1ef3f1dad69470c0bcac69e5f293f029085476d18098501ec424c2346e2514dd86f1ae66422b1989749dc073026bc3996b705380fa5d7f6e675704732f57d140d40c08886aa20d724fd28a695c9e15cec6148163a4ab16f7ba0e7d5a5d6133f77236165bd45d8eb6ffbd81ee4bd9931b2dc29c3515f287c0ae974907e1da15828d73dc23559a8044005ee128514d4ef429ee7cc27ff8563825ff3c4e3263ee206f46ced1eb665f417cea71e38655be9c99a0cf20315d6b28de220c203b9f970bd35508842a33d94b1ce2f5cfd83908e669345571be18883e1a884cb8417de89e26f8ae2581292d862d9991e4a3a7b913333e2c352bf8da95724eec001f7cfc361986f40aed04bb7b3846773230241b46ab905bc26215657a4334cd644647e796f4b0ba8b8dadb5ef1ef64c25b278e207a3f144f9ba5fb4c88c4841bee79141905883b07f050ffca14b4127f14e94383db0bb390e34b4645111f09cda4b4913f95f5d1fa8c73e4b51f408bf652cc0e45d8ed7c18696865a801524cb97d51f788c155547b213c41c52a5a0da079ffa9bd30d601154e48950a2ac6e54fbc9717e8633dcebc01ca83cb936c995e9452a05bf15530a8cd593121d066d3ad1415d55833eab64ce9cd56ba1da58e2afc8311aa179e212359e54a95a96105952dd9bda319acd213a881f81470081cc3ac50185396f9888e287339450c1c90810168eefbae133d071d291cf8f1fd6363258e2f3c133df0c245b42d772d4e86920f3874d94b78dbe0fddc20a77168416fc9d9827e1fc132d4bdf589dcbf7b916e31a8f9a86cb4f6421e3588e645cbc86acf19b1acaf8163c6e1e11aaf924b27f34ffbce46d1e805e303ed9baa9df50f8a4d2a7a33c67121b1f1bda694b654ad49b05cde0bab665687fcab0aebae70efc146f4b5db6a0f2f7e77d91a636b31e6c41eb41e7931fc4a39a2c7f0b39d9d8a44ef98b0d59d68743439db1bfeed5ec001247b5eeedc78dfab06770f1465a419f95d533338d1bbd5fa8a77c547d2f0fe3e2204500e5a3d029a099e7ee4c6d48d57315879df954f43fa8d8d7ab81f9acfe9df6fd37308505200ce8f2b9b694bef972f2c5be5d0a98d798b140f951eb133bfe04daa5343cdef17a3970c4400493d95b525d5fd9d6d238533d0116ec1945c745b57185464c716b52fa55142c2df2cb50d912a5ceaa02c49f3fc5eaeefee24f44e8f103ae8de614187a3d9c22166893cf1f7530143f1fd9e6c05e02ebb8bfbd9647ded203637d22f07481153e5b7e1b85e152ad4b8884fad51836e136033ee4e6b13101948fbf6831226b4fcfcd545fa92450ef0ab59640a62ff71a0183cc32841a4fb13e043c054c4ec557cd3d3d388c907a5778a02c58b3ea89772e66786021f59c679dc67b2c73654a0a300db4acccdea45548c3fb4adc71c230627e295ac91b3fb4e0e5bcf5a02f56db5c0fdf04cfb41bf9fc4e128e1886b14787dd8c766287df93dc48ccdfd0a7100406c86e1a19eb1a1168f1a994fc0963737186f9102b025717698d0bfba7b98d61170d11c276f2a41be8991e42a18411a91402df25edbce75b9bff7b160e6c5f0d996bb56efee428023650877d1901c0f7b16ee9dba34b0bd7f37f6668ab6131e2e41bc55312dcb05ea37036997653038ef8421a159feb8913be8fe39a8515bbb821441a5c7da93da27e693cacc66179af03f6d16339ed77fb33a8c28adf57cef4d0ee50fe97a150f6a69b7e51ede20430788d4cf124ee869466f18f2661de5b62b719ad61518801de7c12f0181b99321bb1098d29681a5bc9443f70f5cbe15129aa857c366aea2db95bdc49cdbfa83f8205274bee586bb6a714fa88424350df2ca3c10c97a31a8724740186e5851b5b21451f35d6263662e12deab59eb6ffee61ff579a520b934f0836842b9af722cfc843a7f16def1dd2f1fc0ff1e4adb48a572a9b0aba58f4f66358781b25a93b33199e69a9a8f526454035eebce21ab0ad63ffdf8a4e25d516d0e9094d04b246436efd362cc4b5a88333078e30fd5114a022c144211fabc839af259b3b53511a2824afd19f96b4ffd31a2f0b66b11b3a16d9c3c3b63c34b037046c09d4a3eab79720d54e56cf219877befbabe5cf7c5d86821cf0a86aafe0efa8bbf8ba04a4e2f739be6f3ce0faf8a2c1000ed6440b187323c336e086cd29b77aaec18513f53ca0ad2e412fe060517062e6bfd364fcb95aaa3ae697fee33a2f16e6eb914d9373fc63aaeb5cb2b24ecb78792349c67736b4e2995bb4e0ab0cd8b75d7d1e125fefd2f28bd668d2a4ed6de5956ba567eeedeff600a333b456114b276cb7f2c693ba17c6fea2f572df5cc27ea9dc8a82ee96c2aa3e5b44907753f6a567d5719912263c818d63a337ed5e08aa51749668b828763fcc41f370a2788fa96896777f921d4e8c2c58453d78f4171a466d8625e3e743f24dd83f4be3b8c27caed51a0c6f5cbb9ba5acc8aaa976c3679885e6e96d4e8fffdae249fc86741bda6e54456b7738b4fa2392b080f6da859945d4b48fb66bea298339edc72481b6a25cc338c23d716ee8d9674dd365438bdba3f6272a202c4c97d18ad0177f1d14197552ffcaf72c220e2be291f7fa406651ec8157312fab9169c3a3ce634d5ecc60ffdbd55286a7c319807932bdde12e628bf9fc651185d6d3dcf5d0c7389e1a69757c681ec9996380926a41cc6d7275dceb9eb9aff4a597b27229ac27302cfe7d534df909044696373d7c895e8b049cabbb2c55cd326fcc6a5cc752bc9cf8c7f941c67b26e3824335719262abb68f0b013c59b5731b5c5afababe1888903885dc7aaa4cc8e9ed95c7e69dd8a50193c8256db596d16ff503e11cb00b193bba07ba12fb8ed0d932b2731fda0190464e77914fb7c1fef9296d8830a88d94e37738139e0ffb5936295fe1f71186ff7b027e6d69dbd85e42c01fef688952b7d2fe13a6800e8ebf208c34051c031548b502535a129772f3b140e08d6005d5a6566320d7e2a9900d1746b8c2e3d15cbd84b0ef9627b2dbbf621ecb30e4b5635fd7d627f8a3438203717d1d0342bca93cd31e77854abf4f016fd102b8f73c6b04941d4bdb42a16dc44366cfcb53110c188552b2da467c65c6383ae86fe54e664675aa6bbf7d89eb930ebe36ecd32b66a0cf93de5bdd98076228fdfd35b79e297ef369939469c70c6d2af9d8bab840667cef90d0d7d1ab5ace9bc6ced0b509ebd1c03ad24e160fdf554a011fe2eca0456c49c28c1c362988647ef259602e8bceaa139047758bc8d3e63ef00aba1182502c05e1e0a30aefa47bd735dde674e09370b29bc83e088a7af3b75526cfa9548bff52e6754a437e2f5d6a0b9ea087f2eeb6a0a6f140da172d2c1ca5916fbdf241e74f360546cde75fbd562d1d2cbb4d049a34ae45337372375817c35b8c01043d420011e75d5b256eff5b8222af3ca43b39885091b7b5b66c68db7c99d62b0341216a4df7dc54abd7e7a852f89c869f3cea70ce4d74da7b4f30924b695cab42c03287cb92dbe6a8d8948793486ae723669d338cf5fe60310f995a913abcc53937a4096d043a9518556366e8c11d1cbf3321b4af1ba7f00e56b894389a0485beface56132b73c8275c4f88f1ad91a84d220743d25b63cb2f0d266e08190088efd460bdee28ee2f10983ec8c63e259f43762ea8226b5c2261d88a7ef87a18cdfaa3dec0ce0c219c770baafeeced31c605590b2532a4855f780b6394b88e542c0fc336dd6d44783c673ca8435ea2bd4e46a8b4c972715ebb1794a3590910f55e110ab5151f0b3358c73c44dc7956a287c6150d6f2e553efdbcba87de6fa227ce91a8f314ed5db43ee3ae51e14fe4500357d0314a6f85ddb3e82b42d581582bc2550d2542738b402409fa19224607f99649ace14cc2a97a4bef5a98b755609ffcc2448bd792c091a523f866814ec9f7839fb1094ee16edccd5b38ff99998aac318901ca925169e6f75922bd1c5033b068f145f451ebef8f7aee788b51e7b0c524b68ec6449029f5e3127cd51e8854b14e16ac0b012e40ccae0daf5df965aa4cb8741d18e7fc9b23b5165b337af950e6dcc152b294fac0a571d53d656899354bf1da899cc2b60eb003c31517f4e84a8e0893de93cc505c91a580aed60506be8dad0aaa2047428d7c207a6b2a20b0b9a3fe9ac6f52daca6dad5beb1532f0e7588f8bc70d402def6348b2b599ea3a5b97d0c12a299d764c563c31137e3162d1782a662be7a58401538e5101292ef26c286b5f19e2228bae613a79c3ee5bb2efb9e09e99d367001facdf9013831a10b853ffa658380f97c1fc0bc60338e549daff7a9bfedb6a71ae87e361babbaf0ffedd32c862c33e03cc84b5b7df088bc63d3243f64fb376301b95cd22bdfa942d4867cf53cbb76ed436f68876dfd770368b336847b98966f5d34b07ad5ef7d9a9688a781537abed8c19942f5924f6111ce0bc7c36e0b61f4d3172d372d87d35216f5e6b2964ea1017d4dad8d8e5ee5abde31efe459df77b98149529768f7e68b08d4f49d1965799675841320cf29dcddf3477d8b818480c14be41a04940ef2a2144b56630610650378fcdf3790428ce77369cedb90fd2e1da52461c42b71b77661f3afe168b20cd5db8f7e7ef39f7ac8a9eba740e55c1832d5bfc381dcd8451534c3483d10003dcb7124b475b411c8b33eb2a459684ccfb1da69c33fe69f93961f2c51673117b9dfd1285366fb8b215af2a23181825b2e89f619e5776d18a78e65bf023765dd749b89feda025430533c8fcd54b88708eb78e8fd07705102674f835c861308b7e3f2ecb61af4491a374da02ecdd002cb1e7f828b15541f34df9353322d0bd6e1c3105577a738bbf1b2fa3cdb9a8f055fb1190a32d34dce6b313b21b5dce00fc1dbffd0617780cd0e1bcc684f7248b7ebc8cc0d6fda422422c41eb99b2917ba6187e562669ff78d5ffca9f1eff0f80fa1d4edd0987f40273d73c08a6d0c649b696e5a0d8dcb6c3264ed46fb6e166e041d96fc7dac0a8b708feaeae62ff22bc927cf0f1d10bcee92f099314896329dcc7746ddeeefb486a22385fd60755d46d4994cefb244b5089cceabce3f74c02f872f0095a38be7ba25bd6e2ee88ff0a0bba3480e434fd239871f573358ea5d7772db7fb67dd1fbf70a695632b64eda2f9f474b810c2f278c523bb9ed5b585cb243690ea7020e3be0cf0b61e8653b78ba31180110a970d620e088ee3d74ac6426702f0cb58f6e37700fcb0cb57423b0a93cb40f705ec6df989d82bcff032ee910c568683a9dfaa4242a159b152017b8c36f0c5ec8853509c8d150ae3ce37b3dfe39862557ad2aae3cf0517a4e5281f21d04b43a951f49c57fde42c034024bb1cb7db22fafbed16847bc9d83f1a2c4e9bc800a09db2da5fa06bbc0cb5c4f27156039857c5fc8f5d33b658da50e3762a8d0e53775e99c77dbcdaa6fab47f457d785c8718710636aa26ca9ba6ef592e53fea75f0025c4c9ef34420bf56c078255c1b867aaaf89099551831afb1968baf1f0227dd160752c14f6c6211102a98d6eec69781ac3cee2d2d45399df82b178ed75bc90b0082e69c8a3dc0b27a074a964ec0aa9c0108d1cb1a611f3d7f85ba25fe4d663b8814d3af710cb9dca04bd32ff680c34b618b649b2c63abb4788ae8c1a96a3f7ea88c395d0985dcb594639677d247063efcdb173e6b00f7738be6346f2fcc83a4c3537e357a5366a5238b6bf6035c0c4c0b13af6c981f1f77a57a622fbc8f2d4c1410080cfb4ea35d09bc54690b0af1fb19ecfa45bbfdd6850f478e1ac773ad14bc45b5f72c843163ef8e4dac54339cba2a524379ecdca23e5cfb3efc11e640b7db002e8023db9460edd3dee381587e2ab1494c17d67edd9cca99b0d5186defb0972e488a150b07361b22a6367377832d3d5aecd7d4118fcaaf2696fb74edea0d8425cd5cc7a7a9d6cf423431475ea74e22012e3de0603374d12f24a819f1cb497e525936991e4ba20bb175909f1431feebe96533c4dc8dd3d9de0f5ef73712c22a344a4194d784cc59dc7bef563cdac53cc1870fc765430b667f28560ac9018900f381725bc92337f3a00f0c193307ac464fa1212e5e9ed43a3d3a3a11c20b5dbc949ee3c417de9f9c9f4436b632bca0dcb137ef4a965d08ae317a97955657cdf7c3c1131af6093706cf095f33d94bdec5561f1810a6dd93dd9821ec1f60df283bfecadc2d45734c2245317d8206dbc3d72ae39ebf593a91b71c4300dd0da77237a923079cd5d8b2c2354d8918c7585cb178c8b028c2641039e18276489f2d67345294ef50c3efd90fb9ad57d09725549f93879728ce1f121652299e638445d2818563243113d6c944fb11d41f93276943acbdd411af90981ccf5144edeac70f80a7f1128aee13186442c182826175930fb25c6c25506faf067f0312e20f5398263e73bddcee6b48cd4a419fbfa7599da56019a59590b38ced31ed9bfd9a14eb8525e722b65889435695b9e1385162be2a118279023a6c6a5e2ba307ace763dd94ac9d9c21cc6f6640533b4bb4c202b8cbd6df754395a95d4d5b1a1d6920486203e91b1c2d8c65fec183c07e07b689da21bf6ce5b063c6a35bc276af3a1b6e93ca7c6d79bd61b40339e87de58881fdf27eb4385086555e40e52103033ca16068d97943f980af6457b9b72ef40b6d439e6ca741fb4f63342a761cb3b3986c730c61a66ca25353daefa8111117cbc9fcd53db0e409d94011294b9dcf42037bbd0c50521e8def14e40aef34ebb14633b518bb74a49eebd78d506c9a0d2f40c9ecd1bdae43ef8c520ccc2182bca56e7a20e7a9a4674410f09d80a6b979f671f2b56fca158c73afdf8556d03924c7a7756701ff558d08bbf2692e83706dd9c495e6733e71142f6eeb7773b8d15dac068bff5f90ca9df83708087c3127a1ec816ba5aa83ce0edc9da60699937ce3e9499c2eec9ff5dfa52d655781c7d48b4cc0d913619ec6ecaece7ca2a88f69ac2f0d78d7b382fb4d4c089680be4d17a850149107e9ae6960b97a3f340af6361409d91a7840b8a4904c169827f81a1f6c31e8284a67c7c5c88c190a28c5168f33cc1d8370c1768c811aaaf46f269fa7c3d3010856d50e191ab3e9f1a5e828eb7e85420d8223de33a573e186878f2197d8b8b72935f4adc7bc4f81f87c5098d6c684d974d10482d9b59c6a79b76744e04eb23bd172bd7da5ef2e4d9fc85dcdad62e8cc00d3a040ebcda761542a33b1ca82b0fdf5fe884e5ed7ffb318ff6a2aa575b0d4598f14bd4113fcae8d605d05805ba5eac747c13c8c57805f22100496c2da5e015cec7328e8d5acbb8cadf2e60c54bf5c80ef06b08d10ae8cca0e0b18a5314849604063255ad50aa7a20c09757041c1647afe8fca55a585d910df3f956b732866e93ae072ebdc5e64bb7be96e9e9c5b06af59c7ea70222342e42ee51a9fe2f60d26617bf3790b1f2a629ca267c9cff6a34f5bd8972752557cbec7875d3b4bd24c5233a8e462c25f6ce4db98448e300a484d968502e0566b99dc973b220ffef1f4278bc0cb306b16c819b0ecd8ab2fd1435f71c07445ddab367bdc0343b8bbca348efbdf942cb38ec118f0f3b58dd424fade3fe022a0cc4beb28238841183dd24b164bd274552ad14ebce2b817156f1ddce7c93dacc8e0be65c963ea7809eb152eea541b5b13f9c292c2a7877ddcba752eba7975c6b18f256fbdfc14a208229964e1e38638f801f02407b48640317eeb2270bcdda29c950772d4bbbdb41f054a5794433e2a97b2dcf19aacc4d6a34590fe8d7e519de862d0c2cc68ef10066bc251cc33455fbb4244fe888677a547b8595f6b234edac77bd326f96e61b7c53fb4f90053cea5635d5487f5f7dd04b066cb1d98b62df8a4a5bbf180bbe70b612b3aee36c2220759fe5dbf9392fdf6ba8e86528557bd94fa6c727bcc6dea2c43635f8eff8058aaf4099f898ad141227cbf63bd38bdb76c821c7c14be72e37fea42a136539c34f6b7b9db2ab4cab0f5197e1f94e6ac0ce742c45f00be37764748f1b91e975527096fd9e6783d72b492085c26cb24e924905cc3d54a09b35cf142313dc44817d46831eef3b74a9cd90c5f3e8bbf9cf6f48c46340bf227d0dd8b977baaaade9a3271cd0ed0ac003d5869b5f55f05aea45c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
