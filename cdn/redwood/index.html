<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39858154dff88d69ae654a31c02ba1191a04f0bfc1e32da3e86337082a18776edd9c46a694576507cea4da448b8c21b1115078b7955434bd3de1e8972587e80e4119f27bde396bc307e87cd57b7f1b7acfc061fe87c9488a09895732826fa7f7b416c1aa7c522b3002b0ec2a34745a715e45d4a352e39459f28cc42097956792d20dd18c4648dd18fa63d452ae90ff789f781998f76f2da947bdd416f108a8d3bce9aa451c661783eda50dd3cd9859827062f12f040680583396cbb499ff68b1fa4203b89071de54071af526272dd1c959deb9faccb0602f0cfe2a9d4cc534bbe19a55bdd23c752e56baf4a5896b1b7dd07d23da4dcd765175bba67cab31c77e3d6b1dfc6fcfdf0ccbfe265154583a8967cd70bc65d0e0bfffd7a3dd0e0366fff5ae18a90d71975dbfdfa65910524e839d72044017f62ebca5089aba48a82a71ad46636d2efe62c4def0a21b033dac4be2431fe3e615e95ff98edda95b200ef157a13fd7dd4646b138dfa33ca4696073b0992a8f6421aed1291d926a3f4750a0cb4a7f1e56322ed3a742006d02d2c037737f66d65c05e46e5eda5a25f127e4de2e7269c4abfb831581100f1a5d33419a224f0342989d4a732aaa6f1b7bd95de996e2acde238aa1728d581bf3216732ad31d8197f342c09912223e17dfcce11731e454bf072c1126f6c72fefe3d30c655f166d3e0efdac7f8118cd98bba11bd0d0610525e7f5db71dd86bab7a3dc17e4606126d81a0daca5f3cff94b0a6a3d01c5c9f38952510fdb9e968bf7252fefb680f3df6938567e183bdfc48ecf30cf1548250d7359c3d0bb8d50a3979ac262085c1c2d1ee9025f194b816f8da13565fde8664cd27882ee92e3aac5ada3af0e8591dcc171da9cef8f29e27a7241e66323edab724590129b3ccfe0d845152e484364c8bab1e5473052046a03095d2d06cbd4aecfeb67c853190acf4b781c3e173be38f05a73abac9eb310a3c9ece3c21647ae1bbadaf5ed16e4102f136bf39be98ba361496546306658658359bdf05d0ec381391ed36bd5d7b9ff7f8882cef81c1e92f619912e0761e2649b5ae0105c013649f7defb2233b8bf402083b5cad0513cf79d109304f558ba4ed5e679d63723cae8f0aff0f1aeca03aacfa06a36a99ee24059d421d0e8882988521e83b803c3b4c239b08a0369dd81a8bf7a6d2b09d93bd8d82e16527d3d5d29d5cae3531e63c8699175969ec5ace9733e98d84f87f17b724ff2e6d729c76029136db417231a622b120b60e8fd5a3aa017dbae5b394c458a5dba26347f7e3b45ef95f6bc406cf707d207a14467770da7db7a74990cf345089ffafe14c9fc80314a4708d29729a212651bc7d6552842ca4059a12417cb712602f221f240293bc092749b7adbecd89ae5930bb5cee48baa86fe201ea228634e1a3d6eae406e87a2975fac3177df3e24734bb77a45230d0920568db46a5db7b3e3048fb108130d1ab373596e6ee56453a61834249d93e51a75ccb112410006bb9de28a6616d078eeb196543eb86c15cd18f94e9725f9b3d46e8ac365ef03c5c0df86abe9a0c2d9631d208682e847631ed4db4c0c6131db01717915a6be37896a539d9d482b45cbc84c6fc4f7c1ac233e60cab40c94dee1a60f2afaab0da202c2a9ab1c9a825f85392caa8339f83c7b0ef55b129be27fe28aa6c4a34bb86a57bf1cbc876af0f262fb23fc05193ca593acbf4596a1060c5399211116560058a379aeccf9d82da129f507fdf23c29f0dab7901ca226d786326eb4799910327c72bd8add9878fcf567c88c5e21193165cb1b5c000f2605245a1ab1ebabf1704be79b438fb605e0f5287a94868104ee51474504a9daabea5960e7b9388e63b33d886df68477e15e5d0828fe83159ce812122fed1bc42b45d8a3732d2e883f97dcf4c74e780b6bf1cd3d0d898dcb25520bd2809548d53c01d9a45db7d816e3699ae121ca788f0fef06341bfc87b3e721789886138166df348a751ab91b674926ada8fe882e98bc3a051a19892868223eb141815f3f37df7f5c5ff65eda14b62b9aef90abc5bac1b7e7a43779837f8bc5bd18443c8eaaca52f79e6fdcf7e35310c3b764a86f81673c429abc3e3f12717a756f5b782442e0700eb6adbd21284227dd393d48cf1e27ef9372754596337fdca131780565148dc43f396e5f082e074396c6f1d621b9aa0554b72389e597e8f8f36de5faaa57cb72fcc2a2eff13ba50595c2fa9276d94a6971e0b63845d0a01ded2037ca38b09e44178a930cb3091340b7449c886cc5eff30fa5b4fe4a2af828782ef675c4109f69f669c2cc2a3903d55c525d9a0bafe2545c78d094690beb928e2c179cbbbf5af03abc21de4b312f1e86b8f5c18988fa88f805aca335510bde398efbb1bd76b136bfd38f8985d985c7793f2b637deda5c1fa1796705653d295f4bb7f0e62e607be00a3dc374885d914f430a4cd5020d542301d7848c0f0c4d7acaa1f38f8717306174b61932f2136997d3b5967c8ca9e3a972b78b9383310adf179c66180614f805d54f125f1a6c62bd9de1693008341690b30c7af4bf2c482d1377c813b7994a97a13cf97d5ec4607a4572baa391497b31009262821b0a991e7aa81dd8766643f7734c256c8898f6025d331d97681e8026d1fb63af188e44e9ed0be8e2fc56d142c8f07f70551b545cc2e518c0bc1a5667bcc6ebba0d961cf11db692663674d0ea99c4183f8563a75c8633bbfa20bf3411493d56f4642131ab2dcbd5cdb6d7b37a673d8fb628744350450cf7999bff043bc72425ad1ebc46ec8642760d783ccabcafb4592ff924e38cd67d11cfe36260a3586b9bcb6a61241d0d1ab928cacb5c791f4e41a012c28b8fcd13fbaac3a5997322893c8033666ee606c8c9f938bb136329dd675592bb3ee395a53bc363eebf5b0dac14fe78f701f672fdadbee24e634040ef0985a86966d55acb7a2ac48db263204a71ffbaad6b0e1c0ca4ab46e3c171323ce383138ab4a5cb979c74b2b78c9f38303920a57b6b684f9c1cf12c5cedeabf28b0a31e6ef4edd815a4d1635ec236b62dc89f1233813c65b2c87a09cabe6278c6fb86a6c2e77476a3ae8f19176266bec3667ca96bda6c6cc1f3342f0722f92c7c790cf84002c1f0f9d35550a366a0c551129da9539c352fdd3d7a4a3db9967222300a1d15a26a5efa642de35d96f67d6573e88a4e118f0167030f7ffcf3d47e54ccceed584b6f7fc94d511d9e8444725b931f2f4a5a2e744deceeafd1349dba873044614b3dfa73d5118c6d714d07912fd794abf32bc6416a6305a1927eb41019c79864eeacc5215ebdddfe9cbed98c28b14b0acfd7114f0a83804b1fca50822db57e0f145d0f9449a5f9024c41cb7a2e91fdeae917dd30a51a717238d413d38ef5593ae51964b3a85048d845e2544eaef23186fbd53a1f7a86d526d11e87d40783c576dc43a3559357414b2bd2229dda5fa574dddd5a59f1f9ff401e4bc03a97d60c41b125f3dd25f333495f5eb50fe15df10d95c27b67f0c8825c61949c7793e0ac976b891a1aac896b51958104eb304f859983beab152610a37f62999d84c4e363de4e69271b7aa47f50908f087f70ec17cb64c1873f2c9da1e1b2ac5cfeb9a717db15802b226bad5cf0a10861a5a109fdeed0e36842725376f8901ce2b0edef14f3e060ac5d8e19b15e800f9c5c83b4e317e611fb14f439551b102a53a68e4ffcb376ab6f1e44d14cb786bbb83e22beb5ab81a3264334e431ca5efe4ba2dac46a16539ffa42d506a5301834a25ea4e6bf3fe92adebf020d54f5112410c1941e040cc801667ee52a9b39bc7b9bd386a518be25a36563f380c9e4fcbaf131b949f3cfea85b42c5b4b19d097cf369abb5405474724853f1af48ee438f2fbdbceb7806de09fb7582176a202fb94bc78591fa8ce25fc7cc2a306aa3248b17c6a587ace877c71d64a5a0e4a5b9aa57c944d750a78bf327f952c72c2b4cc92606b7aaa7ead0ba75b07c75efc136acd8dd08021aa3928cf2243cef6ae44d149817ec9386a49ad772cb7c20a9db681dc56a2475160be05632d0086a2f8c1cae567edf58d529607781bc8771897a5a8d0130aaaefb72d572e5027bbbf1001fb2e1e6044037ce5ea47db64c0e9a60b747ef94c7896c48d9909bdab9000c756125a49da90990f4d400c0c4a7c2d2917b1087ad39c7ea677d52d086aabe60ac0cbaa803efe24430cf116324a17affc453a2b1ee972c17dd70f1294e61126b0c08f4ca22ffb81bf97d29c2eed3bf0b8eb863d03e6892ada9c6a9768a873aa563fc9843562b701119cd3c112a072f1cc43b1c30e16a707dcea6e49a44524044efdb63c0db404eed9826235be165dc3a043239a80d50bbea149a6d2b5952edce8955d8fa2b434240c655d5452f4311b37181e4904dcd8d649ab9f3bbb8f2b124353950100f4e29b2ced78d9685b9d7a7595d112d3f679e0e9234de6d04ac7f8da81ad31c3303add6df63064179180ad3d13590a6063c76bea1cbb83e87d3b51b21b222d9026418ee84c076424e889aa5effcaab648869edfea879ded01b91ce54cee4229f9bf5ca8104c59dc742459798645953b9fa1a3ce995589f642da641e4c20993c0eac66cb84f657975e4126f67747ef322d01b7e57a255b5e75f703d267d6785c0d9a30bda232bf56bfd7e652aa4de621a067e898a5f4b1c0eb1a2531fe2ff4e6d51d0dba467b4d581f2a4e1db84378bd9f1d8e4656fced3ec42385bfd1c384324c154fe8fa823e9c66a58443a49220349928ed3257aec3e72620133e3dc5e15941c5ae74a687c599dbf67df28fe4cc26532963649c59168764d8061ed3e2e28b5ad32968259b60b8e852bede927d95152527836ab0fb3f6078a23d515df068269c559c042fd97b5ddafa0c814689ee2ed6a7ec45992d1ad57980d2bcd0d0081949d7d0cf9c42f286f4bea790ca43e65360a6d7031f34b799479e07345039934dbc633f4a6e4025a643245c967efc12a4f10f5d4e07b021c86cd37221e5b93d05228b1c40421420f259962ef073f310bf3504466d5d297472f5fd9c5122fb9754a8f4b86a5d8740a702f341f3ddc195ab69b1ccc5f2f5daccc5e1f2d559bea87654f2a23272eaf255d03299666bf879b029d20e18bd6fe130c3a3b8a243181438bac8e56fe4170f84974e7fdc7bcc2008f0e24c3fcaa0e996b4d0932f8913b3edf87b66ff94eade0e30699aa02f634337eac14c41d5b52b6e759a043f288a13af11fc5667c94d1e35a2a85e0df020d63cb059f4851f99a795dc2133bfae77b1c5a2420e18547353b8475bc8f4244b5f2781754ddfa39e2d435fe9893ac5bbb0035b8d258d71d8cbd011e57cc43d22d28d1584c63bd9d578e7f468fbe13639afd673b07a6b710fb4b757ba0944cc0fd7a7f9f0fa12e608d81898c4e50230fb1d7b41a4080f576b04edde69e98780b613839360ee2374002b62808abf6d512307e327c9e40f271256f0e0124ebe2e91b8c369952b56cc679e14e1168cb165bc16b251e973e7886b581071fea2c99fc5b01c52cb1ff3a07668ac21343e3558696cd5929ee8f893e6c2991dde4ec6a5fdc1c9cec92ec867f0e566256ea0bf1f52fb1f16a5697598e6c41b68703b8e3185babb637cbace5c79836f32dee14921351a097521073e0776d2b59e213dff188e3be15a112f9a7665914b1eeb7e78d7557bb86cbc364236050c797720141f1bbd2a013d414e624d65ebbbdf4eac0a113a3059bebcae03e4a8c79e114d084e9d97f780af518f50db67995fc483e68f8cb4d7a79a5f87442f1b8bcc9922f06cfda8c43513528e7f297db3b683a1ff256ab78fe6471831310c52fc3c8fd7ddec5f3afa534592967062ee4f7008aff547c6f8a6d926ead1d5eb92a5c9c92ab97d3392ee8d84a6918717e384ca8225b47cf7e9a18984a83bfe24983449952917f0e6623bc6417245dbe55fc0318ab4c2a7a1ad1d9219ad813a473e55a191030de0b06437d1c4aac376411191fdf6660cbbf0a4a7404d40d6a68f28d67b49ac2820ca7f0f7c013f050debce3e3e38d578d1f3ffa20ed3e238c1325335549fe49dc6ec66e349075845964ce8324fb52723449deb7369d271f911b848b12f62837c77dc934e681d7f8f80d72c2dd63b936d782c78c1a6967e095fc7c51a331f33b79df1b709540a38af5453fef73ccfb45dc9a76e8212a426d4e0fb95c402656471c4ecc359211c1fe8b0621e98dd76015b8431b9ec0271cda7573bd8d841b43f244e8ab2e3ae337bed59f9eefe6d0b4c014cef9821f7a1f979d61771fbea382d8fd50292adf447859500eb60362da770c7652b51678c90a7a1cdec1de941125f80a8500c62bb58353e6961b80b79ad23349fe0a1adebf61666472af2cec8ede55d7d28b966b59932bc623363bddd67bd1ec3fb0e3876909bc257e558b61a4c962d6af8e8bc9fe0cd9534722aa1901a5c465ab7737712928fa50099f94d23051c57db2077275f342cf7ddc12c81cd4b3b64f9f344d4ed902367e9543a77a0fe0c6d299edd9c2ea285eb4c520fe3f8c4471c85de1a9ba918ba570d60e9e5403df344b853b5f88f243a39e0096fae5903a7a4d1472255a8cb1dac0f3ebd123cc2726fdfe30cef69d6c25beb8de0e5d56986c587e18d20858f9dcbc09413ace569e192524d7a1005a96a740bc2b4c9cd8ba91421f53881074e6120c0f191012cc3e3dc8b64537a448ac783a2232af4f23dadc37b7cda66e102f3ed7733a14c9349b44c0db040b18d6f08e838003301769b3d264e520f78d8455e759fc96cf2aae4cb5ed1b191b856ce27d6096e80c242eaf1ff39e854dd9ddf57bb6638bc3bbb770250ddc69dba435af31f4c88a4d7a149cbf12930683acad7af2ed8a71d26dd9ff92df909d6a26e14c420ea85647b62521c16092a0a3a155be3fd63bf861eac1c5957823293ba5ccda261590d50d912fca321ea7619de5e2c6b336b0a3c0239711821453afa5176e79d3edb2db96933197f1f38200986f4806038179c13f67cf16f9220bcc3c48096dfad237e05da9a9e7f5d5915079ce745a003a1b2b4e51cffece3ee640b65f3ad6741a77a369cd6be48b6614ef2818636651d90e9aefd81345acc0fe2ce59eebbf6bedd2526e3628fc13ae74214936e3e90d93ba0c6c8545e32bddb5ce5910e7fb7c639eba45bab10e70ffce5e8e642fa9ef728c5ab8717fce5d939197b9ea67018a64c802f0d2fc5cf545df3554c0f7e38c1a5bf6fd7054526b6f4970120656411cea51cc56fae6cda1c971c2b7b49cfe4fbe7e1db2d2fc84aad44b839d446ed407a1b9a693cc1bac9bdd93f531c98c5509f322f1de230c483d7b10f38aa5ab346033a13066e012c04ea5377916d70e88e942686dedf14d66ed1f187b93cbc5f57b5771d9be37ae192e3fce96c547b570b2a0fe8e0c460397eb618591233ff2e4f26a1ee289a617696254e1be7f4f349f2ab5ba94b89d673cf4acf7a63d725a2161930981b9de49cd4373d4445e406d5eff52c611a1ec4d3253d58d797827517d9b3420d20f86406078d83d9c2617381e56825083c77ef6fd139f18bc8815816469e8ae18ab70edd47583ecd24363bd634b2c444197661087eb52991149cc0c6d2c96f419e79a07cd6e36a0f7b32155f2990c6c8201266d844f21b7ec51f8a8bc69f00945cf827be2e56dc158564176b5b7abeeb376f0b6d0b62485d59b786b403e582ebdd09a084fffab82c175496c9c82276271c7cd05ab6207036a1d76d3e40b6911ec75904e17c0f9427e62dbe542a52fb58caac0c9351fa256586d6dc86e0b3ef79a18a5e166652b540d68c39b70e7eee64abafa8123a0499b5805b8fddb780a8de68304ecf39d4d48691ce21041775c4308da0c6d45b985e982d5b60ad9b576f8a7876ca800cd0810c65019a4784be54af61cf2f7588063cbb45138d885cd4fbe69277c160e21aadb963d7a0868147feaa2c852538840034040fa270a20dee26e37c272dfaaccf9c38f6c6b0dfd065af2191fb02283f41a041e9a8b0eb9ba03eb50ed83617fb4ccc0852e3a63241930e27b58aa3c4ec415c07217071948fc48c887ca51f9db7783428d37481bd2e0242412de012febe0d63218f58f05d913e0a001ffa44c4bd7b8bb9916c1487f8c91c0973211a9951cab2b56b0c341f1a5ec393ea0af71a3bb25011807eb26cdffbe192ac66940c3d1d867e77cf23a250a70239ad4a087520a4d88ad69ef95f78a3aa84f098eb800f7c0f9078c01a1c7ff2794564d3d0ad836fdafa917b5b0c04a64b20baec3365cb04cca3c73d832f54a8018f37629c54f50cd1799f8b58e7532e4648375f9ac31d92ce28bbc91a535f03c9963db6b610d67cf114a40b7f46b7ce1646cda3fca9f641eab4cf714c6b5fbb06b0f4edbc5595cfa2bb6624a9752db9ffe188c17263df65a21ee0eb5c41a151c719601b05dba0c97913014df41152bdf88fbe0f7f6295e88f5d71709187b4e29f044397ba9aa71230ce031eb9b736602a2db1bbe36e131b0bccd968d1d9d788f9390e148e4bc756cd5499c79ddde3110e9e2c0afc632829fdc86b91531064342fef23a67c8d2201938a206238d25ffb6e4d9756020b0137a7d3e6ea52392f3c5471427d8e39721f92ff78f3246a4e7ed398a318e460df912a4168e148abd3411b2c58f3169be305c04bcb114870ca06dde4f1105f4ffd88ac3367a4ba54bcd69c39e63791e2ffcc8581d6a5e4068ae5f8599fb67085609cb8efeeffd15d9ac2ed5112d43a60cab6724831ca2cfef71cc90e5c5734a0bbcfab38b486a4be91e2312a16faf6445437b79d84ea875e38fea4e92fda30d9acdf9587d29d8f39d2bdb28c837e91da0e8ccab3aafb084d73b87c41359bc7b431a5f194dcd0a275832d63adeafd0ede1dd69004cbc70a2f7d56e3d6098bae4465ca97cdeef7d95ebf8a0291bd303436c8fd6b2f421a7cfaddec2895531810913e22ae74b180581a0e08754fec1748ba79289d1ae4817f82ae5e61f2e942c48df21d44653073c84df72d908239d218209604b9ea33bb27a5309b83d124338b71bb13ff407dce8641845b72fbb6b188f1cf8bca6b0516000ba5e8ae95dbfd271b1878b2b76476a450d849f45e038c1d24e3b78db098ac1e3d796bb421cf64c37f04aeb6754a923e6d6ff6a24cf93a0d6c0fa89120fd447f00e735f353163f8255c2edfe4539c962e72b3eb3d0303763fbcf3fc7f6bc770617ba09f4705d0e39df36410940a788df0e15237698d17fd7ad7c3da3befcdf4d57f22bcc822560d1953e655e9f913df8b97d8dc824170649bb2af6bc261de20aaf34ade665aa9209ae9e9c5df323f1177079ff3f2aba8cc67f27f709e73c8ffa092c67256f4d352c856a8c0919ddef9cfd16f3e33b2dfcfb48822cb38b3a120e919c6ed3a2af461d697e378d0184e8410209e54e51fb39aae542b2c8daf305e86e255b0b3a83c72bfc8370eb961a73a31f39a7db4bc9663c952cab26f7455b6dee8fd81e22345c4f8228a2820974f833f82e9e3dd2fe2a0af44e2c41856a2803a8f42090939e795bf6c753eaed114112ee00b15f034f2976aa1c0ce34c6069a5e5416d0d3aa91065871e3d4661bac2bdf24b6faa2ea8d3fd1fb0ffe6d986881f8731b6aa442fe1212ab1e1946f0f4d3a1f0c407fe8293f06fe71b265afe533085c3b3b1ef8530f8577265031c80af2f08737d579b6fa145486a39e34a555e962043e3b179bd238eff5c6081e8dafeba0c044782df31b9d66fc59b7fd8fbb4f4c508401e6f3ce408d2514f5dcb159de86ebb70d12146022c143803d1f4ad2870a61e3e890a68e7c1fc9d62a36a0426d1e9150ac6171f67a38c8f3ed7f18ec182203b4b295d343519d663d3cf67f6809205baf7fb0fc4bfb31cf1fed042c9d3c15bbd8089fef28430b17234bc86ddda440e56873f956059461534da7ed4856b61d6d1507d0b45082e02493f3e853aad95eb43e94fdf020b242458d8328a3c080a04c1b6c4e6890251bee79c7b871c0e140f97c04c50f58d665002b71adacee95ca32905eeca8eb57046cc417ad0e6bc94ebcb1bad1b4291963b151e56892645c0ac66afb3d9e36a143dd25bfd4377adc0b083ce07aa5731c5270988c5f02d21b94b10a5b5542e1f42dd46f1aee3eb57128d4274bbb92f71d65e25fce2c4d78e627eb051d25364076fdb362a2c3f4348cd0b1e0d1a0fe9292bc15fccf76851d457e4c25fce0a7c1288b612b2043165f25cde210eef7eb3f02058ca12b06e160a2dc3e2a84f021b850d877f909351026b7d70d78256f233255762802cee6873dfa05d9761f401068bb4e5ad57107b8b8aabecf9a32c42ee365effa058b40423e3ac8720ef0d441361f47f66104bb27b11d7dae76eb66387aef788f84f1f35b6de24abea06fef180c925e304476484b6ff4e55bfb11737e6a85b54767ed69141a4b38c6b1ea148c17a71a6b4d6d2738f601446abc9a7556a90e99f0e9ebd0f68999cad13ef4324a740bcac0563e36d9ec2c7bf6ebacf775e2eb9e932a70233f791a38fdfe6a6f79fd89fff154746522d227b9dc668befed0fb654331cc4afce39c5758f1297c6909c952c576f1f8e88cd4a97a721b10fb39dbd02b5c5e46919b747f9d1c4905ff753cb2f52127311ac9b966ad4bb9ab51781ff0b80520e88ffff2150b2ef07f0d4de4bcf8d7d04f9548beb3ad0d915c3b9d53a0d890d75ecf741e74f83bca3e35ed372ea61ec273814b77d2da160002acddc52a4cbce3c59851b6eea8b95735c9047cc4d068f000f63f2dc27e1e33ddb2b289adfae03d1e0f1f89c40d340122eaf00bdef4619394019173ffe6ecbd124a1f2b5f1401ed041883ffa86e7a089da5152ff04b3ea45d80e3c1699f29f3ed17e7a9a455c991a2d18c126dc927340ac95e7c6361fedb9b454e6b76ef6203f34558af0b057aa0803e8fd6aa28f64ac17feb761cb867a9a47432f51a84cea867e6050aa292e7b48af5dc4230dc7019345ee46a5a0cd610f401008c0d26121061157764b60037f2472f05cc9a444af198c8b0265b8d0a75aaba37bcde56acefa225cff0bb66a1c4a2d39964d650a994b7d21780f70e5a2858d6ba5d916e72672a22f50ed474d6b4aa41dc2c5197febb04f58bce573a2092b349c76165deadd98c064e3e3eb8012bb13bbc2e474c9c0da075dd446341a670f33bc813fe6139b99a09013881934346c3b254fb03260826c5af1aa08a8b53703036836b1202c1a64d2f4f48ca9fbbaf3ee1882f24cf2981e17ea494a1a076edfeeb34f1cf15daa75176625248e670c2e586ed5cce9557a3df809895c9f0c9386592c62f4ae9ed780a0e301720de772a00a80b73ccf82351bf4ba899ea9aca6dcb1ac220429665b914ecdfff3cd565086ebaf191a4952f1ca5a4d442fcfc609aec10f97d8200ca5c7a9278e12c2a49fceb0d8902fab258c9b4c661284a04247565ad1c34d0a5945f63ee57bbb9ce1525c0dd0c7630bae68696af43f9f74cff066d54576ec245fbbf4078e37f0dcb2842bdb78d9808d826ba6700aa475c69a82b8370a7eec20a4472638dcdad5579f3d9251daec66a8d39e700685e85fcf973ca0fe82928ec5283ad2f454fa738a3ebaf30486aae7907205b8b10f5ceee00f2e8549356e5649d4a549a552b10244e6218e0a864b2631305612dcfe80626e62113bba5781e9e2333498a7453b9a69675c06b46d7438b1e13685f4859accb0d722351a63bf730d7e978aa422fadd6a34f62f8d92ab08834c38010a497d3f960c2c01563187f629b7a84987c0de39aa4ca222bb5b0e5a0b7d89abfde3dc56b1a4af6c63023b860d31118f00d46a1cfa069d9c7f774226bc6dbe52178e7f26c8613bba88c430d1af7f364da13af56a66e1256bfc36d78b68a395559a657a7c2e0a1a86343d6ef3ebb61c61573ad03e69f3cb0725ac63e54a33ba450c9e4d48e1583c55a84c33706b5a626968862099390c4ffe42ffb6806b14c50177460d7ed6d61e0aa9b6a2d5a6dfe63334839407799bfef169ee43a86c00f8f3683e0e7286a9d255bac000b0c725f85c120431ae1a518774215e98de17617c20adde27099911b98e88b79be7c3668ba444f43d2d330fa4ed6425ccea85f2d73f04484324e26a13a2fe3fe98b703c7bf09edf49c68179588d4210949715e3372f44b3dd2231b41403906346b3ba7de75aacf5d02e363848007b8bf19c649202c4baf87f9eb05c5eca42f8d1dda366dfdc8e0325bd41a53ac5bb36d68cec2d350ded995e647109fb3633330bc7991f5513007e7c64ee747b371f475161d4b1711d733d022fdb58655b7e9f6322bfd78d41a09fb5bfa2609f752f2e295dc67b5875d32ef9b57f116273e6e935483380d4c835a125354776a9b785e1dc5b562c2f98a60f5ca3d832d7d4922ac6bdf3794f796e650c289e7b926c5d701d2ef394fac5cd1ca51fecbed90529b8f0d465810cb2389a579f5e9cb1cf88f4f6f55f93a9d6f5f533c636184ff2d6e1707f8d5dfe90949d25c85d7611ca839202963df5e57366a7b0f7da49985d5c1e0c38b59d27cd48396a9535a259c83da0322642b62355929bb73449d65d16a987b8ccc4edfaf7d8ccd6bc08abc67af8f4fc7bdcf06566712da6475549227fc3391382a42769fbcff6f40eaf6595630e4bd28a6c4aa4e98167ac4625123094da0250f80f29a0cee388e12730d7d59afe31bc8398feff51e8fadf13990fe79ca7904ef2412e49a8341be50a4d55b021e51f7a36417ce45c9324f1292cfb334c6aa57e940ea09a629f46e5b7f9ce72530713385c7436f6426f481e37bb52627ad70c175f7b26b1df26c158022199ab7c4c22e96b76c8773c209aaee30f2552acbaac028768ac813a78e906c9b6ec2e87f0f83683ff7d22ebbcb92a33bddd13567ee579fe3e4da4815083e777e99db4d81266ba1d37ce1c44586fbad4502c0e851ad5df1c91e9aaf1a235a1bc2bbb5b14f9eb9c65a3790e9b4680c7ab27505158f65567f871b77df36f4ded83229ee25a1607a8e2e181e202e5cb7289c09d334c49c47e0015242a5f0524b4dbdac8157e9372df39dbebcbc4bc1670bf316aaaf8be6918bd18fd8a565f582664c142e15582d1e8072361804b504adfee63a84b0f415ff69a9d1340cc54ea35da226b4d74ac6b027f22011a3176c0583500820772fd09ce7c0369191d807f25fe8b5cc9aa75f1f842851bb15380f3aab242efe31b5dc366799f78419493a30d13bd3ac0ef6d26603cbc034db06f22aa490cdc2358cf3e1f95d0ec3e4baae6b2a4f1989cc3fa55fac1b98bf32471b409a7aacc145ba68b453eb159c8b6fe52a7dfe37156ab61355fa9145077f5b2c1b348a88828f6c35cc720bab86cb913f74d57f50a5d478009f6bb031ff5b6d759019fa8ee335230a92e69194ff5471e998b2105a8d6059eb26bec292f3150863fb87bcade913ffe026fb801c9a8185d96648edf2098779b49986eb85688c230b4c097b84ba30e8018fecb4b7c4f9fdc72a1c807cb46ae84a2474a2aecad69bbdb6a3736480cff9e4994942dcfa65e7867e0bb61292cdf99b6023800c3373878293817f072d0058d6833561da2dc9f871bd8bf50ca1d09f4bf373856f48b3ffc56d3eceb54571468b8f5c59773353c06f6eae5c887e58de44d31354733d611a05eaa8fc9402ec6d1b6b51dc104da0ce590f1c4e98a95f83773553229b06dccc7df8debf64f23f86bf3f8a10d416681374ef6df7346c0bf7d634d03f1c88aab4a5a35195f712b75f4f5e4b609c04d0a19a3d625e18ed6f2013e05b430233e6cc71789ff21ca6800b7f2524e3ef24d2aeccf6fca57dfd2845f87ee30fdedc01dc6ae3135f107176a3010a488aadf49706bdddea79c4c0af3e26b9627dcef5aa480efcccb5999ae3ad8b6254c60957e16d687527202bc7d9777d5811723ef49f691131cf9386d5ff360ae4238c95d0760c7b1ce565dce5bbaa96e47b772d545428c720d6d59f1dcd54a16263bb5c41d9cf7254380646ad8eb461646d914dc91a8695c23971ad857e5d07aaac5f5f87d56bb138a1297e52a8ba3c54a760ba49e4a0ad45a5d26f6307a5f4812ff3c1d8baa604b8ea8b9aa15c52307207bec9f7cfd8fa42f61528c1be351ed85ae70301a4254e1186e356612ce72f703be78deba54a9e82d51fa59839dc34c4942c630289683f3e952c5ad6f48413184e55dccbd7e65bfe6ccd94d5bc8db3d945b0d13b55ad6b3f65bf60459af01dd9b9e09c50e59a3b3314abc5937e434f8fb133d35b1ce7098092a2336dc0d31acd0b98effed58f23d96c821dbc5302ec582b095b270e6c82938f29a92dfcf4ef118b2a5883c9900dcec62251b946faa4760d0a78d4eebb4528506115bd7c0210d9615300979e33c069b6fe251827a80cad556700a4c410d8246a7ebfe1a7cb1528389575f9a700b74585ad7f8ec0a0789fc5937980a3bda60aa839cbdf0bfb7b3475e61c6928a283ba95cd242a67d7faaf628689119560619d2a48bcbe04231c59721b5b849bcb42d888027373bb97bf6e77b8873a309062f71a92e4edb7513906d5e038e6ad1c24ea98fb92b0f8bd6412350236b0251f8d94370d9a174112dae28e241045e67915bce1f0c3e2f3a72d338d2d29e6b2ad0daf8b339e7a807cf5f3a428bd1238ec916885ad00d14a09f1b60feacef6c8e68e7f7922469f7c3ddc27d6c5c78de84505bd402bf97c3e8404f43fa6bc3ff81bde54f7a0ee14aeecbea46eb10399523ff7078911462fc15d1f52fdf25f12f519c5ac1215e93750d7d62a677087906261cc322991c81e300324d8d1aa6c0651a021af0e2f260fc960e2f931ea71dfc7c881ede8fb310bb2b9e259c7931313a155a60a84a93bd4cd65bba07a5d47300c59335a2a3905538e5a8d348b6a1b2ab4043f8106274c006f39d7da1f26c6a7ddd7eed1913123282dc2836263d75d25d3893db72cd2b5120033c122c39a8448471b7af471def5135abc893eeae679b2386d01e26b84ee12721e6fbb8a3015e5e3ad12709537ccf66bd9b6e01d9283a64a56892b639ec13919041b8ed19d4e6aaa052f7c9caf42fb3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
