<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"740bea37b479ad273e09e95a910163e7f3fc4d654e5d1c9037e1e17388aa33bc576c01de7d3b8cad4b71befa24162da8e27358fed6cc9e327e71e0c09d9a2ca0f9e00f79f21f67ba00068e6630919400837016bfed6ca8ef69a21a8523230713453749dd2c34b0959d98ef2570932e0269acbce9b436fc6761551406fc205c39bd7cdd12c64eb89ef9289e13d9a1ed25f9573804c80369c75bfa0abc5a17722c1bff492e3866582b3a181b847b90bbcc5da6c8dc4661287021d20c40a4ba90855a6b23817efd67f1f03bee92bdfddfc6a0c13aeac70d4022f0fbe2ec9619951a272a129367bc5c488d0e548ba7665395a74265adf5a5ba4064b939ff70be3fc1038c467bca887ddea0320ab534656e5722b554a21cf1a010fbac7f913bebebfd04d823aa4d53891d2e1874f16028260ae86d81724c3b6dfe91e900af490d7afd92275c6710ed70424383995905ad67b42405870fe77c52b90d1364184345c00b80ce22bafb12422abb50c6c382a15c581ab12958a5ccaf007fdb08578ed9db0cfa7aeeacf4370e0e1f50e0fd655d9a2c803d4d08f30b0cd4588d57a2b123c85fcefc31f961d6109c11f645711d42f8bdd48ce749cb6dce4cad25a09fc4159693d2fb9bd19401bc8190c7e9935d12b2757a97c8e39f040622f01d50617bedc8af11a638f4f4014d3f2f5c11e5d5721c21087803e8b01c6a0d3a6dee004284543ba372ba5a05569d3468ff237d5bca3dcf36a9f2d9c3825f83ad4af5d8602952def387bacaa85f265087bb1cea82af937f7a9d543f0647169ca4b01dab0e7273e64360658818afcc4a35927741d4e2931438ee69f2fc2e2e413b0359320828bc1ea2536ce6383dc1230a002c6fa99c146fc5c7a7e4ccc7932b02cb0525b83f676aed5983ccd5e16fdbf637fb14415ec57428b8a6487bfa97361c76fe26ca82bdc41a2736fc2d3746cf54c665b3b60e2767951d93388f8d7f33e2b217b98632819cc697acc93dfb272a85592888513ad4cc35a0f86500dad4b369943bc51ad779f0b0fc4bf44acd5ea69c7b6685c51dbfd433bfb5724c185b36be485e49688f1fba3b03a29e30e9382d2abf76d21522aeffe26c514c1b19985af949604be8889b0f33f59a3775f437feaef05721defbce2bf985544342e479a5765bfdf551021ff313858c8e804cc68eadc979f9707a3f7db3374b23a123b2ec6274c476ee4be9f6d7899c518729ee1a2a858401151aa805d4a9de7106312cd61c8d77dd8fbb61a926795117da7a745195f579ae49f8515c20b4839e4d97cc9ed559d5b1cb446a53441858b983b1d5ee5a59f900a63b698e9b18791fea5e58f33914f1f7d9f3adabaf6ed3607aa107109009be0b400bb08d5d4ce9feb6699c5c7ce5811a92fd51324aa3bc33670d843d1019d88a1d849903b25cb6e3d6a7c8534cdc50e57c994a0510a62aac3a1fbc5dfb27e766e12e9b81459a275ea6fe6dde861e1b148d3f64e4708767ae42f43b3e5324ae741ca1d10f5618137a08a32d09affe41f3d9a2caa7fda01accc541da4cb0c99ac7ad0f39da3836843f1ebafacb3cb8bddf20e0f149502a57a8cbf04016d8f43bec9b3c40dac0ce15d1b8daf908a15ce05ea096aefe4801278c4a1d66780d0468f1693865f008d78b1e93590b118db2f71a3623c2744cae2edd1d6a6c70b8c7def466872e7ae9f79e12403d41b54bd60642fd252a3da1538b7e4bf747993827d95d90e3251ba5441ba8201228b8ace07e56958cdf350ea3e095f8a25d9a7db8f33b525d6c120ec6aa8d3223b5dd0b6253c3089327766bc5135fe7a652a1e1f757e600c3d9ffafdf477e6a718ae56bdc6cc48354d2caf4025279cd20dab6c74c506d16d7b784ea2a08422576e38a9f428685779574ba441abbb0e5327a22ab1ba2946f600eb2a3db752a9f59a65d9f2f9f471d0cbb26c4dafbd66166ab8ede5df8f972c768f4b56ee01660cb61f8e8e1d96ee5fcef99b39c094e9e64163f413a06da6982c5d16a14a3c38eaac02002b52f33012a6fba03d83373de9b5681d524d448a21f1a6f3fb3b2be05217ecd62f3433cc2f4c3b6f94fcad8f8dd0a0553a3f909bb22bd72bebcd1fc7b6376f6fe4a016b39968a996ab866a87f1fa5a007b50a33f7c3ae0d797ba06cfca143b8d736a44e6f43598c07329819d935dad15b823394aa586dbbf16cb72d1f19b156b7f0a4d60d5927e8abbfca7033bca2a497464e00632527dea72044f82008dc4aa16ff877222e154d0619a770764d177ded9b04f54788b41fcd2c76a6f57627ff09c9b6b0bbdcbfeb75d3b1c71d184e14fd234a3f2fa44a445d9850274d69a46a1c22a4b496ac4b929b31fcb73779d5666b89832b8a315b339cd4f493ee4258794367bd3166f6bdcba0d6efaa22d7b809e616e91bae4bb45e82d5fef2bd05403b602c1d998a324371a60591776f49ccfd9a90488aafb9a8a276520b5f69e286cb73785eea59915f050c83ef89cc9c765e7790878af1a0d79287d6b9325388c9153b154418d4890cdb6c7c9b6ccb5c87cbdc1fe2bd5f80783a479621a64c38bb53c3fa3edbc63c7a3d9131ce9c2b80d800d479591b63cc07b4bc2dd285c9ced07367da05d92e47570239a3f70f95eedf8c269f832709e712f24ee98c9939932e61ed7edf9c5296a61de977ab34052c33d490d1cfc19a4f1d8afdef7455b097886054012be29d14e808530dc9aaf9f6e7219530389051277ad618a74b5b2ad0375374835fdfa02579c35d5bcdb2a32c3df88073119e11676641e2b50512061ea200083e59b9a7fe6ac06ad4ce18edff450b25c19b1cb8f6bab41fa95dd05b1f121f7fd00e2a1d2086f389f6fd4f84a056e6607b9032a7253c5227a625a9631bc6b126888f8bcac6cf595de749ff3247e8ed04ba311d1e55b133b8d4afab0eefa19b6a1c8e160a70ada0daf4fa6660dfafa7067c1569258e98751dd08a9d16c13908987b53e11184482b19af2e78365c61c55fb951522c5c67b3b1f3d22950dec091b4985bfc606f4d791a6f09fb99c6e5e1d791a361069dc612dceb22e1e88c02bd400f4893f25f34c0725049e90abc15c8f9e9bbe383dac8a940db2613f1a04fd95c5350296fb459d7d4a43b81830db79cf8d700396d285a393a3d478ee06f5d8b5759fec44a5ef53f216b4a9064fd2be5781593610665dd463b21ff5a28a79d3afcdf07b19a4881b8e3e0abbbdb4837093151111d03885cfc4a56e4a024861736eff369ebd9be73b5b836d6b1f20d85f13d65598b2e9d9cdd893407e9cb4705ed96d87a684d354f15f1fd6f409d8836e2f7f05083bda08fe097653319a79f7614863ef194608f6cbe1404dfd80b94de5917dc4a4141021361316f25a69d25436b4ae747051766abe9e2562ab891c6a355c3f7808f26bc3c950911ac8e7daed5aa8280164d8facf92383168b03b5545d2df38244a2b9b6b8c3f28e3845bc68d2ecac8ba07fb588831433531924f055257453f9a8f2a5cc9c4f9e5988ac17014b7988c98ce2d02e6266aee59c37690b334e06994ba4b1e412544ec0895138005d213830221f6b841328a4f9b456b77561c8f2c8cedc4b2e66fc15bb6bd9c3a232097afb453adbea3246e7f0be668a3ab40b6f55ad9aef9a7c4e06f9b17e2dd5dc7f2b943cce35ad460467eeceb902ab8f0542b536639d32be6c38af53e822ba5ae685df1ac1ea59761162e46af8ef777951afeb5c1248d348939dab936eb1430b0d30bf7a7c76e3f26c0e5c83d0c0f5496e2c85ab9eb4820a73df8fee3785c1fdafe27cb8f6a86e2e322c23f0b382748b582ba69792585c88491a66fdc3ed745b018279f664483a12ab30625f544c6301d50832d330e3fab8eebec83cdd8dc2e9e05c4bd581d1448344bbd12a61a4fd224fb7be4c28eea5d1192997f8b69bbf1b90e766526c32bea8adc72df9f33288f62d3b8b4829035f117297304d9399cce7321e343b77fbd16d659c9372147e677a7465d5dc9ce005fea3a55ba96d8617ded8aada9caeb11ee5106f590d60d0ed2ef8fb6cbcd967b034e0046a4fa534f2d40e4db8c9a8f7063147a915a643ac641ef15704cf12126f85f7e5a58fcba3cf757e0aba9873744f56df1c09cb8badc75cb6685284a1174eeeee00079dc673a9679ab049d2d0d6e1c61b208daeb8eacaa4168bdac6716c08f4e97df1508ee5db11c392e6b1b01b2771580a37f4a14675cd38f30cccd8b279dadbaec8eb1b741f2409b3229f0140dbaf33cdff8ed93989d96450941658b2742a98a7e2e46e662d5849429df0fe53335b1fc72c3f28cac2f0684a0e34ad24f909f1cc1faa7078dc6e2b9ed8816e95e21cbf649eab4983991f64ad92c90c178b69f16d944406f85ae178c6d4f1c0ceb01938b5b5de05fed1f0a3b77b8af88c7e1bccfc25d9d478f02c64b7a27682d6e7a611415cded7d860031e7b7cad0e20ddc77ffa3b2fafab03be4fdde1cb7ade4ca315d69e76b156724c769b86168fa3cd04643699e4846a246ab4613fff920de40daa6a4a9f225541351fab7a9ff4d01daf202d6391bcb378064d42c8d71d1481dac168b18c2ac640ce33d108b237d8c16f10bf1da639887b30882432c0ca5cd9c9b784e2ff3b502a7a3deff496d6bb1030efb761ddcf36f71b3baaace9b465b62b7e23b05e07b1893dfb78f3c7c77f97d56fecec7bb990306f9d0cc643769ec8ba6154dc2d7efc1a917d1ee8c8c51a26701254469398313410410147916325da5f24dd582da5d4cf818e00844eb93d98a06504cbc10b860075514cfb43d660cd8f91a28c0a3eb1d26dffb8681c10afe5a8102f4c4b479508e7e2da65914a5aa989720cac56a7a9f970c80045133bbf72bb9159d81b120d10afa0df44c600f617ccdb31ad1f7c217c068232f495e9ae653fe71cc45d4816b137c163629c4bfcc31c0c9ac57a5c6af0fa88e25c0bcbb3757617ddf802edd3c0a72e8dae356ef15bbe4b70510842f81d26b5cd45d8374d9b612612dcd49db87b70af982aa57a774e114aaec17b158a4e0eff9b6d9c5ac03169744884a4d7e42a5ed13a584b56eb65158ef8168e1a808e416e5d1dcbc319c30d2ea470d5c14443c675c24faced055eb444dcae3f01f7e7fec4305b65ad0136dee9a516456efa94fbe550211de68359c500a46c6536a71822bd87207d8c1a8d5aee15313b1d730c0f4b5f3a6722c486c34f6aadb2cb01fa43a7e146b522dba0c76cbd13e5bc7fecfa8b2d292926cc9c8974f9a1c06e6dd5825a1f19b0690c49e50b6c4a1abe646c05eb389f789a4d4034efa3ac54e4a3beedd9e0ba1a0d635d42b5d432ac779f17741a780ca789cb42f4f1ad68d7cb3bb5e04fb6715d2fcd08bf0b27ed6a9a24115a221c4e3060241251ae49644f3b63555702b2c1757791b44be10fee2f8c44259793c23d34afdd358c996d2955f55b606c6687a0f2d34e0134c7c033ebb10f44c01632d5a47f06fd4295fbefe6edc93705f3852fbfa74cfd3f964c607065fe2df21dda3d0dcbb9fa807d7dcc3a6dd0a1b5762012772542f0449b861eb678b9f38c91a97c26b16329cd5a789d52a2ef15c3bb5df878b7a90857c3e368f7d6297878e72a85cd46040ab8f65725b47d2cd60e579ee473916bbb10499c1287eba2a29c2bfcd828cbe282e561a721ef47e47cd04fafb89e8b3a0ff9cb55140079eaccfa5564019fa5e3f286425d59dc65bf153273ae5f85a811576459af41eafb77c90be264b71eef78bbb59c3f63866cf0b5e6cb0ede17c6bc7c192550292e7a28651d8e397790299e7761be7d321e14bcf515cfdba5714723b48b5fa38b9461950a2e61d6d9505ce7cb090d659b456c5d5dc405202c974e71ecadad100623d701a9458466bbbc88ac08bb53374061527837a5322ae029b45113a283b187102fd3fdabf49b1c512108fc79d31f03a5ffa62fb204a06e238509f2536886332e87df7ab14a8bb3bee0895f4eff520fa5bb1a2fc617b6905614854bbd59ed0c2f355f9618b3ffff7182c7ee87372ac046d03cca3a3aea0a782f11df226473387cc049e0f5cc794b67c55ee7cb14de2cb605eb491d625889e72c53d6e91d7a9ca43b534a916153d4dabb0bb5c4368dac86e2b87de58ebad7f2639b61e40d615152c122a82ed963b9aaca92245a43366e52101956bc4675b6bec61733db232e5e7cdd570dcbcd4af260678dedfe45306858783fbcdb1ab46adba8a18257c732843f3c15c0474a03909976d7a009cbbd2a31dbd44aad8c01f9576cd43c585c9bbb5b7fee04aa064985b1cf250b6d85e74a04de9513097396de14ad3ebd1d3ba1c95ea4775dbe064f35bd5594a0df7ac26a42d66bc8f78adefeb0e7a7a9b1fc452bd87a86c31f6985eea485d9c4758edf4148c4c75f8d59013b2efe5a04060f7c8d90d9b12ead56ca77c89137d0f7026aa1facee9eb9efa1c1288e25a44bced6f8c72c564cab39986a9f5f464e3f6fd31354e86f47ba0acae52a13ea1fda99cfd5bf540564144031dc09290899b1564dff389a5e9b71f11dcf48bc0941b2d8e36c4688b012d56de629d026f007bc26b32b533000f3aca9356079f174a36e6a997660f42b7527cb341e0c87f5effac5308feb0a2d4144d80669fc7b9633dd3a86437f29e452f87a1f9e932ff67fb5c59a0ef94cf30f6f6f1ae264099c3ed9294ca7e040b5e48a267ff85ad86b8c2c44188d9482f83584e186dfb494040c3f4daea8123058dde5ce8d4c225066436b4c31b7427142d630dfafd41254da3cab55f8c89f7336cebaafc60d51e91e43d05e94e1a50806e9ebdd5c7ab761def2d969404f5e356b27b6abd9ec3d5b37dc8ff2187624adb7c6238b55419681cf64f8b37d85973fc1b49bd8a7b1369f0f6a7e20b951a6ec34af5af37d192834174570ddfd93280f1bf12341bc22b36c4b2fcf4f9181782c0f6346994e64274a24aa6ea02daf67fd7508d507437598e2c5be059bc661ed9da95a9c6ff7cbfa1b38adfcc1ed68f031324a598f4b9e307bbc65942d569f963b652a87dbc2b3fc17ff76ac064466bc3212580758798de93668cd5af2883d0a4b2eb3852fd5f2f8cb689334f333692f5e5da59f251ab565fbf7b33a012d52553e142f90ac8404ca563c53837aabbbc421f30db41d4a7264f800c5f167302336187e659114d0c16146276143fdc49bc7f7a3c30a60636349b8273ccf615aa8526d2cc39b81a5b9320aa700ebeffc60e4e5a1e29483cf73ddf6d38b1a42387c44d01443c74c5ff21fb98541c797b983aabbac2240f95acd8cba4a0e98608e0c4061a45d6edbb3f27413ce6e3d6614bc928f0349528332034fea94a2b6a0258be5f15a9d62d71b12f42027c4d605102076308ca8db91e6a85410a36f40d6f09e9bc33da155c0c7acfc61138237c3baa209cf82d7f6ba13ef948a3937287b7cb8c25f87b0966f3f9c96aa14e8b7c30d89518c51b5ae6cb3bd07962b874b01a8cdc8057922e02421e87287c396f10a44d14f55c2b656e9c8fb11ffc95ce0b42e8504ad4621502c58921d045f10bd295193a86a61a8de29520fa08623f74dc4f4de851305b94948a3d621e0175fc1938d8661e1846a0d906795f2d1681c5c6ae6d74f30fde156f72535bd2764f093950a13c921e21e799f90ff08385fb8db9ce6177324ddef7c0e88b4cefa6f320f605915e9736b84e4c118d4d8b240b41d55120e55c7cd993380459d431f8b97ab676231be4935088b979ea1245953c948cda4382342004d491078157f7c45b0d45317be569f87cd8e96c98c703ab469bf1cf432eb7073b2dc2313c57d6997f1f28c6f9fe36ec1185921d30f78089f1156af43aee033e37738f3baeff29cdd3b73e2f3d8a7cbbc4719843178e555b2dce3b05ace6619892f6ceea9dd2c99f11fea00aad50444abdb55d85ab314b0dd72cbae1e440d3091ec8d681fc0c01d712d43395ac67780422c71ee726d19d5bb920510610695d24768f78fa8e1c661d9eb061f721acc010fbde355fb10d37ccbfb1711a77cee9ca5c189e45acdcb88e77749c0b6bc5f2bcf04c26a8896e836b46e9a9d4ccaf5ae72805733b0294e452aab9494acb1644ff73f346dfa4a67847906253a506817276a372e3a28d70cdafaed5eb4c500e7d376c2b3ced7c44cefb325cdbbe90285f8ddeebb3570948131db01cf77c766ed1a2f59a82cf7ea57d50b3465cd0647fcea68db947c0f54e1d5b1bb049d005c1ae541fa05eef41ca595e4b1e7056e0ba6e31de99e6a201977f8b973a7fbc7893bbd41838f7b5b77834033f093d571022e63493b83a756e10947696cf681bd15e0711b0105ddbc9c1468eb91da100fc8184d0001ab8e2b71343996ea286d94f627ecb302a6a277eff4837cb81dbf462ed64f3bebb2d28181d44aa951c16f724cb31409abd6fc3dd4f1c6fd8d6e0444c131004c483c154ffe59d7057b9c6013f56844287d394dc88a4467d7ac851f310b6c32b1717845c035fa12c070c494836c70653ba3f9fc8b3471650f59a4429eed834ecfbc0cb8b8411ef8f52358b23436ac4930773c683e791155cf5e09d9a36996d1dbac27a874127541184f0385bbf5bdf92b3d58e17a8973e3d7a6c0d63257383434c5d5febc6192ff240c081d3f8b1e988d4d5932c6845c0f9986fae526af8776ddf0ea2af0b9a4bacf16ba83cd0f8935eee5d4d35993f99abfdedc1345a66131ddec7255787fb6afbd431b73a7cac53546aca1ca820aec9fae8a1563f8b12d3f6b6ee02e65d124c3d913861e4ac5a354ae970ea8d34d7d3d63c05bef1eb9d183ceb1c9b52f78e013b29a41d52961de98d6b8a63713c83f7d44ca0bab5dbc055c1a0457e227d7d7b3a788cc1a89800779ed8b79ed86f5cd9742724777952131c0270630b863c1ea9d4032afdb8f543dbe41dec94a7065c2f1089a7eea52544204546a0a5946a18b3096255730ee54cf54da62f9a12fc969e48d5367b3137da9d7575449dcd581aa590489872beaa4e2720a3f66386346ed44acf41b72c974e959aecd052d42be8def88a690735a07becec2e809a1b56b068fac096ab6390735b3406b201f51e5e5793a3906ea58b185a64b1f848fe165ec3112ea515d08bba3057400b07a3cbf75e2e532903d88e9e736467f8145101543cde8fcf00b1e1bd70c58721f6e79100b04261652039ded9b8a800b69dc2e21579dab3d8378964e1f919d160d8a4c3223aa654788c168aecb238f7625b1591125aec9413511065e0c28a8096adab8739f578416d48746ca946e25ff887984577d355089d23730a4b550ad5a57096d80a8631f84ec8efe5eb458c0395769ff5600e35f0e34f51a39bb9846d8e101d2d9a123c2b1370f6527ce87fa66acf177cdb87a1d115eaae088e7d763bd96e25a134fc7b0d204d811441f18da895bc1f0e8e896f13d1aafaddcf04bc8ca313a00650d652fbb02fb91a437f700f24662b4a9f81e2f797bf19c545bddcb1e5e0cb025270bd2596c1c884f2881a2b8ea9047a584bef6a1ca44f1d4ef264abcb390bb9b134ce6ad665fdb8a3b858bbfd7dd5456229e732bf4b1bfcb643c5e0898da71558ad442800146f9c3e35d24950f32c4bf639c1f21b08283c131ea2cae3d0f1641b2ccad23af45bbab89a6f53565f5fd9a35d1ea0d55ed7b0cf2f0792abd3227a52e0159254f71fe80c7e19ee3ac71319a01d6382ca20c76e66d7ae2c8f442971c1014e7f9b7295a73a8800321220d4b7536849298a2c21a5aad08f4071ecbc9b8f22332ca97c493f945bea6b8cb86c26bfe0cfe8398abbecc50d1d6014f4b14a0b72b6ba76526f8035e306575d0a58c42a77123e7c0130dabed9a2f0841c0408ab1f61236fb4ac4b6f019809b7e3d16c9b52335e061287264bea48def5293e250acf97e443bef8944a5ce20db020120f1869aaaeede9a50f763f35ad192b23dfa84a3419e1e5c5a7a8faecd407b87b7b8d495caffeb946afdfdc90216f82834404dd2329d7524074f660fffcfbb75f476362af9c5adf688fbd06912cd412348c226e4f2a1ab4729d038b82309dd13cd33afa91ce0ff834df74ca3a8e937ce9be06aa6e9bfe5f0aee224e7aca5e3bba4cfdc54d819c6d6e7d8985a68fd0c21dd60282f662f948e89dd10329ddfa61296d004ede9c62cfdc3f3fe4cc46363ec94d67a3d8c986890682902848f4c48b8afee55f2d6215e30a3cb7610a8414dca54ebd7fd5bbf8b47db6776d4d4c44172083f459f7a97004f017762369b42d1eaef7450762ec8bc7ff5075028d7ed2922846a5def2f26428bfec9f24e4359a3d5f3ce8811d91f582f34f01eaddb74fab8ac1dcee5643556005a3d722e8e3ad7442d8c4fa6feb8b1be8a1917ee777297433990800ca36de473ceb8dc3f204a5cd35a067ec032b9b5d17a6033d2a3f39cfa40b9c2b0e555b7f6bcb288b29bc6812466f8a2f2203e57eb528f7c381b93d175d5738f54c176c067011641eba11a032fa902ed3e8647dd57066a83f49fbe9cdf451b9cef7087e474cf96ba8e8297f1342bd7d467126044a89f2c48ee7b44f7b57779b1714e5c424f4723fb75372e07faea52ab2a82fed639701ed3d6ed2f10fd727b069cd4bbd2ef42bdf4f881a653089f8c1ca2e8fe25bbd41b15976e1b47f71d5957e8769fc58aef64233219c3a323cc7594f0e815677d0affe02f4dde4a7e6a9e03aa79f38e92d508b18155235bd83388431eaebb41e46f19f8bb84f9fe368c905479bf82602141c058cc3a7a5a1e0b7fea278f65a101b0930db38572126a91fdf29581110af2e55991d4b97b1956b18212ba2eb28634745eb55be96b67b87e5d5f2b3171f0507f7cf3178233dd4831487793f792da699dd5dbfe4e8fe8d6e97b461bede45326d26b87d18a68f6354d86f34ddb32ebf665e1de32bce397ac4b01db7410683f3283dc3a644231c1566bc7c6c8b1697a78870f93cad809e824892a6792ec5056f4a40dea7bc524fdd8d53e5e32f8eeea8150cec1adc28cd60c497f0550ef87bc45afc9bc60eebcb6e027717ac45b21c0cab5d687eec29c9bf0a80c1300823fc89cf2a1d073073385c4b95b4f7854cdb7091598ea85db2addb5aedfcd8862ed83188debec008341e35118167ef5a37ce9d71cffb4bdce24a4b770bc8c6e4bab3974740c02f0e868f12549582d60e285c83d85adb60495700cb312a65e7b1ef5c13ea306ecf6c9ff03da81f60fe1d5d12b706c6cb69e98d95cf83b7bb948a9204424b4037e040096f69f147f4c1e65a017c0264dd7bbae790a34bbec60b315fbaa93a95edc9f4164b515e78707a93cb6bbb7d7845d5295a18915f42e03c280101b68802b0a5db3539c751af78ec63ff6cb3aa1d04395a941b0c629351aaee3594e99f998459c04454815f791bf9b503d1f18b8bc5394216cc7b1f2b64b1217ebae901c8e314de20aa7677724b1df116e5b3aaf768f3c590bdfc2ae426edb7f36a959000bcf354e55133723f1f17a3af4b56e20a84f406adf3305d355a4495257b337ff5120350bfeec20f2859690d593ae9a87121229018a446267ad798d81851ebb3bc000c9656ebecf128103b00f784f5c8a8f11cd12fad467eda763e6362e66b0dcb84fbce4ab6342da154599bdbad35c40873cafff407062086e97ff85f742fed3d2cf461823e632c2c007fef9e2e5d6b2e51b680868a4fbbd595091009b9e6e95018991125f76837d9ef0ff2da89a668df69858178fcb2258439bfe313a3cc022052d152da6eaf48f227cb08c2f700d6f4ff33f636ee4e9e59fa95324102140a592f3310da9a4428fe1bd431dedc96fa8fc7bf4d6ec6390aec70fd8451a10c1edf4f44a01fb6103c0df5babae647809862cc058fb53173034303b149ecefd1b282be92041dc028f5dfe83fd4cbd775cf42835245a4c8a9695ee6e76daf5bd4581ba9da8a5672ff729e6b2f6f4dd6a081eb74d9215529da4caf4eb678c35a7ecc076b18718afe9d7835301590a3b5dda37c70d64813764cef008d0b3723fd54bf92e886ea3c35e7f1b2a921d179bd7f781820124c5188d88a022746aac0d9514ca830422b5472d7ccdb7de30a845c3fb268bb2d2b348556d36cf31cd1f846be3ef48a53a2418c2a27edf8e2706ff6f6246186319816c42f1143ce614069f210e7e62b0a0d8e63e85fe67618eb9ea9794b117a91203c2533df87650eb1aa909571ace9e4340a10541fc9fcfb2aa2ec8ddbff588f8f23552532adc44f98bffb71e09a07e2bfa668e0442f58e3ee87c8407a346d7ea78b2d92de0e5ee17b0256ff87f45025080648d7795c1c624b3233d78aa9e6ddd6e936d9ba4769b8020374e13fa47b27ee35957f408f7159f1ddb6d87fd4fe70023e9cacb16ffb3b6dc83134c38e030d45182a133a083b1e393de33cd716554abbbd0c3218ac924c46847067e9b498c43c008cc04e89e5b6313a0078d951c45bd69fb941905ca2dcf5f9502a8f0eb8707fee9539b8d4648c589db112938f5f68ff48e254840fdc770ec12217f5978247dde236e9d414dd870d7b1388547791550fbaa500dc5896999ec4187b1efced928e0e5b496fde1942461eee431034c568858637b7e24e5cb2a523d6a3175cd033a1d4a2ec9f112e41204d6c51d4233aa4e3d761e932081d9419a1687343bf48316eccc870c2b94f2b6929c235b7bd54a2402e8ac5b63f3caa517ac7fd4e7f167c6b6b6d778b6f2a455e6fd32f6de230a29f835d5e440507c5b20b850d50fcd64311899292064cecfa3850c0130feaa7054de0cf3c3e2a6b8b2f2ed02b71366c81dbb8ac9f141b130739a0d0af64a6c3b87c229267aabb7c8cb8caa4945d38956f03cd89dd0eed43fc78f92dc52736560090ff12c02f2cd9cf7b6ea654d089f223f5268834187b9ecffc9f7a82b3a81b0eb8febbf3bfd0e8b961bf311cd8badeea3a0a319dd97d01b07c89d19f43d496c3abf5fda49b97eebb54b4995327a06e13e54a5a722dfe61153d70c4cab4b3a2f02ed9a816c47269a9325edf187e914ea2e3bfc7085778b5f8ce0e40c0a51be658fea54537e36378861da2f9fc3a4e556e2c5bdf1688c2aa85018bab81b369ad0dd57781a63a6f0fa226e2803ec630690c6688db402d0b224da90b314317e027768b059568e74ddd82433ac6c76d20b063c9c78c70ca0d5a0cba71ec4fd730970316a704dcdc4f53c8757b9ceefd629c182b7d6e34aaae34cd90a0d5c1e6e98dedd2bfcd6cbfb633e02d0f9556e2bc65585dee3948a15f6f7c7a07711cb53e65d91dc4be6081d21056b15703a04981ecfb350f0141ad63678c19eaf0417d1e6213e98a9318189993127dd4d20b1a42006a8169265f0ed7d3d667586579ae33d1090bd9cd08ea05f26e957a1ca904b56bc12cb87a56cd1dc1621de0e6ba1bee7c1b56be53479b3dddab49456448756a226b812ee5ba939427032aa0de902dd286ee24f6936bebd480dc5d82e52b8c12c961ba83396c433aa7ed36a9ca985cde676b1105407273b6b7a1a20150bc81c07050d28c6b3ed637b8f5fd2b7d08bed1616ba71957f4cb84f23eea97d9fd54110aa66741706bf6c009a0fbe2b0e789cc14c46ab738cbe4edb4ecab12ab5b654390508cdaaafbc6d5e882ed2c320599170cef1ff589bc0e87a599c4d9af209d938a8e1f6081323108818f039a3a8eb46f5783f0e4c34043b2570413a34cd2415cb6dc3ba95300c51e810da689fc1f6b4cb9b405a068239b9b20d738a73c40ea483dfc2f0397646fc87dceb2dd740644beba2fb2140c6108693b7fc29f94ebd8fca360bf5548df36b53120b376fc9fb084624b26915783d569a08b3e10ad57f073228672ff6e8641ce1d58312f7733ad39ba59c7bc59931352bff5625f1405dcc62a4660f1872e7a56b08a84eeab7098305d6a7725d161a5d99de9bfb0169149ef50cb4ab924b9669bd87d1040bc4a7e91009009c28487c7a1b750c9344e3fdad326e890d7abcbf02262da4c21c6d695de18d1278f58ac580f1a006d91e19ce55273bcf4a5fa5bf74b4d84bae6f90c295193bbc1fce4a007c47d5353984910499c1b030c54d14270f785a21b22c82e6a1e6666cf3c2487d63ca4e79caf4f0a7568c5626e5c324d7f198f12d2da4c44e8a6e2cb2129e2635b7c76551bb47113346b82253b331a041a6a509a27016269c6a32377bdd6c4d77c484712738bfc133fb168ba0212d459d10a7182eecc0579c8be3afec7699759b8140b152066920e5e51813b25c878e0f079cff0ecf7172363065d348186fed30b61ac53b19cd6d0e1e07f6a0dfb6b35f69931663f97338f9e21673786e70c79b332b64c82139d9c1fcaec89791fc39ed848f31062148f84f52be893507819c2fed6ad5dd3ae2d5aa59598901936970ff1d84edf2beedb24cbbf0ad3925f01a7d13b4c4a81664e9bd0936dc213d0a777bca21eeca7d38b022620d8ab68de47141770420046f1cbe58b67d1208296756a42120d57410c8a8dc94879bf498531c8574fbcfe5cdb29c2ff6fff79441296e9a31bbcda7bed43833b59cebd64cdfa6b0c0c4d6b2fd6dea1160a0a393e4b7f012e5b7b50ea9f6a74f2b501a97a1aff53261a2d0f0c152f46bef74bae916ac1ecd82a6323e9fe0472eaf47328202ce67af6840239cdcad67178c8ba71fd21bf39972aa57cf9a2992f9413d922bd36033ab0bacfebf3fc419e57db93965073f66cd4ef19f742ad5575f1a45af7880fe57a9ea234faf662a9e2d6579a57b96b3d4f4f9db255b07543c8160f1673d1effa096ef88bd7fe325852564a38872d1f817f0034a82efc7bca8bbf7f7a2531053a99caf63719647dde34a5d23ffb27d783c5e5ee866f711e38f9f7e55f69a6c470994887cd153fcf54c8802657f8ecb11c229e7b1c42473ec2227c1670ffdee0a47c8b6063d3e8a6d7216c8fce2c152d838658f82aed88ff4c67ea18b48c8a4d9af1e2219916603ae2db391868eecb406fc027f17e1464b96a6449c58854f86b55091db1f0a76529be44155d6f08cd090fc2a7d2a76fe7d2bb2e906098ea4d57b91d71eedd67d0d64e0074c2818599d4d73518247f0acb44e8d44e6a378886e583adda9d0bd30eae3f0c5e87a16cc44cab6da4d3d98c7b657f35a2cedb684cfb3ffe7833bfab6e50b5fb58fa45bccee2d9ae75d65cdeb708a4739ee60c701822119f5747f41dffb664ac54667d0f5f5299a7b30d3e04406ac2c608052dc2d68b72034c2457d298ddc57d76d51df450261df7f471eb65324fc883f666c2f1565c23fad6fef0765993f2a8a0adb17177223eae7b759f150a2edb1f8fac8363d2382c37fc8a11a08317d73bf379ab2f46c6eb5a9b709cb88e088d7153547a299563430f141fbe2373909f6bea00b51708a08825258e3829fb2c2b1e22b6244765e7cf3da2ffcfd64a333955aeab423e5ccee32f1236b6b3b15b25bd02b28ed4943fe837e5e4ed5d113a586f598d5f6c9489a2193410c04693441c2cbb57199997b6d01171fc1083ed877fc6343027ef7cb565a36b8052cfcd616366ae5a1b0a504c371258531aa92ed2d403f293778fe475bcf4f8ba9dbbf5206852a534d7ab21893ccf538bff6d3dff52ab9cd205102054f5815e0591668d60af91055cd24b3c665d4c4d7c39e4fa46f166908e0b2bca4a5dfcfff54a1ea1e32ad4af6ad087797213d6179c022d4d055570733003d24726604f1b94887265f7506481664bed408068cc065b74adc2b0bafd5a19a86987a729d744b4d786ff609f8742f482e3dbceccc2feb63f0e712a1d7f3066d340345f304e46937dac90cbcb0177499f5699823fdaa9cabedf7dff1698d81b464b19b9722554c710594d6d95531bf09a6eec688b997db3310e34075b516e4feadf721023d0045ec226d1b115fbd08857f4c1707196b4e9cffbb92deced371d02c14eb16ff6fa36011818c07ff06292df0438ee0d1150a846e618586655972e16a0f0f97735a632df59053cef22449447b710ad22e9f5cb191953bd1461544cc3cbdba8658f622b2c66eb57953a19c9b73e6e70f7441c5230455382af8ec0c556b47f4ec93dda39db95771a08b3e2469364b59c54e95eeb6a0e99c8c21c43221e9301d1324b0c9123f8da675a7b0fe5b7bfa5a95287c91f031f495bc48f85e33792a7f86590dbb00e910801847d1472c00aab17a1f238e7d976070e6c0a60a52cd36d1f0562c68a928435270d6d2b26afbcf694ceda2716855b89e43cb8c4086905a271bc40cc2c0403242f6fd35b272f8670208245623787c2721ba4dbf3d56c444ef885f1d05dc2ac2ed2c9f04dbeb8235224afc19e230e79f7ee8a4048ec78689c2a3aa082c51ef7835ba0a5656e541eb450c0cbb410d225d6e2769b13c7d48455a630d73d99aa113f099eb2e40400b5e720cf8992cf169e100abf9e0ce4fcb36337f36625f78aa6db56ebb78ff20ea2d96ba46eb7642cca8ee1621c8b193e984e7c30a305276c9a6956b3059ea1ec0673328a8900587f0f4757a39d824e93c7c22d6f04533c0016d2a3d84717cb1c834fbd5062bf99c318356e4e3f8d4819de5f31255adf6ad62a6e36318b04bf639fb96cba574f80cd7f596bd38ae1bf81420112fefb0b2684c206190f8ae8b51e8b4390fe3e7b3e45363840f01a11752a698bed5c7219a407cd6a81269d43bc904d8d25a49d0a3a7ed8e7336da0dbd673cb4c5053c9546d8a1d43bfc66d66dd20ffde1ab3d7fc9341e4061b1d9c9aa59c807580c85394a798541f6d42548bc4c67899b3a2357e11700b6ded31375fff703fc1f80468960ecd073e410c0821fe4d3176dbf604ef216ba84c97615220e635b57d63aa4c1fdcecc870c63f5452278d164809f73da26f1d2eb9c6d56a27ade9baa90917f5fa39cb458aa01fb24b5bda150e13f4180934cc3f45dcbf2e22bd0e01129b3406b5e3081d118b5fa3d3c672d031adafb4d8df35e42eea17ec9ce86d8c6c4f1c228639dcb4d28709ba6051ca4e927c4c0fc2a8630935bed2ecff77ea8d5c5c1267b1d23b1c2df2c98aa62b99e37427280b60300b494bf397c7243960bd975159e436928911ede680857be8e8cd6b7a49bd6f15d30eda616a62f20cd9f39e0f7e47eda31c9054965abedb302ad2280c413d4289646bb4e5624d6c1a76a247ee100c3d515aa24a204ac261c3aac59d1a610a1810d221f69ada9ab1418d894fbe24151b982b920d8cbbf63fe0565ada398e639e68991a80739619719ec5595e44c8039f0a3227a94f90704420b009280db68f5e6cad90d32790ebbaeead05a274a2e72109834a701252bb6293256d1168478be62cf203055ae6b586abff9e5d645e4663f45c1a138a7913eea96cc8f884d29f2e642e38351c78e0eab5eba3fbeee7aba4999cc89701a9e75a35f09ed7f6573d3c7d98b05f8b4844bd53c6840edafcbf75fdcb9a951422913fcdee36e04999ac83c911b238f59846cd6582823c865f874fd20aed466f22f922ae004c7763f11544432f4d3900cc8c1235d894bfb00ed67bd609b7b689c54389e774cb29c4c595aca1a3a3a914089d9fa4c79db4018a9af0b0ed3ece87fbe678e226ef109a54fed249e870cb35f4ec6c37d87755ad298e4cd3314daff7e2821b0574c1b9dc98037de9c9878ffc37c2ebe3e18bc5165853a68618a3db1532b0953ebf837954a8d22d218e916568c549ea0767c8cef8895c6f0c2c3ab65fd14a91391b19d256831e93c00131d34d438bd8a8e58239ab55f4e03b60681f72daff7b23d07b52a53190be0bec2be608b917a8cdbb428aa203977757b4158b9feb1cc55182ca324191232f659703ccde14f47a10a0212303fecd2ea85e06892c92744136b922a8222d878f9645b7034061d5f528a1a35e387899387a5e41b55dc81ea2b0f52e229a950cfd169e54817750340569bd9f95481a73c9cc2a16d37ff9c01c6a4bf672745d0112ea67701acea029fa10fc6f928b0ffc513d02dd682b00ed47a6f7a3036a41c76ef06dab0b2417de2cb9644febce2e96e2b5a1227ffd2e821597b0c2d0e9c68f608e4e42f68c908468","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
