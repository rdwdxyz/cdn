<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52e5912ef12704b69a4a01d9c8c823df843c866e0c24e99ec528e9c6e6c0618e422c0dd06e27ac9e6d777cf225f9ebc8574662e24cdb8b8c773071a856c9cb1c42349dd7fc31436196bc7a292f41a0fee3b8e353b1beb2c40ca40f09888e69dfb9c2daab60d6b04f7a0a2d6a17023f0b8d02fc4207d334dbc3fec11f99ffabad7017aca7d7db22b7239fc493a1a808863094af81d2beca26d469a3454cced7ce202d44bd19816d19de3f910707ff1652aa1c12166c72d9b6923bbf2371312aac39dc7911b04bff3dcb39dd9bfa7d6185ed3993ac632c2dd27be58645ec08a79d37ee376e172febc769701329ad3ac0202f3116a172850cd917bc70ca125252357f5e4d0ccc988e5ccb7f0735e27506f2b5d853cadf390f6ebdfe8412a30e0b4abde84a26ee6d24d9e377cf721d332cf706e0d218e5b350ef2ed487144bd8cbee39e53f568ec2343d047c59081f253e091d9a4fe3e01e65069ae62f262cacb63e0bfb5b62695b9c38b041a76d9582e9309ef20e4f251dc70bdfbb8b7f37196a611a5961982921a97371c947bd246cf5f842023f525752572f338783ea34b0391c4078c3c0ef690cf256a7418c7dd2f867ed4f9cfc22b71694aeae6367290d0b2fc78b292085242ee0a92d694ba0ef269f5d92a2eddf1189072e8025f34a16c5ecf550c107efae47ec292b7dfde6ea9ddf4f9e4d1f9b692daf1a2ea1f118b3c0ceaff521a631cdfa3e16c48ba056497c647ba55ec02ef2521ea632d48fc44a4411fef20c77f3d0e82bf159a383d46475f49001aafcae6051548bc3b98e6e030fb61d80c6b265381c28b0eeceeb1dae82f0d2315bad7501a94564473ec55db788560f1d8b7eb3a22a02aff2d15634885eddf01667de6852e0c825ddbb7f166e46bed5e4373a456d4c2da62b894f6c5e03a6577e7fa7c3a60c9a83027f9ebf55091d3e0947507c33ca3af0add6d8e1f0daa696acf04f64b3e7f2bebb65f4af68263b2aadbf4585de19d18e859c38afaaf794b4715df0535d054a3be76b6efac0f8f19d4f6ab3ff18377e9955b3f3397238d850eb9e0e8277d525bb770f69a75fb12d8a5b2c888620fee1fb58ff060831a4f4db718085392cdba3c6b74825ec27472168439b8e0aab87e3c67f65fbb754f7b6043cef6f5ce5900a2a9dae4c2de81b195cd0641369adec24eb1e4acf2bfbb4d596cb1e3214cf66f948c299113c1329b9c39579eac0d301880125585480c956c4860e45d9f1ad9d32768f961e430fa6e961369b229aa63f5f398f4fa3d8561c69381c08ebb0910fbfc46e0dcf3fd423b69a42acc669f42d6c796b8ee03576b45c5a516f69aefa58b86b11c04372c807e7b186da9f2d1e812243cb7d5df48dd3e0aef21991750a34fe380ce0a2a413784930b25109ad93be3082fb356e64f67a444af27eebf6d13b7b420a619a225c8e723592a12c21ee59d1fd05a1093a438ce2929b052c603756a905b4ce68dfe525d6e5fb6d20a1d210af8e19bc4e8c805b61911bc2860f8ef2b60fa44ef6eaffc386548c8662ba5c4d32be275d502b16a30b05d19bda345abae965558e9c1fe7b27940c3a1084e46da8e4142bca5bc16f37ae28d84984bce798bfcf8197777606d8753534b77b5640752f4ce32bf5ebcf08301e0a4e318bb051d38dd028fea36e5a3e49ac82de7d1c35686a554d4deaa9f941217a405263d2b83b06c857c431f7c395be1247aa79f8b22a94750349219af507e0c76e1d3185e0c453e3be5998c742aefdbf5869f3fff59430aa53bb3fc499f299f6987fd69827bbed665ccdddf787da4173646f9719a01ee6c39a97124ae78e603ad8a85226a4bdb4a53188cdbb56391c5e760cd7c511fd4b6cca856743bdae109311bc54f2212b13578ba5b8cc386a018adfe5c67da0d89fd523e24a1b54ccae25bf1c475cb60b92bdcb54b920033f191e6c59dc3e19b4b88a12591ca0b3a7c3c5b5505d25b61d15561c4551ef34586fd7068b61b14a1cbb74b9ba5f012bcf4eb9a823dee5df8f6bb4d34d39f10cc07b9fe96932d54cbd30038f0bbd60502957c5c33c377662a4cbe14ac878dcf83bd17a97f1ffb249655f74a1618186ae644cfafaef83611298ea4d69ee28cef066cf3f790230e7a63a537c2b31b99afbc45047d6983715e992aede68c95b4dedfd9a92fbfcd570cff9a48f1adc0250a2fa3812c864dda41b0431714f5fc0c476ee21db2029d53fb718aa39d1145826636328d74872e62f61cae734ce16dfb30a889d565adbd62c95705314c45ff82a72e775a61da2bb31a9c4ca55b418595bcb69c23114913763669ba7c858c8c90733721f93cc80aad7277ae7f96a1dd83d0c319e2c633fb7c41a9d6760c9aaaa868eb90ee00c7bac85830cd67b7c2035bf8c1537bb80d172b7bdf0f7496514bf61f0957f3a501ce391a0ede868c24dfb29f5991bac5e77baa10b61df9be7cfcae190c65f2625908fde0fd3086ec8bb761ae1d18c9f37c6a7ad7f8a0d3c31b418daf6a1e4cc104b0bbfdb54adca211d19b896a5a154345cf0c1d7e90989bc65688c0ac612ad73e2df00cddf5481128744b6e726d1536d5ee14e2ce059c0d05d789418598b26aaf7074675db35902a1b2fcca7a1bacb3956e9dd99f1e37d83c4e66b58b0339557e2fd4fbbae0840d2c8154fa6bd0113bf9a80793eec3c45124c7c197c29bcc2a72887768ceb761ad9448327d1693b76ccf20de0321f9586a5f76c2e44c5f1512705e8a1f841f5ef2e8859b8109ee15a2ea3e5d52a1ef0765c2d4524390826e38288cf68aaabfe96c0acd3ca4a58151e20b03aa579e481141c672cb50fccc3240245e380ac67f37c4ff7cb24d310356c4dbe0a7109cf02ee9bbe2b74c725ac8c4d296a9391acf03f4b569a1b14ed6683ec0d6b1c715c868fdefdc28dd6ec24ba09a65b3bef56621a8607eafed24f5ee3b7bcb27c0948eedc2563aa352b35817404325a6b6d99478f43a48f4133d46a62c92daaba71005d531fe37d457e2a4346e4dbeb9e0ac6523ceb2aacde62770018a764911a9989095a63aa6908a6da41ac30966ca48fc9866d1e911c286c787890b9b94614b2969633f4293697cd187c838304a6dcfa548e20d2f707f3d4b2cfe5543368c8c73ce0ddcd555fb8f5e17f0b53b74245827c824afb1564551e7a2e1951edf89c9494e755440536314a7c279941316a49a79b52865f6b3b82ad78023dfc716d9a9ed8f91f486bb23ca888803c798882038c1e9e0e5df398bc1b0494cf1a9ff0ae88648ff96763486d74995d1d354fbadcd4bace49618f75284bf558efc2fa7dbf32002d8e2c48d7e50df4d14a2b9f813c64db26e05b3b3b2de8abab9cdcb3817c325997ceb784474a3acc41fecc976ca75624ef2b822fb31aba4889b0ac68e0c605e153c610c9054612e111fe64f8713458f8140ffba9ce2dff5377b9de07e61cca623177962f5287824ceb411212b7f20db85ad7b97b44dd850dddff3ba73a7f9ddbf407bd3384ddac8b7fa9e452f866a548acb6b8c53414a7f4c33a0075230bf762f1672531265a6795ae0369510cee00a1b0375776ad73c60727554a2eec4187ce701b27f7106923130c31343706c8cb1572565e3edb3bf9a0498b7a717a5d88442df07e04c43fc1cb36b952f817718117e9be8ea8e31350e93e5a7d5c98d0b319be6789976506c854d62850e6de450ebded6dd666b737e991eb89f3054924aed9d45f1e00ef05518a7b6fc94d02c101e870eb2f2bc50e0f18c25aad0691a64daeee73e0e645feda71485e134ac59fb816187e2e3fc390f9200888723db7f0e11bb31111f36b34e71a1046cb227c87577c95d267ecf8490b8fee7ee029142fe82045f44a3caa02de461f9d23e19ba869e1d9f7315ea7c5887e6ad35c8bf4c5433c75e4397f3939c086ade8071a18b1cbbca4f245649208e763f585cfe4f7d1852c2c39099f5cea56bba23e77daa645ff6454f4f0fe7612c564c111477f52f4492c887c2677065fa6a7a60cfa3c2588cab8a571d2b2e728c43f0693626eb2e55ec4a9ae9ce7d57920d369b67c8973d3e15386569bd74e4f6df3fb3a3d5a2e982b9a05b9a8ad7fa171c2d3929b7d260d11b0427a6400c067d8f74d7af6a48385e544d6f3965d6c3eddc1e3fc5e0caaaad71d24333f1c837e179cc82de6b4cf94929e5b5f94ae4c91de47a1e730c655684a95c229e536189d5ad4ec4cc40537ee2b5b38ab3489c20ced134fa3d4dfe351d3a60cda9c01c4958af215a6664548200f8b77436a549eae6e11d1129f464962bfb656080b30f87666c7b54b5b103430a4828ad53ce24bb3218bdc12c35e0e2aa89b9ea65eaf6fd209aa65360440c9f0648aa953e2819d80369450096e00ff0f46b7ba5689a5059e19bf4f2dd38c95fc3d439f52dfa7a455b6854afbf90dd677a82a084afdd692901ee65754db1551818c153f6dfbab9a7f5e2dc07e3cb937db91fededba59f2a36da42bfc287371d07e0c32ed9ffa82c2e679da0dcef047e5e9480b73b047b1bab1a1f2189dc931a889b385ecf3e8db61da420c4051c9d7a8da0c11a7bfb1a40a6a001f51c69e1c7f2db30ff8f5dac810efbe0c95c0c09d5abcba67a13fa84e03885e084aeccd5ab948d10bd844f5aca315bc6be83147eb689cc36c13de0947ca20d57111bd9346cf833d665166db8d8a8ed4b8ab45ecdf7e63004ab45a5009aee513a05be14c5373aa16775658e43ad19c38f11b242d1833c05f5e4bfdd013bd0ce4d490075934b9869b1bf8bfb3b89a0622f1b87ce0fb9f155d05de1e58a68d5f503545d21f6699dfd5c7b721013d22391b1388ab3d902285b81b9c6165019782f1624991c87db863d4069bb10ce1f0af5ee3b6b6fd66085cefea4932dfb8a6c1538f0e3a2ed149807896956ad8764ba2ebda3c1b73c2f8302cbbd95ba29aa80673400111fb1588f53a0d14745708e340c5ab6ffc9c58ee5abfa53cef4740f2457508328f8e8137a7dfe8d50bc3b5db92b8897fcdfc026a7171318b570efb40eb544eac79ecde11b17e6373399ca6889d7a0e64319f2618050df0d48546e52bcbf34810fcbbe56359d25bb515ddf1d965ea1bf95c63a02188ae0e75ae104da2a21dd71167dcd1682115701e6707c30e48d7fa81a3c1c72abb449f6d702e83be46edb1bd9ff734759c79975f215bdc42dc16af4e195c8e2477fe53d316539db2a0e78fc3aca83fc256d185e8510a43873994495d1f96863ada0366a366a28b55670b70ce4a66391476ad302c3ce4ea0f576564ac6ee1a7716456428e0e6cc49b7f7fdc23ecf8864527a12e89c039d22534a7c7be6bfcff6b169e9a641556a0b5f8593816e39273e2105e463deffc1ca08ab281b5b75a6ec2b8f3c2c689869e8a4c694fbf1660b3216c956fbd9f804517a1427cddf9744dea0a0e0c655ffd02758c9cec7346684adb6fcd1f1071ab443e58a80fa2d643d30e66fa1d55404c46013e707d2272b683368e88ebb1b8e81a71aeed10024d5ea19e967879b033f82f9c00f2379a1880c52cec6eaa16d8f4da5ecc73e119ac92d6154643c0e3d8a921b6924254e4fe705b3e6027b59353857c739b46d088df058bd1f1f07facd8c48dbbe227ede149fee411e93e1e76708ccad532ed6861af3babd0a08a90c8ab5f628ce772ff1586fd9fe9d2fa567cc4aa81b6c006a87773a3bff1c8082f066b61b4811ef3b12820b11cf2d4ea4e7ebe89a5c1b6fe9316edccb681c30515e6e96e8203d7c9b075d0d2b83ee6ac9035ae8ff07883cc15f8bb453ee4c4f80189372c23e3b525580bd22e8334ce1fc43cd6969aa62592c8ba95f16884ae3c621f6e19210e8284487a9c4599e2c32f7badd4ed4bb30853ab2977115e789d81bb211d59ebb8db981d1a2b41d16ee126b650a6f222245d8255241429000e3851ccabc99731278afe31b484e36d2429af1781a73188de3810fbaf1d747f571a66dc2fc3419adf7319c4ac4b15f03a59ab4fbfcce4893f649fa061e1d93fd808744ade4520d3f49ecaf7e404e427b37858c7540eb73c6c68ee6fe46548d9317aecb9a7ef9e29feb717457b29b356eeb4d45145289cd3e613a16dc7876da37eb1833a4f4737d70785d770d802f1c1c455a588b88ebc371ab5027e670f9bfc09ca88ed86c7f711957b03779d69fea56bb716e2993a50631eac4b9eedbc6ac207281f531d40fdddd36317d2949d7f5872b148d8f9fdb89b76a52181c1760b4b7b5279aa4ae30b26d750c9c531a267c79935bc87715079dc9ea8dfb660afefa62a86cc708c23e65f3d58809bf748d7827c98a9228b0a018d5aac20823fdf62d9b529b87e7227df79bfce8d06486f504bba2ac29c21c2a3fe5e0514dde6a1479900b5d68392f7a2e38d1266696f54e36768add5e4b89a1d5aff7b61990f1bf97bf9bf2f78a23a6b92b0b26ea1a8d16577da59aa7ea5cc40f12f945ddb7950b1771cdac896780f8ff9afe46d928106bc5a8b10868765daf7e4ecd856094d3e7c5e05adebb46271afc1358184b926717f07533ee5653e2d60d0d3392c72b0be604396363f2a177a1649ff6b350db840c19b010d2ec8a3b13a5887e50be479eb830662318eb551f8ca78a2e9135df194befc9d2460e4dd0e07ffea0ea65df7738e7b96717c572bab520f08c7107a3de4e2ea938f0c7354e2e06a714b9e26d32f9d56ee6c3139bb749876d3c48fc8e19b702b07d1a625f8353164de4c39ef20c15c4ecc9e451bc1a4afdd73c6ed24359f749b50a5f561ef913dbed2ca10acaf598e87b992ebc0bc9019496094ce9b27a421c3913a9b4dc165e5834dd27de8ccc2a3143189138c377c32e718824a61d69b88199a95bedc6344b8f7a2d341bc494ec1a4be71afe2efce2ed1c70a065fee73decd5484e888dfdf975cc66590b4b641027be18a7249856645d24541677fed19859e3261552379c842372992b05288f49afe8d6a0f98d974e898551136d6977e6e2d30ce6e9309639d9fc6ebc9c219fb6c060943960d9f4172cc03a8b2e0bffe520c147d322788b158a2a3bf4ecba47cf0238670219247333eea7f791d50e701200f28de24c3af7639445baac9bb03bee264387bde3e2184b9248cadefbd40aa51722147d4b592c7c0ced994b96e0752ca32f356a4f2105aeb097fa0a70dd11e0142a9e46e05b9b9fafa26e092622668e3d47026264255d6954c0f2e64358835f153a7e9079f2446f2a78d95fc99b2b7f20c0e8625ca6e8b22479f83db7307649d7aa0fcadaf618c8ea202ad6e1e1deba9c23009f41947f27dbc661c772546c1c17b8c4eb2bc7856b07ef367519dc550d8725e169b0c68ffbcf868c53533e9e47346accf02653fa87f22fa082c86e970cbe2ea564765217b3373a4d7985634de03c00b1a18ff6b7296386300342ca514c022ec9a0b69a37bf264594fbedc693757b13b380162d2032d27192ae9360e69cf9fe53966d72c57b08254029b2ee4bbcd82e8233765ff71c2a09c19189d2d162369b60a7ba49a9c353322355e147d77bd24a51280789101c7b57118705c9e3e42a6b4844cbf25ad6cee3cfdd0b398e4d5c71cef2adab03b62cc1431e8bde3a756d1e1bdf47c51aa7f6e999b11357020f6112e9a30bbc7306396c419d68744d529bc13c27d3fcf5e0410ec7e1743ea727ea40042fc4cba584542e56339c3654969ef1e03b67fe40367276bdb8b0cc994c17e6828d688a6f916d4c31eb372eb7f3cc97544f3913422100d317b87209793bbaa49d218ec4e94765941c2458111de59f4b45e0cd79a5ba347edc82fcac8e9dfe05bc2a357ea955895328d30f1a8f9ccf21c39a178feb16e4282f5633517a5a615f368af58f710a298df5583f85c216fa21dff58082030e330e750638e42e02f4dc1624c4d594649fc6a1c73f89195a6a05dab32d2b9610d8d29a6098563c6c4c6d67fa8f898dde8971ccae5583cdc08eed850dddc3235eceb47e1970b0f43acf5ffc6eccc4254a10535cd00c54e4244d44d0ea22ff071833bfd267f466bd931be87c3595b6df9c127980579ecfdbaa2bba17da9aad9e34a841fcc8ad70c69022bd2c7200a78fbdcd562460f08cad7bc8975a3a84976b12aa3661d559f8a411b75268500583e974fed5e5bfdcdde7e6f2c2fb91f0b86a8affd1198a13bb8198e5db4963b8bec355a8a73e0d7856cfced2c955171c4977d8755e0aad34a2e690155d3232796a49dc9b101d897d42b8f34538688a0781a730f8c502b7c2c2af5ed873d20367ae88790bd3569e0d67e8517f6557bdb06f2903582a06f325c43a0ed5bb2a144ab93419255e75b4ffad8ad45907fed0621be6e9b8227b5db6c3855ca3339e7988746c40c472234f9b665b736b8b21dc50cb9162d10c12ddb3de0743c356ce3f70aa9596aed6c8c540d2b4f569d614a7ba1629516e649166c3118e034e43574d6c1e4d13f5a53713a91c4b43eeb8433aa986139c206bf7388c746ffd48d3a230f79553ee1b70a689fc9db356c669f2e7b69b03fe78faf691937f863b2df87cb4a5a69e7d29645ad201388e4e14ae49e4e80f275d28e2641f7790083c000308c44e15717161b08c129a70e43a6412d755b13d6fb8505ffeea5893e6aabcec468643acab1e490cd169226c72b6e2cc4e5e8b8cf5058c0cd084b2ace73698e9d6e4a0951b24da6dae5eece3779b9347be1e3d74da67f8bc38560d807815eed60b168b1f266e99277704541f96714c9e05b6812d403262df43b523fc7475771cd64c645c1dde3c1c9d193c0089b06c4c45c1cd4b94ed60b2966f98896774cee1f96ac1b53b95ab58a8068097ba21ba12eb5aeb536240a25e74dddf2019ddecc54524f2faeb06b704a6cac87d62d43154d9e5fd3c41f69ad27e726ed2b15a3bf625eb4008cf2218e80302808f03a42ff8804775f2263824bb137f84b9b9a501c5cd3088da7d6560e2eefcd1d01fd1500afcebc904326cbf7cb295cce08deb249ae35fc1cec4e454a21bbd236c8f2afe9e1c08aad446f46dcfa8e7bbe72566c8e2fdcc13aa280e4a52fdbae1c7ff018d6ca60bb7db9451cbf3cebeac011b53e75842d6356b43dc67dd5a2674ecddaaf4984b236f348438ed3e4fab80069a7ff19f9e29fa6b266da373c541612fe225a95a426bca0de61ce6b02c66f4f7fd589e404fc1e2f51851b2cb93a8d3e7e2393b197f401dfee68d9b27bd8e887de1fff0387e6fa632f9cfb534acda0899243586f205e492dcc9f5963e186aebed44260a31c174a75300ebc79c9c8fbdf28746239a226773e52413fca48f9ac01358beae5cb8905f0f19fbeb3ed5bb891be075652a2dcfc18c411c4c1d4965a7bfd646649ff868377ea8ad5f681216839705485ec682d1b40f303ee730d1ae24d4d81715aca84a810a72fd5d0267946e97d3acad85a06676569d979257df88315cbfa2ec74baab2a599e4e27aab3b4410dbd50007087fe9ac469a00b3e1aa799288ecf7c0e2515790fc1a180931d5bc6eaeac1cc7caf5621c7d0b52905d3e591c6b00cb2ad91ef061e3aa15606c830655dabf8b65e87a647e03008826d28dcda625e38695538a89aaf2f51d54edf95f324ded8238eccc80881684964ed4ab94b9dade3a77ea31614d4dadcfae4e8b0216b9d6756eea7989e41d300c08fc2916d7c55277ae3b08ae27aac2c6a1545b0ef4f24e420066ed1d83b4bf5686a8f78d7e21603dd8af9e90e531946f9c45a50d72b601b2206e77872195b2f5698d91912f6e1aaa503a977d9eb23bc08db1521ff777e9a7f96e58df2ff0545945f7eba0be787d5543390d2dd96ad3494fc7e7e91189172ce29ec855be7d77ab20f60a308cd7016230510f2413a7554ff811232ab0fcfefc3f5d4553437987cf288ce746f95b898b96b5747625b1e00ecdcab9c6d42fc8a258aa1463139c4e398ce0e26641982696b6d2ccc67e0e9833cb4fce644feab8b3e673d631071397ca48320987029f02100cd96b8091fe841ce76c9ed937d52ff3b566e637d4f154536c6360f65ebd29d1dd1235edfce1f147252b269d67118c616369612f948e506fd6fb8f14dc68c7d0c81aa52ec61dd49ec95a8c128b29d80ab51e74788b7e110d61f977524d611fbd02bea29885a160e16c2a7fed22d8fa908eaa3bcbcf7151e1a93daa97aaee6a5be7aff7e882747ccdd6d4de9ccfb23039e3dd53a6f06211b72351daccbe50fd6f1192383a1049bb6db9bb48b61970d1ebc7a71966aa4887fdb46fde814b756c349119ba0eea12e369f1b452bb3bd60be4d8b755c8f9ea6d6fb34d9e5c20a33abf8d38dcaa1a99f9d4db92db4aa6324b859a298a264cdbe730577512603030391341978e8cd9deaef670ec34cb034db8959304345a42a68e418e2e4b797ff61255782f0fe2822c1c1a1d3e571a4b4aed87de3472c1652e47f6775aa2530288ba69fc4a493b28cbe43070a8538d31b783d5b4c7a4ca0c5fdd984e1495337bf58490a86e16cfa6e00578197e4f766c012c495f8d259fbb9ee3545302492869c5c1e60987c4b33b5ab487487aa0296dbcf644099e065c60fb5861552d420c02a906751ca5f0f0c998613f3f27889ddaa7c75a023ae6869f0526a2a66112935bd5a03bed1bced6ae4246c7f43296d5b93e52a5762967b17525d711634d8ac1d209fe6d6ffb75f7d5ad77acadf28d4f72f3a209569a6d8d56ead407692aca6c48227fb9322cd95db22e1a9287ca06d00101c1457574ee896fa52ebe348a35b9d59b33eecdf43a324949ecf035b45f1ea151291cc678cb0d168a05cfbaf36b0bc21cd38636d717f2c116f85d2f5e325601f514505f05fd2148f97d6e1066a1ff27cf0d69ea07fa22810ee021c5297893333dd2f749b05c47bd3f6914e1fb3c3e6bf7fd16c6b003501c8aec9aef8bd121a9b01042c0c7450421203dd87bc4079944b5baecd3fe895e7035d1ce90da4b33b535899bc5fccbb19a855c229c3bc2f5c541daee62ec0edc7b8284cc6ce35e2ef7dc5941e893957752437ed5d3124afc1bf56525c9485eeac153aa4926563e44c0344f23bc45ae55870206320396faa2754dc9fcdf4105a9bd20519205a11c8eaaff6c4c398096ce68f60eb2eb91f570eb7c0395226275ba830873bffc05521f23387b08244aa662432983aa89ab7f0f0fe0fa1d95e93c2134b015a7b6b6f9ce8000247a1c933b0be02d8e9b139ce64343725187a801f9e20bc16400485435e06b6a65246fa11a37f83092291a296b7f74e3953692753926364b4549dd9320ae1edf6ba5a07d2c84ad15d794dc6bec70dae1e2137122f49a6af15da4dfa837f269f91971644439b1b2bc41e2c2ad657f8920b8f21ff041d27483e0af4db42f5044447133689dcee9fc94aa1b8e50cb13c0617ddc22cb2e63c1989ed944346aa07d912e02f4a23e9e8d9ba110a21e665bf052124a0f6fc3a72f51a9d6b11bfb88817965bf262415decf8f1237be8a3186cc687502fd05e85d546941dae2bf253aafbe49464b2a5a0044cc78b69fb132f1a851534be668832beef86fe692b861793e0c25c1547cf44d1002b1747513f47bf08c6ae7ac2180b2dea8f4656b2fe634e1036a74027b939263426fa916baed8e51187e73887b647d7af1e206e78e39b4e1b56026fddd5e5f38b91ac0457f92bf063614acc2725688db7cb52defbce8da2dde66a6c15697df331ab593aac9a06da19c43eac4905867dc8607b716265ab0a8c7b96336823dda319e6217fe4ac309a98eff6b10f6fe3dfcd4cf82c0b375a5e258684401990019d27a3d01f2c9bb29c6c56b06292754bc86ef761b6c1aa973e72fc7ddf53181f873e44ee848d6317c88a8bde72f2231fcf2b0171cf3942d2df6d60ed02e1f36bc77d158062ba654f1397e39e8e27a149068f2868b9e70404180ddf9a4df7d6f6afb6757960ad5fa76d18fe558be1fb9201318904e0ab2c2627c5c7c9d1cfeca687f3050fa92a6c6a8aba62c1c7454b45f4415aac6506ee448c1bd72d9a8981a502c2493806a46830ff146186faa254360c935e7a3066a90fa6c98f09201776cd651b5e24a403496543bd7bbf511c2d1950510cfc5ecb798ed546542f913920b6daf9ee9a8d73a35d3f4e00b7739871aac57e9366d990209cea3f54b924d48ae99bd8eeb96ced824f3c3094accd9cf501441b25a21ea85ff96250ba6419d9c568dbda626521651d66717b3a1645ddc3d44a2d22bf19bf20e07498419cd14028a74b12eb4d2513a8f5443f52cdf3f2801d2b39237d44ddbe448a096e71602a064e1d07ee1d174e2d2bacd0b3d7beeabb4a468d99956b206f21401dd0065d38008897425c8823bbb8827f079933f6d4eb708f6d75e0d04cb6e014337775a1a65c803b08287f88c990c042687826883bd46b9cea45d7b20a1a6c7c983fc91aeb60bf8468ad5fa01d45ac8b23ec6459027027ef52bedced581c898bcfe833211ec279d2ce392c9681d4064aaad9ff143f6b610fbe9be8aea417efa3dab5ab7df4c9b71dcae13358fa5f14a35579e0fb952a3e5f35de7f647158125cd06c36d791d69591d95adf24b9c17a38bf64dd7713edd943b070ef8fe02477a5d38653bb92d7debdace5d3705f78db1ad8dcf671a42dc34abdf03881aee417af66a4d342dd5f27fa30730c528a6c878ae4a7d722c70e8df75833e2d419b914607a923912785d29d64fe3c7f143696bc1c67dff3a75b0b5d1e5a384efebd94fb8d2c324d16c8063b21271d327a3b75745fc228142ac0b08489aab597aebe541a68096185556d5fa959dc5d4d3bd6cd7943ed26448070c3dba4726133c31b1afe4403ce96d7a49707373e13d15e3251a30d13da78e3053b570bca1ec0fe967038067df02dd5417d81aee1f15078a56c240fdf7195eb3aacb5e3e2cd925a4607240acac8bf24ea37b7f51fa538348db16ffd9cdc092f82e1c0ba9a4c99deddac9c61686f342fe8f52e3966548ced915600083a6d1757d9f920739ea23376b95c968e5a8613709922e1772449e88d332bf4e8cb6b4694a9fa1db9ca4311fb82f006e1ba02a43cb320a821fcfd466aa56191377ff37f0a2d72f69f8b875e6abbcef61d7d6b55a5ca18d7b8054c0c8d0bc1e5c6ebf214fa7459c293ddd1c32a4a742b753196134e26ee8445354b444215253d3ae2333f8710ebcd634f750bdabb025f79521192b6aa6a48e40be9c3cc82d950f63f1be1eed12a9a5a113dbf8d0fda4e949d432ac21be7e93ec0b4d38339ff416eb81b047c830d99e0b6a68e1c6b869c97eec262819e4d9b02cd0cf79f2a419d4ab596905ad6f831ed262b06ad7a224f2dfbaa562bf16a29e7d500820b529dc54dac7e3932d48ea813de10e7511d8b1526e7b53270ff16dbea89380c7ceb9f2a1a157d09d41ba8f021343a1e57a6be36894b693219cd75063ac7e923a92bd39fec3fc01a3ad04f5f75846c690e78b18b8808ae802d929f44711288721011ca49592f775db01e7fb2c0bee809e393947cb56e2a6d5055949eb1f473beda56c65978525fe6daf624da43db0ca94046ac8a7d71762833ca9d8285b3e8ad3e359e76370b991650d1594e73e78c0d8e548e9a2906e674fef4042dccff57ba70e4a5759acac46be670a7fa349b67517d35572ab40ee0e591f4acfa3b160dcd1374529b80c5efb34a53e4a4b5273fbc269e8c4a8a21b252428250d41cdb7e09080d255c8898d7c3eff2da45aeca9eda839228cb408f8019fe742e0369d8d03124f8215fb60e2cbc010c7655d784aae7ad13da2b4475d96851198dbf3924154dfcd7f08249efab6a33f4f4522aca3ba3dc42668d9562f1a307b70e3d6ffa7d4b3fe714ea031b58ca8a8fa1f60f768891413e9f0a5cca7ab0514c61873b96cdec81510c632df77ac26207404bae997f715adb907bb293569e06145947c374c13e738863209078289d4d24352e84ce309fa4d6b07901b0a990a7234150b495a2301393c2f3a42f8cf10a8a255aa12a25db5142f7fff21dd8840aa129d96677ea90833aec125bdf66dc8990d5ff2388899344722b6c88986ffa265aeedf7d0f0c26f6bcb3b56cc961e5b4c93152ba8aa4101b7ce1c741c8bc413db7c38e7d6137faa0dfb2268a33d75c824a0b3736d0500050de7ae8559fc29052830d99b0c9b2ad23d13d508df23d842ad25730c5a917493c7910292e241602eb90a9131fc25bed3902db1231d11aac09cf963127c4c0fb560a1e06b5789de94b25bd7fa59af1d82987d33566ef1b245353c8bcd5af2b3ecf162693c2c6fa03b6a885f900b13c205bedb4a5c3c441c5da11066058845286ab23bc2a188610ea862dec9f8659e20d7b253ba12a9829faecd7f1d1db97ba582c538bb18e6dba03fbe8d251b1879b3ca97121dd5ff251481b5cdd96e6e7b90b544b7c9b398cf0793f0263480e0ead656454e2412ae1dd6eb53c4aa6b022b73dc1bf69bc275932c1a572d943ae0463938a7d93e7b2dab43b65d804b671255d9ce8072eab8b897aa9729dbcf8e1ac3389837b332879a55fa6c0ed80687d90df43e39efea182a597806e451cccbd5f56e9bd419962c61899e36b13d093e96821582697ddd7ba2165cf16e79c5935ac64c6a3613ae909f329aaa7a60c2b92029995d288e4c6c023a8fcb2d8d0420b69d2a6382732f0ed45e5c2407c15945eed7d7ac82229d3f00bfde3e433bc3eaef60314a65af7160a4224d2dfcf0f3db3f7aee839b5f6c073777e8c8139fedd99917b31c3c035f5907c4eee44c83bf68e26a02d96bd5f119f83dc4e8b852272e93b31701155f0683de285dd29445c06af29dfa7e7cfe7a7bd240aebe48b551b1a565b6b7826f5a085b76a03915ed895ad64c53cbd98bbc2aa0839e9a2150bc8d0a46a700d04aaf86c648d7c7d0557d099236dcced354898f0d7226361c390b7aabfe8731c30ee464c4802d1509b28098fd3e9a199d41bfa86bbba7e07a06214db2aba1c2c38d49e296e52ef1ab86ce5b593130ef2e28a985019a59e4ac27dd7dbd8a0c1e6e39e889afb0640239744bcbdb6defa36516b9a9872c0dc0e278549b26a83ce267acf1a514ca85db76c8cd15f4d9c93c0408f183fad2484deb46b371239516cb7e41d1b84b8f4df88faf45a2161aabc19af82a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
