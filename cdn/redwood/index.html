<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c32e9b3b23d4e350ffdc0aa35e38809f182fc044de8a31b02e329ed38f682ba788f5442a71cbf1d72a47b42decaf937696de01d0acc8c3f477e45c84ddadfc64cf81fbcfd4dbc457d85bb75693014c2654e0712f9d0a7b75c571ab6b11c4db630f0f73fb6ae467cfd769d18eb2523f8b417d7d4749151c63c934d6301a8f57b559f8ef442f11ee944608827dce8668eaf18bbe98a341d14e6f9de51058ba0090b1879b50295ed4138312495864f1f9055326a056c688151e8eae4ac0a3787df74b9bf4c2d2f30e17501e02afa32577e8d9c87063972f0d735204d4e39eb02e6656adb5b54e09be4b2b5598b689b13d2f0c7bf988db7800fe21549bc6071af74c0f1257a10cf84bcc072213aff9e5526b21291cb3b49adadf1ac7eb3c8390e1f3f45b44ef86271c8efc67ff926c0154c056ce26d09170260d757fdad8b05965666adc953288b7fdbf89ac325ab3cc69e7496ff5d9fffd1236b5c53674f540e38aeca4d1ebf32a2909a009e7dc898cac8f819d44a087c08cd8dc3e6e7a8056f987e12e3a71fa9bf9c95a77b0b7ca13004b5d18e9020279f4037e1aba3c2a1bf4cd147ff2ac570216ca7435ffec8ef652b8e8149534a7b21ff4efa2427528190b73531b1ba4635822742400c92fda24cfe1fc520df0e01985b51089b326bbeb666d96a718ae49cb76b8d0a91467961019efa46918d43f3a4cfd19ef22ebb0e0c604e27462576662d0e08b109226ab64aa552f4b12b84763a187b20f86ed1ab5897356a8ed0697dfdb263a74729f3cf71b7d12ea7a69880cb5bdcd4d7252f03a9ba60c97e8455dc00965b990b3e89dbbeb0f5b7c07bee37c9cab2416bc576ad9e0afc8a46ca1966285cea685e672834bff101653d9872a1b78e97e4835bfdf043c6d7947902a27cacfd07c3dd17369f8677555d0838f948a3cc9dc80caada09086200637bff7b0a84ee8294baa1a3de83deb356abb5b1d39d51acb01990438f7471f803e1aa841b326a858bb702e35f4424ddf0a8a84b81f4a1d988a97652435cdf6fbec7586e4e16935641fe3fb0e056b7d4e68fea835a610343e0315b27644489e73cef2a9ee14c54b3ac479a46f7dad1c6d65bc34bbd287ea671489b390617e68b034d37efd21d97860fb08cc63f658baad788b00f7385adfd497d5a914269c8ff45a3539d75363d895db30145dbaedaff87770a52cc558d5da2eeddfa736a6a8e96dcb0d1d4265c251b99eefd886e018281f8aeb575a211bdb520e334f925f692f248efc4a1d94d17557e74ef13528b5cfdf86e76e96ab17aac0b5c29aa1508ea6428dc87b09af34a0baae257a88d888080270f11a097d9f5a3f65ad16d50bf25699ace742b235fab31568e0bc9fc5913b70b6e4cd100125d663f279a37f616d9726d2b169d6991cc3995752c5ce28398ec6a1cf37be85dda9202f755e674fc3d08c2ea508911fccc6ec3df0b5fe1d8bb0d193458ba364cefa08262ccb62417ee2d56601cd193e6513b6bcc86c27959c3218c33079b7be83dff66bd0b6c249f2c6358ee889460b8db2e260945d23d6439ff5e41b84c99805ae611a1dc5844bc778fac19c7c14f625a18ed62ac219c507b8b74cdee4462888ae6199304bf245cd5a8c2696919ce05cb66506961d6ff159458ad740836def7b09e937e7f63c2c96798c2c2939989c4489f6e5eb6448436d9ea272cdb04aed85822d8184d481a3e4cc59126dba74a23384973f39ea2f2e45bcef509480b73a940f960eba08c84ffe53bb0250a808a363a59f218e06181fce8c03e297a141efba13426e3bad272b859f18a30f5e04b235c8753d18f056cf3130921152539cb712281b57736be50bf343155e204b155d25bae5d9f9c396c7f9cf7853bb4837f84ce1609112e8a080791c60b020de6541decccdf95008358829948a7657ac9be8b1f6246688b60563529666d56d47fa27a1738aed4ccc16b93725f808634583995b3afb0b37b27e2227a9cc0416b1bc238d4936822cb7898f412b222dc43309582e3d1445c0ae71e674974588c259156c77594d86d97d62fd7679a05b43160939a6b447b7207446e7252f9a44058ca7703cf76ed7a852347dc353a3e166c6ec76c63811224dc348f34a78e56d02645264e6020cee993aac81f24c64ccf8a1a2fc583cf6160225db44f410a6726db4b548b54044f988eb628ba22bc719fc7f48e61f399592b0e4117ddec5f3ec8278d3f1e0e4b3c3fdb8b09f1fe9fbc1706dd0d0c777d9c2f3812070ff741476f2d8ae1c06e65aa48882bb0bf4fd939c9957a4f26c870df7635d0dded2ee95d4581d150caa7d437cf146619fb3c36275c839e2de65abbabbdb778ca8b2f5e317e0e0b98b879e4a5ca1092aceffcd0d93962cfcfdff5a73089e908b501ff91c0b9e790f60698fe3243f1c9266466a788a23c9a435c8e63add2aca2e7312ebbc1e4d4eeb055a176ef86cc48958cb521925f4573f29a523447a013494f76d9bf2f0e71b20ba864eb48ab7bc6a87f2fffefe68a4d2bb6e982a403db8eb8884701bcbb58fc2541fc526e69f8900d22b384cb040a34f878948ca8464ee4327af78e35935aac252da4d2f0bf7f70c972a9b9394d9e0e9ad70be23e584987a8efcf63e9f233f48bb8fe7bacb4db54849a6dd938511d656562e8c0c6f56d927d1bb998d77f5a586ec3c9272e7483870980792a2ff11867f700047311624df8b8796dfd255eb0a7e02f526533454d5f514a8bc9cb7f22acec946c8310323d61775ebfe687a5dcb2d3136d95d9c8e1c0cd14009e38c7f5b7cf3cf3ad5a5a86d49f97e8531a64a80490f6bf4f20e54f2454a60a54d2420d2380d32b28feb5de3e6dd6a570f04a3f5aeb50c5806359f96b88a1aba94afc65b2c56ce6ba857cfcba766fd2b1228fd281338bf8589948371c55cb5fe6e9d269a22d7def74eaba6d5c14fa8bfcf7c45f40594271cbfdd789a94a7cce7c1112a103f7791cc3bdaec7b894c9d0fc5d69eff86e1aa5828bf3832bd88cf09a0ebb7212c3e3ae731237e9c015e4204b064b9f3efe2ca73bddc535ea76a3bfb8ade5576268f0453de062ab09acc32b4aa73ec0d66764e7c61989803200367592626b5943db444703a51eceabf038a21ff24b659a37711104d4cb1263e008939fa4c792d08b6c6eb153745944bb3825850c444278d7117b5bf6a5fec46e85fd1cd65a388e497e19301d88501f1f3b36303ca2217201dd2ee9bc32e469a70d25970d70b36aa336ee36a2d82f73bac4708a827e6682fbc9fb5f0cce4ae97125ecee59e81cd7c4bf7eecaa9cec941b467db900d464f2a07d3f64b9e35e7bef19af947226b53edf807d8e510822977bf813b3ea5826fa6705d8e7e4f7683bf4f8c209b7bb5ab9815f74e112667b011279ca8b013acb83dcb9a12ab1c5b9395047bb6334de4f148643fc4c44459499a80d9f60c105bc1930b157c571b1f64a6945c6f6b854472c3f67409467a3f37f194c13e26ae4ad228dfc42a669ac09cd135fe507f21411731e844765f21e45609412aeb135b52035a443f19c932ce1bbf3fb0f600aa23d1374bade775a81caa93734faa76e1afc45e88d564d3b2f95af7e6a5f1ec4d4324a275891e7de31aef0969b06133578f181a48973d0eeab906d7075aa88aff1e67b2e95c180185cb0bf3176c56e6526bdac3a5f344a24a9695ba6ba021e1da745873bd07af6ac4ee33ec1cccae2d837d0bd8c9581d1ebf64b0c5c95c0f09f88fbbe53c30f0d22de78edadeafda1cd181c1a475730059593b913742b00e15346ffa643be2aba216351468239ebe74c78d727b09e616cb46eff2ad5b3eafbd27aaff4e5b0515baf29a824cf4ad24ce85894042f4c39bb496cc4836fa9484d4369087c61b03626d02df6a62490055622e4a12aba76161511fe58aa20e926adc79470558b1c90d16d7be5158b33272263888cec4257529f1835f39fbfdc3d87d7c5f9f1a4e2e6a9cb6e6cede64bee4750c87ea89c004ea660983d814a0b28dd2946cabada7cbfdbe9360a75c901783ce833e54387556a9cc7f7f7911f23d96777fb7acd171e15aa1612789cb75f73a54569d6d4c14e23e3538bed35cf1c0b45362557853845621cdf2e23d89444d92f1f66351db5c0733f8229039afe83098e60a037487912207511a98fec3933b511c962de2bc72406f6ad7bbeaa2887f18e505627ca988c4d37fc39e2c6cb2a9142a9f3d5a8efa3b9e78113403e95981c87a1848c7196a2e0bc3b4ecd1b7c0a036e98edc8b79a429814e67c8452169f53147d40990672dee26deddd00315e5ef898ef245ce1890eb4c427339efbd3aefa09529131d94a4d20587f4700aa83eb17be6720c3f30f9cf680829b116393430656cb16250a9cc21f75436957d0ffab7c6d95b45666d08cae348f583e4af71bb6bf7eb543cd3b7c5ee7ba031dda15c8b451d33d3cb326b6aab7bae7ab5fb509f46e7fac860b044bd3a0d29c3f5bb2bb6597aade1dbe23998040739c7a8609e29aa766bff73f58f9ed9534537bd97c95a8b7bb26000470140af92aa71975286b1a7d70f63a141e486c9dde6385d641c7b8dd675e6705ef43c80fcd9ce6ae5847e38d2018e1aa4c0a56b2a8421d06aa8d4fa198fb2739dd6d8c4fbc3641f1bede93c07fcf1ee6d802d0e808aa372325ae9bee048867ba77e6ad7d33bf2419ceee34e14731995dcbb9fb25131c8a05ba23747c98cc7ab96823f8e03ce87765e78aef8ab8b2322f6f2474df90454cd1c9d825892e1475024b1ccc341467ab89da68bb16787ab628e12848feaf1e23a95bedfc999b37e9d712a92df92526407acddf272836de81efb89ec8c2c898cfcb0fa646e6b3f89b36cbd771bbcc7c611eca8434f20c782375e66a918a9948d5e8e7ae2d7f780600d24528b02cac766f1c1c6232b4dec79f683bdbe78ed4b09b30a3bb69145cb842d65a7e1fcb75aa32fe0bd3d4884f7462809799cb333dd3e2a1a908fa4b09f56bec7d0ddedf040a6774c502dee4befca5b7af7f4fb4d2a5e3a2f6117f04afb5bdd423f9b2121425c864f1b72469b4e6832ff2cca12e6f1dc5574bdfa70c1303348b1e44f4786c51a5f1778f7e06245d87312722a34c6b207dc2fa1504bef9984bb9689a187f352a42ec83d042be959f5568b7f545e32e2b3528e87672e4cc552029699d15181092c5ec8afa78903b2e0ed597a77c3c439375471c56975d0a0de72de6d5c3fd030ef62ba2efa492060d86ab5c34195c743b3555c17e417cac1105cba281ad32f05341f60dce04032feb2343e524f608fc7dd22f75d3ab967fc8ad3d3af252b868ba00ee11cf0b6567c32faa56b96e9c3f6fa256ad85dfd516e07dc19747dfab5ca62cdac749ba888a409be80926d360ed811ece13db1f2d918b18dfc152498e59926783891a425551c2f90bd078de5a704f6f6d46b27588054813e7701acc3421a8a48f3872a520135c6f65821823d9c52e3b567285800879eb402a8309eb3744f002010ebf491879efcc587c1c293d6843ab78ee41f60d336164abd75b1cca0eea1d842a63927bea175245551c7a9e9686af046f5c1ad249830bed8e23d7668fdf00c5e282fbeafd12804ab1659db47db58a1ad45baff50d449af8eabdc5d5b3dacbc0735be75e3017de2d3e09b9f7c6826e9699544357e10ff0648cd3ab39ebeff92ef43c7e42f42ada4c684a0aa0477cdfd286a0242cf6a53c48e0642af4f3171b700d8b66325b879f6ee5681bf7a95ed99ad925f7253f49e1b4a544b856571d08b159eed9738fafbd0b5a01b33a332942d48bbff6ca5a4f50e9db40fde7643602816e452663aaf619911c47307553e6e2960854e7a1def77baf8e7ec6d51eafcf57cc9e33f1ef47fc3b8da82cb1b15c640887a5baeffaa23faf5aebe39dba0f2c5866828cbb7b52637b741422398f68d8363ef91b02a43fc970aeab4730709c0a76608b2b125d8f6d7a243c7785b7fdc71f6d4d3498341c29ada844cddd57405f251fdee9c0fa54145880e779b9a5baa0b8dfa3ceb03818dadda11323fc16dd828b8338c2cae05da1d3e2446a429e0f78a936c18f2cd7776b88a2181841226c24684c9bf055d57afa64cf50ba016e0320a5295ce5f14d25689e71c6e1404ac1d20a2f7e46789282982e91dada934b7124a0dc5ff5805c12197eec29cde02be811156eb1a82aa1ffa3672d48d9d03433f7193613b471590efed92161243b4037b42e598849d9a5f9a30efe96a7f12e6bad83e93fb3a7e5cbde9f8a2863c37edfa019ff479894361a7ea523ae2d21072d6690fdbfdc8b231f1c078296b8c3f6971e3d7d19c3788dfa068c9385ecf51d37b7cd60d6c90ff7a8731f5f0d8834b99f0a9c3077491cce1826f8e3c08bff9136de1e0cf6503116935fcb61db0b1da1be7ccdac320de19a69accf9bd691afa94da02da1b29952fa9617dafdc657a680bd70d13e0625fa0e166843b7aafe7efe4e8be2b5aaae5bf8eae1208aab341f521eb2bffb63723311f342d051d3aede00269fb43e7174aaae0885811a34cbc0d7ae97c22821ae378c9b34795ad54b241a4fae937f3bcaf50e9a1857cc57ea58c2169f05140508e15327c01793e10098f0b700e4a4b34180c64d22d4a9eab71abf72e2f0df1964d71dc9a5d60af23be50c44be4a60220339a2cad9657c1e19e1abf625479392d996dc7c18bf4f24cbee8d0ce95227c82973da6ceb4af0149cbfd64d238ed544fe50d5954c5faf1657501c39ef2563a0b94daa688ceecc4b674c1f1f5c33c9bc609aa651bc93de51296337caa93d7a7838abec46a7e8a029b300b2693ca93059b9ab9dc00c787ae601dac62c4ba1f18cad113cdaad5bc4745121cd7ee1fd9dafbdd9ae91845759440a8d8af6e3ed9b76106fab4becd6854c7016906f76847829c52094761589a6b262ec661b27d5c56b00ae54d122b8ee45ef2878fc6f0c679c9e4165d49711a3fdc4f95e54799a9ec25141cb5f8244fe706f1b699e7e86fb7bc8cfda0d8a9bbdc47a98b2ab1cc372e0a665427ba043c2de5869f64212e844293311d2ad7cdcbb554ba2fedd3707534698700c1300191d42b4cc9af19f54aacbe22e5cb9e1343b7a730ecdcd97f1b2d5f7c53f27bfa092fdbad9802c3bd7e4a2d83fdf7f4e533d84c8cdbfe192c39663742754b80d1e3a6cbbf4e404641f21e99295e3533a3ee1a03a4765ee349c5967b6294ca66fa1898bd02ea7902de871ae1387d348b5e40ecf2b6a78b2374e802d5d281b1ead7f56f06a77c40c6e8636295ce93bccd254a9ab7a12aee79533417caa6d94b43dc795b6e4766ec67284eb49606ac08e1811da6f94879ebfae88f25557f5ef1d856f64c5575da53722a99db9872304c589c06d4df8120eeacaeb3573103a8aa714d61f194b7cbd3e83e28d2c7f42f7f6bf3c5fff0cf94d0c3d4b0eb39057d708a1fb297434392b08541696300b605bcf5974d4acae7961c009e960e81d752c5eb1fa328a356deac61141ccab292b0fb8d6493948c102a4bc1b61c151d34097096a45f3c14ff371203f28359c1005819ff6af3c3958ab545a209820ee9d354352ad13dbd41beca52f9ed1c8947a1b8ffa9a8e52a584aaa02c396d1995f7b7bfcc986135fcadaa9447a78fe9785f48aa58b37ae4d69351d63a5f9bd28502bf5ddab79a71f0221339a817efd7b0277854600edcb67f570853c687b526497cbe876069070dd6f8dbea9b0c5d9ab14d6f9b1b4b0a4dd4a3d39824d0a54039c3d8bb3f2b5c500dfcb86cbf5630edd53d743d8b60fdb8b455d9a1c935688f63006f809ace8769e73562078f00cce150d25812032772a957db1fa605938e4e2636ce7db02738110090f83a7a1ce3342fcb2d222aa9d730ec33523fd3eec8905ee3941daaee55c3d28853fffd6c5b7110b7254a9ff87d446e67bfba034d6b97d626193fbe2ed5d23076b7568d392ca53483ff772cafb50693df9c264fcd34430a3277e7e7c8488645ee77643780c7bca6fae7e677ad51d0c38069646455b45a5a28b6e082d8f7d27db0a72ee35281a845fb873276a66fe373a5df38b1cc51ea296bbfaaf6b03e1b9a2e1b9c78b6a46ae77ca66f85d28ea190d6820acbc12c114d4d7b3648a4d14a6f85e36919f86b37f89a2418628145586fb1736ad21e8473383f7ac25dbc043e52c35f4a6afc093fbe0353ccfaf9fd5d423f7f52876944bfafe82aef650ba5d05ccdad1ad3a5cf26287811025c65014fbf49fe8c42b201ebb5658216729ac74642f4c1ce3f30c21d4bc0206d811328d29c617859302c5ac2030cdebd0e4983018c83739974a2ebf48fc312c9af0df6d159ba9d2d501f3378ba2ae078e067e0bc08d754376341c5a8f4843b9ae573229e25b19397ad16053e681a278cc18bfabbc4fb45d91ebf45606513775627c3245963c21463760520aa2d0cced76b27c3bfb6f52b4af40a21d559c99209348c184e28c31c5ea643569206bd822feedaaaceb435ba747ef49e3ed65b6bf1b3fc43de6b518fec636c7f95d405baa5bceb16b77a3064b9b80c0c8c75a3e5c58aec8bfcf9ee746fdedef0f0bfb1835fafa5d6ab01d9706b5d71c4c34311109e3e54dc35683beea7576915986ebacf96a638c65f471d6ca639f967baf082ea8b8ba24f33722a594505957f378c57bac3076059ac7b60f8a252f952806d1662e8894bb614d36e00dee626fd379adc060392a5a8725197c2f92581c71f5397a5185afc0dc99c632bbc90e01c93a9b33952805bc348daf17ffcad8aa59df181235e313ed8209d5b516dfe00d84f9e1257fbd2f107fdbe7090f9510714da9bbba597f256f3981fa6123539462cf6d38101b05f4d4b3d5fa2cb6e1ee629f1804f46014394fccbbef504b20e27162982d98924c61fbd127efb89fed12666de8cc69aab73a0335b59b738e2e7ae873ca08a1d93150e3ad7a08b355c1bd59e6a9c63cd7c3e941bfff6373ca96ef7a2a02d82ca5ff8c079e69d1feb078648f5ba887ee23d5a03816ff85f81c9a9cd8ef0c65480e83d97e0a75cc6c03fce1e6a7ead9a5404e4abb1361c745714f08d0fb553e244186bd2196e106d25ea068b34a9bae8d3abfb6703e94b889464bc6256c645553e5ccad34d4f83573b81e419e3710ce87af976c6ad93dd6a0b5179e7950e75a464de633b69c7db6989f242070f1ee82f9953701056b3740813163fd57038cdc15d234b8db26b2163cf1bf4b82835117e4a39fefb186cae9bf6c1f15c764551660e4e5d6df1f847cdb7757da24a44801670413ca87504608ddf5bf3fad3bafb5a8cf823f9e292eae427042d77343c814129ea3ca19b9522818d5ece1d5cfc32cb6bfbf49b50df7142461bf5bad0d7c6d8cf4016c0cd8f7df935c2edcb366bab607979a836d5cae44aeb68c097388d735b2631c815fe80cdd348f6300029d3f3c5501b32a355614cbf76633ac7c461ecca3dd66790b8a24b6e0a3e8c2efbd553d6a0ec3d1ee604e279d626999bf5e3dae07181d19ed3ee9688eebcbd1ea19ac3442bd66b9470aa7bdafa94903103d724a55e330ff8fed46acc3323d77b28f5d3bcdeabc21fcc2a6cbeb2e0a9a70661dec8e5d79bd13b0ecf4d1a2f19043e4320fac179ed1cb1c94434ed06d5bd1a7f3eef3be71f2a09e8d0bfa9b7dbfc8509e835662f82e30022b0124d3ac189a7f30cc2bc78966cdb4f61abede4aa1f8d9081dc4baa4df5b46e0874c8939c24230d6ef260603f9067040835c561120a1f2078b99efac8a047f0b1f51cd05d0b629898f3055d1b8dc32493288523b8a2281b1283671dc37bb6ff911dc62e0733217d0611b9d6a772cf34ea011fcdbd23f2b03ceb580e9d63fb0d0ab87eb20dd23948279115b10a4b95b73c6ab2063d54356a0ad04ab60f57a8efbb94ebe9210486ad6200631aac31cf898dc9d0c2d01c789c815e26bf572c65f1a166add7dd25b5e5289baa4b4f6ba73f3d903a84b6ed6c897914c215f321813203a723c924be28a4ecf9360f83221d744c6d45f5ba32ea3781f6816bded86d43b3f03e972890075806a6313b8c16a46e5cab9344b3cd1fd1cf2756ac53a6007afb1a4907d1c8c7ffee77f2d794d40958eefadaf48975ad5469df583de7f843f9cf32bc36e11f3a2967f561f66c1490a751221e9e5cd3e7105ec8d3d2362e08a8d9d657a9fe7c9e9089b9573ee337b7627260317d62ae4fe05fdd1e7054e5eeafbbefacea15be1ac3fe500cc33786f3585b7445aebcd63a365a0bbd84d2573a393e6231afbd824c96d6bc0e89838a5500e488a0ea98f1ba79d18ca88051bbb995ff9a19c46371607b260861177a6b9e5bfe1ad938fc4ec53075d70e4ff83add24e369292ed42440becbb3cb7f88532eaf59c7930f2df9c507432bb1aef8bc6e12e53c9d6727a2e0f67386ddea6ce6b85cc73f17f1ced68ac9261df34c273ad78af66e5f503ef9ac1b9f6c33e93e319f468ef25989df7ac99b56c09ac003945638513e0835031e4f24c894e9a99741a3cbb16fcd2b31427023d91a7a5e72d59954b6d929d0e724466be6b0d73bd6598a2b0eb56c4eea855761fba8d395eabea36866c3d7fba7f64994c22ac08bbe838be3162044652ff41f004a8e62e0fa0c6eb4e669c71f9215706639a037d6e6c321dc0d2a10c97c1b5901abb82785fc7257dee7faa8ddbfdc8dd72cddb57d3adbe38a8146cc86c5ee933043243196f027ec30344151d02ae018b674553c1a7769228400fdc3308c18046023184f855803d811c11de5099c35dbb239202553ceb56a6ad8498252837990811e4de7d5d08fb44a424511ec7c98dbd37050630fa7c608219597168ebbd7657099769faed6c23ca1f98ad0f6dffe62bc76ed9667da454b4aeea4fe0818178e7c868bc9b4e65ae865ff3527446557f61ea1860cc5518dcad888cb91a5f53780f01726271160afbff6e079485cb41b5d7ed76c136505359ece7311386e5014e578494199b2a3ffe6c18fa4b2a5d5cbe20ddffe2cb1aaba0c21d37e74f2f89834cd2b78cb1c3e0e213de9216068da57518a4790b68a532e4ad94e85eff01cab22a10031e2c0e44b81d8f37d21f2b262602ce956f00ba64c6c75b009aabcf55d44e65eceb1a823ec734748cf0c2dcfafe7166c918897c65c0dcf4496a0a4628d6cbead67b65d839578078347ec0454b5785ca794a6a5e0ea6fbc2b503083bfa0fb4197a3f486844aa31b5538e89ac2ef8498e8831dbc478702be0e1bb9e57be33aaff3d16354dbac598588f1287d78c3bea42b577021de8e6aeb6c915a32e37dae77ade18014ecf8fa16e474cba7be22eac1d0eae70c8109a54028fd0830a1c7f1b85cb2d75d0f3f75e6c0f1656ccac7dae46e6dccbda04417ddae20173bbafdf75c24851baa831fabeb3e5fcb937dcb5223ae377ad6202dbc2688b1b536114ba21a71ca589fe4550a6791450d46e995f6beab6f08b9ac319aae13db6b30ad46d5776bc8ca1bd6ea7b16409e9b11ac6710a1ede9f7ebe8cd8a75dbd47e2f41c43bcc9d4c89081494f4b07c1446edd92d8b46daaf8cacc0d7b9cec64549cf8a063d3ca0bd22b4840497fd951cb8782bd699e6aa374b61c054fccffb0fe673225693ac89c37fc463e3f6e6593d7b6b54740502f01c8126366638d9892d9af3d182efa9f66fc0c6f698add329b81f2bbd58894d309b1c1056137d50051a8b87b3e9e88ed97b501898f91e3a5dec805b974f5c5f570a8e9264344eab24a0893ee708ed93ae8af749f313ea9cebe979fb71449c9e07264aa6ae1640ceb30f66a3e3da31371c8b0f6dfcb901909e0969da6444996fc269fd7dd639e52a411f8530fc9b4d213991bc51cee32dcf2e82aa7a791e0f37a216b405fe4b63f21af260254044b9a020a898eef2f8458c43765990365a00fb86ff2ec311956d93d6a91ffd2da256344b277a0d9578c157df586b7a63bd08bcf18e0cc55f6ddaa8bb33ddee652366f1c221d7b8cd9dca02d012003a3e3cda5b69efaa81673dc4bd6681e98741b2a47a7064146c0d73d803b7bcce238c4b565925d68fe5b5d6ad163f73c72b8b37f9e207cff2e63c2a47c04160cda08706fafed5e92c86d532621346830273e79196c17d9e7db81cc8d94f700a9a943c17a150ae2a2435da558f6f1eda040fc9068119fe539cb61f232f7254b5c48096504de09784c7cbe81bd4f70fc7695d61abff293552bd3124cd0d3d141aca1aa71038764707c1be8df65f9c0cc3d2e0665608aa5186ce9d06ec0cef1305c8b264561a54f18dac4e3e27bcc7a252c3f27997307054a321bcbc1bd6605453e6abf0dd16ab19f46957e601cbb64a72cda6821839d024720a699d43f536105c5ed51b53a89c85aced6bd9f21e3af101e9f7707d8e68903abb65df59d67e2a9522735513124e6d2b053afff90d057ef3d71238c2bedfb15bf26807ade76de4e056d909ba4190c21ed4214e1354abe9a68c129e60b2579ee78dd6db74bec000df76356e85a87081e1dcd210f8490f0ab471b9241999b8fd192ece888f1b78e007ab33b062cf57eb4c71836a04e1ff44334c6fb5bb582422e01918d049ce75a28d7704d897d81e60e5e666dcb36bfcdb97c8fb9339105f35d19e455eefa7716d1bf07225f385064ebc0d04f47030e083dfd831fd935a24ba6be38f7da98195116e18ee8d9523758102711c387c5154178a92179a44d436d2aca8ba993d657b80b5fa073c5363d72a94da8ea6111d1547d088a08daa8c0e257db3e7fb5a16b7691dc979efbb372e4c8ba6bf632223c38a89f9b4106b2f1faa647244c66e1c96d704f633a559221fa37e6898823907d82aeb1fc9d4a5adbc80cbb8a399b1606be65e3ad914398001f49137a10f3ca14f9fefa32a61e2bf299a307b48d06670cfde357df72ebc1dc68e9c5e35c085f9694eb8844f442228279c06317f4edc90e4c2148a035cd500ce1bbb0b2f2b78640c6c33931b559fde36136ed649b9909b8195b5b74c316e23c65f5d424782789b97e467bead0da79dff4464b7520f5a9ac18a71a379a1fa222ebf520151c5c603bfad56e0ba912162a03f3635a92d53171123306569d4560e6925b9a9f970617873435a446e783f5e3b44b276e12bbc246c552d0774ede4bd8943fc7a72ef84cf941ac95f4051043a9b0859ed702199025d53cfe4ff720a4c7d32d9964ab8121840d6378e8b91592e9ab27d05c4738f6ecbc461ff21ca75802da0986cf0912b866df7285cf9365155de4e47d26e5901a372f666690b60263e448f4c27751d89c46a022615969ffb8a5e45f24a1a61789956c3d22ffc477873deba20b670ed779146e9db98615497bcca2f1c6537a14ef58c798260b8245252555be3b88623e00c3f9d708c7469d83ea98ffc7760a64c279302122bdd95f29c04f8a57cad8a17c101cb48ebd26adf2536e5760e51b18ada1144eafc29e2bdafee39965bcbb210773109cde173c6216fbd07e4a2cbc875a720aa5091aade419f8e20f0fa3c2763afbfb28f1a079bc91b79ef1dba8f255a91b3361ee8bc1e6f75d34abe611c5e6a6b945e8aab610aeecb1d376b47e5e38f0d9049b5bdd941d3818dabaa4948f52506b5be8c6e666bdf133e7c96aa301ac17fa07f865a8f11a2ebc60ffe388df8a5eb7ee0fb0cb2875a23f4080fde0715337e43d53ee39f2d02bb40660ff9a28d7da1a13575d4a26da3abc97395f983f866c2267d545193632b29b95796eb8de71c49ede0b3fe342b6aef7d6658135114b1340a8c2c4cfa244e3b9931d23ba78d3aff9ac4382b9a82ee87fc65e2d936b0c4b3abb0fd6403f9d611f5d9b890b1ad9cb1e1a02fd91f4f344d55459af063ce47a1fa0f6f253fddac8f6dec1e9eaa896cefa41e39b24b29dd2830e0c7a15a8432f0d90ea3f761898941ab26fcb90226501c518269e332d0936c0fe08b005a6850cfec2e47af9681e7c82aa6fc7493c1c3b0c32db620afd5505acf234a078d393c2e2cfe6634ac3243957f6e6b37cf747125829ba8220a6d1c748a1e9eba5fe76d206f43f1dd4bd95cedc19602141a5b5dd94ecaf4c22271ede97eae22bcf4b50bfcf13b469d5027f520b2df5e7d281d24a0f5ecf776a696cb008dc1f40facaf80a680ddd162190f24f920a648218afcda24f7d3177c6822770424079104c78e9bb9fe334248d6fbb84b1b64328b26dd219794a3310b6b6a6416ba5841bb95ef95e0f8f4d552b93346ab131c1725453a3160f6c229d98cac79b013ed6a03b70e23e9fdf20bcf86c06e9509a0054802ca5bf8a06f2dfd518674222b97c445466c1a3605399b1788609439e17eae97b1e050d802303fbcbaf2742272fe5c44d22cd01e9ea02873e96a86cb305a5907906fce4e7a08a83b9f6b44c771c1dc45312f0486ea5664bf408e28439efa188b5a23a008e5ff5ca9290130ea2cf9da43dab0d455ed87eca0c543d4b585e8269e8d1839f9c44928d69a5baad5907c1891639c9395f8897b6748c43b3d122680b06f6216f68ee43df3b61341b2060662b55a252f3c7d3fd63e3f8a1969e1b471c3438dc886d4fff289e2ac127425a1f723d013a6d2015ab5686799b94e641a91e52ead382c2a055eb55316b8e3f6f3cbb027c9f134cfaa3b14cf618ceac007ea11060d260985e9036b3c5f8533a32917ff5135c5b75181b0eff2c4fa7260f186cd71eb0b261866c7a9367121de74ae92415d401a30820a1bbebea048ff68bc463e901a845668e73d0c7a1f3656e1c2ca601946a72fd97927a4f4ba7164205dc47afaa3e03d69794f05c8387f87c70b9e17dfcc10ec05839134e570d0adcc4190203a0a2da34087b67412c0ec6092659a86921a2ef5744c34a3e0cf8cd93602cb1084acb4b3bae687fe471726af09f868461089966fcc3cf229ee5283f8c6ee6d1b3c3d37431c1a0b2c7d25919750af9e5a33f3568077a9a3596e08427effc66bb50b53ca7a492d6ca07f4292ec5c1d0aa49ab722fdf9061d39678dfe7bb145c67eef4492dc5e0f817bc4368ba64c8a3e2d8662941de15cf7ba647fa56a44bece19c057e47104e8d3b3cd6cbdfc4b48306ec0cab5251845c0f7a2657c92670928f353938a294598db2da4153de4e43dc30b739153a1ba107fbe3ae1f3240c0c9ee2981652022ae52d98dc441f7be8ec947cd3b2cb82dcff36e6ffe3752151aee5a8916aa9cffef493da1822a5016d11ccec56096e2220ca6a9234b88aaedb5437659cf436be3101a41055cfeee3e8036986440880a9934eff2bb53efbf441be4aaa657a856fc8626200434a0cdd064ac1bd883531341935011edda16cf8a1681bf847312cc7518f2354c60382ba17e2a8c996d55beeb91492ad0bbf83b5b291b8b2fdff0fcd9d606012c6a4f28e0a8436555a919e6886d2f26cc1d47975219b5354cc86016d3c55d303cc8f5b278f6f7d7315d60c187fb71ee17c28b255c014fbabdf38710140a5d691ad6d0d527bb299cf582e52f358feca8a698a0edaf91a84ff1c67858db5bae44a1fdc61030022031d1671392ad1c6936cd4438eed2b829d191cf287444916d4ffd70d59e1768b0f5be3e173569ac0f919ad8f56967b11fadcdd05de081b3895681cc6448d7ac921e38146a1def17f8ebefcd726fb955fb4c0d09a0612e17d45e4d31175ab3a66b10068bb9b3d80f9bf66a5a9de12ca3de1a6c6d9cd43fb78fe3c88cf3579864fdabf818b67f92c59977f568c47f2c5c5ecfc591ee9fecae752e19ad770da205edc6e965d4e2e17972e96a2cbc9bc5c39d33d0997f7b82d20f9d79e1c9831c5e1a617378fc7ecdbd743a270bf449b7af2eb2efdab4a51d07600bc656936a531c2d9783b3232f865fae2bde4b2234bf2e76e9bfed649ebfa14ffb7c9bfbf356c8af87afe43c5ec296ed1a8d299e2ec8dd9dc0e5d0d67279662e93a8f8515cf0c39e64c63fefd6f92d3acae6bfed3fe8c996b33a2090807e78ddb8f855a20bca572a0cb9cb6f39ecba3c7f7cfad36371b4d90e215e10dc8f2932871fb871c2c5b36ca7876124bd25190bfe226cc21d250838c9f928101e81aa0d5e889295f9c34a7990bf002fb39d4e81679df01c7c78bbe3e343192909bb96b60709c9f693becef3e97df63d90a0ae653f9fee626ae94e61aab87aa5bc7cf0446d3b6ed7016ea3af1d83a1bfef4f27662a22c9026bc14610d02a38fc82ee9cceea1014c9436ae6449c8037599f8ccb316aedd099c8170778a2e8740046d41d120721fb881da95241fa6d8884c4c5035386a2f36f6e449b199e15adfbc9f5e2587f207352e0c0cdb9b4bdcd6ea34ff6874140bda28b3a5a2ed762bad3b743fd2d37810ff2de2e7a728d8b47a3c0e507c4d89a3dbf0834e7b8659270735a95e40ff750936c69540db5efafa5320f24685ceb7e0cba40dc4a4f9e74f2f084194533ecf48a12af143859acbbf5cbaa45564234fcbb299bf07945a64e6cb625a2bc880cc7d485dd20404056f9a1108c9a37d6f64637a3b2cf48f8a8616eee77e9ee47ec80e2c7c34aedbd556d465714c44e72edebc0d604a1e4b17f808e475d39b5f699477c9e9711d3b376b5d85fb26604c35673c608f292b08fef0ee6e181fe03833b01e35eb77058878b521b6957c534d7c7ee22398f9a1576cd8f639bb55a7451d1e3e721d2db769acb037ba30eef1875454d6d3f5d25a485de7990537c9935b4a5749d0425f51a64e9242c47c980b3edb7d4262493c9a3c516a67259813cfe51bc2fa34d145b0e2b18b48089783ae3f2d524e8f3ee59f93326dd96395185fb4dcdb6e357389504d72ceea2135082d62eb3f0d9b9945296bffcbac948bf99f874fd821f791db1fe1a9327e28ed86204500357e63135912fc66c44766f0963fb213b357ff9e981b3e54460fa525b55b4f65ce7c233fcd41cb0079aae8efc4409a428023e2ecf6bca1847d075406c9d5c662ce4d8019d15997e9ab56d744f2d16cf3744be2d7fc7e16681d2a54f6258285f80f9bf58bde3795f32d500e5ea6449555d6a1cc95554295d75ee9bac37a5206dd48c1f941c59ca74fbd6050e3ef9e387dc2411b3fdb27f7ecb71bfbe7ff4527f2b3ac7d3d4cbafd8abedb7cbcd4cc20b405b465c1b4938f0f846a864f30e3558c579f325e1fc16fedd45862b10b443f21152fa49bd81b5b6fa64c07b8cdea7e6a7412e6ce8df06f10f4a6fc49ea47c640ac8c939939d29190930c0a79949009ca949d41c26bba389e75ccceb21e76646b04474132aa1c6dcaf2e8ed997573afd151133fc475b32af65c627ae0762f618cf1df9746f32adea7190330559866c2fa19104a6c0ce18f11f057e67239751207a4f75e42558905ae36d4324a78a144f9a2d7f7f5ddd6841e2e892bfabc5c7076a13edfb51a0d23138c24704c5394f40601da6af0da208d3f75f3350187ea9aff7e3ec1d210405a7bd2979add14c833399cc2652fddc03ef46ccd0c1486083273589053afac7d426210a97ee9ef09af48a89c2cff7defafb6696887a569fd2236fbc9680236943fb6c7d1d21ffd90e8812fa5f1ae565addfddd5fcdfbcf63c1ed9ef608b6f923ac115c18ec90d04322b079ee27933fc72e3edf3f8c6a1a63845f84e5251627abe047f732b7a07075cd481380a480f68de2b5d9022bce15eb0ae70b9c3612d81dab874083d1ecdb6cc5435bb08bb7c412b54ad1f694c2175dd392c12b5c30990b00a06d53fac4387d4a73c192bc11dc38b59bc8ff54af307e6098f303ac70ee32cddd9646346caf35fe47692a6a5c5177530c09f46a4117119cf259916c2232c127257707e3b621a497279ffcf090e24ffb287e93599a945de7ac7c874fb9e5750141931ceb10f0e2c4b9bfaef4f99dbcbb2a8e3bcd0e97a3762d1010b0b930a43ef4cb797739d30f9b94b0bd349463945f320abfdb5fdd557b4f003894d7d93079106adae93065884ef59cdf802f2e6555e8d31c37d9f67c60b771d270ba6db372fa906a65ba4908b8e8c99b7f9cb1941377689329d7681cbd383d930e770f4d319e60a76877732f91be7a1a0f09fc29c2a59cb2dfac44dd43b2641ebe14d1646c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
