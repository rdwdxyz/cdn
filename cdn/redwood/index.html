<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b55680b6a9d4505756491877f002b3c6e0c22656d2f493fefa31ca752e4dff2a09cb00d90357753ec76511c39fdceda9a62934ea8e3e2b1bf13509e363f6ba59f58f3bea7b9e6f6f84d37a48efd46bb40dbc98dfe603c7acd5c27f030cb64de82c44d212135105129c9e193fa236bf11fdc3a8c9341554e39c2268fd1097f0e91d13653bd8b9caa09108a8d023846a0923ef41090b63972cab70a623497ac3f843b5f8542f0e4da7c8256a958a731d41a4f6ef273fc6d3a26bea3c57a59ad911c882c9a1816e9d06305553f53bf6bfc7f35aca484ce0ce0b5e4b7ffc513208b728c7ca47bb783761e15d858f2abfce406a6b3ea280e0595b876b45c59e922084903ccca6de5ed34511eab25f08565086b002a3ce8602814568236f0cbbdefbb7799043cd9567ad6678f7e71203d19acb9c09145b79ac0123c7c2e43ccbce43cc738520e5d106652a96dead34bc23cc454c1ca2f8c8697b8aae199bdecc443c0e76a0a88914a4c9ae7346a84fb95d1e8a439dd3803e1e429aeb3926df9729822b40b97514ea5a8c4fdc3eb921f1b43abcc289db58db031424aaa97d9cfa48e96029374586d183b4c34347144aa1c4e7f64af5bc3e27bb631275e0df849e18e5b166f378d88ac3ca47b054409019fee172a45cdda2eab96ed8fa7bff1718db379ff3b98d6685ae31fd2b463bdcb79fdc8552a29191e4f947aa00a3781c86c3d209bd486b41be122ffc291b5b3c99a2ad3763eaf19f4f7e0992a9686b04ece9e4bbadccc831541d24438d0582dab3aac1c99fdbd2aeb26ada474940e9e8abd765c1ec87ccca38feb4b6d84d9fac0ce8f143429f85197522d984c1c4856c8b72b53f04d3067bd6835e82707b008787d44acea919eb12a8c0d325fdbca170d417c3bddcf66431f2fab95cc21315e08d28ae62d6cba79169e258d6b50f2612e877d56beff62da295fa381fe865dd506117a950785ae5a615ddd18fa744b487a6e48d275a6485f3dd705af7a21318bd0f959bccaef375d478acd6d1c51171b08cb9d1494274fff7d7fdb53e4952b4430bbcbd7dc193c96149658f124df43be08a9fa128bd667f90fb80217ef805dfc8813bdf36fb6e82fa175680cfdf3ac35938d65ae9497f52615b7d4cac33d87b1d8ab1a2e5b381492e4a48447ab1df23fd0b9fb41111c9dd501523791135b5573a20522ca21936ceb225b7ed5f0483a7cb2dc34517bae1a3de7ab5eaaba6b2609f01642b5611a04377f5b1dbabb4b3ebe015fb9e16f2aee717a7b90d61c6b28cc9d87bca37b350619e57007762ede18d73247833185a4bbdbe574934b8de9b5c329dae9baebde09a026aa4c87e045790999f981f2820ea63c353b2a209bc098cf40449a32b5e7c2d438b4c74dc092164a3b799ececbb1bb0946477ea7691dfad86c435eb6f915bcc45b06fd9ed6823a650fcac83ab91a22bb578696177c75cb4f3fb6b80456e41d9966b580a2fade3939295f83c2de0056ba1a08c82ad8a83b2335adbd7048fe8c83e0499d0c7634c56ba5c4d5301408f1b84c06a51d4965d8fc15f05cda1a7eac8f90423ea461c9eadced818e3aeae015e25671db9077021a1f135af06d3108ddbf5326f4e944ee95e826cef1e36387d955467001cb102171bf8ab85d519666c2148faf665e8adead533001440992be622e81e030f1b8e04c1448fca6a0c93540bc334de7e7d0b303c34e75dce61ae8ac286b31896baaca6226967f1d7dc424db3fc01e0f973ecdd327f2f5c716b7bb3e42fbbe04f87556c9a58d57a9f764cfcb861da1354530666d602ebdbd5836ea9e1aeff39f4faa1c9a6ce5cc8af8fdcaa9dd42b60df89f57e1043176a05fa2563dbabfef28575d81761efd9543d4817d042a66f10dbb69ddc7ea3d612100182529095d2ea3a760cd52d752f70d6dbaed6dc1fb665e11e9f04c62624f853df010e89889dfe6f4caed13f4985f075917a9c0e93318652e4e685f02bac71bf7c1545b86a7c52548fdfbf743227448aab9bae6846a9c288b55ebdeaa0c7f5a428c0a41b4ef08279b3e77bc9ea7ec60134ff3b2238d187e13190a5a97d6ba82b5f54a4bcdfbcd073fb9d887c03f29a29f5f9bbbbd479c86ee680b8ff62cf2a8920bf47006a31eeb9020635d1a6d907202fe5b81e3fb7e1f05bd262b30e0d6419bf9b0070530261964709fe741d2609ddc491925f394745edd525f42721d3de971afe08cd29261daba8e7b378cb4735515f8595eb6ff3de794b3bcf3303db18d25dbf1c86cefca5f7cedd1f71571ae68871972fd3e87e26f655cb455436227b65d0cede5216d9d60a7110545012aff2c7933bce6ac5bee086a0326ff445378ccbfd886d473bbe25eaef45f0a8bae8bae0029fc165052ca91113a2f58c76b6d98065051b63d8fd76c5ced7f5cc0e096ed3864c36a2e33c5e3f45de2438dd3f70e4dbdf9410722bb712fcee41945a3ded130a8ff1f6a3e8468f8eed3206c0e668774a6f6a42e92ec537c6489df3c3361c8ab1cc0cfd134015227f4c4063db71471ea68784805902d3bd3e628d70bdb57ce7c7e5e6ca73a05d9da2d78e6550d31c6432aae73969cf4b3822e423ddb11d8e250f295b22007065321139839b5e10f2fd5c9192dcb1b8cdf6079f99f7d796a211a95bd12d701eb877ccbaf7bf71894d3c1e0bcb55fd5c4a18df7f20f04f8adf194b467fe22d522fdd88521011ff136340af0d938999888734a5106ab44bc819c7538bf756dcebd09f97c5bca8fafa8f589da760626cd28c0183caf6f35763852079d053997c4b69b6fd4cfcdd01f582a3c113417b3f916561a6315a2f2c5a7999ef9bc5035cb7318ff2a94de54bcdda5e200949978c3d339c438951193addf428fa63d61f8b148f68d6109fd16236c3e23daae5d1c9fb870e3190dc732006ca07c8c67b524d6d594d1260a97d192a52af88f530415ddd50f7996b4d9906f8070051a9c9f97c581c8cf35efd57764bf91c1ad7065d466917c7540cf30190d3d728122e97c42969dd272a7cae0d868b0e6e28f50a3ec649d4825a949c39f7ecab7424f4482c0df1b1a0abd9775f8df120d3d985114fe9e7e8876d2f980d4b562da58a6b9bd845cb01956f27e063f0e97e7081fb2fb11db64ba241db3ab9126259637390f2533feeaf3903985585798059fb7b56ca8e58a9194b3ebae25407c522560a78c1f161b060e78f16cbece7cb0706432307f6b3eae505abc736c9c144af4af8bd6061a86baba39c99764815ad7205125d5540e8961bba8e1a675355e6f61d176ef345e20971e241a22df049dca3bad7a68ffd1a1c55901bb1f7d6c0a713b01347c23ffbab8058d243c40787510bb7110fca7b5ba5b720e01e63764ea6b5b9359610c5bc5dc485dd269eb6930f723e063e1a354133e6b15758075dcb0803acca8587b2d10ac99cc5408aa2d32c0ebadf21186596613f5fad4229cf97410ce9b60a8b83727a52ad6eff8430d5baa106479d8d2006446ff8d9d8f31bd8ccb00bed8f6fc8030794aca6fa80f724e3a7defbea4fd25281c025563257315568ac7fa1b94850f235fd5478ef8fe8fa4cef44a405143773ed4522b499d7ad1d6592163902d6f1ac17b411969c0aa4a37b4dabe07dc4dda5e9f24754bc45dc1da160d8729bbdc65acce9ca44da2bbd2625ced5a37d4544c1858ab384a20a610f7b77b212ab156308a7577c24dfbdee2bc4ee844a7204c293c0cbdfc2a692313b7f843da65667771a9db336a92d3f3195bd79f34e45deb52176763b33eab489b7dfe05dc03df8c7cb42f5ed0c017f862459b73660d079f6275315ae99e243ebd727a2d259a8c6f840a6799bc169a9123c4653624e65a92d9a5208f789138e1d5462f284a28b51b4381e23ff19acd700a4c31103c433ef8d636105fa5a91ba924e317b8573932f23f038fc2881bb38b66d409510bb4b1f71ae61516f876ee0df099815535635e54e02dd779f04b5fd6e5b6aee28b3e52bc63d3e38a623c38af891d77fd648c707ad9a7ac320ce87651c32a2f402902c2bf26b2057e7eb684f5b65364fddf4f225a1b754e7321ef5d8b52468f1d84307afc1cecbc649d84aad0eb8559749a254a93253dfec2b97ea3cad0e896791210dc81f95d45b69948e906a478c0f37b42de78eb42423b0db7e901df3aaa2a5f6be8619f6f974394a3b5b4dd07a2e51596962b4eb45cf33d7ba990266730242e4b67fe8d1de6fb7c31e55e1ab4a7a7754b51729659e1280762833d4fd8e52495811fe40880436e3fb30d2bf7a10cae4882f1fe218c7e53870a2ea7f088e17f49b5d52f0842a35eb98026598b2ef7fb40479327ce2ed40e4782a83235c1188297aa5c404c5df8c290d2e3867439460738adb2d6a51f82aac7714c517bab8aab2ea11b7cd2c63e7f778a9e214278166d79ba141417f33e64e664cc76d5611af3ff63d7820f39fc783a306e91a1384316cbb3f183d717311b53029b09cf0609a842635225a40bcfd4d8e1e8c902f19e3b7e1261befe59d0ba76d8455a5bac9a96629b9a2365da63a480510fa7adc5828f06f1015b2b9456deb7d9376fad535001b0b57a6c594134514f993aa9180f715fafc990fc79ac464ea9eb1ca3857cf1d85e1da2c3829174d70c6c42ca3d49eedd738788fd65436c16fd7ad7234baf7445db46f17b35fd087bff262448cc41208bbf0c13c7b02b6bbec1fbbd466a12b3470944bf5ad1d89e99ed68be48dad69f2bdc8029a167aaaf13fbda242bc7c6cac42446d16d27e4a3b80a987291178cdaabf2d7698fdbee07b9243bdad91f123cb37342c60f6fd577dbf83aff35dacc80befdf7a428bf95c093d3cce57d5f5f7056a86aba962ff8277bea2844ead2abf249c114c1be058ac328fd056929720877a0f479d72d3d5feb6399449f01f182400c4a7a6be7bf517e2b983f30854a0150850b282e01c71995c3d4e845235b6d8381a5f43b12bd33c0e4407b67f25f1cba3fbef016096f79bd012eebc767e46818c6a20624b11d146cb84c1993eb5a574acf537af12dbe0a1f47b9a8a105fadb1257d74cb4c294de93e120837478e870bf6ea83ab48727abf1075611f6696134a54c043ef4124ece713b8b4d900e4767d34a031870ae92a69fd380ae266af926e950e68a358e378064e431392c1ea6ea0997044f5dc1e0bf5687e78d6c5c3dd7adb6a7bdbcf95c41a906dfb066e7c67a3081d60caf1eba9635ce8a7ca1f2c9676dad7709625ebf523f3e3b42b123d68a88d61f6b2ce496f0da2f54f23d97a928c83c9887c4e22c2a0eac36a957a30814fe541977097f4581825e4650934ba09c014c661f8cf9aaf0552432b74093c57b27b1d9bc4a096f02adf91e9bb0c07d8f3ef86d80e39544dc535d82a96576739fb72cf972bb4b3b98b32576d1a5948a836064be978dcea22bcf618a44338460dc7007634f48be51a6b4cac80d9032a4fb7363244f8d8100ae0787269cfd9dfcc4365bc3556dca7e55f4cf7691e1c97145efc6ddf5e2a404a971e58934c660bd2469462e6a25fdc6aefbf2b94a541a8ff3cec5b89f158f589f5f2ae34c1d5d52bbcf15684945edf03831a394160622a3fc7fe5343f5d4a83b81d6303ace71ce3f46e14310e77071d17d0a44e9800e0d1dee699bac9042098cc34f61756c89d20f7ce750daeafa8540b865e1724462d8d3a35a7b829ffafcbd6b56d2dd073236c2b7d2e023b18973843c356ab13610e76b0c6033fcf482838658afe19167ac5312aee69ccd4c440b5a066b416ec81fc1ed9743971a0a970e8a4961acb566f23e3998adede3b5c67e167356c144cbd34788a042eb0ce4000bda2da77291c53b67ca28a91197cb29e45a7c603c818b73723f4b56e2cf17f550bdb92370f8aa0bea605e395c154eb5b7b5fb312a9a2f1e5d30be0da5f67c25eaf3cba03e3c81a75dbb0e773f4a7fc9f02ff03298ccf6374c89f124ef5379e665e9925b13891ebf8cf6ca50dd7f8ea3cf21b885a2593580a13ba75a06a769f75abbb146ff33e03d685fc17c928fd1c9e4ca1654b17ab373d1b2adee633f8261f20f9ac02c95c9db9a22f11153b0f5869a6529d1801259c53815e784ecf0f1698380e94742ea49a176510867e29353c5e2c89b9ba068bc92d6d0649a49da2e132f3a662329b4b2a8623fa381e87b2d62df844858173f6b981bc9deb0f7438ba27dd0bb7ed0c5c65a87523017707fc074b9bf44c62f046926fba4c541c32b7708510d2a0f4a6a729e9022a2f192889b5cda7851e112631e803b2fa1c34c2180ff4d69bd44376e4527eb28fc8e744e2bfdf66ed6e5672b00bc033469fdf1cabb254b2a711c8efb3c4348c7111b98b1182dbdf776bc47fe474918ec283f614922f7742b4e00f1205af4a83581a00cb506e306c99a0ac19694ded327f3b756332b3dd22ded03baba9730e531b64fd0d48b33579964dede87b7826951e0369b7a1c59404c77891ed932f64cceb4c08e806edd14243bba09c36a216a42b4cbf49e78d17fd2eb8454cf3aef7f9481fa7e4cad5ba169a60af1267823a19eff70ff86a2a1f0a87d4d1ac454006b81a542a8c9e2d5f09beba12abd413c4462351a2802559d3b228d7149ce583474110a189903daeee4f1ce9c6d1a24189afde94f6d28ecd6b312d0695818c0333ec7be6b64d03ddc2df11da47d4d111d2a18b0289bf0dd56357dc3f935a409ed4e1cb044bd8d509c6226648b15acc9b76ab9e86d8946e474bb65fa3923974c1462d92c0cbefb16e9acbc4783652bec906ea4db0ef3d9ec80cf3ddc34be10ad88306d9ce88bfa6ce6d0804732d15c2f560ccfb3184ab98794fbfa86e194adb8398a0180a1300276b4ce34d9d713c5359bb16f9a96a3002eab6506abe3ae2c630b69f72f76adb5f50cc35858d0cd06afdc55ad56478447a9aaf47492129d951eb92bf2eac366e607b443ea4440ce8fbfd8e1c8f3c7bffc191f436fa8d4edaa1ac40f1fb7d3e75b2904840b74507922dcab39502e47dfca381e83c817463d62aa9735de50acbeaf4b8983eba1010c7739b3a3885c4a9b3a6ecf81bee7db5261eb75f3922b14ca662357228f8cb9e69a37c4dbb5d484bc467929b67e668765c0438cce3f2edc8da340c79bd3939fa363130d9d311035ffc2145846662ff8bcf5e2a52746174a3306872d901698816351796f0d55318021e55ebaf358cebfd4502c09eada459324285c7f260822ad50baf4edaa4b80982de6219ffdec6a1736e73f3ec29c12e22fc40f58c2e32d44582b696fcf77a10be422dec7bbcd0d1c9af0747a59b9fbff7c672216a68bae97ae41b5814834ebbfb35038ef5dbbb82d3cccb452e007ceeb092a8bb1527a1fdfb3c23ca04b79c451a8218fa028d4572a584b1e6d31f71a55651a3a7bbd2644da2da657b221c27e5825d1c140ad59f240d640f4e10d6a80ba78f5c94cba6c756090054cef63e1e37496f8acd1cd19b984669890da46def4d5bf2a0e18926637b7874def9e37016889297d50f9a602ccf75f8743be8ff5f6f1f49807525846efec3c8d7280c7c4af02b806a0fcca8ab543dc8e2aa1bc192c4619248aa4a83e8a8647c0fdf0f2752533db957a07085403a094384a675c732b60152a8d21f1e634233876bf0d966d45afe3eedf6c4e1886cf3d43f824e8dd234b71a135c99b3e153bb47144857f1fccdc1986e6db541f927c7d7287b5d4b105545ac452a54c899143d5edaeefc537581d0cee5de3a8027a5556d95cd940926537fa5cf45928bd5b6038dc1b5c53d7f5ea66ff73399900f5dfad735f49d73f80d6a52903d57681cbc5e6bbb2ab13471f39460bd0a859b3ae84f3475913e1ef02e38782c08190cd7a0506126905bfe7516202bf2c696aca4b9d9c90b85b65036b77d37a9ea9db2c3fb5dfa62dae74d2102bce7b399f333b15a629b1fa95ac908e5af535ed14f6dab5eaef31caf012388c66b805fe3a3a9dc385eb91be38fe27fab60cde14c00999cfff6671ce7a8021d5dc4c2b5b8616e998ed48aecd32de6177e71cb5f1923f312ba1f61876ed89d00d1f118ef4b03f1a759a0b0c67a3843d08fe071b9eb1893257550eea17db116bbc937913cb4a518cef6766931538bb0012c890132fc69a906794528d7d0b2a5f30a108f0e2976835688f5e6bef1699879bbd08adb623e6adae37d43be3f0426e7cf17164ff960cc7b6d455652d971ff992ab0499a4edd2dd40f104e9a2a55a6cfa21e4cc30327f5084ee9ae6bbe2f550cec9f955c34ae932a1fd3e57ee5fe5f4bcc96b1213963f2a7aae3ede1fb8712d2b6d112a5239c818c2f85e8dbfc4af02e07533482d722ac983fd668758c226ef5af017b27ccc723d75f1ff233dfd357ec847572dd2adeef7ae3f0a5779061a915929e4a7b12e25ca7fa01392748f3486becab761fe19516459d719565f8152dc5fb51103741f1361a99fb21b547eaf06bee07f0a2ea514e9d41e57b0e17c1129210fad3ae42a998303d73edf96e40ee436cb5a30e3c14cd5ea22732571d783d7b05d1d09bf7af92dd7d4ff2c072bbb5731e12ff66dc04eaf650a7c32fc26aaa85a9e174f73bb7b9862489dac09b14dd709737fde3271852bc5535fa25f280cc769828a08e8613736ff3f0ef62e2156439c8344338081fcd5b9b3ff9a9e5ce9c44d246992762831f1ed8d12f050353e22db91dcf0417771c4cef799cd0d7ba5eed6c4c6b4c3712b45f7e794a76aef99d24dfde7970520be786d1484e31907318a5f4effd933dce2c5ef3819e625f7e517dc67ae29d4c10b167c4185d09b2ceb43cbd161496e7d8bc6fbb0d4ed8ebe1d329f5bbf614c9cf795add3d60bf4d92e0d6f3ec6d7c9877cc3c38dbd11bea8891da138e45accc35f9410e3effeab96ac10cb4f77d45d0493ebb6886ec07d3968e5cfd7e4ada52aa445285125a6ad9a2fd6c37e6186593ca968b0f555c0f70f01e9eda0445e4e76dd3106e20b8b7757c9b132f6b054dcfbf4bf2833e79aec3bb4b2dcb1429b7892d33c81eac1e2442be1be2c9b04896302af6176a18eab1a02c80d0c63bed0498ed31a8d1cf0fc84fa3f7b62d6a611b323aeb82c3dbbed88bb678c7f4f3cb1ee6f8a5436b6f21a2336869aad31dbb5721d9e61727051299bb35d68b86f45f72b4e7d455baa5551ef53a4c235fd8878a17ef912ae1f09465d320e31ff319a24b68e971b762a926d70989513b6e46f10e199c6a8198337a3f86dfc74565c3d2ce13fc1221269e5d5b369bea5f5120604d478043b60bcc07368b117d5a3754e92c18e15f07423e4760493b8954080d6796f5557e88901615f7da899578f2162c70935b15594f85281f20a7d36cb2a89bdfc6f2b8f3d1abc2105712300e77cc2ecbdf14b496a76d537e3114e811367874f91e047f6490c458aaf5c594cb027efc27d80312d02f7937d3512f7b3d43d13449d094f975d471ed6937edc34f37a036ade475b1939516f6d704d4d39cda70d59bba375dd825ed67aa61dad47c6e56f89468c890d636a193a3ccaa9d37fdab438377e9db6e9ea7a44faa41bba9219ff3cb9349f9e387e98e440dbab9d1ae8ad0979cf788a08f4011c368d6f7424981d28834b6179d55c5cce89beaf6c5b5a8e8deca111e3df5f264d3bdea0d75c37398be04d1ff221ee1ec74c4e0da841452624fc2aee55e8e90093e9b48d0e77bdab546c593ba3a0eb5195d1c35f393d40139610778396e7bef121c6d74862f6eddecc897b22452a19ac678c7694c606f0fa366feff555bf4cef1a51e0462b7d8617301e24a800b3e8a9a0cf6060c5b86a3fb957ff8541717f94fc186ba3068b5354bf3cbdd24ad8e9d5ccfc422ef4e84450ee985cf9e5fb494344f6d02ab35d7204f3529fd843aa7f9d81456396aaca71d496fe105572c666613fad7485a966a1e6397d8a3d910a8efa3c2fe7c658aad7844067211dd80dd2481ace4958db90b9a01856b55300953f59abd670e4f848c56c1cbd5795324d747719abcf322b17cfe5642b4f94868e05fb957736568e5a6963540fe60cd27f183758bedbe765611d2930cd189b31f549da1a0db99641a2cc65184f05e1e39eda381690d7009075708cbc162e6197b945cde8ebdfdf16550b32df1a97b113e567415ee0b7cb36cb0fe2b58b1866769418e844bdb3d7ad9efa85133e7f8fa82cb8294eea0ddf006854527c7d3739bcd8baae4eaae96084c6c9bb0be269bcb6ca8c81b2601d46d9ad2df1ee105a6658b5848563bd0123d1d318b137fe272bd7d4d5cd253bb707eae1174bb5e71bc2f767b0540165b7bb1b5eb2d5ae5138d56c68d1802b3daa96e453c1c52f25a8353fa3cc9ea3be8d6b07644d631a036756d87704647542edbe8c56d40ffd6df973735da68669a1fe080a602a575a9b14d8d41f1b2eb6fd6d965b35e59e27e65d7cbe21ccc328d4aae5e8c2c9e84eb4921cecb16b646cca918435bf55fe3be90aab66c2b8f38e6713179b4daefd9beb14e12940e53a0ce89b1133655f819a78b766f4b4996a6a1da9b4c8bd4cd3bf2bb0e1e0c917bc94a82cf25e8f229aa21bff9d2bf46ae9a34c287d7e7d2eeedbb1eccb096017621f60381f82d06c2328abb89258f8172c09d3bf6956bc3e144071238cbedc9b3e54bc3b5d3070da49bbaa3f9b01efe175060398b6e682907d98fa07a1f0097dabdc9285f4c44418bb88f7a24444eff1b06cf105314d8a48e1b695e80529bb0daab5020205c992ccb9b6c71d528c647875f75f41b3ba67272c80818fc0c476330fe543ea047245fe53026bb5887efa00cbc5372a3df44243bea85ada6d449958e713fb945ca6d7822e71cdd3e044e133474b5221e5a4a020cdde153f037621c105e36e672fb855775e21be8bc6ce7e8c2bda8afc295c6080eaa0fc15639d1ebeacc7f5bc0397ee122ff636634c3dbae7d3d0f293b46a14ed4fc6c81a09809697cd653132e6825ba7f131cd6d25deed7dc0a3b7a610a148cdf1a07f4d4e244d9bda77c392e3dce63319d6f27211200c9f71a31d6ef92dd938c8c6c5e917bcbf83a85294ef7a5d730e63a72ddf3491dc2a83862e359fbe3bb8fc2673991b057f1f676abbe702692a351a256fa2431571a836d651e39b7c180f6bcbfeb46bbd47fe31894d7a60f86c2724ad08f52a88ae01225b6ce3d2a645880f4f219329e7894fb83454953de93b5e2f972e9a6f628dead06c08216e89621073ca083188dca709e2d9aee912b08f5226f8056cca0b8e130137e18b7b1bfb6c347a3961c67b87ebcd6ea166f72ac8d071ef0b239d4f95153c9247829702a581e514a38f847f501e5ad337428b3acfeeacb0ea5ead959c17d1825479c6ebb4c566419f8c4cf98fd908ac61c73f3c0dedb3c7ce7817d69939b6e73fd17306048e014709df67ad3758bf0ee7978b676a387fcd4a26b4f743dea7ff4d69f2a2f118bb796397733a66fb64ad22ed7d5fb4b8537bc21ffa0a5070abfafa582c9b37f06c4afc82603f607f4025301331bf0cdd9b9576d88917f801bd69f2264ccafd1dd4419a7bd77d7c647e24cc256eedb4f58cc434281539d574d19565549e800daba563a9988d6ecddfa70c9a67d739e5f915b29689dadafda3dcd464dfa0b903ee75185d790d06247aef221e79fd8a66e6a324b2194279f47c38c6a1c53be81de7a418bad2da8cdbda44c55baac575d6d3b735fd34838e9365f56761db2985bb78b7a520f30f5597084be9b0d66f7dfb29e6835e61b4dae8ebb8a243cd6c91c78e16cf1b1fab35b402625adf43fc69e6ee6b25922b1e4c200c103802d5a1762324b94e32e84e8d3cc0f065802469dd5c62a197de3ce89854445b1e2cde3783d996388f74d2dc3eb4cfd8c033edf036c6eba1e63d5c8d29680b14c679aa6fcd7b80d87856211e742a9a22d068f580583348ee1f008ef0f3e61a0f9fb6c9e0c370c374a087e63e26461eec855df7ee596fb6b8bf2957a7d6c255bc112d5b0037b0407ba9bed2dd1a7599dbeb6168c2595f335916ea2a508395cdaf3d20e04a771e94e3cd995230ceb208b2027792713442fa2c83cc828e5f76441efd3a76e57bb2fc2b4eb9f38fc2988021524ac2e73479c3c19ecdf7a82317a1bfc61b25a8b3348dfd05c662984aa880205b856a60e9df64942570965d99cf41c7baad46ab003acd80fdff5c0606a7469213538fdfdc578ceeecb7539e326f90b78567d9ecb63cb3ffc554a99b4a2e869336554a38f935bdedec047b74af3694f10cf906b873c5f95cfd01fa9ad497e2076cdbee6e8ea45d363723b898ccdc155a0f46e05b975832fabb1cfbb2dcb519c788b685f69cadced82cb422dbe184b6546b77ab225523c13b0206dc6d424700e2c683c6b031e2dbe9c6edabade08d39759858fbcdd0018d294d744ff2729f2a65c5b23741afa824f8ba2c5dcc1254ea44955444bb0f3759448d86d7add66bfe9fff8e89cf874a8835add787c2a48cf0708e769e5fdaf6c075c913e2c71f4472971b1f493be2ad0a70d4ce760ad614320fb1c131103e850d71258bbb0a285dddaef3742ca5aa441f2c3ab6f57148f2338ff4a13963f91a4a57a3bd87e6e193be2f584235de02aef63aca8e93062600dddad120bf6273019525f3c2acd3af57fedf4545caaccb39249a8119f9762b1fd3f23d8baec8a6eccd600027bca3398c50b24818cdf894f9496102c0e7368105f63c7f9e8b36f7318650d120277f6795ab257d106b5fa9fd348bcf2ec2c1226659377b5f4d59603523ed3093440bab745da08cbbff25bc50327d2acf4247304d67bf08d0a10a65188c31b7153866110609a90d39e4e38e76f1f54937c2bb767fb72ebaef33d4e124c4e25c18840507fd189ff79d07a7000a46514603694e00ac10a97bfcc7c0f8bb4e57dbc3576be3df24e5bb337a386876a76879429c1f8d25c812e5223ab775931b61b16c494960daa0e4c77ef99aa0a35cf1e9e32ecf77d1fd006888f6264da16505963c1c8d7977c63114bfdcd4fb4ad9e3a77f4be944b720928c946a1c0a85918fa55c95db6738ccbac998bb7987fdfe7a032142453a5f5b5f5f939c512b2c99e6bbab9734d91b56968199f4fde1688777572502353027cd94c3c79a3b19a4fb337993e61cc4d92d88b110f2d0b6e1c0f562bb2b725a3ad2641f89414520dbf247fd6bab2c45d4ff4967396a918f16157db079fad04003e9a5de1e3f4538b6268cfad2f213c5c1f6704d505f507ec3dae43363c6e0e6e580e59db39bfaf5842c7a9cd84ebed317072edbc5c722425b31a6b4c59a965c9dd14f0506c451127bd4445168ecc28725b56189c2ff4d1ebf80ca9c7969c642a3290502e1af581a8ee0c5b307a554194db9f5df2751f57c49469ec0c66f38fa1bdcec24d12f43c1248ab08e732cbd30b6453affd20e8a1327a10f2accb7310738db7a5f289016f6f620842341c5ec26f9e49e31d479f5f39bcaf2542c74691076ce548987f70ed35dd8e29cb65879151ff173670b001c6ff50b4966746ee28a003f74c029f456f611d43792cf1214b533c5261955cd2c67cf4fc0f84f626227c24751899d2f8570582dc1743d196ce2a0a626d672feacf9f596bd230010246b70a589a29a7c9dcdff4e8ef0d8e3e62463e1d90a13f35ed7a91c7c3b0c4207c8ecb2e93fde98b0b7bdf5725ec2d8403be471af0adae714935412c91c253bcd323e65f187ab1fb92c5d3e36162d4678bb14ef75a0d47d925523844f2dbf6990e6a58f9b3ccbb15ff4c738d4250d76f3cec5909a44bbaf643022038b4c3a001daa640ad698c5e0407ee4fc11b08ff905c2823af2d92e0794afd1d4784f2f1171406aa794f7c8579b98b8345e499038d5c822e2f07c473f5cfe135b280ea2af7c7c2e28ab7251ec5c917a18bbe07b2b9a773689cba609e2dfb6bf6eed7bd9d0960096ad66697aa97eb37df4507c7c39cfd69286e777a2dde37f5a4e2587573df68892fee278dce80a73979c3b536b5bcbbf1fd7b7bb43cbbb322fa67c0d0f317f908429d1a00a79c40c90cedf9d42ff28192af70f9695cd66ed2aac3a97f71550318e471c31fd8b7dc40906f8499b112b364335d39db650da0dc8b47a07dc44de551092b33bf937f412fd3d9a1d1b415ddaed7f93b27e7a3e16332ca65c2ac40371a0d0c5770ecf479fce8de634279cd539132b88bf4b6630069b30b9e579477a1cf1383e1b258b53e9c99878e188f31b502a62373d66e9a9202bacdcc0d4fda844c2bcd6e889ceacc2f86d5f1f8621446918d7761eea7393ebf38d40626936ab972e488e82ae6e58e633ac47dbd50659c4633a226995b7cf884195249d292f6df5e26e9c9d9c9386f24842dfcba75b5ce33c3841be7095c2ed705ecb3836c7871f79c570a2f6f188edc4f807e3dae384610f43bf58322a111b2b11ee94317079c7657bf743577c7532fc6afef3f45ac6476fb9bc8e9226ce101cb6705108410d9320c66d47142fcb5fc8c4f9b0446e855529e2636cc05b2c6eda62f2411ca35ba6bb5f85d16a355e0fe99fa4723ce13e19da7d8b56ed2d716edc9b6f9391013e525ff935face08933ddd9681a4496a1106bb1c7df93ae1c5cbfebd240ab46a6d0dd36a3f6ca8609584abfbafc647c257068970f2f46134954056d33a5e1961fe7ada1cc1fab3b74337894c8920c6328b161465a85d5327da82f77bb3feed61469feda6b835a195d0777d2aa1d7a79bb3a661bd73e4d7baaf6a2783b66080979821e4a6795965da96bb2334a59099bfcd70fd177401aa0a1df0fb7849f9165d4f7fc1915bcb6f7985a21916428e6a1a7865172e2a794757617cfba4c47c073bfd7ce8ef7b6cfb0f9f9f26b75ea21e36e9721a3380e0587b6d82af8d03213220a613e9687e968f1519f9011510da998e55037b6c1f496e580c7139dc04cb938bd9b79cb728ef1eb121f587e68cbe9e6b12ed6e6ba8323b3ce9c90ca2bd40be0cad350b7b3e37fe82e453ae3c94de59965a892576f128b358791cd08fb5e7fffb3a62f1ed4da74a55b4bf898adc7673517c552257ae2a8eee503a4aecea9ce2d13ec405a5ece60226f9a42b79112689cc3b872b0225f23eaf1daee156b4b0fd485072c1119026913eb7fc4196ad2f2fdba741289189784e76b8d8eef0469214a8bf91fefcd7e86b2c80460f51d76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
