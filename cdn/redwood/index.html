<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fa6318ffd7fe02a05b2ad9a52cdfbe9d685ec3041c09a2c1e9018a7a1595a73d5b57fd752d6929000398e237bcde1cb55ec0e46c15c05479f23a569534f3a9c1ad24a27d0b5ea54908e012d3ac2ce42ebafbf7fea714695f491170317c96d9f247d3d959440bbb3550c8c2849da18760ee6b4569f4050f383e5f3d33535783202f41ba479fb4c0c3cf151eab646cacbc8fe45d269123372f4c2a1df38c2959218fc237f486aa30ae898d484189fd0700502ec88255d6d934824c251393c8c3b82c30241fd384230ba0876ae8448ae3e53231dc0ccf76721422f426b043dda4b322a3a9e6b7d0f1e8a42a4b21e9d8e2ee7ad2588c4d8d1c788f83abb8647998f8f1eab819003142d2f5126f2d12d009459bb13f8c721941bfee6aa74e45573cc9dbcaaaa6c986113809051b3a520e42972da47210e8491ba40c9d1a98c736c24e01da0617c1020be26ec9a948922a699247f1f38a726d6502303565b3e91667fa4705d763b00c40b53ed3eac35a7f099b58cc5b6731d5c473714b27f46a06b4808e67c7fb7061d5ca731ac53a46ef2b277553e78b1370c34e2d54e0ac23ebc942143297959e20b2d8b6e7cfae94bb1bb4ccddefc8d312b077946f09661dd2841410119a8ad2236a94c734fa34155ca3b0a05ccb0a8df65d0da09155082ff23e0d8033cc6e3528a829c81bdc311549c89b9f659d1d6958d61574e8316df022cbea82f69cb9e563e6dc9fd9adf40a1fc1927e3ab7297dc5dddd655d8d2697dcdc7c49b929f0296db4e073190cc87c373e45f4948c94d3752a1b3c85322952901d00e19f06a45de318865c03ec6ac1351143122323a70a078aca239f61dd0fd52cae924a6a3692ba072c3567cf2d210d645941fefdd673f0e6ee4c693a29448b32745a174ec1069a42d7981d9a192cbc4b5107cd8b60a28d74cce6193fb836cc0eab41138be1b2cf094bfdf27002ba9bdc45f4aec121c8a4bdefef36f1bb3b93629219c8373f493e07449021518f8b54e5cc20473e34fa07b00692f23501c00a62b7c8cc100ef5af16edf2fc59aaf7700463728baaa5952f63a44052a743457f0aac0292fde64dc6e9af5ba8f743051ce7cc01032b9b9f4240b38fa857102d401ee0f9404f1f4b353afc08f4045fc7e0b0e21a2e73cc7fb993d2a49ad9bba6ada09d6cc4d6bb4bb97fb61d22db97273ef73e84333db5a28e13a5e34d4868aeb5527f82ee2657c2c5c12d9f7a20152265894af2332029ab1cc0f243b3f8b5abeecd77e944999aab99766c5ca266952dff724b8f94f6cf1c01b0265fc5c61e9a6533e8ebca4ec1c899fc4cfcce014289270eff673df79a5509a4ec53d8e219ff08e144522c528cce042363102855f15d0c6f91f32b16e4148d7a7487b268ac01fc76523219856e6d58fee5b883662b290d8bbedcb934e79395f344cd463a69f61f40391b261afed4620a06b41a8ea6832894ab4a11a32edd2590d7340cdbbf5394f4fd8171f262b13247ec5d818ec11836907f5b6aa1636ce16c2f8d522366ae4dfe40bf901dacace7ad39b218ba3b25262e7686f4794db4430a5583d9e9eaa4c27bdbbf35b26992abdaeeb69a0169290f87b847624e65d23c00d208306da0b8fa7c8b55996d023b8416807da7fb90c857a75927430e5ad2d18d37880aca5430f1278ae59453d4980ef2b3c3e5851e8fb333c7087b3ff422dd29c4f950af5e3c91fe0884ddf7fd365e4c2b18a4493580ae4f26ab4e5f42e7d9da5b5cdc38f988b8e56e31395694e66e1506415e03e67ec2aa30fce10b4e2338186c2178f30c630b9d19103275644bb1422d233420363de4e1644d5368630767bd088bc58ebf9b540178fa2083b94e6eeace5e9e7b827c25d9df8939eaf22427fe8845304499c9d50643654efe48a2ceffe492085092ff413b27a914a5cece7162f516a86778d611d5a01d35be7f3f713fdadf450912d937b76c2537e121606262df47af7e75f8968f663a3b96c2d3ab9372cd3b92310fc3705c5f5c06a5dda1816c5ab66f72bd1cf201bd2935b7127ccc53950392490304237489a62442e670123216a0ffc09379241c4686ceff97bd374c324ac164b9c66db3ddd727d9637a97e4081a1ec87d4540bc7b04964af022e672b8158716b408bc9c67a4763579ea62aaeab8a51d765fbf5f658d71825a295470e20a2e194636bab4eb1caf45bc3831c847d699bb47fc90887f6a2d35de4287126d378341e80afe5f72f5415bb3ccb7b11ca2319ac0bab2bb66a530032673dcc43b5aaf1bff95aad252c8c8babf44b61951bbfcaca11507448f37a0a23ecfd148b541ec315eb5ecb2203f2a269f957a62bb809fd633b998d1cb0edc14427f582c1de5fac0e8f01baf620b393231e4116827e9b5e4203b538e85d47b4e09923412f57545cc485c7ff59e05f518109dc7f474105eab0939cb3f064bd3c22760fa5918e6fe2fee750f9d1376608f35f9d75524c2cf7ee6c967cab4f4318353a0e25d835a39120bafc970fd9a7f94df4c1ad1b40441b1c4ca6b0c950cade066a9e6bf30a24640e73aa9443e64d9271a62e13d12cd46bcbd44fdbe4881ac5b5c1a9fe256c2de5d7536fe1cd84c5af0db0b603339db95477033bca3da5cbb2f0bb615c57874ca911c51c731dd567b40dced050f081ff4f4e4d6d3c6be421fe580d267f63b0ae4eb744f4684c4c8bd66fd3db1b768dcd4798e37df94b3e9654f64dfe5b88599546928763af4ad512c3a83de9f7aab328bc1ee6eeacc837d8268c1eef381730be2ee160e6866a383b460a566170b279738ca54ad014ae9673b2501e8b80c135c577064e96a1fee000da638e81be85b76a4811f3df87da220771d6aab9389d3b950022cb66242c666f194ce2a36daaa008d451c1dd1cf17c3f8932dc81f650a2604ae703637e8d5176b5d78887c393f0b3acdc1b8ea97ce08a7f974c0cd605d3a5ceef373c0b717f12533e1bf56430f316cae1566662f73cce67a5b4d19dbc0a167ab19232f72e7a15c4098f2feeded34e1efa01772c09275016b116289dd426a760472d65d05bc83bd14b208508494552977f61f5fe5551f4eb5cfbe4cd017cb51b89e3f48115a8b6132fb9e192b59bf72bbe05bdd5ebbed39eca67db159d370496c1d7cb12c2705c113830cf190f2bed79acdb1909066255f7d152d1a4a510708029c35a2248f62eb7bf93bd86960e6204ae00e1382751dda9a927a28ba2655026799e6e30aa580fbb0e410ab7b29470ca3583ab55df967f31550e6f004fa3ef54107e61847c0b3046dbc18fcf06789428ffe1f91304b2599e1bb4103912f8bba3cc39cb0bb5e5bdae2272a2d266a0d3e4d9f909dcb4a6dddfe9b832f2dc48ecd57247ad23fd3d8a3295157eb87795daaf49eedbf4e1391f2fa47066961cfca987f6983392204eb053e8945f97ef0f119cc85e9934498ca75647b2afe098f37d20158e3123a55b5213b690f231a98e149b5e5dd2c5b6e861a8be6dfde7585c3b44cb5d7f63bb6c7cdb8fec71486611b864226173430f21553c86d42c5291c6f518890e1ab642a82a060ac95d9ec53a3933a27344dd902903485870d1bdd5815ede8272221b07a735fd697306fdc63fdf6974fdd8054e0ba8c374565af4b5e08a731251bedd6b6c49ad35d93882d72b1ef071e39e61a653158c4653df604eee05ba8d991900e2ea831ba0a0c6af7e851d7af4fde00611fecf75c40c20ec5fcf88b891b0fdaed0c56a720ba12723e03f728305f0ee5db0742ad4c7218515dc1933a2ef311d96c7313686597e2d121252b6d74e291056b98b8a1c515d8fa375e6e195a586875d6876cb74ed05091d59960492559d973d4d039af4616792d36e11769d75b3dc72a55c394fa8cdffdedc9adc3316b0fdd8909573fe7f96aeae51202aaef3db6a58f44fca5ab64d0be80e8be4f98fa3ce3314a7d1f8cded29f7def6b76c5146baf5f6eed6c4662f59b2f8f1b7b3ae41fbe42b0880c688e6156f504d6c0e402752f838faede213605bc03894accec6d41005f68c74a20c0dcedcf533b3e43c0af05c280b499888b452871b97efbc39e3dd71a42c1022d0af185e0a659f87b4842c34acbbf07ec62d23441cee0bd0a5fc6917779ed1eb3779a424fc2bd6af25db81a7f89026b43eeb5d3b35f6946fe9aab1d7faff9c3858658041e8b40992215ca3a876aac7b0094eb30968e2ee60cbe54d79cedbc245f30a64509e5e76816bea2275adaa9eeee51a35055752d589b26ad5496ba26c21b7c953ff89a7d2bb52d1026d6c6e9de1b27b49ad64a718d8048e65c6e637a2226f20fb50e746e44711f1e6d00a1c5d632b1cd891e50be303212abb92e7c83c2dcb5976d433c7912a103d31b6b167f6c69ddbf789d47d79fbad50ad70a36cf403f426bc8c0f89f518fff611fbdc8b76722e123ba31833cf560fc16215d0474411be406234b50fe7b678e6b96738b3018b1a2c4d3aecf940a344841ed1581149cb96139739cb91bfddd215542446a20aad6e2cf893369a885bfd50278bb3824464496af0380880e5593412a8781b520c16951a612f91ff5a6d7d281cff3059b1fb00f7e17437a2dc7a52aefc573af300d60096ad026c148abc4556cc0a9c1595c8d0f4b616a010d92456d30409ce4758c5bbe22038bffa12c4990dc8ac80e97f7c5a85bac92ee0df78db7b35f532d84bfa6d1940d453d2f78b68fb3061ffa3ec90de937d64352cd437bcfb0418af23523c00cd7635e4d44803eeede548817f71d210ef90ad0a216d1328a492c18029caffa3ad79609fc30dfb57d29562fc2ae3cbe1af6529d8dffffd308929642cfd3258148a48ec7a4247030f36d1fdefab2720f30d919b58e32d53ddc45498fe3104bc5fb6ff34804481936715df4151ef7b8262637a2e22956193e01ecd4694d5bbcad34c4176d8df76f4e8d3a09e69193b3232f2a8689a83e84212fbf4f451cb7e379f1e3842e40196528bac6a96fa64527214360e1b095cb5f3a1151601a9eeba743681b6abe857660df0cec4f2edd62ba09490e5bfc97e217756f47586dd1f20f11e340fd16f90360f56c86ca81589a286438befeb77f0c9b6d95c55344e062afbab0570363f1d57eb878805bb9ee7354b9a96a036bea7668830dbc758e8064e2e27a630a91ab431e862141ca5e4ccda6e95a9546bd45e74765c3db193f2b24b91975071c7419d1eebdffc95b5e720e3aaeb7e16597fd21f7e2ad8f30ca6836d028107db1a70396d5fcb7263e94fa2b6d6343d823622141ecf85794be0d6f2801fd65520ddd6a4e3d901859afe8fc29dd5baeff012f543559d1b52efb4d092d72e6c6246e6fa32e2c9c761847e79089543c5ca7f070b396b1d74863fd6ce03779505d817cd96b8f4fa06ecba68ac6a2158ca668b83fd0d17fb31815f37a92b6538ca4f076d67a734f8747a362d1f96b35926d2bbeba68e5140e2ca609f660cbd02e268bc7fe6be9efcdf69ee9294d484878c3ab8a16823128508aac90e392048cdd32e7a210810d1fb60327c660b64a4c3e5aa6a50b2a9246ed680d1539f9dbe42b551da61353c7b1068b855ca6a5aad820339c57daa301c8ef10d95d5ff5fa5f353bbe2015e095a56f827124745a5ac7c082371ba9cf6f2bc7420d29b6c52c39a77556b71f814594562d8aed1e9ef99e9ac662fd2b4b820f6e6a5ad76f9f021399d1ee72ec5a33e1d63f1ca22fc1b6d6976056f20b9b0e34b779b1d70da4c5a3ecc4ba463c94bf90232e956a4080ac80ac1b3352d9005904c9bdfa7d68694d838f1b9b1bd5bd80c941b2c6268400f8ee36dfd8055a0e1eadd5deb6c559356dadcfef4fe1b913caafe86019503b3fd36fd7909f86315858ff5be23d84171b5f3ada2460d7fa7a8bbac18d3a054d2bdaf1c17a78dbdf6132aecab19fce97398d19acf9f9029e8187d4d20fd8c1744a6e1460898cad5f41574deab4fdb16d4279122bbff861056c6681462cff831056c5fbd867a46285f1cdc2adf6602d30953d489b944d691dfe362929eaa40de0b8f0e997bc1f3a5462713898f55501fff0555ee602ee0a65eb50862225bc57cb773e6a44b9a5d2a6514b9dc4ed0b84a0e8f97348495e0c327fa6799294dcb20911651c0d1f7ab81ddf496aa0b1e8ef100215e8f5d2adf3821adbe98bab3633b1d56c953df83123eeeae8c2164747d0528b484010c3eb2795dfed6a9e402c25e71793157d2f6133a1a0eec4ce7fbcff6d554b109e224ddb9ba8eba9ccdb7f788dab1a89f0001901808acff58bdd113871c0fee60a58f924b09ac770229086bb47f0d044eeb7598ed6a931435edfafccc0c7d62a6985892231d50208ec90bf7701459b541465d0aebc77e0e3f8bbd5b237fb503f37ab7ef1a28b98e60c98b7f393bfd5a2de55e8d52384fc83b6d3169b6565d2619a567e06065d4c5efb4294cdea8534dc94729ececa513f48ec911d0ca9e33a23158a2e432620e431ebc5bb1a4ba5779edf1b074df9da1b910e0ba7d7324b3ad7355439d85ffa8c126bf88959cc151aebed1f3da1527a39a6413624ca3711f85de8b9e888120949855d14f90ef8bea3f6898d3987928424b41e66ce76039902f4c5e003ee08e6b1711dab0ab68164abce7da77040bc4aed6d0b527aeaa074608353edd036fc4745477167e5437c61a4add341c5c363933212abd86c28b82b0d5d76fa9336c3ef270ca429e7eaac44c5a4cece8f7a497d5aac7c986661f67ae8db99d49cae938f566be58f0b6c05d05e66194d9722ffa248b5fba7a6c294cea5cf11ca2990f1e1952c28fb80d24f1124c9947fc73e871f143e8e461ffe753da912089b803d4e8f8dc73e3510ae66d728d7b6f161e4a5c15f406006043f1bb9b55869ee61c8a6760b2860172872779385222be82ace9e98f6c598a6d199cbf507c7f63292926114f4cd3136105ef84c4b9b3f824b3b5f0e272d28acd797be4cd9906719f3697bd2e2e8a43597c88d5a5ec63bacd0722869cf9eed3c8f8e7d587965e8f5c9d959cbefaa32a2f57109cf78b69cb5cf0e2171be6b8fb6322c4216b7ee1c290bc179b437e6b91a385baf753c8aca12b470577bebbe994690a7331b0e1c53e54a618adac9053e8b5d33f718998b75833a2c75fb0fdb5acd466cfec1c3f77386bf1b9e86eca69e4790ebe9f477e8b10dfcd59db7a73f70f1fd4ca1a9ce95717c94ce21b05648f8dab401765e7a8ab8b639c2380bf9aea2cc817cc8e4dbf7bbbbb3ac6d75e6ce4f5aaba5c2e2d33b7c95b3d74da3bd2444e05fc6e5c11e8b78dab814e85e364f433a61a72f28f759c9b0591ba0490243cbda17198bb1480479620519c623b05cea7890a4163515c691c5c316bd01d3767b966f5f53bd17b880f6032f2cd3b8617696ad35cf0b95aa28da55b9d2a0dcbdf34325497bb8406efbf3e1a4df4b8f42fdade11a36ce136a496b5e3632db3ee991e6e25ab96a2afe20710d8146d40ba23a5c12dbdf6e60481aa67631bcfbd743e57b6ed5e1f547fd08d0de59c64d346c6d1d3fe0c7b0b0d9904bacdb08fc9d2edc26a6f506d71baa78fa24ef3fcd265870389c740be9a79a6013dee6f67f44d993ae0090b9ae22d1635a04557b59d81b40d248494661fb8a333730331a06861de7a71b446ff35d386aa30c7337295b1f4a9232e92fe708e1b83bf2741756f3d6a64a2814964f3d41685d876f0e43d618a28116d7df9af26864a0fddfbdbf50626a7a56332e653325b1d5147940928ca084ed49f6449c2136dd71341f580565a15a6a2e5cfff09cbb705d1027ccaba4260b708d7acea786dd92ed1ae7f9d334068305ea9aba4ded463e4980d45fedd0670741051bae33d19fe6d811ecca3b898caaeb4e7740342569a45f64b93f0146d73abfa6cd947c84a50ad71017ac0516b430d8e351364f2530d98833406cefe45172b1f9bdfd7dd02726347e83ad97f943616aed305bdca6f4ae6688f271b0b7351c88f3507311ad1f469351a30841e0c95edb6be90b1ee8fa3a7619bafe25460253ba57dec110d7d94242a4872ba2fd885877152ec7e685a18e5b582da571bee703c8951a32f01a971366d332363f5b41c1a8a633c14c03cc50ed2e1e29e7ed51867020eed46dc014d597c2088698faf97fe3fb5cfa8f4037d070b7dba571275d4e5410eb8fbeb39d92b31632abd9ba1e6b280baf57ddf656cb45cda9bfef2bce33e79fd79e750ff00f9bcd378a7fe996319bbbc52677d96abdc18488a29ddf202e672738dac627f9aaea84c37c5fa5748c3bef943377e980c12f641a779bd72791bc4b96ac2a471a4746fdb39da6ee7761161230aacb7ae99e6d9b543a2a4b284297b40b93716ecf63c54d9168ba1c00a41d26be8ac7bdc38e029fc8433253066b3f5a6533729aa1ab50b3ab72be471d4b9988c61d94d392d318d4c0516864b26a50b06d2011548ce02eda1a4e5a6751c4516e51c94fc06a9f8fee58123e37fb089cb91cfd14fcf0e38c559b2726df07014537060f649e5a5e0d7df7f1feb719f763823fcd0838ac0ce40e18aa1b79821febe27194c8ea44d98956a57d7ba2d8c3586ab886f286a990feaaeb61146ab84d9ab27e5e71b8fa7f9c09e763912d39760b7f29e82c4e0a06bba1eb4f21ec01329b057ec4f646d8238adcdd06c5c065d35b3cc69af9bc9417af862e511f61cbefdfe2596f98482df033bd7db2319a5a00d9ec169e6e513a4844ab009b7dde2f4bb8dbe26e46ca0f877acc668bab2fd02f0ae132ac0e64727b5c83475611c0d32462113ceb11da6ddec81f6fea1e066aa6411ee8a815aaa58814628b1b776f879d7cb16189eb9a2e6fefd54db0b3126e3ad5156d3f98ef8e39b808a13e1ff0f8a11031393881048c86b97db0db125e2b46f942f97b34cf83b507e22c9721f5f1eb8a208e51625c514e8f76d0d1aa7f657901b7da2339c108c56ad790f97ed14730baadf934d1a084fceb65f84f6790e9f131144aa63b997ebcc23810090e9f245fac1d5804199b424a6d4e4330c739840bac966ed34c3cf8b2f4b17a789597fd2b32c3d63929aac5f4d3f89dc28257ce775394d360fe03b229637011003be1996fb08ffba6b1d687c4dd7650520ca1c24ec4823af3c2626fdc6115d056a0f9813976c97d16ab36acb1c674a6469e430601db0263bee915a769f9dd6c16880718819b7177025ca1bb98ed989a734f88e9326af80d31b15ee6eec8d9674ed6565ee908ae38227fa8e7db145a504a0b4dd3446a4e4b0042b1732b77fcd4ed7819da92646becd831b79c58c496f71653a06e37167c0924f6037a6f8565193c496a85d58419fb9898a56ad1b5c545c08a239d08fd6a1dc96e5cbb242d71c563f18a0a1f800c110b8f29a38dc2a65ffc1026756aa509657394e20f6765ea6834ce333ae835b759f9461de80e9415f50fe313c2222e343ce7c1f300674dffd68c51b4ced57f1369336860447164497e18740fc714466e5be1165d3718d4bbaebe6a620f7464c5e85a79cc96bc475bedc052e1192d5ae27afc5f6da2e5b74fa7adfa2918bbf67610bb31ccc4369ca8e2a6fce71a6d11d795fc2407e2fbc36cb41f57125e18d788b2ba223acda085bbe54c370f3ba348317c98fd92f36f66058166706ccbbf1145b43bd8bd1efb9c0dfdc65fa5fc52738aaf63bb87cf5203c4e908f335ceb7e812ed1d3e1e379a851fe62a2e0b170e7420ee6180dd9f18d7fac7d4bf426937d810051becfc96f85ed657d759cd09b725e62da4c962a186d474ec82d4126a74686007f2d8a4a353ce577d6d1db5b73b67ac3650ebc2d133d64c52e1cb2ebb3daacc791808f893be0ad9b03ff95b94db5cf6322324a3e1460ca28d67963a0993dc3b8e26946a85db8fd915561b4e04598b28968c61d06869661cc3a4bfd7c05881896661368ccb48ca7c1337a6bce6f809aa3d6dd76065aee4058ad51f740b8ea9b25447a475448baefe5ea9dd408be6026b6abed7cb7b357975ef25e78b32cbc3837746721d1302ea55b313a30be2bc8ad6717d0ae10e6fb93d9cc6bba748b3e72af0009b7ab32f2d81def449c78e7a1981cb0c474b94921258cde4672905f3206585091a2798e2e1ea6bb67cdb751f7bb1eab495b12b0025f54db02b4d2cab6034adfeb2f8b41e31aaa89b23edf2208ae1efe1f8e0e5935c0830b7fb8040c12404cfc30526b57ff5373cc42903e68a86cf74506fd7f70cb8426bfb1b0973928a81ceb1c3b3f951f270bf9d835f53cb8ac6d62ac35747feaeb642fd8e2abf0062e9b00bccaab2a4e5a1d6cbe75a0155c8e92b301f17f259b8081eb4100ccdd7ca48558d473151379d6c11092ca7f15327b8bd6f274769bdd958dd8a119fc2fe0871ebb69b0cecdd43f96574d5c5a9ce0abbf69ef94400f55c6d485b81b059402910fa1238208375e0b2b01c00657e4244a8a5d8904e630caf9c4d753b11d3423823ae892edd55092216d847cb34486556ae5da3950e4a76ed9c813afa14c81db7c76cdf0f22e71c344acbc94ee6191eaffe7a4666ba72240ef6941c04fbc22ade4ac25382d982f3b4e68446f6e3be23109def68a86206ac2abe11f65a9fb4e10b3ab5824015dc4decb31ce691745cacb54d95d406dd2779452810897b27dd54daa1637b7fb0ff9f3ad9e413b8299d874b028d6fc6565ed09180e0c756cdfea767fd61d44fe19680261297f509eb811d4bb284e3e221027094b3b5ee983bc0c088ca693212c61f1b59eb6a7d28125eea160a5f2b5f39a081fc61307e9f93575cfe36f0569a8edf3cc415380d7acb0d6db2e837a61bce466dcedda9f03c162ac3817ca78646ba583bdbc87101e47ef73fc72c5289d1fc618b0e68bfdec22eb5ce2293475b1addc66e24df41b1a2102492d9b66b2b485dd167b473772cca1bfbf5eafc796ca442fe18db4c24394059a3a7e66f7b658c735ccda2905aa582c3431d5f7b81567cf044104e4542bbfc507c3200c90680f772f77d8035b9ea1577db4dfde7a96cea356c68f1dcfbd42e4f1ec77504df7e9c3f717253baf5ab15d54fa8950c53256669f2f1fdf3e38c0a5d9a0981fcf2970c47b5779ea07b9668eedcc12728b06fdd037649d095fb1dce89587239913a8b810fc37e5e74beab5e667527100c13b77f58ebc71d233389b9dd6d66f0c7bac554a4613a30cacd8012d768871ff0bf1f5a33dcf6c2d601699c94c369c9f5616cb555496dc5cddcfd9e99ecdac1bfb426cfd6f2c3f5187665121bf478df51877e2450e9fa3f539323e44a4bb7d513a7cb604195bab58b627b4f392865bff0d24377b2c0bc37cc58c53b1c77a549be85bdc35d53e5e0cc45bf22a3e4d58c1f9f6388b6b13d7e4acf0da71917e96d18f1c256c89a70b45cb160c2ef73e94a1a3902ce21bc5e1bde317a8f6516efa598827fd0590a0485f15b14a8e11c83f3614430aeea4180426df5f82d884e479620fdeb911037de2ec0294e996827b0f681ee16a138a660b3a71ed06c5bf61181c938f8e2a26e34cb53d900779ef97440f26ccdbf7bf390524263a9fbe37fc2ab2472bb0bf3fc1989110fbd77088eba8d4ea70a2a5b3e8b0fe202a0e3ac83130cd4f0d40cdd411ca1a8ac7239e5fab3da9d33e965614c3db9eb1a84d0c9cb2ed418a9036eb3257323e1d48647fecf9a203ad595cb182dee58c888b9c0131edd86c706bb2e3add3232bf41c88f6cfc7b829fe92f850ed6c1c38efa52d88dc63ab56ac9bdd46d34233c4aca50267d69da59e3183c913f953b92d4b9b433fbe0110160813f87d6bd1241eedeea73ec3fb05e427b1ce77c6032461f2add1a93e3d3626569142f2bcec877ae8da284dacc002d037a8900941d803e2988136ddce509449365c6d0fd3513244b1b8274fcd83e54adba092dcda9efe1f25a59df637dc99a5a4e904f7967bff35a9a2d8d3ce6a1aa41de8ca14ae501236f74facf839e5d4d6690437395ede811f6dc93f4c0c6390f8aa0f25ffff715b12577fa539ece07af6b8d34f94e1cc696d771dab95ffc95ff73d89e15dd268f4d7bc8c46d0be9694f293406bcd6cb357b2ffc72feabe7cf36c72bfeb4a651a0c3d3edd2d9a4c0b7b05acc9065ce44381233acd1726c95b09af202d2c35a0dbbe34e66d00638e0e89474f435d896f95d44b05d25dcaaada6c53991f6ff3f9ff7014d902665d8e2965eab9e081ccaee1eeaeb07bc3080f25fe440e98a138adc6856946dbbff7bbe0b28467c8993ee6983af09f87b210321c389c6391468c8c90f0c82fd6eae6b9e3071ec05cb9f38e2ae07eee92348ff3c56a4cd4548d5e64c8f06d59e7f654e9d49e9a93105e1a0e93e57424a0cb895bbb3b358d984bfd6267f6fb6713d2b5051013df3c76b2ab22a208946edf3aeca54bce6edaaee511ba9aeeefed3a0c04c360c9077ce8072d3960425bab28500941974cb683c7a0b6bc0a790a1ca858bcdcb130463a74fcbdc57206b99d907e6a18a5b27f9d41a9359120d7385b27a06509bc96133403e41902f4d29399ff3048ccb4122d0c5405e508ac94fcdf1f924ee78a4bd0e483429ce2b04be9aeb573c49b82ebf27d21a1ecf49c6a5a69e3a558ad3f3ca288cb2702340a36f2db879c6885e8c060c206c354bba098dc84e69503a21c6e62dbdddeceb51a417ae570d5e376199d7758c38cee1754ef47d46b18bbd20335ddd865aa435cf79a03d06e1439f375fdf9eaea07e9961fc13d8e4e1b33178acc9843968ca7bd042a38b12f66a7abc521cf4d597a00c8c8809975a8f4626f1b10bf37a1d281191e3863b63d3d6a89be423b5de5a7a4b5b0e41ca142d292ea3773d6e1ff94efd3a7e8caa77b222ca0ca060053a029102683936c3a4d29900e09514e9a380be0edf279f6fb74a097509322bf70c73a0d7774bf0acae87f6dfccab147205727a409e78e06f3ad03c082a36e036f10f39be96c60a6e13b84b73480d0de5dff00412a28b612f854317016227ebedf2af86c37de3ec95cbfd12081d52d537d0b70091fca09cc2b6e1156314248615601d0d64035ee8563fe8b088f36f8f150fcd86bd1401a3d24ec7397f99119becd40bc8512d35d600251febc353db69f5b0f7b392e1c512939afe9c0703da4c00ea87c4195ce6901c151a49f9af10d4d8ab73e63ee2acb1f1482c8e0277ad182a6ea7503f8f2858b9dfe6b2fbd7375eb50db6343381892908c4dfbef99503928bb3867a4b9d0ccb54951a143303403035fdb07d9f9b0e9410fa2bccbc84b4b78a3edacd61bb5ee300c53d6791ec7568e92d83ce49345c3f0e5858ca5e9eed75a2296d0df59a999a9495d5f6ef1b5a9c080c1c832f0bf91a594872e856f96438f57971208b6a638146ebdebdee3f237a9cd31524120c18e5aa3d49ecce68abb1b2e1fbee497ab1fc0374e4cc5fe42d53e8c5b2214fc25bc60a8632560d9eeae7f27976f260908ec48a7d79d99d664b2b2deab01d8f2a5901e5beffb407b8e45a6576b7ba39f2001e46eba6c902f017a4b25391fe5856fbbe75a820f68c1f0427bbcb3852689e5748eef43f924ca6d4cfca77554708b6fe607f3bc948086c93b5365d8b947661c0120851c160ff277c08513629d19e521cd0f5070be42c22fd1a2e63fb9c314e332cb73ad68a877c59ec3838ebc113183b174eedb58c8c79cd92cf8cb0f4697be2c7a9b6b02bc4a1a313446667bcc9e0e14d4f207e3e4f490fbe5cad89aaab2a101adc0d9e26124d7af937264e62e9485bf413a23364a5e2740ba8b570026f924fd5231cdf635fe98338b99c9cb616a74dc50d1b08fe1267688756f9083c82ef7cd0879638e7e67fe24ca9b55d4d159d861eb3316270836dd5615c754ee5fdb6c1ea5fb6cd8c43db66311656f97ed886f9d71cda190c62efeabbed8ad1a694f545cad4c7c853681a81aad083ee7e2eba0b6681b339293f93b2d10ad72c0fe2fd44b86b3da99223f9be1b44833b2377d2f1c70d9b2c8265e7ee3ede3c51a1f06c2ef2268d39ab1bac0fd428bdff4a3a8257c4fdadf8e344ce544a9fc266516dce34d8e2405031e80d527c0d6f45901260c18c956f6d6bebe3381a9983b23d20d9477ce50a5cc163076e702022001177f11ae5721789cae70eb7a236fc9025ec70ebb465deca3f174067f388906ac135b19bfa5bc6348666f8b98c8a34cc904ba2fdd162a04e164e5e891260a89405d5d4806daa0d5d8bddbd55dab18c06b70910c3cc5b86705377956c944b12f87d4f8ef4a4ef0632111c1ea7b9810e4eaa4283596309c764702952bc7130b814077fcb1fe9fdb9a4dd6ac0d71fe8ec644c99da7b10584b81f8a6ea034449495dcf217f94051847be90903d56143cb3403ea0343d4806f5191704a48254af3774a980c4304aab997dd71f6c0557b6a328d063c1a8ef464c164c93a207e00c71af59635fe0a2c051b106160d55aaf62eff0da167442aac6374cae2955c7a6bf50af3a5939ae297fe001268716d23dd5d5327ff0d6d2104d25aa1ad4acbbda763649f8d789cfd8b753af8746bfac53f1f43f9f6822e3573b4ab2d1aa29cf991330d6a10862620f2d0f95a35034e1538907533e19428f3a95526916de3248fb7dd6471a50f3bd617f0eff3b61b92efe3fe23d1f5fd8dba290e1f961816cf0a10fbe7a6868804a709d76c62fe19ee27f46c378ba0d482577189a7b84ac0116e40773bf3eded4d11581b8787bda8e7f1cbe6ef6fe84324a44a63e2541be2a099b250f43e1b8ea47b26bc5c6241ffeb5d68d191f15958ca332a99614741d5a0cc6888ba5744608c1707702d53c9bb82e9ca671d3d4b1d8ef87cce5ab062d55e0b6ffca6770cc86e65aae5fa260d174d9a6b7ed66e1982b2ea84172418c6635975585728eddf0f010d0a30eb1f9177eb5bc9c901fbf9f72d5282cd2207ec1c2c88a1329b9b02d964e07f4b28605267b7874b03982af09049914d76ab321efaea86b06b895e377fa574653a2aec75f7d3badded0d1959bc86ea752b437ecdf7af145b3f84fea295cdbb36da261a244e5e9258eaf0512e1f878396a27428709d2b6187a309459c30a1ad712df676188eaddbfe7822010f06552eb57c362874b6fc00a1a68766f01d4c655311170469446dd91d7f8c0433786d6fbf9e2bb4bf017627497c1b2fd541c5e1fd408d79b22a870ed73c46dad985ae912b420e2cb4716b47fc74503d29fafccd73d0609a035cf2a1d65c64cff1b0792b76d37a05a6778a86f896e963eaf845b27a503b8b9315c6876e187278c2df695da16005c4683d4dad5fb2cca8a8e3664139d131ff58cb7dd8a50143a810944d8d036675870873bb4229238c318b44caac7dfa7b538d03e470f54006b0a0393e6e0d877e7d4ed3f54394b317714a80aa733f2b7fe9efb64da0ec965d6b3b646df04925754a09e39c8b5a700f00aa3492a87320ebe58243bbcce822d67dc2d8ec985aad32724a6ae05f307cc7c050056c2ece6dadb0329be7469a57ed410d2b028424e644f9a2f1c011641b41f549b32128cbac940742d2371fc9cda38f15d9d3d41199b6fc32490c25fd20243033270f6cbf6e3728a7db0a267becc14b784aeb4b6dabee1bf29309c38385cfbc41e107fc3233666482f7d5d7054f8ad07421b8506781ad40890d61c809f214c97e83d850c53d83f449b6f270738c4b3d82ea1aafcd31b70d0bd4d735e472b7c77b10da79a04fcfefdc653af57d5cc192db45af04e5f3a684f79789e83607480860f8aefbcb3ce7352fa4b9867bc937faf95bbb664290d86620d951908ed479b1b1dff89396e9ed175820cd7dc86730df452d5b17f93802ce78d3bcd6c04e97d4fe2bac37ae232fa1c387dde45ea9e790b738a0b9f02b788d71eff6942a5de5d8deaef6d9c9d2bd932cc60b32cb4f9c9830c49e5df81dd1fec8d1108b90430f04d26f7beae0ba587f6aa94317c70f51338ead9937d2f36e3eda4922c8b53c071fe15418916552cf7c5b9a50e120e57dec4513af8782329f630cf6020a21c5a2b6937e9a7c51fa7a0e4898105fb2f8cc1f0e191e2effbad3b15fb7554feb8af85ddfefe91d7952645e38db18f01361ed073dde44d8d4ec3c1a2bd09e9e1242e45c3d9bf8cb1b1b0876778157e738b3cb5161d1dcfadbb542388dfca1ef928f108462f644ad8b9db721af0b7c15b5688cf7637cad3e88d5531948f157b50f598841a2489c8e43e9a2d9728e408b05921105e27df3b2f5b3a143e3177f86efe9b49b8def7487f5eb2d482a3aa5b6e41ca64868ce2b123a52818fe1e5f90009498716b9c6b8d423976fd56abb656638434a25d9bc35982dfada102cba6e5eb7fa65a3241ffe7f3492656febe05a8d6b76035c528f2beb9c8037415a2f52cb79ab63c8dc8b6a2ad29cf79740016e1aefdf203af2e8d2f6f078e349eabf7112fc4d0e165aa2525d4f9f77bd6b7faddc9f78af762e1935ae90ec60e98f86fba8bb8e99f11c02def39d02602afe90bcfa5c4c5d06bb0f929047ae6ddc2f20f113c343c6ef9fccccbe046922d284922acc4f88e5999d9c8a63adcf268b680f0b28299cc3025232209ac68d8d2ac29b8499d17c046910bebaaab9bfa4118ad5fa2f93c7e245290e60076f127895956e0cf4c4f36d4e42b27676d9a45ee845c332bf969011b1cf6231ce63e07b0dddab5f01475f31628eecba3768b7154d7726ea3d9f8a50880aaf06b358c9f96959741bc2dd3f6b9ce61f7714f0a5df97e52e1248af0c847a4d81a25ad7f162e55bd9a99cba17db8ff7f644639c6596f9a389bce84e7c9e63540f8581dfbae281008148e18ddf0f1c215c6130efc0e3c845b5e27a687b082c34f9aca60c237ebf1bdea3d9f7b20f3e1214724414d2cc3eecba401505d9a80d4488557665a37bc7cb2c7f24708d6404dc75b29610a1f952b8def53e0b15dac28c7c0bb044d55061ba325f5e40565a45a85d24e861424d72474aaffc9d2f161c416067aecd3d72d928d14ab943c4699bb8df95bcc715aca03cdb460c3f20bdf23081967b37e7172c959347b5a98f234fd57848854104341977c2a7ed366bb29f244e64f1664d623b9b821b8e5b3186359c0dddade4f5ac9932dc820a6d40d994c987b9d39dfdc6d46ef1ed0f0dfeacb9b906c99ebb5cb16d08e8dbeb91d0df2473e50312f6569d15f83242edd0706d692a948d57b088cf33b6817b780ee1530a22c860e6d7c3c657a5d0ce1f886c7a7c7c63a29f1a8b088740502fc32318b2e72f808683075b73d0a35d404303b4c1975129786a3bbd609fe8221bf2aa9dff3bc4eef434fa437a54b64e599fbfb6d56017d4e372a1bb4396c6bbe8c41e010ab9c2c1ffa38f834a2be3be5aaba6cf875bfeeef638b9fbabf119dd3c80990fc1964a2e6b901cd880c7c6905db1c1d9efa73d5446fff2b33933eb4f991b2cb1d421d210d058fc1cea139e78e79b25131fba020e118f9f12afe29565150ddebc28028fb0850e4d55609d70d8ad0587ddad4276702a04587bc7830fa5b29febb98e2df3b2d394d2c16a3611fb49954a834f2da402dff1f47fea513a25324bfea05499e3cac4c938c87e7c22666ecf685308d98919048651a9dac0a6a42b03585da9b9089fe962506c62335d97a7ad75538a24253811b9d7f81e9b3f8ed09c6dbcb04b6262a2b100415e70c0a28596bb576cac43f4b1572e6d967e358d79c61cc3b9cd81713247fab3fce0d75d921d788e4682ce7246878fef3b7b9439e4d43d926945b1ee08dc231a657979e8871c682a88633ef93ba8060d9fcf2f169ee874d6290881ad493d12cef86093456b3d27ff29683fa11f341e1c151efcb0b2b7c602fae37159d34549dddc35eaf5b869a13bb91d51f19025d7c57eb616554ffd7c4a1b7dcf8fd6eb8e771f49340adeb815685f2f262f362be97cc3d3607b208eb3f736aafb4ffa7dc052d6304ebe12c8afd130bb4edfac7ec68e3c55e331df3918df4bea385224d3c86f0d65caeb6f76078de54a5064855506aa6467b44addca9d19f8aa109b56fdea6e1955fbce7c9028fcfb069a83f902bc565bd4802c8e27d08fd55f697557a9e46e5df3d98afa75546d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
