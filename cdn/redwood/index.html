<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36c80744756aa6de9eb38c8fead00ac5530d5f02889eac962d16b41f0e309fce3ff9f77e5e63d24ca13e631b00ed5c06937a36450400ba8902f4c490f1774071f86d42c7db1705838f661bef6316a3f3b404b5f3e428705b481dcb08a8d421a7e9eb01149b7e7c1c4b26229aec4d5ccb6c49fed6a3f6aa46de6ab2f82feca12f0a17c48b0c601b3c5dc21d83fd2de1e07b373f86b6f5cfe6c1e4ebe8c7af8acfde87d94785ea493d8c011dc96f97ed58e757f995f23addedc4bd7358826eba7d60bb41efd5f11d1e19f6df2a5970c9a2c88786467035e9052233cc2637a54a94566fdce25f436901f5f3291aa6de3d90d1a28cd807508c3c265eef9ef46a013a7b07ee17d7733f4e740bb915a4d74ad3f7dbdcf286daee05b367a410db09c1239e9a0c98d9c46a53d9fe3247a5ba5e29a9441c76f39a84c62b34c928a7f79e055615f3f1fd54c69e849544c9261ef300d9f18d6ff1108b4877644de5b6ad6d625f8a98529f3c7cba274c59a48c1d328b27d7191c64462d6e5f0ab2b4134feb2b70bb5605f0f689d907f923f5c95c5e0858d036d07f33a746efa7b60395e9bcc9467d16377e44328a462a9aa5aa6357a3bd95e02a1acca6e8cbc9770c15c2c881a3e66d38a5db30ed86cb9f622b836ee77ce54daafb12161b517b76835572f3a10bba265c2a612fea20a0f61f965df4d50f985e819e093db39276d04cb8a3d86cc74b9cb86ee7a75f321d552a756f7d934475f8cf66eff2030effc7051adc56d4a35d357009867a03ad277d294852e47deb8ee616629d7e2a7cf669a4cfa1cb3eea2ff0520d84c444e39a113c9a5f2dc18d7ce63a6df39d6cc24ac1d0de4e4930faba0fca4bdf0eb2d50e21c314a9c66f3b7367be70522c6313fb938c72b8c48f17e4cc3d9dcc7507d8190353e2eb3a95e76e6012e362cc5a37a0d3754b49b6fbe931366e507e4219e64d6fd3f0c32742cc6a647bc8f910115cfcaada9b26f3c8e270202a41489b45372cd7fe0255e191c9568fce20193f660697f9e95f2f3308180f210ad5504cbe8a167823d2c032d7638ae95ce5c6e64c39d415a03433f720c10418ab2c24a0d52df1562c8d5ecc948116adc5f26a73686aed3a1877a5cb803b7231d02d1da8f0fb6d913f59e4e561eb7ef550fa5ed1bddeda268f0a781945dce11c6234037fb649ede508d842e16e2f83f0cbfd56706ecf371f7fd4ddfe58c9a9022ef0e77e9d672c6b628f0e30c2550624c13b2244f28ee7cb4e9651789910fffbb12d5f0df4570333fbf7e83575e0a0ce361cea6e32f4a311f89efa92e28396ddbd0bc4dd1a533f7ceeed514b08ac3286196851794ab9490e10f9971af455c318dfc2ac0fc521b11f2da96da0f3f2ab6af7a2efd961ebfed0ab2fc6332d95e8982e4253967cad8375870527b9f8a50a94d42c093c4ea2ed11e97812005f485a4f254e22d411088d9bc9ef9ca49856261362dd529e7e817b7ff29c8fdac979232a942f434582f709f6b439e5037c0f28476e153647822732f364d9835a7f7bdcef9c986cd6d121152e0ea8c293407c0705abb6c24571a926a1ef2f61619232c063ef7b878619ef9f7082d4d27e8d42e0add6dcc179d4b92b4ebad341c747aa6a7409b0846c54eab9ad9a9e0563f6736f54f4ad2251c531ca60f772267ab023f4513ccdcc3e3ae18ff70727590bc21c97102849380e3dc2741579011ad0f2df3bc4db152d18db9018b1413670b788392810f25a8601012f7f68ed7f8670f86fbd71f40b6a4821263283cf0aa1b561cbaad605b4b8a53cc0d3a1e4c9f7e314bd4e0114a657d92befb76b8bf7061fea97fd2fa50ec65c936608a8e15939a1baa55ba4b1726b5c6b4b2f44b4a6ceb23ee12662816ee9c219d26fb0ceb62ae410cca41b9d572f0f5090b0ad18a5000f99fd781eb9bafd8e71034643e51844026d52ed95ae54af44e7f3f1e20ff9724ea2bdaa4f71470c8cf5e2b2a9ca56ef069ac047d4d02f8dde58fae5c3393ee76aff058c8cd09480046e7109b83f1b96758f947fca4e921ce70c4f3d8828ebaea70788fbec42f3bd4e92b8714085daa6ebcda14a052b16269dd1d3f40aa0f60116768759643238dc66c43b90e5b4e437bf362d0ffe9c2a02ddc27cf3e3ab40b082bbdcd19a688bb3ac4b9594694149154b31dd1ce433356717f24a62f2d7a7b96629a39955c648eb0d5ecf7edbe1f46de0bb0deecef9df7ea02d1fcdc599b43ba1d9f7bfa8713c5e479fadff811d29051b3e810129dc9f517c0b0f61cba430ae500fbe98dab21b152f688dddb694fb04a3a9b399e738451adb01c970c5445c841a6a3d1e34805b513e4a737ac3aa00ac8abe9f93389e8c27de8446b635ba2dfb38c678abe19e06ec510b4fb1208fe5cc2970eccb53e5cebcc92ff5ecbe9fad519f1bd1ace35517a9ba4bd6de7e2e0817512a005da2932788e2400b18190a7d0dd38c558cd5df1a25ab7d8d1ec75b6c8bc1a2166697db564715f9a82cde726bfb656c4e27b8ef90aaee1a82bf8bc00b4c7de47f3f872a95c0954c357ada1f2bea970a19a1ea7d350c2902b02a5a1bba0bcc255353354012f4537ba247ca2db6555178fe2c107722aa5441b4184be96013e0e954e3ea5beab18150e12e8d23eac001c2ca5966a7837191b12d0d563c27a7c19f7b5638160cf2950e8790a2b504099461fd45ad20c6b0524122b03a679bb3f6dbd9d7e1a11ea76af1d76260d9a41fcf740d1a3523064efe0830fae7a8c013cf056dab3d07d385b56fc2ef9db977509afeb19c3da6d1b8bcbefebf04c96bbc53026da533ec618e449c94255c19516046b5c13d5590d21d6501cef1e02bdf878ffefa35d7f3bd00869f9e807a063e6d0ecd0569e8b9a9561f89f65c40c992d59eed131008b1a233157bc017036fee8c45e4b7d21ab3dfe2ca025e3d538c439162274ab7ee16835d8cb431cec259a4ead6343ccb22dcb079ecfb8a6432b3199a9702ab6c0490f4783194db61606ebeae0c7753abb3c39a0b2613613e493ffc8b34e64f6a829b57f04cdfbe397ed792061784e4c2aab1676b3127131b448d57805636a70ef7cbf7bedc1a159aadf70c372abe91a0a572505826cc090a93a7852db01000c8e8349e7a02303f9e33cb4d32de1bc80b400a9fe801af66499d46cd40cdecd1966499cfc1ea1b98de8eac96954965ede4f0e30a81faf87e44f147c7be52a3b5a7e39bed262243245c46ca82d9f58f9fcd84285ad75b2bf2c903538fe3c7f65c548788b546dfda8ffc599a178b04a5bf02e340346eec19af10170ead3ca414d276c46fbe55016c95b13e9610bdc1b220ddf0df9fe5da65df71153887795c7d6db8609157c0d3f495a1b7ed2f19c5322939427f095e7fa0aad0459d2333e8cc738cae367b2f320ece328227b5c1b23b7065cb96d78856e8818023c4d1d36fc400418901242bfa558a6545de437cc791052d0b26f706039c1ad4196dce7da107f7155be00f5c272862943dc62ba85cb4401e8b927dae1628a19a793d51c531740cd1d21a1c2e0f1e764758c783515855c2dbfac35506cb515c0fb07ad0c381d56faf0f0e5f5971dd062b7bce6e93eb17aae4fdfaf41186d880776ef58b48b6bc99c8af81691810d2b5cddd4e4e92c0a15966bdee16f84b124d601a19cb052eda25da6415c336956d29be529eaedac90c2f733e0e8b48b0ab23f084ad17d01e083724bd670dfec542b5e8df8e049bc6985c021732759696d74f66f73c266bdb9de5529e4de255787663f1dbd328a71e8a238315db52db26a455c6261b0bfe34e1fe6d40d9b02cb6bb42261f53e801ada662ce6815705728136ac679ce9cdc7381f5d9001041b46a2e2b92eaf5abbd1e75875621e37f20d527cb11bf8b4220765f589976e9d7eda52826e0c9b61c632f4f090406f47e8e755ad38e508aae5abb42f5befdc255ac9e978556a2f1a646a21e22457940480d91ac250e6b2e708be38faed7d699f52bd944e646aa0b12f8d1553fdf29ef9da60a9a770028494eba351381f735a9139f3d2470a26e4b93af939139efbb1e7cf9a3826980edf06ddd06087ccf4f64ba00299772e136a4c09c52a55830b36be6c3a840abafa6ae71a81e553a9c1d07a2e4c72c08ea1dd4c1a458724393d6e61759d5ca984c1a2f25617cb3118b63cce6e024eea79503e70b331b151af2977fb5bcd1b642b093b1b870e88ac1331ab09aaaca0ef8710cc1be7f3cde90be9d35d3b2669cc7e36c28ec04a75a63b43296556502ee9ca8ee9c91d43eb45874e34df1f73f8fd669b98fa4e64aab21af32f178f8a5aec37ff2ac4d2462832a6b4447d2a537105cf5cf10952c7d6b3ae8ace1a1fb5499dd474af5132b3685ad29803fd6f138b22791c95fcd840f2f0d9e7de43d9f957f9021fdae680f08ac28e37c92b88835b3a996565fe0a4610b9cc64f281d4c85145047afb3d97ea5a0b1367c011fa1c9cbab121de21647dbc16248deaf0e67422417714fd0078951febfd9e2cf0f3917631a652c64fe834844cc4172db4bcc1540028d7c527b167452bb1eac40a619d849d4e54861d561b228c0e349f933af13751f40c70ebac8cc9380bfb6fada529adb4794efa2bf5bd381f2cb21452e4646f3089b64b1fae718901935e238a3f411414b8aa2c3449166e87a6887d5a4816c19040ab34151c8ba5e88ce8d4d09239b2753c30320627d7112685317f06058afa35930a9edf8d19cf6cef49390edd4d7440d631ea83ef75c19e60292fcd1fef36aa5fa9f4a9f0b46575982152a4e5d211c1d0da9eef33e6b74d37df830e811dc15ef048b43cad41864b230fa536774956af0177d57a71b216d159bafdf18ba8978ba80b637365da8a4d5561f1c7bfa654d93322f975476898fbb0c1612a8beca6e32baefb3667a3aa879947ed6e1e165094d368b170b5bda08fa512563a78a04f02f4288dab06ae41ca7c4e8e399b27f3ee5f3feebd58e57d2ded31b3027301839c4d1558a0874f0f6d5115a97ceb2531a03a1632cd4d1b3c5011a62631e6255635ac0cc0f99058884a5a72fafc1c464669faa820050b25e4f20900f4cf328d30b7b6abdbc7862c0e75cd5e545b918196ced405745bb6e7041a5eace7f545acccc1ef20c01c1bde63a053aa1d3820400d201b2300660341a555e77b88115b40c42ec3531f68d42037c7940026554641f4bd3f631d1d6caaead6a6540b1f6b845d72f180f39afa7cb78faf98855bf740db11077851090d7318fe496e011bec824fb69fe83bd1fa5d727b79179c6945eeba7494cc3ea23045c18bd516c0bc50eca16422d5235e53f3db84dfa0fcb6aa37d54b69dd7da4b9387ad21ef0b0d6af701c602218a540fba81d72b53595e331c301462f9b42369ef309a1df63fe5b929d89f0130b23398238d860298a011cb93088b9cc7378db1c8d05e71e681af6fb088bc8687e81345dc82648dc73da919aa46325596b93df88f31d54ac9f938f55df163b51fae6db35072fa019b3dccb5c944fb0e8aeae5521e0923b8aba63cde170f2fe485403f69cf338d2689d452d7ab447a1b7f2ea431507847c7c431f9f56d948ce21cd28f681c2077b3e8614c6fe7267e6ff6fd2339a4b7a648e51127c6436cf2a0ad6c308fc89790fb1f412c0d778e7de51bf7389c0d6e3c7af2dbd5268b5daba2668a207a18902db034977093459f1aafe73788fe6be11524ee460b50afc46083f56a1845980c0d42edb585cd85de2274cc7853ce68d3a6d857bee63cfa0a003803793a214225766259fc47102d5fdaca39ca69e5d42f02953cec6f585c70fd2c027b291331decb02971873ea54fb8802dad3471df0c1696ebcbd049865e2a08c4130586e2fae67e4610d2f4ee292c16180186bc704ef4a4fc013fbed2ef66e79d57ff9e78b758d5a0a0600fea0b4b7c5add98c4750efb51fefa37f1a781f7b15dd20da796b487a5a42b62cb276e167b92001a50a9f37d69a74013dc00c4a5f3071b443e1f4756e9a287c480c67ca956418d50861a0589f6b9bd1eb6500c58b59e0346faf67d366463dc8ee6d8bb1a2c2870bb9f1908349027250bc00f0d2fd81b1ffedbeaf9faf3467c46aceaf1368f290c819f090f519041146673c88aa8dadeb9c1ecefa781424088703887272cf0f94357501859ede02043dff4a91154ee187b4eeb997d3d08bb8a5c57d596692a4874eda3a406250b46f41ff6021edb33bb0d704d9e51a7bc5b4b7db9e5663fdd564ce62c82478a124e064c462464a2a8bd73e833289e1c1a362140c117046c04647efba818f8472142623af7990a08d6b502376142b3290c9f550158bd0650fbef976516e36f2bbd01b918dd8c0b67ab36e17c4e86ff9dc77065305f1fa2e4aa6b35a3ab72ee4dcb016a6b91f30133435b56fd1da6a64fe80362695a555e90affbc6476d1a05b6652bc21b5e745226bc5ba4ee83c090bd4ca507167a7929636b142b44fb26d0b9ed4380419ec4a37b733a225f9667213c514ba4659883f28ebe1b2639f4098e3549e8047a9545370f9f86e65897ff98f49b6be575141241a94e6371777dc6296e943d55ca2ac0a203950182b04c20fb23634d030a00c11cb6842a5ef10cee08056aea9545963c06742e7bd2cd7bb9a6529925f8f315a0b39b1c2066e326783c7b05c900287bb403498fdb3efedc26e7bf9a235e6a83daf12a393415cd6ccf3ec0f4a082a498f9640edba23ec83ddd05778c12bcbb19afc589db04717ac6287ba8fc885aff26db73d31182ccf43fdb1e9c6846733f154bee7d2c0c798de15d68323e690e36bf36c4c77d4b6baeb15f9e4d7380055fbbc5e54fd08d99845e976891514da92987e4fa4736503cbe3405b3f02e4ed39fdba5c58f73b2c53aa5ba087cc8aed3c8bfe6abab08a8cafc64c61194b5e7202698b16fefd934782650e7b4bf6eb18c3cd7105a90acb2b4ce149596953a77e8285fcca9ed1d4e3a602f7154199e64bed68588e78a35953c0cae98d942ba5970e8d68a3c2f0e378c5f2a2b741cfa5bda53aadb143de8fde37a6f71b2f8f0693b9c985e062dbe176b09c2c49b60c7065bf96dbee070c1e47ea6dc5551092d317119a2b1c0273df1941a1a5c6babb1df11c2dda79fe7776378b2605fac08f5295fadb03b436bb18d49dff6fff4348cb62b250dc1590ce0e7fc84080f85e3809b7ca03e5b83a71c3fac6e87e41bd79a3c5553b00a728d00e4d321ce6d528b4e718c5d221fafe60f5cbfa22f732b4301407dc998d1ad44a6ea18178dbd1c857c935a5673b9504252599f669f559e0b65932bb9f8b9f36b23b9a3c3f792dee8a7b2a95834f0e6178c7722d9ce16c78a87c425c6b0eb9f3b81dc9c13f0531db7b401ee3c422aefa73efc84abf4e18ed9481526bc422b6342528dd252ad80d888255d309d85e1aafd724f85a6fc61a7396d0fe4aae7af7c301d29c0a434e49bac2ac1af760918866d189cfa8d0b86a3b6bf2722da7720eff4689ee8ced519422971f62e5b9c40d24c910842b2f290b18fa48b1b048c690c48f6e613c4003459858f2d9e6463c26fdbac91777c7b98cc88ff079c4caf756641e1a6089ab0791ef89281f5321b7337518a3c4b9c7cd9294486945d8c78310b086deb3accc0045d5ed73209950ce7e2add937c07eba1e3ca525105143c53e54f87c34bc19d2661f46faa82d2c36740cb2c847385cdcbb84de5e625d55164f87c63f05c0e65981ce646f6ae78b4d148158edc5c836c7344d725cb6cec6a73f2532ae8886a5e2f5503593a3894be45ccae42667900fb65267a4c5d6b20309d533afa6c47e2d686eca340a1f91925099b5b77ebdcc4836fe5f7c44ed01408075d21a8920dcd92e4b5e9a61a17a66b9ceb4374be604e3e6a3674d8766f2fb62b40b783176ed430ad5be2b51091b8c649c6472000b3922b1755e116f8b21a29ffcf225582dc9deebe23c0848cd82ae07e571185ff5471d5ad46ea301acf39fcedc65738fbe37132b5698be664505dad43844f265a0d82be3fc2dd0564199df2f90c226c6a8a626a276046c2dd732c37beca7be0be92b8320afbcc0dc1a4b73fe07176228e49b95e0287669126b791fb745f99c3f1a5c48a53411183760cfdf11da9a25b46714932a800ef08196b258feb35133140739091578a5e912e4e236266a1e810cee6b1bf34c614d92b28107715a8313e13c6e977855c296c6fdd79b1d02b0d1d9b33a5636d63029d2779db0f6b579b5536e2a5e09a7a11cc43138bc4af5a731d05f123cfe94ed60a8794c873ae3bfb7e657f59ade8e230c97a81bcb06ba7acdf2b9b0d8d97c61c04b58822522f344f9e2a8e6598a33617698894eedcd9b28ac7d35a40182478e4b8409fcb45c8c6069c8ffd4663ea3a82bae332c984256681c3b6f3028bdea03e31951bdb89d75bfdb528885d0ab0766528b59715df82d6114ba6d9faa60f870ecd55df67619a33f19df6db81c249425c36517143ced30dda367c451bb129224e0c5ba9b53983e2abdbb3c193dce6c16b564f7e3ded61080915d86a1aa46a1ac67470f0c44bf34aea94d697128f643f515b420050d932c271b00681bfe7067f1888cafde677e0a430b46f0735bafe8adbbb238f10edd8d1dab608fe8dc8f638b77465a07df559d4e5d06dfdd8634a94bcfdbf48127d8af5404a6ca1b420219ac47fd846190ae0ad393edce6ec4c44e0ad7c917fc5a2a70d0c336f43636e3d99080767cfc8712f5fd6fd7d9dcfc17886ddb72f5d4991814fc8fcdf2afb73b6b57ba8f8122629b4d7f9f51de496af7064d3f831be00c4af583090d4f4e317d4b2180ea9216846371749df8edf523c23d282bc10ab74c772dc84f1ba3eb7ac298c0c61a63380abd8a9edd6ff5050487025b90200af464b9cd7062d19fadd2215d70dda26a37b2c65cd9cf9fbc9d53d04cbe7a1a2827c672b771490440cf59a1a77bd90d1fc7548d894cd1a5a41e95dda69d8e66aaf19da9b1d5a3d172de5acbc6cdf8cf3bfe034800df52d2d56f8330e033f80a2fe53cf3aa90a4cc72f12bc4e22ec9587a41175f4e0305b9383492988e2bf5b6dda0a74ec3c42b3fa63b03b1d3f65537249831deab1ee2630d96abe47e1612035c3b92d6089962d72f055bfeb3c5411ae72fb49f30a970eecba8b1ff76ad7991aaf6761a59ee4a0cec4aa20d5375d50e5a6ae23dd14ed1ec9a16fed018f9e12a7f2243b189f5cb10393d0163d6fe4b6c9d8bbfa16c008df097c3be03efd8225dab693ccd2ca5d59bf77447bc342b2c2622c11fa97efc078fadc02bd64b1a8cc2968d244f768bea9e18d30aa4523ac4e56d0704a47c29fcce5f046c392970ab49252acbae44232f7aa1c18dbabb6682487fbc517397c058434aee7c74f3e23727c3f4b07fe883459cdb713edb4a5d53416b955a4c93daa3df4a502cd109f171beabe79a02d500b0d686085d0225c0739d785d0add1312b2ff87afc7eca0331118cc93cb96a86526354bd011f6e9780506237a6035c6626e2a2884173181ed4fe052478694deb74baaf3024a48bcc2878ca0fc1b21cd22ab7de556e5ce8dad2ae2f4276813564f16eb2022ae8b3978535fbb70a8e2b7e7eccc678913af1a7ed1b4647fd456b9d791c902807c6f61198a6d46474da913e55a93d8651d70cf6d8a614d59a444b9cd9b6348da14d9f487044e50c377d6ad32da220fcd6e8e32ef3234fca8429bd7d6dca95ed87edec0b45be1c50b8e4770a78ef4612d8e57b7fe2d03286a1e6ccf2960275fe4610624d950c2af7631bdc92ecca3c29dec4d490c0b3a09217994dc0b60bcf96ddfad1850bbc38d0725193bead9bffcbcddd306bf79a80ee4ded3f22d37c7bc1c59289ad118a1466d41e2d744059c428ae23d66827c28824ee707e018ca546125c900bf3448562a84c06907de8a8c7763e55421181fea72f4c345b0b7ae8404fadf5f5f6761c82ede464097f125efe00dfaf03fa0a84b8139865639b9e6b893b0b8d1e0897b6aa21527a44a04c2fede042c35c0d1aabc9a19f05f703db40e72c8467d574aa3d4795ae682c1b66676ba2705f441274c7eaddd10217bc5ee18d637bf18ae6641c2798a7e75ae102f875d4ffc59c8957dd66c9cfa911859c2ea2975e89589cfccd540267063e169828b57bc6ed886c18d6820ae75b7a029d77367388d2c33c822c92983832787d82a10ecff7c123c60f980c66118db41eef63806f81cde79508d6c6d352559616733491f75a00c45a9d508a1ccb3796a0f8f5d499febd69d5a40e0f08594e292dd72f2a993126b4b202df78c977ea585b2b1cb539f66609cfdf26188d37ac9cd6090642a8673a002b5bd35224776bbb4f8cacdbb8fca1d09f0693950a1ae73799b45de307895fab2819f8c49182dbec0f81155189572a9bb7b7ea458e2359b7fc990f90d33675cbdf3ef53591fdeda06de8c9b57b7070528ad56d42e7fa2a1d1d25a71d511251dee56bde865d83041e0522e8a54efe52a960d2b151c8ea2cfee1e7e99bb8fe3bba1a471c16392cf74a4d10c5e2f46fd200d22c360f0d570ae9a497ec50be04820796042fc7c7eedaeb94fdd288347cc7727b5a74303424b311c193e622194668550de203b95a22849ebb21fe613318dfbf436aadbdb5b7d724bdf06365679130867718b50b4baa22c2aa93707acfa416d9f5756a5ba0ab6a20db9dd324efc39012be9a4db78845cdfd55b07acd2a4c53a74f56f005051d24b0d7b776c6d82f80faf4ecbad8301e37946a45d5b87a20dd23223d805dd0b60e697bbb869bbfecc00ef0efb65644c90841d67a618622c6aa7743d30323f874768ad901010ce9059502c90dd847aefc1d3d77398d756e2444fddfb7ba4e0273d49239c0d0002cf24aecfb28435e2b181b0eb1bfa055a1f9a6c35d2b90db49c1b4e1a2b17897569303bd734b647966c00d12f953cf83210655b8b68c232af39fb5ddad3a0b6b5c54eb8691003559e81e45227dab8651aa45bb30838ca0829309389f8304b922841e4974cc796b911cd9125f76a5a51d2b5f389f30752909b644629d3fdafe4c2e38951a5c43dbeab00c15a52f0ff7114deb8ce102514aa39596f7345a58f5a308a959e49a2d13c3beab4a1c94ad5fe73f0295c02a727162f89e13eb2de5ad383cf8a3ce0aee05230f4f57a3b99960ba56af17649c059c5113a65b854e55e866ae898a15abeb30261e4cfa3833ed42ef08280a11f17e548912f38ad8aeae9a51a9580e335c34220701e326731f739b1609cd85664365e1d4a37334445ae30995073412b87bd3d423f4fd80d6024558427429729cc74675cae8506b63537112ff8c10b86f701eb2ed15514e4fe2ce6365633613a035b96f46074c07c32601f30d92b35909fb0fb123810c161277c110d8378ea2045456e5daf4422aa15f6ec90fd75c6b11abe59661524b180ece0e694670b5379c2d98791cfb41f235bb5d00965b6b33c3136b95a2898c6ba78a22c22ce9c9de15ac5d56cacfd9501fa1e7400a351b3c50e4821354234ea7f9cca8f1b96737a0a73589cd8078c90cfba4dcc6af074bd7805f6b2026a654e8d3ec07e8e1810e39cbf418fa40cb4e5761752c18d9f62ba97047a3cbd6bcb63885dcdd4b6f751d8a1856dede18a9fd9bbcffe2392544f93eb99450112acf0e7c4f5b7d81cf9be01e614c829d2443e56cd6b189a5e7270d5395cffc2167fb521166c19345c048bb843696cc05148d5a11c206f3e0596f6420ecc1cea82e78450dd11abf0e66f3a3db85674ad671596d1483e7ef9e75b5200e082f5b1ea4c12ae2fcb153c97e88337bb1c39429776a031df0317d5e89958257534c8898d49a15e19340f37cf16feda072ec2e6d2fe20e4c779fb84b5fb0a04fbdb3eb916e1cbafc797b068070a9169207d5411c6d06b096e2d0176400420d3f946e583aedb5398c02c4952842493eb877e095eb56d1824724402fefc53bebb194e30fd3758cbe88dde8774f5a5b767583978ad5fc57e4cfe76deb9a89e5d76090538c2566f0d149991ffde9d84678fad61e81541fa7afe1a00223f55e1d5369df8696c5063d177c1a44f52178f933964f3a615778c7a242af1e72d09ccb16b7d60126dec57e70515a5551f5785b35503bc0d1fad8c9376121399b9d677896ae5ce2a94150c96873a9c4d9bc495edcd761304e0f3dc9a5bca598ec48ff8840a6f00b43df5b845edc283a99222b31087e671677af4b45d17d1d7902d3e52a08523e2ff7f89377c3910f5577a47653144b8399187e68625abcdc153a9c013ca03056f9eb4b382f2c7ce5dcecf0c0c1cff57601f456701c1f963c4aceb585dcd0ab89c06ae9b28c378cea7d3b47b324e07735a28f047303bcfe1f8e012ada3013e930940782004b9ef41c2a502978c8c6ea34f368e2bd2e35ee901d59b82c62e8b5f663104d6309d6359b9cd5ef26c3602e72df0854a1ffb7e1802890593fb635f719c9b41b6e01b6386d8cba80f14e00651d57c8f258a0500a1a343972b24b395624b875a1f82476fee562e85a0834e9f2ec889a2fc762f895c0102f685ec80b402a0525b1919de3b6fbf104320236b0fb99dccc836552add965c0f9ebc34791b31d791e0c68bbca5620781a78a2e01f58a3fad5547450aba51c7bd414d3b32700f8f78c67309308e8164ae33de47d5ef25330577ebc8b71a43e2e30a91096c171dbdb8a1ffb11b3abc197fb566264a1773c6daccc3e40879d26c6b2b67c2be1ab80742ff93956fd604197ddceec2ec2a207f92311d74043443aeb09a4fe821e877ea006793f3f3f607f2bc4f0eb8d7ac65873682a567be722d313c0f84472e798c3af8ab5927e6d2a68c43a72db25c15645783bb399ba1df7c0547439eca55db4c40e855ae843cdd82752478cd983ef7b9506f99493d032ac088eb86adb107d4072d01e30e97be02f7fb6ba2981f4c154d31b8a76496ebc5e7dce08f4bbc245c50de3ce798754f4eab2908428a95861ea70f672e7fc2026a257ac57b537eaa97f35ada1e607de54febd7f37858cc758d4a0c2622497b5b8295befe6bd0b93bcfe3bf59b81fa1ff8d5f446747e16813be9958e6c528041337e7e05d312c40d5de6ed05a83cdc13732d6be8c48b0b174a2714964f09847f63fd292142dac3e57af3c678edd33a863fcb3954defd5a0ca0e26fe0623d58e806949f5a1757bfd32ebe70ed5ccecffda6387d64a81d5ecda0547101b28ea3d9125e8fdcfbd0c9bc2978bec39b7bbe2581aabeafe8ee42b5b23e7aa4975e8e988b95294d7345c11ca38e33580f650fa019f690080fc5b9aa66f942bdd73ae9e3efb022e5d93814eda63a92208641fe9143933dfbe08cc12ee8da31804b562aeb2b6e7683fb44630f6635b296079d794c69490ea04760fad8e3b6b951d103836ff77480ad607e9b1f7267d9996d0f150f298e4c694ac6565dab0fc12aab7b84e888e0f86dd00be6ef96714bdc929b0574d05e5b03c2df0a8fdb7e8468f49993754255d1827036c84fcfbbe4bc4d3747283c2bd934d097ac712ea2923d1e46e6af035ae363666166bb969720de7a6a37505033bc9295c4c0cb91456e6e98efc2870d7d10afe591421fc1d46c650f05ea6ef21c310e7f877e16654df2afaac68781a29f17de109f42c5e2e08d34a4636102b33470fa42188fe332d403df9485dc8c7aa2f5e0cda744d2b81bb7edf2f5d392b226acc81060f4ce2e8025570b70caab64adbf305ca16d99b4d79671773302a01db903023c853637d610e4d25ce9f60efcecd3384920bc87596d9b8da034a5c330ccbe2540067815a55dc2cc88100c168dc565ebbeb1fea968ac3359503e3482714702b33f359fe50228021e352e6c06f06c12d295e3969e1fa636c4eac0df6d04967b63ddf462f9830d49bc2f0fdeff70aa96e82611b7661fcc84f2abda1f666418c88dda1d5a87e67af9577770f6fae49a3ba1d16f00c35fb34d4184bb1c17a786a1f8136849f73d18ff202851252d15935ffb1890bfd057f5186a4fe6c481cf7dc2e1afb881e15dbdaf7786578d17e5c2a321578a4e5cb53e5f5685e1433f9e5d369d56588e82b2b58db8325bb431e1729009c364e45e72d2d397fce147d2e1842a4984298e2d3aefd34e6f8c37bbdf10be22660c1b075c6c7913d8ce931bcf6310ee3e7d979524f7e5e297f7caf634a5daf7bf8bec9fbad480a4e16ef2296e2dc38089ae80c5640f9455774d2185767c24d56f35e6dc7e539be02f122a132afe79b4c5060089b38855a5e182c71cc6cade3607aec292dbaf7325f3933cc443ba71213414626ec95559e774e0ed5c0405f671ff8039b30ec967ed72bb69dba40216a1411566f50d6b9815063cb519c485dfa53749c5d7af91c9ca0b2de8c1389d0ce7f65d05c368fae42b8773746ab4f82db8f1e9ee571c31005f8e968b74406fa5744993a3aa72d74c52c913c8fd6607cd4117d72c8792e0c679348f45d61057d5fadfd1ff09e2eeb4363501bdfc44fc3f7fbd9600f2e9473fa828fddf1cfcc28473e1ccba29227c6d4ec2b658ff5f43f695488518804bcafa364a672a3fea09963ae19148ce5ff0361db836c7cbd1fb100e25567fa5cf16bf3118c20a7f875740722c443b5f669053292c859d18a542c719a528fc08d03649d78df47c30c5e6166d3a522779d0ba24544372c283650dff77120ed481298857bc38b5cb6ca94fa7e6bb43fbee14dc3987691357a994c629ed38ea03a705054eef48fbcc34a0064b3020c3490a1f9b0f701769aadf2fffbb4f021de2989c6682187d39fef44b457b7d58e59983738f3a51366dd9b043b2bf31328a368e9b45afe10ee8219360c2c9fa29029cc4731ace4b5c952c5026688dff09cf4e81cf8e5c0736954638d1d7c8549c638c3ea0ab9ca32914834825b6e8bff566f4e3d009d85834601f36474c0dab16fbae104ff2629afe15a54e8621d84e1c7fb7b8cc60c3e4ecdca00a089d43e8da042b6a1f65f4161f980696562db6f1eb3fd307ee48f81d9cb34b5c94e37b14787f20b81b85d4e4af045ca9065210e9ef40cdfe49b0424cbdeabaa39693fe854c3823a2fd850e3409ee1265f5785672483d66a32949381119446d3d8d505b946f2478aafca68ce0c9a35cb0de704386f9b05f744c733788287d40285727813fd5160ad2514d7bdbeabd3c909bf3846292f40ce9af08815ed265f93e67a79150daa23fe22a771116158c51b68c73813b768ecc0aabcaa60b3eaa70df0c787574e79f23032e19b07bd1cf60041d282f7e0f5bd26e3d449b903a69847078fd55f4855cb6fa700f36ad2cb5c0d42750ca613420e2c833d086fbf8af8ab6c47cfc1b0654516b075de0825ae94445ca8dd0c9f950a9ddfc743d3517350b8232e5bcb436cf2fa4a0c35c153da678872eba85e93a987a1eaf47e29d90f15f96539dd2559685c5b256fc2e66116c0e7d9a675f5f764d275d3908bf6b9095d6568dd78a62ef9637dbcd1950bce421e6105c50ba1f658436febf1c9a39f455b9cd9e72cf4d05b394070122206c9352b189092217acf897acba2338588a407e8620875d1f67d7e5a1bd773623065f34557ad454d6ca46d8d2bcf7582436a573fa6a54f5db02eee352bf59bfd13cbee2bcfc2d2c58127cda54462c53fa683557dc1142c16a3d3aa5e673494f0692ad58c3f30cb6ff5741f2289719950c6becb919c244668d969ba472376be1c29586263cd86fb192866f55eb2e321794862a6e4bb9a1f034e3d2b3de58f5fd0768b96607ace7177c4fac4d13d58dcd3d9214ba05c0adea63c989cd0629b9aa4641cf20c74059b97a3fb26d6ac505496424319b54a713b3c6ca5873f8a39e0a1a4242bb6094e4c6e299888a73c3c3caef2215ca2719472ac2fde2f037e0c23169a0c0d85cf8a2d5489d260e700e9bdcf7e5534da4c7f3575747b04fca67688772d32084203a3d7bfb2e88251850387110068532f60c210f29fd0ee0c4c38313ad646be965ce8dd00e8ba0406029f4d40799efa22c9401a701d71e022f57680b93f2b6d8417a3d4b332eeb6cc247d4a87cfe8f0fd7afaae640bbf1e68a1144eb3083c9fe6956879be283ffa4b0d86bfbe7f37dd4ed2ae61dafc3949cf4d4ec047dbd352b319d75eec6837cd618db0470426fd12f76b39b839fd6f36f2a8f8f89833b5c643b1f6d8b9234bf15a155b39e65c32b225aa05d67b4014da4f6c5f0e99c6dfb306038830e1395c984905c486a29a42fad975ee6ad3fe836461352be2d86509dbbd4eeea7d27ee8278b9d8d0809f7754040873abfa7c8a91790ac65e5aea39328649dd40204c7b00dddb1011e54131474df575d0c86e82cf9dca58346930355a9caea19fc1b8887ee739baea5176c2eab40b90792fe87434d911c453adbb091c5d7f548608650536e73613c02698ffec0e042ce31883b29938590a72dd3cf7267d41a41979a549c21608a919ba5b7c2ef71264fe0986c80fedf6680bd5513016fd333768115c6cbe2c73de88c51950539b9c75725d18eefa37b22a1bdd3ea099cbb07fb1faf43926bb100571b72e3c528cda34046f795adcce03555ce9b8e473512def574b7dde0b671783981fbe30cfb64545984e75c792264e0dfa490b8593d329831425dc8c4573b8ba67d46d39770e68e0e125d41188ac89fea7e2b9acf60923d5722b263d48bcd9fc95e35723da3126a10a67c7e72561e26fecea15df4be4ee271128836ed9503413ccbcce592c4961f01c23b6230b8fe4f2e8f0bb7b2c77436c68fc46a252e186dc27ea621ba2926d9b78f414d1f631372548be7cc36f5f137c56c141ddef7f8162fe15e766527216cacf0f6eff97037733537b3acdcd5848c7d1dee6e87a094b6ccd5b6ab0995cdafe209105d5fac2f581e3407dc525997959327a44b986128c6f7c78666c7dd35e285e5aa4771105621105c7e855ddbe4d8579741043db33821192dfc5e123ed9cf1a4bbb0c63b29de9e459da73580a6d2f25c82212a84c7279263b62d84b9b864da028105ce851d5eef4d73d86673bdf5afe08c93d0c682075a487ea770b6163551f1a50efa143aeb9589e8db0992db76454f3508581170aab38c526c7b7866a287a1d922e0b83ced11c40086758219fd1d15eb79ee436a806b9d4961a8bac430f9d73c9a3149144ddeb91b186112986a18de06b3d363948b12b4c331ad91828b35a5f0b51ee201c95475f2b4f0b33dbdd2a882b0d647a65d381da540bf75d921fe04fba0bb75e02255dd1eac9f112f3f4d405b31d583ef5d4792efaf2387069615061dd89708e2a49afe891a881a13ac5f77fca4e014609641d9a8add90763bf579ccd8a8e1ebabbc018046094c48d3ef6ee39ab2086e3d3544c307b56f1fe4b00d0a7d4af778c19ceda25ae09d3c74bfe0afc89236823d597c872f59df64ead38cb1b9faca428f23a70bab2e23f0561cc0944ff9ef8086df94c1a43ba495ecbc01c6661a96371f15fa6eff7366de83a30f2a5d77c1ff88e051778a32d11acd6b907f40b2a4fdc28fd83cdaf324655b63834ad835a1fcb26b7def6d5e0f5f17ac9d7b736bf7b4123fd655eafdfcc65ea1a2478e2b8399c1f0e76dd902865a3382557839d8455b39589831fca1f62e72ecd36de2a54ca438c8a0a98030022e687e847790530601f2989f7b06b06843ee25264c21f578ef70cf16a3efe161d9c65fb6a2f5895660d381d080bed0a93bde2eda101a89b6f35bf88dcfddc0fc958dcf74e57ccd07663dddd15096b104df216fa101a7f78cc89c175ae18109438adc3d77e0209b78f455e0114e24fd0bce73ed0a0ce24c023820fefee5e283b31bb1eebb2e3416ac306b3e3c629a2e1efb8ef4c375f85bd7805f651a0a83434e1299da4413f0d80cc81f8bbb76355aacbc917212a64a5108ffb4b2a11e15a2a9d36d11608ceb8cebbf7ec73daed0228fd23d23079ab53ac0706d7f922a6528a9e6983f2c710c793b474ab6a6c1332c81e5fb326a61a643f68de3c9c1a97109bc1942b1b20e021e746f9389a673fbccf4811b0785f0d2116d7482f6d4191fc8175e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
