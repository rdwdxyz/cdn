<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8fb2f15bef6321df695b37149a3fece421bc5187e368278011c7b8e75fdc7a7cc5491a7a3f96df72d9650d5fcbd9d2943c77375cec74085dc6f382f2a95e3002f4a7fed218dcc76eb777f3980f805cf4d6eafd1f70239bd792e2724a3f23f3fc6c03b02a9daa103049b93d9dba2809246336a31b360451696653b8c4bfeef1876fb302cbb4d7eeefbaf6abb88c00c5475466fc2a23dc5e011e84e60a59267360620bf5e2c7af77e744ff1f8dbd52ef153eb3b9b8d420e2d472f0f1531c3a2dff7de573341f7f105636b77d2b1befcc45cf995526d5f8069eec71e0e252ade6f81a8c9e4bbfcc9beb31c5db797171aaffbf2d4b570d356f3fe4f9a6cbd8b51e20f873cdf367f9b28247241b31edfb56d64a351fe67fafdcd24a4c58c8f06a05271df36198c44a952a3da5d3e4e3654dc47bf814d4ba47983cd2d96ec8171d6340a0d170a9b0a41b6bc888fa65a9d6bfe6b3e83345417e454697315ef831878ee06e0a34822bb7da774430f7338c6aafdc0a0839117cd63fdc45b336307baf4c41f3c192426f97a8fdef3b46e5988086e61b58ccaa54c3b5c1f7e178740487724be9ae30e2a7ac72aeb10c2526bc53298217ecf4fdd2d858acb95c687819e134bb270f9e850b9f85633b4277bf9937b356e0af988be164df844d0c955693fad1d89e37904d8f2013250a99aef9d83be649c14233b755e5b5c22567c321a482a61191c0e38a6aba2f7efab9c7a230e2f29c20e1e8c5aea3ce40dfea4fd11a5684f67d7306fd6b1c2fb404773ccd897f1794313eba43b98b0866a5295103a12664020c08c0effece092e44b639a0927fed63961a408fff3c7a89d63a11097c0bfcb93199048f839b75e1280cdeb3aa625a960b11851d96b4246002710258fa0baf8539c00b47a37e71adb366d718e1eb4bb314f4190118ae30503954bbdee439c58ee69c9287b5f088c8ff6eda4cb81de79db2bc3feb5e758b7040ecdc8de477d9a05b9fabb232f0333a01513f002794623b2b973d2bd686bb463d71baef54a0f7fd5130968f2119419a9f927dd68783c28ab1a0ff56f878fae0a1d6315ba0f512c62e1162394ad5f65cdeb6c1fdf6195b51e8a0f1581f06b7107097edabff8e231602e40e2d963bc0d3d5fa5c9f5f5e0d293873cc333a680c4437fa15a647bc6d64b2447bc64b1552fdf57152ea7b0dac27402094a054072a3947966a6e7a69f65c83ad8101652f630c5089dd17b69307ddd89489459d998c0343b7cc926d881b50f228e917c3872ef4f98eeba662617c1a7b5d243c9520e56e549dd1b26b051db6326da7c4216d490dabe8fae2b0929eb1609dd05d1a9d91445f875e8cc676f81e6b775e578cf8fb9d264ac290ce274aa38694c9e70d3cd8a754fc53a266842809312d7e66c6b2b91995efe83d5525afc6818cba3e13d4290dd83b1d9a1700b3d6d5412d237d803bc3c8408c84f512866f0a0718a0d7fe104715ec239efdfd7de9db270a5360ede4eed49ea4a58e83ec8f83f69eb744f489902dddb0c27f49b680da54776482bae1789987246ed6afb190c8faa57e1662a361581e12e6ff2b4d7aca7a28653f0f6443f3be34268dbf459611543ca86f091e22e67ca228c7a3d71b14dd86c6563d01087359a54e0aed79c221e5cb55a979798d7ee629cfba95f54504fbc565b5e3b01e9ea707039d179b704ce5485de5ad899254c71a5db5f09e7cdfb25eecb29e31565addfa06b807dbe9d2cfc696cb38d6205f26dbf285aa509d85cdc9a6c17baebf9168455d91c84f5a0784d519a4dca97da773862bff40284d2cb6ac67ad32a7e1fdb51af2ec7f76c886db7ee22cf70877ba013d655e8e5375a4226d27275f8eb2def78ca8b33ae6a9a2ba77e747ccaa31f5a24c8c601da4d5f78e680a50ccaef1a50524359c950fc4ac4899c193de87d7c55514c1b0f06b3d5b97e409230e59651ba1c9636c7e328293cdc5a5512c0e3edeecfc26fa913b6a0f4abd6bff84d0c550de58aff7dce852003dde6863d3cb50e13fb810c9d9a17920e5ba80a654790a081ed1416ef533f1a52f4151c3935fe61e0e7e49fc34c56292db9a67d25be059caf3704153375af255528aafca1b99e483ffce1562e990f8704d1a350255c4b7ce412db3672deb0a5c0abc31ad8bb086fb3627384865a3e02c74ec9daf4ae821e93e27723943d0923ac612ef3314e16cf75a015204b93f90cb1d67d2017c008eb5cd38adc4109d17c44aa50720c69dc17c261663dd8404fe82b3594efe8e4156cd2edfc5a615d1ba1467f5b2cab81a8a3dd080e9f5b29e54c90094e2238f96cd1b194162f7c9f3beb384611f8d863d287fa64421cf9b20e20fa69c5fed288d2dd92eb2953de83068b827d7f66c87379b6f24cda0ad003a7cd9719999302a459bafa32e9702fa91760c80adaa29061ffeceb77dce6f0ec95e518bfac5d65b440c95c951a2c1eea9d3acbb339ca55d46380b533facfd6a1943e537e0d5319e51663827c1ced8a11de477fd147fc2cd6c781c7fba61e432c171cfbeaad67bb8ecda519810ee6cc2591b90c59485319fb86cf36318be1a1d11865bbce839ef6c476062e4b7542700665c31dc566cd28be391a0f993c0b2a04da8c9456a6bd2599e68efc7ed7225e24160be4eb4626069e134bab10917e4a7d09aa69d57012f8af74494a14ea68955129aa013cc52ddbc4f0ea99e03ebc354c3de7be69a09235e43d6f4f8423416ffde49abf09b8929b2890d59eacf6b4a41971b17a87a20880413055a31021711f2596e227b0262e9a34c00d0801b272810c7b6429ad888f250a9c496fae0f1c69079c11cad8ccabfd354ff9b67729f9a99aa71d8c6a0f8b61ca626a3bcd28de55599689ea07213c7d33b81f3f836e981c8097791dc117b8c78fde1dee4828a305683bfd799f23eb6c70ca4d03fb150dcc0bd1f832930fa7750d561ade93b29e9243f3bd5317c22095ca509d5f0d68303c03cf01782518287e373a50e7182abb3baafe05954d85f1de1a589959c9ea0a1598e394a87745ba1be78b90a3299bd31c5fd9201da3dc5be75ff71ff0f1dbfb67a76f3494c61fd333ebf6e946e3167e0abe52c2e43a4ed9b15c25e5ad7a96a1405e402a53f634a155399ca944b5d0fcd93f77d0bcb4da1f53675ea4a28f5c5e7d31d35ea2f40c150ef5bf3a0d4d9a1fb51b24b2abb5cdb025aadc410f6ed65017667f659d99de15e04a0dc1f8c5b7788be7c2f9840788f64358261448cc38c68a711900b01bb447b9ed716304f2b0477a96e9105fa87108a054c6e68d44319cf9c9038cee6149611bbf1cc55f3a5e4c527cb5b82385af96eb6d2e270f71bb562d52b2a3822a2512f8ce8b389aaac8064213b0dca7e5fd1f7e5933c6c7676b92e4d71db780c42a6e53a31472d327926dd32b81917e6eb04fe408ef010c405918b4f15d3e3623ad4365afb4bc7c507456ec0d6896ce941993139b694df1b910c952c3df04c373d6c69dc444c22e446c678aaa8ffd47d8233656d1e74e744ed3edd3dce83e8573f1fcfa6bfea764ee3fb6093343d742fa4a5aa08c41958f938f60b378880c2062f58d797f5e44329251e544d146a9965994ee4e1f8b22cb71ebd22af61ce4d163df95761ab77577506be77c3cc96a539bf95a98c47b58311dd05e9c895200b1621f811c5f5b67786bae01529a99526fc9c449cc6a8d9a9e0a5d3498780285142ee5145b0e85964bc30c83cc9e069263c691bf2294641dea606d220a0d5b6457093bac59e793416f1d8c9d4983efcfd8486678103a9a955a6c91211249e20e16e3555212a1bef97a2ffd2a8da13d25dc6f9129438cc997adaa2519de48aca5d28a07d07df62e153bbbc65b6e5c6be47c05b670bcf4bbf9346e57828cf857ed0f00fb335366be257d2525e48776531107cdde473c34751006c9739996024f068565e3bd63dab9b69bdc0f15027a40f426213cf176032053b8a5ab9e49bab1d21d2ff516747044b7eb591979ae15574a187a8c9f9c55e5ecfd70452145540f65304879b1e7c798f776ddf1ec1456cd1553bf1f29e452b5fb0a7f1a8e3eae06d1a0e3e0021532b4a5e0aa59b7aae497bf9306a4efde61d82a6f363a988624c9f5526d3a76cb3807022c57cb3997620e212b0a343d90792317584340aaf2961469b1c160d1dabe206e397f0ca7f2968c9384cf8dbe6cd097a480df39b3ac96ca3477ee81a037ba0137b2b0b51cf9094e32b30c1a0e9c1d77fdf44793155d9702daef989dece3c47a1cd26de17c0ddd08a3395020cd5407537d699faa11fcf6fedb1f0872d836a7493e9a29c70eec0276dfaa621d5559d79210c40756332e1f1d6645dd2978772d38a2f7db97b02173ee2d524277246be95a54ec00ed6026da40aadc370a0f1e5c93f765132b5e13fb840d4f90c1a763067a78177c817e5b0c7ec02f93a0c6477c74737bc19b5a3549d21828e35cb3bd1b7ffa39a01b26b5b310620528391a6b4b4feab371d370899ddc3ba51135e3faa0867644a20f8f6ea0a175a2b404b4cd1a0cfd8d555fa12a1c03d6115cd13382392caeff6d0db819e393bac23eb701cd19e9055af726cf808069db6f9ccd2306f9b4ae7ed1639e1719d968f595629ddf17a623420c0266e06d63dd5a2a793825c1f282067434a05ec082b17c87b544ecf9266bbc4b8f470f303c6522804ff7b9ec0afd2e027a0ead985fb86738c15e3991dc3e932183b4694932156d461f41f2501d63c0eeae97bae6d1c4ec50ae36f7b5dda76e309daa0729929d15f9cdf8633877c8c6db04db83289621f9ecd3a2567a92d66a943d9a8154b95a8ef469e276a43eeefb94a44d8ba27b5f71c7fa6ef5ebbedf702cddf556e52442dff78f672d94372fdaebd8702eb9be7715084db7e0e05f530c2bb57ad1bec3ad48e9d04dd47ed37a368777f24856400ff10427701bf8d3ab51e9f3512679ccdf60cde470898684da4d65ec919cfb4ce9e3360e589dd90a230637d0533e0c2c612a5d7edb5965af89b76a58e2024730f02fa564d419d195b95ece75a70dd00a588206aef3f8b4c99f304f26aeec9b80cf690640e0aeb4d3d077207b22e1496c3cf666298e791bd6b127202c5834b22dc70fabd859e406c502bcfb4ba6550b551ef37bec464543a9e18efa15c2aa2cd933f3bfdf4708cacea9319d2dfb7648ce4a51568138b9f353412763d9f1348ab4f44ed2001183be1d38bdaf9c9a716a1afd6e35d00c877178e387cdb1e9a5cccc9a7d5a3d823c4eb511bda81e20d7bdd0840112c22c0924c54a8465edf98aaff98a3dfa51097155ca4829c66823c3a03a6d6c75217f310309dba2422a981665c454196edfcfa0c8f6cd8440dc1ca221ce71117564a4c36fa9049141c287841d1cd0b0597c21a1170b22a19c1643b782d1eeaebf06f2cc62d9acdd139cecc055b2529812971de11f9ec0dcb604751f07677a5f061cdf5bd80dfb501667406a946f943931d1f4cc1312b8dfc413440676dca928c5a913763801420d6b75c6d0246da202f684ed9a2c59d39505dcb5cd1cc600aabe25b52116bd77e39e33df72958703ffd5fdaf171e6bc7f634a486afeb86ad1787edd0ee2c3f8cc9c73f10bf83fd37fc2c4a677ac429b9108d0ebb2f197b2c194485f709b2bc0ad56b6059eb34c2f634ba5cf7e6414f159af05d3a201a62893decd2decba2c780322f2ed5bfa71f528531c5d2e74baf43df1caa3aeada814a8cfb3fff27a2d4e36e3b47b19b7ab81a310a15ef4ada6919d34b8e79616b65de58ea572eec3203f044aac77ca2d1e01d7b1b5831108285601d152adb14ee15149bdaa407a61b188d62040fc830d94237342bb352934f04210839b1e1681e0b0bc2bc2f454b7033dc41c9e11409cc8e47b89cb41f73f28da658476356ca47a21c6f08c451f4250ecedc7c870aaadaf0e27219b875351b8efcc4e30f279f32c4a5466010c6f970bc7089abdf5ce2297aad90a38b41442f7f25c165dba08b9267c3ac6deba8c9e19a48c55554fac12b2fc864b7ded4e539782be4a68443def4d4ba71ddf6f6112bc61c982428f48ca234c031f33c7fde451c182628416067256ca15232d19aa2224605c2aacad220e7c3c58905c53ce9450b49936831945f6805e396226a7c15b2cd68ccddba1201977de1bbcf5e6e82855172751a6bd74fa5431e51d44d57542a9b7dcbe00d6e762cd3ac3a54de8506e1a27ff57f0a5632a196e8c78f536be4c83125505f5cd8c77c42afbfa110b90795f62614952a501e4f7c4239e019b6a7eb05ab4397992011a0229578aef7f9caff4b05136e6fc78a6da75d5d01f40f329c41dcd7dccee5d48ebad5e56d8d34528916846cbbd7bce33b623398be5e668dfbf7381bd9f205e55ef5c5686fea2be5a6fa33be55f04d4d44b9e96b019be713b89857bbd37c5837a09a7747ade0d2dae01ec5cd2cf2b2bbb9ac25c29d12686d4680427cad7d7eda2f7ea245e0ecf0f8aa56a2220d2f7b52282b377cd40e5e7a6f6bb5e2f6ee4e357cc8c0e7c9d3d955eabd140595df88045098584480dcfd451ad77898e2b9c5c3097d355c565aaa2201eab9b06a026582c673fc047d0c50af3925cf49ea3a4a97d43f9ffe446a871b72c8f8b14d65d051abcf0f92d03f3f453a155e0cdaad85f06e6b7ec13316ba68b9ef027696b4fea1ac98d66916173f0ee8aaed7e0f4561d912e39d1b3374b783adf4b629539b53c69d7f357c1e6122b5874492cdd34565d28d67b62d449ae9bd110ccd4d9f04cac3bf54d8a3ecd491d10ef1da3699cb524abc42e3f201e2e158bb9f1978fd4b111b7a7f2b90fb2ed224e18217b943f0086eba73f7b21e832ea91e3cf5199a8fac85a4b75cab628761a9376c420313c766871921d192e7fbdead22b93f24a97dc07afad22ec4aff674a886b5c67f4d78e729499fa3994df36d0b26d4467e429290f2a70e18a8f228f4df2a83884deaf5909509816498da39fa8501fbda86a48484ce9cf9401c7096de2da3df5a0d5610118dda6a05e47171b404094252fe6c7589555830e8fa5d01406e0876b02e517a3fba0ffab9a5aa5aa402e897c92e3780130d4091f2e1c9bcac04f589ec9c1a6e549a19de9fe85444360264928e57f769cf17eaceba84556c0bdc3476e4faf3d3e1d6ecd4ff2a96c0a09964e845a54bda969318767c305e4238b98ad966d355b1ab398f563585b279fa3ed10d06ab942af621bfee958714b9d65fa71ee70279ecfb66c478506f2426abe8ba32ea1609712f100981a7c7556c89069837956dd1de4d25a618e8a25bd862064091a74ac7ce49acf1963d1b1c6d8ff89d7b5939618264b213c75d51a2e3db6a720727752c223b8e29125e4ab609d7fecd1ae69be2220ea6acd57aef5d558ebc4361f567d135c54889430852df9406ea1bb4ffea208ba54882d561bde1a7cc312d6b081e381bdbcd68784b15714761cfe0271b452f83ebc76d0c11f62caf6cb9383afbcdb301c7bc489648016d059cbc6989d0030d4d485aa8d582f746ae13b2f671ccecfb5c4ff5afa28aa4f0d82c114d73b9deee1efb9801fb2c588379d5e4367da5dd2a351cb672259138ce84250f6f867c94d104aa1b5ed54e51c1aa1a201f51492c3bbdccafcc8111b125f4f367b76d32f2898e9986c557ad3e23b46edd531b1f8af04176f060e1801316b75397cf1d11450636e3740d258d98d16b2bc1e698d634d99af0087e8ef42061ec0f3601a18cc1f7a8dd92ea5ca7d0e92111f910d145c15a66d1ca8a58222a03806d442d52da49e2f6c8b0e9309d1e8d21757a61a2e5c97b268c2651dbeb4215cc9d456e700d11b8d7158073a7dce5ea0d261d4e6a7d6c71ca5c81e739944260d729e6c65e9d4b5b28d9806584f0ddb04d2d8443db19f0ca1d17bac3de90104960975f9e574f5bef964876619c31905497fbed2ff4e9dddad0122028947924ddabaabe3e26328cdb7e7015003bcd2ccb77bd649c0dcb1d61ef05977b675e5659911f6f9656c70ab80ef15bcaf58c116bcf644ab060837347187038568e80591b207e545577725eff0785d247e9b15fa283073066d34eabb66fb3676ca058a27318e8f0d4cb9bdd120a0a7ae11fa58345c0c0eea88467e7a88236c4ab15fa0cf5f4b771c1223ad7db4ac8aa5c1b2524a1194671eb8fb79295e77a9411e6781ba91611779cd0c070e7ef10becb94912efe1f26f9d0640950cdcbb639c3c48b115fe00f11233182fd7a9c55cb9b9cbda7d82a55077b0595e392e0594db0f5858be2ff47eaa65753b2cfa80b3f5fe1f0084256e4aad0b67b09436c3e46a8a8d3042d1367b4257d7c4c86a8bdad0ffe0612d5b3a61147340245e30ea021fee2d27a2b161002fefb653854f09fd65facf00ede03a6f025e981c82c8b15a7ca167bbb3882863cf4b5a219c9c3d6aa48d017ba7fbc2e90d80309a4df534dc0167d02fa36836c9009ef117754924d1c877175e092b028c3fa0a578b5fc609ec3ac2ea7b09962cde9a0e5b32b1edf29236aaca29afb6222de3d05ed449c2c61d923ef9dd2b82e4161104d654c8c920ce130cd42f66f9f7382b8e68e45234bd6d8c81152c3b3713e0a160001e738f069f665f907f9f1006848e6367234ce65adab1de267e8cbdd993fa3020fddfdebdb2e1008b3abf703d28202a1ab2bd497fb662184f30a877d98462b108c7098f65115d4ceb06499bdfedc301c5ec06cbb0c1b401280810997cf756941bef68cecabbde29408586d8a36ade3e48c02dbe34996a58fc3301ad69c10b1a0202eabd4668545d4d110de24195685de66e7b8ca682ba677ed53e9e0e4b40bd13abbb87a2bf4dfa0578f747a59a9e775326f7744b8a7788168d5ba559954ab8c48002a1419749a772fc7538d7009a91ab72efe8d610c4805f07860cf592a43ac38f67aa35a5a4d45d3331f645dfcc9e0eb938502b33b9c04dc9bbce71bacbfa1523a980d9b3a43fa45526f04335410ed97231d4a70e4cddba674f9219e43c821f304bf2216d42a25c3d69e5114f705b8f2abebddf73785c56d1fa329c4d6588f370b41b380772c375ce8184376f9cf159e85d319ab67daa1e0599420183b4da7bd21a6985af9faf68f579ab0141b72d4a3323329a7beedf28b012473decfdff4bccb05b4006cf48f6dde715941e2193b1e8120ded199efdc0861e7160bf2346c7c4fc93877d8163f94b95d2b8f13512e7aec8bb24709d465679b75dcde33630cae6b9236f3d6c612078b33f2e1bc3ada9f7b707d0c1727993861f04b55c760536a2b132cf861614c38b1686952fa0d989fea9f12eaa7de95b2bf22e6150a758f44679c1136984740920ee0e1fd22c540ad9268b26241bd85af3083e1b8f4a2f8ce78d9bb840748db2a60f8d2970b6f6b82bae36aa80e164755f77f42d9e612fcd516f8ee618dc269a4978a86fa7432384f71363dfd143e32f1fba81e9f8431484994acc2b7b53a7079765c8c584b0dd1dcf0411a820c77752d1df64db4440b2fc69e6360d43ba69bccced487cdea29340a16845566bedf50db74f5c649402f7a467f2e0bd8ff5217c8d40fbee7c2a2a70158cd045dd85b13554df3f3ac23f1696fb32f5d00fffd1ef0d773d76307bb1da5f6077dd6bf815a3242725245976c7807eb79dc5595f2feef004e169b1ffb7fce28e3d2cfa972ceb52e75f268e1c207961bbaebf5bdcf92373f1b5d01c10244d8adee6c6fb4d8f8b2e8a0fab544e29d4da600f61077ff14dad97d8f92f5c2bbc230629c9932a1615b9f93ce424665a0a1d5d1111e1c2ee5985d3f9a476ddfe20b478faaa97496790ca0faef932935811b708aa15f0dd420169ed6ea40831397124875eddcb30c456e6580d72959cfee6cb4a041ed88444aa281e327d99afcc04de9d110f47dbfff6f5191e99ad0d4bb6d3346f1c49abfa68f904895315adb21a4e060b82daa9de38401fd5874e16c4ac27b0a5b9e3e18e2259ed23e19cdfbcf29c24c1e166e0c1c8c424572dc59f9068c4486d5775a19936e2b047829e003337cd1ededb37c426c4415902c8dd9471e9c1b1537470c12f1dd23688f99be15da9119b0549791a001f3a726e6cbcc5457f0791d3d5e8fa75d512564b89d958eaa65be9bedff17d2462c787df571373b839b8fe0e6551a462305b925f98705c28305fa759642fcd54724bb39bc4eec05be12e16c61c52689b96e627f96b263ace490a92fde354909e9e6ac6c2c3e6179bd1a87f2ad9c9ebea735f7400b9a9a8ebdc5f56b8dc4bd0d46992d16ad2ee26ee42833bd519d3de3a91765a746707afc0da401cc1b66e24d7c3b2c882ba80b6d5e8ccd3a0b3fd7ea693c73f05d4b8ba32131dcf3f2e0e2c0547dc9a76b84cbcb7a4766321390cfff1b607f4ca0172bf7dae2752304c56c03ff299e2c6a4664772e5bcc001b24139a7781e51e27c6c44cc9342d19716c7675a77f6cd40d9df7f971ea7a33a601eaf6f14e3edc9aef449d3ac85526aee3c6b81b5eb7daac094111401e8fea1216cb80133e0052c26cb677c6fe0564c699ab4e5f7ba336daa8b99376be2b92d46f0830d7a3c5122d8b9a702115e3fa93c38bb7ffa113b4aba2ec89ea65e03d4ecf8dc5e5508705999d794711927934e1cb68688b987cde1a924a5a54b5375e025c124586337d052daad4538363545ebfc7361e0a9923b06c12378bd8d66cb00e4247cdc39302dacdf561baffbb2101ac38b99aca86104e3d8e20bdb40506ae27107e8bee72c0036d9287d818130d013de17aa4be599d8d534844e3cdb4aff39378627369cae485b48a0300377078bbfcb134ba8ad57661f78153fdc126b94c6ab02d7072047a776fe19c70811cd39c78f104a251d4063789bb6cd4c5263b7be0c6c31e39419495ecad3113f9aa9048f4f78d24dc8d3fe1486b2fdd15e2dcc1a1c7bb22b26cfe12a7c4343b38cfca505ffbed00e64083119771415e2b081e6157029259728222dc0ca0a3b2d210ee55ca9a721d29825edffbaa58d7f7bd6ab43c944aaf5d35ec8adf0516e13121f9aa9962d98094a113bef645df3027980df44b066e157219095fff562a0a576fe38f749b4e8470a179419cebbe72dcb8f26037ebff412503f9d54f047e0a0c251175c5faaa1a196e17682f11de6dca2a85249d31ae37ef1c96eca75beab47bc239b73328f159d4fa9c3b77028d29d290004b0ba00d52f70feccd76214f643bcff55f818b994ed4c34f0cca52955ef8669b596f098277888aab7ef6dcf32e858ed1449344df0619c5041e4a45ab91d90326d335a46361f9558e8a5b4f5595d9113993e0ab8bb9711cbc3f0ababd5776f3296a7d00d3903577a557182ffb5977922f146b8c7c7953fd8c003b25f331c8666b87d6f44b86605e7a6d7e51d7b9c28a30fc795f54784abd3ded5d56f00439a77b123a0f3ad0af9503107d69db60cf8c3d906aef874d8173495de1ba436a7a2a2bfea39bfae71ca708c575228065ad33f4e9ba41c817d6f38d9fe0b5ae10ac8878ce343368a83674edf47ba6d9d4901e05e48c7380a0c8ff53b285ab9b140463b96b64d51d20b5bb33f413e777dc5ef8d8d3080abc95f7cdfce68bd977247fbf7a16f0d78ff9d012235190d06310d80630a4cf3c7c09f6bc6c8bc77db09d891f1781d3ad4c7646b67269f3b2b86437e75111edb4eab5ef9ef635e1e5202eb97871bc0c616ef5767a0e356a3e2ed8fe90b516916621edace5ddde684d927347f36179c46a3997d01a6476fbe5823066e85668ed17f5f3736e8b280c5f4cab2d5a050e044764506122035195391bb9067b05b35c7c9926ebd557ed6a5b5ebacdb45b1b4bc1b6d8f27b6fa8491748271c924d3975384104ed371cf46784cab88ab17d8c78c33fbf4d46e1eb12cc8b17758bf24b3ecc2d31c9104a11541ba91bfce2d624febfe7426d86d4e92a119278df726399c1c3cadc60e6f498938f0b9e9335f39c7aebdea5eedaaac83525a1c2f838ebbb98da1fc78264ce0b620fadb60c316b9821eefe41eaac2dc82012b73deadec4ea64543a4f5765741e8ffee9fb4883a670dd484b8cdbe811e9a304567d606cf7a3b3efe34d8a5005b84b2c209265261aa6587276651357f7fc023efc89a90f9af13ac2278bf5b4ccc8dd04c7be1cc700cf4aa1436e0c9001620bb46ae197a2c27e5f782080b9b321ccbfb8aa8e946269219928c3faf2121a2c1841b0689db442767a1e6748c8b660fe62b4c7e625701d0ea77ae47be7f5fb28353dab6e3d8195a5888e3eb6885d03f338cefbffa8ebefe226f4fa93943e49fd66e391c44b7013007a8545fb3c1b607f799ab1b32263ddeca45f5bbfd10d332f0ea51abe423e62a01a3a73946542c9bff65199d2046f1c522e53618f6eaebcecad6be05197c9cbbeeb1be25089ac79ade87dbc9860fca75d96878d8997d1ba62c883b42bea9d4351c0a42a92fa240db57e4880d7a74d750b1884783848ac74005e903fcc5651aa0ae8b16db1ff12f448b9231d06c94550887c800453e1937fd0dc752073b0dfdf7e6cce469914a5acf27e7a8cf27d8d7b587880f248230646a56aae4875cab8518ad97da6e845ac2e7f01e5c1114018b5c63d5f01adf0b5bd70b15bd4c05168f34cef035d82ee7d33f61951b18f5074df60b2c7cb87fc725cb7a34360b5f90253eeb562d0d4e4eebff6e70fb3eb91cf78d662128d66cec06213f282ff615f7efbaa8c81e9f0cd1d2eb79f472c210a585aecdda0468f83587e432d4aaa94a6f158b26fc5c1da9aba26541feda7c3022ebc655c4698684e20ac899933201673ddf9157cba4e38cb6baef469f02445f591fcba76fba0e7c7cce91b2b0ddf63ba2f7e5676af61968bd2d4b2b28e5a4a959e949fdb5c46ab540619bbc16db49bf8112397149c8e8d9d04275fbfb9e319d89f692113f15dc08eed3d0c4e008e7df27b32d583112c13f1fd13a38b791af56322ee2a2e229fa71719abe06c7eb3239c543b38cfbf472e6b157c2bfdd59240f78337563dc6471dd7e56d0f22990b1def278ba5e39cef7ab79131024078f03a3e88ab36e4ead5818f64b4792b8c2e1655e5aa8c89458fd496dbc5f65256f5e5d694d1aee45a68df18ad2aa7ac136b51d0ea345052e70fcbd5f0121a7daf6eb6bfef78e41d4a15d62285e455ecf22d74477dc54a03f58c140fc996158b10cde321a8841a7f70e913872626608b8311e655a78c3c072a6af21e8e149de63ee72d67248355d2f97f5ce548d32d2e574459f560434dace2b7b14feaa2f83e6400d16a67687b1a8c094588aa91a170e9ad34c466e503ab8942b6ae3bcd41a8b4f9bedc3d7f3820f39f6e100d2038eb37efc59696c6a3ac62ab26354f2961d4f65722f2283d8f6e755ef253b2a9e48b4e8f399c3565a66b3aed7051fd2a4cf259f9772bed25e2e77b6cfe5596b037165c67f62cdcd3934d64d40c59d97fbd803a6cb5c2c31f29629b656b9a007a4c7aaba9d16d0fea6ba8df68676df6e84419f5332378a6191cf9742b2cff00d8546010bfeb88cb88b73e83427379302fb21a6554d5c0634cf35d58c9d0c274393d1d7ad85e464368b9944118132e4a5dcee14c5478352884377d3488117761340cb62055dc22ea0242448ce53b65c5a10dde5e4222670ec23986ffc627c5f8fb098fbe121fa55afeaaf01909f3f844b5d16abe13416ca2a739d09b781a44f3637de94908e1faf27e8f2055e6c17c7e4399b8a46d5f9f2de362455884d15eefa3ad667591dbd1a2f76d48608d9c27e0def3c87d78cf7297387b2aae79ddc7f757a7c2ae8cafb24f12528ffe1471d7b8634b7fb63959c5d8efd3b840379792eb443f4738746510785931c0985577cc27f9acad9fa368e8c8d34ff1a0ef628e77c245a19594b3a3a7542d2f0874a77bd1db328f39c6dff930cb51eb8d60b744e7f1a0a9cf0acb709c546a1d2813f6f5f5fb82dfe5762afde8bcdcb443d3190838d87fab308102ed584d446b543968766324be29ea38dd4468320b043ef31db455d27e7ed0a4194c239238953d5560e1ccd6c8af62159fb1ebd3167024f695023528d918b190ebfed677bcccb3bd31f496d51b1951e5d291651117a58ea08580f48f85123bed405d9fda5b93955a3f279fba4b93a3cefbb2f399555fecda68d0f5e2ad181b08ab5f9f34370352f453ee9f56a30bf2e40328f58294a1acca6a6658f51e568702b3dc11afe4835976b5f185eb93c61045065da38b84afc3018165d93f9b166a61f3b67e0b0e6c1038f298ab016fb2302689cd2410d26b5096e048f0ef21c7230d0c53a1bdb1c448d5ab8dfcf57f2b8b46af6648038b8c4ca696a80da8fde3442fd3a5742c97a283fbb2042bc7d4a0be2eb06961c3b5d03cb6be7e3c4df2e1419227f2b9fa1e109ea5cf52e0e159cda4eff0398a434ffa261a579d94da70024db7b5580838eead12ed6874a8252d32c7421742fdc67b3eb5fa1681195d48dc49291ae1494a0092ea262f67f8cc24eb984af883797efa3e773b333f0f945aeb7d2d5f926c0875ac49f6e20bb0ffcc3e27389b594f85685e01173c35a178f76befb2f090106b078b68698481fc46dad602bbf784654ddef345126a7ba27d5a61e46289d18f6d5100bab14ac114859ba5e8303c893e4e7a2b7fa5c213829ec06bc14d8ad13887569a18278224432eceeee116069e3b6545361966abb1638632025666c7f2ae4e3b12f177d9040256b6aadcd3ed9ae4cead41045b03d3b9e39c0883ca7460d01feed4e27067876747872e4cd4929e00ffbc775902d39c1164c1f709b39abf41a26e7740153318dea0ee61dcf7428ef055489c05e7acb4aee5cbacce1816a5b67e692ecccd9270f8d120bb2049aacf0ad7659630dd0260c4aa3b932a8344546e0ac02a327b3a0ad9943a7a8cd9618dcfb873f5510a0baa0ae7d33c8c27cb2f0cf3781ad41d5193130feecb5171052c422eaaa43ae05e00772daa4f62237b171b0b5a433f27ad7eed769498c5f7035bde50d77821855fb932290433fc99a5687218201fbd28c111e79a9b1fed02983c943065ca2637d01a703830e6eaed8849d0413039e89afd95be839cce5eed653ac3119b731711115da572ef0538dbf324589317ebeac3a215ae5ce50a403c34d9e439e6a18673852df98f43421df34584d94afbe944286fc41b9c0cb6fbafdeabcba654f258b61d57f204b17ce2ad4fd45d5ca2d8c30af03ae9ea9c9d0b72bce6b3a336212355122c626e6f1e42c7cb33f5be25a89eb515913820f5f5a667bd3ce9218a458b6bb85c2ec25a83acc5bd22d8e9c4e1c5162face4108785b54692569452ba7680580df7de4f2cc6aa7c5266a812db5aa630ad052dd0b88f883966a0aefda8a9c4478e231308296b2d889b6eaa1a95cb425ca513a392b26c1b00eac83746731f66a623df46404aa6bfaf56ac22c2a307f4e7a867f05f17780b044562dcd3b5c48b9bce643a7d0f08d97681e96e78944412e84644b7213a27af8dac81876fe129d15ec2be4bf9de69768dce9357f4e75dd12efeb08deeb3dff77eba978eb644385e8726e977f41c0f520de0dbb80d27da61f6d4fdcae59739fda6268b49bffc5341560c4e81143419f7978e69ecf2741d708b9e5282b4dfb800ae73de56fec32df2dcaf27f943743b240e754a48319fec3e2aefd50a0282a295dafeeebb4032cecc69d22ae0b980774dfc8a1a6bdf3f3f9d1ad0e5dcd81d8bd4f5bfe654b5607a7ad3f567f3156f75ea418388bdeaefe5587031c735f5cacf4f54d7ea31182358d952c882c001cd484c508fa59f21ff08fcc4ab7904d345c2c1b8fe786ec13186b354fbc34ff4b96cf0a4f3f9010d5bf1655bb2ff7d0d0c0548ca0272348f91bb97bf0e991103c1b6016bf5259adb57955d3c1d622ea32da6fd61247d592bbed1495e21d137d957019fcc203f53ecf974f74ef6e44ec2b181480fc87acd31d8bf9dd4a18bcedf5cdba5b9a55b37dfa95dfea80838d045f9ea98aed5b3b77b2d6c34c0f8404cf55aae32f7d3c1371250de0fe21412ffd6599838b253c69e5b7a547b025060a14433daea70a1cdb43a03e13b10626747700de913a420e779136ccc74c8aa0b3ef40079ada6105877b0ef2c7648c0b43b995688a9d90c04037cdb28df532a8106aa0d7df75bf697e0e4c0b62f58c91c3dcea5a23fc2744fdf6af400faf1024f2707a118e2ca298f045195cfc6d4c2e52b800b16584f4337541d84bffcf553eb68dcbea36722a987d0ed7f86cc279446aa19eb2d4094de2aa6609612937ac10ca71cd216a848328b1ce1fe8ca90d9619c71c13c1f1b93f5af86f33a7b09c84d6e44e786a97fc8fbfab553ff1050f5771af6fb30359453ebd004e61aa59738fbf660fb0077f526f9d58ba86310cb8fb059966dffa3a5b87cbc27898f9f0d352019ae379f82dc236b113b6fde92d1d51da70fd78cd732306c39b3003aadfff115898121a3563a7d92e554901ac0bfa53aeb9257ab77ea720d75c0fdace8368b8116ecabaff5d6448038f0462cabcb5d69f2a60e481e02c3e4d71faabf98da9a38899258bdcf67cbfd81851dd5fbb5bd04b8a292512bfcab488d25a22cc6d550c81edaedc152a3adf531b2f1e8f95f9061ecb2789030e63cac0e634e15778f7ae40429b0f010a4586ccfdc127a38734a65f239ec69e74d4e4288a7471c4a6b0e3a5393c94b334b3323d6941d03e881ec2a893288432c23f5464e1c2be560bed7f8f0d21767ad8c17f35ae541563320499d1c82ddc63f6999703171816501884d55819de6b9b7b234d0238ab75d939e8a1a379c9629e522c226bea915e144029c1427551871211242d593e42225611f56e69c41b8dc1d6cc217b3f26084a8df7d9f4343f158265ded32753dbb3b775a1ce8e3f779a0c40bb455fb9729f9dbc8b64b4c1c2c825d03bb481acd51a4e21ab9a3f06c966ae252d55ed241520ce0d43960f9f8077878875d024f8e1df85ee4637cf2f318d913188214fc3690bbb9619f317b3a16a672b297a06372eaba1bae1b358076009ff5511c4a3888e2d0539f438746206251059663043acf01667677fe88de57939d51fd44e3490ad3f2871b4cbebf7d876a3efd30d713f896988ce31dc402f3b9ddeeb24596bea107e59c3a4ed8ba6794e8487a280b1000b357dcc6b0c3f432e05fbf10a2340dda3ba56e235b8113b2a85f6b0f2833fcbb184673cfb808fcc0cf9f460d5d97069c77afa3ce7978a9555e109d8875ac81b4b57a6caf3b15db564624dee0fe5d897729d651637d33c82c1306090b9d9083a74c0a3a3f689985f6a77e588752948c807323b25954a18d3d1a6aa49b4775459072ded5fcf678bfaf98b3ea6b06f63149fbd296ce5c0466902134a7b5233672ad70a3370d458a8e7b98e8603306a597f9842bbcceef4dde94157ad008904d6fbd7b42e6a6f6a2a4a4f971dc2d01fc1e8e2bf2b55832c7e955fe53b9f16c5bd0bf816dbd6ae1694295baafdf2c6f8e07cb043d0eba3f7a6babdd347958b9addf4208c9d79321da3b98fcd1dbc9d80f14aff5da2a15a44139e93e4ea4b35d84263f2aad6db6fd05095fce7ef5e8b1a46b9ee482fdc81b8fdf74bfeaab84f4af6a1be2266fc0ac47181dd699d96e935d9032611945fe2e4748e2fa7b4d0e55f39415027215db57a2097d14b8092af7e18967a5b484ab03b5ec233113ad23eea4e5007c6364aac5a0924e12afd7aa674aa9e97b08be03caa3f531c3b1ab78f809036aae88f7cf789715c1ad8b917182522a239e95407ff0bd58a63f4414113c2349c7dc39e9cf7c41c45d5eadbda67190674ae3f07409228994c31fd05bc163ef31fa5fcea324a1d505e4a8a07285ec1b84618bfecf505fb16aa6c7c91a66020dbda6570828d21d8447708d0b61fcc19e9909a000178f99e65628ad96f19091f58fa8803aae1ea002269ff373cf62266dc1671f74166f58800d0e446af007ed1e9628ae6ca9b8b962e26e7d0c48d14658f12a201cdd16d81dd2b337e55f1a49f16965e44a541d003cbdd7b32822097df0974903cf67c9ca182","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
