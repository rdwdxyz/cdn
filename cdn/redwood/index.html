<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b2449e5af5dcb72ac9771ca377297cf0f12050a7da512820905bc01dcfa3dcf1b3d2126929e4a8ad95b1b4398f651377abab582683fad8e2f183f02f8397670de8fb98cc509f4ec1cec6e712847b4aaa259c4fedcd391033818f766c485aed602834fed61b8e63842b6fb6866a7f1d217693c302092e3eddd8fb59d658af3348e449fb7426d21e7eccc1dd4d4801fcd6b17021a3bc085da25af1a68b0338b460b268fa0ce8930bc0bf4d84c77223a9e23dbea0b5664667a5ec9f8de7da11c69c888d44f72bb1467bf3f588710b212b418621093f829bc49792a9034c91d3de6d44e7f4c1788ebcf25c6f7bca1129e626256cb7ad0d7957fe664d1bb08d6ca11800bbd4f847f64f876602798bc6fbedd0833d054e2b142248f1b1ebd776a18c411f4a726e6fe554ae2ad3f71ecf9ee3d0bb39baca59b1acecb2aeba90592504360b27549edbd1397179323c94cf7ceee824f1ebacd83dda99a895d989cc7d4c13ddf1528899ede7d2ad90e8291dac0d69c9c450c709ffd431fd2719d7b3eb8841d630a49b0774e9a327847ee625eb4ad4ae4a82841db5637e669b5afa8a2cfce1e10086b084f132049f74f44650bcd03f04ff5ab316353e2ee63e3207e0e6d9581aa33353edb6bc082ea95ae612e1106ca9672f3ca4ecfc97918f19b3611e7dae885021d4e4bc216eb976b3b2919b37889e4349ecd6cebbad1d93a6fa871b1a32f56f4b987bcd8c0c3a287738b9d9a0bedee8eb043f01c51470329add196e7803ae5c8bb776f00e3b0f88dfc14a7a3a3b48c22059cb03d8b67958b67f0ad76fc3d74cfcbc53e6aaa7aea327af091e1aaa27822b9fafcc75267e2e40115ab3e6d97dd58c4d0003e193a56fb774a45492edf5cc3a08cbcd90745fa91d3bd0921b8108ea115e5df24eeb5b5152d7bbca1d25209e627cb5346fd6f5d5c1772367fb9eeac2eb1fda68307d11d83256defe35ee5342f2fe6658ec2036ac463799a15aba37bdc010845147fef0f7dfd36ff965e6624b37618f6a0a4ebba924d5be15c4ce38ed7f95f848c7bfa5aad3557be8df20993f2ea94cd795e56770ac4caead4614d0e171570d14abe6cd031b92b9decb3214de12814dd7bc48396111e4124ad4c705cb061f3e89fe45f9581e4aa9cee4d6f425affbd41499f2b782aa105838cc26c6b026ed9f31059e6dd2bdfcfcc806baa36b842a0fc2d93d369d0c70c340ec2a0cea5a5c036b565b879f93d81c33fe6e84cd2887644d3a01c50595dc80a1f0e702a212f0c26953e9cfa914330b8b50faaee6c7405d64d0f175d22ae90daa98e52d165266f2f65cf8cec074b59adcbe5b37962a5e2053f5901960f99e4dd5ceb6b3a92a7f9c254a2aeee64b5cf0ed497789158a525f779c6e3a414a4e8e39e23ffeda758369143076403b1bcf321836a9d1b8ee3553eb1b2379b9334efd276d703d52a47d83e8b392bafcaec8fee395d0a6b177da2427c39baf9ca590925e31845b0cbb922a6f095e71c2763f164a43309b17003f5ecb77057f6d4fe6748eb181873f855f82d459505eaf6a68cbb274d46946b967894088f5521015a7617767a4f6f681971e663e59291c376ef042a738a1a6953b92a1399dfbbf3be7615af4826246338aa9c944815f81ff7e71ef6819ffdd9f871dae78e2dc1318466002ce532e7d398bb4005cb0873917a93eef2ae490ed821c8d60dfdf8a2890bf44326ff3f14b386f20343c303152cea0d2a9b8e2fdf7fc17e944ab1e4a6b4d2387d311d89b8d5cad8d86e3c486afe6c63235d4edf9e3f295d6ff059a05f800ca29db0e7ddd3191379f56b7b6f29c9f88cbb602c1116058b12791470b11863d145f465ba65029ec47cdb73aec7e56d30a7b8db17688b2d71bfd3eeaa6d6f56d7eaa546d759df10e17b2c0cfc83939c43016ecf1846371eb5a79bef77efd2eed85976b5d3851d136edfdf5f418b1a77ba3e7a6a0f506393f762849cd8a560f69cb52c2dba71f7a109bcca8f8d31a7ecfbc3c1da08832cc872c4fddb6e40a948f86d951e5c384634e2f2f62b6d6a334ba3427c13d873237c194f81802e85694b8af01d456e2f80234615fb4f4053c6fba4d68cc5482bb620d7510ff658588f30d30970590758ad4a409fbf8e87f5b0750007522edf6ff57babb4c2856021f21e04206b008dfabe520dc10d7f71d61a3a45880bd3cc443e7fbd0363fa942a052ef522763db825b3b3a7cfd35d969a12e83297d8db8a09364b0b7f97c8f71e217360a1db36d4afc43891cf88570da83364163e566e1e74ef8140f0cf88be1fa9188fb8c42f4b9b68a0d56ee0d4b9afd603b10ff30a849a6371a44b841ae00cf3ee2ea464e30fd015d13ab3344088c9716247fe3973a7120032b6e0caad1e69bd1badca489ad9b23d2a01fcbcbab3d01519153f637b74210f656f478af24088243c1ba6e909ad4601ea84eb94e670caf7217f09e0d053e484596137653b140cc76470b324b78077ef6984ecc64526c7647cc97ebf2f2c7fe4646dc7487d75d10d56d5ea712b5b855368b9699e8687d0054e631dab4c52d6b31c9cba1f67bb7f5cf5114105da7cfcc5307d21fdb5537ec82748fc716c45b3da7ea67e8543e62847a00608251187a79f37b271bc5580c6d16b80da54121f4f19857de5bc9c724503884189f0568937e291e8e6603a468c0ced1e21964f43d57bcfedd2c7174ac1502591724039cbcaf989a57ecc9dd8503ee84f1f35855325abf51c298c33c607e02eaccfece4c60b39e2601c952f6a960b58e61f7811f164c47ab476f41cb056899482a894c9b5bb69d8bb55145755d55a65a5916cdba05307e926d47f918114f83bf3594a68b864d91632728f43905f5846b2b3cb196089ee0ea58bacfc89d75257ed702d1962dfc0baa9b5d6ea4c3345897fca7a1b53034d7d0253ac157f4b3929768ced981cdad16fca4319974fa20f712e28f67de3e3561068ed26b7851867c69e1ce195aab1fe137d56801b1784bb86986ff6f8e5336a43bbbaa7012a81c92db9eca4ca4bed1e9a6738d91ade026ec9d5405633bdfd2c9516fdb270e32efaf5538bb957ff5461079bb67661dc81e07d39d1cb74bb9d10b1f987d7b75f83d559fac6e67e24bbc308a67d582a932c417ac503c2034764ce9ad1843c94ebdeb89fc3080ff2cf6cf173fd49ddeaec9ce8eff723d9fff22d66613be307991a98a42b78ab30af3197a310eccadb481d754c269ba5fbedd4ff2c0b07fb6c6666d12e2b2a0682e0cb3b79bd58b3e7e8895ea57dbef218b1551e708d8eae5ec636c760424194bdb34c6f70cc99d42621dfaf0668efa94bc2d898f9421a1c6e648112bc9836c59a0019737f161533944beca67343f10c76a6105b382b862df67d9178ff898475c1243e24ebcd58cb534888aaad72c130108cf65f1d4a4385bb1536326a2e3b301765aa9e8b6d0441b270533d98cf66a4cafe8b23e908c423626a2935805ec097cf99745298a121a79e8e2333f844c6192b801c25dd0432744d96cc3e3d8ec07657e6ffb8d55f56c9d929503a3760e510ca86d8b3d39b6d1ab1d5b5e942ede0fb463a89129e99b1717fbc21b2376333b0b3501b799af9555a38c4f1d5abd2d6ac7c318b1ca4e2b3d8f63dd011eb5c821847f5599570b7154bd4a7b50fd5a02c3a1bd943e359c312cfabffa0ac6097dafdca9085d3e59fc0927ede38a0bef24f7d48a1c7ee1d52e78e2b517c4e07116f2d7a1f9872b1b394ade701586a524e58ee47f577ee6adbf0226401f98aec48e4256298e44425f9999f2439e849f13e971bc7a835393740a3abd1e19c280497c82e389b86270f010da3d4f076a7179c397b1337f4d7e217c1af892859df46b3e7dca16399b640a6e7bd608cee275454561c46bb5c5eb65c1532d6be4ac778c13ec0b5603e198d8eed2585485c7277e2b715653405524b7152cd913656ba3ca12f86aad94d9bb25518ff1c2e57fa069bcdc7c94f777ac433ca29e93e928ac2fbed30b02a2fc6f4c799dfaefc7929e0bf149ee807b8dc93e072769ce8207dbf6bafc1c0656fcb824b3077f87d66ea8049a2c8192dd5f5114c129492f490165a187fbffa5ccbb0ce93c5c0f1e92e4bbe5ea58e92bb84bafbdd67d234f150c0039397f5dcc8685ea6ed86b144b3eac3d903792326a73f1286bf18a914c1fed3c36502f1ca971a7bc95082771c24af592af825bb7201cce2ea42d487f8025f7177378c5c85ccf9f5e9e6b73f8ce07401cd45720263cce6a2d793d7c5349d7bf468bdaf44ba6839d125f54ef018bd8e9c1aec985e36349c8840f1b68cd2016ba52df31291eddecc669d679d01443ea21b02f9b129c9d90c4b3468d6de0e2e08ae171456e86ea4f109742d864f25f9600d2265aa697e02f0294d547d2ac41b3ba5a868252c48ef328eaeb93aae258ea3ee186bef4a6baf92db672fa13e998e7c49323625234dbfc7e33b6b012c273e1310999014f9024f8d8d33f981f58a68f034905ff39ec4ee8fa076b13b102539c15cd659a7a9df5e9d39622e4db42fa37bdb0e01aa5bf08e67b5ddad00dd9131114f5dcd71a5c3ee21e33403d52a5cf4c49ddfc8a3a33a35b36fff91b1ed6754c67a03837b2e4eb7226eff1c9f1583325d5de542d6227f02c100fc79d3dd9123521140548cba361560eddfef24803d46211a92d5084616e7d2bba3adbfbf8fcb880b750067d21f6a62dbcd9a9d8dfcb6a497e60a4daf983bd95e62bd9207a547b56eeca533821b585fc074b758a46e7c9e8039b6a86bb77c7fe72f4d24f269c1779ff6f7b43d245eff9c764a6100f80c5c0380d1ff890857ca0e53fac036c53e78d67e3a3a4e4737e9a5fc502718209407dc7058879d0c558dfe5d8dea82f13f76c509eba28445750d0799f8aadd414c07b928b1593c063bb15ed6edded803f186de4c90458b8b82656771f05d58fdaefcf646fbd1b22f5a7c30056255c97dcfc3f3ec34a22aca6be75342816fa5b0c2d6de6f8d9731c73d328e3d4513ae5baed828dc6c5e5ab6a94359942b81860d652541abf7da69cc79f3a328aeedb851efcafe6b4c0c37a0466fbb85bb6d7f69e7011ded6ef68584f1bdbd29af6ec7a38ca71660f154460ae096a8b9bdd7664d42bdb17d2a859e740a8c106480ca0e859713b31af4e331114499711752b4eb4456deca074c954dcdc81cc02fc98ae9acfc73644bd2ec137609b7c8a1b1d300c6e9acba926afdbc44e104518e0de03a3347f6792bd43aeffffdd5a8679a70a079b58e378fe6aec2c895aa7a3efce2eb57e4677e60d469598869b078376ae78770135de9288481a34f6fb18593f8d23d4100262fb26f832f4d131ca96c30331ae04d7adc30fea92eda3e3b4a327f6e32df1909c8dba85f95e6083c82284773d4551ed47a3041b03c5abd6957db2d0eef255490283cbf4dfa0d04b53a360c9c9a2b990c7cb01d311c61b7a539c6bbb43ef5130f2645c10eb93bb0467a227179bb997c87e52ef1c3080e8bfd0b1bca5516d330d294269017ae0a8627939eeee09d65bede4b7fae3996055f89221d57e500e6e32cd0d3e9f9ac93e7700505835f301f9db938c4865d6f1635060cf9154ea0baaf3dabc70d8dc0a1281c8bbb0fbb883569db2ea51c03d8c48cd3d948f2b7cc66f02448366f69c2c4b03024d3b104817a7ac5397bad994c5f7a7b50f84dfd469223f33d4ae904a18250e2c414c296f58ff870d5ecc356f9f4907ece0f130ea554e7e5dd2bd03c8f430841d66e9c5d5a2dc4638b1aa7f9e3fa7daa56cb5c0753ed1017cbf0e7bf07e02373fbf5d31456483dcb55f6fcb2e7f923add4c8beaa2e18f029cbffddb084ac089bc7288609b3bebb034dbebd918b86f540e0f293968589e03d758a84fb23005105f8a7ec236c7fc918b0847e65b8b609d3015c457ae55a2022850e9a9a2db94da63154222d2d5bae0a4eafca36f9c8a190783543d68d0605791183b2a96415d04630e45e8a58492ec6b07d0a2dc380fe9ddd82d576617cc88cb9a48e91c3eaab872ccec988dfca0251c3aa2ed80161b97fe97bfd451fe0b6834c83121d6e4d3a6fc93b17f8ceeb10f7c447288d0db3ab7137dd4954f9b3982b91b03fffe941f80f9d57fc251f13028a8788dadd912919277a2611ade47df41739b6f32e63fcff56c9ecfe795fc9dad8f91279d945041d0a696a32d2b9764b4f693cde3eef911b20686607a9ce32d1e587457e2766fddb63c971efbf01c1fa072352e8de22e603e203027447b9d0dc874258e044d4976a3960ac486f01c09d71e7308d6a71bdc5d14ad1fa54b5ae58c0b9fbcdda19957463b06a390966483eb43c1d9f9af29523f0df645065fe924e51a13476027cd6d5cd71754a3393103be059857e98e31d30aa3e76ec06e0f801c6360a670294d8d052e5e9e8fa0b1ba68e9ca459296817436c2322031c0de3bd6060faa8819e96b567f61dd8851aaa82c4a36e2401e905d3468bfc91bc529dcafe61e4389e387dab1150748763abfeba2c146958725cad303ade120f36311b0ed2274f72e7bff9b1bf668ee5f50885a5658f582313dab31a0a0cdbc2a5f79f5d56c4c988e256a65b06ba8ac4883f40207d6e9b2e25b4ea5c9b439b15d335d1e454233155d828414dcf4577af7507ac82e2255174af204920a6da31cf9a2efbf5604eaa83a9b3b0de93a900472dfc2ded1cd2a1db47915375ef5f36b68dc8f8780bd6558f57583f91005314e1b7696d1c47d23e5e72a4424b340b2dc4ecd6717bcc179c618dbe2148c67a18f2ea50f7817e5139d4710a11483d23d8f415233858907aee091f543c1f9322bb83c20fc158cf7868792a705aac130c5c08812f66f1225b9faa33a8f178c84809a4a7b9da8bcf27ecff9206842084d12e75bc6feaa3a4661b52780cf4337d0bc928fafa6d298de999afe156e0e9f0826b159501d795d55eaf17bb63e4126aa8e1661414367b2d6968a0b8aa3a242f0c8f266b9ad1e82e3187d5d97f32bb00686722acb9719287b70050f42fc9e17ef53eae6c8fc7628f1fcafbbb2180c4d9fd492e947f601a4e4b910aa2d13e435a5bfb21177c78b274bccc77c005fb10eaf1b16da5daff5a9fe5a51742743f89ceb79120c50654f603eefcf1391864bab9fbf2bb7ae1e6d98098858a733ee0ea633f806a7b8fc73f6cba05d2521834bb52cf33d74f5e46e020e1a0adb5a3c718b6a7b9cfc5fd3316842c66e451059ca1d12b70b9de8095bd2239e7f20bdf030bfa1dbccedfb376b5e14a80c996b0c3c6e0744eb7236c2cbaad88aa6113632e51e59a1e44e0acd386dbedefc7f5c5cb814efd4f23643a8b0dad202366af5a390da92b7fb753eb7f01a3ffa08c3ebd319a39795677e88448d987ec58760c7199727f5650fa8083f6e205173969a130d682c686da51df5831609627e2b56aeca86100e960532a0511754359d637aec54f2e8b267ef9ce7ad532736bcfb59d466d72b9c1afa0aadeec56251e7f5b21ccee71196eb9cb2a33ff1377aee3ebf9a120d225efd2345558cf9a85f7fccf6f1bf392f7934fe545991027cba679ab8645a4297cea930e91e452ee8f1c6055d908d6b2007a82cd0bb8a276f431a6710c3942c29b9d69d284194d10a3f4edd2c45ae06d8ae4cbfc80ada5c313c175f9f5d80a088f57efb08068bbcc8722150e9880257fa9d333a390c2eab289a1262e1c98e127a1881ef67d732e0590a51519548101949aedc03d94ddaae91b6c274327f175c579b193d567377ad1b62c611516d8f69238cf683a58393dd53eee3cab0d69196caec93c22a6e038cf75ec0a63f3e8de2eb58a6a679782ae79746c100801bcccb7d3c68f512c174bf49d6426eb391412060324356c1679d8a83c0fcf80105533bf83ec143d9b45d860624b3e16447c3c5b659057a3306e71ccb35f0b105bfd6d3c8f0b31414a9628be4b9f445c73e1c9d19d9fd243c1b2c3398fabcbf5baea6919e10a4972b8170282ec4acef6987ade9ac8f6b6d406b6ce948d0c52ded0508a27e9803fd0b92e2e893cad30aa5cc80fd4bbfb6a787783f05314ffe80db8bf040651d4672ae38fcafc788743b7659b3521133d1c00c10769c44bc0e6a823cd2e14b678d42a8a0dd7b7c4d06275fa71f275ef54384773b39b94ba562ba6939d67a5fd5b0b60f9741decaf123c74caa7ccd2051542ee07b9e24b7fc6fda14eb0884d2206ebb2ab0899b3cd118cb65187d736ffe73656fc42df3d37703747889d81e4a979a3eb8e2ff5f4e8a41208ea2f0812474295f8da8a9be01cc4d028acb234a4dd9f8815c8545b81c82c17b1b80b51b20cffc57a6f334299c9745459db308cc378580a6c98d140cfa5547acee47d23a7a162cc5ebde1c91115ddb589dcb9d3c8eb64e11349215f83b12ecadde125a2422042d528b4ae7523a6bb9298e9ab808d37588b7372a163451944e71138f8bde912bb2f996cddb364bd0446947f048d75933b59c1725ba84367ca267957178307c4fab78d9d7d0f5a71911d811884c4081168bdbec382ba5a17f67c0af199cf0fdb158b67243a4fc9946e3ee0bf9e29e1c30cc26f4c39af823f108f8b753d13a1210fd3f981c81074703cbe46b828ce7fa55947e858d308595bbf7e904d7956913d5a21ad1a408109b2015cde69e655578d0e1c2b5e45617ead4007f43d213f0238ce81eeaea82352670441c0f5fd9cd651e9de6f4727173b17c69bb56a5c2ccb4d476f3d7573fe6fa3ebcd42fbceae9451ea83ce8edef446472bc0f6cb4533aeccc6f2d4203f89f78103005a0fe1c9e778ede6f05faa7df18699a0a467ef82a1f10a40c519c76fc1e946ac49814b20db7312ba38a9341147a3100b3f14eb2a652f31496f793e1fc7ca34afb1e16b15de7a8e4ffb33ba3fbe45374c0b57b50bab7e3d723c0fed6f042ce02d6e5d2f175222795925134667bb5966db70733e3d4d8c1bd9913208b5902908f59c2f1aeeb1b9c1ff9f8033890a0002004259e0a1312047e22b5e90c7688c8ae44b211375917c18d6c99fbd83700ca0de0dc21338903db56aa8b244372ab57fd62dcc7c97715cf822e3610bc106f3e8b6f47022eac89fc6c7c09ff02a707ce0be65f743bb7c72b3bdb2976bd377dc24daafd4d0a2697f82cfd6083c2f1b7f90e2757e53bbe299e770f274504cf11d7f9b5584bc7466996453383934b8567a7ee3116aea20357a2ab4388932357e4e6c1594c7d1031d105ec5761e5e0645ef899d89843c6a16cd37a9d42346fc3c61587e528bc7794635c84923b08d6e1ebf44808a4ef01d2c290145217bda11a833e662fc7227d4c7fbbc011fc4185dfa6f12c0214a74931cedc3641dabe54342d034272babb953af9b84e871d83b0bf9ee2d1bee42be8d1c5abed52aedb8e26d8e1530c57a68e0f557bc34e6e8acdb03a60a56ce928902f3987c6cffbae6179074de21e73573669ed447021ed255c9111f5a2166a82e942ba555bffb4b68ce82991ce3ca353907ab4aa5da9ea37e1d96d1d852b402a5cd8590a346288a5fd06d3a1bededc1489f047163f2ef15e6662b3f18f6cad5bb5f7645080d2ce2dc37ed1cd40a5259955b7f00239f24257d07e098c36c83ce57e8e3eb1eac0a43900bc9b81611edf390035fce9b8373682167699db684dd79828a30f31d545e75b6a1b780602bd0910fe0d216fdc0e271630fd00b1a3e7383f8b3078ec87cfb8adc0ce23e7774c3ebcd37e5c2f1c8b2153f2c4c082df42bb0d6fc94f061d1bd95c489bd42865b65cdd7941c05da50731e593bf9075a0e14d92f5e5e7c3f5b34a2e06baf5126025439aabcb1eb0e5169af61d09cf7e4a8a5eb42ebcae47903f7271c178d7804b09f6a5e6280dd9eb6cfeb63ba169dcc8f87cca241af63095c5fe30b280bc2bab740b344437e67a2238d1e2b154ff7531be01ae9f5db3b651c6f415c85ff5cde5f485524db5c47bb6b69d6d40f3efdfb6ba96f092ae9465b400b6d29804c8a8725016a3f56888af66b35a80141b9d54fd573c3858d188691f50e64926d0703c07a03a518af3caf56af6be684c03d4108ae4b4110705e7f11782f2ffd27c7cba11f9604e03ebd79fb4363d03ab4e4318c3e400fe83efc298c61fc753773cac760e7654448ac6469a3b090d73e77088023e3a32b3dd060e8fdcf2a2dd9bffa9f608a00527e63f5fb9fa51d806ebbc9ce885f54fde1fa8a3a99fb6e28eb55ce3323c3a71333e4a70b2408573b90031ae1fb2995b657bef5b52bfa8c9a00d31338e991661433f250971189d7507f72e5c766caa49672bcc702fb713e98bbf72b4c32a5c265e23cfc21d8267594cd09d864b2fd7496d9f62dc950d7eb6513504938ce89f8eb7cc76725bbbc158bd25165390ca6a7842e04ef9bf49afc31a07e14c4d31e75d96f42095332db7e6555a3cdc7af7793469f7720b81068e6f19a791bcb8400d1559eca3d72d45b557659bc80cc7d5e0841f778ce1679291c51d1327fe05a42f045f652c46352ddfe9e9990fac2ce85fbd94511d55b034379b5248fc6490f5bacd3001f9b1853d64adec80bfd99ab794b413f24aed5a290578e6403704238d12bef717c6e60c723697e9e927ecadc63717c850b13265b9722c91a0470bdc8b30cebcb8541ef66ea910235279b946e4e8e5782dd69d4da31a767454aebc2267a3f0a17ede7e925f0b74241bf1266c657cce2d7a41a8010a204e9a4575c409a9e7925f508e1efcd695211fe99b92108b887fce51aa96763614a83a34b257fc01e6f44fa068bd601f12010f51a6f224bc78dc12ee6fe9bc7eb2dbf3c6bf520248851d3f64812bc87a2f5b0bf9cccc5569bb1932a30e74706961fc65ea95b5a124cfabc075c537c0a8707e066465d16543502244976a0b66e2c10eab1898b4d5387c8d2092eefd932b5f8f670a3ccf0886bb2be281e6a45fc3cd889f4e5140cad62c0581805593871ff39ff5681523b78595218476491c7016d886da2df5737e9b06c9cf2c654e5bf39b980128aee230dc5d823dc03e7b0736737211ab3561181bd161909cc1e9f8fd54434f1128a61e5860809e54301e064bb2aa25cf29fbaf03684f5c85150b362e7d0b8e6b4bb7612c94acb6525d8e82b433a72e17927ceaacc15d6cd143594d781f26077a8207dbfefa4b38cef0a0acb5c688e2298d304afe81ba853d325ca98888b00d19407ff7c7c5b9039f60a08dd6c9f25776026c44cbb8d165aa117b675088b84377a1b00e17394efc5a25e9cd15a03199b3fbfa660ad097ba6d817aa05fa588c4bbbbd420f1ac1f754458a57f763a4cb8435d987f940a3c32bae63bcab3c188c385b9fb2336730dd2c118fad368395508514cf2f9a9c6c9f90d4d9f26bcb729713312d824058d632fad4d7a46217475893ad36b4dbc370648b56dc66f3bc87255c5b97bc7bd9651ed7fe20452c13940cb28e3a09ca82611cdfedbadfe3bacea4b7b80b567cc434af370ef9d6935a1d031ad0a577fce91a6961fc1b8fb3eb54971b785e7103bbd63fd033abc6cc5bdceb7b5e07a8fdcd701c2678da4db5d1f98ae75f4d6d22ea05753bd30e3a5bb6a21d4d3d3ee247e2ecc694a5754113f76d16a8b71f2ed81bf9105d200745d2f45d1c9fd13309c03c0d5ed49a1581b3ce1a00cdfb62f01013101395680c80dc11af99bb18b8ccd2c199e442b8e61ccd491d8e934212dbd0a7230dbaa4e64fdf68ec08b6150dbecf0878002104d21cb763b8bf2d5c27ae4a19e233e3c9910683fb93535c475469cc2da0b84a908b190fb745962dfe0a99873db7e29a14ccda47007614d5eb76f8abe9baa4b58d15f0a69b5842529c00dc74fa17fe9bc4aaf286b7c4c17ed32d0ec0028e6c2489362460a2c2760807efca08dc3377d6952161e2234936b6282fb528db36af3164558ba4918336b2e7721869f754363ad30f5d9f96aded3d8c140232c574dc34f3bac69add4de59719efd96ac7ae7f6ad32656a047bdbe617d77fc463c3f908f40abe434fb705413a77426760deef4da3109571877e88d21bfdaa54d2993b62ef1b4589683c034bb36bb00185d033b341a5e214ec8701fa52246276ac0314031014dab49a62822cf867be5fb3e672b0325419b7b130d2ae0152fc58c061da0d374aa12d76eab798cbcf4b57b3f4840463f2a291ad278de9edd93b86b40416cb31cd2f7441e320faeda01f581efd2682e2f1a5657aa2fbfb7323e5b172c8fe5be22973010c5a395194d69588575c1098e31829e5c9c192767936e523e0296064b83a629dfc85ede87bca155b448461365114100840dbfacebebe5f5881e182cd210308b17fc44ed2dc9e0ef6942d27e811a2ef87333563aa2a2ed030b5ab1716559fbc609ec221f7ccd1d7420a5d99cc62964082ea94e0b8392846fd03f1ef024dd4e42c9408a193f4999098786fc7241f22c6f46bda1416ceff2692b5aba6528f737b41cccfe9361fdb049cbeb1ce60c0881c5c1c372f40d1631247279dc026e7a8a0e8e960a18e63894760b915605f1e4a8602488cac56c2c55a8bb2627f0e4e5f9a9aae2950642cbb7f405b03142d1c2ef35663d281196e8cbce6467212ccffc993ebebaba0252b75815fbe7c5309832a424bf25b3af59f69df0adfc033c17ea2394dc6bcf49471c1c8ff809d723d61ea4c1d1ffb073dba3d3476bd701928d97693a520419f1eca65d367f3c88a350c9ea1c3ca1ab07147eac71114ce5085531efa1b36f7c7514fbd672088a009a4d1f7d5e7a1536af60b1c20dfd67162c1e5a568c5100b51c99cdcddfcac7096600481ea0e1b1101c59211a682daa93da93d8eea41fb9ab63b0a68ec5a92321ea0cb13689b02d0d0eaf02b1ba654c7c67568f53b391e67bf59fb2f1ab8f01c7525d112d23b7daea535dd09a5969ea561587c3cecdcb15ee61d69617653441961ba6fea9d529f8a3af1b474424195edd725e300d78defd407a0216314e0f43dc7a4b82a2c9575681cac14039bd65acbd1d82a9ac543db3838e2a4ef89cc4a444ab29ed95c42bebb9cb2f355fa34ad76a750e68591680bff34166d057e19760939a42df567dea09f7b71e102f330c937dfc7a32e0d64eaa23b88f8964c292169a99a40874227c82449cfdd19886e94e41553c7050600f935dfde27849ce5a35bb18f46e1893a71948bf97598915ed6e629e892e1e177bdacb20bc1458484f67f2ece5c20c70e82f13cab4027032ac80dff8109f8e622fee7f3206982bc67374c86c5462ac2c1e8fc8ad6accee91d967cfed8f4dfecad723fd68d1fdf1f8067309027686257da4d7c06c8f9790c3601e8f9505a594d21411ab60dca64c914162aeae9b27e02235a35c99617e27211d4cdcc03782cb0f72fcc7c6f78273a332cdd28cae1b759eb572741a19b128cec14b2dbc2b05c1a24533ab2d3434f676027896ced677f9472956ab5383674f1215923cc5c6f94e8a24567569b27e89bb2d178109816a41429242ba0477dbd4f35963ef7ab7f93d17910238b77da3b7502f61bc6c1009cc790b1d4de989e182e7943ca22beb07da5034a3fe1cc3ffbb35634fc41a232e5f554d0888c6424d27014a4d90bd0cd4ebd666253b241d341475d35b4d90bc3bec1b4d059ca3722d836cb9546b0c24d3bd1acdc3692f367647136db9c2a3a4924c255a335a3294f2077a2bedbd90401a345e5b0b5fd38af30c994d84cebedaa5e53562ff4e4a46ce869a56c28e02dc70265b4bfb718a95ab2504e47f74bba88710f76d28188c4e84b60a368a8fc40a35fbd08de6ca38a6fa2ddf1be9c4957a861a6589bd89d146a3270aebb507582bce4d86c17795159812837cfcc509aedab0321b6710687df4ad73eec594806b0eaf3efddcd1418db1b8f1b0e73c61ccbdd857b536121c119885846c46164249cd144698111d07021753a685de3d87f4df0c3d34ae453fb7e8a55ecb120287eb5ff6a950b75d2560da46cd4c45fabe86a8caae18146b748cf6774578091cbe5d04905bb96060c16d2ab5a78cfdeccf2c1b4e1282067b45542b4a3cd9e9399c64b1bc9bc8625f533a00ab4e021829b112f3e3ffad01c0b41acf37e30449acc6d127c3abe17cb8b4cc5a4d061eb3631030fde58bcaf3b1a5e51ac5ca1dc581dfb3349b4e881b8faa3a39fa99945f9a189e18c35cd0d2f48ddadf935abc7c5047472e1cee12d39c6f431db9db80f33d2eb2fb4840e4727fa816a8e47dd8f1cb6dd5f1acae0b1c4a9f7bdd6bae047bd1600b713407a513e7f9baec9fede312a0e7fa757ae316b5971a70d4cc91b42193c31cf8878bc6a4258376a46c4719e431db6f4cf7b7ba294c4b75f23391ecb5e675b963c634792431a1d59c4fbc9c69869ebf193dcae52f0dc7bd77aaa19e160df3b9b7983199ee08838a77b4d531f4a4a634685b219cae40461420d6eb15b1e959ff8e9f7390698f6abe915dc823e9a08f558031a26fd40259db750c04ccfde4ee513b72776f37223d4c4ea8f0b222e007ce31b963eccb6d0ca548725578bad6b2a421532e17869823623f1d6834da0a8b5197a971588416306f982f8e6eb866c025f94a10c518ed74a4a7fe172c003319f957547b353593c29587582844d7122489f6ab4bd0384e69d004fe9ec4073a4e8479e343118dab80c8807f61044e6f82513def1a8070a88578154cbabfd6c58b9e7bf7a82b7e521dc5eea89ac6c1d5da20d8bdbf40f6614a975ffa780984ad8f60a3e18e1167f64f197efac1fbdac119c309a67255dc292d041a86a7985574bf31dd72f1ec9da2c97b5afc29e2ff6354f34e6c4dba7b498af5763923c06d67286a3e1b5849499bd609f4a73b03edef04ab2560995b07e640dfdbe34c02fcf0beb84beaa236db0158720841b3a4d8e6490c934eaa75f0599836a061d91acf3dce98b8e3d6943a8942e64c770351ba1fdd5dbeef8cdaaa391098f67307547cad27d9ccbe677bdf7879c9d826863e32e0bc4906cf9f0f33422cc6b02acf657cfa8b77a479539f780a8175a748ba8656a4bd1d2c3b8c9b749e6f7ddca617eade01c05a1766c236e3a22ae8693988ec8db7badfdd491e96f76bd121d99a8f5bd0cecf6e2a7937a7ccacbc3df26b805093633980a58f6b90cf3f5e14eeee214035e1baa89336c955","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
