<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0b8c181cf04c2b4dfa00dd1936f6f594609958ac150761c316c494c8f9dc3da79af77f85f1bdd190ff726b2ecca0a12dd342fb0f9fd9ab831cb21151a2da4da4714efa52ce897d56e4cbebb3563048ebf51b36d6c6c83ff57f6ca7862f1b68499b89b7db166c892396f5f81d4fda1aba732d6fd9bd5dae8c2de09eedb2c5d3ad5ce834b83da6fa89e5c57c75cf297b3b74e376d93da21e567a3cae37a17fc1130d99ccc2c4c107cfc68bc1b9356f085a2c457a9221451d435ef98c8a1cd129ab12ba8bffe3738ad712f1bbe8c2054e10ebceb7c0f9c2019b17c26682c3090cfb3a4a14bacc3b70edad7d07b9c75f720618a4acdcf469bda7139d5487e6b9811d7e569312fc516e2c98f45a31c17a83afe01be21eb34ab45e017c5b10828c068b69ed46df15064ec81dc40c01f8e7255a46c4b78fc5218f711e3f6fe3ccae634fec3833809692c108ff49d023cc5e3f34b823f6f4de3abd78963c904676d17b7d46fbc00c9ee530157cc5756e8600e387a4dce9e904aff6863cb3621d6bc65d0dcc571a7e9a5207a1bfa17b42ebd65d69a34cb7be801055f1ee0dd8e73547b56ec1d765e07374ca8c7ec1e6185703185dda76dbfbb94486dfe12e03b9405eee1fca1a428556a6fe4631272be5bea2710055c4ff1721a7bc80465f0e61262763a1b6677bd54ec0048e4370e48e62cfd19589cfc25017daf60d805735dde09f903719463a1e6a54e99ca7393c3e4786115996b8163585587afffe2bd728697bc60beeefdddc58d8adcda3a6815991d880ee1efdc70baddb2e4318ad1f5fea7ec01b366e281c3edcfebffb344dd97ef312a4c09f4c83595ab5cb2463e9d4c6755834f6d6d63e66ffe2856b4a3060fb8559530d416e2e54e503d3bce57300c6a1a2c46a7c0811104d52bfd656b7316c4802648832229fb9aef584bafa8331155b540305a14d22ef8b8c544ae5d12b25912b7abc35efc1eebb4400149ca5804863d38134c99c2ea18f0c68823ada8d56caaf8551e0247b6937286ea0daa0b2f3aa7a7cc39529d7d77fd02a2f2cb144d143354be70c3334ea01a8b31fb7b769fd5cd3a77759188d067f0f2ec4c0a44b2efc4c81df2a2da46b1574f5e5466b11d24cc43f97c3a71030cecd490bd1c7e1d19b59fa5ac8dbb2bb6dee500c3656a93617729b1ba6e85feb8890e2448435f3fa4879e1c51ed6fc862ab1781da33b559f83128c340627b07767cbc0fd4503ac5578c996411bfdc1542fc67ffdd667b697dec7d609378b4189ed074c4fb15804378ee2af300c3554a03270bc07885c9c5c6611e34fee780abeae775ad66a67a4dfd3d5b61f251cb0da84507d5b7c72844f5cd86477b9f9a156528344a923ac150a9ac0217f63a60e8193cb776712a7e9ca871b5f89bc5619732427dccbd11c7d05da9fc543450fce7f34c2020c0608db8e0617c56c3c4e0ccc78407ddd074f758eeb215d79992d4d018d4e840ceb2c9e0524a703c72dbc0019082bbe4d54e11a13538c2275f7361d702d584108ad63c378fad4e5d9206116e611f88cc2f879b09151059a76c50785bbd48bd2c2febbaa97005ffe6d148dba313f828e1a7d62f39b00470ee81e62090185f23b8464131430493fd575ef053b125df01ad7dc83df43d24d53d1610ccdefc268984694f8cfc5338b4a0af6b3abe4823713e4afbf76a3b760dd0032d9cc68f52aba81f1cb4b7a641a48d6bb49b45b9cee3d0ada23228e0cda673184e38a5701cdc708bb3ad90c28b04c2c8a2e9b704f3a4a4988fbda1b26e0d84d67a7a4e48be91ff51403c6e398894d12d76c88ef0322bfceaa43576e81039c205d6f74821bbb81ab793d2a2170de0966e415beefcd6aeb9e53cf6067318da1adc636770373fd5d762460e63c95f5e55ff47a498651f4cffef4785e49ec704cf7a6ac68366b648597889bb9783af916ef88562eeae014a2a17bee2f03c4c9564ea4967071b24d324c0c4571e30c6e169cdfc882ed32d33ac07f34ad5052d7078b39439a3b90815ad3fe489835123de8f663e34d93e2d429eb8f325375e01deccc986cb73a09afbf79fabe201dcbd4dbdc06babbb6aa6eb2182d3342c76d5e191531efd4858ce3b1d27165e1be8139aefda61bd205c8b4599ed2cda5b252c6df48a03d41a0e2c3f9af220c345d35d787db0e789e30ad52ab5f0d7d2381316d2bf65d3de682c59b3e9dfd2d5eac486bd8c3b3e384c42631f276b0836ee48fd3693a031b60e7c05b30277d4e13619820fae25982693fcad9e365b47d05c4e60c4fa568724262a3aae2abe46ba34eace0cb34aa9f7821d5b83c1c1f1b3ac322ce2663a45c0597de557f0444b2b4740d0f75ed0a228ac6b8370776890c4b61100daf9499a5b6dc25ffb0da0cf3eda6a43dcc43e2775b4d1a3a770aa9f7fd063619a6499eb4acc9cba24807e250b5a196a7da80e1ca1e5084f71dc9f4cdd213d4ef491e2f72518fac543f11ffd4bec7892825c8150c06ed513bf2d50b5eab465d76017b767ab8aac9a84aac4aa10be89e2cf1fef74f3469b1a4cb6fc1b76090b4a453521d995cfb26464ae9d829574830dc03ddd33c974cf1a45946d4e78c138c78a39da933bffb63cb7424323428eb821f63f8301bd6a96061d0e2fd8916e00b0c9f9a28488e8b961636de43394d7eaa4f536970cbe9af80f2eba4de40cb13d9528c83cf819eb87ba93ffb088612f5b4cc564d35f493c2c2998ff8d0ed1a97de15c00e8b70f806c140258534ca777a43449c8c70b876c175508b87fb534f06470d5de280287fa5345cdedf278574c974c1ac650abe594d489e3dcfae7fd8b025527a427f98e5b901e85888e0b7797042a44bc6df7cf243158405b8fd02e6d43481d5f11477c33cf9f37f27a037ff5192ca41d2ce3c93d7e2aae168060de4bc9e8abf861229fe17535e175ed7549b7ba2cf867ba7c67edd5391e3b5d801b84135c055771aaee357842ddcca8ad3a4b5ede0307ed789834716425f8ddf33726ffdcf3c17e5924b667e91636769f9442d0f556bcfc0fadd64663115987f07af11f6db30fc030551e2c5dda942fb90cadc6746fdab8472a40103ccda10113b2af7b578632a3b2fb0620186647b43721209dc0e245f97c76722b6bff04132e14cf5c539727840fa386b730f849027eb1cf7aab7d1e0cfc67c73a95f0afbd8d93a4dcb61bb5036e1e2e27999c4541ccbba1a2a8b043dcfebbb41e502d4fa41ebbfa29f0299c9f700776b40e834286ad7178985153056d676f419e07f42822b5087a994d3786a7275c729832dc81aa4cc1601bbb96f524e2d72f47845ca824f6402ddd103c8a8305f61b68ca2c132830449a195a3e842d4148d00121e5cabb9e63cce2f62468cae1dd5b7ef05722d827002ea08d9805bcb10465fc5969248ccb74587285acf0b82a3fe2f039210efcd88fa19eb19e71a69ca57e0ad6f4955602c2f19dc52d244a4faff8ae5db47771e1cb89857443bab31cfee085e5fe8af708a34c272256c1bf1ab615c61e98b1099e404f93785443a5bd92bbb931f0956096297291abaa106b30a2701aed95051692815229721ddb3ade7124c3a0598f0496e858cb76fc95136afd7b80176d550c02e61415404b1033d309e4f994ef1e77fced073abd85027b18b4a0a5ebe5a4c3db554dca8db4ec9b86045e93de1e92ee58e0bf43f34c00cd662f67c3117679372eb57bb4e373cbdc0b57f04b4c1321f9c0537ef7bfac1e3be871934fef99bfdc6b37603dcca431d3248ffa9adf4d1fcae4ce5ea0ac21f6dbd9e34b864846755fcbdcdce0395f69329b063c32cce0244b618c8fad7ff504e126f2c4d05660871543de935e2030d9293856300b6137f570b79fa0f6e119b934ba040f566d1f3ae0820855be08aeefcefdf7b0beb0db96ba5a88d8075b947cc47b8499994ce860263a79e693c0259347282a160901407e66c3bcc18c71befeb49699d632bb0fdb27e41ac0c17143a5f04f5376d3c345fb56a90c594e4654bb4e5a82167770a23d9a111198aeb3a5ed6116307fd267b0f1d7b39bc88c3da1eefed5c417e8d7cfd86ca4b8852a2a37422e534fc301c0eb434adfc59454d6512d11f3ebf168fa80be6208d6c440ec90d283406a7a534889d9e8be8d8a5d05adb8bd4731007afa40a02e901975ef3755870af2c008d9b82544492c820113f4cdc0e313ee2878c52fc1f426d56ad4892c71d4ab8734fd751f4ea4bf774f622320655b8a5eea1e4de5ef94fd144c75fa69fa198cac3d2d84f5dc3cacd01c67459cbc388e10eef777bb7e199d7a80c2e1aec897797cc7ca9f054487992335a9a516c1dcc2120b323d271e621d7419cd639bf91af3040bfc75ba1a2017962a7e05aa686033c2c8873e4684181adec85c2277ac2f02049277a262574f45cfd186ae9ef20c72c77e2de43ab0a884af643eb97c9240d3d98a5185ef9b48f067c38d3f2d469f8625d84982cf014888477474d8f8bde04061f4a2aa64efb9ea4e9ee5a879c9222361a155c9986c92531d65efd623611b99325ef3d8847cf566572b3719ae186e29aa12620af576be90d6fdd5cc68621f78709d50da5e62f12a74d00ad2086321ded6be78fe415a58509a35268e7e104b938206d8b7bfce7d8108b43b30a8d111a6df43045dd7061dd1b705ddc15bfae00849ada4679a9d8bbead1d046088e93c1d5e39dce7d63e26dc58d58c6d44006207bb484b9f5025747e9c10ac35cbc58cf10accab31247c44089464ba14db593573d94b92c6c2a12561fb36988cde87b52c2f1ffb231b5289b93e11e769266d4a447abc9fef40e35f5639aaf045f2ab324db7fed0eaba23082888faef719dfe1867df080ff959e77d670171fca18d44cc7363c32059ccd48666ceb0df2b28bf4e59b4936504e5fc3a551eebf65f65f4d3ed96667734aad97ea456617ab495d1d855d6d2fae48d4b8704a0a098d85fe9b1369d1cf52de42f77f817ef68b0e96b692d103afd1d3a1c1e1de3f0ec807d457e3524024c7c3f065aea5c4b316a9bb702d40f37ee884ab070231736e203802f1b34e2fa9db12c757d7b74448fa9843130faa41374c848dd4da585795c7fe043cc7961a70e68c39a661b089ea93e56925d0ee57f3e174efaf885dcc67b25aade6459ba84760dc7371699eb0d89389a8d0baf9301a7f5619558214be0b3431e4d4b46c7beb89d16405406e6017e8d6478873633328d212ebd90256d82507be1bb5e8120fbf8bc2d48b1103afdfaf6e04c8993dc0a3803ae595e855cd7526cb5af64ff16482d696334b9ceb6494a0609aab4270d4cea670a2b28a86b6751cc705f28c9ae59045343aab960cab50384924cc30a6d0b29144711299e67e3b03b12e1454b84ba331fdd10248dde023b71bba8168f925f15411ff5fd5d6e29f04a4f92925e712302b67684561c51c093a5c62b3dd9db9e1ac62b42db662b54d7f2b4705158b416dc3593fa54502d54af1e7e48f12bb1aedba25b1266f57baf779f35171e4367bc5f206965c3b00ebea376047dd114855c4e1cb9353bb3a6bbb71f124a25c288eab51ad5c320cede34d4ec7aa542994c3102400436c6f4a2876640667b5d0154429e6b52b24ece9c66b5942e587fb8515de54bf2caac4dd59d9d1b1286fa00cd5c54721e60b52d8af173197678a6b5a11f69b1ea95302a1865ba91e9a019ef34c24a7e8b6e19dc4be800c3f4c52e11ef4b2b120a2c31281edbcfdd1a130bde8f85387b6c3115a42a7dc57560f3c35cbc2a43f6870de55de60f20847383c8796929b7a8afeb7974ce27f7f69726e14b04d1c89e190abd5a3a7a87e6b50c62841da8dfc708acf0cf6e97c66555bf93ac729401ffcadae6f0a281e8f7d98f37a86a704cd86a93227ddd9d6b92bea89f2fe4756bf27bb13d69dccace1c3ad80fd535a97814cebea36d50e8ffddc79ffb9e8d1fe5b042cf52d5b2ebf789efac646311ed3ec4399b348607346b392dbbbbc4db5712a1f1f15f34505dccebc6f96a1f6bf0ab8b7c9ad5b84e223faee3905293b63810f16b892a9a91514e0e2c00aab5eaf67fe37e58129a6374d8186ddc6094db5e427c4742b810983d7033fb9de3526f14408bbf0d83e3c8b30204c3f1a67fb2740a996f13561a74ac0d4e9803699d86fccd607de7176a0555bf101ad0c79f3eea6938bc2f0ffc1c42d1b4047b50c4730b268f479e9e1de7a937dae0fa133ac993c7b621bf98b1880ee4225da9669ef7d9854f8195787de3316ec7d4dc2d36c8c191a6d3c5d2e08824909ad0d31beba10f4abfda2612de426313f32c3f93ee9cfcddbbbdd7df0edcd2a017b8250d2b9d0de52299a443b17c6a95248a259bc17d45c8953b62725b8952beced0c0d909b2fa91ab702e48378a303778224efa53ffc77f56258178ea3a5fd74147e4d6982ba98ebedfd1b049a0689dfc9fac55c83b696d64ef1294164d17bbf2876ea3d8080756d1c19f834ce46add4341e45732269cde1c0807f4f6112718c65d1c8f27a6c56a3122072d33d7fb80272b9fb5948d16ae665480ce8cc7aff1585d884f09d5ae0e2079daf92a1558665962dfc333f675247db3cb6089500185c460a73d655d7863f86647c92113f54aea407a76dc09ad7610bd8166937a3f375fe90d4d8ed53e077add2cf13bcd99e555add0ed29ff1b93d215067328a6a8dbc4ce47c6edd609c911f9e333d2d5bab56e510be85c595f525434164648c542f747bf05f3f7d1ea03bf94d7246a42b3a7f532afa09b627943ebc2aaf1076a1553389bcf34f277e3e950a75b4b17ad2073aec6b56c9e8fa847dda22190f1fd97ec13259e8cf6cb2a39a1633b4930e6e9042a108eaa3686aa283e32d130419daff97fc2cb36b1496c1317a227c45abb4cbf51558a0f01bfbe64db112ce6ddc8a0f31d9625ef95143d8bd530c586dad74fd450ffa2b801574ae35f4e94af08dd251745d74e1df9dab2454fa24672a6e37cb19ae74aad24982768fa62de2f44bf32aa4790a41ba1a4c397b827bc367d9989bb149603b4cf0ed30a747305286f487cb48940d88259f39a2ad804cd63c7093aff6001d2a267224b8fda1ae0cc8860235d3f33e25e974b3ed948e368d924d6377c1f4c1e4008aa28d29bb7271ca07d6ddddc923c43e657ac4b81420cee0f170345572e443223195a113ac22aa56013554a8c0ada301d0e52a8ddf66116676d96551e17f68bd643ab52f496898551c49020bf538989c60b84913cf88e6b044fce3b0599e0a8b8429e3359358ef051a7005b09531f4d48170f194d6a07698bddd3b51fece78c6b7743ad3c9543500d95b69cec2bfd4d35638061810a98e12d77d8bb9e1e3c7226c596ae699e76862ac5a52daf42f18ba523efd3d51ebc0116588736f3ad0318076338be0c226938389a9a9fb5ff9d55e20a70b5a5a98210b06b9cf6deb3376f4fd35ceafab837204e85fd2b0df3a8e97f3f3cc83a8a2c9113831236f691f6cf27f85458c93cb6fb5bf8e21690c7c0930550d8b65fa9b8a3b4ce5f181fb409342d8d037367726086404e85ee0e7e0415a1fd7fcf2b655bf3349d3f9df8a20032ec89fa0b55a331fa9d4edef263690c5ffc860252b9b00a929e83cd8816e4138443b0693116b285791405d964be58aa266836eff42d1c8e735975428e60dc4dadf13d806d3bb9ffba255223fe056ece0d8dd953487a726dcb283885e59b87780ad2ee392132d6b49bbed69f35feb5a5ed50fa5c6cc19910915bfb201f201c51376d026cd96fd134d4b982ce24fdb3b9ee5b042e3a3e89817f437fe008637329c764e22e5401bccf5527469f41ef378959ec96354022fe66aa001acdecacbd78f13043bccd29630c5f3a2fa2cb8bbf38f880d045c1dc3d488b9868a663a68ddcff5b54fa39e93fd481b384220e8445d2722828e59478978c31fad241e419fdf46ff8e3d397f9250687fa89507be483c871bb7b742a8b80139daf7b5cc9ec3c1388cb72ae67ac09b958225feddcf434a09a623f2281bf5f24ea4df10015f5e682e5ffd99c3094983b351df55683ecc34ad1ab35d5228d93dd1cd16ebcd27c43b8a99e5757537dd95dffffbfb88b7db72f01fb683d46bdc5f5840807dc816e05879a55cb497e5790c906ee9cd240420bc725e9e86bbde25c4ce2302fdf545beeb16088ec57f968edfd74a7a267ebe4eb3b4c46fc31303c16a07edd77f322c118b3c46f72adf2715b38bbdddac97439f70bf37e02335abb25896d89d8d1fcacc20365356c1c3342145e17a9ea61dc4b977dac655e86ec08b152f677e509396b0bab69c3a29d148668a040226f6b6abb471f15d8e10a1ceeb1d23617ee8424f7f32bbd5db89ba847ba6989a1670e7a900a24baad7f6085acefd836d63cb401ba1d9f2fbfd9bcad5fc48a65a42389760d2b69a18d03bc761220936189946d16b89c0931ac90152d004b5004e89a0743bf352a08e2a25e26a0e33fa6f4ae1d938041c6e45391d8c9d171cff04d567c7dea7c196d6bc95c26757d1780c6e89eda0a895ddcc3f51a3cf27fa55c5d1b2a313862ca556e802dbd186944091aa2f0e8d158ce3343e5d207cf6dba32a8f5f1d3df3036bde61cb7729e585b23894837cab68dd7a73003326ebddb88c9ba79e8ddaf2eb532e0e4bc1712f6553403a1419556efd5c4e4dd428b5d19d3aaa7007509392afc0ad7fa57a25a12b5bfa07debc319629a6341407be422805d64a5d888d9da4f755b583c191081578848702a09941d55aa42829972568fd5f5e28ce8a1a2cb18c7952acdf30e64ed33e3694c7a6a6269b3a1a01931cbcdd8505990ef20ba63c0783ca9b04d133062c301022f2f41e160226dca9387ffbb6285c6b9b59faed9c3c6ef9535d9c9b3b75bc14124ef5ebd5cc64c76277087485ea2fb6a67f6f116cd336873152cdc311a37408825e37c4b2b9876a72121711430088d5849fd2bb892cf969e985eb0b95c78196a26caef3c11da0eeafb4426d5166e0c930356cfd4b115d25e30c8c7be30d4a2df2f17639dd3c7118747c20ab286b763b8a009ef2e7efc4f6427c9eca9968bbee3e2522b7afb113273dc206eef8549f58a96ceea9e099a38c814ed88e22530f8491b862c19040216a8f5ad0e3e416c97314785fd758de7c5cd9b614e2eb8c119897a7bfd8f85977ed30a3f353c2b851c72db8e729a176663773bbbdce9cb3ab969c361c7d4aa8a475c4e5661bc70b9724ad9bc3026a924b90f32233260ec3e5047a2c9e67d94984f5e4103bcff94b2c69e4c416550059a098bdd79cbf108cff5d5d08b4c1ede56dd73db969413ca0f33383910260e2373a87b714d4bc2ddcb1f3423c7fc4d4f491de6c0899e5fe0d2138d0e291baac92138509ce5ac17107157450e1ea8887ab29ae043bcc63aec577a425aa4295341bb7ddaa2d16a7a26d32979af9122aeafe9aeff0c4d66586ea738f3796b98ffcd13a2d89899f1a494a8f0584dae82bbc1067193e474e6f5e32d9d7aebdff3ff04ebffe581943f8ff5bb7779987518fa6394f579b3a8b28e78e6a91fbaaf7279648642a31440e22f4631170241855f959ce19017b24fa2ca2d41a5d89d99b41792fb76335efbba8d659c3d5a96f327f8334af6108bdeebbf58f16d0145897ef9f1ab90892a3b3918a279f946b3b1169d5ed130634cac4d4ca1d700188379e9e4fa4aab0648b6d8f6085ea0338560c37f5e9234667369789264b4999d806838223d994f4446f855fc1a5d52f17bf94a711b9da0ae9f5d47cfbdeeced661337b8e238f91562391693db45ca1f73dacca0bd6754f4f794038206d8866cfcb2bc8f722c497a1e1036ca3ab2116761cee6d310b6e1294a03368920e9543ccf967dfb9e29b1b9d2e73ba17181b2179e36642fcf391a073efabdf1e810212d11e65477646d69c401d9e6d80f095ea15d57b04d42745f54329116f740fcffc6a2c4a988a22dd8cfaf19c32812f9ff570f377ebca8888f769217558d215665ebf2c3e629187b723bf9c5d86075740b1b0f28cc55ab31eac15e1aea90dd98795fdcdcd946224a98a380bd1b1ea969b67f920832627372543892fa275f26e6624c2e56d14c41e7136ab3ae44b65da4db1b1462bf06a145d1130dda4c7213ed237afd7e439b129fd53b5e3de74334988db6f9e0bdbf01b0d3174261fba135e3d71153aa99251e5d11a57489c3d56a39243348a70e2cacf11caf9c7e439b6c0291b6170a9766ef8057899ea66aa7f1ffbd8ea3e1b64e83428f42be20eec9467770ccb01afcce2339209130873e30c01ef58d8d019cd3bd17de6f685311d8746079b72196f87b7739bde3d4d42db68a204a7807ad5edaec1d2652f57cd872bdc3c5ca0513c2d002ecd892a522ca334becba736f35c03421642906d3aa7f306953533321c9e211dd6fc4d65c2828f3dd92be39bbeb539d1e72bd4fd8aec485c1d16cded936a9f8055c7f339305e55966b5317be57e18c7760e0aec4ad25f515573daf75bf5cadeec8030b88dda16c5050b0b14d3c1fdbd5821c55d6ba0fcf23d0f5079ac2be6bf33d5db227241b00181225f4bf88b7281240c12486bcb680e925563a150dd217efce1f806616f1d48e554a082e7d557eb65e99ce8bb0f6a0289005c716cea096460b58935e0e1251a965e26641a582cb26797f26d259b5291bcd209af50c082e359cd28ef1ce6d6db46f19de96821246e289309653f0a979246e20bdde560b7b60fd4c952ec19d5463b53d0bb7b5aa69950dda7c0df49c239817530a4526e72015bc9640ce4d2eba6638b9939ce724e8a582119d9a7c1fe84aef4d22251027d1d9df737bfd1a0f28667224cff002bb4e07c79601075eec17a3c78894db8d668327e0c894bc676d03def6f57a425c86c6e18fabcd3a43a7bb7818231c7f05d6fe9362fb45a319c25441c9a818b70d7c719c651d6ec08869d92464adc801ea01320b1b3ef7c808e1c9624f1c55f16c26af9c867f69631ff15f66d78b6ddf8a6d6fed2cb0eb0f8b076e3bfea914546732e92c0e54253023f6816d5a654e15c3cd6aaf2d5c8bd49e847ad6e76b9b66969a466a4767e1357330eab557d1832cee8803ed4cfcb0e17bdcf88545b92a123af6a18d9f87be28df3ce187d774f7af4fc8195205d16f24df8df4caf602952ada5419213d519bc1779934887ec9bc65ad4aa7ebf66a3abe4d15c9dc31f2d711c26db8b708cff9448148cbb4c97bec895b510768653a34734bcfb8b747ab49dff5f497c15ebb9947267386595ea77c09b34bb9e4339b67e9d65bd307cd6deb715a71daf817f0f6d00b0e0200952dfd0aa0e7930d83c2b50ddf05500414a25e8b4d4aa35dbb214303268c193fb0c8e60e75c27e12cd96689600a0e30a01f0ef7209b9b6626d17a62c440daddee592238ef4d7c2937a5d68cb08189fe7ba600cc4d85f923aa45d3c11773057bf3944da99fa065f1dfe104a5cdeefd8363551b24b815847f14eb68ed4ff5d358912c646f6d7e5fae642503baf353d5021a385e5e96f1da0be4b8e7d4425da082f5b8faff0ac2a4544f6dbfc1da54787e58ef355f1f07e4ec50f4f809a23a9a290327a9bd2ae7e837de6b9ceaa6bd69940ddd18475b39943c16fca4158f1ba397f46719cbe9681e138aebd78a057e0fd529af3378c70977a80cc33dd4c8be2204ac21c14277b8fd81996fa3c48a91a9d02dd596c8469bb85dda264786170be5ad88259f612adb9b3f55b99416170db1f0c8c6ae35773398e2452a07311727aa2e39589ae94af56b65c3c15f0a9f3141b6a8f3a50ab5f03f9d127a462825d4cea5e9eafaeba236d837947a37d9698ff4c77cba502643e7f21c2f15cfdaa2047de0615a025da20c5c528efec4a212dcd31cee6ece5d24e98d7591507ac86f8a1ca3fb77c9e692e1a384467b38c62e9a6fb9b903ec442e5ac783621504dba5c6d6ae345307cce5fd98e7d5e8d69017ef1ddb2366c0c8a3196ba8b9dfa8071d5076e81c6ee04d5d7a4e41905d88643ffffcca01f47d39cc44b3e063fa0761e14bfda58a79e1a49696ea3e752b96fd9296d2ec56c77109b404106c8fc63397452d3dcdda197f559aefe2234bbcf5078e188292b05e4f80e824a8f415a7a2105e6af77f266e16fd0bb1dd0b594ce132b2f00207e1ddb4a15a11e3ab6b130f899cc570e46eebab04401e2497776e9f1c444d678a818a5069ea805e4151b5adf8a5eb505b91a179db577f51cf9540d10689f0637b3bf0445f6d9120bd5f9c0aa47c5a03ddca2fdc64c53f9509304bf1265ac6e200d8baab1110889b89fffd45f164a9ac84c5751a06070e8115745ddd84b9b817b78d3eeeaa554f342333be22d01d83f061f59381ef896c61a547c15ec80a875fe498d6928076de725f8f7b51ed47874ff03771901a436d73ee2ad24cbfd949836d1959c8090b64e6c04568c0f303237af058ba0f1bb3c74e4b52156d83cef5da458d573b3de244745730d921d0438c65d49199c695965c0186c375f1b51c2b600a6ae95ba2daa7786345c15783588b1ff8fb01b46d4e30cae2d2d1280ed01f692eef3faedf1a73c972c2c98e0dd67bf4249876b90dd2f35f5d06e4cd5c9da8026c39529e877e34993421c6572a9f603af7188dd17583abe752d4a852087cd24e6331422ea3a03d8344d9351991d9975b822d75f69410b3f7d2eebc3ec695a996f09f9c78f3a12b3e1ea6231ec2181f8d833df09973b4f30be8aa986cf3fa2388bac15b83d685fc0ca3ffe35d3c7e714325066e7e67727cc85a13b97e11a978976cca706acef6393c6fe0eb852395a269abedc75f05170d55c5effd485479cf4f25cd3f5d0a5b89ba9fda67186a52eee04dbf488e450c4f6bcac01bd18756ffaf8a485609b4a831d981c6b6ce9b0d53e733b9837abed7a3f4be304d6319be3fed9bf320376b4e3bb075a52b02c7610524089d280fa722fa45ab1761e9b6630ce60062989884fae213bdd8fe31eb814a28fbb7de40ca53ae1ba1d469522e38e25bcfb4d829f14443c23284d5bba03260a3ab158af8df46da728ba25d761624be21501bc9ff4ec67312811374b0a5d6194a0cf503b6e50aa93473475a7217e09104c6d6f7304ccbc568bcdf200cfb744f2f9a31ea02f91e4e8136610d671e5b36909a0724569f3114e855dc208b8ef154b7c6016a55d6e5aee23145f8085f413537b9dbffbc8342d5fe803c5941d73cd0adce29829aaf3b7cbc5af67b60e85d65a3d80509e03fa4b49d2fc2776e8b0f84358d0c5ae9bad5c1aeb15c62ea9539e40bd7e35e073c2fae3eb3c1371c5b8f2499d608f2af15759caf22746337b7bd093c31db4e79bab99b0995cd39a5db8250d03c8ece493119e0ad848ca611dd0b2f4f6dbe4856ab852718a676ce6a78e966116c78d6c7a0f7dbbac058844c2bf8f32fe90ddfc3208d1c6e9236169bc0ebd2041af848f96cd857f2dc43d76357e09a9b0db4300c79489900d17419e0132a4dc58d53355891c5d8e390e516e6f7c9c98697c4d83343775284e77feb80b6cd8d87a9064fa835d9442232da31f8e20008580b31a13d5316b7657c2cbe0d10e0caaf7ee9f6b201da68b2c6660e44ea41d2b19b0aae0aa22db2a71b76a959c167bb82da0f548462ffdf93a23af01a25d7224025bf0fef2bdf4567d15c688197f5b3f0ad7baf1e5b57f77ef6e1dbcd877ae51840601deaeb32720786667089dd65888b8c8736346315e9f0bc68e5321adb962ef4954319571a9982d42166b3c52ef5676a163a9d7fe7d4d9818fdcd639c41100efb2f8bc64ab27a14365fe483dd5c4860a813a21f9969c6543650686f148eef4c5e2a2e95375999f1b6783ae654dc2e012db30e9a58736346ef20fc8065e58c33bb94047d8ee8bf48f7d08290aa1d925432cb436dc810ead51b2585003466847c589ee9ff4bc301b9d69c800657fbb4958c667dc3560d4baabce6881bfef085a84b7eb327ffe82fa266964cf1e4c5815e7c126bfe4302f9334f4fd3cb9f6c660a6d6268e9ab378dee92736c84fef1fddb11b1dd5d89ee9b9ad18dde7017704e3e07814241d8a933b94a3f0f025dae9ab715efaeae22ad063dff46de5f5732207fb31ebdba37a236d509893d2e41e7fff27d9d7c88517f4bb0f1cf53846ffae1b6dbaa90cbe438590d5bf58a72dca82e1300be11505555474d3a6eae9ebd83410ee9dd86dadd85b4284ff2e025c999918ed0c086aa5df052799096a77140618c07cb54e2d7c9a572cb5903d70c1ed6a11c54140fda63f6c2193afc65da9c1f1a857c50441b4191a78a29af2b707337b0bc18bbd05718b9e884698f73d8ff4669161ff664a92fc7a74ae1fe5736a35b923fdead76e1775cebbcec321a45308dbf2b44f65c62b3f5fff9fe7744a3d34394f0bc37585ea0fcdb1c95585134e38c373c55bb42d0dbd8d10e20cab4de499f30327356d58952c65ea2a9dde2aad6c751f99f272712c2a18372900957b1d384944f2fda5caa00d7b3f447a86bed6b03858706b65eceae1344d2de76b5130468ac04ec778faf34a6ba0c1fba1fdcf4f820d6a22837322ac1d96b8c3f601013c6d9c253207a504f240376d8b1aea30596a3f0fb9095b297122e2af5c2c9d1f5aaee106dfb985858c2cf2d0b59568a39d12a8160c3b8ef88897400eb8cea56d4c31cec5f3772d688fc9bfca20c1ab547ac9423559fe5a370037a77e7851728115b51b6d33e53be1629ef0f8867db168ce7915d9b5f3516481405fc86576e4b045ae547447ea61d406ab31459c93ff1807e1271b5796ed0a20579c83054d53b13a312e10e30e6562afc22f09570b9f899ffc62afefced096ccbe9079549b8495e02ae9cf7ff29bd523918476dc3cf72b47a4cb7d1277c9441af14df60c76b29139818fc37dc18e6254a20680bef4ecf9f8809b21079fe431d8c32ad9e83565755aa8fabfedd0a321d17c6844ef968bb7d83e916ed97b201f797e2ffcc2f1ecd3c985c2ea7b79c6d874094674b82a9f6b0088b678afbb204e8da363ca1dcd58fce9822e1247b0cdc875c170d1e642be791de9791120408392073e65623dea9b620761069df732f913f363928e3f2e9b2945cfae8a142822a0f60cb989913c06c19206ff0ca7234f919e5dcd5cfd628aa5bdae6314daceb57e788123b643d92772d8722212b62ed83c6581f3303f7d3a0485f74e4be31b78eb179c338a589fb96b4aae8d7f95b19c7c3246e285e1be31c8bb3abc036b3559d7d7d3bb41a5281c1639bd7325cd7732e86ca7b88cd8b4075ca0b66a3c38077deb0f4ad9e38ea0339a346ec6e2c3d3d000b26cf854936ddb3111e0e8c62d5a684095cd1ddedd175cb4f7ac2a101059c5d72bbfde724eb0cca936987076a092074f7a8ac440af13920ed525b1c4d39876995bfc3cda67e21d8167a8acd6f262369c95b8f9241f9749e285d39beec7cec33851aff0b30dc6042757d2916cfc5f5976a20119e5988d7a64d4c7bc61cf5d02a6b23a893586c6f3c257262a3eae91f892b30fa1777afc02a3554e807b2d150f6042882323a5f1a389bb8234a9598bd04e2662cf0ae34b252b85adf4529c3b2af04583376257434cacd9fe6a34e578e0cfdbc7b29a76bee8b0dd2e7086b37a147589dca7ab3d300e665c4a90a5d75b0ed17f97ef0702f1a779c31bbbcf93dcfba8481658dcc01cf3c2960cdabde8acb0ffc52710d56c2cc8242048bc4584b923e8096c0db11ad9183c762560cda81cace2e59e009ed0b6f240eb27718fa0e289a0f46496e535f88011b66d5b11f7e1bf903f3ce9dc48e3737eba0f79ffb2a35f514b4d6ae4fd0026ab084330300d6dee4eeb2a0604c81b1feaa025c1d43f943c9fa90e05f78e321f9fede0b7e4d0c104cceb71d4fa30aa27c7951bba37e2f4ebe32cb48e89a766689fa819731d0501bc7dcd4e0a43a479d86d0a1b3651d37fdacc4147d9a584f78f2b149a4d82ae2dbf1e4d9041a9f996a5d2cd421080b9cfddfb29ef57ffb62315d4d62ff97999fae547ac4e3abe3bb1b417eac37d5b1ad7da4c804fea5d52626206cf2661653f6834c0a3729264498c70db28bf93d5d1b77a371b92c27d7f02c38abae0dc39d9be1e38d9cdc7b2d024b3532dd5e1092707d83d956e5ddce4a74e7f9f80153539eea09e484154bd368e6a7fdcda98f5863d1235d3eb03513cf428eee6bc0eef27c874a329672b6d26bc260534aa2534d0a17256deb7ef6f9317e6ed16af04c14f6ac9ddea26ce95a256bad249bb7104f1f2e14d6cdf93e83067dfb02e15aafc8e724be8fe83f95545f7567ade53f22ebee9d05482d41fafb76d9039dcffb6211e7df092fa49d66513cdd80a053d75df8eb1b851d5f77c9d90c5842e0e247ea6cf39aa4dabf5e5c26d85eb35d63effc08d5db511f9d8412da4025301206c068a69f6c2b28761c916825291a4c3a875e07bb3dac7fcf6892feaf99f0d151b739a655f54e1e6cfed91c170839816463c92c40737debfaa7058efed92eb5f0664ee3c7108daa1263310bb76f6b30cedfdc3c9f41246da2e56de9ccdbd9c5dc3d104d6a272ae70d224868271b8aa18994bd53530ce27849eeb12982f0e7ff3cf90712747512471b8d2d75cc311dcc88577887f3db474b1ea0fd2dbb00a3fc8fbf1a4d204a8c96d30353d754b05a945c2bf4502ed67b5eaed178cf61e8f8f1cfbbd3eef358809208b793dd06d36c4f839b0075ed3ea35deafa89b2c475d87c18a50ca3c75d26ea4f7f5851752cdacfe07dda186f341fc8ca865d7d2fe48046b9a9ef12536f2506332c362c755dea2605333015e5c908ec691a0b9ef6768895346d0d2ff0e0532717f764fda8aeaf5250a726c9b612d97b3f8c93c69687dd18fef162df3d10cd1341a44703c5552d981325e4fa30772b63d6c59c903102be0f18d09eb3f44cd09b78ac686346b7e24fd340c4a9fb68fbb0785df8df983aa2a058d67b3d02ef2c037b507b48af88ea6e18724c45c257270f5c328f7affc3002ced34892ff67ab199a6806bd2fa07e0daa5fc8a8937381643a1c3f4ed71703bea83f51e14382f698b454308e7e4a6a9597c982711ad41e49147b828ec090a261e0942fd5a6fa90f901d14ef0e2a56207b049b1556c71a7672cd95718084143d85c3c798aeaf695f777a5c206d54f1b0227a6137baf5f0d3a3d810dd5578e130cb289a140351081a86e76d913b00790d68eb38d5e8df73d4d991f0c297c13e6b46d3d603eeee8396f0a33a69a3be05c608faeb960c6c0094e9f46719ce16b097e726f5238e445af384c6416609f6d256c832ce2389214ae98cfe483bc4814afdd9fe794956af9cb209caa710ecc2da408262d88a0e4a2daa1578d0020e78961770087558cf8d19ee39bd2f973eab8660ff9cdd406f75af073c1ad7fa37d8bd4778f8a9170d5d90bd15a079a7d960e59ef2a1f6170e9b5c5d819a0b6767987168910fc3de742b253cfc49bfa27c2261fa396b0db52de9dfd0988df889fe2f7633e0b956a564d289a94833771c8e6d9b22db4e7c2881ffdc8db861a5f46236d540be4b3677826d4340648b999e7e361fdd8582e3ac32cacb9d5bc0354e3f307b5f6e8aa39e1c7a96a4e91d26c2f28e53e767b97882535ab0358f71be3c05001be67d8993659b11716375d2c5d33961330af210f83250f94fc9916c6ebbd66369c2869d7e8b56a5e9e59aab16484765162b9bd59bceb652d3bbc5c1355656035a676570077e3b605c7004f96fb7f3cb5449d213a04880be6057912f0df680889e851e355d6cb4d14eca59b50dfd24f857482d952a9ad6785e212c10ba95eba206d3460c16c7f63bc2f9796bcc18ab4b6821679553b9e81a348d28279f4107731a737051662f555f308930c53df9cf52070c043dacc07633ba8cb9f650871965e062a5683a60598ce9906e3b8596b7babfa52cb4f9a29fae784fffdb28faefd39ffd1e84d31e7561ffb537d213529df6723d542c4c645f10d44759951b0e2a714f1134c0d55685fc1dd0d528dc09476282cef8eeaf91d95ebfe807d51d7a333988e5c8dc06c39c4dad9c1f706cd11591","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
