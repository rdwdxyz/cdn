<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f61eec76cd4c96c86c3d552fc1551348471f7c9d48fd7a5d385fcac70a49bf88867d492111c76aa84affab26f731c2d031c146d1c91bd50f9ccf8539f6a1218e4c89edf5c6f0f637429a9c390f6fdf1866dad23fe1b245348aab5161fec1850b2a77bfd7d82295d1bf69a7d33ffaea2c633706bb83b67f9620a54be5d54892f7731c1f1339905bdfe23ffc90be53f3b41ac2a8b60829f3b7c08df058ab4247d122422bbc44870a1fce9afceee9b4f96e07434a5e67330fe436c13dfadab8c6558d1e36691ece2e545e6deec7f341d506e2d38ff0da1e07dc259c63672741d15c75d0e3b736a7a9ad857b04b8d0d4b644492c3cb23398df54a69ac1eb06a8018d62e03a79519e59349975b229129597cac3c914ef11166a3445404cc6b9beaf98476719a5770ca760de81aab982a1a3c3824cc6b4ea2dcdee7360c73413f5dba4e4eba88eeddd23659a89642e9ecdd01b3db4bf04b5e980648a43972a47c74eebe04bbdf0f1a34cd4d8c4eb492e51bab0769e18538d40ab9341e99a79132835d7e36b5c3ef9d30c766750ba1ea2325e5d64e49f43fd530313cc487b41e09f191ea689560bd7bbf6fd8d2a729740d6b60ee2c181a46ac572c2100ef6205985e7316cd0e2ad2466f7385dfccb54db83ed0997b70ff6e7105894bc6adb8a60dcf83f4f9459cb3098cd65dd3a8f3937b59326191ce77bfee176f08a27fad68e2835f215191c50d43d6994a7e617c0e855214817e8990ef6cff2c39b52ab1e0ecb14aa2edaa5982ed578236a3ed3a8ca34853dc3467d0b70237d5f349d426558525d15c1004ae0b8d9e543118022723ab87134d1b5bb1dbdfef3e16e5fc9d5d44a54458c85ecb965071d9571535097a2e0d0014dfdae2a4ac90e6605dd01bd435ec97834a97e283246965b95941110837bdc4d9ea687f656bf99cf8fc12447f2ad9767ec38dad1c1dbe3122934d6dfb8f976f8a088b7fb2eb9d55f222b60fa8e0a7573f0875828022331def5dcccda0cba890c727c0e7029973f46c67ec51e4551dc8202b989f6462b281a90eb6dea25416bd206f9c0ae776a26de1582758fa0ddfc03bc5a4a158a2aa006e4de6b8296a3ee8e09dac70ea8800a66b488cdd86eae3ffae987f1a96762781c3077b620b730c20c3a7aff68b08fa123cb61aab5611d1c94f474d35fe717fc7744175918fe692ffbb7ca0c7ae73b69cb512057d231ab33e30d764b1adfa7eecb889c2eb6b01e3b53c24c1da952c9169565efd8dce9e479dd36751752a77e9cbae02b95d544c272aec4c1df43d15774d8b9616051fdd91bcd7b99b8d09b922f98f9fead812ef53847123b100216f89527b391978e80cba7bf4a67377d9588d6fc875cfba35e9602501fa0d9652fb7104625a980576042c6f733690b2e203b6a4d7f5b80b51cec63761bae53b2eaab38ed8ca8c58b554f013bab1df24eeeae704b3c9e2a17efe24e96806f40cf11cc147a5463356822a196330160b316226d1f43faef1fd0760755b701fdb04647f3b90ff01a5b1f12bd09496188b85c500beb887d471f2760ccf8560d2b0b61aad52d5fe0b574d0f2ae28912b4fb833dc4e748fefa7322a069eb6360df2ac239eb687c9499d8e72fc29ff17d1faa647fbb9fa357ef01587af9dd91cc665b97370a3fa1f94088163973edd8bc6d9957003f5bd5c6a4096df0c0b23721b96d10ebf3c56f70a543069325f1633f025446c2c568a0a87380badb1d8206ef05d056d475e454eec73acd24d531b6f55adeb250a800f3d5b8c2c610b1aea83403e820dd495a9f6827d5ddb4258b8c232fe970b3c25040d8b167d6be7a4af3f6297f9f84bd0a59b31a35e98cd79c79c66ead6f541b37253c575477c324a80061f96f1115fb4b76096c4a57f9d9f5432a0f07faadd7094f8a945b7a014f1a93fe7e8997bbbe7571b0e45a03a19ad582abe4107747cacbb5b5249c0af4234841ec16de35773b515f699596cc82ac3085fc58dc10c769f25f9b50a4b7c3f6c75d3e62836c3064d2f8fc84a7ab527db0bdedc34b191ddc751184e2c240873408e5ec54cc7af04bc77041bf05f6b121d63fadc4e5f28adeadda7c9067118af7517815abbf9f2a98bf0db0f7f4551b8b0b6d4f63e9b8a0d8e75dc27a58805f7220d05b4c3dd47f805cd9d3237453167c8a2502bbfe1f333acdc4c640bcb3a5832931fb4b7acb8ba6ce56b017094209270fc6e129c08b9066156db6002bd307f4601a4f91593f12954ecaafaa9cc09cddfe36cbb0d51c828802ae7f9637e9fcda6ab38c7ccfc409a1841b96d34641509902acbc17e253bcfbbc4b9a048cb72fc714de55b21ec1c996ba21d288f061e647540f1d4a719a17761fef8ee33c37e5a146275a80429caa0c04cc93c6ff9428aa8e448fde68f0e84759defa341f673641b36afac3ffaf1e9c4ffc18ec7717d6a7026e9bd1682d9b666055d695caacc1fb085233c549e27b40db539e128b341ffa6f58f1b28ce265eb23480725be8edee9ba1319da22318f99b005e7a10512e2d5ca25877875ba188310bfb9555a9f7e09e1a2308a297340b7c177cbcca475a0041c6b3f4f9a78329f8105da92544b6bd2ee603cbfda4db4dea9483a8afb9a651406225c09b1750d346f5a91d7f4804c2dd1f501c908fac85d27a579f39496b9e2bd03b4903b03ed0f66b06a21d8acd9dc2f4430c977d41f324097fc7c657089f96c64d5691bb757a5d4a66ee88798923ff2a4b2457eea87f20e339d49ac1b3a21b439f846b763ec307e4655ac4c273931a2f51417fda1cedb1c445627ed21d71f05a52c20e0eb25a6a25cfe3e68485afa4a1d70560698b564bb4a22507ba67e0716d0e2046f14532f96503ac3d909805f154fd7b1bfda8f0bbc50fea0c0d2da3b24ad4529588c4d9221c00354b86c24c7500e821f3e566a8dd30650669130c96cc3e272c341d31825ddbc696b6ba398df06e2cc59a65c97d8d0f12b8008857519e3297b70920d2796162dcae3c0465fd49207d5099a0473b4c60ff42498f45ddfa527a76537147e2f70a7b948f8d031c4abe77c96fda3cbeaeec78ec03581c3237ceff0da490e92137eb82b61a7f75492c3d86d507372fbfd2858196664f7fc8f29563608fb3ca259f48f6ee26714582d4ad489706fd9958a0ac7b235668cd30ec73c0034e7e56dacd6c92b99ff786f45be2d86d98204c80e266e8238624eab8aa024d5cb273c348045d70f1e2acbdfc6800f9e88f2026b1099a3a8d62bc556a6ef081f133da133e5be2ef04747aa46debc233ce79ed25446366fb83424de5147ff83c2ad32d15f56b1e688446e9520555aa8f7ecdf716837741146f4fa10810c3c5747edfd268a90d00c4e7ca0ef8a3e50c0622b6d84a2ff7cb8ef00484d6cc6017a175abf570fa8d39dff890b0345387c6985594f5bc627d8026faaafd23e0e059f3f1715b3225a5960f00b0316e362ef76214bbf327670df276ec3cd3a9898524c671bd4facf28bcfc5df504ee4c817791f997381c44557228e528f984bac0df68f556e233fb60580482d0bd2218b6842eb6804c1cefe6475fe4e56ceadf0cf19ec67759e50f0543516e4d76675b469878b3cc148cbf15e5b272fc946ccb693dfc02400dbd20961804daef96ef059ee4be0bd0191bb1aa443c67371262f2878f93c0b959643afac430fde311d0811d3ecf996828b303b9ef7d3c9668ea60c5c52959802d08854991c5e934def1235f091ad25ad1ca8250002ab80f5e5961717ba4b2eefc3eb51ce9c3bbd6485ed5b7c5653068700041540dc362c9bd791a6dcdfeb1acd8fc8678297c7806b56534948a769f44069a75c7edb2ae196c56d364d74396b274113aac4c09e7eb769925b60734ac42957ed207c3be372087dc6b0012e44a2b915626a4e1e2c299ee9aa7e09c46574d11b5d9a68cb147fc930f20319016c145e6d13a1c7de784d72996366c229f450935d61c96f9c260404c57bba9f36694d3b1b859669b14905cf40bfc64bb0f03654dd1c34b929c3f2e0f18a0b11fc8a1bd6bdad7522534d4ba1497ed2500bae90ed2aa9a2937126b589bc792c092297afbd99033300035728bb605b093c56c16b52a8d43da6d6be420c134335b10732dcbddb59dc3d619738197da360c7cb0c0ed493a61e2251795241bf7608400551b9c0a5fd37fa630fc552b850a4ea4697df63409ade6c50c086df4768628f4e61fcf0f16cb840c94094f16da469969a9628560102966506c7cd6ee553b94805d039b15bc4fb983aa27f1a16b50a5ca02f245c474d82daae828d1baab1fe4f78d54c4d011a963322589e55b0f297df01a77d9228e2f10743f24e983cca6a6c8471113a249bf57797bf271f6f3933c919fec2e370ff7cc668f1b2dd58c12624417a1ebda1428962854879203c2f05a0e88585fb89d383f6e8bf0c14c5aac78ee5c3fb20842266d5ef3b106cf6563e112a85a5c6130d624ce0d5e0d9e8188765d819f37a8f38a3d332447c7cd62995d42fb38cf03f8e847effe33dc36b2113fd0966ec3ab634e40b2f37d8a78ac46fcaf23b4277b627699515e231d0b98d98b03aff1f31d17bdc1073d35fc0cd6dbf71822040e15fd86f22b779566721b9e1375fc835b79b4ee76fd5abddca4bbf32b694dcda6bc72d426752323e1ac11aacfaf1a7781e300f829f9c76b6167a4c3971cb169bec3ffb31d4f0a1515712eee1e363f425c099cfdda74921f83ea0a400b45b0fa4ecc971e99baf21529cbe68707182d7d4f7f3f3bb60d514d182cd26517fed35324216d9be6d841795ac8a1965033656e3bd37bfb7a8bda58c2c08705713f078659c99b79030177618fa463f7ba410c8379b558cb651fca92c56285fe5840a8b6acbd76f1ed2676c200ee262d840b98ce420680b88dd151849db5d42e4681c5f9f38fc401bda06474b82100e2ff323910ddffe9fe7ef7f587dbdfc781a9753a81090194b6bb8877e5268b1eacbf6ca03ec35c97215bfc0281c413bbeb565c804ec80a097452d0d6a58d7ddf1c27f622c945ff469dba86a45cebaeb8c4ce4dc927833ce87fc331f5e2e444c762f2ebdf00cfc9fb3e3e2424d5c049f91b7100e5e23ac1085863bb4dc04b1621e875ba3305f8875c45543f29364401c06ee5d330e859aa603d242cd87f0f67331b733f82e6464799e4cddf803cea68ee9584de9dea171f10c84dfbaa1a7a4c6db76a69572b1d16aa065377ab516d59f580988d19af5890fa4d270e785b583142a804b6626522dca8951fed505481e2abda859e30e034cda71b01cdb93866a7f6c07bf568c46614f9de99ccbac19d4fd509678d4df606561f2a994138eea6f5bdfce3022ad70df3ea34ebf84ce398118ed3b278019f36f549cefb76b4a9c226c400f2299dd61a55dbe6ab25fce978d0595f06622dd069e29d7bd35fbbbc33b6bc7cfc716aad1e0c3480e6a8469b1a24992b202f331ef806239c671242a9240b5715b934ff412e77b5a71a5752fa38468493a8fab0ddb09163a9b345dfc4212cbf269f3b8ea8dcbb2b914fa45f1d8ff541418ab1530807febc02c0ffa101d55c597bea773db4ddd5768fae4be0f096430ff71fb420a8f9bf0983c899a1b60ccf995165a3d6efcaf7d7eed24e92af39a18df520610ad42ac13c392fbcbb488d20efaafb98f56c0011aec60d930a41ea0105c2ff069144094bf2ab7986c4966ba2c690a34a4d1e129c89597d12e6a83c4cc3a3db580044b4f03ec11892a2671b42cb9993d3e882f8ceedb1be42da38d0c4f27279360650dcc64813f160e8506289bdb729a4d6351343be6222d296436dc715477b28a8c64965b2c17442c9d147d16016a8213a9297c59c99c55fd2e475a90070d7dc62e3f253b9348659f026b98e0df9447884bdcc89a7316b3c1f274e8e284ca23b82fe19f8e6eff12fd16a50c103197227e82c12ff623005c5b55c572853ac5e82308bd5c04f2b126176c81bc49a58115eecbf0a6aa8b4d8d9740302bb6924404da9b0e578a260a4b278be6163c22a8d292f5cbf06301ba9bec68aeec43de229c5901df0d1fe8c665414363ea629315cf6505b8529d45aa9d55420651f9e1b2041cca1a10cbee94b3352967642cc1772ed73dea7be2e47660dea803b9e31daf2b10261ac95528598192e47f1e60af2e0d309e565e1ce75a5f4d9d68fc464aae88db2322defa47db3a4e4e9e8fd0a869ba47a476a26351498a8d1f006f2567d1338e1e221e22989f18b208084610c7919c07914a5fc762a1fd1ea52ad8a90d3a3c2a36c12fb8854c444c75c4e32a90640b3f83ac767538da182db6900d8bb2cf47e2c5790b7de123640f2deeadf6c71e52275dd640916b40818c6259373f6e3349f1cc97e946a4420266e3152cb9216031317f61d8c06950be677554afb1fa6501daa2060d6e4d927d62fcd8342ff4dadfd493ba7ec959125f5cbd0020dfac97c6938364102ed60f3540eac08fa4ff4e578d9b1b5346b9468fee0deb4291150860a99d1330968080f00ed4920b1fe7b508aeec5a86adfd7b1006c11e8c7526d66ee3cb705fae5b54625eebfd64fa15ac381f445638cf3fa7f4316b0ef2c2971b6a8f85990a4bfc728d001000504ee17a5e82258227221a8cff55812127e6c517f824a2e81770e95f93ed13a223f10e173e8b1c67577a293cb1fee629dc2253928a7e1277f86535f471ee2160778bd03c5ebe06500eb2d50088ae6e7272f8c59af1089219e1b524935b35bc8e12b0c7608fdcaa00f3ce0c412e80720fd04da3a71c9546f1082c2cbbacae2c0f7de012a7c157759f50f661339cbd96cc3ada6567e6194015d46b95ddc246b9043399065e6ba45a66458cc2cd041c3e35ee69004023de0605387911993e48539670928a85ad140d5aad53fdd79c5d1aa2d405ad09b7d6e044df9acf1e9991f6581599300caf98bc1cb910e8ded07b64055ec3952e7b313fbd88dc05b599a00da3fc589483d4109a434932f6830118dc31e064af112da8eb2e7e8277f2fc233d2b6af987acf96f33a43e5aa9aa750dd5c4fe41515b8ab844bf44339d4bd051f6daa56cbcce45905cff4cc44fbbaccba00ea1f859e3879b9cde3eb71e57aac79c9c9d1b81e6616f2d66b014f554b3ea0c51b96edeb5cc2bac7117558054298449a9e825ded53f4871bea8929c752e9a8b9fe070d891bdb6377858ebcd3dc78f9546a6ee1122e1d7489c01d0d41776a3e27241984bba27d1a3536d473f999bd2606d4eee9967b6adae4cf9486e62ce27c14cbde5f4b6540caaffc41071b4da83b996e78c7a92dcb55e392ca1eaf94bbc5ee48f12ea3cca2c42d6cf738eafba2bae36e9d3ab0700898ebf74b62e5e7d9f839c915ef849770f1f441486deb73fb46f75019b9f44e34425aead4427298528e52f8be0460c47a45b1779d1de4bce15380dc4c0663fb3cc2e688a1f24e43f3ac90e1eab444a9d6551b2e819f8bcd1caffb4f6062faf35da52222e04bb3b3a2c400b36198e4a7de084d8b5323b694b6a70e13d0860338c0315c374781f6074f1052da6530f1360b0cd009091737a9f9562caa14b9c82e595a3f83f62b82dce7bc0c5cb3d8756c94bca367d09ae0cbb885450ab11e06362f66b8f90435210bbe1e0ce7bf8551818e9d86806826e26e27cce770a1a0dce9f32998b6140d88917f43e92931870e1255e393aca91e78d8c8ef295a51aaad0937af3b150773ee240ff29a6987cb6bc15bce169c5acb54a537c68d9d4e3ae2fbf0fa661fa6fce8c30effd244aad7780dd8a8b7d40a506729e3c77b1db2c1e96ec906734e2f824e8d8afd87b4533e1e215171af95713ba25f707b2343fe8e642ec5557334c16bfa67de5656cc2ccc4aaad9d651226a53d50da78991de8b8bcb1fccd8fe238347747ae9cad030a8b16f57dfca6be65e275a5bc3b814e9f7da770f579d7970397128da750e045902ff0031b8dd5f17c8f2c6c6b41039fb3741ebd4482671023493b735a9e0d6751aa8a3ebaaf9999d19eb4e5a9af0291fa40803c9c74aef91b96a8de88d4092f807c97a936d3e83e33904bf11bf0101fa59cd7ac550406b045d0bc1f73b7f05fa420faad4f3f3d2c549c863fa2698eeb26dfbb32707faa24d0f33846c0c9494dc09d0876186c1e9dbef5eae4508511c25deea2b8b156f52349dd087a3f899ee354d006259ca4b227dc67762ef1dae9f9a69a612f6afec6aa4aa1b45c88f9d98c03704c96be141b60aef219a2f2f9060ee6b5fa35914445cca01cf4fb58778ea29f3501174ec77d3bfb01fd40f64e2b10413e68872690bbebd09f216f0568ce5530e1e74cd7abf1b49184b8b614e038217d3fd28096202fc76232ba4d9dceb1ef6506ba3dffed3184cf3ec3734bd3814b5307687ac7bc349a87cd6af48cbe62d0618f5c4314fc2bcd86883466aa79ad3fc057990cbc9177a6d3b5743dfebe824b18822c7277b3b6f4228c2b5f4895ccafac27afc7a25db72aa3266eee166ee31c6fc2672f1355909a20361c7042afe0bad05aa24e46344f3ff700349d1b883135e55abb7bb753399f665a65a0730600bbdb20272992558042ee4b9473f44a8bfec602998786108ae8a94fe90130e4d161144cf085889ca292cf0bdd1b554b9c44ec91c1a5b91e89002fd3bf6ceacfab164b4c2bd27d12edb4cbcc70b83c19539ac3574fbe566bc8c4e5ea7df537b3c1596445c7bdd83f34fc767a59995669b4f1c8f951a5187599d6e812e34c7a998833674e48580a1a780f25da8286dd724aeb69ea711422508e8a3d044486d2d66e5b0ff44c04805b1e20fb5a604c28ab8bb8b11a39d0678db55780553f48e09c394b2a739adcee47c3737e4ede5a7596a8a1124129efb9db2552f371c9cadfd527b4e67710479295fc8d1ea63c546dbabad9bedfc5d94e58044f913fbc8bbda7575423fd8b343527afde5b1754669cb89d25335486e639570360fca6d8d27e0384ceee6a033b6668f2ac5768535aa05149bf2e8c9b600043294da4ff9cb45deb2ed19966c4b402fe655c127caa039bfb54538bfbe78e16ac24acd2fa8a62c1af52e92be6a4fd3f2f0954ffe1b6c243fc974b868a8bfa35f142524c6e510b0cdfd0154606eb13b5e85bd5b27e643b323c455d96a6cb58acad41c356b7cfba5a7c9223bdc7e879bdce33498b683f78524355932b25d0664ace4cd5257195b67f76780bbb4c2d1e20b02090fb735e5554d813b0876b0d289d8db937bff57be621f14856d56eb4c72f8d7c8bc9d3cced9d7be164efa015e1b1c34df49c06c88cd3609fdaefccd5c2db272e405dcedc9bc956fd5c933dafe76d0179506652544e622d77afcbb90ddbffd139bcfad16935e253959fc9685bcc0f7bf643718653c9c6bda60070c694b7965392e4f96ef94f8de220ac70ed5b634af521e631abb941fbb4802c00af33cef3c7f9dda0933980a65041dd3caca67168b086553c5a54a66f42d9209661f1880a4662fd8c6f77230ab0597ab55e81c8b7cefe72341a6e704c99085f136ce0247f5377dea3efb7f1e1f0009fab384cdf20bce5bc5beffad83881b0bc400e6fbc0f97776257c01bb663327e48d2bf2f40a87c4860935f5e2adccd493bfc3716a177aca4ad3a696f75cf4a2d294c1e08c3e33ba3337b9a6a156512b841f9653e4aaf344da89b8de9c97c7fb7c137126f4efc19aa5e3418e30771ef05efd6ad7b5b50c8f3773fabdda9b6edf14140dae482d85ba6bf002c5cd6a0456f5a90cc6b783a31101b19fccba1d498a19b6e09b8d6609287520057d13301b38a2cb9181041e9d5e2b1363422e93d2280154af3f9579fd64fcd17f7d5a7af358b5ae488b229eb5e29b0c6377a35421f16df3f92756a2a4f049f5f57bd163086b396340351a6b3ebc352945930cb15c43d0c1be32e2fa3ea85795426f784661ca1a9e931d3c8c386ff4051b8b1f079258010f9a3f0885475aae77606368901fc4dce906288b1884a7cfb9d8b8aad7e11c5e05ebcd159b4f90f8a13f7f8f8febf26a5aa431a9d1918a5fae0fb650dd2f820bf54086f49716a361954ddf8f14c098dd8b5f445fadb5b685fc3d95058c9e2a0090a559990d793c01b5cea82cd4508a4d25034bb11e34cc818597ca9f538569eb4f15aec8352498e44a1153009f55d78c0cdcba1150f1bf2e70806e83925ed4e3fb94dfe8ba9353687446786721175f7238404ad535c24d1e2d30b5cb1e98dd35dc58ce725676489d632fc9c2cf82117cf24af881cd915cc16917e0a4b23bf426cc8253b2cdea8eecee9fd4cfa0d8b8af00dd5708ed1df12e317f31d9f1ad0ba658c284bac228361da20a30cd8aad49fc32d4c4033287f16b6532c521a278b9f6ddfe4e408c4462b0d57d7a414aa069d79559f0cc8b1bab536729f8e5f0cf9b03a86975303c7d1dbcd4a9a7c371cc10781e4175a518bab255546f796b8ad2abfa95c81aebcd71edb7dbfb0b8e6b96cc2288256d8be8ce40c7f1713ab28a199a7e8ac10f5375ee77153aeaef7ce825beda498eb655236e5e9a38dae298d862796c58a1daae19a18813af5737f79eb8234b8dfd8f562075c1ea82e340aa3ce926eeded0895e07e0c2cf9eb50ee8e7f0a5ced2b612c2fb812d495579bc58ea27c4ad864e14374d2b781da1e6482be6838aa9c682903296556f4ecd7cd6e984d867ccc701ee0c587c4bd256bbf12418dc9e9e280dcd5c7f581019c77bcc23ad674e45c8e0c183a55ea2ba141810077bcb1424647cb8f1772e6f720c06b60c061fb139564e2479af74d464984a1874db112761655f6459b9cf7cfff83ef8e5e405e958d3f61f679c49036557f3021bae2254cadf7a09c44087713bbfdd25a82772caec3e4440740d895caedff957ac32f46311bb591aebe38121279b647156e9285a70a7d53766fbd80d0146e5069e07f8d6169669bef41adf32a69aa3be333e984f98932d6f113e7a3eb7f6cc26d09b8f3541e2a75cfe14f044351ab7f939b8538ebf28587999ca5c9cba5c2368105fc769e6f8beb5949619b6122e5b15d232b94a574aa4d13082dc30b15c28331f432786d48b69a111ef56090cb0321ff47554662b7b9f850b51b43e48e61629aa26e6a06beb2aa1a786a7922d4f84269cd0c8250a9e0223cf60013d9f161892f09ffba63977db66c03ff890868e5552bdd11e1e5ef65852cbbce51619a9becf5866fc1cd5b9d2a768406e7b9819fbc30241e7fc921d2d3a29905aa05476aa1f36c671353e52bbdda8cb8f68f86fddacf55a0afe483d9d56c5290e235d3e349586ceedfdfa2949bea298a3d7f8669c723dd55ce6bf5832593bae431d6eb9af81be4fbe2d13e2350636a156a303f4860d0bde58a6af81d87b90cfe5e7b86b5e2b7851c4f93f9dbf7c6950550902f7feaf02d2447a75a898748794241c82927ef9ff52d399d40883629deb7312b696f7c9f742c3aa00ab9e476ffdad351d31fee276711ea5770c97066c0fc3d9e0d1e4cc3b70da511af868f060740d5da0cf79c99a6451f659e1631ae27bb1fc218ce71f83c9e68f0e1ee1279d981b83602b15535c0809a3169f5f0ba4547405cc182180d8f70967a3f89dbb871dd883e424388b04bec8141dc0d6788f902c08c30bbdad83e553dc0bcbbafe8786fe82e792c9a56c93f3babdc168ee9b63c11fceb9f87ca22b3219284dc214643f473fb402daaa46060ca4b80d1660d9cf39cb5ea15a1a90bc6c38cd562e07dc0b7e24f13a107843288a5a23bd620997f0d9af0e16cd67c5aeb6f338d995c783672c11273c06ffaee05214d5cfce64ef80c6aed8bf778726ab0323973fb3deae357b6319c1e27a31b5f8e2247440f422b647af0cf31d41d1000aaa7a4d5af9e8f7132c7d9666e0623461950cd4c9b3446cea120bf1b008d26f331d9e7f4b797f70b43f3417eb25ce5aea76ed1ad35da64ed373186a7c6b9964a6fdbafe50cf6dc80790a5b2ae7cd0f830266fc899041f5ab0e66436033dfe5612350b434f71f0666a3bacd70156af12f18debefc476811a860a184f625db351266f611ea547d75edd6b3f05e254b85ba264024658333d4ace2aacf2518f44a509fa4241fff40267a60ead73e2d52889643b55e1755bf999d8b710964d3108bb72f92d33a620776ffd3a8d73ab5311b7f883666bc3f3feecfd1be675769620cab45bc56ca0174bdd45eca317d2d97dcb8548721aa454ae218bbc1260826cd2e586b075e3c504b75c26ad602c6e2b93f03dab9c1f1865e3b9165e6ce65b1d250b3a1e436616235c5e02db5aafbd86b5ffc6236f7de639f15085e04e1063aa6f200d7a901c97a45aeae67e32135df18eca6c0871de4ca179d1f06a5320587d01ea423c09c0167c48a746777ee31da5932ecc25af82c3c012bfb75fd0899d0403eb8c5c5d2c5f48e0a9fe2e54ffce63f3514d51561e4afae5f59f832da5816b3b39a9d581a373dfb087f95f01c09a7daad6166ea8b065056842adcc82985d865e0c948fb8d96d7771aa9808ee3376c6fc965004f9a2f180f25fcb0a1e535193b4d0348a14198422a5640ad9653f0a73e3ee93d6fbb4539e6f52b4072b186e7329ff4d4b39564ead8fc3c6a3b262bf368a60db8051c2d14cd5351c96330186704b00e7e29abef29f7ace6af7606d24d498bb668d87a60ca4ab499c1382a7be5a3867e442fe01f32ffa30d1e880e2814029833db1d797dbb1b6627818408b2588bcdc095fc0f9e349315ad695b8ccb42ac78e198647981ac85b78c3cba4ad5951fdd199268dbdde0c1d85cbd16958c11b91bbd9f1435aa1c6c56e648f3a73ad1fd3b7783c49027681407eb02ddc6e0fc99b2eaceffd997e2b4200aedc31fc636fa961abc8a508f16062525a90592a6283b23f53e0ba904003d46f6bd1a34b127798e0ffd061e98b4ec85960c1ac26877d3e6591fc07df649f0c537f6764286562e4069bf544f81fb5344803243dca6506d2eaf9f10309322ae3d4a94c2f88de679c71aa2ef2b81b16f77df5b67c98f48c0202d15ca6ecc00e1617d4c50c00a7992de1069150edf42daf8bf4debb97e63a0cb8465afc841dd1093166d0d1dc3adc1ffde9987e6e340aa188a3434d051ee18ec9f0145c2b94c661502bb7d8efccb95b8f86b4183121f3e5c61173f5ba52c6587e1d94595a69b82e7e7f2f4f4716c0edfa296cfcb4f8ec79a670e13ca588896341105ace191f180e5e80101fd20789d7f0ae6bdb79a2ce613bf8f3302b06cee2b7c09902ec945ab5c5dbcadfc91ac3d51ee46377003cf27510623e57651ed92c7a331fcc649cca8db715b88505f4aa8ca90a4c404f541ead3900626f72080b783c88ba0bc46cdab46e4ccfdc80b2c0472466ba201c8e36d9f89793e0999c7d56ff2febc82d355c524d865082ee8312b0dff4ba304f7db401468a0315918f2647a63f29c5b7a920f2d6dca15d75f6907903864e1bd073498cb1bdb6219ca8b877e4d0ed0ca362ccef8a30df2b9070ff37753f0cf91b0f0acc4000ea012990d7cffadb7f5c9b2cd0ad61c8d9172aba18aaeb5b81aeff22c8c1d8aa41292d06c2ddfff11b3c558c508338e20cfa5a16c184cab0052ff7a101f8ff4fe4d7e777cd7d7fa6a3f2db5b87f137589dea5c95ee99f5da6c0d404db427e84053e9cdb1e8365a1979a2a997e782ecf06e3f04deeabb896f13638017000712a3ea8995825b2094a13ca03f560cba18775dc1ece12641d93d34e44b5dc2de3cd7f5ff531d039aadf685fd4a8d3d8f2952b7bcadc6d7e6262640179326adddd0352f763608f445e333c1a0291e4fbab5de0a5b75c4d4c2a6739cb30abf1f491536981c1e95b6d509a77829a4de941b9290e06a3ac03463065c77b2add7e47c2ab1511f8e1c1860023f0200c24d49e31c152964f52854505357f05639504800641684a7df4b1f9772121366de58341e6a77a5b5b50e7e1c4eef6c27f3a470e61d4ee6878cb59cf4c6a189cbbdf999018a06de6cccb4199d6a6e1a53c45c2c193178050809b4423ea1f6f94512708d7c3dfb1e94e89fdc37fb31b81f8e35a4b3b2eeb13cf3854157b4b3493ac02eda77434263cc154f509077c9baa58534bd43ceee88bdfa38c5e3c4330c60aba6451bb39e0ecffa72499c7af10b0cf6b012a4d7c31be52c8d307a32332c9f403a69102daf75ed87d4e376ee6c44b2b7bd75d2556bf570a150e45fc3f8441f3ed4dde02f75828b48b0eae87427c7d65950c8adf86d7fb8eeac1460462e363be47e1388c1eb57eca2de069f17ddedc81d6d86b2ec955e42a41aa24b420a2c4a73775c687bba9e9e9f4fc9437d2bfbd850f1bb9ce30fa6902acd5835a36b91b9b5e2efeffa8649e17d3c90da8524423f264280b0c3f0e0718d779e0d6d39b47dd20fd6c4ec86bd396e62282441182872e43ce1524e1aece4515d80464453614408379dd5b6b43879684e5de96024c0118138f129413b202381c186c819ad80378e451b76543fac6e6dcb64ff7dbfba1cea957280489c50e67ac0a6d252d57fd8d97aa71f1dd148d6ede39158e5681e5d24343b5e52c174f08bea541b4953e55a4ddf3b2f462af65f4dbbec7cb410af5c59710d9a7982884b7d6bc384bd17c4e8f6cef748026d52e61c50abadbbb2c24ac490a818ed7c0687413dde6ed7a90ee1b5b0ce8959ffba12c30afb84acad9a67f732d80e27d889a44cba75d100533c1be1546e89dc21887223ce13ec778e4443598cc065d6beb60e46de39c6a3e5432c630dbd48680772f9e980b93d42517f5131d0fb529e0b23d0a983aa98fe7c8010736496579cbe62d24e0d36795544bdeb6897ffd7b2d9f45603ebc1436cf752e8edb6179859ffcbdf2088cc9eba6a874cc32cde401a0ae433d47660cdc99915eb2f80dbfa69ba50b3f1edff623d6c01412e27055dd6aa6728bcc868e8c622a1f465080324bd3fea1a6e2a49e2c9505395b453b2ea79c83c020c8be237a4940e8a916c1ce10e1e130bee136e2e2a6c94f3311f692ad0863228dd37d18ca25c37004215e9bb82f543519549a20c7e34f48632797dfb0b492207ac8de9ad1762ee046c9c02248626532977daa9f52169632a6ba791d54600cb3759188f4996cd093a974d452d61dd45ed287c47f144d42b5a07896e23de74f67786f67588effb6d93380f3adf0914bc53a1202ff7c0108b94f114d7691ca2a1ab57b196a9bdfd59a4dc00df56ce86cc0d52f4a2a46fd53b1abe78c904f17ab691a48fb147ad143feedb0a9d84c4e0849a7847f21d4d2df9c4788ac5512e191eaceb91dd80b80af7b355b5623d1742726813f769caab69e2b93a396b1ac0181c8449bce9e1d78c3afc327001756ef01e849417c35b0fec1226c27b5c18c6d9128939904cb93125df779dee7738700cab9407c22650345b387def7451dadb653210e4ce10559e2c0105e7b93207a36f936eb6492dd4fb2835a98e815341814717d4c2334b50f323ad6dab5ac06e6f4538486c86778d7e038567c6d702e23ac73ddf3505d45031d358d7cd55461c27f7647911c45a6c73ab0787f97a96d658346dbf136e105bc35c517eb6045bf6f3ce1e7c8cc751cd4ed52c98b2d33f8c3e39a39315e28ff6329c5ac6772a0a6edc19d2b379279692886cc69e19d4e3b363c76a58f3c6482e1a7cf303af2695a265bdfec7b02d23a3a7ba8944337511c426e6caa61431da0815200e4b99c1b58d919e60af7eda4e5d57571a82e232d648072b6ccfa37660076f8d8deecee17d6f321cc32d8fb7ac4ca73f57619e85ba0f5e6d3e987960abde9412f0c33b080b1e258afe8d01ee837970ad0713cbe6b75b3a8e47683a7ab0bacdb3c8059c1f08af2a50953e997a52e866d9fb8f7b5c4e0a758af783c6c62de90784bdaa1d39c71cbb90cb336452d1050f88a624562122ea7aeea81d01275a19ed2fa59fe378581a54a0f3916bfed72d49fad07918f976e4a0643216deee880c1423e3e0e8ee3f6b8e6da69067c39273314a9b51adc38e32e43c649c277eb5133cf46f93ebfe24b60f27e4830be14b74424f95713efb6b9b92b418dd36317dbf5f873464702bfa32288dd0662654caab7bb33784d039a565652d35f5f7de5cac018ae309d1cded0d6551c2666060f7240ce0073a8d8926efa30437b62196fd9a9f870404b488f97d5e24fbaad6a51012a4128bfbfde627c8169afd90304808bc8201601ab4c11a47db6b3b2b602399a3b0e57e24b871f535075fc31a616ffcd627266e2a7b79b2f7729f6656e7fb5eb4cef148e157254f842b04443c4322a1d2fa6c0cf9e5bc84b3b01ec6580a985185f10a09a045a1daa58453e6c0aa9642b9feb89a5f9f4e3ae17966825370fd04fd9a1b143085c47d10fdaa18b5549db7eaa399c9dea48c92f3f3db8dfe9da41e617f103aee949237fa04ae7b9c3078ac19886738e7a7c8f6098a1aef64c0c24ad5fcf8224f7be79ac24b2efee63601e25c6c54a97dad4387ed397d85e9ecc3c40aea909d1b934ccac30cbe26806dc1d96f4cc0272e8fb7d4ede4719cb27c71cd9c41611f585c02c7afee0a185507e5f04398367e0f3315e2c2e49dba5a702563aa41ed357bc3b1d9a7320befea7310ff0bd3e4f258eb2ab95cf247479072db7a602df43544e9d8ee2cf05305115361ea0e918f9d5e33606eaf173d91993afe97e2a49ce00b77eee089b3b0e9fc1ed7b1b2e692f4cf88d2ab16738b70b3112e657e070b30bd0ed0c573563bfbdf4b2f6294246d561df3d4ee00303a80b380c7a9dabdf41023f65f7596418abf0e243d506c2abdfd89cede8d121b48d152d6ba3815b90d2d2a33715f26eed8e4cd82caa12c510fbe07bf9b59c080c0e4eb0d7697d5ea6dd65cbd40ab5028e006c1485845b848a57f0399b500c37296ee5cd01b2f4a0a2b7aeb08c04039b0b9cdd58234b7bec268e0c54c79b867e6add2ae1d43a1a90f5752723fb240b7f66e95c07c9c04152434f5eccee68fc9aef6a8199f6f240aaf62d2503662cdf6d0c672ebe64b5c3db5265bec81ff3893c3ab2fd7cfe6915cc0d175dcdfdb860b68e0bf41d0c8151febdceca02c3feebb81022c754ce10795b7550f454350e3df4ae976b04331c814894ec016448ba95199669937c46aed47560efc539694de4b602c011275cb0c579b31cd89d9c34a1d5d0c594ed1a7ea2bf0de08db18e86669de4187af6a6bef285817566cbf52738be427b924d4b2b2e275d7579ec9c7081d1d075ddcff6cf21ae7f93f541f5251cdc4183d76f8c5eaa3bebbe58e85babab546b0928ed3776c0461b684abbaac627878eec35b6cc27f97d5c4fe72e773c5599d87c21b877f0be35be94615bb57bc06a4098f39e27d9b2a68e73931d2b3f1fedfef2df1fee9fc2028c5f8a0f25df29e452ce7d98c5bb11928c1718c91a2d49e7b4c5e494d77ef01becd77291727c657db77be0adaa91357a7e5fe55abf9b0b1b6847c17135dfdec2a394e1b339ad75c9f87e7ca97148606f8dc4409df3282937c223d5c489b6724e959b5e11ea9e725c5167e88cc6ff649ba14833f6c34f5c5a93432ced3a7298a115953d6f2cc413bfb1cda83e51e13129ecee33cb69a4509893c8e1a273f6768f18da3505eac84b611aaa4e25f4944a6d50a2573125dee4fb374f40482e236614ca73b7ff948afc40bed826517573e7c3cfae03beed028207382e5f07c22a2bbae02bf5ff877768edb927022d938b9a32f20a074bc043195a59a96803851155f35dc2c22f423e2072b9f8ef93bd27ada79182b78307dcc6251a9072e41091068b3157c7d70d2297ce2441dd52f8025e3d7c6544a055ae6441408380a57a2ea2df29c3570d2a0a2b44888f120ac9ca7305bb7e097c78ec046b7ee7e5bd39bd0e6ae84a4b08025ea9b1b9bf6a9780bfc21f2bd946b8eed1c794f6295b1831835c85563eb6d8721145363806793fe8cb4797eba8c41c9523f347ba7702d61dacdd89c5abccf94ba3172bbb29184babe337b25ab462d2aebfbea4988945584295f398757e897e111f436125b7c6fc9b59333813bf71ec51db2f5194d362eed956e2dc380da3f647433b1dcb4122","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
