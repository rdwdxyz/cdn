<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6a4e0b666939c65158b58d750a0a31ffcb306a9f3be121378555372378baffa60abfabb2b2aaeef29045852840ab9f61ba039226bd681ed9d5f202ccfd783f3048f5e6a91fc0b097683412de3a405b02579603f82568eba5dc5712f413c85e5471db75856630452e9cc7e28107c3a75654fb71fa88f5121b11b2455bbe933d21065bfaafd5d62b61f6b11dafb9d05eb015cbb676b195460f94b1e872668b95580db6b45897fe1976cddeb343373d41c6a7e708c0650fe54401c566b537966bb5686c957017c8a4091bd7bd92a97484eb27ceaed8da6854762eba258dd039ef678c49a7719ee2de136467ba10f3dc8b8acfe18955f6b98f5a20413d8822bfb505522d885d86a9d5ace26de146e1052d5ebd6a5baf1830d1531f8d3721bfc190a52c898f85b56f33a99966d189556a514e2515bc41dd7ce206089e375089e52d165a374e33be5a60344febaf53f1b20917364f388a8507318f3341fb81c1c1c3c2e5f01e6b018e3f73923de3dd2dcfbbe6880fe271fa96ed037653ae24d3f9d220007a3b97ffa174801f75c70ebbb2b7da5c6f7370d411c1cc1b71265971e2c7f545e14dc419c33922f84601579d3fe505ab9a88dd5e30bc287e8bc6f5517b79342ce69c86f30f427e7665381b33d3df3876b2173e0d8e0a3bd5c83487054dbd415922739a0a0615f2f8b4aeadb3c28dd2585a7ab17623f482d8ca19b25c36750e8c40ed66f5e97fd38d46dcbbda122854bf77a657e5a40f815875055416674c203e53bbafe67b84f7aa791758ced60184b1ecfa9d94464e558de8527baff9d511cbf7b77a56cbd64c7712142a881a263b86808d9a16d8d2d2be98d5ce48b114b3c7f0dcb2a5b19803d2150e82ed00de34be8d93806a5287811a8a75fe27c638ffd07728b17cc5e732d31e4851d0e2ac01630aad2c1aa8c2ba5f193c332b3d949c988bad5fca75d1bf3f1b6ef0083e0b96f1ae10e2dc0ce41af79e0bdf82b8c4194ea6dae2633b8f4409cc86d1d370da2d366c46b9aa9bd89a4ab44cd7d489c051fad2085dea31f05c31dd0dc2508d1ae56f7995b168c9c585ba06112c30ece9ac0ce44b84e84859bc6b241890d81c337d39db1984d0fa54b5d205ea9048c7b3b734279258da0aea7f69d8f8abdcf4980801b7d0a9ebdcd4c8029b4a0a00e3729e5bb3ec332b2fb6b81ac521f00317f4ae8b042cdc2bb1921c6bc785abb8167c967ee8db94ad4bb0b937135781429ead379f6001be75990caadf52e59a6efeedb0a63b19aed4a2e8b935a7bc1915f66043bcbd5cb1918eaa1f0a7efb94648fe3d291da8742f630d36b1d8fa3e6de3bd7daaccf0aaff250ac5fff70b41a7a414c39d403f8aa2d47baee65227dd6b669262526258660f1f0501c1a52b5e362c45c4c7e317750badfc930dc5b9df76dd63a3445187e826443a04772b58410db1cd5ae5f72f3dcbb9a5a2e66d38b8531e09d61dfe14a8bd5c39e7de0dcec44fb6bd2fffebd23b381fa0ab5285918a1bed51a829903ce8655c47d6e65bca2a9eb72cd327c344584c5a7592215e07bcb29547353f5245180f60a36a7c026268d0d01be2bd3a5a48fe573b689bb05dadfa391e0238a270553552039d5a92c09e095ed7acf7ec34c9f76e495eab33ce7220745f4a8afc0205e974f1fc8d3b546bf5f07cabdce08fb6957a69a516bb1d3295629410c9cc01140ae5de2eb1b7e81f72a0d0dbf77391fa5a28e9481ce91f9e9ad4dfcfec1466037673a895a4c45ba01071535554590cee601b8120132aede8aaeacd9385fb46bec4a1aceae1ef931b1b26653ff10e5546994bfa8bfb9cee439d26fca84f95b66215113e2f06ac25fc4653732240c49d99dcdcb7a63f0ba180e333dfa3317cd598e79a7ee00cda91df30dbfe88c8fb938601983d2f5fa3908c69044f5e26d77c631e7265f7bc83615624be204af73882dced58a8f9b689a4242996f3816f34bdc057c131006d0379c18c94cf6d779714d19ee69d4056aa6ff51edb7ed6e73be8f955fa310e9a28c75ad9c8307e6f020de9118d703a34eba3974ee83896f171acefba71b3a00f1dd594bcc48f33becdd2b25dde1dfd5fabf705b5ed4b5a57db1e347061a175d53d23c5773a6c10b94f8d1dac84f94e44d96d84dcdf8e62a309bea987c0a82eb82da765b5092437b33bc58c034854d2d67764038626a91dcfb333bf926d397b1f2aa8a14d1c923959b1a86f35d673390dad700c8b6f366f73e9ea4788f3fb694dd3a75053a10ae2dce1190429ec57f0813389782b9729014815a855dd03f42a6e63f03309d060348656bb587c6f930a8ec7be5465fb0fde510697640f4c351bbd9564ed15342f45d24a2115ed0072704ea71169722d14e1479be773582aab3959a5904f8956789f1111acb10c3c106768299c1b0bb2b5658aff2f87f7275d59b3990a11916fcfeb33588602d832e6023b2df263755913e29d47b7332ef25ff48631bb4e4502be5658d715884a36254e082fc61525d9d76f7bc2d00df8fde82d057fe1d0e8acc009f7983cd93699a35422304917f9147056fd55530722f32987d3ae9d3089170c6dfbb04ba23603d91d8c8229855860d66b2a87e13df653d07ffd1ecccf199609cc1cfd285d3f70d7fd7fa964cab548280329d5075cb2f91b802eb73f021f8a58befc1f4feb837eb5b8ff9cf230f159188f8ad7fdcf38bbdbe1f1cc4f6031f9bc918a46a4b1eccbed2b3eefdda4fec7e13087239c466f44c8bcb1f319bf70c5f747ef91341dc56cce70eceb0b3eb5e351a05ffd71aa25ac3986c40d207d21966bb3d18ef1a95b79f7008b1a4f00abb202a41dd3697f69a48066bc5cdaab7bf260d90259bc3f033bfe094e736fc142b2d3ee51f59fc4a94dbf659b9ba4a17b48c12f797a3e8e61864b9b030053709452e1b1bd05daec649740075d8a72109e79bbf38c28cda556ec553709991e6c6826e0d9f698e0d257788a16e352b806dccb4e8d7dc498cc92d6f1356e78592ea90a3e1404b9dcd279d264ec7e74e80da073e8f6f30ddfe642d427c6ba889ff37f05d6f9fa4c6de13ea0284b0fa1b1c3d1fc8c8a3f5ed7014104a4ce6abcfbd0a4352a1a39df5e072bc9fddfcaf0d5c8bca51347edec2f2cb7361eb48aa9c568470a20d79e31932bf829cd654bede708c726bdd0470cf12d39ff611eb17b2eb5948b326051767d9def3140502a1ab2b916849b292a7ff45936462e221863deb5a0e619f5c779b5c27011abc2e21b67dad586cd09933b630656d51ec95d148bd8ce01cff1093cd419bb0ff77e8c93e695f4028addb6a7948b6aae5bdc94766c2c6d2d6320ef3eeb653502970cf4f4f674561023044b68c585cde08b2680c750d7e9cdebce410d3506add78371643fc7af6694992c2ee63aabfe30d97a88893f44ad99d3baa823851a092cd31998543d45ea9d0c1a9027d217577998ef2a6b0e8e87b4ebe6ad4f830d3c8a4e7453af9d0566a9e564326589733df2b6be9b9928446702299e1a83c6b856d03f359163096fa0a5dd1d9cdd1944d9bf371a5777fb62d3b30640efb846082c50def2bd4e6bec54268638f8ad5b31eef871a35c0f2263336ef2471ffec1aa82112301da4b17d09df426db5750dbd363d3ccec7b73e5992d2550549babbd253317745d673fe91532350f2abe0ab9e8d4a5f5f2f7be9c092b842acebe8080bc637b0d8018ce3c6e0376e03a26ead240026dbae439fe497792331e45433af28f5dd5fdd4c3bf72d2fb0aaa8ea4fab4a318fe3f3ab8fff3ef068e81a398c8caacf53c43f0cf7aa46438bde68e872c5ef282a971ffdad869df5512e1159bc41410b1344294a4da5b0e79470bb8047d7e23804dbbe95993acf525bbd7be54de0aff1a2aa23babf642dd744b137920af5ba508306dfab709890a401aff3c600c26076f37b585e67138b0a705826b5dec82449d40aae5ce465ad9397917e415f679e9b81387b4775d017d1666e1a49edfac68a6f30d98f3780c69e19615c496467ac3206c89b3321724b2106f11e6af616a50317e247c5b7a5613ccb9baaaba03faf91352df944c30e670ebe37946628d4291ddc0760aea212d210a52a6810d762f2283f028d6418fa44c9cc3bf50a4846b4995edc72686943c41b776f92578beee0537d016f9bc88b0868d16b3a6f677488bc76f7cab6b4c7538e30c1f11b4ef3e352a891f1c4712c9f0f6e0eaba604abc1474ffda864e75cac36c246cd61646503da57a3313f95c6872e1564b0252386a8e1bc20f1eb753aad346d859a40ad32ffb5f25a7e13812caeaded601efde60e3d36f6e3786d8fc173c819eebd98da5fc3109e2a811f07806bde9119074bc84c138135b0799eb2765122819bbf3d982d69974e588e3244c6461608031943b83135cc8406ce8428fc597ee6d8ddd6e44fe32176d60cd276db3b7d3fffddac841e096f7dc1f15be8d267fc15a1313193d57b867d1ba69a06f67e8eba1c88f80a9e553d356d47127c510076bb1a00ae4400f971edcf84ec4508ebef4c87f15e521b89b7d3724e408a82c44676650814159567638f5e59c3e30f7af3eb8d2ba40fa607afb987df4369ca0b0f188e7b9a82014b55db0b8f844905ebefbd32c9bac30038765e16e3d23b04121e09ca7750a7910adf78e622810fc00a5738c932569fe57d78a5361196f2a0fde8b9ccb94a4d4b3315e70a238a0cb197c4f22177e0212e263f69f021ca124942a2fa3a562f9c93c8b9627041b48b666a5ad20b708461308cece2afcd087444c230ea1cb4cf8246ad86de9f32d202c75557562197867e47964f4d0f727181b67a10c91cb47dad8f4f9bbaeb72c409105191da5d57774656a73936df00ef14b6bb4b6cf4063084c79bb773d2b31b809a004b98e534f18035bca5ad902ae3d85b47cc75fbfe74e8fadcb0ad1ee4ba2d7764d1080584c73253c2f0258dbcfdfaf91055c91d0beba483e6be87dc9ad685cd84686d416a55e4b2fb1aad0e5a413eeb2db8cc44ebb8427e0132777df6f2f363b724b3e70ef7ac31b893c50c3798db367f0d75c5413deba9c4fa8d1c188181893dcb045f6fcc07eed9fd3da3054301c9b5f23e384c482fccadd824acf9d944f4a97f9b49f1a6960ca2d1a31e0610e0ba56b44ac42508172d1e014b5f69dc86bcbf7cfde853dce537fbd6e2a58bd9e0870d89300cf12c12bbb37eb047d18aae9bc525f5d8ad8272b265058061dd5dad85b879850d1acacb9cc5f90fce825252fc85697d7379457a44fbaf7a664603b5f1f4ee0392d363c97de7a2bdc7cc74019cc2c13f3dff5d521f84a13ab3565afd085d2d4515d6aaa10d53d939e8853e8097dd3c7551e47777e04544723273acc57f6ecab9b53d90d6c8ecb5cfe6bfee0df41de78b7a0846d1ad603eb964543fadd1a6f79adaaa7c805e8a5a97cbf587a43aa23a6a3c69ebf313ab1711b33c2c727141c2ff419382be9e3c3ff4d0843cbea6905ef233e67fae811cea50fe10f06bf8a5461908a11d56f044abcc350866588cb3a150b41a205d9ad1519c55737f6e59afb0466f67ba83e658dccf868420d6ad8e8a355ae4e3eb51e9b75e9df5f0b7fd8e33ebff534732d4f4feff25b23045dde7372850eae604f2d664b5750e1b8174ae764e20dd3dca4a20a2c252d68d3b32bbe3f8f1797dfcaa008ca14b46728f0b35ba1210dda98ecdbea2cc8156a18c7213df99c057c7fc7fa02dfad903149afa5976bba3dc320c1f1fd8d0eaa0a959bf66d8593b0a1ab8968fd6a00493debba7571253c3eb8fdb10839595021d6fec6965e042f81b6a0819f435354f3acf7b7bc67d575226e1802238a62735f3b4e83382b49ce454baf3ffebbd7e5f099871afff8b75d8ff48e843e585efbb04112a6aff3d165f17f9afb8f753e2a19bbf7cfbf5c9d9e4f425840b50f44594090c2761b8236deeb5065c86e4ccaa66f5f5abd02853ac5fa513885e8a8785ef7d49e38d748588ffaff66932d2a99e748baab87d71582000f76b6a43b9ee450f64db1733805dbe6c98f664042ca84717198e637143689fd0833b463e279ed955a768d65d69ea74e4cd1c2c3ff14b816deeb06a152cc0faf00b64764dc85ba1a4c7b4548a783b58d01e3963f24cf2e9d4e0dfea7c2f329f9bfe919c6b5b83849c71ada5469b85b285163a03eb16e47a2600fb24dfd30af1af4aed7bdcf6c87982aa37461741c7f3b869e2f27ee6669c2c453328a0ff3ffefaaef90fad7b33d6240631b41b772123eef707d8323ac4a1b8e052977031fbe5880909316b8c7021b424b55a26da4d20d2541ddd769bbbef028f7073387efec2a294e5c16452098607b96d9412622c0da9accdee06c747a9a4b91673e1d88aa83cef47876a5ef1d1100410491a39d16176b710c295ae506806d2e3d3b279f997e407e9487aa14244ee31bb873d81068fc042844ad657f520c82f0ce68c39c9b093fa63b88aeeade7ba3666e2d19481b770150d077a2da19ed213804ba33770f7bbf58d56dfb34f197ebea32e5f29744349b58300387c14231d4443f3d05480a510ecf496a6ff5c399519ac86cdf27fac9beb06442e42955902f80bfc56dc5b185cabe45e7bc62a6b70be1347269afd40c095aba71602472ab6c185e8c364b1ccfbb6d057ce7504b1d850019e8b00e90215208f5a59268257b9f95acfb608a7bd8ad75be7a4fe458b0fcfc534d3ade1dbfeb6f45dde3ee3180e3609c7356f4ec8578523380718dd849cd59495b253c8939882238a101f092acdfcb2a2b118b98be8814d0be39a00c0f064393f56f960debed66563f624fa499335ec1829cede891182f3c26640679a68800788da5ffcd109598a22a7bd9c87ee65cefc82b488f90c317b3b4e6975774423d8b08b341d30381c91bab64f2e3e436c9427c6f4d20d2c9f342ed1fe408a878f5227f1d571996bca00c721adf140c596d9807d2ab904b574a4b7a7754498a43999946306c7ce301e050d3354c8c1df8a50be7872ba49fa91000c043be0fdfba956a6fcb08f46d4db865efcc2b86250cdf7fdb216e3ad29a2094d0ce59b3af71fd3b318bc77d13d7b8c5fe9f258f7ef898ced591389ebd3d1c619d1674eea6032a825bd9b277b2dbc68db8a5b21f1e408d58f93dcbae35b327b81577e295accdc03c46e765e726e9f30d517731f5904bd3d5aa815c0ba9c0168b14cc02d05cb497f4ef248390f226d57a596c59629f19108f582a9d01d8412dd94535e29f1dc32de13515b2a933d1cb63ace969958a2574d8169cf35029a1447321d8f54e829d32edb398367b193867e2d784532d1a659c537ff03817f3376c1dc4c4235c08c1cf038a4bcd368b4da700548b5c8b61a0827a489cbc03b2c2ca1f23faa134147d6d8802b5a14cacec4c7753324d349d83f26d2ca136ae1d38c22e89cb8d86856be3ebd7a0395f2553404218ac55835971111023592190296232a0e973ce0d42b26c9fcc6aae77bd389645cf3e0b86b0b71ad7d559ce4b8a0d6aac1da46feeb4c9e55f05152ece4140731a7c9a84b9636495545e4eff06daf70b9fff65264c9fe468a4e427696d301236628dba4823c536da9601a1df9c6d55bfd1cd94ac32b72b74ad86cc03cdeffd576c25e499e312843a25a23409daa48a74d4b04da9d0a159ce5f81d8121d3a1d54c17790f8de6c87fe933591a66d475cc18d5084443393a1115c8be9b3417c28fefbe09d874a7dadc50020ef86742911a597a864aab1db995ed2e1e4907adca94edef6bd7e507e5356684e7ab1e6e7e6fc050330dba61795998ad0bba3b3a86d860814555fa51426a7641093ba8c2dc0ddc4910a66aefe85698b3f5f799f152a9213c3fe5a49aba0d90cd8d71744f4c2891f3bcd449b2b406157a126b6d4837b684ec2d6c1493f32423105229850256a57f71f4669b7dd60e768a8e3cab2dbd74141ab58fff473176700d7f2896cf9e06555b0867f4e4de12f24c7facfd65d657e2fb892e9935bda0428e5dd208f04aef3bb60d4c3d21d3a1ae6052bf7317a69ffadb968e0cc4e20e589dc50ed886e6fb0d2d9256cc3992f217f5c7302b2e89d2199765dbbf2b48bd2d7ef930cb5bc80db767da070f61888a56364ed4b1808a625888d39c234850ef99bc48786eed401c78b9bde66148e3eb1689310e46e8423e676c3c33713c482d27dc1409b641ceac4c88262d996024d315c2b4b5e5568d789b622d463c24f34716ff75d8568d4776475928b11f23e88207ce9e00f7179b851db207f9c7cbf210c41b17ed7363edc71dcb71a7061abec7ae29303b78b65b45b0633554c317d36d7bbf0a5668e0275a14be77852239b26d1d57c985edde72bcf2aba953b5a89a9e40486ce234162d836ba2b05d49b3c7c3c5f0fe65af2a3b2e907d274b246f7dfe27b89fb3721e1b42859fdb3f237fec8073889d40d0268d1941f2ce9e6558ecae19dfcebda3f6e80d2cd55ac488ab029d322d2666933afa85e3b28337c03c91ddeedfb45f59c9e0fc4d25c667ff1e747b811ba0036b96a4e0c5beced2c866b68cb3a7d78f4c0e767aa8c8eff8feed9b5978b4beb1cc91e365f2d8c52a892edd75fc858b1637d7c653e325c30e3754715879bf1a9db2f808e48cfa19dfd79a90963e9d496f24700b4a71303aed46afbe9b1ec6fd7a19dc5f2501711763444482737748bf7b83c08be452019a8b42538e136c91734604fce26f96813cc8fcdebdac8b40669d503e5e6811dd849a0b400db9fc3192d45f0e0ce7b0c30998638118f26272e240aef03fe9f1cc9a36015fd49dab6db0ad1c590a9c82a83b58bce767b989082d43e0344667698068633f3d1b6871824b1eba73846c0864d12ed76def84804da3df1bdff0a24648142c4bab6f7195718e66935f0edbb20e87cb051ad6b8f96a006edec57eee91088218b45a0623195f4bbfc274cbb43d98a136232dd65569e369465ff14e2a910fdd3cf96bb1f2e33000e8267739b2d4cf801b6b93596b9c2d84eef4f5a94c9d6a615beb021ce205e7930be03ac64640c2e0e191afff006c9859d3aa2c85440518dc9c5e1d4b31bd9f8ece6d1fb95dcf1721f47ed5e124a9588b5873b973e020d2980fe4cd58dd1faf3db86cf2b0bba066ff390163b9e103364ff0ad12583434c16eac618875c196e7f91b1c200fbcb67c1e8c8ec9de99ebd7454870cd041a9d1c50b7ea532276fb514392cb822acb04a84e08b6607e69c489fbc153d2a50b7a8d2129bebbb3ef068545d50a1486b3533512377c770ec6d802fb676e4c229ec161cc68e4871d353d0d87c667cd431fc95e7ab3a091c8795b884b6faa7c50743495e164d613b2fee27cc8977cde9c0e4400ad9c6ebaddef7739eacc0b07e3df9329f2f36a2a055d234cdc4645e73accbb4a58d93d92afa9e6191a3e8f1d04893d916b579342db2451e76dfcdd740c5415532d3027160404194ef4886d76e4490c24f3763ca03bc5f311b3da4f47a8126d707d66cd4f700d242e8a9ab6a4faf8668aa88e821e6d6a41d69b4847868a30a26711d791a73ce41d9d71f9391ce9da725748c1d8bbcd18c8285495c233fba400a63074ee7c9502f4f335aff7fcae5d0e08c6e334e236d37296c6188d3bc947b2af45736b224440d2108dab4c5ca675b857a09f07b588ae70afb245515355c302062b30b2b9f7a569ca0bcdca2f8af92cf02feae1a19634b62586ff4e82c02a605466cafb5f40c795559b8275a1b8a109a646c4ec1a050aeb3f2b0c9bbaed7f0f4e35078fd08b5c89b6e68c90ea332bfdf041f38728fb76fad70c255557d67732e68cf996275cee4cab500bc6ab6ea60adc23a7097a8ac9d821a7b1973adda0225012c6f8df3411f38911bc3c95d05c69bc04dd40592fb446021f784cf1e9d0382e5cecd37c2ec35a50d4db09b7aae3d3ab4e3c9373ee897e71e6cb0385cf3b3759b58ed8a742a3b05122c200fcd84ebb016f817dacae4688534625e90e78f52e1d004bc6901be154516ac7ea820f341478f29b08c406111d44a7f1dd42ea68a416020c9e5cbc0dbacadc7ec181b793159baf28bb98658445fe9ccabd9f512fc26d90f6674849a8b35825fd8bc263ca4811d788052d2bb8527f8b0d1489dc74c7b514e22a0681fffe0722802d90638d7eb2ca9ba8397e4b7188f5fd55b8d7f0d74e40659aef636ecbef00f414f9aed6c7002ce84326a6e7301628bc5d9c5dea71c81a2c4a835d26da6725785a4defdf6d2f0b8f4e28fe8d55f72ebdcb697aeb77a8747c8c193875dfc8e79be2c5e1965aa0c5b861e5267837e7a9143852d0fab384793d8483a21e7991060dab87affb3e48004142ecc4bc7a08081092b9a51b7c1dd324966e03c306fc8cb8e59ebe2c1e0b5e45ed259a310dd9175f79b086b77d82d23813d46b65221dda300cd66991271235cd7e70aedb0a3cb2fbb8a256a861dc00b901a62788a1fc1edf8da518772c18deb7358fc2905c41707c42a2b568041cfbaa02e535d24a6d28cfb500e4f4ee0d165e951e2b92f2138380ee2f3aafb76e432cb527dcd4e6f2f01db592c01bdeef05f3151b0d66f4fce85834c6663a6ecdcfc6e40e7d0320241f652359d22dec92a0963e3a8e411d8f5ac356caf47a65cb777e1eeaa8b3f3d518d8aad8f35d898a3ad83a81444d563038298676a52ba683adeabe76dc3992f46af11569042a9fb920dc8369ccebc836bc2eaaae688d0cde411e3a87abe4ea936ff2fc256f8a2cf5e2057618f1dc5224cca637f5b65dafcd0fd755b309012ade26689b5f7ed48cc3b9572eddcef55195561b0b1f37b4afe90b09de162c27a5c1e103dd1e694dd91eb61fb6b1dd657c3f23f1858cca2632e64f73308d740982d6f38cf57747801f241ebeef6421de0ed6aa70e0f9da05cd15292d02fe2a66721120496d60f8b9f818214d12c01cbeb942c601455b6ea67c5650ddfcafe60c62321e0a7416ee50a13c97284669f4a1f42a627a2fc1f8af51871829afb9dad4bb7807ba167d9dfbb459e54540b4dff302a446d97f6cbe0ea521d97c6a1c92465024888f6700f2ae9825ea95b73c736e06b7b9b4aebe096ed24d416e7c749995b21b2eabad295284e331c4781c6e50dfe5da1f08fb161246f841324707229dde5b0899b5d9bf0959255b8fee16ed2af4dbc9e74d7f2cb3a341d9070a595a8ded8fbb5b2d1579e2e4db8f889541fd02743e8326d266c270e1e6618ea79720ca27032ee44047f10b234f8f0510bf5706f6d2cf3c7fe186ef2a2f5a5865b0d3fcf14c8919dda0f0d781678167c59e1394355d287094abcd1bd4c408ff17db47752adb2ad72f5bf688f08974ccf3a9fbfc49f6fc41d2759a04b221cc92df55967720d15c89d0774ea914025727bf0ed90ed34984091d058dbcebf55fa8092b4e76fe29f7e2b05f47cb854822a734dd95573899a47ae724044f1c00459d997f225b69346f57c1911424e390b43b954150ccd1e2a63128969c1ef7b191b59ccc0c9dbab2de22e1709c9220b72c70add0ba52463dc3e11bc6b9ef0ac96634ad7b5171c54e24e76611d63072d78b4d2cbfdf01710f02fcc4324ed54f05815a9f5b80d7c531724e48fa4b8eaeb1231f2daf9c8c5f7a241628de5da7a0dab861239e8585418aa642d2be52d51b52ef836c27b99b8bc1dfaeeec80dbe64064d5c913a6646bd6cdd0ff205df5efd97d04a1538e56284324bbae015d9f576b8e940141c10f969440061f15de108383d19a512e2825677f1ebbecdf9ccc232163206a62053ae330a2998306d130a4a5cb7ba7f1165815c449f29faa8f71ca6881c42ed193c9c88cecafef7c1e64e98b912f74598fdb606bb665af77b37fcb8cee3346ad3797093322207e423f2e1b572dbad43cdef4f3a15b9cb27629b2826e41c78d0982f195811d9490c3606a04613b9cc911970ce3202830b60671c901ec2bcb282fd909db464e045111eecd1681c543c61ffe54161e2a7931f4ec87e449933e61100f609b60b6ec99ab9b0b63d22a2c5736753122d4170aabaff82ef790e4700d48db46d5b96a3156ae68994af05ff16466cc5a0d67d854f59da3eb1cfb0325609fe1786af918044d671231d771ca208b7a4e01908bd10e9e10e06b23ec376ed2af7b78c1c813144e69db42c494a7d709f4cb58a901255d2485b1e2252f0517a66651fb6a00e2ba35f914d34b71b4cde3422dfe2fc744ef37adde9e0c7c8d342edab6d5c3b5d42021469ca1a1931a9bf6dca3b564bc867a33c1f6329ecc6b1cca797f521820bc9da6bd8311d2750907a8b644c8faf9f7b15b1ccb12beccce88d3b58915fb330696268212aee188f345c632b6c346c691904f13f8da7ad131d9011ad00dff659a4b5530f94eb26c60159fb341379e229c49cfecb5e4ccb2f5b914a9ef31cafc1186edf619d2ba59af9877de4a6ac75c85d2427cfd2afaec5ca4d3d131040b8cc48a1dc0091285eb39d2ec712d8fea24e8576839581b7b13308fea69686904f44d2387b6b5aac0183b6658907768b03187f735be7c16296259592dd528fd11151b4f068e7f070f40ad435af88f80025b64bd90aa2bcf748f32553c36cc43f583525acb9f4bc61c7021098509c7d151278788483df37f35afb96b76827b9103076eb8f103e83bc53721a59274adf55daa51877f02691a598c21da21d64caf9707908fba6fcf315e7f7210897afc3ab2938b1661f9b728c0eb5841fac1e29576fb2e8c9570d4a650003555ed7fda03755a5f0360206b4bc776679148afd2a0fbbc9528710c48c0198151bfe8c162e685727bfca77361c0150cbf50cf48b1cbae37133631ec31a733d618dc2f848fd63467f6974f6d5dfd6f45033612f0f2edd36c6645c9563146c6bf7798adc7b8bce89ce075f6d04d6a57e24bfca78b468877237740b3574dcc6a94a2b099cc68fb9fc05f23598956160be52e94fac9513af9f8e945798f2eb252a7522ab5e0fc8cb56540d355c608f20d6caa14785eb02a3c6132143480d4ab2d05de98b6163080333dabe37660e96b6e49f525e80703ea2359d7e1643a15fcffa236b64ef69d7b83d2c0376aafbbbcce48e87bc785e2efa3bc4651a75a0b2740735a14f72d8d8be6d5d36826131f896ca90101af6b5d1decc073db6798e9765dfd3831d6df7a64ba30407dab184c47aa71a56a1b1844b009318f0d38a16c4277f7980c794cae072e20bd6ebfa501e9a9453fc27a46d02d108eb5ba1c2397807b2e16f72fc173d5e8f386099fccadfdc011da7623412a497909c5f77df4725cce0673665eca077fcd919a02f5d1bd5a861927c21f2db75a32b8f9c4ff9134eecff716d0de43b7a1a65b9f36fdd98c6d53773077ab851efc6b5884298434eeb3bd218c62a323e631b28274853bf2706356fc747137ffcdc298410eda0cdfdb6c6c1288baf15c7b7329eddca399357302f1381a6a8d15079b8038719bade21617dbaa3af28f33cd5e1b89a0052edc03a539c90c94814cd051f94bf0011cddaa2bc43db21901be5f3d26c35b2c79dd6c11889d0b8ccb23d38368ba3e56cc0ad6027f9c737eca62dd01623354a37e832e98b7755356bd13ffde3704bc950ce3e12328db8d4cae4bd46c2910d18dda9bcbf1625ef29eb14c463ff7a2d76cf89a95fd35f28fa0c1dc57f2469c87238c2b02599f53c91a722c8f2a97243da1eaeae2bb6f36991694d2daf620ca1cbca7606525ce2143c07178812d11c71b594976a7e2873581b6644fcc2e817fe5efb6e571482fe2a4c658942c305ff9384b6470d1640efd2170007afb72037fc5fcccdff4f4d5e2d25e02609b13ffb56633bcdc3ffb5f692851e45b7a9ba04c1d554063a791224427f1f020b13d8f028f084ac984a46b35d7fd9501abd1e8ab1e9bf6248a2f1215042bf37b51f331ebe6b84a5dd04fdcd844cb7a718e877c50ffd6642bddbe40fea5984e0d2f02f06a937b77ac296eee95b04ecd49463aace810791031c15e9db6167bfe9e9c59aece6439a480aa82e472e9a046c1ac6ab5454b995885647e2f52865748650f9c15f12e56b9febc8b6f39932aa079a9c2deacc75c60cf74b7385bbfdefdba81aaa4aaac2329a0821c9f409083ed2a30e6b67127960bff3665170b610a446772b25cc405145cf8a33a94aaad9177d9b656214446395929cffc11ed333191d59375fe39831d0ef62c46cc89e55f9784056b5f924b9d840696b2cd20321336232cd0992561da10d0fe1f5e384038bd357901180b06e23d251b3338270c5f7507cd2edd41bd9398cbe7f10de78edb198be45d742d442c73d825b87fd0304227694aa2e215ab0366ceb6b3cbf239a6cfe4ee81ca8e25d798ddbcdc7623bb960a85c2bf4f8ea83264ba94f042df4f0a99e29e24e813ad66da2ea8aaa9be30ea2e0eafc310723ca69a9b1c362edb183d2b14a819e098db003073d1b63f8a4ed74646a48c6c55ea7ed41ea0cfd701a004dfe137cc582b7f08798d75c7348d1f009c7725640403aa4e7fb62133c89635055124fa848ec720429a9c528fce3ceef21f181f0282e560c10fe89e840be4369896da474b6ffad12963ba322d69423b5221202091e3ff4987637d33732306f3e4db4fcdb9a79a93259f385aea665be50d99cb8daaa70151be6ab5098c4931bb8845f4180c3656cb17e232b9c0e7396b54b182e08f1fcd56c0add558cd8eb265cb4b8543089663aa963078c6e88672aaad25526075eb58e967c09c52b4117032ff9773e4b4603c5dbdd81180b695a136bced19ae51e40eba963488c99477f0907f31068ce3820826bd1936866b661b7c10f76a7df6cc28747aeade1326453491a3a0829a7e567cbfaeb8dd175fc96c8815ca71f537358e014b3e37062d760e248a84342cc6c28a9cd36d4038d8ff0f8e97feb9797ebbb9a2ada545e467fe59c4f931b95502e0adf77aa18d78a30d8a0ce399f9a3005c1111e0a2ab03f64c1331c1703fee113ca5843ec2677267647857205194a1ef4e05651589d3b3193aa1aaaa181d085b8b1d6e5b8edca0e98011ea07bf5222cd5d78d1c77532e540b57e7e0e29bffd92823783c94bcb3b1b225b9cf7ea49158b1d4bf2c0d5e265c2005b12247c61d28b643a029c8ecaf9a5c6574727e720e0aa6b078a254a52fb0bf454","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
