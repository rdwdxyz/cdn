<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6dfb8ce3762aae4a4c862d6bdb77a3bf5b7089b050975afc38050821a84838420c47f7af53d6768a56f7cf871eba0ba699bceabc76c76554dcf7dfe467c4b270ac731065807e1a150a1edb18bfb08c6860e86e6fc4fe2485b409198115aa9ca0a86707d19977022156f66f26a69291ad9c586ba6f9fd010e40baa1975355980c7eb27a7c87cac296133e75cb07aa4099a90a0b8f2b1236d4f2699662d25120312ec3121e655893b113b1cb28aff11f4f7e71359e4b31a1490f010b672eb375fd48306054e3d7c21b195477b03a20326a8d69f4e7bfcb27e9d47ed6c340602d830ad58b7aa42b6a6f2fb99eb893a3bd224e929ef074a83344deae619726d0b780966dfb7de534a5458040926985b8bdfe148218df0a860062432f5ed56543f89520f1d63d0470fe8413cf4f9b907ae4329571039500e7064585b76bb79d506effac8d4458a41dcd1e66261288faddbcf3fc774d5d492f2acb396cc2aa9bd1006fffb67e6223989775e7fed71452e16e526bc934fb57e24caf3ca5bbcf5afcd788c2bd0e2a7adf39186b77a1638a024bbe1b55d9527c342274305db730cd2668ecbc2ffde4223e4dcfe9dddaba61980c0533216441847ae6391949d72ee32937347a9b8f459f27ddbf936c561438336e13761e10673b3fc9ae9ce30cf628304ccd28d5c4892f16ab02174f74c891090702a31c36c82447e049f21f43d48996109f52dbbb1cc5656dfaaef8bfd4c6b8f1856e81d6e015cc613d64ad5ac72425756b1a7884861bca56b453436eb7c86b06833003f6907e882515f4b936804d0ecc9dca9eb2d502300a6ac139d8a0484f31021ccdc92e1bec89856754761364b525f40822037fa2573fa2edd86bb3870bd53c107ca1aa475d8d2647be28d5da07d323657ecc69f69104e2b8395dc5c2c9750becbed286b61a41dee09be4cbb2ee2b849fde9887057a49873eee133a46d43605b93080a84da91914e3e6317c56782a3b736fa7cf02100eae20e2c4cbf20aedd4511c82426bec4cbfde34982f9691781aef0ca1813cc80de25c7216e74011609e904614c56c31314ddb8dfc621e219924f18e6688620f7795ba1318e83f57d68046f8ad0ae67f63d31091b9b78f1548b19bda624b6ace8e862d5d0973ab29c4c54c98242be9f60fc306e2ef261ec1de87453f9f8737e671aa06e5f202e4c4c6a26bd02ce7383daca63a967d93a899650b0355d81aab7e0ecb2163a4729889e38a2a6171dae296ae91427cdb083f06606c678e6ffea666db70662bceacbfad5bc4cb0ec360bf20a7898c0955b9878b330f6a948d25f4f4055ebb7f13255fd49f2ff3218881d8908b8a252b1e6cc1a6acfff27ae4e8809d809d49ee12d0848e269d230307b38104e8f4a57dd9d806d2c207920fc1b6949ee738821e367144bcf9f87bb65ff4eb21605b5e592335bf7d4e615929fb88a2011c6e8cd93c96ef42adaeb6637bc5e486cde2a00cdd74b1b29ac6842403a2d19f9f916cf41ff51830c73b0042d1389bdcd215b5c61c2f3adca9b38658f54f98b03ba0510c43d005afb538753671d9a38b6ed18c13a5142d732b1ae4ea3cd40edb6598495c88bbf28b39dc83333aca75f247f81d6bbe5102de493c8795d68663b01decfce7945e23aac0bdd9b0e9c5b5613c7b8ff469f63893ff0dc549b6b39d9796fe2915b37f531c2bfc85cc0eecd879b38b1c19df7cb5e43d452e5f424ba95afd42ec982fdfe96a4c2be01c137ab5269a27a702813a037565a62917aeafd2ce4ff547b633d3f8e1fa959f0faa8eaa4c6392b91d0c5106e62394eba0442522a362bb62667431b8bda5b75e0f0c372235c730192e3f029fcb6983e697bf4a37070817cee09273d5eea9e65870de85f44c29907c679e9cbc593f9c6a358a4bdf257760a70626f5e99f3d5c86fb7cf5180de411a86b5236fd92ae088b310498145a6e9d0645ac690795925fb1e7fe82b755186d4d5f2a6a5e2da32683455603892578fd595f718d67c1a0a04d4f046ab6f39b67aa3cd904c6b9ac15db97045913037e164ed70250133151c518e4637e5b9b857476c7769535f649fb10308da72c7206c4e69d407ba6d1196a5373822f75597c72cf59d2e7cb1865006a3de51936cee1902708cfaf1d858ef3a1e76bb5945fd00bd199765661de6ecd755a959a50f2395d0d0d19e12d427561965c62c7508ca1d056b4bdbe398343c141eec6ea5d55274cf7a65c5d718f1c904be1f6dd08fb8355f42391b9f5030f40d01cac891c186c7f873e974c14d1d08a73e3d6ce7e3b0dae57699af43650eda40dcc7fe171026fd6c7ca2f1470c4263d539c334c7334a80de91db3a12174c20256aba6aacc4e35c933b20af9adc34d47d9f0b3958790f5620bcf2bc39d19e8a5ec78f80ae8432ff61fc9e6d22daaf4ed0dbfa39a7a4a6cf62ed2197338d685c520dd2cfcf73b109ce9e0e425c6feb23b85e8bd1465d495faceb71bc26e8c7fb54aed46ae4a89462cdbbb0da1aa725a285056bb11e5c0181e232edec1156e18ed29489a9220ab3efaee8e5f8dd81ecde5c7733ad1b0aded272659d0caf56a38d5d2d91ef33123ff4a90896055e03af4ad6897b521259ec818fdbefa1923bc9444ded6b4a3134bf9320205403c92d49bc5b3f77bf33c5051f12e9ee4059173d41e1032fa953d3f473f77354e01859ed5661ea1051546324e042ff119d6e0911c91ee55b6df276ae315ab7b3cae189c23588aa15f34d6486a2a07ca38d965b8d484fe43b7575a0fd13344f8484b1d98f53cc3c1d0833d020b03db978423bd1150f00e977b4efa3781a07d83156001da72475a2931e7102518fa81da2758fad3fff55c1f38e515ae7b05786ee4c6447314b76fae20960f93c53eaffd367d2c2f93afe277b6a3d95cfb7f124aa9a4c74961b900c92854d97af6acc2db9ba81bdfd5a9dda0c2faa06f22c7cdefde9ae7764206ddcab822a678d3aed5e0394c7ce2d095d94afa1022ceb1a58de88e7d97c2b9129f25cba8523c7a4683d1b832df510a7ecfced6f38beaa8fadf7f459978063b0de5df79f96d7528c939b99ba1dd3e18e72f752ec02f644ceac35a768093ade9b82ad2d9031eae733cf30b62b29ae9f4a51b85475028f8938620699992a55dc4bf58d43c9e0d995033d0d08020123c43e2fa04a485dfb22383b06f1b11e15bf73e41c1bd706c163c44f5086b564488a95070dede8548370a58bc51452bc0592422c5285408a2bdeab7add647be9fbfd73d92303f594b050188a1aeca0f7dc064bdcc50b9d28202df6b46205ad1065d7ef144f524fd6ae31607a6fa7da9519f60a144c4ad0aa55aec8eee12a43669b466ad518820c314914d91237a5e1d4a0ee6913705c171c9f53da47d0b04829037aea5da125a9a245192bff993e1777ba529a2bea2a4a9ae6731fdd4c2cbadf3ff33bf96d202b68338310626466c913e4e8dad70e617dd87e45adcba22b365e0ff3769ec9fe7dda1c4ff76611c6999640f7e52de478dedbf7f07bdff2d6fbf7565f88ffc831d229595c4619b849a754e463899050be7dce83bcad3454b26bcfc0e9f4f85a36a0215d0fd324964c2a5bd271f3fe8827be6c6e88f880abc278ce9e52f20f56f38cd4c5a0667b6da3eee2cfb8d2f33c1c8edde58665b0108664158e4dcf1753d41b6af20ec947b4a05135c34d1d665a469c96c9389fcb9932f4aae9952c130b4a5ce7384c2c235a51d03459457808872dbbd7f2398dd801d17232965d3a15c459a4878bb05331c65191d8db02e673714b3f39b609ada61e8c0e0fb2dee5e2a702eb7e9d6c071d2dab26d2e9b69032fb797cce45ff3c1cd267817ffc3013f695ea1ba1d2ab3a6b59247a1701be14799dca8ddb8f514ee85a82a74e39f7194997ec53e81645d6c0651543418870a37e5ad92cbeafa313e9598b18deba85efad1b1e44c19293acd926acaf74445d2bf599f5c35e41a418ab973949c93fc6f9e92ab5b71e1f4cd5314c82002e5c4c433315513daa097f6ea16056769b2ff58800e2904bcdce3119d420d70938602fc22359a36a35ce717619fc5e3a4f0112d796daab87c9d17637ac877146ef9fda3d845515155f1605fe849b0e0809cf61ec1299c04d348c74d6a5e1b6861b04d287511ce5c1775663a8b8ee6aa8f855bb504cc91836d0237f8223af803e93a3cc379ed998969ac4232cee1198e776e190820ab80947e7dda2e1b1ec83fde15dab120a0117e68034fb0212510cc0a8166fe0b376b36ca3656e9f2919907f17ccfbd1ed1d5048c58c278ddaf0dd2ace9e420369a072afad0e26db673f69829f42464998eefce697e56b1b69c1f7f481c3d9430567fa994ff01e6536e7abada131e5bf3eca56079408936966637dd4775222833f0267376007fc83bb5b0c91eef6680619845a142f4d73c541f6ae6ba830dc06fef02b32468ffa73989277eab07e5c58f0ef598ba93047effd16b75d1528dfada4d403efd09fd5e1502f2e23baf8e125f86b1e6097e401b5afadb981eac75794d48cf7d1427b623f7fc49c14e5d932b7d8691d1e23762f2234603164ae627b2412306c3aa42617798c749e8eb7d7651b0050a26f7b92597a6ec2ee43a01d6b31ebb51402792dacaf5b79a4d2c705513f7ccf6ae586fff6fcab936465d982f964326a82e01bc5d8e84e02600660a7b48471d60cef15059c24b6165279db799163e008952f6f14ad943053283c5a2d5558678e0d0dab2c539f8b57c9d8fc09c39acf1b6551edd982f5ab89cbeaf6eff4ccd0e3ba0cdbc47f68fbc70bff521177d3e799ce4ea69baf19112b953f58a534a1794b7d0a9681a3edc3132247a61c8327e84ba14d82acdd17979450b301e86257377ffa5a634455884716e003477e906d10e84bd401482e1174581369e7943fe7c2859e1253b4356a7607be716b594077ecb4c8a9d6e124af0fa6144b4319f91dae3fdec86886971743d175e5bd518862d66a9642483ca0edc3981ef8354d2f11dd38f447fed32d23945496fff5c1197da2082d43f3a0af36ab9b6f791cca9520296e62d9f4451bd2c66001820420307b10c88d2a16f7be2a09d09376f418641d3614f800ef04fa9a51dc774852b3c19f7b0a2df5008fecc1c94ad13cd03b2b8babb5aa091664705e4eb66a704df4167034829fc160079a91c1a7dc32125f77e96447c8668388567b70501e1fc3ceb63849a2f9b2e33eea846133af17340dd9536414389c2e153fdad0beb596c4f1e91c24abe9de78a34e613d3958ea4c10dfdbb77eea33afe57f7ccb8b01edab65b0e7afe97fe104db532fb713147a3c1103d399836b6457be6ec242d5805d45eb408de79355fb5d4189f477686f1a266068765a2f9503af966665c0061eb6332828b12695a7bf31fb9b27a52e267460cca2d9897fa88227db484494534acb7207ef4033d143b0971798ebc13afde3df06069a2cdb58bf707faf948aa33307a3465b3ed9cd6aa232b8e1c1c24bc3f412c85fe3714a8ae65e41b034f8b787ac5212f6393757a116433b2f0a96ec669c1749964c243762945b92a48539d06136063c916f14641ccc6a2b56bbc1aa187532fa5a6203194b2fd0eda114f2f3d7bb9590af642c8d8b582d8bc158b55c2777ff55639015c7ae2b165b7a6890fae5b9a83d9020c63a790e859a695c05ae7eeaef18fcabf2147775efebe203d3c6734f9a54155a3d27447f0c05e3c1bde0b592072e6cbe7688342b553e2cbb051c74430f4e6016e9840174ebb596923c6be2d5de8f184eb0cf2ebf21ec0fc8d92cfa38a40473afedbe7b986dac216426d7b70155f0d6bf486df2118c8c886ad243e79adefd20d7e614a0c271698ac37344d843e4f57d9080b77e34b5844ba663747cd3ec4c48a9cfcc949d4abd2028eca50290216aeb3f21871c9f2bae8d81ed88b267b0adda945567d49188087e68ca39d51b78c9b67f41ecad1637ad3401acb71145215a0a787362ef476946655a62001c36b9c8f56e4f8cf17b2ca1979a5cd7cc572884e0427cf01b95aa1e8fa5d0e629ce409dd6ff8b77631221da0c107758bf7ebcaadf408c9872b990b46661fb0afbe831f69fe520ebc00929c0b03e70d2ed0f84b254aaf46527e1b60adaeeee9784b161d5ddd646255fc62c0d0b45e64da65aa218804712adff42a0064a265eba0f292ac41ed67783620e738d034b09f0ad17d1c6009e7b9a8f7edd07df1960b570cbdceaf693a07aab7d493fd0e94ff5e91afaff382eaf28c9d70344f7b3ff08934be063aca1c3c44ecd9690a30f01dff224b2e814d7de597f559f1a823275b4f5e1f333c2a48cbdb28fa3d2ed8b9fa0c102aad9ce2d186b8bfe1beadb1121f2b5795e1960601a5adbf1bcc2b591abef5d794aaba0ecd18a06d8ab6b465b3e9d33d84e5bcbf04d0fba3820f8ca35e27384e6d4d5c18d9ec4ff73a6aafbeb600ad9803f41502d2d33381ca4df445a003d7849c5b74e15e806153028b090a76549819392b7c29ad3b48ad414ae05bea3250bd7ce600679f65d63c8f97bf4eb3aa981eccf0a27972d555049d6cb6a5dc031e192e4fc7dc65741364ede6e43fcbbdae0b1fdf38453efbd4c6b28dc6cc5ca3ddbbccc24c7b37adb8b4ee3b216684558c9b03eb230d62a30d5cdd913adc945fa5e8c06f6ec6cd3be9dff651767b6b3bef4ac406e36f2779f1ccd843bec081f281fabd75923c03bb86727b88401381af730ec45c086cf1c8bc25738f4cf15835ed538addda54c4f63ec2d9af97b18f967e69d749327fc9d7ae6276906a771ef7585faf2ace31f2acc2e595a0ee3f7f99048afa0b129664f52b1543add3fc39910499891376fe0f3b8179301b1ecb4be91167ce8cef71106a969252179d0a165a8f617689604cd6a53cf3d2d3c3f4db9d7daeb0bb27db575061251591bc44901ad7a66df3e1b16d5a0c91305dd4e75d4cc71e00c3c94431645768902d433e2f044e5935517bc4304c34d3e350fa8f7b098748ffe22dc5d439ec3453ebad6eecc015d444f102cdaf629976df4800a11d9741ea7737899a5c91b3e200033c515508f5ef1a63ccff387b48c09b574d52c8d97d5c9888a26b8234ffb952746a96e9f6de27832099fa730081816a15654bebc2cb91a610e4575e4c45edd0b97bab1fb462cf062aea8489c10ed7c017e192f1de8da287881384e576c2605d1c1952396182572ec9e7cbdecd9a6937c636ea0b7cf3e3d4f32b21738191d0468a748220b1bf5ed1a9432b9401b317c536cd74e3a4728234a73fc8e6bfc9b8cc5af1e0162c7e193733d4147af831c8fbf79fa4873f225e0e28393ab27074cdf5345b9bed5f963357e145b71a29bd4464a95b54857e0b700aca38a5a892f01c4fed3db15bbe9ea36a92e0e86b81c89bbbcf981ee2fa8184a1e44837c77f286682e4dbb377d71efad69c62bd10a1267034d423a72e2cb263e2f561f9254bb019eba976d79a154be9d3a9860fb5587e50631a1da24f4be0f05e1fa9245c506ba9dd6785cf677c1975eda652fd811bfdb83fec2403780f0d4ab5f2b4938bd20285d46571a8266d96f807f25f23a6768c76250f781344f45173a227fd49aea4f72310fbf46022df41ab0ca9b5458581be0aa011c9082e697b57a739197d050a3839e743aabd632dbe87dd658b0d32408762b1c8b56dbf96c2f58fe0573eebb54e0cbcbad26014f4fd89693bc033dc823c3c670185ec7d90ad6737a22dd32f7dcf8f77101d9d4e0cf7a5c8d478c44d045f35402cddbffcda6c24e9c63edfabbdb44e271650b62d5a15af0ae6ba0f79036caacb2d844f20a8550a9e92d5223f801cdff25cc04305d27db556d8c38696a2fbb1dd2b4eb2c9f5655358a62cb3d7e278cefe4d5cabe3118083c18c6b9c390c62c0227ba9a6a253583b6bd37918c1b2222f534eada265598f7eb0f37356e4027f3d8d764e48e87e8fe7b843ecd6e3bb4a8f9d400f7e7fea7a8e7de368d247f85496d57be1b253f796b1098846639b9f750ea2382f21ba15058c79b78e4afd1a83e18bcbcf7ad026b383992f832de108f836e57cac74fbea3269d1f4622bc8957de10b8f181ce2bda0ed761ce9779138f5edb32adce69403ddd902b6ca577f356dfdd3527eafb898e548d2e6bb20d9430d4103a9811df5db104886612e0a5e3e3ce319fd3e0ed7bbab8dd7643dc9d024f85f2981cd98e2661748fbda7a0b3370a4888cbf5b71d8f26c55e8ab4cb840671a6fea2513717428ccef91741225b01b5c197a78d26dd55fed5a29a5b2f4fb9ff5ecad582d43bedfb9c507a872ea3c03d3094cb4409ce4786ab8e5719b086ec00453a9f02ac8fc923d9333d38c7f3e06d7ce6bef37b3875f7d5b45bbe01bfb9400c7b68a6252343d46144ed6b31c50e500f8438a201a6137e91ee72cc9e4d3173756e80c679155ddb1a79e247917d5c117daf5ca93f396e35578a58e819e1da2088c9cddb429573febb78cfebe93ea708b3013c1ac311cf00e4d964fa67f5314e574dd6f0340b17c55fd34c9cc34d470f771ac0ecccec18b2dfaf74b491cb128a7036d3fb955d7c3dc3c8923c32743c02a08e9708d7390afe7373f3489c1c18ae99cb80fe285df90f12149e74a03aa96fc20571ea300f876e72bcfc872def8afdab6043441627bf52fa787743fd9ae61a8a4a62e74a5e2aeea3758c1e15bd1af8a78fa974a40cc96669cf76dc0136b9cfc20ab3c5c49246be4a6d7200e58760d3ce14e5b56d5fc53f51509212c299bf0d9c7cd577047d45fcbc1f33bfd02ab57e974ed20e7d8d7875fc63092b484182e3c5c8c349232585d395894358f8ec015c6ef321280c955e0cca58e5e0e02c19e93ccc7f2d4bc399de4d5959f5ebaf7156325245e538bae01202255678dc1a0f4bceac452952040e223f6057cee35566de51df26ed1f47463a134041649674003afb54e96d0ad08813a30c6bcbd5543c3734ce34a5964c7657df02b7a266cc2691614812f4be01a07aa980537891a40ef3a89a1afda477b938a05198790bb5f22799fbbfe8d8f267a84d9fe25b9c6b1859219ae180b2872d7ab3c90edfe086dbc4dc207774bedb3f09edc7b379dc3c21a0309473cdc9c40cba7f9a6789b0a902f7f969441767848302364210a298a17a8d216789150b72f0911afd7ee35521cfd02be30d0a9f1de6486aa899388586f4ad45190c22e667b0cbf7378078ffdf078d6fd96ed596230927e277c088b964e8b55d9fcce8453d20804603f3ff9775fb9a929d4317dcd489af54c30c0615f709aaca4432c66081ee9c168454486be6a9c208254c8fbac19f5d4deae5c0de5ce22c9ffc272f17d83db6a72daaad7ad2ff54c7db033e9b5b37dfc0f7e38f9e21bd6791899e13ed8c5f6adadb445ea8189eb5ea102428ea9e88adc1e7f9c43a92c536b0364c324f28e60df74d5f158bd9aca3dbd60d267448d4d121c0e378584c7997f48f46eef2c9df746be4aac12208d7c2ad3e4686b2eb017e4847863d84b17724bdb3bc5fe45936b1b29169338fd72c7a617b8b8e57f2cf37642582aa2291cd9fff07d526e5bbf27cd2fa64431344a65c819094e9ebbd591e30e2cb336fd5364ac4e7888cdf4a1e402b161e63a5f1ba75c77f59a7341f4c3c83ed3cd0ab01359956434468b683195b7c5c91534f462511fb66a4695b47854958f31e29efc59dd484122a1991a0da4aa8de801c15cee72e7cb99924129d403693ba680291b41121bd23cecc9a59516e690c99733fa104a90b6d4aef61a8a442ab06bdc2e7b1ffa816b3f556ba172cc67271be8490bc8dd0a4be913b544588e4d58eb81c4539acc500b7d4526f9e0d7748a2d25e2ed2e05715d6ee8063a9b6f0e0f2c30b3f5307f66c044a2803b9d37c32605f7e0c575972caed50f69819a3f7196077e484a24702899154a9819ff6f73e7254f088d9184cfdb12ca759d5f6bdd283d10fed9530233f8cb617d19249ea8f149ea20b21e2e21e63cffa27a0a00cb76104b8b32557291d737adf27516100532819ce5af33f45ce0c6af0946e0cdd317719167f8482ba5c943259fe3814d4798ef3ce77b715a356e542ea9d0c71463deb0b06b07e4683f2f9b2d9e72a7182244607d1d5bbec7191b68acf5dbad442511dd47065deb7f7ff5c594906033e04f2ec5c5c7d384f5128ef01c39a706a45252964af5bc5ea01a3843b704de161faded2205956527f69964a14c2b12c054e4695b5b7577ed258361901b5e190f5d799cb9ebf91cb4643315acc418c7059f52cc8f948e2f5cdf8b09c9d1623dafdcb1e5dda91c3e7f72d97b9e67c31ae7f658539001de21ffb1fe8cdd1f683f5fe38b5a2151eac3cabf752ff88ce2888a3adb875a1969d758a9238ee83c4b80d09455c81ab0465b0f98ab29c4b13e8009056b9ca0ab259983d9d31e97216617f2e35c7bf209663c7b301964fd0edba7db5637ff197b5af627b6d76641427081e584ba94b8ca6eed01ac04e8a47c1da0f2467f619914a88a67469550d0eb5890eea5a966ecd93bcb61701b9c1df08174105b02dc08d986c9529570a33fa1f8130a19e22504cbd7d7d33535c86d053cc0c1468659e27aaab028b56d51a840c5ae550eae6881772033ea138b8b861484ec1a5953daaa37f7cc68d63df5f907eee176b2e5768ad26731c39640532ffa7121d61a35a4cc99fc297ef96c98fc3ad05d2bf175d853fb7d62508720003213c644be9e650f8710b152ed7d77b6707b9e839bc4496820dc9dfeb5b180f5d065147e9c921b44ec1678334ed924d56c3254ab2c94e8120be62744660b12adb430827c0d71947c6c9d729b55a3d0ce860ef5d9c095e6c240fce2a6361bdb0ea4df6bb205714111a937e5af411f2f96b2b6d033a3bfd8259baf977d645bf572a86d199521eab247489515be93e4373d8cbde72080b366b058b0790b2bc5e2485b1277489058f00dbc8e1c73f07bf6bac7a88667e33fc83da363dee147c28f6e9716143d806975331f8fc1c51eda194368acc256faa5d4eac42caedd10e98301ca48e7bfe555abb6bd8ecf5b9e01646746020071ca611477c1dfbf224cdb62b28a16839c0f7fb8943992102071b0748a9d57582f693ee8ac07727a57e073281541ac4da77f8c6c65777aabc3160acc274bbe035f2893da878f7d6ae324bdd643286ae1c9668384e15356fee39b4c08dc144f21bfda21b1a9f8296b6ad05caaff8561918606a4a329edc129220d7a2912ff5b1e50105419e971f22b5e445aaabefdfc9cd50bcbfbc496ffac2fd0e43ba67064cf61e0c599fd2e30bb5d5c89f48afad628afdcc906d72a99bf89f24257d7694c837996581407b7ca29793372cf5db461543d9f6bd2ab7701c0eb8fb1ee4f5b5e2b82e77f8fe15454d1dd26daf1834f7ed6963c7e76db737b77021b768e1a6c4e92407603977892b29e83ede5bd0bb686e62efaaf926b17e8fedc293ea779018ac4b7476ccba82748079476ed2d4b69fd8e6b144383ed2110cf7db903124f5ea06f670892a745317894bc7a68920b2ea403495767de9c7977812c09964ef74084d6958497df94dd3c4f490054b75025a2967b87a43e2fc26a8770923a6097b9e6789446dbdd82aaaabd6fbee9249a231cd341c68134262ff5fc167eb3aa7e6b88d591a1af100921047b77b76e786158f9d9ed70a7f8ea61857ff07c086b1a5bdca79aa5fa8da06662541800b91fcf9b6873d89d835a54699da7cea12e6f7929ce3ea426102e139acb646e3ae3cce9360082a44829ca52034831f1eaebc7a3d3ba164c753b93b439e1b8582b14c859584c98866e06c81ce8d4fa63c768e8e0293249209901dabc88c3a588d4597f51191814c9be535de94dbe61d3542c7f19529e7d63964d64d457e4117837fdec34157f579fba7562834b2df9b0dcf892b3f56cec2e514721d5fd983013a381d53c0312d9717252da4f8fbbd6a092931fe6282460333c171e765c4681e270f0e43cea110f175b2a9d8228fbb601117ce5dd95f0161126c0267e9574f4ab330d031249591722fae70cb0e683c78a474289d8bab233ae36506201086528506321f5dda50ab9158787b08b7f42d9ace9116b7646a4613e1ee56daf0a1f23910994233a0af730aa11c3113ebbfab5a7498d8b37017a4a05b53094195b82b8e8ab6ade90358d9db014011126518fce3c3e67e59c5e227f47de0d467db2c25ef383494b7016f2abf5d16cfbe9d904486fd85883f46f12a418ceafd4a64f55e167f0e651257754e60aa671efcb5c046769703270ad2726f43871e554c5f865a5cc82e795cea5026d84a2045301cf3ad88a2a21fd3d83dd8607d269efc37683cff340aaec736dd4e09b2c957d08b035b5d5d6ca9333a62f361f9853de1375107cf784823986c3251f144cb38e39a5397a069efc63fe6cff3f046bf9a3e1177e4e9c5cf5738c9719a477dddf6b5ac133c389db5d71d68c0cb1290d3ef5e9f0c94d850d58656c5107f6adedf743f21290e0dcb13df557d9c2ea75cffa69a6504f6a740b6421b74e7ca60bc4674cbde97f61c0a1fa4364ac413bc02d7d4119c4b184c2d43568fcddaeafd962b30b756a28308cced573a0a33f43b7266abe36d306fc93294cb7a483dba533e654bf83163b4f975a5bebf7cefc558091a641885c8980e322ff17b4e461e2472893ce3ee5654b32cfdde95d26b1098c08fc8bdd1a0598f7fd8e701d40ea36b66f89bf1a4b76a693495dc4e4fe1de75e6b5c1b4c6e5ab131a616de123dba94a1f8db4fbb7e15de7d4cd3ead9d3382f93a1f5505116be0a5a6bcfb200eb85bc5c9616e31e91b1a78462d76e9a5bbf5b2f94d2f822c943b7d7836e22803324e8498ecea64c92265cad0082c9e4f502dd13e295d883bd15775f4198667fca86d2e2fd8f58b985257fca38517ca5169bdf14c5dc9a869109d0f40e7bb9e989400f244c44d2ea37987d8ad2a4b62cd4d0eec04877190be78430cb50623c73d6ad1859fda3850dac5d54de056191410f9554b06f6d1158c699c321fa388b72c8f807c0cf5199889572dc12373e2d6877539855d185b3c9c79ad6eac5ece32a2fa4f547b8934a64ecd73de5526ddb30bf892025854c33cb299d26d830195ba2664487a2b921defa7d05aa2b3ceb3ccf28369eb2ac67ac9b98a24056f15de5eb8aa56cb789d82737e57f7c617486b83d37106f2b977818121a9f83de7754de894066ac5a69c4eea3b671f381da6f9091c1bb47d938bda670997c111006f3d0f424b095c8dbc5104f14d2718c88879d3ef0299035894824da2056fe29f759cd8dc51f20648b1eae0ea3e557b49607cf62770764783505c40607193d4057a4e63b19403f3d679530660b049f6171f11ce627d280c540cec91445f457a9cbd1583813d89b28d3e75dab7b632c0d28f4999ebe7120f200b2b1c87e5b9a3df936ced884bd702af00660bb7488558edda9f8197847b2f0ba73edc16ee0ae323c4b4687562548e88b0cbf27d2a5769d5eaeebb75f79124ba9aaf926417f516912d7cfc3147e8566cc4215f768af4451e28a6d83ac530998a35084ebdc55f0c40154f417b8116894c18e30fc9338626f5892132cef794f9a5783e381ff7115cde7b2a438163b409a9519e6f76d22c982df962476ff8d5a512c45fe83c284e67f5d549d554871bd8fe11e794d3e6cac7e2ba9280eb5ef4fa2272d96e59f0e8a06909d14215047d6d99c3cfd70b4bc9a2020e03a25f7b1218a3c2ce72a69ef487c0a37b4ef529ae60634f3f5116630fb29bf50cafced0ec6b585f67a583764bd135138cda60f631718560857d9554121f23cd20bc0ae85ba88db02cc5dacaf812062637f98e33fd8de78baa9e088135d4220fa5f591bfa0850b74ff3dbb5693a5206cff08e6873303c6308dbb0f6759dc90ae41242ef5d6732d1a77bad298857bb6fc1af43e5882a29e8fce0e0b29330876012b6f785ee6c9ca42afd3b1a3ed1c26b8bcf4947895255289a9009d9c16104afcb8335aebed3efc7bbf5a4076719b323f5c17260b12078a723e8788b0747a498ffc4d03c5b44d0a61bb1575c27fdd8b83f0e537bf4152aac305a2dd3b8696ee0c4cbb2d59ff77ce70bb17563c7f1e5dfcf2cc0843e36ee5e5ae40590c69ce0c073d1997b3a116f85e7168c1ccfeb3bd27a379e46ff236150a1fd1ddc8e08cdf8efc93ba4d1be4838f37afd3dcd9e9b0a449bce21b526520550b2a799806a8cd26eb50b5a142e72d49c494457ecfd2475ee40cde150a9467fd8e94a791b289d6c4649667796e26e3312369f51e434205534e0ca1310c33ca6cc51db9f248619cca2a21920a9ad9d58399a546b920d3a9685b4bdcfa525f03835840fceb30e4295efd879b16600df6923603dd4bf0c6fef7520037b2447a2238e47351503e21e202d0eeac7512bb5c0d56d245a5edaa7e60d7cf20a5d1d4c0bab3a2c847953fed0c495ba96d18f7cd91e74ae548d1a1fe131e1bd0d7c5e0f39b200ad577533743c2af58f7b253cee10da44c33dddecd8c795072189ebd75f36f115ddd83b3b7075a2178a7e0b0d58636dd9a9d9564b6a7d90ac080ccf4efc0f3f38fb056352b5208c3b149e989035dd7b49373ace61daebcf9f6106f98aa4acb13c90950f6ee230fc1573a045a938ec495a4a2d5de6976adc4dc15886c13208fedb23081cf406c1e74ba385d59d2e3c1a39ebf272c972ffc7b37ce73f934af733be016159daf7c95053102701590f944dfc90828dfb8acc887ed6471562cb4f89ccfde48756bfb3e4813d8964b8ba6a56dd4b8fa1baa07cf5a64b5015b498b041378548600e4b0a7efe5d29290b20668a2021e04e146519dac8c910818434c5b92d3c5195ce4108e98d8d8d55f18d1ce9e6fcc78ddca84fe6153ff7df40bbb31cb6243cd423a8d0815543fefaf451e12514cb887fa6bbcf540b6a81d1d9f9d83348f9f824b2b4e40e5a53ffca554d427327216c6b35b47cb30bc16cc7fbd3571016b430ad9dadb45627939db4facdfb08e4efc8f4f01f32b8ad8e458575192f9e61dab84a788c2d94bb497a9d313fa0de3fbc0d3bf1a41805c46124893720b7053dfc6838fda6ca7418e07abab02419f0fd14ee2bef28ae041f3b114da97105d9aa63d9168bedc0cad529f03948decd8070f1c003abdc39ad9f770c122f76c878de42154f9cc189962c32bec25c38c80cfd2885fe30ef422707e463f10c35bde9d35b4f7c0020587dd6c4a4926a9cb5becb26f65cac8304c185833ba8f0a17467b6be1f1c066e2aa4bcc2b7e5c857b5ad1ad12cc17fcfc49d8cf017a4985cbb341cb641da14854d5e5861e0d4de2a41a78bb9c3493abee3072eb6645718faa126c39ae7b21c831bb6434ba234aede9573a5b40b473d949e6311937a82ca4401b9b252bc716eaf0b7cb95cb198e36b267af8f2ae496801a453f1ea8ca97d3a1b51a1208df3927b62c7e39e68efdefa0e628a93dc71a73d7fc91c1ed573479bca034327befb13eb4880421f8c8074a046d5536c4c0f343231b7ba89a8a86d89970a885df1db36b44b1968605b3d1099747d8142177c8bef379b7894a5791d5ee321a6c36fd0e5a9de391f677a28c9b410b412df484361634f4871258a8a9fa5347a82c1feec01316e8598aa4c6d91032a52438aeec341e0876efa7e7cdeacfc1c7affcbc893de388487dee545f4e21774ae047156b4ae070df978b4e80e296e15bc3fac4c9dae50792791c0df33a15175cb5c3d26fb5cf58f0f2dbd48704fa914dffacad09c351dcd8f81c3a8dc8a14338d35416eb110bed5d69e4b8208cb5c8d21ca551a4f398ff01573d7e6649d27920193c27f1c8169c0e3528c82e63c5ba3614ceb5e34d47c36203c9ac1ff450949e747ed355054b751782c1bb29eca1d6471561aa701c9943b1eb5b6cacada7c7327680e7a1ededae180a577207aac7f9baca448ee2ee03f1ef857cfcbc8c30ef201b787b2d5b8c3c5b052998d8f6847324fb9add0ec49b81e1d4a71534eec94dff68afb669a34523590a97edf3aac0e08dea1f5fe5a3990703c937ec71f9efdabe70656772c6907b4fecc46e8ea9eba6c54f95c530776a1960d1a6da4f37abb4c0984f9d96330fadbb27a038d09362889234d7ec6c3b12b729aa5d3ed8c2f3b814efb178083847f6c754344ab305438fc0d7a4ef8349f5a6990575309fa7ce5db327bcf9e1f42147dcc092b5a2c630c1b937514357e81cc426c53f6d20515d334193bedaa8182957f158a08b701145652b6b3b2b0940ff7f29346a86230358293cf2f8d9416d26deaa4844440cefefc627176170aa64a611d67e312a227e9fd747e187160ff5fda72384ded252afc1ce4d47ff3984522b964348785257e6b8080aa7230b4173723b971c5ddf3e6edc84be501c46f020770b1289dd82391adc29d4edea73c289ea6d7f51b921b476dee68c13d3d06dc153cd6020bf863b7c32c82304b2ed098b78566a66d31383ae7b35ad566f30de95a8004d20eacc907cd4312c0856699fca32a50f2919b387495c3d497fd3c506d94f1d886e7edce7787b916705cd6b1957c158f02078ff8908e89f183f4f3e681b723c1912b1afcdd1fdb2e5f3cad472b985554f6fde3aa2686e3d8f7c5d378d3d217977c6dfb55162b930eab70271adc6b1b8c5fd17dc0ff8e73a7bb51a24aaab5f5066f967d8ddbd4c1625097eb0449aec7d22ac1e822422cff1da491b7fb2a85acf5f43ed1196fb8ea5e7805fd21123d6967c266871fd36d98e1c216a8e4434e8be81a3bc56e6dc0a447ee4e90dc9a12a9f0312c2dc8e94bf64e5417cd206ccb3fb9621e33cf5d734bcf2680f453789bee98437f8061273bbf0cea0f6c129ca733463589636740e4c42cda629e505cecf060ac824dae741afa3f46dcd71adab1cfbb8bc7fb4767ae8c18707f8ddc16207fe63e632b54410c2c150de6094a5ca905dced7ab9a36e4eac5e44ee8478a0ec5e936503cbea8e3ccf0e50da4cb4580faa1758b0185435531207f5bcfa0c90d3a60e37c5a2b10c5db4a9d5501ca41a6917e0bd9fba8c4f8b7d64703411b690b0081ea3b3d45e415617f4a3bde944ec7d18a557ea1712c1dd1a98b9d02f511b580267416d75296069837c93f9f80f37aaeae1dc83d6c3af4c747fbe0fdc464c4e07fe174a75fe67ffad1ea4de7db67bd6d6f50e0277e63a5eab1a1ba991c751b72fb56de0245a9b63800786e268ae511fecbcb021cab06a58fbe655afbbdb592d6fcc63aea470b58d77c5d528aa9e14a6baf97fbe60d66a859cfb9e1cebe16d2646be724730d42f4d8dd1d8b87f142c4c57b88ad13cc66804d2502e81f7b8a194e5be99f4163730a324d148eb839ef5b9142013d2e96aa175cce0f32b76e67665a3a96d41b587464578bf975779b5b6f62327fe0ebfb5cfa8b6d1073a0b48716a972b274e28aead67866262ffd1397fb361c69ff16454101f25b0e9623e73c3977f8b280b9adf0eea6fa9aea4d47eb0e3f0f0975cc88b857dfa7b4f514db0f71c9110c5859578e36a442e2454fbab730fd8dc9993e0f24c492af699f94b24b623e4321139288cdfd574be528bb329213031469e8f87d957c46d9472587c01b1aec1385ee98e55bb03b9ebf1ca425664b51a68eab760d17477df69295feacb874d041a1f6bcde77a265326979f19c050961625875df009aa2fa3cb20fa738bed51f9989698aaeba83f8019f567cc33b4527a6d5b3e736b714c326afc3958cca9b87a796eabe928abdff9076eead1f84c17100a4ed2c9c68f498f0ff51cb8541ed2c2c7ca80bd8c8476565a210211d7a0c8f13808532046daa62beb41b3cee7518bcd362f459a9eb7298f531156a40c735d8991a20fda9cdab19715ddb64dc4e15315c99e1718ece39d982ee8de1d358cdb37adb81179abb3a1a443193b3ef0abb5fa6f9c25077de7e9d3667e6d3368704e1c71eed5910938e7050074e4e45832a11e59baf5fde9197b97589f2963c8b5f4722820521ba96b35a8707ddd460214d882acc95067bcc1fa502401cf0af38dd12e0ae0be256b2291b058b56015c791572a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
