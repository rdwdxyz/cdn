<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c3d685eeb2d670dccf3787ed97f66259ddb17139fbdc550f7e27faccffd546cdd89f79e26374cd7f42b3c9a657c69fc75558d53a3757f0aca0a74b26655d8c544c72d79551a4dcb1c277bfa91034a9ced5f51bd939a90de427465ab6c166ee603564aa778155e0559a94f38e963fe0d6d9e8a6effe825c48616cae8f7404d8bb100700a3d69b4fe63e383b17591bc1abd9193365f7a09f564d7342e7733fa2f3ff4a84f140fe587c329342177b0f2559643647c5d70557d2aaa4e34df4efec93dccff40ca1b38fc59935c7f240297f147708840de3eda181f932bb45c2321ee4cb5ae143d1678394f3c584f97288b65413f9b81e608a7fd46464029912ef8d80dd3a22dc5c181f711aefcc69d43fb5db5d32b2796e3b7d121032bc01718ef7357b92b846ecbf17cf3f7cc1c13274ce25a41e20fcbfd0acfefa862bd1edadf48f7bd5e22fa0fa0000957a2f7cc7abc7fc4026620b01e450f52442d93452756ba9ff412ba6a4c6dbb3e76729b47f2ad5a82fa3080a2d6faf901c75d008c31b8552fef252749d03091bb5545732c4245e3fa1eb9174d41c5d00f76338404fa7fc9b8435c5dfc08d35fa3876796aa2ebb218fc2e0c9c099a50b6608ebeb12a6044e9e720c02fb7679e4453851f17dd55e96be9a0aa303ce0c3210b20464bfd1373d9445777eb68b749dee2a72e760228a5667aeb8f2c478ffa6107c25eafffae524c833a79e1ae4ce7a1df7257ece27be2aabd6c34c132a9dd423df7dd247ae240bf72679247d89b6bfe8becfa61a7cc29c50c7896cbfc24edab2769d30e2067838d1789e79a6ce60225c5e0080842b9c2489959666c9c70e9c068610adfc8a37890fd3a2b150c5b50546d0dda8475d8d751acaa80e3e8cb2884e79bd6ee7c7db57ebceaffbdcfa0ee3217613339baac8dfabaad3aa78fba23cb9a5cdef4b679ce9a1c3e80de8cac48419ab6b98f7067605a624b0590578a9c75c2262bee56b4a4c6f748f88d7402184e1431282dd74b64064e6df60501962ede98f40c3953c714ed708f3f4e762409383524385d4c45196c2fd922fb81edf6f6a2a1ea890f6f9733d6cb26ae50bb10bc99ebda5290f9571002962fa4f148fe45b7e21e91ab40b8b51c85ceb94028123293ff5d6a3f86210385c943ac38afe079a2c9ff8031b696e82d178b76f5503ae8e77249bfeafb2c15cbcfe0b2bcb25bc91510662fe4b1d8e6a9dd5cd914f910c0654e4d3782cf0bae3c1ca0049881f5004974c7a7ccab23de8f07e7adc7e6bcd4dc0352a9f5fb21bbb468079aa702da2d005ba35f6a821f15f1d7519ce7ba671e81b9bbd1a07d0b0e124a17386eca76158f491129f816f5e7520d0f4f73359399bd06efe59eb70a64862e223fd91806cb9b69330f2437a527db2a7fcf6a640bbaf147e4e0a65741d7754d7992662397e41e0c96d4f9d7db4dcae02265436a0bac441e5e19ca801ee801506ac1fb581c9a26b91cc8e7fa4c4a627055118d73bb39a68bd0f1aead7c1e1b27a9ae5ef1fa89914e31f08972ed3f8ec9b06681363a6667ed126af92f154a38102f396544c4adf9ff4a64ca884c8a0c1a47b704d041d72e26d2e9792201acb16e09b9193fa11ffc53e1ebd23162f5b437b07a6c3c51087244e98a2259da066336307b33525feb4210a6548aaeaabe42b852da8c5a695faedcf7648a8c1cd63a2ce95a7bd01fac223ad030c1c80249d28f2f52b929a7468a77cf3f140c6c0a9cd80b5690a34c0ff7dd2f09095b036fc4562e2610e746c0b7ebf8b543168fd52a6698eaba6600e059470960235fb06c4e5d8990189e7eb2d544c7776ca8f1055588ca00069443c3b847a98a6d5fd84447ff74a51b287e5ccb2778cbb6a1405d196c6b518cd84de483442554724ddd24472b65f8f42d98c3c0e7f013b6781152ac6c4287e841aa8ede1172777f2c2f64858fb8a00a5205213d1ace28f0ec4c82e5b10cbb2addb6d565599401f15534f2f3be033003793b1edeb86cdf2c11269f44eb309f7f914e828bd36b3218c285379ddfc4bbc99ddc97bb0165f1a8d9ee49f53abecdb33841299abfa9e4fc6ae966b9ed92d945edb5482874b8e092307bbf4e904fab3ea995aecf86b9b8cbb0c115027ba27488073de02df39a8d0de5621fd3e421e099950ded95dfd34c35a7cd40d4b8c41140161ad1d2efb4c0468b155de9cb90f7b069d3734161f302cdd14e180b3d879cbcb6118ecd24c7bdbe80f92df2ed540205ffa71f059149e00fc9611d3bfb0c45845b66c5122167140c79fd0654baea598105d5bf84124889c29a530745a0319b1cb68490af67b715994bb23291ea7adf24ed1665cf8f491705ba899bada600301c171e647bdc14c37a91f5cf3e25045eef91f4bb5705fed5218bdb3fdd0af01281ea8dbae4fc5c06f3568acb2303972e820ed68cdb42a69ac44ec00e06f125e683ecdbe1b7d5235d5339193147c5cf78749dd02982c41b71aa8a118a81f763c24a1d4a3bb6e2f140720b9336a6164b7d519fccff25fab64944a67c45df88ebe89addbf8380fa5e404b7ca60b1fa571366696508fb5b6977d018dc01ccb9b62082ec672c6a41edba1abafcfa5b0f1e03b38be20b94469b706e63832f8f7d4fe19b29f006aed3f532051437224d496142db8dc3030383a0528ad27bf809856bad393905c04f09043820d0f19c5062ebed5511974637eb97fa80b2f601d54e39da27ae17f546db34b41bf7935e0ced5bef3995f6a2527a26d2853a9b16a55a331ecce60af7ca809d6a9702e2f0753be8da1eef7c5119348bafbb3de85a17873deb8fe3776b1863c8a7d28369879a87dd9a5ef97908b81316533453fe14866a7b826b161db4be75930ad3a9c9b86e0f878665de03f8d49296f2a35509ea941e420e47cf57059f625fa3b5ede36634aacdca1be0961d925f9b96349b1cdd725511d3f21c1841b0be89eb651fcdbeaa7a629cf9afe963f4801211132574e2f9d24ae4bb01ac873652551e283f95d4a9fddafeb0d26c616f811bda8ad76576fdf18f21012dc8469395ddec96d38d5e9465573708da7c25427b3456698d22c791cc3fd807e7ff4af60683fded6225c7db98d4a92196c999eadbb96b97002aca9851ea69e94e20dacc3fce78da122288c1fc53d63e557aa62530b6d0554f210011cee5a75154f463b560e5f2a67a3e856c8f9199178db70cd9cde04222814bdf59c68e239dbaa79a5c53a1b404f11468f310f874f5db59e235e8ffc5e59e9c6f734e26ef72796110d869df0c82a384b7555f3ca1ce6b1368f8dba2b76db49e1432264388ea1c04f869a3ea2684792f6dcb45dbb7aec9de5deacc77579c1869bb9978be0862a42b7156adf978706ae7bd03248cb72398a9c837a65a063ae4c3a0c2e24365d5e6b064b6fc9d17937e6522ae75eaaa028ee8c0e45926ca80037018a83531fe6ccf9d2e442cd220623a0d817b4047a66bc8c14b7f6ffaa06582aac87245fb5623b3d8a2b8638b29b788ca28cb554ac4ce07f73463013264dcc5008ba4f26249083b115ebfe4ed303508408abe8926f107084fe3aa2a372a2867c99c91185814dc109afd5720dc49696dadba1589df98051f23f01e18a914788b358dea46789870b805aaa7ad9874b4e7f5edd97a7f1e178840605b7692e5f56c032d513b3a1208416a78a020f8228cd54daf9aec8d49dc537962285f9f8aa942523c6e8011b7482db3c7c34b59c0f4716ea2920fbab6982b5a282dd08812e4e8cdf8deb87be56f6e29819da9df34c64211cc1a79336815759e05325f33648d24a27c21e737789acac7858e0087caf821c07450e1cfa20264c5fde9a31ab45ec1b0c6a1fd3d871b9fd2a3711d96479c001ca7e28cd00cb61ec61cd515471c9730b29142a19d3530af9abc1b1b4e6f6c74ef1171f8ac6edbf2e0c41721814a61505ab2e4930243584e09bb0f99a4f8a0f94acef23d095d2c8acb5e66454033c4d726bec87c6a705bb439a249c23c87c6f680809e850f352e3d38b206311f186f921f8d991bc2dec0275a1ab62dc007916e8fd9a1876575551e2a528dc692197baaf5c4fd58b918480be7a1ed8926631569c65f5bfda00ecfb416b2db21173138adc8b04d2fb9f402e382fa08aca1a40df78d39f665b2d38dc4dd66a22f3393a93779dc2ba55f34c4e4f6d842cff496baf81e4f2ce4176ddb204e96cfc7695d5164d8a529e766d56242f6a6f9c5bb497b0e6f82fc49517fd651b028d323cf571aca230f3f7bb0b8974ff04fe26dfd1322fcf0b57addce5c7e730cbe71ff338b6f8ae15c2675b23740c798d2260868a6625c725dca259decc4c5faed9f5721083866b344fb5e86d97227b1b099e205d208d1e5c53bd04cae85bb892868199e82758a9858fde9d62de0787293516152b463f3146571788326a1b0b5df7874af5732417c001650c28dcb6e2642d7558eda1b73ee9b1fcb03c916880d9fd8db880e1c132bf2630551618acfd94709a9dfb8509b5a8532d4261e150415103dd9dd589079d99d8650951437108f00caf1a319ed7b4bfe94ab60136614c31ae165edecfc243e839d0793b0efb02b3413f62ff64510525c10bdf76a8bccc6ec33e9b955ae99004ec40d383417601def08de5deb7f9420738f7c97aa3911b810797271a142eec57e4c2704d5f03331186aa6981ce8810e8ce41f06f4636e467928d6109f9a261ae7360bfd4b0837a91eda065b0baebfd117eb8d6779fedaed67ea9bc5bb4575942f978a876ee01a8bb2df30389071be8e30e05d6cbf22130ed9e2172c7618836b25dd50afa00c33d61474a23d5e287ba1df44f164c4f89af974268b6cb022f0fb923eb478905a00d5c57079e0ca62ef9f7e2201b6a4127e340af5cb1b66af5227a84a26a08d5d711e328ea939d4049b4b7cb39ebd58f83d06f8dc50aefa8fa9fd2656bd7faaa7b1e7fbf1c9314d00998264931e8d25aa03c8451a8e43b42427fa2d25e9665f4bdd2babf08663325b4b09909abba896fcdd0b1e077691a613b2fdcc8c506819819440568c756292f83fde7b1d6a6d21fe06e5b5d1f504ad91eaa1aa77df55124d3f4279dc17a6f81487fb0abc309a95613dd9c85182f418e1c29395699200505c4892d54544ab51138836ea987db055d876565de65f61aa6931947fc9018eea6c6c7c21539e50944495b504e1127de8e485280410b807f0c23733d66c0be89ecccca57860c050f5f86d85be17521514f4487547a895c708327b27bd8f46f4390a9ec9b89930a5dc62a804a69a74dc268196d4c7974d17d5037e12aa9d4fbe86a6cb28a9aff7026436c5f1655c05ba81271e592a1d58fe0f46afa9b4840cb1c8fd8574d71645916ac10c4cfffff3a96ea54cbf99ddd40f6c2b7937ced76aa20b26bf7921efca50b2f10db980b3ccf2656e98fb07bb0c84c78a622c70e403851060c39a87672075a22fbec2ea68ad1b7e49f4f439445dc91c17c0ed495a3ae6c9fdee84b20774a011a638fca94463696ce377156a565f3b900a7b7419725c685544d24c405707aae2aee82ae817bdc58edac90366961f0730730e17a09d3550ddede081e51b68d68a6b6970aad2483b22c7e733b34c2bf3597098db9acf551c488a23e97a6803dfcd09e224a8d69ba32835795f3c47e4b8b175a0edfcb860a9ce7a5700011872f5254dd9f10eb01375d4663fcbdaa967af0709b95f2fb73bcbe99f029eb5bb4a781ec6c1c77105a4a42599e3205101230d3aafecb1ed7862989660d748394a18db65014af3d543f371fead268b6e220ea97d1f05e17704c9150e5540596215f8d105bd31999e77e4104fd4f5ba2d27179ff16918082c582047e95416276307a0d2801184646b50716ad16478bbf8013585ad8a4d2ed99a291286e811910d5b9612fc9853e55d072f0993dbafcbf93166c4d71d212fc5374662578d9619a1f8bfeaab21e61eb416cc1448f03404e01c59192fa88788f4f666c3fda3430ca065bd419fa16ec82d03a0e2b47b6120e17fcd3400377b2a65d894d20651732b79bf725ad62546c7b0c9cef0a5d82b49cb52c0b59db6996ab77a424ca0e5d22b73f82ada87cf0e1ff9f8010bc9ef7ea349b5f57fbfe1baa1b0b30c0e71013aba74a90ded0a93ee9b24ef4eb93b63c40d37189b185a9ff6d2e8cee7cccda54475eb4385854663a7aa7dc29c1a9f5f06c35cdcfcbbaf17b7bece8d7b7b53ed06d702fa44547e109286680e1ef0bd0890c354386228edb592284cf2dd51d020f046004fbe96039843fb8c49779a754c61e1f9ac038c757dd2150515ebd4c6a7ecdf2eb0026fdb56cb36b058308c009954307ceed50c60bec811501eba35a3be563129b61fef1ae123b0090d0e1796b1c8f44450ad0dc472cc5f43f5a879cd17bf87899086195f7436a5b585e4b0c01cbd84e5a6f89430cd740ae431f92a017c2209f00267ad5661402e7992a60b0dca3cb5b85d86c3b380a87d68dca4f0a6e60342fe984a4aab7347ebbfc69428526c42eb3e3dcd8a3313547b31ec4ecafc2bab0263a15b97a7ec37b29fad911e5ba8c2c3da066cde2eefb55d45b1a6869dd940a41db414ba4ded960a891f110f52e1bf867ed1e94f3bfc4d04bea850d866211398ba5b9f5195db4d397ca35007076292f7218265b848f3e3c3ec2ab313679e1f8289959937d7aebc528477a4d30f68e7baac3faa0b8b72ff3dfe7ac5eab586ca2b10d9148685abe6b98198a30d10cda50b7a86489916f44ea504b449d308ad009d89a72dab2db2fe74108b4df6b853039ed04f786d17f5be058b215112560c3e74ab9aa1cda06659f4f5747bfe4818c4d55a3a194a8cff074967ad5b97ff18a64384791e40750c3ac88b2598a1f86b76cd536a340ffef22e805f27894ac2ef562e2a36baec00aa210d34ea04d1fc3a69a8c98cba627c625ebe9e0880d0c229d5eb9a543047d1162ecc9238062f81f1ec95050b6280b9ac6da6418c0e53d2102500ced13bb3186d4dd3f2ef550ce3472f1d0ed24f18a5645795c912030b8255dd78a2fe29203a3c5fb781eb3c1fb1bf3874b3f39e2ed3fadcfe8ee490372e466a63a6174abcbff298bfcf3f9ce0a0db31c24fe50cad9dbe4a0583d52c3ecd0904a2e005c6ee9e41c31db7cd1b58bef0ef0405cc45240988fc00e6375d35138ffc4d9f3d49810212ba33dcb9c655be18c9ce8f072571d629755cab9dbdc4612dab5c47d0dd2ef5f05092a6d25b952761f3687e9eb2be90fedadfddc6241728919a85b0c494d500914fa5a6ca9e3a051545c6a00a2e1ebb00a7bc65893556621f4c84cdf102b8f6862db7cc6adff56cd79f7f50b1bc9e8de60443d45b5a9ee673982e5a481242ec6c1a467d5fb683d5409d0198fe885ce5b9724dac486b610532b4f8f2b56643bebe5bf5b92f8aab87a0cc0dd69fed86e36b0f5d76edb742c9b67cde56311f21f3b377eeb76822a5e9ecf1b997335f55ad2a9a03591550ca5306b529133738b6efdc5e5d65cf410a52eda1c3762223220d07d82c8ad6d1efa20ea0175d71bd84b4932b4051d0aea65609c9ef41f837e70a571736017f0b985286a9ce58a54ef318a502d34481f0db6aebe5690650eea8bab4dd1721b60308cce5431bea635e97452a8a1815c2f84939c5fa43861e9492ab87176320ff0e81b80ba3a55c312564eaef983dc21a1625985c5e4c2f94ff38e93bbd40180dfd90bdb9add841da5d42c2824f79026e531e18e18524e22e94202a3b1194c25298df1139aa88fa2fd376bd240ec4cb0309e69aebc64133f0fdeb2fef0a05af8e5a9e5a14de73b46b3c3602dbe8118edeef142e65b68c636530ab31e6abe67ebabbe54e4d819cef8b0a294b640c4edc338602e9b4ffc7d7e75e145970beb3e00c16636154bf409c1dd595485a74525adf78f5b57d8fd5f1f4e019261800dfbb51471a2c11e9b8fe54c600dcff70f9aef09b1c959ace8dbca5bb39bae1e23186a6177fc1f37858d6c68519a7cb30519a08efd99eb8b7fa4ac4c5123a5ca65915d0219621a68883cdfad4d51552d697796cfd57f387cdd8eeca5e519ecc889680386a3118a5e140e53e3a89d30d5758954e1a8f4d5296e44f89244c4dedeed17f7eec77932f01fdc3266465a43940f4586b897c203651b4025c9937dadd25bfed611c0295773abcb27ea603a94c993fe1b690b4fb7e02dd400a0e4bbd89b19e71be2f7660353abba056c24aa1338317c8b1873824617e63e3aa391a653312c1f32d28466ebbe048b67e13172e19cab812e1547f936799f9f936b404d1ceb279e6dab2888af8b2d4094d23c8fc185ae814bd24c832de5290f5a863f5e098e840e98eec71dc5d154c8fd714a2eaaa611336680aec2c8c48eebe1acad20025a2c65f2de1d820bc96982eacef87442644423901e39019cb70b0351a2144deffaab34570c5f8b11b95ecff5c944b642f59923ba98c61c30294477d9f84528ad4d9f013227c34e780627435badf098f4ea140c9928b919cbac9a89caa5cc79a8fc283991d72fae8478f8e77985ea84b66b2f5a8dd9272c97dfb4707ffcdfaa390792bec5ca3ac8ce1d99fcb5fb1046067e17370b56b66314e827eb0615f00669a027e4513bb8c6249f7d68f6af72b86a84d838e0a868f492535e34da252bac4a0756db0e721bc93c6691aba28f8afa903de447baadfd0e57f220ec3175f5e6d1abac34cca24afd15eb8bb46cc8d22cf571bbcc58b0e2157a88a8293e446057a24c6ecbaade1312c147968f3597f862212ff273f4e3dba18f9fa531a3e0def319928a6e4810c690cc3c0ff13e7f53c128632c7ec1a055dbc1af12b0afab669cbe11868d7d1f45c631d0584f7014895d4a7e1ac4317d8d88f99ac5ba2d7e52580a9533a22a3026207fdf127594f8141d55b85a5b4b7161aa0665b3073df206fe0b0d51968432b2eed9273a09c8b03ad987600bb9b90c665f3b5425363a978802b0bcf130bfb2913c7103a7f887758a250162b22d5c69f0c87f902b8a7047f23206946b687a6738111470c02f0118896f13dad2135df087f8eb8365797800ac0001fc6ba29f15fc930f125cff1c28ba0b15748a9c2e163516a4862ccb6667d5a5d613fba7213334a3da469ed0540ae82f3da1db7dacf01e2860cd3a462533011b3588ad1667d9ec8d6e4fd42630c32f62e19b8d7a2bce26cc733da56d2c96029fd24a1fef1192abde6fbeb2d73c60c0f8d2e76510c87224f445a51013102595418c7ecadf9e4cf5ae6efe9735600a96ab165afe393c0bec8bf005c0f7d63ddc5292d3cb72710abb1c2fa5a511ba8e8c595da2f3acf7972a5d5ba1a8be09bff5761a9285c4de2e1014e164a2596786ececc17a8d56695167548f6cc2aac4389972e0acaff506a6b4bc8db776a1b619c7e93ca8fc2ed3462786ab2ee377718ec1856637295c8dc5d694a6e197ff7394f902ddd3e83b4cb2fb87e57acba07396596eb078b2321f5785f64212fa348f6a61a3c9eec96f7c10e6dce9181aa9bbcfada3d2489d91c79233afc213370cdcd42a5ff163fe214c5feed6757b24f4568c50f7b6e2f41f1ddbe1cbd01557c08bca905c930be6e503dedb234c30be2f3da64fe20919433f6e767920cdc273a0bbdc12914a02d9cb1258644942793eaeffa38d4432d7652b2444a1c333a44fdade2cf52f981e347bda817fa7056ea9324645c31de6acad0b8621430f41c56075f2ebd6d84393d8b75590d3094d6912893091c14a0e4783ab7f2b23d5cfbbfaf36a90dc79b14c80383da21fa7e636cb71589ce6faadfed18e204b4e8c714ccb1e6d4c6333a63d90152837d1a0e36a35f4178274c1e226433bcc54529581d28fda37a05047834a52ab8c45def289d6da75ef372815e0d33a42dd380141a966dd7f386f7fff2f5c933e7cab6dc29a6a91fa8c39fe512103ca1fc774a2515ba61d46a42c7de69cdb431edc07bafec562cf823dba529570d58ed27ace0429ccbe0906a1f54ebd509951470f5903fa9c1a0a3eef899406a917c5e889c596753e216f08c962c36483e4c9d9d5315472127ea8be0aa8a8e9f7dd37f6e6e80b9f9a89340406146574fa58fc70727e38acc019ba33691fb00b53174a5ba4eeaf4200b8b0545955aec37797af3deadf7a7351edd40dc6a8a540accf7e5a8d9f3be9386272eea45dcc4ed25670f245932cbeb0206bb1723d105f7cb44c606642341ea8cbcd92eded4ecff46b9ecbc23e72939bebd78024c3a04f24144043fa7bbebea45b356a26e02ba53c41c629b14e33f125029646ae26ca0d4ec68586ecfc4e691717c4b70b834836f280b95006a1438fbb48256c9933bc4609831fafda9a04ab975c84a1f8e1f4da5eca4011d42813922cb57875b9d186b883ea91244149226f55561a5b3a9e0db576a57fc93c5780cf3b2eb9d557a5ca34a100bd66b450844710a5ede56b2663cbb3094a11544d16b528490ff2499c65c66eb1ffe990ff4a4d7a1bda26334040b52825b901eb331e0201713d16894ba04a676f66ca88f72cf653efe1bf61dfc7bd34ca2c56ab5078cbebbb643d77a8a87c3e4b3d788affe6680a0fd7461714b6d60d59d5baeb508e0befe1ac535465936c9a2d7e3aec55e9988582c1c164b55af0e6445e2611ecb23989a00402952e38601bdfa85130fab595b00d24b9b4d7dd142dfa1730561b93faeb38504109dc6e56aecdaa97abf25e2e8f8766853db6fc83df66e2fc24e4d4cb6d12d84520582cf9547b39164620e1ed9ffa9f50112b1bba74a8d8e618324a6a8e587db6c24e2b426ce69213bd5b9abdb32f345f30c6c533c943f180c167c38b891bb39f54985e33a0c5cf3f62c820c50a1e393ceede3ce8c103c160cea3d22cabc42e5d12c4a917276a17036782a875afbc3d3b69f21ae7e2b9c1b76850042f9f575133b812566f6007ba67503a624952132dfbf076af5dbcd79b0108e2472cd321c57a9b969201241f9abd4965b46775ca2364f7451b67e93b4fba5b68ec7f53519767f6b39f50e071fa3e062435f0c24e9406907f09c364dece1bfaf91c3fdaaf8861774cb418c5b47976f93c76891f54c49db0eee333362712a7d6783f92d396de316bac98e7d704ae81087b52dbead94d5ad7f95d0dee188785721211bc3ae53af9f0d28bfa2ef35ab0e97abafe349596acd21bace4db7c587f3019b10cb85c3e22a6e5befed08962459b005e90efc63b37c558808c4e6c495c21cecf29ffe134f65e9c98d2b18cb9315f5cde0b7ba567944a88e8b029190a80728325dcc08004fb0f06a8edb15a2a8410f5d2d6b8e82d650ae046cc71f8bafa88604d520a1488c64ab48be9c6a8b1da95946f97769481e3fb81ae3b117597947f863290e215701240609d3d6ac57206be11fdaa85bb6e2036cdf8ef0428cb87051a50ea05b0aa1fa3e28062aa14e2badcee0dffd46e7c0d219918bd6fa524307b18e7f9ab4301b75bdacddd079f0b7b860e648423507c87c9c552286e9accb513c9a5e9f08473900c058059c4a6999d9e44fc4fc11a486ffaede731f0992a94d568d9123d6edea3c1ec331ea3d4d69dbf617f71cad45c758fb7d3929dff782e1d926c44ebd94a8ebc717a01745c25ebe675b791a5f12d777273e9baadc50457d98ebc97afe2148c45197ae1eac88c06ae53f4df4058edc839358f615851a6547f264f69e3d12b3c5afceea05a65cd1656bc0adb909fe4bc95cf31f6b00c712cb1698df85f79cddb4ea57278f64e19f169ec78352bab9cdad150b1329be53c1fa7e194d08ca265d17b332ee71e3b9c1e5088ae8d448abb0320be856fefe28c6d40beeda55564be515104c57a98c51cdeccdd517a2629a8349cf29700ce8dadc829b9db8f46bf3f16bfeaa389dd2403f513052f6a2eeeae37aef9c32709fa82021a032e7962b8ad4906016ceff8c5df3980226b11b13806ce986a92132a93530df7d2aa1e5e41a4a8aeff44f902bc989b68654ce58d4ef65802e4d260efb6f8a4f942211b66f668a90d7002087387276861168baf48e10e4f7f3f2ddd825b835eaf3a4c34c9fc047f95407a496340ddd3861817faf435a9536a9b38551541dd944d1f08174aa55821a21e7b8a11fbba99f0f49a0d9d959318c6ba20f03861d898444e9294d91cacf4247b271df4aaaab666cb33a6b0ae533ab826dc9beba2c1fa3f54e2b92a507a786b57b704d235aa3c3437f026390e00fcf18092ac0b5b2684c43c3dff99b5850875fec65270527487eca37944dee5c4d413091e10e871ecba444a0ccf8c8a2a6191a0d7e5e51cada60758fe007440f948397225e63b9699a1491d62507e8f63aa6f757aa73733450157272bbbe374fd58df88949d3a428e5d7320f50f8ec538dd92632f6bffcfc09bb2abdc695ca61382e3a4bf295f15e719f126e8bffe50a1a3a2175ee6869205c916876e27068403b0a1adf8bb691b516e8dffa89068ae77e15165604d532cba9e9fe2d75f28ee1b27445950edfac86d364075aac2261308f94ddf728751117d94f4d079b280519c9e922f84f649614d478a6e42b6464035d3b160afc31d307c4c8b3da8b961b2bc440aef4a9f7dddb5c110d41546df614c3477999ab8ca4c07a719b351afa8a15c3c0f19af8bc023db8f5042469381a524512069dbc6cd4484b95e2102c26ceff0e794b3a002c945c796614435fb64fc4ac7626c2124d28f4e229c8a2a276cc00a17a047e44401809dc13da99521053c7fbbfc0dbd999b49754bd26d3c8ff8349cad83b6fab0409c5f1f6742d5c7fbe51f697116d3bb9b53d796afcf406a0d2fb55a86440dbf23380ffb464a0c6ab8f3bb4bb85df82b5ad410db5e125001650e587fad269d9dfd56c8b67e5647aaadb0453cfda36f1dfb5b37c875f86cd847432ea33910490abac8fd953247977c1fa3e08681db2c83369a6ebc55f8cd1e3fddadb9562096dc37fc8fc7c0dc5121a50a1a94bd0d255604e2ac98f934a2e898baad11a081d4a50ec35a473589ee7e68523bd833d627c41a7e5279e77f8ead2cf9d53080448c099dfc7085f5b517877f2c68d0e08a0039c0c4637d78532df32c42ed42bcbcfe59a0c89844569849e1288cc2450f0abf7b5cb3277cb7b87eb3c55cd41151e38d3f4c7dc1c41adb33b2309c430a010c192bbf46e5d4af2d0882dc4a5303ca27d9c23ebe1062977ba26e0fcf03c912175f53346aee52ba85e8d05d688fbdc9ff100387fb756131a81f1f832bf13b12d16615016552d2d0b9647fc3d48c6fe67e0418a70b83648af193e66930c61a546673bb193158fdbc4d8b5072cc6631f1c6d1e27d88ff75dcb08ca5d3cd9718a035bdc7a9261080a692c1ff8aa7372ccc18441672198b87f86a595a9f17030b52609e39e0e63e2716e2b54975f7557650cde870c60ec2dfebae6a61c06b8d6ff2759c867dca69306999dda4754a82d2351d5ff0dd56f3407f24cc5667874d155c0d2e3adb63cc1258d667d2b66b2fbf0217623d21ff9f79d15a62b24b76dc8952e010014c26578575a07d2027dc3fe48099dd7c67fa67e087c0c6e8da89a221f51341bb5b06e63916bdc330555b8c6103d1d66bbf23de162c90f387898032b6aa5934541c2e31af79e81890a61831e0d6149804b15b91b2a65909651b5f37961493b8c2f14b4611e9f396fb74da8e9d526cedf7362d887c4bacce8630a81bfedd7613713cd17f50cdba74b35bbcbc7348c3501c13afbc86c99ab7ee7fefafcb0ce8352c68cc852d14c9602b7b194bf9c862774d26eb7c5b182c16f056cb30a67315f1dc23048c6cbe5c44f3b01fcc83627e1990f114d519af05e9d7e407f0f04b9e5691ad191dc1f17cecbfccf6833a9d96045349d5c892982c469786863bff4c233ee47bfefc92687e156fba4e1df39b7d297f68f7dd728046541bb1ba4b8a9bbc0ee833ccaa64d7013c9e09215ce906c162c9ca19935548b40a80eeda23e0d1b993b5e5c6883ace55c04ae15b85e6f81f2753f3aeb984a30c9faab28790725acdd3dba8e840f19f2a2d1fd4eeacf5e57928ec58d2c395fd24ecf3f6ee197a4358846e9cd426bc0f350b3589f877bfa4717e146a9d7601ec64dfbdd1dfc1dccaec485a49ec116d21999e335a46183e8dbddac1c6d2e9de3198ec8590053fe8f36459cd997cd54a01fd4eab47bc484adf506f157d919e35d19be5a4e98df5d4501e9709357b8d46b8aaf8c0b7523ed04b74d0e81b9e2890bf09488004e06cf7f09d3a2e1792f2337dbcab6c69b6032d5308f1c67b44bd33bdf03d50c97f7480c15cebd6d9c4f78eb444b295761f8c37743097f491f027cb4c215188b040c714a2868989263790a89684cdccf16336cea2ac7b5ac948372e9a25e827fd6ef8ac78ad15badbfdd7604a608fec76bc0598411348dc45b02ce2a544ccaf15b8355150d6c3041739fecb2e1611f136455a41e678282cc66f6bf7be5d827ee0d3c99a820c11893f4b31c91fe1ba76067f9d742e07e9b73dc231f6ae4b5bc02f57e5c1f691e719b711f5556c8fc9d76830f8198a3adddbe1b9dd4d6d69696c454cf64b3ad2f61018f084b42da99e3ba429b913db8815a21d8e67b6464626adb7994d7f712e7593f5bf68718e406d492622410b1cf7952fb743e5db397b934408e16a22229dbdc5172638009b797f5660045c9c68b95ee0a7458d058e2fe9f30a1ca93c77a799a8ed8b15e264152cd37e129ab8c04e7369b1507b6d77a761da563426fac78086aefe112fa2294c5df8e8e51ee0e332c86b55127bd620ad4462c83abda9c38336987c82bb37fb610db28ee74686117baed5880be05ffce6ada2414db4f857cbdfacfce2ecb62f7570183a9c6f80cc5add168af4d8382c99b433f6991171a6586cf90ba2faf69c28944ed9a732cb170b0744036ab90b00152a0b77df4e14110b6d9d9b0687617d4ae3570c06671e9e6ace0fce70b42060f6af8dfb166d76032a29f8ee3a5e0a5bb70c344f54bf462698d1ebdd4e40026d91f244aa2f3d7abbe32b281e6eb1a5fd6b5b802e0039f40aa7ea4b47cb726b4dcd545d67b500b0790a7ab9f944058a4ef4a5522f46e9ba320ca3ca0610274b4bafb9d2374bd86f5b90d57092d0fda3dc6f2f349c5fd18ccb47f22319b1109bf36ff99ea573a0c62c63c1e3e2bd19499a97eadad31030a2d28c1f931e375c76a429353df09ebd164e753fd0d11116672df1431aa5cef05ceff8d7c3d4cfed55402c53248d626109d8d7629672c30fc82c628e60d009107208b3168602b6b78593a68a1acef15c06525be45ccc8ce5f72e5733798214fad17764c61f77907af610db53abad8d70cb2e605ce21ff884013c894ecf5ab469b62697be246d1c37a498ec720f4e5fb9d1d163743261315eefddd83d24d9989b0d72a43bdff4714738824f70b63639f779e6df419e1af214a3b0019e9975dfe78726e1ca5d6fb9810bb0801acedeb9eff49c0fbeed23708f5835415f7d0d63bc3c2a5f073e7c15607316f3ae243d165470033134a84245028c9c33047e4be419b9be917fb7494c80596f439243fb43e765a2182d2ec1677144b03e82bd7bc961b4b95d91a4b3bbf5543c36cd0d6935ecfb3274123996206377483c029d484226df33129ac597c38dad551d5fb2af4212123f351453cd58f3bc87887314eeef64088d5e730f275acb244f98f5d9515254641c64be6361e1edfd7c0fda0bfbb75a8a0605a2f6221ad9ca0363140038348377b065a55209fa3b05281668bfd45b9ff7c1328a0b098beefcb3f8d4c7fbb1dee8bce79b74e28e78aabed1c443863ded5e9b2922c4520d84c8dbc4e57d3766ceb6d747bc9bbd6958a6a9de376d8aa0c6343992d7a96bd743787c001defb4b13850c7ad99687f3db7a0304dabd32a50a798b07f2800881c56c5c3951acbae4e5c59afc6c7930d27a9eb15129c00e0381531054296a416e57e92fa8756b43184a9e0b51400997fe399a846f375cc56267c496cad2680e17694e8b42cd09a6762a2eb246a1e8032efb2142c1c293c3460fdb65e1dbfb27cebaa8dbe63a90738692950ca85925797ec29b7aea716d86c2b3601caa60420e5d4de20a5887c6788d4c2ff60a11e969d6b0471c7384ecbeb838b071d5d126068f0d79170c8f6694dae910b5c8325272ec0cdf59be15fdd03597cf694c2836736e5cf6d3fb2a8c3e713f1d3d65935b3bd31a69de819fd236dd339d1687061875490090c6990f2c2b550c1fd41a9bb19b2903294513a6eb64cb5ac167f997b31846d3841a912c26d4cd488bf1ce28faeade20aeff681e5aef9dddfd8645d819f4fb596efdd3b365df130a84a298b18690f373df44e85365757f300883e879253861dd6450dbcbaab6dc66f3ef7a329d620e1b55681983e74fc21fb616df24423b4588a4f8d1ea014dd7c5d8fd0e7b42f35676fc1afa70ec501a10a72a41fc2bf26c35a7862440afafdc7e5e04478afab554c2878a9c02319b17c0f76623420f820f329292312334b484cd1181ce8bd12687a17ae4733ad893e1cbb60e9ebc819e0ad977ebfb978ab3adb1ce5f7d0339e85242e6cea76e4ed3c629c92621f9a230bc74fb36b67b56b1ed88a56310d68049cb4dccc19cca83e311d5bb4cd281957d690d001010143964cbfb5732c23fcb7a0265c3cb3d25b8f35e1727c0fc433d103172757352ad28262477ce98202fcc7eef3408f887ca4e8519d19329a0d170ff657d200db2bac56598556c8541b2fa998b596543babc2c7c6b94e8100e222049cae065c7e5a83552397a5c360415e68dc519be87a18ddf4dd63e8e655d02dbbbd2113a4c4b6f0cf450d669eec7003bbd44310232f2732c3e88cf4f89a59a8dbdb5fe6b4133f20459d549e2f66d5a638d75f99715e4126e307eea744f460894d277f3f6daeda6f719f298bf898b73645cd2bd2350e0d76dd788a559aff51d7414f1eff53ae3126b0f6d05f0a5c75db2cf3998002bf0f6e3aa9549cc2eaff22b00d8aae412fd7babddfa7af918b6775cde924bf0537b310e8c44c14415c696d57b8c3d14eab254b166788958d9c7177745408a1f26dfa306e55057c53b25a9221c576267575d11b4a369102ca26e7061abc2994a070d7c0ce18aa59ac3bc3bd874842c915bbc42f5e63b35cd5a9aa6176cbd195bdea777fe70848a2ec7c46fc32a9bb8e5ee658d02c9c6edf4a38e4934aba11608d204db70ae1a3bcce0bf08d866f37acbf8c3de31d2a997ae2c71b6e77807bf3d1b9e10dbcc54af77e51fb9c23bc657ac43454be0dc1544e6cd3c6393d4df34429c6393552efb0ef6cac39f5b9ed96b4a637a2ee8876706508cc7937e20388c830a3c3d8ee1f8e388ed4db39025434ea56d29dd1bb6e5c6b17964e3f076b85ab26620e3f7b36e7dcd8267a30f9ff28f642a325a3edf03e4dd3ba013059f2342765a8db449e210bd32a8ab2fb1689e9b871874906eb48fecd79f20cc5a66c3b49625d5aa410ec7e7eed60f25e601bc3dc8c1acbd0687a1197777ad705f8af17e4545af7c960ae2d4456bb47285e53c574330a451bc325a8e3b8bf2b05d34f83b67636c16cc8a7c5d856db61f16d2e3daa2cb12b9275a686ac4c60eddea4338a97c58802b3e33804ca91ac800c16505605ac03b507a15365e5035639b7f21006df6a71470291fb02c0a7f05e55deac667ac927c7319a1f70f798afd69b10b8f0d0b47b951ca9d8db7d7c44152b42ec60da7d27513e20cfd76be68aeaa300edfd3f65d30bbdeed93482fcc6ff84516086fc50429afbb2da965260b89ee8aabe5dd1186dba9b7c19d80db8df2c109b49effcdff39de0f62e33a3549fa5ee9f1cfaaba0c6650ffad153d2b698f7d88c4099d63b99089a5d7b832edfb9e29d8e7a8faac97a73b8d1ce1a83fd216d9120cd6f424299b39144c5ed210405cfe036a76fc6ebaaf53a8646ddcb2d74015bf8f3254589e7d2ee9180af0f8bcfab5c1ee1ed3c925ff7296ae672e1359ff379be3a737ad7f8b40b6fc16b5477719d27d8be2660fe7df02a873318ffd3cc18700bf90a213a22ffe242de975427dde4f7b7f572fab50","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
