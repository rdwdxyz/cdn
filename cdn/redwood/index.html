<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc581057a7bd2322ac28edfacc8f1db3ae0d62f966b73d4d61d630e1df3bc74db9b1b64c0ff6bf7c6a89200736b4439c1fdcfda91f9c31bf69cdbe1d1ca353b510b4ef7f37d85875c4ccc67f746fa4e7235c1c1ba85b4361b4f7e87bb32c3b223fc937f302199a2cdb85d119da177a57ea2475d71c0c44931909b692b0a07767c19a840f7d788da7c4d0779ff961cf7c50a8010d6dc7582a1c0ab704d3c81e3638391ef776118691f62e92bb11e134e5a654c0acba7b52fd6a750f1cb331b1bf95a54851500408ea8e37fb75cb171f79eecdb08f50f4ae881000f97fb06a31d48bff164a44f9020e0e1762293854ed28a9eacd1aea709dc317a7f9a6d3fa6050c36d1f930a17d3025f0e314e11b17803fd250d9a9100ed4b1cdb2f7f9bf9784de5775415d8a75ec219a85a18303eac4fed88b1d956548fe4c60fc22e3b2e79693f11a5d558bbd12d1c3bc6c6c3da2410c638b387feded967c0a31933798f786646c88302bb6b2377fec3ebf6ac184264ca55210525b2d5528ac35bce215288f2dbc5a368a7fa802ce11767f218b6619a44c7772fb6fe9b31a762188f15a22cf0177dd63f039ed8257ca118bcc97306c4964a4f9bce485a9e9b2e692debecb858e9d5373538250cb31b53ea418fef5d6ea4b64bde65b0a7e55629f2a78aaf82a7bfa70bbb7f55cd28f1c20626771aac811eeab4bb19a4f83a3252a068305952d1be12b1197efcc4dce3098396555dd33856aa410059886a6a4a3c581abaecafc0583c6b5992eb9d14728109467e142a39ce0f12b5bade00943c3dd12a28af10edd57dd2b82e9125583fd6b458a409d3d7f0332266af995bfd7c301fe8b7284cb41b83093ef5ee98ef0c194c003f7798c615cbc51d3b89b419cd1418a34d6fe6eb7994b501133e2d549270c8f6588841ac850313b5c36218b039662fdac61ab59b5b54c90da3937d073a0a0b8edd32c09723928b43e62addcc342120bd92245e78259d699194ee0dbae39acb9de2b223defd00690b4f87469e5cec2e644cc5277bc22f586f7b3c6c8bfba25ca1c0654d1c2350555e3791644a8eeff2a82800370237f27b9521b20b384e394df50af48c4d0fdc454b39b1cf74749f70cf07c978047f547d823d84d259a9960115a5d8e231b81baedc0e7d583826a7933b697733ac13862305c8087f54c2defd51599d94d78f6e0831fff7b839a91f491e393fbdb914cc8142006e82366caabb2921a305e1f852c00f308547704327f2d0196cdbb4b9a01304f13fdbec997cd69a1d2431ffcd6e587e225a72b3d84df99fa1f75c46e6dc598d6d2c5f323500c2dbddb2ba256bb58b9ff8d5a09d40978075a03b67a67f35a1fe246160cd1c2beef9f99bd9d3c8f898f8e6abd6984703dfc14fa824e9c21a400429e3c5d26484219a02d8d6697158f87b0e9652823b5689f03b948b355b255274f25aa59415b1eaa034ed41890b86eb9d3f7c2162e3c16ea4c8d89fe5688b541598ca299227e6770d97dcd3e0c858c290e8f3f80f6489acb3cf2ae9d0071dfeaa2e52a8a775bcf389649a8b4ff2836b1fa85260301ddff259f2c055b4bd611ff31c2caa98610a55834b72df32fd1cefbb230b42cd61643e87884d6e7174f5dcda2e650fa6567b35a42a3ba1f3ff7ccdff3d293f38db12fcf8575acae292c85505bb2e0e42894be16bcb31cd2ea750682b915d52eb72f07e67a3c9266417ab14e38d0e35027177d4a0c7d91c44b98587337c66e2d2e4e87dc03ccaef01de7994cddc1457ce6ca4c1cf1a11d800afd423b458df1727b1a1aebca978ac2625f39486bb407bccaff095fc792168a8163ed4951bb27d91196f05f27263f3d2953f6eef645a464efe849f5226a0c6869e37990500b39b29e97999464ec6fbad5f746be81dd16089243dcd7717a5a659f34ee640bafaa876963a619ffa9b18ce51857233d20f89f9eeabdc10356369c8cefe34d72ef140fda19906f98093dae418bc9f22ee31347afbf804748bbe0ac8fa2ddfc90dba1d4c0298fe7ba115e2a1b434acb96cccd46924a7060d319b50d5732327cbca90992d86608341940ae09eaa38b1bd1f619d78975a2459951a0e47f30d7202bb98ede475d068af3c06d2b55de10de5090a1267d976e3533ff4158dd74a09dc011d4a2b01633a8301ef1b3adc0755096b9f536f785263c6248841251e6f50f10aa9d81f1626c859c3d0af2fcc8a81eb9ba23395f3b62d6d109da77f93d1655fe848eb74f5ce2b25fc96543f1cddd191d18deafab4f21bead53c2584747d0648f765a82cbdd164c62326bc757a1567df6224e089d30586a7e88ab65e356d58735d647ac0cacbd209ff60c4cf8d49a3b9052240a5788ee69ce8615da352bb2f44e36e114c245b4ccb4f5e44c3991dadd1c15c7715b95805d5390969bfbd40b558f3099161667b5f5057b693b0cab740c0b4131bb013f05b7279717202dc286b317e3354afc6ba5262482bb587f80c22bdb592676ff663fc6e90bde716000b4770d13ff659e32f642c6f714e1646fb18b412a919eff9e54f040bcb8a051c6f62d0ca38aec182bb0bf83a9ae0771f2666818f90437302631893adabb8a60f7c166f12ea950f3b5c03af6d2bc6bd5bb3e88244be3da18629bd66bccec09a7669a0edb80cca2f8017fd424b8f24a24cf2c090be1a1e1c4d4093f84b4088ca8b7118c5c45395225b041570d6e01f054466b665b44b2faf46b17a398c08df17421eeae41ccaf55bf7da63da3479869ebf77b455fe5544f93a549b65e5f77b06f7d25b169c9d01908c44b41663907a4cb998530bedf0ab74c4e6721dcd85e39e3bb3670fabf54884f9f16aa5898d33aca6a5a328bb8a65b230b902ddd01464580341788e00f4abaa6916cdb09c0d72ab8204540692c4b8af6fe4cbcda2de9c1bb666e2e6ad1b99ecaaa557bb0462573ef0d45eda9da810fe75db793482ca7b51959fc4e4a9b3d59e0adcfdff23112c6cae4a210dca7ee74b13c68e88611ff55f706f8920ca3fcc333bb5e9278101e9bedce5e830bfab8eac36b61d3db4c10a7710fa6d13268f361b96a98961b98524b4372c421a7038ef80c7fa9408d5fb6a570748a6c29a3a766f62ce744a4c6298a9d65cfe8f81aed39f4918312450a45f4a3fd95b036356e8067f310d8f9297bceefffd6c79e62b9288afd518e7d834773e9f16327a28eab8e85d4f651a5af2dd8d0b4710940dd8bdefb38764e48669cbbb945a31c68568d4731a6123ecb59a30923ceccee6fe49f7b44c582a0369d6584d6f939b5d455ba13069d9e7709940bdc7369eae2bade0729a93d8bef8d02f74bbd3c83ad9dc1204a7360f9573e6f5194d3ba97d240fb025d26bb57c248e537afa48f0d4190fa1b826d9852852c9620d61833675304d4ce89b08ccbde761f0c7924c5085f82b0b763d655996f1435999fdd530ce709a85ac6f2fe2b6c33d9265a8ab3ea48d61ba24d907d151d37c3f6e55115dbda88103b2193c83edab9fbd3534598bcb558054332ba84eae5432db932983e5d7860dfa3a024e464db96bc1d7b81b0ec8d74dad3292fe0074e7e62063e463902e5e1ea7abf0c35b2b42a20c55bd0b8c45a45c0265f83fca4ad6a7c1044922dc346ddfcb56b648ad3763e25a0d53b023097a4ee62afb76dda24619cb11ff25326c18657a097bff96d979c243045bbd78d32abbed111fbf8c27b57ef266512538693271495ab4ea2cdbbe5199520fdbefa991fcdc42cc16476a70b8458d31318c6681b55f69cd0a91617e99e4a3ac3a912ff7e4b439d433a8c3174b4ba3f969e6fb87b0ae8fa688e4635075112524e5a88da57fb9ad13fd025de10d69164daaad3e84233a8eee1553c28e68b45baaedb0a2f762dabbd818bc75b9f21dd5a9cee830e053c0f9e9be248468cfb4168238211d3aafa839ff6b6c7f5d6f99d7e0c9bbd7be7a587c4ec7999193eae823f7f0e06a91dec64cbc556dcd85610b1bbb5d506e7e2aecf6749635e2864bbfdf6f4aa897443fdbe9aebda89f7284128e5132bec04479b3926676415d0d71f3961618394a2f0dc9e03e366777967e4207fa4086029ff46c203d60ed0c52bb542199a86fa38138a5bcf3b065465205528168a4b1cc2fb85f987e4fd3aa7fa72f7bdd949f246c63a6d96d6ebab585940474ca81585784d804bdcaa09581a994015e322b71ff308a6f948bdccd290c9aba4c020c4347d607699549a5817aadb081f2116b21d5d9396cced614a169fe7fec9e66af65d52937ed9bceeb93d4da0d753ea43468a3264369d07a6930cf2b4ee7e11e7a16c4d73cb351c5f58f4519bd8ca43cc241bb47ccd14292ede6da290c82de1cce86038c5ed1b457576a306aeb79fa50fca72724348658019c7e4a17f16c639c0faaaa111ff7ccd1d004137a8b360750ef1963572c98691125e0af63cdef30435196fe1de881c3b1bc1422e2ccc1fb7d3034f87dff520fb2f9923e688f8ea5bbd176aa866118ac6022de2586a47fcea092e08fee76444ce45f8aff9ec7870ca203bebe7b73ca582b5bb330c579feb460c1a8c5b82d68dd453bc1f6420fdf55990a9306398a416b4550f58158adbee3fb772d78c4daa33d9d97d1fc73c75cd95f3ec6fbd43c190d6fa6656d47f910dd72f2b1a6b9544aaf61e1450ab65cb4b2f2dfa550b0d58dcb60348565fe4ba20ecf53f0dd5756ddcac43ee1a481df6ee4725c88c1b932cab104807a4599a211c779475d04bcc11c38fa126e688a75d0c2ed7f0ce2ea94c48cabf5ec3335e5ca98d096c94702060877683443fe8e6cd167c10a5e8ddaec9aea03fd92d061f41bdbb5651f45643c7fece9b3d9506ceb1d8d45b5a9ac250d2849c9315adc953ecde0bfcc50848d50803ad9573369a6ac700d1ac638cce2661a5588b446b02412478797a21fd483956c1e7216e62520a227c930f7695b0072848989a285d21174be8414e7cac59ba6a9cf1c4470895e9c05eb0d36b68b552c755c3b17339a0eea06db653925e3d0629c7a1d4dd86417ba997b816fc87298d3faf921b0f999ce1f5aedb5b384b59a73de2b5bb95040484aeccd63c9d8be58eed0e5389f0dc74ec1f6d4c828495bc3a295284f8b1b0d064047d12f95a1c4490903d01aca8de730acab4a8c11f97110d11b9f7b02091f6dd3afa134dfd43aa853066ba3306482f0e775d31075cac4366ec91db7a99c9de64be5bc31062adea554fe8a3e9d7a571c8bc19aa46a21a15f1297754172ae8715fef2daf1fd8a3bf03c159bc0867fac6fbbcc76471d6831da67931f56a8b419983f13a0508183344b43b9eae44befd4ffb0cdbec41ce071c5e00b43d9026d75b9720067b75e5d349b00cfba6c3e7eb46c3326075e12297ce3270435709a93ae26c8cb2682206bc73a8c0bdc0c2ffd0d6fb6ebfbc97637f34e21ebb4104b345e14748eea7e98e9a3340bb9940b2b644255d105e55b1f36a067d4817a7fc9a0409fe420c8ed262cf48a00fc59c3716daaa1aa9bf2aa3915cdc61cf9f7b0f945f0ff4ecfc11a2acc05542d97c1746a92e5855a136fc469474fe71cb638ca3c39381e6af991f7f032020ae7ad3d391f119149381e7742b43355680b407a1fc7564a6538cad867d7f19731300bd4b6599c3d68bf42f030b76488b64c601f3cee32679921c06970f806f5c166d87bcdcb0d9d9b1611f8888a158d11aad3990111ea3bb8da8116961ee49b9f0e2aa37a0481fd28eb499a61ad9894e57d355e78fd76ee1584faf56b1bac4c120e20429752b5d61c2d898ac1a7adb97a0e08e30c46bd830fd3881c173bfc8a35b345f4b3ff3dcf0129921355cf985789b3409ad5d8a663f18343384ccc2efb658901817a34e3c68896ed11c535e47b9784a4e268e99c5dc35a5f011557368fe4c482fd8ab4bcdc6f35909a14e24040e762ec97a2ddd55031f7a2729d6f64ed2c2b4451bbf7c6a827c6c04781d8bd59e2044b8e8d0672aa01a7a84371746db594a223df0527a59f3704d410f10cf0b51aabd5ab3c9c6e55d934975ca0220e6e9f5515e9ee28f77a080a6940275b3b2dde9f966f33e802a9057d44caef63a67b95918ac09a8f1ab928978771df8fd96092414de3ee3ce9a4d7649d60a5fc121c91f07eccc1bb24c28992e2a90dcfcdaa882a4facfa3305007b875c7d7a792a6f4e8d750e9689ddf544a694ab47b40570248b45db1ae7fb2263b2f35c74c145445fb838ad39546738b1f955c33a59bc38c631e0ebffbf510b1959c255fc1fd4b0814ca63ce7527611ed89a38f2c5d7998080722451ce84952365fbb91166f8aae283730cf04d25b190a1de95a2cd7d0882837da0a62cbdaed0f4f7b4f689c7b98bb615971ed688f15d90f3abcf39c9fbcdaaf88e42c88bdca2d72596179c10b2d9278f7d1823134f7e595d3f3afce8e04bb6d802aa8851d69604f3f2e65bd342d7b353558b0693c9f336e6afa2ed977a5103be2d23c89ed047c4c2b000f0887ae69642d4a3c13a2c24965196065384774aba9eeba4a88e4a6325d707ecfe6713f130e633e9662e4fea6340e9ed791b43e8f6c44df95fffdc1d45afa0ad42c0d947605ae38bfefa773569d2fb7210bf9e436a944d2cf7a103548b0ebdfafd659b378a5e8cdaf2604aee825086a0d092ab38f8510a245a2478c2db0f8335141146a3265117126900bfca750b781e6024f0bd88b31272fed44b67899c3552dcac461fae865a4934dd4724ce4e82b570371166d95c6b641bc5951239f627fc92657d3df357cf97c004336726995a83b1d2574de814b8e83a1cc2d589ffc0994b0961f394b4c74d3ce0c046a78b6186217aab9dd4264a27f7f01768fb8dd60e9dd4d19aa44fdf7d7bd8b562b3db17e13ae6d95ba071b4637227a99b41769a8fbcdabf76c68f8a218ed7d259ec6fdca2d346a0f9043850e7510550648f836b59bef2dff498e04021d5226d9dbfa36fd508fa43852313f6ea014942e613029abcab8496d0b2ed45d0dea9e4056c4598ad6908a55a77aedf036fdd97f42d3350fb17b317b4290bde4d811f25306eeae0db0ad3e02c8602e41907004fe693d02278537e04e6b573afb06197070a0cfe47a683809694c8c14ba3f096121c1884adaed84ec22bd30e0240a339e104c119f5de154f35a68abffb2da4add1db88c7496d0d4c3588f61787e6e1c871e86ae587e33d2e36749fd68c249aed5d8285232f0550cdc09c4a4c9825de8c413c6d6337c81698d900eda1f0bcb68fbbdc33458fceaf107238979f6ddf275979e87e3e2a21a698d93ee2d507acfd7f902a49a5882273c8446858c0ad2350b812d7d12b5a547d0e4020125988b2d66d79f8d48f92d46815d051d67e13740dfcfe717dce96664c0008be8a2170e903c1af8fa943e1416d25362bf2ad933a6637b0725f392669e5876b2035202424a120d38f062b01596a07476f0cde5140fa5739ae628b8ab56e739cbf6dd5bd79cb471b4657cf180bf3659aebf83e6e3138daf03a9928e8d0abe9da41cd31067ae1052a40566c581778738307586557c843a8d24ac61cbd227495d36cc2ec44abb7f92080815b7950525bb4d8e4ab0c5d9bac5495aa6bd30231686cafb8b22755ccc663f5a23b99397c8c3a75512c65aef26b7d804521a42ae86a4497095ce0c67fbdd8736334bc3297a7368e597f283beddac87143b4bf6f6a1290238777e8167862ee922715e5e163d93396ec7716e5f2bb21f17e65625dbfc973cd120812b2facc5513ebe2ea4a20c812ea2cbd278cc665f70d34457c9be5ed9952380efb7e813275f7e27fd694b3457b904faeb6715c7d90623648b11f8c7f5bbd0156e0b2fd3105631a19852362a1f0a0edc0532cdb5162a6cde6c43b81b7987b246ff990397c5336861b09177472f1b9524aeba8b9d3d560e4d1ef38858fdb572a17d9390c6b18020b4d8442e9b7c4f10a33777656b66f313063d3791e3b357547ed2789636296c8234389058d3a3f88a9bd93ed68ff0acdbaaa2f833e8319aa10aa25870f4a8c8554220eb6c74e56c1559fa493c261691145d1b4b855f071d28f1f7dacec372e09ffefc09df5e9437d3b30d4d2e256e9b42ae6a52cf3886de386216bc2b3bdc155663f10ef9dc5ff556c9c3378eeaed247561b86d43ff9fd8279d34097ad569b6ae3a62e007a99b4e4c22e87f8652d9c68d7c154df0eac8111d27574c02fd3061c47ffafe64f1e6e84d3601a7a2524c4cac2daea4fc0b3807c1a5afc2cd4e1e45c139df3b63f14505d299e8ac52c264766710d690a514a644c693f7dfd9a0ddd6570dd302d698cf690c142afec69e28f219c7e5fecd97bd145a0fba7d5171a84807d58d86aa7ae3789ada4946fc3524f0f074ad780d95022ccc0dc713ee2bce6ba94f679dbad88c0be7782774b314d56495ba066ad87b3367c2dac396147758fcc8c926047de354d7b992b48d53c19068890bd63922ef20b9ed58a78e75edf91095bfcc4fed89568366dfff73b22d2907ef3ae0b5861c62b68e4bfb2bccf3df407197d9002cb0dd308acee62e76767604b8c3a8cb8566240cc21467c4ad697bd46da97788e06e57178c72408b9c86fecd6944f4811824e1de9f7fa4eef04b4ae9c31850588e9b3e582dfdcf964c4983bab396465b4e8468c16de6b85429478b3c2e35ba4623ccbe605f4f7368de268c8fbdc902d82a15619c2987c003fdb74ab80d9608905e17760eff834c8116729d3c2e1d1745d6dd7eee450e366ae4d1431836c25100d4af716cdb1fa7849a2045bbff7f6d9c4a3932331c3bdd92d299f2c1e69b977ef13e4d9d4065053603b2e5dda646757d61fad5a3c171bc4da22ee7eaea550bb0ba567252fd12c1a3b933730b43edd546a09b428cb844569e77bc403d17b1dd4bd3e743be83a09e7167edb09e1364bee1ab8919e06575eff239e74c5df4a5b1e956fb2d4d29e15bd2f6357ad126234dd8d17cb71ebcdbc770d65421e87d4ab0a0dfd5ea98d6dafc7ae0759fe6e80d635bcb08c9ba704f4631b90e60deb674cbb0fc87515e7b6cc6c3fb21f7ba8381ce0047732c9ff364e7e0ca6a49fb49604594b5f0252c1fef24bc66d9b1c34626b090a013cd59e31c6f372fd2a8f9c22fb3237a7aff5942ba4fa8ddac47624963e4f97d8cbb5646cab8e2c0fb466bbf4b420e4fbbcc582f3fbd72f1c51e87447727e17527d01b28aeb7d9427ead0c998e835363ed3d6cdf169cab2d87ad1f2d8698811b8eb0851e7e09e24889dad5786d928a0e03948f8ad542ca75ac71dbe05d0aceae3c9b86faa2dab38e5ce6e08f07442ffb07419ca6a8f14f0923d880b858cd0b27440d61dfbdc9db29848516ad7fc5bde462583dc9c5dc59baa0916329963a33ec5ef58791e149ad8fbc0f9c73cd0204f097ba46ff896d24892be039f7e40f920652e5fca53e91f59c503af403d2e8e9a887ac675b68e6dc72cd0fd8c2d33e768302f3ca0f150aa4391982c7155cbba29a998f912e692df71224a1af71177a2eac7aef1f19eaa46bf4bef360081be894257b7a6ccd9b216ce13e323f2be1e7ce6b0628e4c66c54f96b4d34077c87302608d425314711f157f919da6b5b5ed335f7bc393425df842ec5d0be71fc10606626a97494a4942c3e37e8653dc89ff983f2dde66085a7b9d059a2d0217bcffbd94b10e6d6dea5435904d22e17dddc8160f1cc29aa540119ef000699f3f049f141bf261cff5bf22848386ea8530b06a82001cf501bd2134f70d06ec9b115c98e29ebe565dca90b44abb5c35539700072fed9d8ef3e8dfe2ac1af25cdbf3eb13aeca3dfa8d77dea1f6b23ec553154a137107cf4d09f7f9acb84fa995127bfee348cf542507c8fc60f372843948eb64155c39dda143eb4a3074fd55664c9e6b5f378d966317be972fa2cba1f35140b09af26c004f2e1fbbde1fa12f42d1a6f67fda7d414a2d497bd386932f9212e9eca9bac516a92c3df311e6811e4a9cee44bcfff30a0aa37e1cd942b207946b3f2407be8ed80767e1d2318618d96af167249d607381aacd6a0e957233833fdac177efcdb4d363f771de774abb7cdedc2c557d3c54ac99793302ac34369b2de3751a9f6f39c0ad28a3c8a17b7a37860c1454ae39eb617085aa5da7de2d9f731e30d60a59f3b56dbf68ec42d2c9f83f1ae9c943210b66a31e97431415b4715b9682c5ae7a3e3e3b7d85b12c684561b4eb209bc302e6b82767fa7cec050bab9454f206c922168e93199917531b60146d83541e8e11e5a62a86a238f9a3d3b63cc803ca4b52c9e8b26b8bccc3172f0974cb032eea2dcd2526ccff3e807c8ca21a7d65efb1bb2b52452f50649b5c743c7b7999433fdc85bcb15a51ae4dec919306de0b89d7449e8f40c596b251229297861b0b60990ce1ae027d8bb43b231b47db57064ec631a8bb88dac7707646a7516a24cb9670eb5e4ac6461e3e3e8878a6acad77dd6cdb88237190dd70a7c4b8f579a1bd75ae8b0a1e0d5e8ece2345c952f98f8202ccd99a62058d8095e3b828d82133f8c0cf4d8001c215d5f603a0b78218d6b4ea4ba99799bb642f7909c6e40a6cc42ef6cdbf71443fc49ed2920554d08da06137e9f17affbec2ae3e2558379b949979938afb1af56f06c982478b5743265d040c4a85ce36c9ff99b4e6437a02b7c7fdc92affadb25e6506731e9d73fe8c6bcb3f03b9153bfdc089aa1769c45db7d6abf8d984620f9ee8e466ce5c98276a98418a2db0b1c381451fed28b24e9e76f30f2d34c2699c04ae6ddcb9752c6e61b5f1d4211342a5faa4e4b08421ab84811e6326b8816e40c426adc94ab669e9922444bc0b23fd1d4862e74ceac9b74462908894cd246cf03f1c8e43152dff57551332b3fcab6eaf7382cb44643d39e7236e0d789023a76ec113333c2ec2c00387205ff84751099282b1e3bda916246ed1a1fbdc78dbc6adaafe48ad2cba4db24422459edfd1ce8a75d777c898c7a0acd592725dddf982dfd05f472cbe7a18c5a9b943127d1be08ff14e7e986874b0442ba8b3b20e725a1181470d5ad248d29cfb662728c5a8265f32496ff77aef6eef81e58d53d819d29f033694809654582bf3fbe9a4917cf0ffb26967da62fb2ffe54968502969bb09d1ae81fccb61d04f3bbc110a6da58e7d144d74d71ad772f135a40753fd893288b0876722e86dc579b616ad6f1d9ac2ce7ff391b3c9363024efa1eb243e49d624741af0926a5d098ef258b2502a7b7512ed2b1598481fecde64a447de09187c13e9017c6ca6b06518c608e3c3438d370715ef5855fef56164ca889ad79461fc659106bc852275b650147c2c577c846ebc5bb517e1a425ae35a52340e47e49b809091732496b19f18151874c30c38d568ab70966fa3611b5f85e0aabcab41ae4aa5913e6af810768536ad30a09c1f71267b9c998d1a7af1d3d68161d653dc65fe6e55f265bf0dd63b9405d786ab95d89f022b41efc37b493eec21d217edf9cafe85cf762176cee8cb99cd724dbb2af04e83f2893c5b0cd2646c28990d189d5fadbd74dd25a886c2c515046706a38b1f95f503693ba614c1a006eafd642b3b2d15f347849837d48f7f4f116b1a5737d5312d1523e189dab9055305e7aeba42634098a4c82e7c77f0f09ba2a3f344b686d7464752729a7057cc1bf33dd8df67736ef90a25ffa76fff4476f075a8ca5196776fc041a9e4b2653631e1cfa70b8ab128f23e4e8ff30d937a205a18816520c725ea9a64c9ba2e1d169f3a8a5a930a2b6405b89344fe3bfac4e5fbffafebbe2ecd3254acda271e2a49f4df8a085016f7da92a65fe7402855740f430d2394473b05fe9564b1fef26c633bff5f830d3dd28358bbf8b6df1421ca45ee3db8514d36b7ff9efb7451dedc1ebd318f77719c0de6430b1bc5dc20bf53d7923f649400b85d5735d55b2165abb31618e89fcb71a1f2bd5665cd9ef83576fffd1d93fec884eeb30075d32fad41c8e49cd37580735c5d56ec736e9859cf54c8681d927deeb64177066b0f39d6f3d68fd7bfe27b788856f2095b2f10f6de7d05ca00f006af40b3a3a19f935008c17ee899ca911472a4305cad7876cafd8fc41939da0a7b543320dfc33de7237feee1cfa7a56d5cbb9059c32a8fabdd4e1356f4fd07ac064a4dafa185525aa7161d152285cbd998cac31afb72497fcf39481f8dac19f3da4b2174b4fb11c003a79f41fe22c4028b771650bbd6daddf8a49f64ce381bf6157c1e9234e688a40e85e0e9e0fe1229902b8cdce56a1062f7c7f8b3ad13bdcfbd63ae67fdafe5701be7d77a4e4fff8eef0dadb035a353ac2b75d23667a5b1d6c1ef18c15e07d24951496e4be1dc04aaf83f3e6d51673123ec07cfc52a104a0288fa0979dd1b9aaf598216ce477d7f505d57e7552c00883a8dae8a474f0b15d2686470ff2bfc61fcc50bd3eb670deea87a996bc67dbb104a588bf33230502c2ae67550bf6dc2325c8bb6101051b6a6eb4b2024895acfc930d7609de6d42cac01e19f10b06c1f2b4d46b698ea15926341c03ae1a63d945e6a818fb55b77e55ef420a073976ee309b581035369af6b1efe01d64ef522f45a7614459750a75a399b05734907c7593a300972f90a6c332845db1d5ea65117491d28ec47fae271a88c6c9c3b0a027fff24906826ff9ec56ac24a66d32d253906acb3411c33bb4a41917fa782c9e65e8ca2db1ef3c54906f99191131fceaa44ff31474db89f79208633f84bcce8ab1e13324118ba548ba24988f1bf343238a8ab6723abdf054780e5647ec1865ffe97fc1b4d389d9477685a8baeb9e07ad0ed3aae330419410717aa424313dba4101cb6c675cf4bef53488337aaaf19e31b107feb250b8803c197ae2301324374158afb36f13600ea79b56c4ba0513901a25928bb7c35964680d66f673afbd8f35d3c7e6a6717326ecfe3c564db2c9ea762b56a3e9f76626b98a8c9dde99c94fa6d64db6a3b3dd087b465de673c83eff85f97cb5add9f756d5b054a2ddb8a4e6913514777f10aad3669c6cbaad84abf0dff033c182b83a8f2ba4724bdfba36885d1e61a24c3996dd0ad9f86aa9354927db939790f00cc088615535637dbea4cbdc84e0ba7d3255b991ed723f5af8851792f08c7e2f8a523c2f5ccc72b969a5c82a97fb660ab120abca2f70b2dbde0f2ce315037cd78c2a20032e0d9a15e9a3cd20060c388c9824c7b0f94bb5d39125716b9a10961534fc87a65b7c21c72711d3f015ff404b983fbb48d9c7e5bcddaf5b2c5c1cb66b0d2dd56a7b6fba66006c29fea635a46258fc1bca9bc94fe1b2c215cad39f4dfa6580e54c5842fb249be08610aba7e3992ef0cf180d667bd8beed455266324c967f0aad03ca101cde188d7cd77321e4db41abeb008c7b8a4cd95b4008eb99c4936a8f9f31dc59a84039145a135fab48e729b6d27170dd6098af7b125e8407e3d767dcb4b5e17db2f1af2b753614cbd05a73193c7c9def5432aa943cb31b8b4410472d0fb357e6eeb970e7d315aa7760806c0f23e428f976b3e45e71c2b9925b9af7cc541af1a41b7ae194dfc369639fbcd910bf2d911fc2482c0975e70f3754843ea8d99f8ca3779e009c5d6dac69a24fbeb0864d62bd7e07a34135487d8c27f73dbeb6c4b2b700255c1d68265966bfeed13897fa9a33115a90cb63b751d51b46849e0b06b04ec50a13a32ec9a1eaea17de08a1eeaf6a49466501261c7607e22c4841f7c61fea188568bf82c42c284e5d71609766959eaf1a88d4528230dc9f13bc2a01942aeec37c95e264674218f1801525e5fb80425def856acb42a07dab1a99ac257787f6154069036d4cce28bd3a432be1a30a5b7c66fa5027f6024a42535d05c077fad1c4dd938deaf8ddd2ded3aaf91f8fcca77fa8aa44f57027d2fe01a67601e7fbad3b508167c5c1d2f4b4212fc2b1b52c325c263d72e74e3049ac09f4f92a29809505b7f5468a75ae6361e2752b3138870e63c86520f789652460b4e2534c6ef16304203e7e6846bafe4defac6333f40c95ece4cdae87615860809fa5580d549deba7de5e0f1d574f0614f5d75903b9549da20dfe3b7dd0330ecdecc1ec6574c0e62e12cb9ced7608289adf39cde6039c6bbd63fd03d35c1c3314cd1add2f10bdb523b05c2405cc5955e2089a9953c864b82b25e15b6c2dbe822adb1097036a4b6c2f9bfcfcce1624a937fa1320bd05dae573e39410ef62a608cdeaf693b458f3a9ecbaf9c0158fbaa124b75306295cffc6fd22134eeff1926c9259bf2f5e9662d55e78145661391286ddc746f79796908e7eeefe1ca24d69d70bf270ff8a1928feabed2e973cf019071949c8c590db4822428c6adfa67069d2611328e56ff0d9b5a3d903e26c270aa11e4e0d5e50d8a1dbd748278e4916bf7af4e97f84ded6c6a3bcaf8a265db47e62a986d6fb352a614f5702b89df7ca1d23c330e4bcee36c65b513687c2a7ae94ff16d431c55fcba97a1a4a3d9e44def1107417d21db7326324e6b3e0e50d47c294ab2d964e32173bf2bdb6dd829a7c7a3e6617a0058d92793293f97a7e62dd166c654ed1695689749f1081e1258248f294db78e7355877ac9d4e720e7331db34fa11f08cef6d390174f8a729336c56ecc2539e1d089db287ba7e4ffa37dd911a47ac6e84fcdeae1bdab8bfb39d9ab1002d3c0e2aff300d8df7038cd3deddc7a228a94c8b0f14666e1c6882af180c06886171fa0488d8b6c0a5060ab93f943524e949297b719bde5f02d09bcef187b2e82a71dbd53d744cff74774df77080607729401a1e9d310098bf0eac472010437deafa21a0ba8eae1ebb21b71e7feb998c5b65777325b01c5c6d8747a8a5d81e25f19eda21edc2848af8c03ec2ca93a85d030ec0a71b4d531b03cc4d7ea7c5e66f44002f32ea95d9c4184f7764ab14b683f310318d9736e3059e44a7417461ce73f3e4791c2d8a88a45234743990e024d0a2060305908992edfd3de7d59d0b70d5bc4fd16d4c54093c2fb7988fd9f01c81472b9428c44c6c7e89718fd38a11dc94d2a97252761be6abff1a1cc5ca656537717fb5ad825b1cb74490c8c4045f97ac6b77f9b66dd2d6b0f92b6cc4a8a96b408fdd44089241e130cb5cd16704aeb30041d90ac3c1a233f3563219bf294921","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
