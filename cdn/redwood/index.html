<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ad008789ee319c12bcfec14551322a014250bc002172104fdabec5962068de97d9b382540796e65e3a88e9127ae2135b668ab2ca2d28382884850369241264d4b4ef77a96e291816775a484b571ea8ea6549c08a6b2fe7d4595de250734dd72d0defe44ed8e0a8a37831f2241a7ec1168faf83afa26c8684875b716de660710f5150598adccd78f6789d452705248adde571ae3b45b0602e97a9c7f498f86ef64c11e9bde2464ff28c728db824d3245ba3c78e289142e2b01c39a19cd9282f6c390b596c303bee4eb0d75a76e59fbfe4c6f174e7c6b5c93def590c244c31d619f4a8a6edd9d8f8f4b18fc0eed438fce46ad795ea04383d9e7030d4af33e2bab950ec50a486f366d7928737730c8c4cc01676dc08b554c4c3d38b0d6b5923e4fb3460a94c4605d8c370840db5a59db706fb36c6a0fc58d2403661ddbba257e0a9974c2673e09d53a054d4c61eeeb89250e0370d019049ff379a748f05ecaaf6c73d1812877cef685655b0a3b6cb7008ece1d19c0e8e8560f7f7cc66bbe164a13a479ba7750c74f4ae9866c25512af64eccaa6da808e0306720c8c1a01772b0f1be205bc09dcde331f89d530c87c324774d0282411f57bf3c50ebbe28b82ee1be3268c9f053786fccb7d272227b9abf206c60eb1d7a2dd06acfb3ff4d8bb5f0bd01a05a5c8363b3bd11a2f74823f3180e40dde995bf2c208c3da81c16b45883f828271b99e8f8411160e92cc49e629dae2d0de939bb2bd54b2624eec9f81f628ac2ae6ed9ecc9b1c3fd1aae7f69ade1dbf0d1583b6faca47fbb26ffd2eb46bcface406d37d6c2e4207cbd1c883e1965225d9238a723371f3b45730f3e8944d58aef647e1cc4cda130ad0202c622b02f20303abb02d796634d94c156c5bf44018bbcbb9c96fe63c976316ded1a86fcef9a381a48e69415cb5f26e5457bbad86759705e84eecc9ea0c9563878d23136f6f42883b38193f292cba21ea999dbcb1b17d3d5337ccab57b0dcedcb84280459d9506258fe26a734256ca9d85612ff93945080208f0dfdcb5379bfb5158d2fc1af2aff75bea5290468aace363dc7a9d2b88c768eabca305d57e91c8302926e8732ba18db4983bfe469f7133a6be3b229a86c9a2e6e3973c0872dd716a8ed210684ffd9fd886dced6a13f32b1845e3e61afe72a34f1ad22ca5dae8579c6d16bd73aef618e8ee1d93fd805caac716ab746b12eefc17375f1ab0f44ef7f7c972cea3945c43ae2c17528777f3598da8da75efa838d9d180751939cbe35a67340979f793e80ebe075c5611fe9a95a8713acd6f96206ff673fa16b28f3bc93fb4e30ae4dc82a33dcb2e480869c3df7079f4b17f3b3a015f36e7b9b3d09797e9bed5772508869d59f6d29d500da888bf96c2d55cf404a8cbceb75a8f84e75d6bb7516675d4064c30577bac8e3cadd9e4cf5d5930f3dc07bb725a61c7573898b1232adbbebbcdd5027517b0f238e1901d944f4df07993326acf4ccb04f069f76bea9fd4328ae04fe04519cadf928b720ff9688b3e47d46c286473e0558d68b9d5343723fb37d308f190cd8fdc7ec11838b777400c9be72d4ff2258725f0293df0b57d617bc198e1c6648749cd24d9e5f143193e63b2b5c30169fed1dfa0146337399879bdeb5f52383150226a9ea22dc90e4f0a721c6138c380bf73b5560193c501c5a5479f60763734f9043365b50b516aacad21e9fad6ec7a8f7f259127cb491d95c4602f51086ef15245c38e4c000cba1057afbaa53e36c3efc979f286c7d18622624cb8c6349d5a4bf863c0ebe3e2765fe014aa11f54c4827d71c7082ccdcd8e6c974b90cdd1e9721f73a76c6d93dcf3dd94e3465b6c45ebae77b7d1e738095d0f39803899b37a51ed401ebd8ca71c20f6a355b25098672a31adf99b3948ee4849b45c905ef2a84097ee9eba500e38c5e18bdcb4b4b9900080c607954239009f7c174a9ddbabb57154a06b5711396b21251c5135416992e2f39cdc3e7651844be47d98c9d819b9ec6725bb03f3d8cedd76d63fe2024bd30b539839f0fe91b86bc8fb94023e61ac2f1668fcec178901969b83a60040d75f01ff33113a4e4b19cf2a81c509d511957a7bf2276a9fd09ab0f8d01e42e1379b576778a368f61bb1e97ef2ca1c25b82d1de5f844c5f7524533bc2c9af16a67d9ddc8b352e2f74b03aaa4db742cc026ff9fc5c4f05d2d695dfd6969a751c98fd0876393a1f824c6f4009242665470b852dcf6f92b4a587701f48efb96911db1f7b2d5092b9e8b2f39d5f26ac682ba279c3f543ea5fde64fdeebfa132839d446a4d9ccfcc5b77e0d257b6ab93916877addcc1254726a92e464aba9b5deae764e8d9119cc61fe0f93d2d59bb9d27b1a2f02b66f42b1906a0b660037037822837dfb6dedc9fe27709e36baef18a183443af9d19baae7b9beec57d23ad9cde4b860d8574a98bbcada10aeae1659496225d7ad68eccb3d6c41d69d0c3212a1a2ac5a126aaaa8dbe7c0eb804ee6b14e8629b80d2b88275b9a61dcab365a9e85c12c5c7f0a62d67d15f2cebdb3ff0a8c68e122f954f1ccb7231a34459ceea5b5e8c3ed22685eb6aa3587108365019cc33881c850d0ae4b2c098c12079a7673c406e4326559f2769e54a63241700066af0df8fc73a8ce2acf3c853023fdf016c5a3130a44dec66e60bdcadda4bbc7f9a4261b7d751b03c1fe2bb9f6c152ef1dc0a2d33d5e631b2b7d6f6781d4dd254d5e017ccf75d95c60abe43a39c682e0f8cc8118ca9ab43918e5d2b0d47495b239abe71841a7f520436acb6ee6c571b17be2647c263cb0304d3b46304a174a9b780b3b647f98f8f5286684d0a3457b7da3091df81dd6b5d009a6d512752afb83f5804bd0d9796be655b0a60f5279e3a98c01942194a1352853de0860eae93e71863d48471f616fb9f5b46ea16237165e4b1a81e5fec79c9b18169e81ef63dcd72e9b4d757d2b3034deb1dcd873cedbd698df80504748f27a74919c6050519e980b8b3cf9294161b9cfeb6ed56a296098eab507b5f9d449eef829e73f2fdd3af1714433d2a273611b9b3e0e8d020be472299cfc1d6f30a7cc1bb368152351b46c582a817194d91d030897e62ef62838f08b35acfc8e7791d751e51d9da4d2ac69a1d4be641c78e80f84d9e8c69a539aa5939a96a301bfb2364d236ab569a1ec7b2bab512fc5094109bd681ea01cb346c81b672048eb0709c4c50608d6df3dddb23b541750a99d0d7be8c3b8bf10bfbfa6f1ec41d9a1cd575b8a280aae608a300621855687952de84437afac3377d100c16fd1b1ca5187dc78e147daa5491fb28915f5497c8d4b77d354e62bec093972801a88f2208255d994bde6706ab14fe64ff3e62b639f44010f0a72e33be3d774dc1a2a76e302be1b700fb3655c5c50613759bd4d3836618b62935cb852e33c4067d3fbea90062bb86069957622b30cd88df1dc88331ca51c49f233780931a4c7b1f8b4c1be6e6e97f3e0fe3dc717288aa52db3af7af20a43f06a6d6c4e69b624bf94035f67322f0932cdcf93b532bb777b6c3da758a00942be1670dea7f0eb3ba602914d1c30e9192c24eaec229384560dcad85fb06db4044e6c1723efa4ad2c5aa05dc352f595c5a7f976dd94e8a2a744b3d6123ae7414cebc3c232f64bca250b0e6d2c088c42ab71cec5888dfbb6ef54492d1b561baf52771bd01f57b267a1f39957ff7958f9921f3d29b583bf7f1759918b95973e409f1aac6b02f2e7fc0759dc3f8c78e045b8f8b59a96bdac8f70a302ff0c0c972516571b8c818163252550e6e9f88f2c2dc11e9450ce891e7dca9153e9b828028560e9e7e5c36b4569cdf2c8adb197b24789a1ef5047c57f67e1db49c99293319a403f775b6acdc4c00e13263b65119a12dbe207a74001d06f7a660e176c0c928e2b9fff5ff79ba65d522dcd9ed96a0616ccbe4771f18af5d60fc6d47a8a94e860cfb685ec1e0c763f561643fa8f3b777401765d9bcdfb88c71ef1e9f2cf0a2162849ca331c88ce3c15411ce4398cb973d73e70c53ea27d035f57e44c5ed60efbbbe92a34d5f7e6b89f40f3dcb1240ab685ced75589ed784a094f11502a52dd86fedfdd35501e5c6264298ab00f4c6bf9735d830bdae704acf58e6640e3129e80a4db08e5e28a4d4941e55cabccd69b7b4c0e8048792431cd2ec6c1a06ae565dc97955ec7a9836773efc5aed597a2cc18c0e9e87c2dd9497a0892b29391b69834b6a8e4bc97d20cf6075504cea79ff261a2710314d67123948fdd153dfb6cfe8c40348e3a8346a522a05b0655cfaf56c4fadce7e28b57c7829decb394d83f8afa28f6aa505be345eed5a827ebe905ffde3a1a36283d79fcf8370da414680729d35d889fc012a398ffbccde54013cd6ca5a3ccb8af3587340fa71d9f1af010c1194b232604451b0b8b3b38a4aa5b1e9def7f230ab7525664f2b540d7eaf3ce7e43a704e4dc76e6a1834e4e0784695799032580313f2e45210a1ecafdd9da2cc0b2e2fc5a84f46fd4a25854dd5569a5b97b718c6c9f9d968ede77e1544924754bcdee3f01a18574e11ab73504c81d8364029713c79eb7ebb750f692ff6426d58ac9a2b364760207ea49cca8116e44e8bb391a038c2eb02749d39e4d606e4260fb62d163629e643f4b7670de196970eb7e42910d1315130556dd4783888466bd2d6d8f071878a091f1862760df25b2f5dab5a2c6f85ae8490ba6a105063c95572a412a1169d0d9901e4c2750c30b0470b75504bec3f86e26f114388c602677aa1289119e99833c7a5271340d7a20a2012bbbb1e57b404d5d821aacc1a313892ae00dec5d2ddca0659230ae04f3ff31f323756214a88b977b419db6b9df5322b67345f396918a4e21f5f320a42e4c4177b051b78982f5fcd2dcc021c18b31931488b3ab848c1f4d8d0364fb6eaec7bce8dc0c7dbee25afd35ccb15320410ae4c29033828e52119fa86593a6168f46bba137ddac2e2e60d46e6fa92d36f37ad4cf855fc35015d23fd69f2e787ea9490c08a9e4b0c1549474d9054e30277eff3e4a14b0df1d628795041b10110907f9fa78bda01da18599a84b5da7453d3edc3ba4a18de6d83517b162a52371b63e1b96de93858219fafd1047a3c651842dae3f0ae379ed82d709aeeb4be6530ccfc843bf6bb9acab0eb96174b4ee95e07dffef3d846c19e4a7e43140895d92b33d237c734f5badcc2914229c75d33c5d26495d5d285a0114b99fad68e7867ada09ba27f4c0ef5418603463633834269598c216faea0e11a6c02c323dbe8502c627c884250e6f78f02168606a55be667c66b8b9a5fcb34d0065e2bacb4b7a5862f8079c59b7d355990bd68c3c2e0e073102680a8743e44f9e217d769070ea60a3c097ea3deab62ba7c6c5e2b2565aa98b408b0eef49fd2406db0d7c79c909f2df238493a084a2f6e79dd94efcdb1bed01f1132eb1afea4b8263d5c6ad61a15149cbff6912fddfae327f65f49a81c36b4325377b8d0536ea5e7e800a9b3c43c3d64f253fa22f55c465d80d20c0f1e40fa1658ea0dc9702291ed68d576c301a43eb151785106b170749da7dc9b75b2d7a2ab83a5865e2cdc1f35fa6db4c206c14f5ed5438490d55330a1bd32cef53f6be9b4380763553f07f773ad52312dd0003ad3a93199a86dde4c81d0041ddf56e996d64fdc2df66d78ee20f575e721bc4cb29e4d1dc356a11bc58c09bbb3b35a06d4ad067942b516803ae9a51be9775c61768f4ece14e849dddf6039274ca28015d94bd0eea077e6957609b9e670fe97b6479cd87c365b14f5d0bec3674da84e617d0f93208d92b60d1eb7f007a95e55eb1ff65bdf897bd92a0b306f8eebc45aabdb5fa810c68512a88a1ad360d28462aee2f6a5cab5a59ac63ffc6e120ebf75bd0109f0ce38970f31955f9f50be5b51301ef390a5cf87c9649cf39c868405cf403a6c0395be2ae30d366c6583f19f64a308157ab9365a822af39cb9fb235ee7c7be014ae2337747df50e36037530bb151a1f4352c3d1e2bab1a56073d345289c707e55d58ddcb9d882bb9b9c4a6f1f5d92e40d0a095c86c9638ffafb20b1dfc7a05c7668ffbb512d3787f6ccc2427863dfc3ea8bbd501ce8db842e44b5608e7242dbd37a1620af860922973611ed40ea9794d19b8843aa06c780518a347352cd00c00cf5695a6c2998d29a29ba9a8afd0a2a501db022e56e6bc50196cb45dc7a9f11a12fa5f542200cd6040dd73d5d56ddbc80648e23a4e28e53bd106a220a666b77121bc502deb27efe5aabaf753628345df065f0f8995b3a8d0805650043b3e76baa4823faec7d739dd4e631b05732f4d2d6a0cafe7c1e355ae809d01e5d0df9f3781bb59f07a4d673204eb104268fc26fe3b9325d9efd3a01136a4962be41628a0b61c34201f4238d1ec089e7b9d967b320897268d41cdc1ec2d99a02a9b26b746cb793602115a4f81f2fe72f0393acdb96e9edd69fe46a16f0b2f0489a362601a66d431e7d34f637bfab0885c763a70f408594a2a8ad1722098623a9d1caa77628916ac608e5b786a8c48bf663e506e7622498ea1b07c5166f9ee7028beffadc8f28f726d174c4ecafeea3cb4bae9cf51b4a3e72e91902434279e56aa864314c00d703fec9ccd63356351cb05473c1817bc29010a83beac6c02cfd7eaae989d81e1f8e50c4f70e264884c5077862542c9d2426a305f417ca2957303dfc8b144892749292a18a7a34bc1e42be92009e30bde9ab2df3d181c87f408269731753254f50a5c3089c24ee5da4e18baef340d059eafc64845f6c10ee23ae3471d0fe0e735534ad4a818c6a1e540f3911f0ffe85b7d53d585de357968e01c49fa17df002a20c790cfbbd5785af4e6af2b3b4f55b9482e6afe59e02bdd3de77deea472479f710a37cc4d2d71b1448b3b898ed0cfe436b5e43bd7083e3475e2567ea847bc976b467fbfe597ba047963b2d620a7b50935d3b0ed81ca36343d63085c79e2a7ce1b9e0393a141628ed92bcf1f1af2da43c06d370a133b7e77cd0e54a039bdf0acd8d0c5ea0f3333921754789b62f6310701e2aab3146cae0e347c09ab9c1bd90c19a00cdd681dade5603c3c4387f909dbe224eb5d86b2ea47c3c285b2d9a336c44ef5801b66fea13b963a256442e10969fa01c0430a7c5a5222cdb8ebd9320772c1c30c8bd7513edbb41738c6c5d8698043b747f80f99f8e44b9acffe18ea0c597b97c80d28b603aaa23a17ba919714b799068a0f22cc049d94d97ae67ff40c742e62e781d9ce100d0c827245e1962848b87b84bf4fe427284c6261b798fa6da7a8c5566f6085379f8dd4389208702c4de78eb5ac494a36c6929bc6b407ab32e2da302b2cae62a73f0b68dbfc58e5ce972c36e0a3b57029a4997227ce470f71e6ccb091b5f48bc7e636e55cf203bdbb6fedeeb7c08ddadcd68d1349f9bc81e2b848f02fff5186c0c24bfa4f1d940e16b31df9be7eba3634b440ae2693fd502e9cd639e40b243659dffac203a9ae14211a4a176b6ce6ee01fb9cacf073ee2a7abda5702dc78ad52642bc4373d3c7f0ecc15d4e09bd2228ebd6d88bd267b056fdc532887fbaddc79afdb9c4abd6a85b3c3d56efa39df943d2880000cbd49cc3fdce5109cbef1621310968527caff5fcbdf63e102aeebfb8e0fb8076d73a70c17fd966710cc969c8b819de6b4177788f300973e3f8b27a1e4c8356e78572272d8d0533fa33d0feddcf01b5086758cb1b03002e7822eb0eace248880cce4241fd46d05c3e3200015e3c0aaa400491fa8c4d9fa4c302e9ac40a1ab32a65ad751567a44e7a39c26290d71c67175c727cc29e4072be76298abae47b1398e0d0d71adc9c1fb82e4fc7c7dad29290d63f14a5e9c18f4fae70d2d01a92c3b786c17c5130d1c5a42019656657e3e4b0b4a513bf524f85b6deeffeeb642cd8b8172b9908892f1d77fff9ee9ae73b050b923c44c32afc0d38a9e8546bedc6fda41d156366e13b1ac6c86973e4b02b443c8040864ab52880257af481808c5f9ac71be83dd0111c9b7f00f358c1193fac964021ff9ab5efef6c7f51f2cf62548629b931c3505aa4415fa8fa875ace502e0236b1a737e31da60d9729fbbaacfe41952c25e1811a4a12c0c51b4bb89e3e195b7602471c8ea609ca325f991ff2e231a965615e206a53d75f985e9fbd6f260985ec84409fc3050a528c0e127d40dca4627008a690d12d5510862035f393a8e8ac8b9104e08cb4f3c91bf826ff8dc6851d2872077ad339ba14f4a54f6332c957ca4fe6e3a15d4fd71b3f0a91932bac590712354ea547e12dd13f739b67463cc595ddd6c65c84387970b8783ccc99f097feee636ac091bf72465eeb1e1b49d37a5fa82205f3b3f13154f2966db287d59447a783beab27ac335da8c735808b6b341967baa2627788592bccf573e1552eec7b23b859030492ac9d4d2b5b3678da22207396117a34ec13cd6db06fc95b256cca399d9d060e824b0138224a4efa59c675736659af94143085e736ad5fcfecaf0b5902ad73077f9081ecdfad0637bd5b7ec199c767e5f8e0b66424d8c3ca94a926d0ef825f19853b3e0416c2eec534548083f556d3ab4e38387c45fe4cbf73439be2c1bd73504d31fd5f3d08751e153fd94340881a5140d1f4ac26933be15f936a6239e8f6793359e42997a6d5bc5ac4760c8a998fdba481be6a470048ac78075e1b6ec98fa4bd8ebcc2748444194023175091f3bfbb5b5c55d07377ca5e93a69ba2633bca60a6c37b82a13f6a5c1813e8bdcd809290e048fc40b73776b68079e39e2258166f16b8767de8fb220de28ccfebc4b0623927fa6576f5481e559a894b800dea1dba2baa82a3fda7a19121e1bf148e802e6637ff32dddd8dde6ec6b24b2031a10d85a839496672bbe03212e420427174235adb7a0a043f2b697190fa3d4e7ed9f7013d5d215297a8584a79163e02fed6f00c3b8b3c77165f32a33332601dbe9ee7217a5f3f502aca299fc518795a8486b54b1751a359613c9dea2c6c4b1e8ac48c126d0d506302177a7de21ee4966fcada423a6dd44a9c189a9e71ad4bc3607285ea9c941753a1686f15c7a3658b0c96becd7af4c89f4506ce245956dc769201a9e9ca816069144b050abe187252fe79aca8e41f1eb35caf1261a92d4748731e154f8277d5b9c0c1b39d40d7052a2574736e86d345a7d67d3605df46ddbaf83aeca8c4ae0e180531afa49030ef7bb529f6874d9917fd67153d617b902fc38865531a845542d1d37dd2eeb4dace6d85cf7ba04307c59026c45a8e4c22ad570221f2ed690a02c1a2b61beb74779ff493d6a17bd673dc005fdc93a6e21919e378e5242601cda344950941975a2241d98e967ade60d218d0b0a7b21ec762ab46e489ba54cc21db176d62a770f58691ed4d6be690c0dc17a5a40485bbbdfe606fabdecdac025ac050edcb96d1b0bf771078fc322fb3cf57b7b8bb219a2c2bb7f2c1b14762f303d62bfdb043c6f1e6426cd030a131374a79d279226027f3b2505b0a30a0e45ee76bc4bddaf3d6e96c5a0afe64b1985656d08f4e58a4f7707eb39a54534b8bf1954df43920f838f0a9af125e66a027357602d8b39e6943ed0b669bafadc5a80393e520968ef590bb6b5417e44bc9e2f09564acfdacd5dada57bc699de6af78b41e13828be77baaab225a14848fa1dfd3ade7018898ee6fba3cded5a6bf3bfc9e9de0a1d00e7f09c96e4be21a0f5ea14fcb2d54dfa4e4e45db2cbe30e8d353bdc21e6959d0ef56f63f7eb637de4fbc3253993e0e232eb8e95d51eb0756dd170b8c128bef942f8235ae3913828e3a3a3060136182909a25e794c971f6607ce4f1d659a6ec4f27c389b93491f0a8732837a81df1d2847b5403ccb1ead3182e3fff828cf94af4ae4e576269555b5b5c1933788054a3427ce9b65fab58b3b4176fd4ca9bce7fd53f90090b2597230ab362a15784cca77fbadc9fb5e875e38ee105458038d7f0f793c9ac363464366c50c7c932b0378bcbb525a1fd7a45fa13efb421829b377a97b6019a9359a53db18be21ecee29dc5911bfed3823a4fecf188e936981713653200583257c62d90903ac9438f3a98e616fcc011a93a2492f8065744f762335420a7ad475fa65d0b7c4acd9987536b6d70d98a5704b9201c3c5b0161ad1ba0e992b5d599f3afb4dc2198f80498235e3955049cdcdbc6bb11dbd3d2757426b759a931c4b42ba2a4cb579771c8794d08ca2682df741b1de0c5bd4c9d42f06f77e0558cdd1ae0723a11e9208e0d899fabd14f8bc8b873bdc11d139e42b15624198accd7815b7dc99954a08faf68fe05ae148d87471f5d0396cfc060c4dea59536b2510d99839dc9f16f2c3e18767fef15f0497eb0221d58052d05c51c4999b7c467eb5dbad48dec43c75da1207f4e8647526af00f9c2e43394889568e56f1b82ff6f9af46250379ed5d7805a05a7d52572183580b8c08df718fe17a71507d421167e5a11bc0bfa92dd93e1e7d91595b3dfb2f6afde6adf9944b080a762a68dbdd56974ccaded06f3e60384b65f1cf1d450ede946552bd191c8e6df81cce454b85c64364cd43d4f55f6d573597b326c9511792df9d1af5a067133e0b3d96a97973c5a47098ab02453977ad96e38844d43b8e54342bb403750fcabc79e723baac5163003c6fca1cd1fcb92d805e167178bcc1d39c94f594166b79c75390369f9ca19c7b67e7c24f5241b0e11335efab58e48b66e38324c6ace90f74650399df0be4acda111a7482771a5f0e8485fc743b4e1e79b82111c54620e2898aa65d6a524324c7f4f563039de6cf14bf67cd33c3390c4ef1e1e7521239acd9ba8f12b3ae47dc54e69affc67dfb3d6dbc4e8fadbe9043033eec3fd01bc413d9fca56c70786cacab58b1a5282ecf1ad0f5ba5e94d1a5a811828b27fa2b5431daca891bb2374cce4308ebea2a85f5161c60a774d8f789f20b6d14ade554549be7bc752d4bf99fa84fa4400dbad0733196a657be8388c4a11f84c3a8e831390375941dec6df56c2ea3c78b0a6f4e4a3fa011d3fe54315286d7b00db56728ad9fea43854f3a40405efa0f7d33d67002235578106a1f32311fe035e997663bffde4237a0a337e8782cb2ebb4122c7e854431f4b31b2859f19ae166614f86efd7a7030cde609352002353f1a3719b3621110cd788f529672d802c3a61595f5f5d74fa5f759c97a81388057f11daca07213722c98d2de1001586d69c293eb25759b9728083c8fc6df55bb38dfc470c0f16fbd355b312a76614701b855541a53e75f13e94442ed2850c9667968d7c39855f8eec789cea86b14f01fdab0b9a0249a104cee39aefcd24d0f88e40f55d5ecde99892b2053ec968d467234d15e053e29b0f4e13a21c2213459fdb78b8ce2d79474221122c9655089cc0f8a06fe0d2a28f94aee554d7060848b194160835ab1ffe8203af0842490f257469ebff4be8ce62d5acd97202b2ccc72fa690a7b8c94c4545c0e7343354919fb7c8e81a1655aaf78cb379c18949b3be6fe70d69dc002f05b7d627456d197b6c3bb0d175fb0c34b497cda945256c56db811783c116919e538128da597e36e86ab4845583312d25ef2a0b771301567dcd40fb5dd9507c67551b1875fc260475c9ae67b24ab3334a77b4539b7bab49918f99ffe57719338685cb62c22cc99699a5cec1330fdaec0c0159a1a1e9d52d81241c2e84fa209e46372cef7b629e9298c29f1939f18c63b861a53132aaebeb848943ba15e0ce4eca808abc6ab0bd28678ce9341cade5ef0138fb9d9fac9926c3773087854bd2c30cdfa330dc59e5c3cb16ee631cb877316a9e1cabc8600c2f43231cfffac019e2dd87bdeed3f353e640c1a3aa6456148577f60ffe4e243416003d2c7aab7c0bbb5fcdfdac06c911f8973b834901e18aa262085abd4239272004dc90857fde4d1e32db2ece4aaf2a0226733fd354aab297f66c1d3bfb04741f1c53d9e450ac460844d536b9bcfed4d0f43f668e332bc0b6b47bb2f0ae4a3ea0a417d6abfbe9e7c109d7476320a843b677cff1dda1eb36b806e567e31f171d95a2530cdb2ab2da545bc85004fcb69533306e35e4aad5a9e9ffd73d1ae0b41baf3a44c44b468bcddf94d4d366645bae1bca7d9b2f9048dee1dc0cc2361594d0b4cfa41ed15114798a32dbfa415f1512ffcc7d7452a5f6dac7cde586f5b4415793b1e41b8a23ba2c06d2da482085deaee15f4aab3c0cb5c759a94e43088e63da73d3b3b55fc9555e3f6184a4860c4bf40693d74daa819ab66d7a4e43182a5919ae9ba83df94c379788a58e8a2cb3c2151d51bcfd27dba2a6b9da00ef11cfde1851cf79262c19d0dd2f76bff961c273d60f068142b0dda991eca6f33d5c1247137ead2103914a10e82499a121636ee0a5a1c08618614f025c4700a8db9b671e40e066ef4fee6accaede3e9c852f4c4757a564cfc0934ce504ff137ecfe7835604525b8ff7fd3ff4f3fc45bf032f1022c3c8cff5cbbbea3165dd03ba657bbf034495b7ed73717180d431e54ef0947da4d6131011ead19804daf60263738082bfcf0e4921a22715e999cae2f3369e072e27e61a3772459348e602e9f2706fbcdb0f4ffe3d1011f4e6778e59eec5b6b2524ad39fb57d4084e46d8aa433f1e451c8fef595b8e8e74b8c5968bdc2746ac6960131c6dd16635c42fa569e6a77ec2a1df08735fb6633fbf9c2304ffa8df76a7a765d29789311d7b10b2ef0c618ed18aabe22949293f5729805f2e1c33880f2097e6823ec3309fbd398cf6d98721efbbd0e9348e117cd23ef0610c57f4eaaf3c8f9df46e468d666db873a3f0d88469c8475e0a5eac8b9e243e3d7f016feca3c935372398089fe0e48447e244bfdc9caeb0dfbbd4592d60c5a3a3013ce4bc62ded095478cb8056ff02612d0719939083d26f960b62f5092672c9d679ab694d4ebb80dc99f956ddf081d74794f5f82ccebcadf36996ba3126343c0708cbd4a986a1eeac3031674051cd2bfa078e2984ad26dbd19f454b9ccf78e9f6830b755b93150c87badf644a4208e3c027cea668c2be54e6846eb49282a459c87b8a05c94bf3bba3f192ade850cfec10a30e1531ec7459e07747256c31d2731f2aa8d7c8c6182f25ddbab15b5f4d25fc7798defc30d8857534fc456ca78ee33fa27c74e83525550aa37a05d5606332f56bc31f192c9dbbdcfdc7587b583b8d1de9f7ef704e54c828d79ad2ea5d5d3ad29ddcc884fa159dd9615783d8c2e90e1eb749a56d08d22e66906c635adeb1d01916350fd6d744c38f43a10e1cbcd73ace99ad5da5e380c5624b05102039805ba26b4f4240a8daf9c71db2386a91778d3267f152b37b9723925ea86d8a2a5eeb1ae3d9a5befcab09b135f51d84d0dac4cf98a5ad068b1a5baf1ebf72fa368dbcc7620c044187fff14c57c52fee064e94191a02c1d6c47031968450005f7eb43d7c9f87899aa0377fd30decf45f8652d7612bf94aa2d98d0d2b0fd917f3ae6dd24db786eb9d4624944275dc76024309d9401110d18c192ab58e6d64b9075ca4f6da051cdc6f1c978177de5740d512db24c2757b8a4f62224afedfb80842a767ff5459979d59cc7255cb226971c8842d7aba692cd304c4e14c0bbf0e5bd4b8d9067baaaccd5b8d89e15e324e3650879e0afdaf34280b6c6bb804a705af2a9928fd26a82bcbfe5d519d145745da7daa225d171003dbc2890f0f7061585aec690a324df475eaba5ef09e81ac996237f248af7c1180441a75b6efc24d6bec9162d5003b77cd3f40dc683d8434e93cedac6fdf87fe16f36f53c7f268bd0902f094b3617f57dd8dfefe87ced9ab4b31782adab557d487772d647af4d01a32c2d1eec46a7c69fcec1e0af5ba01b81fcbb7580c3bd41ca8c640f92ff098de5f0fc2cf5faeaa6f3b1fee274042f8e4857b20f3da8bde8b009989ea2a6eb54af64331138c298026ac6d6eaca8e0df452f5832f325fcfe5e0666630353c876d57caf6ea6a285f201a91ed5f407ca668a7008b577baa5265f04e4c00c06a64bdbb21155b5794b296c3cf08a26c70b7f39bf493fdaa294cfbf1eb82de506aed15e57da8519249254fe111993dcf0a354bde8b5fc56e21f12c23487d26facb715802d4a9433a6d40e6fe0ec9d23f29643edf19c5948ecadb5ba06fb0ecfcb9e3b2cd29eaccb82bf39729f0420a4ae2a4198c14ac9c83dc96994efe39240fdb84900e1b95b87445813e0268dcb4bfccc352a7ff2f9c0f3693ed99dda2f874b693345003c513d46fdb92edd37dac2bd828c86aec760ca118180f0198f55fe6e5728d94e6ff0f2fb5eebfe39fa45914a30f7f7b7546d40ba9d1aad8915f96ab3b305386f828d99cd27aa4eafc304a3ea8499a85ba5b09227829b41b8fdcd8d3c02cfd9bdd3ebad04a4dfe673e60c82618ceb3535930145403b7c778120fa9f7b12cc13123c12f4e904166d2f147f701ad6ea486f557ab4072717a7624dedc57de6175aeccc2fa6dd936e6e3dc7f5ebd2bf8f1a1bc85d3530d3843fa990f566438ae99aed37dd9f23bffc738ae33d246b42065c3d495a8a3bda2d321fa215f40f9c9cbd6229da0fc051f15ab34c929104b35a9c5ae10b3ec102808a7ab42ab54ccb1af8666af2cd0cb69da1d659ed34cec4ba22277853f5442a14675fbf9350a6eeba7e4a006d3e30b02540e1fa8214aeb40b89997d91dcfd486bf7f47251f2103df05eca8233b0b1ad145efdb11f2ac437c3811ac2210eb99aef872d5446e408a697b814e084e37cc3719978fc0b567f5d6950aca732007e78ebc4da35e26c448e7a8081b3ca33b744a5e3bf135127318bc5318c83d5015b1960085d815702429f7cd4911efbff7d26a343bb421361edf87092af86c80657176a3a945843883a04e8467a6d9ea3515550049b8231250c18ee037c61914b3381d54fb5067640e5843934374290bb0b607c0a938f92369ff0c0f0c015e51da724ac4aa7089606710b670370bdef966273681c3f6ffec4ad6b8a7138ef32b572853823c529c7ce76fac25ba334e0fc8f2b493751a136978f359cca0ea9efd3f62dc2e05f738ef5ae18acee997583d0c78c259f8446d179998777246395acdac7a240e85f2ec28c96cd94ef38b5cb0a55aec015e67f8da1c1492c5fa8172ac722be87ff3bc8df59d0e4de2609e905de6888a7ef811cdda02afa672da02b56a3fb21dee07116ecf101145c18d9efc4069e206e3aa11121818a960a19ee3faae0376d9a3519e27ccee33f351c7072209f5487c276e8e15b2f9013445c91c59f56e0bcb4b9eca9232ea0a83ec7ff855959fe1533d4c0c69a139dec4558c7eb33e7f77a4daf8d287089d35171dc75a2450041eaecbaf84cf3aa0501c6a4e996ae27b6e6f157ae6c0673885975c291f8661ba46f4301bdc766997ed2db81488ff4682ac63173df1286e744e1e6271cbaf00e078f0abce5c8e4dd9774349af400629f8f19cc825ec77183492f151211c8969d2de797c647af24dd594a9f2fdcc305a4b17b0ef42a000319bd069027ca649dc839b62d7351ce7dd74c377d2127d7aaab43f05be667a48485f661da98c6efbeafcb364b788e03674fa0acbab69a06dadea4d2af1dec972fb1ef9364fc31d38e79bb0db798872d01a5f65110676736bddebe0b70d61de471d70e9b2a61aa91c8a16ad244f3b229be63abd9c9f8ef135306ebdc7e30ce65a56c7e9bd469c84e968b7cb86cb316cb07194fcfa50e1ff9c0f19415219f6f8c116ae28b556750a7b2890f47dc312d868014e0626bdb8941ae6cd9848feee67ed4c3ddcc1d31c25e760172b9d0ca44bff929cfe2957fae63cdba978a9debe1b2aee7573d1166d86d58178041a3a1d3378a60a3026b57065a3e6c58bd6ca7ea1f0916c5be2308129ee177497b5e7b350852a1edff01d9ce7c57c962c12ffb648afcd136c543c929dda9870be03ae326af07b0ab50169965fba09066677709cd8afcc4ae6e47a60549292e401448b8f1eeca5f99f3c5c9d3480fedaeb1d57c5f4215f1c013942bf0745b3b29da2cd99520c13d72d5a010f0a7e257709a810e803c73b08a9b741473cc483987137ffd9f264abc956b686d4357685a25a92c7daadfcd88612deb3fb79f3d8812df2ff6e1c2083f446307d5e79fa61265e4a71dede1212e3116709c49d3617c9ba16b72e8278e7f427a4b2a14f1312a24caca69659f7910fb8f6b349ed52b2dca740ee5e2ac3a0215654405a7d0c37a0ab2d4dae0347d091fe75695b78c05a8832042bdb7fae38ffe6b6205d9de458b26f32359274451d287445af676fa19985c760c316c2d03d340afbbed8a0ef384a3c1e245e150c2f18f3dfac79617843ad3b0b7f95fe536f54176d52188ea88560f754d42adddcfd0aa9c6eab88e38450b762a34cf8f52879975d9ea0b4dad93b5c0fd87cea8d8db0ab7f61b6584312cfdc9240b010029f00fa301014d11da716d05303ac0fa06d7c7aa81ad82549c0d69adf283452877f7d325b9457545e0a9f485d82e5e86ca77b719a90e58940b00c3d4b5570ae1a7d0c98ba8010f29496d69b360189b955b8b69005bb116ceebb6adda386192f66213334664a26461a533b242f7b0a797c980743b186c0ee41a8884cfdc492a4a44b8832cbbe9c2053407c89bf317a3dfa0e2cb18b9a4081e127cb92a1cc8e324ae7edc160a8d6320ab4c78c69c1f3d3fb59621b410f64dc06bff3d19d3edb529a7e11519f7c5da62b926cb0d36f15e5c46b77f74b2fb5cfe49b148b0d3c58b23552547afff2ae73e8a17070668140d0d066e837a6116548a36228f35f38ddebe417b3e5c980ddd5cb5a29caa4f4b2d1156b2ba4c643e2e30d902ee5eca3069721e3193cad0a159c98b3ed5b9271ae0e20663f9691cd140bf1184f36ed527865e998d80c1bc185dd8a608a8e83a12a3a9fe89e9fec91f8d8b99e779fc76577bfdc74ce573eb3c9d5a1487b968d0cd516c4fd9587d4b6de34232c192b6f271c052da9d568be8fced400bc173dbd8003fd6381184d15e6b42df1b909122ec0085ab8e032d4fca7c44f887a04be15b0ef12e9e1e1c247443e0bc5e0bf8f39689a42be1d06a9d26cc4d9eea60daa34a38e47779b6d808cf3b3c6def2ff7c133361c9e301a8828d8527f881819a0115db3c2c58a3a4ec6a471b6c85e833ae1017baf96b3027b04dfa5a369a4c08759d41bcd09fdd4e1230aa552d724e5596bc08e8b322b401c61ccfb9bf95fd4a570e11696b5ae590ff7f424cebef7d8cb93964b94ce3004e4945ddb7a1fc11f4b0c18028c384fe79700cc2e339df6fa1ab26df00561f33748494d3c105c9e25204c9d084a1be5608dd593edaaf72046ced294884fa87b48ad069fb684829e79e5d7bc58feca1083c2b4531d6a5afa4cbd84fda997083119b892f1a2f6ed30be835b0e7c1291581a1d9afd0212a5e7439eb6f4807758b40fc025e3895764325de793499dec91fc88e94c33ea6001cdcb47e1a29fb59653da8618571dbb264323c086b489b0213ba59b62e801a28ee07bccbd6d0677a34d2f265866d598ef8f69c77c07a606e7b908dba649b1747725805fcde832fc2920b5592c306b5ef122d485957e6559f563c79e38d02d6fa72030b2c7eafb26b9f80b79eb325fbab8059d7783b3526888aa39a08d6cf723bdd5193cb00f4791a77cc53e6cfa7bd5e469ed79f70f34871afe111ee10182fd367d28454200b58e91300239133d67306565c1ce46df167887c764dfc9dadc9882cf9603515710cef82f71cf55e52366e8cfb938c41cd2aa8004ba3abfb663ed4e50cc38111ef38a3497eb470012daaed51bf835f0c6bb55c3a58f7306b047e3889b2e9ced8e76d2609ebac5a4890c43de069265343c03aaaa6814484b9896fd0a8ecd5c961012ce86b588c922663e76ae1792b464ee304ae866b7d1aa55188e10c3888b3293d8cff8a1e3fcb60774f54c2df852c0848bb59e97a491cbdeb71c48516fe1928fd7e7b4016d493e34b11c76948fa1047a26338eb91db88a0ef70cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
