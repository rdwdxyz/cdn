<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b48deb8bac18db90942c66f392db75a248fbbb68dda6bd276cc48e326eec783fbf2e9169999d841ef3b7b97ec3aecfcff66c772ed56c75d7ff71f6d8784c6fb86e34ae7bad63ffe8e206ecd246c43eeab439c1ec073ea9e9e2b05d35e3c16ff280d9db78f90fe6b4aa07817cc440a74169c9212dc05bafa8ee8816b9d75086f08311c7c25b98c94d3afea971bcfd85eeccc90c4bb329b6ea47af8f5f0124c6b5464b865c887de9cf05422f0c070059ec9e4214855910605a87d25136ae71e5ab93da618813a16a4e56a275973d988987b93e83c31964e315fed06f7d6f8e58f4d476dd6188a748d7c84ba7306dd95d7c10f6297b0a77f7d5dbb91a33d1a2982695c57a661ea50d8b278a053a5c22ca64d57601dac66a3975a117e344df3b815cb293e99196de6332ad24f1670761f3f84f82a681d264d80824083642cd8728ae0b837cfd42e9d8befee8ac1a0f7fbf75c51c4c0ee94f7c055deeba164cf21b56aa31e05c35a06cc4136b89cb9db035d43e224cb2cda1fefffb665d41ee1136927c7deaf46e6fd220735c2ab68c5132b20c7c876ef70e63b25c4253f198335ecf7fa018ec4474f957a3f7e02c20049c25853b544d4b65fda598a4dd77a07dbd41b19ac0fee6a42e83bbb3aa5dcceff67eed26ead6e50b0474acb157861d8bc63f8610983bd36bbdce520a1bced3a044c9e69467fd4ee64cf0c2d32139775d38cc8ebab97f6d5890e58bc7d78a389a5592baf0a396ef87823a20214ce78ed583d28dc8ccd9a4673e27cede086069ea948066b9a2dcd0ba5e17d33105622e7210d1ef3ff73072bb16e51e93327b459ac18729141380b543d999edc544a6b0b0df821c642598962318f72f91bed8e05adfffa5a4b2a6f4ba5268e517304293b1c3dff5c2597b7921e4c41454379632e50f7d17e932faaa8136ae95a2eb092934c37a255ede84a324fc872590477d67d808a1308f86bf82146ae88a233612a24f934fd835bde90a61d5e818ec54c8f15e81d3158b3907aca2d34c5b7d31ee3487796081081e2e0a925eec3fc3282738f1cd481fdcff9d8ef91b4a991f0d16160afcfae593d332ea5a0b222d905f7245f2fd0d0f0157eda5c3c072d4d94dda148ee6b47c619b8b0951942b490f1eb46816eac7401bf4d92a8005465f50896c31cb536d1d0a44e2dd7d2594cd7d7f2585c0709bf8c04a40e89191aab2eab64ab225ce0ac6f3caf10c28387bbb9e6c39345cbbd9b81f29f24954b3770a4d1fedfd2e7e5942b565c1377a282051158823e67a4342dbcb7409c0b1f8821f705ad338398f4e35aa550e0b1907030e65c61d6f777f9778cc58feaf59513aad3e2cff6e30ea0e0af47c107c428e86fcfa9fd199329f1e359fce86439f6ee9c3fceeca6b0d3020016a8eff96ede6f07a17b4e4515cad91eef32e8fdc5919233efac0edd74b95be12b9aa628bb35f5d55a509667bd513c284821f9b6838e2d518f053b6d1e1a8329f12dd4ca33b2fa4a357f3a869653eb6d86e6f8d82fc87f8665bf5191d4eaedc6df1c8c15416397989bf6539ca024b4a005d8022246b01531c29178ef7cf71d57fd5842c3db8c7352077ab1cc152893abab0d579adeaa49c379735abe49c8138f5d14e97ee14ff31b3b50c68d28bba0259f138f80255b80ecd70d39e56a084b0040ad591afa2a70807535472c109c7f6761afac81943a0a71bd86a449dc44ff838adebb07a57b380936e1828719862829a580d48003f6efb6be95cbdc2859d7fce18bc6f09faf4188830217be291574bd40c0f3a39e522bc0c115a1f1e0b916cf86d7679ae20c1cf215a7f9ea69530ddfc78c2a40be5e88062a2751aaa082fa4284a3027621cf64312dc97a1359e5e3f121c74ca76bb1d82eb3a84bf387340da95be95da4afdf0f301aceeaae4578d54ea76d9fab650ad4b78cf39146d82550e8158fdc51d7ee97eb0aa899695143c1bfe4a5c5892ad06d7f10fc487bdcf3ce9ce7a4412f08200a0f73db18802de9eb9723617b161926bb7cadedc619e7c6cb48658a4783150c40f6b682ef8c33a1b9ac4d9e37d997e4c1fd3430e525c17638354cffd04455d7a09d795873427cdf095ebae18da6b1f1adac225547801060e1251226cbf7c13688d4f84af7152f97a1bb9c71c51f213cf764adb4e40322f33d275f4702916603fb362b66902f6d17c44ff3654fe5fbebad58597c93d2b388fa68f15b8b43783561b38f4075dcecfb633012dbeeb8c13605d1dc9c12130de8b940cfbae773937e3e7c95d2bd8132ba7fe0ddabca798c9cd8d7a1a4f702ba815893f5b11ead8a35647390a9f9b694a0cd5d67a6fca1b0430f8a34dc8ee8dddb16c623379ca4bf821c40b1856003d78284b6a5e507d029ebb0f10642cfdef28979c85fb1238750a29812a342416c2517bfdf4b49cc4f20be4738126cab8311bf6fa1d0766bb18e732baaaf9d592d1d483346a9a7816bcbbd17765884a60f9378372df5b268a15b2ffffceaadd000bb790d2098654aa13f50b9a3f4b629ce76b759f350685feeb142ddb510c8b131dc04298d6a9f400272fe282a6d152d8d9f020e25dd543f08820196c53c80466c97fbf3183c7e5e2844b3ce554d9d90bb92a58d8859c03efb96f5df4c56726fe595c5fab470085d390dcf6d947e59cb95b832c7686afc02122056f5ecb53dbccd5b1de447e8ca7d0813485f94862a2a6d3e59b81d319b4c1371e02dce20e7b8df24cb709b915908d130344d3e5ccf68a7106a990f88720d5171c82a537641a09a518c7c221c230d8ef9ce3ddc687473506b2064d54146b13df0eac0cb901aad9cf3a6cd298237ffe320aa1b58a013c37081521cae20de2722b7777d37055c03d34ef270615c1bd3c5b3ff3398660d16462507c9f8a77872061b43f32773dab9f6cd045939a492c326c5f3940590ca32dd539dce255ff20246f1f7d330066e563334ab0c337685f339827000c6fc29dde3981aedc8407bdb3fd23a3e5d26e238d126b99d9000981359f88bf611ff3f1298ab6aa44f850e12c101a10eb8073ac265aa0b3ec00269b3bfb8127548f1ca9d56082ea618f6ff47e08eaa9738a00d1b891592e6ccb678c3909dcced8d19e0fe8b4d181e289eadcbbddf5b7c2791b7530946a593e4df83e8d2730127d786ff878c546d71f6218cacea7e4c3d49c5fecfb56e24b80dabeabd8ceb615db022647c86fc19ea8896097775e4b66bd129d1b597db31e17e5e6fb8e1217bde93a33f75eda7c2bdb46986c7364e288c57c44d79573902cae515dbecc726f9688b5e0ac6766c208da14e7909158c3a6770c2e32e7898817f4ec098b1b55c5806d9c45890106316927db6d60b8c9c4570f3ab5043ced1602c61a9e0612ccd5429f1b85c4feb6ff9bb696f216b96b776fcf447efcfd3eda7b7f56f18f0ddeca66121d6539b2490194cd3ff05da925c15eb5d0c97e85433f9a85917f1c98fa276171943fe5d0ec92b532215742e95d319bce5531f0cfb2308c565006447e26d59931489b3ebcbff4ef0b1a67ee92505c12f3db4d956a45a9b8c6e7eedf31225d3a928da2edec4f2bba81832c0864a45b92fbc09f9d01f75cfce7ee45844045acbf9ba3be24d88e709035a80dd3381cb4b4ab4a064bbfbafc571107f6d3069b185dc17a05e9c33c6ccfcb27b1f2437c817471f894e0812c4bc5c1cc1408e7733849e9085e33c2b18600ccba4adfe641f5bf2a51ca735e5e2146d89673c82c404ab5618f4133531627529745be66e757e2dff078864ddf85a71c75597eb64aba2f451d1549a0e1135e02425271874aefd3b466b1b77dfc29c8154bf95b5159896a5f7394951582e650b9dd309f3403c28de184cdb6633854543e3717fb22a5b02f96c637ecc8dfa82caaa06ef24edf6a96e9bf373ca8df7d33a79c8d5908d72b582017931e503f1664b800016c08d38f0d67e8dae74652d596c679d64bfd61ea923b3ca38dc09dd6d3229f64e7e42d9c098f12f25c7fb29d51abaf5bec1bf6d0d6577c3ea02aeac94fa7b9dc2317b1d527fc03867f1b8ff24e5c305c613c591abcfedaf4fa1a488600130fc55b846c1ad708c04837af6d18d690c0f78450d5b69bcf9034af4f4cfd61b5509e5ac611167bd9399a793da88ae2e96cdb5045785afde697128b55533f455ed8ea488343542aedcb4747719bbb13a860d08c5cddbd059fd80675ee559d14149ccec7ed4a54cfb7c90c2611d13af58213d05dc2418711dd32559809b0294bf0f8f79ef26bea66af1df5dd7e23df81e3185cf7f8df885de435c3e05df8e34a87deba5cb9f922e04d35a369e30151f9f5c4c5084dc5536c34d14ffbae22379933287b44c3f8fe547ffc391f680010595eac8eab05268aab0ebc4f0c9c306fb91a3ff171a996ce10556a3abebdd48a5b09519ef552d984057963429d6896df880f9783cd202cd953ecb8c54b715e32eeb6471899df58113077287162da89f823bad3530bd4baf4e372bde177aa8e944b7e49dedb9f76de3b1d031dff7cfcf3c2a821b67ffcda87d01e8af59c7b3594e9d094ddae9c9a12be4b00b5bb99e539fe6b48c95ff5ef4605bf7b8426197a30d5dc2802aa5dc696692fd5061234d32d26d62db99d17d85ce7b3f47f4f50c7b113555856dd1d84c83441c93ae75b267dcecec8efcbb6a04fa69e57597bbb15c9a0e86b5f850853f3a51f240fa80de08563cb10aae21fe59631cf5110069443893b61fd1097bfdb96641a7326bd18b4e3047f10db74ee1bde218eb3b4b4dec3129374dc92ba41ed27392c18db9fbf3e3c8f059180f40a310ebf8bd51bc4e72e4593bc28877dc4ccc6e497187cd46816821b135673c3f17d712bac3657c4d88bc4b1bb7544f0849b06ea980e22a7fb25a350807a1a81e5dd98a6c84450d2677061c8b183e844eef29837588fe6cd3e1fcb112779f3ef25dee65c094578149b141cf1373c2d133733bb1790835c130957dbbcfe799b58af0d9a0ac222ac4f5931d0200947739ca0f669095e4734bccd06a922f16cf73d599b1af07665ec0f4db79ccf51b2903f5b3acc8b04859133d9b597996faa0ccdc7c49e584cf59932124a5631b645732d5a2312142025b1a89cc455184832990e5d7b8e8d65c0e2a5fdafcd4e168aa7a2af9809c704e718d818c07c0156e0a18a60d5bdd1a13bfa2be7e4f36eb84962cd268bb23d00a096afae2c6dad1c42980d42955420f9e006ebff55b6f2e7d7846905ff587014f4569d7842b3d845dd8b48b5d27591c1be1902dad7911acff4337f763cc3c1992cc93f608fc83987df8d36081e231d38c3c7ea4584a05a14d44512f61427f13b420cfacb1ebf7b03043ac12f470ef088ea05c297488940187df64ad5aa3a53ab8e12befaf6414ac106c8fd847bbf5a09debff1b9131765f20ce621c68d1a35726ea04371ed136cccbece3f338cb23907517128ddd19034b3125e87ef09b981a9f6274182c7353b61f22b2a27422f4291f068bc31ba0db13b726982d31c14b94508113837d8df8397d97b0c26da53050d35a80a72cd6b3fad4f0f2810a08841a5c0e2c8a0a77da77366553283c12540c1e0c786231e2565de324d50f4fb37602816c6010c3ee29ad07cbb6c62116111a082073c0c495de2c5571f031ab3b8c624816e791ba7181046f59420a4363e327fe832e1c43ca55b08a53aac57f43d59b61cd43023673ccfb0ff4b492761add2617596b567dadf94cc71ab92d58859797db2ffd097cc41387cd1b58eecd6469322b6453b6e38ce298379d5affb04c71ddec3a358b8d2c24225922db33bb35c8ce02dceb9727d478a6e68acd5913a9cfef3eeeffa53c4e3eb2089e63d8801df029e71e7be79799f9c55157740a394fb5713dae3213ca84943ad8762169c00d96d8ba2f4996f2c0cc757cde5be31fca92d71665a5ba22baee081921fe6e1f614c97eb46bee966759e539e49f10668cc4f7d22e94a311838babebad60413552c4c324a3ed76b41555984b7f342a0ad0d924b4ab5736eba13c23990ec0130e21da0162c0dfe76113900f8b7797b0cb2f4fdd06c38bed107a610c7f997f15fc4236ca936da36160151fb2473a24e17a7292e70233a91c32199ba6562c4d5bce1f1c3949a95af0804be3035ed4026795d9f8f5e31166fec78c118131b5055112c2629a879bdb357c728a6617ad2d2e51e5a3e6f00fbb78241d76957dbb1de2403d30460c85e47f5c5555be04e8691c61f74c57b8779b6ab0c7417428b7e42f20f00d50edcb043463344bcd0668049bb725f6e4d22c50181cd3134c97b77310717b5a05efdf9cb679fa41884b29615d23edbe26db1017c8bd2be771e9a3d684c8d11d3fbbb5735dd92bb8ab5814eebd6806e6baf6ae131e7f24ce431f844f439f809bfad7e8d6cd53f99ce637ed11686cf2b7f53cec2b263dcff67ffcd28bfb1929426289ebe132dee5a17e33465725f0aa0590dcb3004ab28f9fedac50889d3ac40e7356f6f55075fe087f28f003c433c9fc79cce3177dcb4c3c9d66c7142ab0227500596457a074748aefec92fbedb1a8fb1badaba09607ffa55fba566459530d2c98b98959b2a8a73a89b24b591789fcf7fe0c93d73b6ec7cd449ec79746f04f34db4f12f4be0750a42634797c6d749db233687402beda329b5b601db1476dd49ceafe551fe468c2c3eda248c228e49f87dda60d5f4da75fa220c786b6e4dd077af2a2b7c79ec1ae3fb00375e7b220f3558133b250ee42a799c0e2d0ab9f106d1feb891ce782a64a19ddc5fa84fc3bb3a205fe3575264da7100af2089b92f21e1fc2be55ad5bb80f3021b90f506909271629a1f444ee176ea18ed50a6fc4bbd310c0fc478427e3101d6246b15b7e3c50d6ade144f5df2600d8749c8c1e78dc603781cc9121e2ddb0c13ca01f9f394b4b691b10223a64c3cfab26f79cecc1dc4a6dd16a3eeeefc58e2b3b36dd2eaea4e9376d7eb3bee95891c79e4d950170f7ef66eb4a9ce8b81965398e21b88edec7eb8ba1edb541c8decbf076bc66129873a61c47fc603635e6a54e9563a97ccd3bf35b8a273e545a83266ffc36c3f56b55d7f3cf8cfbe9f7dcf0d2b1fcf75f6a6fa536864a0942b788af0ea0c96faa68ad763a9e55125c194a8b811760fb9bbe2725261c686759966affaa10c9a9e07265d442413fc880f5f131646484d3493ffbf72e7cecc2c170c66fffe0770b0952f292c6c619e3059925fa19716fc0d27bdf5956cf68e6420c51eb7af641469b789333ce3590da412e99129e24d810d49a6471fd26e1361aecfb422cc3dd0a094b6fcf6ecd2dc51ff9349cf3dfa6227a685d73e5b2d946d1294e0327b695fd2cc33ad3f0aecc0e190ee9bfab6c80b3250cc1446d4bc4ede884c46e8fcddf2804e701b2a597c2dda7947a04fd2ac3ccb591d77482557f24681257ed229e15046b54547149f69034dea94eae38dc7eae1f48f151bdec68798c65c5492c76536fe6fd6334643b7e3c390df73beea8fd3eae5ebfdf562f5c29b2da2ad0fcab5b14aae7edcc779c093efe35f6685270f11d3b66850aa509b0ce4d7e6bd7164bc2d9fa6b83b80608d9bd43239f9fd7755fcbfebf8a8b61cd4b02ad8935cf9cc9a7137521defe41198f1ef27c52c68a70686dfe40af00a7e6805652b36a63e454ede74949c8fb92ff0a951db78184965e85fbd4e719b42fd4cc5354f80103c11dc6c4104912abd043383e7a1329bfaa38182748f59adef3180f277e53b42d7375153840a11d76d3166e59e66bcdf2a137a409e31eba4f274ee343d9658d5918a94508a29abf27fd036e46771b2d76ac3cb91fc0230762d185f996b5e76e880b2f7a5d3cd18f0408809967646175d576c3f6091770252ee1487f2f47e601c41fa63c9084214a7feb3ac9ce5ffe53d27465211b973be172fd2a1f9a30057065b01e943f280408c59edda1acd2ffc7ff42a3957b96b9aae52290e8a1034575ea95e3f2b0dd46e93300e599d63a957f1738912ec5c73c4169711d6c911c1a86883e0900c6fb1b639c7d29b328ff88190611ffaac79373a1779e41d8c246cdca40b0974960fe6fa2a003b15c81b5e3789c525214476931c716bb38408704e0ef76a09bab22eead9dbce93a623937a8acaf7c5bdbd52e2efa03ca8efefe0d7ae72c571e703305f6c46d62304f32c7e2c29ff605e7c5009eb16445807004f27c4a6b52eb0eaa45bfd06cbf59b1c34310322d5efdaf109e860a2978a11d0edb7acb82140b43c919274c3aa7cbacedb73c1f01cdfce91e3264217632b806beeeb098b35e40a65f4c75f6e00bb3256d36d5a8f5cbf866d4b2346a55b9f52f001732bc6c3ada59d909c15be6d1dd78703a4d31e705879d3c1a1d4a55ca4aba64852008a8c4339a5fbc3bf395f478132dcc1948acfb6f21cfa8c8ccf7c16d3132a181d8f0fe12c1e273f593c8e4ca74f503b8ecdc10e6fbaf5d34cea8e601bbfcf95e347de9c591fc6f46a05c8bdbc2047ebb4ed6b81048b8533506b741bb3a58955854cae510cf125eb796ae8371465e3e2130902db06bd48b081ea2904197314e91f3a32928b9bed6964dfa78e1f3efb27bc1cc07754c2c724363864d481248420cff134204173a1abf83b037811c493f02b0a26401fa86dac6c06edb2c459157cd0adff92b5bd572be7f150306353baa56ef39be23e413805f3b3f55defc09fab89b3e42caef3a8fcca206be7cabaffac5257b51885af0f7b1cb34f7b7b167326003174147efab0a6f7e3252b4c2e78b2d14f564c7f7bbdb71d5038081a43935f871f83881ccdbff15a84acfdb1c451d2f94acaa9780cd3ec8912828cd1963776997b2004e72200aa7c761b00d19880df9e9b6d8743c6ab2f3457add9e9aa2dd0fc6034049f8b028ec6f3199c35ddf84478a630a77ca6b96fe72243dd745e835a0df399eb7e7c2ba56708920ef25fda8309ccd13dba04f6e36cde376abf6b5532583caee32c07894d3000735b070809304cb5ced8d7be28bfde1a63b63ee3efa331c042ceda26703ed42c485377f81db3a572c8b5a5af251779629952d947ce2ace851225624073f1d3097695e4c5f7bb13625ddfe01bcf413ce0917c1762d7b7482d155dd6cb41cc7f7e17f437cff73bb3364d3ce60e51271c3bd1ca3dad4d173806ce9b84b8f9c98d9cc967756cc1a04918dc4ae18eb8fbd68c646f421c10bd01f32309b5ae761139919c52be2a046e23a35ad20f5e45df209f7f31166bc2a6be975108342170fdabe45f7e78177f6a98e3cfb9a6a2e1054e63ca67ab0bb999fcf9efd786a1a083fca8591be183e96cdfaf969d8cdb9a0f680a6dd3bb565fc9b1421aff0a8fc804fa09e274c944a6ff4f7a9794369ae1cceec1455095d11a284f9fa3f63674336ec5ce9f6fde70c54d4eebebcdd94505384fac1e2827b9e5ee2e2bdc370b619ad02d810d23ca30e5723b9de444f6a606d97401d2a001c4249835673c6dfb0de8ace07baa9e9a8eb52e61fda140438b71f7175a8ff2a3c2847e9ab26f7f5380b9e6f5298f2e5b15abe134a7abd0a6962e1c21860716e7eb5096ea5a156897926e324cc255abf455f9ecd1800e99580a12a21c317b4d3fbab56411c73b03c8ed6316bf919e79dae7d49f8da7508285678db30c7c3ba2321fd7525b123b84f53ee986c20a1b0a48b35b3f3c834aa02ea4049ee08af8cd80330cd672b8a3b24a5beb68d469ac193c6df71fcdd9042e11021cca067cce4f8669b4b49a3ad0602ff3b86a0c8b89cb8741be38ea268dc5c0111d52e205a8fc2d1b9587074985cec94b2995db8af27ebb78bff91c6bd05369671eabc025a5719482c46d75942bc5100ec5a57548cb38339e6c697fba9cde7b76c80f8b6b19e088e5c1f3b421456d15a5fbb78ed62ca551e655b14b36ca5fb7305d4966e47817ff96bb7126944a853f7ebb3a4a01596f1785b341cd0d65b6eac57331fc671c956df8edcbac4a7594b9dee0207f832239d036e4867e9cea6dde0127c0529857e3f964cb33e978b8ee05b474d0017b8bd6695f1b57816cdc9fdb4b82107b49d7f461bd38a72f7a9ebe2b1ea2fd43d786165ee9eb0eaa0b93c27948d0a608f7763a7d9db87d4713d6a3f1485260051b2f333915c0a9859239586371759e931d9ef4ffdf47070ceec17a6631530f922d034354dcc140d8a8b9a55f8b65cdaf8831822de9066dc901b7769e5cf37e31393eb05e25015a4ab81ce838195b5cd2b4fdd61b10e827e82a9d44d64c2ff1451c56e6201126cfdc6a0560919edd564838a7def04128ca19fa32d4d35681997c59e9175b99a7d618fa022b587d433592a782b1314412b7e00b24bccb78dcb3a02550f2f91252e6fe2599548202c451ce5b484f628fb06d6ead185cc20bc6ebcaa6705429494869e8eabda826991726ed817d3955982140945ec9c15f69dabaa6e990cac82bd0d850f04f89fc345be65eedf522ce7de9cac509c981be4edf72be178f13c3be2972cbceb1b7938646ac141823d2e6f92ec0d674b71503daed124cd2550d03d1a1a7341878aa7ec0fe055ea59f0e531ac6ed2f4e05e18f1023398af11d104d37332c76c63bb74a0b678a38c1da801b330e32a894b6cf83d4166b516cdd5e490b6a92a93da224de985077cd6d76dbfd0238d8cc60ea6361c79bb41869d3bfa8dc7f15a8d234aede6b50e942e0b726e24fc229ff3f43e12f305efc8d52b2896fac54cd65b7bae8868c9febe7fc69c55ec8c2036554de826e45b024292ef45099e24e042e657cd578705e63f36a9dbc44784bb4e1d89119785ff7f3949f90d054d40cc5d2c857a54bf924277af6256050062afb3af611c26dd1e888ec046fccf77e0c29ae3501181dc264651a563d30137106284735d78022edc9ff3cfc7f16c078fc2609f86608999a6c9c10e532d02700dbf6150be57da63cfe0ec9010032d7a4ae65115edd319d77ec9c4a964391794fc61c5b4cb127eaada295c173a7157a36932b5d2ef603baaf98d5761bfb948cf1c69f62392868a1b880c1b823536361aac54118378a56d659827adccc46572561fc5b5143476c2ca3d215ad2bbb275b124c48c77e88f9eb87bb08e209dd1eb0d07a513eea38e65d58c39b2a908d533085ae8e623d5083b3c4f2d6a1b56904550dd5993a87ea3e273a3c6cd71d80b4a35e122151f2c1e06e20883b667abda8849443d9d7dc5cda71b745eb0977244fa32d4f6fe2188058f029f43e3e31752ea32acde44a8c1b8ca13b891f46ebb8fae90f4cdb2461f070a8f3b4c0f9e6aa34dff6142e17e763f54f8445a72515fcb9b5eeefebbe170d9764331f5360ac98ad8bb880831e0e0690cc28e1c7012947ee547bc68ed3a55a7f669cb37a06d41a58d7892c97293e744e97c33d4745e1be941c5954faaba19f44306a244b66973588a37c738b3256b5c7ae2ae1ff0e93dd3b471d2ba91f3fd74166dc34f8d4b3253ecedc3425d2ba33af1ecd63c689e2c9f022853f374c61994a5719a07ea73a33332b34c8a118d82abbe175cc7c3e5a2188e853463b5656790ff7f54e38f34166943ae649e74c1bbb48c9c4d0c43ee7ca421a4db77030e0d7f771cc28d29e131fb37f33c24f86394c45c442b5dbed2067b47c2b0b658b0623bc8de214858911c97ce0358c0dbc88dc31b0f2f3706717f0bbb447f8c9b3e5ba0c295b520285ee09a3286aabbf3cc2a8d6ac2ea1f1b6b85db04f18af242c96e74fc7fe505d8af340436eac0a158706574f17349f9bb02a705662074096aea19a43dc25ee3586942c2662ee2afaf5451bdb3a9fbb645d4f4f0f56747f075ab553d8334979b2b8b2090e52f6c2adffe177b049198bde415527769b875f9f24827e524f7f689997c92c8f9151fcc6c60b8164b73f71b2f3068e81593c7a6d9729803e1936dd7a7ac25d2509ca22c75c0c9aeba8a98214f46954a22212f6646ad56abc276300eece93e279d2748c4024948c0530c3ff77c3876559517c794077258ab85bce4101c40673ea2fb2d06e3eb9c19d282b4a95d7729d3fc213826f3c4a190eb7f1288ef13ae13aa7fecb921072600b6f1c679baad0833a0e540fcbf84aa77e124ed0e35746e13632601c398196b41a5b25b0a27b79a7ecab11339b6c92041a298873514a62bfebcd0a4d32a798f35c98b64a58687e57a1a623a7c54202fde5eb23be7fabb35bc0e489ebd41f9009077387a7d590e1741134da15122f48c6a5347aa6e78256ad61a0bfd2a22ae0e52b1ef4c63d75696438064edff1826c7427a1e255f7334ff729e5ad6665559eff214a394cc36e541cce6ed098bba3de7f1e3fbe0275e64c4d5e6fff0f361e7b1f7ca010b2658e9812899724ecbfcc134062638499d8e75b6aa3fd2976537f54ae3894a933cfd4d8df15baad0683e9bdd9562bd498b68a553122475478ff791cb585e88332fafc62aaef513c504ef0b6f2120dd423c1cbd07f0b2b51760839487bd0b6de18fb22dc1e5c2ede8822eaf716ec2b9fa9c318c2c49db736f14facd1d4456e3cc17a3f1d1be7f4a352c8a441169769a7c40aeee07528adbd4802af17508d4e19042213557417719ca4e5d7a49d277fb2b9c83e7e2d21e92183f1c07e60ff79764f4ec2fecfd6bb44383521d2a2ba7917a5c800f832b5f261c8032fb16a85c64181c7f3ba775e77c798b797994f55f99908069e22a2f2b9e8ddc09aedb39b0707f9de310f6de9ef1bb612a92e51c69aa72735d9372f85bc139e4ca11cd73227bed8c416d441794a249c6650d151162d3db7da00649966e14cb8120ebb98d29227bc5dc479a836e223b4357568897c931713a65518fef5628655849894ce7588a4301537404c10dd7ecbdf1ae0451e875c5838fa6ac7ff30a54532755405a37ca41bfe13ade5232a5f7c494edc6167bcf88a71035237e619d49a0a8112710f218ee5dd1316ed07a1808504b0cbcdfd6919c506cbdeb8b37cc817adaedf2fdff0a50df650eaf2d807c9bf7ddc392a5c5913a96ab8111352669d553356bee3a263d5e6366f076c1a3ee3fbe04c467d01b694dd6a18a3d516beed7ef14067c3a9a192952e5b083bb0ede1a76626072bc50c3c9b1e96cfdd60165075fb96ab83b450ff3eeda0e488cefd75dff0c5eb41a9a218076a879939e2915e9857a7640acf198eb6810e10bd2bdec7ae3bef4e84dea09c97dfb779f6f17a16df4acdc8c2d69c857c53fc8e4b9a2c0f8ab0c0e11b26d98074c4c325e58791194ecfbdfac17554a481e268128d34dc66766e47f8fddfafd67356e4e66be9ee1941c6a226b20e2de239c3b61735ed41ee3fac2331f4d046b9cc04ec6c35a64dd32009c27efb355c6beb33371777d103230a9d0cd846d3ebd14cae1496bdea6c45b0b6d0dc810049c66f3bb2f8b68837b3724d030bee4944c1c43fb9e721ab997abe61f1ee00f903a9105583d7bbc6a5f03b0feb2c5c0711f07996639835b16980805cb69b7735fa70685f945c2063a80a708b9b638768daad3961e0a01fba3d196cd73ea26333562a41c081a6f5f45fada6eb981e3eafe824e8862be92caba5ac93f8440a4a96302a70f09ad634a31ee5fa93092eb6b2443443cd7c20fe56f3d2bd8c5b906c986e857316b8c011bd4fa1738c06a1155a36d903a8d50400148a63cb207790de30dcaa48c8a9a3067fa074e3893269b89c7dde5c416819b562f151014bbbfc98080e9442661e250a4125fdfceed09040df16fddaa8dce1807ba4180ddbc93e913436db8cb48c766e23f8fa81b8654eaa329ebccaa56d9f4d703ba6500f11dd8fafdd86e3e762c4c7af914b4c7e9e1d9f98d99ab9aa3b2b46818cff753f0cc0492096e95c88b28b2c15afc91b5d0cc277ba921c26bdb8ab47d5923752573a2da19a4acaf16c49f4ecab8d34795c1ea864af0f06f4ee98d006231e227b5da1d91012aae32121d0b1c30d367ee4319d7df2f04ecb31a5c85ae43f4a37f39a12c1ac94946904aa404d4522b571d6c7f505c48638273b16a5959be24b5618d013d039e39e0158f10620daaeb1b3ace097a36295e30f8b5c86ca924e9903deb69fbdfcb51ee3710747c0f9b30f5c37754c20c7307d896357f425638f8d779e75bbfe0e0f5fb4c60bab88c0aebf152c34b3876c80c19424aea3ea66465a74b540c1943639487dd621b149f768e26d5fa2454fe01cb5bd94ff1ea0fde8c9f564c8259a1d2f8f8b7060aab5f22dc5f923c6ad4cddbb384586cae8cd59738d2f09d66484c4c00fa1240f7e65d0c13cdf1e6398392e47691a5227e90f97be357717dccc549a04255126e55b0be058453ed5fc9ccb244a652448bdc55429a1906992046c8e64bd674b2a28d920f190c97956b4146e80486594d24c0bd55f85c48590cab63ec554e381aff16a1de142715ff60162fa3b89d8e363250e38814a07651b1749c03faa787b9c17f05eab6c8175d878fd5e727eef248c860040bbc317b04c2975d27be1c3b529ee91993e58770428cb2111dd70fe9742f29736b9f35005e86d793cf9c4f19757b627f51b63ca96d0b44da6e42f99cb619bb9f77d7c7a28f86b1ae84ea4cca437b33e4063be7e0e8852b830650f4173fe997696780045acc55c74261e2f3b0f59f458593727d9f6fd80e25b2c07830bd924bfe52085adce279165e914ac8e69e658113e4b5f0d9de9391594885edda691a9abc622aa817a3bf774f8206ec8419fd16d36345d2a17fdb358686605f5b9c54513157e0537bf5baf8ba4c83f2bd734f1572786e04730656409e57126025c992d273830f92942dc6d05cacf156a1ef175012fa8d322458ab3a7a8d0c5867125f791aa7532290c78d2e4ee2567283d61601ae389b47ef2b6e072ddc336c52e856a067ba7dcb84043a3349bddfafcdcdb240cc78929e0b39643bec012157757df3e773efb2323febd15f3ec7e890ce3c654b1e75c4896e3ef3f57eb95811de1ab01d35b841acadeef8419652ad5cc6df665d8912ace8f6e6c69cf8b2db97c8d7795ebe39cdd0f2bfca14cff3fb57d3b0f1c19e75d85f8e9610d4bc1278a164209d892a79bc0fe73bda997324ae41d73d24820b6b4227380affb461c1282b564d0bd3e65f25beadb26bd19f54127aefde6d2c91741e4727540ec48b69357562a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
