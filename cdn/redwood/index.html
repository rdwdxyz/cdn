<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75efcc1ab32fc16483dba45d3970896e60b749b3415ddc3967bf33ed3cc83a1e704d2f9edfdde99a57baee7c097036a9c4bc4d403c75558625359255d4378aaedc3835804882b85ce864efe96f92e423ab7ef39185c06831f7687a6be4d21bfa2933d9d0681e9f3fa96d893ace12d5ca23172e09583275df69716895be143b357ce0576915f685dcd544e85d925f52d1f3a185ac7d83870623dbd52a073f64b25c99b4741cd491ff935e4f67fc9793996a5be5c290713cb0d9749262767a9452e73fc5ebddb517760d68776f9e3ebd05dea212072c4a7f39d90f20ff02fc2445d59088fe167e637417fdf27ca5e55a7b58e76b57bb4d2e69b460f572db0588500c379545f630bb7078d66a949e488d732564d1bda628ffa815f41a2abf2bd7b979535b846f5d06537dcc18fd334b0ba787bac9b2b2387afccf10d10c23171ccab45e543dd668e0f12f609cc57c1490f7e4b34c4998be9434a029ab9ec3ce231d50b9ea3144eceeb0ffa46bc343f3b2974a27af2d5c65e97f1b1ffdd4bc3d337045049c3aa88343208659c1de96dec8f6f9dc7097b3fa037a117d9a10c6e2b85b7c5311f115f1fc8181dee12c2eb635422bddf00a9f15e6e6f14a03dd8214862976e9924e854880250ee0db1c5e27f3be4100daad898e4c66b683a8bfbc6a184e53102552f161f397afdf2777ff949aef425f2719a4c9a8b05d73910206667e1152d01e6ba2639e366fa6deb40b9fbe8352b7f337a2f15f95515535e81c694e16f93e9ac9056621e517ead18dc36a9e0c2ff2e9833884d05b9cfc41409a6baa0106e9e001dcfe774b643a1675dae3b7d83fa0868b4a3dea2a1062b52fe56aeb13ca59a3d331ed275d3a386cfcd343c949d4a84338b359161df9fcdf4f7027413582f13417753ccddfd34c277eadc1a53417d9191790df894c364def2e7688a2bd7372659f6e34fe0a75ea85f4000b7486304b95f7483d5d7eae32ce8d60600638dc9d9de844f122aeeb6480af4c2e132ee7949619d72bfd1991fac3839d02b7502c211e89773fce5d9023f8aaaf9b082f70e3383741ff3940633f742984c06241eefcd37c7d536c879dbaa43bf56d569c48884b10129e8fd42abf54cac56e42e46735f5e71599924182d96e9746b391e5ff14efe3fd9600591d9c0a6c6783cff23f98b1e730888482331edbc5200fea66c84519eb15ce45db91f1687fbe3beb5afa0569f5308ffe1888b331002f63c6d6c7e124879357d06688eab347db46b4852797bf5fec1fa2000513aa13404a6b5d47e2910e3065e5325fb668623a60572250e3e96175016ae90fbfcf3a359e698baf2c6173457b9b721058368f95da83e6fbbead979094c99e8328c94cfb5c57ff8dd898ce7a11a9b55b01a0565708356215ca3d61e4288f16020ccacad3dbea36dd422f4c2e9abb7b0ea9a63b4231b7c05e13dd87759fb05025cd4d434965f91a046088a2ee06c7dcfe37249a41382d1a27e9758bb5fb869ee5c3990b360382528c1abce47f214d86e6254c68b53d9668ee7ecfd0ad7db9e630a2e5c6db45c2fb665899cc1d984164439136adf524b8117491f9691a0ba65d7e71a0b1a01a19b044c8490406e36922720ac6ea66a63e76cb42715f28c6f709c1573d77935bb6e90d96e2a039525f38e8cfbb12784e3a4ce48952552dafbdeacd8718a5eb953e33d70607bb9d0573e27c39a6daa600e538ca3f68ea9145ca8ffab1e410d800e702d058b2a87a4e44b5ab887b07726cdc5d49327ff84b95fc2b73e0bb4c9cd0e5e1179776439289b133840bbbad0035e50aa54dbd5cf69d7b08dbaa389b7570401fec992b6f956bfe00b6fe146228215f34422d7bf8124a0df5a41dd98676a746a4633d24ab7bb156c08dd1071b529b3f91cfe910d054a955ef4d478e83c9007553fdc6d7e8f8aa94d006ac3ac4e0ae52b81e1eb18738eebfdd7df913a8eb1a5876b26d0c079ac5d05cd670f6d4b0e6c7785d4f1a33051468969f3aecd2f43a95d214aa960121520e2abf34ab5e02a5551438aa25d94343dc13721bf4129a8e88612b14115600b8f97af01ce6a14bde2ec4d47f55a46b06b05e53b0d2d3ec9513e7859868af9e2181256539cf6d811e53d74e1ca3bb3dec81fca342a5cdc9467c0a76f144cec233a9bc174f82b5779f91ecff833207e2ac2d63bd3f37fa599d60fbaa451e69271aab10a54bb75294aafe20fbc17d548090b748710f68c2cbb0227560ac445bd88e1fd6f2a1dbabd8daad08941f8ae04af0ca4ccbef934b38177f614ccda3d7b61c46364cea8ee9433f5f1865565fb3ad9bd420a604638a7d32586f32b18d0e8ada2d93ef724660434b71b2af5913ac05f392f1e31a87cd2181549a340acfb7d2f6db980f58f882266558b6a91d42d83c6c5bfa7f2c5e0c81bb921d3dda6994a25646f87d93ca522182c3d61d32384d534e24785c3ddd66b0770583d682e97b98aafa91803b66193f8508645f17be5e6917d0e50bfe4ddfc9454a8cc18aa8c6139a9615fb5de20ed66f437aa82a277a86043e0f25c0861fc50e0e21e6ff53e71fc14ad00df9fb35fc1c32052e6c92aa1168d25d0b77c729b5a0ec88ddb7a354306df483e8f5d351fbf1583b77308338365c70e8cc15b9c2ca4697982ef8e759e75e5ec853c5c7bdacefedaa789adcaa374ef8fcba3fbb985a6b388ae9bbddaf4735d60a42a2baa13d8cdac2a0b651528af375d8ed252077e5ccb9d772c3d472b2fb67f6878a7ac58845feb076ce46ff5d51d452d1a2ab209b07e4ed37ca01729b6cfd258b17ff7f6486011e406276c0370cc3be6ce41dc98abed07cac670b144786c740940a3f364a6bd99ee0a1f4a4ffdea5478d5720fd30198f092934e6bd7c7b728a855e6c3731ea866f87fd35464af757bd91f55c5c288a2ad6255661cf1288ffba9b94048e64c66eb8969e9e3919cbd0f0f5e0b64a766f5b8135d598810c3c245f81bd6849563f7bd616b4c6d416b47e80d6ce7cad9a22b5df6691bbe3277f80b1ff4a35daddc3894982f48c1f15fd94de9aee67df4b9ad73898239ca122e5802bf68a8cc783ca7196d2c978660f4b4fd45d7926ccf86d1cd8a3f787127b89e2c458745c9d3eb743d82b49fadfbf0d8bf34dd6ab19ab3794cf06a19d12808cc001fa006dc2fc88b4845516ad948aafc4381cb9f82e258b4e48c35b5d95dd879224a89f84cf772ae5cafd12911cb2451a0bb99e792066bd65698f6099be8d0c3314208530f0ecca821361eafaa510e884dd09f3c652a77911fc9e2af8367809bef3b9105bc839718454ff4a4d0feb8dd46a2785e68798c403193988f699a6360e307561e1975f7e6154f356dc672ea09679047d6c94ae79f67946cef96e216662d83191e9401205988ce8bdacdb78a36f04d0276ea245db237984290e2b84ba909de637f1d456a4c05919786e414330b7dd83976d1cf9061aff1f6f25e2d60853852f03b24ddd5100a03964698ffcdfa1b879294f3b9f54f86c0bb0d9319e81261591709c3743e9dd5697472e473ef843f55601e05b9eefab061c11415d0d30454db305ea0f9426e34d1bcf67481230a33e51b280df20d1208226db6e1c5135304d307ca4f7ce52cf0e245b2602dffbf36114965cb35228b4a8be1beb23ec6eaebdb700d2e1af1c9c1e916519f453f54267909ef509a1980c41e6f482344b95d1550bfd345f9cd4404185f3c63539f6a715bb4da2970cc418d06303f518565c7d34666461eda13aa61856f7a16bef12061dd44647ffc7acc25e8a519509625509d308fc2c89c63bc4b0953b89c61e28d49f8d5ed05840907d1e5920dbb6d3f9fa77653604db982a35d1ed305cd66d36cfb92bcf460329c7fe26527606b9b0d25bf35d615e53e8465f95d7a7cb694407c016cc17d76bcb3286c488c217b109536a5b7d38d55e7c1ee993b1dbba02e64b37d6884d5d8c9498a3adf0865fb575e3c59505ba06c7d504888c35724a419780585f3f4151202afa4c3ed9cbd21c64a4f2f07eb10b4ab1acefbf024253fca16a79c6bc09ee9f1492444735809a38c36254302f5d87ee78bdd8abf70a12cf9bece59e52b831846798c270102398c85dc6deaaf76048e5cbc91273a25b4da8efd4bb6bc66e4c82156fc22638fb4e1abaf4242c350936366eb6d1d70bfe9551679045b8e047c5cda4adbe20e22f0379d7b9d773dd8ff9455906b7c36050f9b7e65ef2076a5e8d716f4270b64d60127a1602e9d4007869dfdb026c68e86bc76282e27cbd9b9ff51f1ce98881302cd0cf58a45b457e109ea4112cd510d1951835dd192d2ec5203c70cc0705da9ea05d1c1fce8f19c439433c7ace42ae5305a2b07a8939e885773d0767622786a3f5af14977ecd8f4662d001b7248bdd1806786957d19892e5c98917c8faccfd066b6a19a21654304e0d997493caf050c8197f6d8323efd75f6fdb4ee69321581c16b2a1427eb071deb5ff9003cef73487a2c6bab57719d07b910ffc4d851cb6750f80090686426b5261efe791d14e8b424172221a10853f353b539a69eca58313d5cb5a08600965e3d96924e9ee84b203433e09e15403376e92675cbd7ab6c734cd0809d05f783ea7629371892451f4470659aff433748105f0ecc2c4c78c4fadea68a49dd2655b608f5d109fb8c6921ee873df363d2d872b171dc3cf111cd1d5070edcc65f26105a69bea53ed6ef3ceda037b96260a12a22f4c502c409efe1e6fdc97d6df8c88823b43e1162411945ad47c1cf4025462843129d012d908f89da85cd069daaa6cb4e0c70745268925d2b0e39dceb4f49d2e76cb0f6bfdf45a700e9910790ae0eed8bd1cfde1e29762188b456b0552f410da40b9bb29ec6be505eefd79100d1e177d14083f75c8d60a6cc3b122ef193a4c3144f8ac913decfd88bd49acc34a83203bebca3b309aec2f3808f23402e39e5c094436d422581320ef46b90632e40b6c90803dbb697fa7ad457df78c5a8248bd0440b1f3ab08557c1f02e1be43ffbaf9a653e9b13bf57a9225f907ad8a57461debcfe67f3f5176c5a66fb8cc1a26f305dd0361d125ab841503ecd3d9e60b4851a5acbab8e91d4af2e898cbbc8f0e8749bd8528cdefa197c8b628cc6c833ffa60a34a71ccecb11892200b0a7d22ee188a52c76033782d0fd783377b9b9f827a433e79e0f7c4d381a54955866a2be6fa852bf80bc77d0076df164bd334496ba9663eacbef21114f2f35d6e381553659a0060799e6a051d227c54ec18deab44e04deea4ed45b5d703ef651a441823093dd4d1bce676fe0382a4ec7c6f2c30c4159c6eb8201cbc013708a6ab9d75636d575fb62f5e93dcf4cb4bdd7054718f3b992a261151d30cf440b4d2f9c3e2cedbd9588bf65307d719f5827d99aa2b39f8a7d5e5d3faa526c620c687e9832b17e971bd3a876a9f9325332ca2ad5b4af811a1f4150588f2ae0460d8bf1d383806c346798ebc0c51365e71356744b16f1bbcd2ba5ec91e4df4a68844a47642af14ed552a40ea0198223968bade2b2a8bd77906cb9464b962ed0d608bbb2edd320765b6478dcf47dc5a4f2cf38048d8ed817b6205502e8e3f96470f4b59394049f16f8174f77eb1be8f83136e9507d1728c66de52f88712f3c1a45c566f63f554c66feb842396a113faf3ae1c2d63ee7869be62adf22b7862615976e871c76ec533033d4d0c756aaaf883114d7b88d72a4ae7175635728c841a71b9f0a5abd15094ebf39515e13c6468f674fa3a27d7da897ff24d9970c80ff6d14d1854a398757cbca043a92ebe35c719a55bc5361f51a1ba4c09d4d9dfebe26db032785c9f7f14d2787ad21e21fcff65c884b341e30b494caa0222b45d59724b543b3347f2a6ebd00fdd4c24d58e850bcbce06b3f33a7b6960ef190a60e4018d4afb76ce1419013bf06cc643370e85a8274fc74676e9f994b8f737a42a48fc7c0ba826dc445941d87c297cedd443be81a884bf93efe3bcf24bd0d789f2f65388288ee7edd348e422d73a31af351786771cccc11a8e275665ee527e848e468e48757f1e8bb4aca6d416d9ceee5b9a21f5419290abf20c7a2b041b7f1229aed225620884f6076c8abb4734bd2f795bb0505c693f5e2dba89e18cb65f355488426d1d133136a713e2d9108dab2b663b28ec996d3fe02473011af14d797513d12c632020b6e3c4d87ac13cae4970c31951c4e02c443de466c3a37f4b56d68c9ec50780b97eb4649817b6bcd03fa6816dce5887628e561f5390687891c442d2568b3d51f75d1c04f972f57e4473bf991118ed7f4a070f875055968ae7f3a20b75647972937dd581da902d8ba6252b2c315bf731538fd8d48cfea6e06ac78f8f9d873abdf072d5be7c6798963aa64c4906591d4217ac978f7d4e9a6f238bff336e9798fd5f19bea3d5f05c3ad5a44106be7af4b10581f640a7204b2b4cebda39b032f15fe9132e6c3587998cdd87fb596a27cc5ecff4895c2839280e1e67cb92fe9369471583218c62ee7a1eb42b0cba2e82c5137ea60887d665643cd7deca3b48fc1ec5a1cb60514a8d27eabf743028d53600cf682896b87889695f3a75cf93cdfcd06196471de6126636e29a70eeca3a26e9c8062df50783bde8b20c72695bb11785393af206b6bf01dd577d0e253216bcb7f0dde67261cc719728ff1c1ad77d6a593400a5f8ed8ca2fe78bb877f390a484104766b4d270cc15faf97d2694b7ed74e17a0386c3774861b6d818bc94c3a1332ee1ed7b1582a51483093655bd557d077a5fe2fe3e3751a4be93e984c75886097abde01e69ad19c6738820cab9e518d0094ba15869f77cbfcf77f78bb0b9fab73bb7e2375b112a38bd8875f861c6ec60560c4bc144f55faa6bea51478c7574a3d30a3271b8640c7ae58f2a2e0a46c7688e1335d582cc600224f07e6f08997ccf5af1f2592cfe2fed1cb808bfa6dae3bcf96df8f2650283a179f8d43b3c77dd2f3c59734905fe99725274ff71fba2b6a6b5cf0f6bdce53b963b6c5afbe42d763ad7f0e9b692bb333447c2c6c0cf1449ed6a7d1ec3b7004f56bfdaae96a33fdee63884146660ec2b1863c000b99f01379d7845875b42daac92cc0f3d5f05746afd727fe2e476fe23129e32fbfa980269cac09c0017e0ad8d16231e207e8c1ecdb6916bcb99262b283e137b07ca82b7ed1c86330b3447aed8552f5dc6463510854430abfc1edfb54d0dc715ae6f891d62324cee52b6b4bfcd2127ff3d58aec1867a75aad9b77831cf93ca2cf5c7ce8c25c037b700a41c99aee44e615e2a29a2d6ea20b6d44ef14c00fe2e22c0fa0fab4b71e749d9d2ad1354aae169c9426656c7c0de761dff2419a7292d8d90091234a765337a204414c9ce3aa6754e6d1efe848d84c737f13f6b810fb013147ee750413f08f10f0e04c67963a8a28a3dc69bbb072cf1091aae70145dcd916f4024f61c97613237c25ea87e9726825efacdeb5839ea6f08356bf888536ca57a00c05a59bf8b742578cbd4213b3ec81acb8a8f62113686e7776a1543bbdcc6d3d822a67de931a717a28b88e33eff06ab2de832dd0c818883f4a6828aece4e2252d2b364955bcd89277a6c14604cb992ddd091c9464b056abaf6f953e3981166c0b32c56fa4ecf3a0eb2f9c2fa9e559601e75bff88cb2c863f58ccd9f43dc3275d7639115074d52474ce9455b4bb83e94ee09108549471a96dac662ac3cf1c289ad0ca50d32abe5f99272a56ed99d0a7c0bbcdd226b69bfb7e5623393e5ddcd49d540a970f6ab13058dca0533b88b930b486fdb4652ba99dad88388a8f27018e4358afdb6f61e588c6e619f7dbb69766e0b92798212fd5bc1cadbfd1ab7174ef1d83665f801c245d448ece638d91be635ac521140d4f05c71cf90dbe17a71bed1d83eb42b462977e9c377065a6be538b78c91d86cf9ec7b76ed7d4dbc0fd49a33b1ec321497b48a9071e2baf8620954bd0640571484d488df53cf6a5f41c7915080fc2b1e83c5a7ae948e5120ca48fabfd1975c002663ae643518cd1eafbdfb478adb28eb00287409ec23578d4a2b2d9fe506e1c4246f9112622fed01942b9e900b3f41ce481b806b05e470465ecd63b84bc449930eee0733176cdf34a0b7819e897deb6ba92b94a526faf4310214bc3a38856679155e5431656c2b23ad534f82f3f9f7f1b8b5de0184dc12c782f6ff53d7fa0415763ee5e0a32a321eb48095ec774d0a3f8dc057ac8e43d1047fe7ec8a9e23f0f9bf1f4bb50d11030f15612dea58e51af081fa8f1512d43ddcfa51b427d25ac760f3966965ec591f85094a197c9454cd829a7b24895fd2b155dc77b8cdf2e19cead315a5cdda78d1f7f54a51c63525ae967e43bf87adcfc274821bac9b41c7c5ddb91c3907a14a249f6a3f3bf130819e1c9e9fa7673279490b15db812f3f377ed130b6ef89b79a16b4a9df7158a43f508b9bc8e42ed2a5e4ed3157caad373b50750fcda50778765976336e5483a01dc7d246d607d3d2c5d7dafaf77257c2e3dd4120660f4a39e437ff0ff3a629d576097f2c705ad5a5c5300cd24ecb68cb6060381ac6de426a66a681a0c5dea87aaf1e044127de40c0ee9dbc3518b764950e73fe6f72e4ce99f1aa670fe4f317fbe84f4a7699a5b016d555263a7c3665e8e47eaeaf02ad4bdaac729af42bfe4ac1fd6b0da9a577b38067981cb8d1d87c1336e961250936f47689f96fe47e8d2091264fcfffafd826042907110e699ef5ace87b2f4c13bbd1fdcd8a8f08f65c852241a46dd602231b90dcb807814d37b4ce225c551f63a1f7af737ff3bbf4005b11f32284e3673759906bf4ea1bd9c97243f36deb23b53713a48be05f5f0b9e4454b608d0204b1c45d39557a9c5a391423b43276a773f75e7535eeb7e70731ca4cb3f10054a641e56c90cd833136f0e89ec89d5b92bc2d454aa6b286e356ceed5d4300d277337c4e6e5619e54699d13098e0cb0266ffc22bae3b3af0fc4761f929b0e0a4cbcfcb4915d0a1e222f3f80aed0a25ded07915e12e6945c318232b0779191caaff80bdd9f9979c1d9b4028c765d9130837a9a729818c00a711fb9d37ec9e9a9a614a5550d4cea866e12266b9a1f81599d4638d1b6955159c3845607b9a056977ba6a41a87b5a122cc36187969905089ec55803fd002c5dab429529914604aa97c395c0d39b3a041946826ee423b03bf7746aeeb53e556710390da010fe426e707830c4f5325d60850836da2e51769a504bc831f05ea75b6affadf37c9663c08f4f8e8471dcd2644022f0198f4b1529e268dcab2f2a1e40061672778e8103139b39e4fb88073f440bca9ebb2bed93916e9eef04217567ec6a99a8da6a122d1614e6cee7f2c1855722dcd500714ba3bbc7574089fb2872c56fcf23c9ad7e0e28d5ffaee8c0925819973dbeea178b99e28ada64dd0ebaf288127360281231721032f44d5163fa29642b88b5940232c848100712fb46e7f18f21a0683aaa097dde82ca43940a3a6aa39c4a633464596342b840d92a4f3a82cb6d93a502f709d113defbc7d231c1a55d4b89c904f12963c1e3c9f63814ca1cf7b61ad860938de22bdd47118c91a2ded6a24384b1f53719f8e46f464f82e4da8c8f0147b6b11e9fe13c30a0557cf189b6a6304844f654ca2cb120d30e7c4c33794149b9df7d70998022b08e19b40d0889b6d1218f6b72c6090710e41a55bb34e8d1d4c29515d82f68310c9a506144860462b9d93bce63de04b11476dfa84b97675b766a4e787d39d03001b9fbb615f52e9332f4ec363fd6714cb5d483ed3d710e3739bb9270adeca8f3ce37dee437758e193466dee1eb895dfddb1e5b84f736c94e8d5e74005ed89cb648e8a053ef6b9d5bcc6b1411fbb31318650de789e857cb6376e61358c72f3e0c5dfb52560bd2c2069e832734ae312a1382aa7e2a9d51bf144e66f9d5536dafa6b57f24fb8e2b1589b07e5ead9f7303609f7b9f3ca1463af941202fa187299b231d0def6e20b377275f790960f526d8c16e689b7e0c6f9666fd810233182cf23ac94192cd9db040db073f5ef50bcf606e6e06e57b89e80fd840c5b90af492f2495cd67c7cac67070a8443544b6876f30beddd4aa4f4f8faba347e2d4cd964903af326cf6e8ff159b44cc877824c516818d92c6251cafdf00f5f86a4fc05069423891acf8291f3185b0177662eac1c8e3804413fe650cc6023b1f7eb314600df65567d0f60c8e7b7690b6b82a91e5f994323b9fc92035de6aa65aba74111fa6ca01a4081b2901875fd124d2d87a9269211bc810df3789442d57e38ae7c7020e984bdd99d0f5ec37fc89380bb7c542087ce5e898ede2020d830ff7447419fdc921508f1436f326e3809e6321b882f00d01f53f7e42c67750e7eec568bb389f21501a2672b88129c7f0ddb1a21b92d01078d10753e0b9ec795634c0eaffef5e315a3ddcd239ece25ea18ec63c6a4913f114f1d95c2360454c27cafbde4f7c79a7c3ffc7f3dd284b9a4e87b851d48c85801ae6414cdba3e9d8817abb9124fc4f4b668327a72094ba9db2b985160e70457463a7e3b362b5452d3f23fdf8261424688748be935b423200de33a9bc74b3e6811234b13cd774fb0451f1d18a538bc72018e233c2d2ef6bcbd9aa1c6868f8e6e0df5282bdce178b4bdfa182e391523207ffb791eb8d8b3d4087aa9d9ee91e69fe00c8296eed244b16bb89d3f7e042075dcd0f7f967244105b3a208adcaf1d116b280414d8cf496cf353c02ec64197b29970ee591830473b8ad4c6a7276cde03b122ff243ccac1cdf8863d5831cc02f5ef95e71762fc44c2a4cfcbbcc61792449710b2026876eb37aeb3f3e1843c00d9e0864b18997c5cf8596e172b981b99733be36d73b05c3373d6920b63535beae07f91dc4168fdc2ca9c5155fe2eab45b01feede5e6fb9e49bb6d50dc20503f934fd0f2694272d092a1b9db97f40af28dab53b1d64dc156984d7d4a16d1b9cff4e9b08dd455b819276848bc737ed86ded6379791985b59edd6594fcf551315fd3db52166ad5b5bf30929aefb5afbe68b13e3cebf95f0c282209795c18bc1ae0db82e2b8f86fdbfe0fa54dcebe2caefc5130940ab2ee2578a2f82c88c086e454a863b0b7eb18664b624a4f5576baaae33d1d36f3e79198676e30ebb29088b5e23e4788023a552d8c9be5edd479f44380ecd8c046923ca878fa4cd12ecf4984de18ef70842c6ec007458627058643ee5a09e4efad825faa2cb9755ce9f01ff6a9d3b2c29f679ae8d989b54a251d58b20b6d7964c9419ba462f73ee75b3f3ae56d09c24dc5e4c6aafda0f23f18381809ea84f96fa984793dadb250618e945009808090d32a75bbb848bb53d3565f4d13e2c9d81dcadd0f0eb676f030a4caaffa99f383028c115c8a2948c2e5099fa9e68b980dc28d0a7f965a0d51d5898a837f1a1abfe62c90d83193667df4f87da33b22e4e43357dd3cd942028eca9ec86d9398864f5faa805ecca7fa0135570e4e70ba635076fca70cea600290ea70ca2bc5703b2b825d08f12aff61c14f83815583006eb4396894afb707ce687925fe21e33ad84026e3a2610cef57000f6270d584a4c199db8d80c611d349039b061a58538573750d278a9050b8c5d389ff289cb2c7a51bb43e600f5b8acb643a3f2c52d759fd87a91a15ab780bcfbafab20eeeb4536eb60a7602c5a7eca26a966cd00dcf70e1cc760dba860a140b1a5dc3f66919ec4a5a523b614f2f818fa4a109a617f07a9ba3a73633b58ffc81208c713001a42809bc0e0978bcdb99dad9aabf2c31dc90ffc4ef8c226e79f18f26fc0682b4b53e10fe75afea704b2b605dfd0f3b2aa39315409fa1dbd8c4f7df184c3adf0715eeea1efa92da4fa91e560c30b37002e323e66d00ed56e34e3866cf1f3e5b685f542312154a3f54cb51dbba8aa59e064cbcee8b1e35620e2c8bfb8da2965652ed135354b67212341808879a26068de46a58c2b0ea19bec5c2772e6804e410ddb157ff3876f16740e42e9bbdf5a25ff06492ce4aca235fe0b000c3a17cff2165434f3bca46d92d73b2468df2cb7796fb8a02a1b8eb19661409cda77c017aa85c96817ba5f6ca5ca67434d55a30c564d26b7c1078cf16f5123e5665d119a9675656d66b3374878accac4a739f8215beebe2c06e15fff3186b193d9d3868c84798a58094179621baa93a21da02a2d0b29f8cce963738a2f0f83b79c9f4be5df489b727cb6461a03ce0a89ac24816ffc3176df4b4de3b7c25f8b6fd8693a73a60b65c56083f5e9dbb151c25f8b91ece97e13498eae317993277b4c000bd1385186befda5cd49d849fab0ef5c9d687b3c1a591611ecb4e2bf2fa6a689b3bd8616aebbd907e4be8474a7ecd9f18b52b951f47677bf3fcb980103745dc6bd0c8b801fb3cdee97282077accf4a096f6e6675dc47249089e4acc2107e7e118e0acd20ceb640293357dc4ee14a6b1231238922d781c59ad242b261ba5e57f4b0bbc3846a4168196054cc9e7f0487714d87b87dd6d73c0cc6554a6db2432c3a4086aae91eb1cb72e82a6dd5455f8c0d0f7df425d4b3ddd164c444e6c52ef31e5e4564af7845cb446b28c73fc258119b769e38d4423a4f64945b03f8b340c325e773f15710b6ea87f7770f88b42483b8826cba5f3ce203847bd7d61bab4386783e8e2500fabf46902d3e6bb141493b20f2c6a675121aec971f3801498970facb038e2151065ef5ea8bc053eeb8fc2cc0fb6995ff023521222cd0b3bf4cd8ec7e87cfdedd3af6b45ac1f62f7d3e614182ae60ab3deeb4c10c7b961cfcd34ade5fb621a63eda1b653189a7d57d53435d8da0e5b02f04e331d139b560b210fee02fd9c622bdef6059a81d9322e99dd7a43ebe107e59526b700f09f3a1ce9193b0cdb4998f249e838f439768eb41a0e6b0088bce579902baba753738bf136adb3d214c4c82ea67092fdbb548b1e99571f98410a5159d11d253b916264fc7acefe0449e118e2f21151fb5bbb45684d3838c6db66049aa42a4a78cd37326a07ca0ffe1155328acb0adf51d4aa916c107d0f2dc25aaae7ee9497d8033e693a0fdbbad7799f4d12020170dfcd4568218f882739ace754e3365ed28257fc71b1dd56d508075ac4bdd8684496726c440d919f508d0edd97d361ff0f1be032110c96d2e1e4aaafbf497ebdbf4e43bf3b0ea10a61f73642ce20be3e4a9cf718032bd77da96a8f57acff7fc3dceb78f5cfe9f012e39b48f982bbc44577658b04d17156685bff8898478cbcec56894e589f949c2178ac06f6e4fe7ea2fc03f1afe9ad78ee666bbabdccf8cba2a47bdd3e5db2b8fbe253ee017fd6cb05ebeea6a8e58bd90c686c73297d6515ee86382d5b39e5d88501f9f34bd95b3ba664f115aa2f22c506d574f55d79b9dfb4488fc78178d74703ca600b3de541602193e4e4bc210d2cd8c07f6fd4d97126ef15b25ad486d6083b488388e2231873fa600b9c6def3150948ae94ca4f76725df3d942006d4a747b9114fdf73548b097a0a918db0fe943ee322f0fe62e550cb1e25ab89ec6dc840f592a62ac105beb3cc9b4b68f814b8398c98b5bf6631e8284215ac5755c14dd900d47a95d11c95f8fd16f5fec6021bae87aecc1db366effb1872cded63f99d3a888a069aeb965b9e76951ed26904f136f78abc71dea67b2baba002e628b4b6e791eb30d2f955681f143df89e472573b2aa69eeaced00923eb6e36bca7edcd06b40ba94d3fbb092d41fe63981e753b9a15d02f045fed7cdafa70ea38b6ce27638ec8c5ea5856a90b9f05e4dad303ee325a29d38cc2401e7790ac8bf65233ea166ad21c6a6c61ed70b1b09c3d4833e72da9b6ac3f8d71c1dce016e8b09c748d392af8dce36908658815d9b766501939c8202643fd6dba916fc5949611b3d884e20e9628a9b9062dcfcfddeb0bfd987db40cd0477ecd31488837313eee936013e90d912a3e50f399baa7a8507ed99f9d3217f8227c07330ece805bbe6eaf2d45edc42e549ee3db4ff7a359e34d50d2fab1d4e0eb0695eb5b8f251ac64a9aca79432a20c941f44afd3a42e7865fe7e988ec7d940491c65c9ed891a66056db31684c0ed719b258e272a6109bafd6656ba9e8f2322efdea1b7f7930f220faf51c73fb90ee6f2f3b9570e89d91e7c1f5f1966ab8cc8f509d07f490c8602c219dd9e0ff1f39c33a587c4f9baef02ce98eff642bb7018b055efc8c01260cfe86a78c5dcfe60b016ea241c4b9518ef4fe11294fe84af12d6706476c03d3dfbfc10c6a132e538337bed6f33e6cbda9f5ac1720e5beb82f3424b559f877a3060fae085c6a88c6c2b8970027bd7de209ff21e680eb9f4e73422259b6a96e9025bc42fbf5b011a207df6829385769756941d6b73ae06a9889faa5af281cae1d6d03bc71ba30d1319e72e98bdf4c8462feaeceecb9c6279130b8f4932a2801990b0e3e7fb714acbaeb33a7f5448a9ad581baf5c7dffb8eebc7030c52403b0e2e7e82e73251bcd56bffc71b65e74547970f078102c01d943e2dfd59d647da7d48e6201138980b9aa539c34437046062ec31dc4b90427630b57526c8440db1f1f116395ed836a4e5aa76fc8763ee623584c491d9f147aaac516ae9b20086464a58d53c397300a9c69dbdb21a2290c1a89c2e8ed1dcc5cf316d977c6ebf8e0b31fb31fa3d2fa77f911a946704e56e3597c78ac2f2af503c749934e2f5f636f957998888c06d73d0b5b791e7856094976be35fa2954d31d04eda337ea1220f20f83ff14c22e55c13fe41222669eb9a38ff387bd769f12c340f8cbbc8edfdf02abb0a3c857905f98a637689f8d75ce1bb9460a40d551b1f6a432fc6cde7e61b2de6d8c9604e4722874a0a44d45efc42ec90165f2b3404897f8ee376827c2d58eed28e2b718c098fca36c43bc0b3cf79a22d1fc18bd8c95c8c47ccfce5ca4cf868c4494f6abd9846c0a4e725a19eaab6c47c478567db3e60cdd5ece598f995e7fd3afa134c691d5455cf14a9a7c1c3f6fcd37b619be1067f29a54d02ee1149d90e13c8db78c3ac575f33d2cc95b0cd1dfe7d386b984412ee6e58d508f7e18e0ea7957df15d5d128f70d383dc2c1e89b41e29ab39056738b8d4c23ddad156e2d5985ff580d8cfe825f1b02e087232af2b9ad5eac70a51706d6968b7c6ceb1422f39ef528bd8d4c41528e6c800270293200c73aecf4bef62723d264d362e93d0d44f441c6dc6a7a8532cd13fd0b6f4d02a710888ca22b1f505a34ad61d8b3a4875bfe9314d6ff39b6d5ed43ea359a0692922bf557f1952fb26d7d29be832d67567fd06eda97ccc5279260600f49d114e1f4ab8dcd58632cc0a6193c2442ab47297f6e2a8f551cadfa168ebcda7174fd4a23e813347567985c1865c1cdee7f200f4ecee43e86716f1f9f808a2f63f2f71b92907fa1c58220c3ed5cb4db42e62d24acfebc57d42aca5ab0b2ec95f8c68f1e3384a369c0233cfaeed79acf44b4e09c3362d4dd0d33fa9c8bd52122c2582316da3b4d511983d60f1081805c23961bf00e6ae21c40a02af6693e8b7aa78a4db2335385c801597e806418306ea39fc76af5dafd10c273adf34d5b28f563297be5d13e60e63995407cb7981b05d3ef83673adaf0b331510ec5741881de8998d4565f6241fb886178ea51b661d5e69bc7f4f247d9a37500f997d72bf93a1929eecbab98593213c2f097f184976e6789069cd0b870551def9842e24e82cc63cb12816959b51f37f91450747bc636503877c0c07e3e5213cc727852b611c5b74b5e23162493202475ac9b52f35e65f0984d382d6887429f732a9fee9d76b0b68ab4b38eaac17d9570a57b784822fe3f9edd895da8a9bb12c307983595af730ab130b80568ac8859607e36c13e6806bce0d7618bd15256f417ac5cd3cfef0156d55cec331b54d3864959be49df1c708c2b7cc83d5340e1bca44aa93862a91acc96b6febdfda8f7c2779fd882cc96b9cac0f11dcb4447f640a30d0fcc0d1785c681a9bc5fcd740c77858bf74934420071c3c0508374f3fe2095850f4f16f3a09b86666747b98b2753c76da7f9cb2d3c07ce6a904dd17f80ff70e10baad0be10cf1add30f41f2e6403531f6e7edb27ef5090d59f92a3b5847e6284943ed19fec84fecf7e66e690c2d71e4bcdb8a77c6677e0e015064bd1e0da940711646823aaf21634860d1dd935c88ba746282e06bec84b0fe6252e81f413b24c5319e78c6de35288fe869710a188db62ad75b8da4e4d85a2ecc59da90739287ca5e21245e4125d93cc970809a084303a332df24e481dc84b297d3a9fd64db25c556b18f3f9be305b1c91162ae0396a91c2a6ea32660aa362d3449121ad13faa06647ff6d87be869e7280447c029f0c8cf61dab9f2c694d8400fa6f0c14f754699add0e862b7953b9e53eda15c76150817bc90019077b2fa2793dbdb796f5a2a4c26a8cdd99a2b1f16093b2b58bea539913fd6b58a3e1d24be2a2f33440c4f54db31eac6c10d2b5acfd04b8e4f953f45427482b210f35adb0ba2b34297e0a6fc81e0d6703b93b475ab54393acf9934b7011e49aadf6866379bc4567ff521b616573804defbee92a2de869fb0d694de63e958c1a668cf531e648a6df23b20fe635fffae3c72f27dace1502df3f0f01c210f1884f825f23f27ede29d131fb414c4df80e3a4c286777b4022e6ec8d6cdd449864778b633ac2d396e34dc2737d0dfc8f70ae698529107615253934c5b1db7b9a5e9ebe81d6ca5e0f63bef80d68da3abf679e1bbac0c2aa69a5a35024550188a7b9ba1d8008f6b7c0f2d2914fda6734e1c6e046a3ff5f459dd485ce06c20bc7f4c8b9bbc920312d7e2a129b012d6cfbbbea2f8ce22e4aac209daf493ac233b35e497a598ae23a1b1651987c2eff8685b3b434f149794c97427c8355ed4b95d935239797dce6786d2d4f1798bb4521beaeb7897562f5b4bbaeeff901bd4fc413beb3073d8f7226b6bbcb2ba81cab29bf67f327c7c89a4a501608a3f0eef9e7ecd5ad179f8fe1f5a07fde2771affa8a91ffeec1ada00d874af9d410ccc31a2322679387ec4950c934d4bb881f3f75643096db4da57973dbf86bf703289ab5b26803881deb89e2731fb73997594d1818a597d42a77eb53b6d49c32cf978ca19f9bb72cf94badfff2fef0ea736fd59f262b99602c25eac44c1095ec50d04ec61678efe2daa9285b12da306133a7d31f0dc2de57548b19a88d9c4b9047cdfeb232f5dfe7148e53ddaefe5e29e78f77ff080ff18bd012c913bf969c94892ab7077d09c8d34e2de0ad37bf4e7ffb69e1ca0b1ef3d958bf93cee7a30a469a50e34fa0ef44f97f803fcb72550d36c12a56d2825779e45fce93db0e150e9a6c3e26e18960ffa3815e4fd0b28ec97ff44e88650874a2528a4547257869a4a4cb53fa8e4a3522dc22c549b335eff8c826894aba38ee90ca5d8db7c808cbfda71c29b0c09112cd80a3bd428881e31148b847bbfcd261fa847f1415cf8c7fdd41b1a711e817dfc0126ed23f6013fef9982e1742fe8af33e8b6a93012d0917835529ca8d8141233cb984298e1dcc4263e600932b74fefa485c0bfec2d90d6a37c951b289bc09c87f72d43815ff91b2a96eb8318d4a61b55eddc7253b376735b357baaaccc95c3f00332655617673188cfbd583d671b85721e0111f66bd0d5d442947791a315d61f8cec51b86becab1c30353429d92bbcaca595df7c1b8db57601ca4b57740e394cc70397c9697cce8b137ca1cd416376b12f8182e64903e3b5c6e86ea9e4bd1a8ebd239d7187fa0e48943bc2055a660455debe3ca7b62471445103cccd41d3c6b531139be3d105edf3baa1eac8098eb4b8bb8173188af29ca6d36f7c06c66040448e369c900fc4e7bdb72ba0df16634194a77ac03b5a44eb190deba76cfa345ee63d60c31f81bffe39bc3800a8218beb707bc0fd8ec0bfa8374a1c9331db7b160f7b09d40223beb1c8f83cc408a1777ff99d1d6df21c66c053c6e58bfc72573ed15f3cd6a18be6dbc5e1f6091ce1f56465306fce24e807825","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
