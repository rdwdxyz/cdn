<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b038886071d797edf3d7b3f3abd6ebbf74c061f127973e5e0ba9aa4e9ebe3cd519b435df7790eaeabb5468bdde89c1d6a81287724b887f157c94f7739a9c828571034e95b99ffb278310d07216a84cc4609c2df3dd91a1bf8cbed014f0e3272eb5b47d7c82fd2fa69e2ecdf529125c6fa5a3c506eb6d3fd0a90609beb0a8f4fa0c69b70500752ff470945cce277af4a4fe7c049593c0a6c01cd28a3a4510dbd68eb70ef200b8680e5f4ff2501d18f1935b1bb00c2ece0c5cd4ace8b0d2e6052739d34c52ddd7ea0c2f8c1ceaf7b2a10d3e02f142a8c33d8ea84fbc7934add0ed1e91feeb0dbd520d4b8807eff8649b9a6e48594679fca4ca93d5df9c6ce31da6d6d01122c957cdd5753fdbc844fc90b0f084f0d44dc2c709387d188c16843ed7bed45af68850c0aa9bfe590632026936827e790682d28669bc4a57d5cf186d3f89e64c97bcd8b2e33278b11deb96f17e72f334d327a273df278b5090a276ce4c009d99c34b6ba4a70bcc36bdc55aac6cb48dd0eda8787f968a79b1c718c6aed2437d9687cdd0841a388bd1ee631cdef2589bc662554cea03b69b36b3cfde9000fbf06cbff61f0cabad6be65092e2fe19ca1a33f2b69d77d4cc7d9da62e899f60b39de1d7cbb62cc271259d03f6672e8886f49922671ad7aa8b44e0931466e65e8657f6f7b5004616a3bb478136161cb6bb802fc3cbd07ad0cfa75782767ad3c37f77bfcc6b043641541aa1fcbd689e3adafdea0e8c9306a6a2a64d1ade868ac2b70af7b0e45be0a254f489d17b15f9509e527338b265480d9dbb286ee08bf7c8eb7746cdfb05d1b6447a92432a7ebd7e4452ea8e163d900b055348e70868fd3435898a82f2bda7652c147a3297c92377e05c147a8676cd5176a992388af41e54646bd5a6dd918e05041fb99abef538b23ff2ea8d42ad466b9fe1edffab93c2fe9ee0cb0566e08f3f3ef879aabdf6bcf56fdd3f7fe6f718219596ff4094e84f7556ede6a5f2f81854eb5a9319aa4c7585749157ad5646f918ae5161403159ab979b02f69929f95083f76903a496f0ec15ded10b17e854f69712c273294800aac689e40e457365772e76e1660e83f54c6b37e201b8c594e8a5bc9e78b247eb7c7bdbc2b6de864416058fd42dd52e6001cbf748c085c75593bdd018af343912fd34aca28dea1fd990b904506bc764d8a307ffe456ccf67459778857df630f686b1e10786ed7d05b15f280476c97322bc60731dfe64194659aef71c1bccd8a0dd9cfeab60a6e3327b5c2fe312fb71469aef52fce6d08efbaba46980ae473ebfcb5d8d2d7b567e6c772427cdbed142dbf92fcccaf9309b555f6f183f1a85554b09ac0dfc40e510fb40f8a47c2127170bf6f399907973f45ae02b4bef194cce756feac89ecd0b76ef705e955994d6397a46d251dab091682bbcc16bb914fc62d0b11348b15f57eecf206306324601c19fe0c8e777322f560e73ac8dc20490ee345f8daec6ea400a4ccb0620805bfcdeb7f733f668a05632abef590d3c097efbacd811dd33010fafa8e274875c11df2d9d81c2cc8b363ee16e421714736e6ac710dcbd27f5236ab247927793ea58ef2b5571efac17e1e275caf37cd0be9af73ab7ce094276426871b112eb54e5be24df4f88af6165a9ba12163575f7a194448db3059e24d7226071f8fe6f186f7ff68a4f033c8bd13a514ab9e054f796364b0df18b4218122858dd29a5c7bbc793a87f74da3b5f6d939112bb1e0d1347418da3e6bcde2a6fdd8edaed1da04c8fb03548dbf470d5f63f1932631a58467ab96c1fb2b29ad09c6317a85a045e5beb1168603e6f96165cf7be8550fbca0f0a7b0fee30775fbf60852e103d7c6e0406e68c11c7e2606077266aa57982a606072b74cc01fa40f56e896eaa809112cc89b9e256b62ba99f6bb4610aa943539cc580faa0fead36d5595516373a178881aa1c341154fc6b74ba7255a316cafd0d2592c2cb4fc53ec539e326d4f27554b9f72ced0e8f12dd56ebc4bbaf83bcf9cce50f45d6ba0e8de1c77d0e707f76d42f6098b7e3f5a78d22b0a09de9e8ea57b83a146d4babd7aa3c056b3abeae5aa43a45bd39adf46be9b5b5a638671bd190eff59a2fd9b092c4473aa4c9bf4fd8fc185876ce7f704d2188b991625a82560dcce1d229fc2b5c7e61d08f1b03f7bfbe9d3ca2228513d95ae2d8dd0bb4a588698cd7511b60a5c5ee7d09514e2a3a047ac63ad3a14b145bd90fc504ee9dd5fea092ff73fc92ff8fffaa52ef50eaa3af3ffebd33425db6735fe7c8c29f8556ade223f6dd5e49b1c6ee61ba1de26f46f3bec45c6261ccb656e9d6bad86048e369e61c2a2f2faab17a884732f69bd3cb8cd06f804d8e5fe998936eed6d847e830f5f271d60b42153a2825d78cbb04b2428583380751217ac519125b671fccf5c05e6e437614083d5f4ba22b1af92eef210fad73d5e8d93634725096f5fcbb20fa62088a99ea85c9d8b6a85f3f4b828e17b956fe135bacc1ae437793eb0fdcfc9a4995e01566772722ba6e6e8153a45e1a450ca1148605febb0ba3068a73852f577e9b84a9bf5d5e1b49caa2150a7367250363ad03985459b4f8c11882c5d197ebeed8484459d5832e394ab36a3aa2061555c09151eac2e46e1f858609fc1c7ecdb7c2f7b8a1e8598762a07b0f9546653dccbfc50438092dbb817062c3616b7f98e633ea2b74985a3e3981ab3fc3cfb3550a844b97d92347c6e103cfee46a6e9b257f6e388f7bbbe445dbe5ee0f68271dde1f630c79ab319423767f07c305dee7489bc85e89f8aa0a5f5075a3b3b2cd81125150cc07989702a390d9022dca3fad38a46543fb30f9fe4a967e9a2e4b812c873838377f00fdfacbba69a297147deaad0461ea0829adcf768c5697d0b7a9ef08ef7d3d32adda38dcc96b4607e430836d65e890602141c1317506de51a700baf558b2e510a1aa55702d022b150081f2b96b97326f19ed6f8b800ae01a906b0cd1706f29df2efe43e18b059b39833ff8f8b975b9d4e952366dc2bd8468c521d1e5c5fa8b5763dfee2d581f1e78aa1f5b1deceecf7dd4ee49fd419f0c17c4b202056ddb147ecc29450fcdf7968742114ff03d5112ec1610b5096ebffa8e6590bcc882798a9982eccb5da676d9487108c39a4ccd599f63b1fe8580d5c194ade4b539c42e66cf1706d323764aef210bba89c4b4d33c78bc906088d2cfd97298da7b2eea8f3fe0b1104d93d9301017222b8cab5e9bb7819f3ef7eef25c2b0f5f10509b9740831c2f3fe53309b71fc5c4b3a08cb3173f3ceeedd77622ddce4d57befe03a386946c13e7046837851400f96f7e36b47831e7a080ec12feeb462ed79b9c56c1106b4e9f71817954555369f0c073de340d2723bef56dd05498d08bc72334cef77b3a7d62909b3f3adb104d5546857b488f8e53289873a043ce3d6eb271e1bdc3a28402473405fe5641b33b103f740be38c3b97276d2319cef09b6c73b10dfdf6ce1782d7e08c417426d07d591be0c069c5c6a4d58872fc84dd9f7437a519afd66f0bba2e7e915515976852785f0e30971e008ecce4f7904ef5f3eb67d17d26791b1b501e19177ebe26f528f5a29315e07762b277f6e541edb0cdac35f334f4927f75fd4aaf8b024666c12c31341f9c33fb20728cdab5c0e856216a1e243f18a9fe207aea57296cf9c5314b8702ba6c6c18e273404f236117c3a9147732e1bbf686073b5752d8da357590144df8022462bc4e41c3ea85f4aea891cc32f25a2b1d845282f5dff0b184ac1d36b97b874af27c74d8d740f8ea51d8c394ecb9efed43e8748426c8c68d3dce2fa816cb8f72415817f5dd90e83ec995462a138276f9c6a04d39b8dc7e24be80916686367cef045460dd8cb8ac971099012925a4b18b632a550cbfea9ad9434ac0140ae9d4debd3b95087dc3b8d4166769e17bdc9f90554b8ec9dc979e0f5cedd1fad18971f76bc82427023fbec01ed262a7f54a946e53f31f25cc7edefe10b06a7ded1951516e7e87ff5a5efdd07ea2f6cd7256758e6490a4cfbc1b80618b77013bae611e8d37c6cc35aa7f58ca977273d54dbed511a43018e4d13afd74e38a85b60edfe0bf98f78cca2a100fb477f7ed749be8cd5ccb463b59a890395d1822547015e5013cbd802b75912f076765bba33af9d8499c1bb0c5d17e75cbba43158e93a89cc84d9562205af87c28d82597cb46c4e87cc7c32b7f41d9fd797e9008eac9b6db714a9fc85fae9013aa0fdc3f7ff1f3fffe5055ae85871484c3c20b7bbdb7770c791e6f0adbbe37805acc633fcf6ffdbf090cf5a1dec518c26d7f7db877f15e9d0af520fb00e9c560295da94df7a36aa72db0009f6ae37fefff9d3b9346f28a1355a1a4780a44a75a65e74434718ebf6126b84144a913df130d090bf634afd179190c2228b0bbd1a764b027576c4bf56d522493186d5cabfca89a67c23b7165f19c3f071a65e040ec78174eebf701eb17096c5290368923e208ad07c22e14bf7b86c4e30d38b235e3c083b3a1f2ccb1f03baaa0fa95764a14e3548c77ae88f3d05434ece6eda38437794c128b117d43c9fca3703f0d1c86b61c46bff846b4156e0a1310da5b61a9b22c07eb4e8ccc2fbf2eec31ded20855ea4f3e0553d2c543ce357e25b8d9edc880f87cb9a83425dd704fc80dec96afbd36a62f71a86532473e4702267577144e6b5b7966ce7790a58a6309935ca12a07d9b0390ba5c3295766d357e3e06f93820d145d0d0b1d3d26d8150ac6bf5e73e71c14e35c0e5f4a9a15709222be6641bf5a3cd3dd6eea4c76686e282b4228456bbd3dd11f189c48516aa89fe93eb617a464cc6e649f89f939983c8f0e99ef12de9450f5fcbeed00a4c6211fa9cfd2de6b27d0ce7ef95b6d18aaf9d26a4ac222ea2ea193a9836cc16690da95faabec96c115df53a27872834101e984b3a7a1ca3f3944f0b7a877d25e5ca68ae2d517b9a99db939aa2f1dcb66d8e11cd01d8788c7aedefa673094daf8fe7f0e50018120e693713222c94d55be18a4a3cc6752ee112961a51d23ba8670a5fa44d420e12e6e0d1b19ca24ff1ea34259cdf25fbbde1342a8cb743b470fdde327809c473b4d1b5448a44defed3d8c026b2c02d8b966b92019d3069795a33ce51eee7a45a339d3eefd3f6d782db990d522a910f8e82c62c3a389b0594a238a2b255a28dea0f074534163f2dee3feaf11cfbea5f5c173ee558803ce51c0bbe95ee2c06a76990264189ea52fe109d25ffd821fb93325985f0584c16e1941dee7112ed12093550bbee7f3ee48fffd9f5f8d8546e656610b6b4f9155ecf21fcbbbaf93d1605031de1b2505e856991107dc4bdc737278adef653f230baa254273076ffae6f6af0fe839e80035c0ae944c19a46a05d1b4dc0fbffb17386bce962e01a17b00099124f025d645927c143f35fdf37057af2e70c14b240268b88f4b4e05d7f8b0a0474a04853a6fffbd63567c81fdf923631b80dd2c23fdaa5ed5f1c02b5b5c9c1e03f6648d22040b25be222da45c34ed07ee1dd58ea0383a740851f9468fa6ba22187bc15e20464d455297b986d8a42f47159d4e62e83a7247a66892c082042d0d0255d4a581f95787d70b9914847a317f5dfbfeca1e22f0b0a536224db8d816c24474cecbc1dc1004662be1c21e664d312c561394a4a27cbe5cdc6f9d7ba2e626585510cb4e769e7ea602cb8e6e651a8963dcd04023a3038a29a1694ce09578e1cc6d8ae493821295007ca340735d2c41bf1fb920f06b6625f39e2667ed779b7154f0df962b31a13266d13e0baef3e77775a1eda751ddfa2d0a5a43ae62892f0fbd9420bfdc13b16f9fe7f8ddd124bea0a497769bcaddfb1f9744425bf41e7be88e8d9f8aa87c1775ec821987cd1705173adf796d6396a89b199c0b1c6d757e9c9b21f1eb55a683c30f08f79e324e1964a96f488d00c3f9184471899cb310c0d27db66a126b838df7587b7ce1ceca9efbdd71e91cf581eac5fd6b33d2da3f91c8ad925585a3cde34220d0b8e633eceddca8f926918753ab2810091b30d82d84644a9cbe61619c609f61708eabceef80bf6976132e2fd3bb6162908126b83d033dd2f601166067640f60c62cf4a04dfc39a7a6c4f004b73790b733d1acc6acfea351ed7906a84b1c0d7bc72a3baf43f20de3bccb05475d7f3e1fe8a03ddf39b39f7dd404addecdfc50908740560fbbf9e0e45b0fdc66ad346bf24e59918c62e4c5e3129a3f7041571cc1ed00311ec41f73320f74cf551557af06b1fb05e90e63c9eb043e9a022bfe4a5f5ac174a918799d00d5aced0e451bebd84c374f364eec65bb70452e23a26603989a671ff44e0a1c761b2a74437548d86bfcfd1c01734b73d94c0da2332c5402ea5bf78ac91364f7235bc838fb83837c8b1a8693fe884ff161d908e8336fe9982fc49a858157fcfad3723215033a505c9d62d093396e5558dfa60c0114206c5d2d21e4470bd3db10bdfbc3c8bf218534c5bcd14851c3b4e2eed9814a41c1c0666c1208f6c057059e957ac7e2691626c0a42625ff485b9ffa22731d17f065cca68d8e7007a138b697b8839767068ee14571c9d24f4b7c68d734adabdea1234b8c1d24c963296dd0ebb58259a0e46ce813093a954bd7fb717be7298d69803068be089d25fd7f00b6f3aa136eebff907a710d91e4519995220e59fd3c025a3039892f546158932c8c782d533cd188949e655f5435176c3e4b999caec732f9788691118b77cbbb195b597c155dae142a503658a448c906a49bf3e146cb2a79f352f9e208c4f8f12f5423159933eab74b46f890f90a974b10b3d4e98a3d718a569659921fb9b3db8e3e0518e84786b029ec7cb2cf3d8b8a71960494d19543cfd13b4466146f3bb7e72a8f4b1d7106c5b57021b3814c7fdba9564d40287158e4da61c080782575e3a43d0aac5e22f81e3f0d693b06ca4b893ab5b0ad9a5897fd188744d309040fab5d65bd4fc7f8a3d58cb734b0be14d2437f58da5ae7971023f214884a767ec79d6e616b83b06fcd66b93cc8cd209d739ea6751ba99815546a75edfc747a8afdf857734e3da6962ac7efa6ce441d72c69812ab2f054be895355d02205567b1a0b509ff2aa084481ecff6c2dbcf0e40e2c68df2c2b91ce64cbfd1390ea4bbb59d0fe924e5e77632d3ae7df6f9ff8681feb04c444e1d776964fbcae344e282551514187fb01e2c69f0b8abe7e7e245c6bba7a918c7e66335158147395991bd60bc58a4d493a8c599a4b9037dd86e8e3211bcace23bf5e47db7379f04a1932c5e6b8ade5931af5a589b60825dff105830afba3eed79964d737e77cb9afc9dfbfa4eae130874f4369b58c95697d423f36968923ec01e7313c8b1007009cf70f6a19b6f0e34023836934f49702bae05ca79a4de75224c362ee4bce10cf7bc83e1d7eaf787806b89aa82d882d138e290d7cd5b07cab8d5a9a5b659f93cb423c0ac84bc02a2ce9c1cf13700ffaf262dc86fde1cbbc1b94826890fdff300b96495a05849659652c48db6359719ecdd653cf603922053d89aa2e36c51d0646e993842f50c239dd9f766599aea72753eb650168f6898d0771979e7925d1e403b83021f8eafb7c606261a32bdbff8d08f2bbf6a43243f7b99dfc9bbe1eb4936323984f34be6afbeb7dac2a5f1dd6954382b3fc2644a920612973017e06ff120ae6f82ac6fd8e697dd4cf8833cb151810e5aeb6a64323e77214fa673cf38c72df1f5bb49d3cba570df3fb6ce1a0dc6d678f3980f5a89446ddbe54d98b52ef198e74e88c3756cf193a2117610ea25b3f5fc08aed1b974849f33317ae1a9aac961e35c076bd0ecf0ef3102cf20bc03aff04a725804a73fc6b508d2299f3c5edf4110674391b4e3a62c511299bad41c312f754f1ee8349cee5f4b0e8af70267a44cb7090c1692e482fc5d6ef950f03ca72e667c87fbb83be6243d7b047153e1072fbcfe00b5c6ca934e2349cfdc4e21b768cbd5d382d46677eee8f1bebba8180329e73832b534e0ec54d75742c8e92a7ea4fde5f8c2004ece0635c1851411447f8753ce9c4ed39f666bfa3b92f026d7481485bf4c55b2c671a5e8d9fe6ba336c464251ce0784218ff2ec19903e9d02fac905ed5efe13c0ccd2dd5e2a7c6b8c95e9fe3c0ff2fafa0df3c1f581d41831f56a9fc389a60d72822380d16ff40eeb6d435f9d8a7d191a681ff9dd7c9227e147ff023a5b643bfffe6e05c9b6b6698774fe953e163ba5ac11141125cb5046bcaff50d8d465d64d1578fd6985aa95374647513707688e8b59cf83b5b9c3def9296eba20b6fef4c2fdeac0f140613cef00e078e0a8ea67e11815e553b9aa07f1f50382a2bb3385841ebee3e871e37f57a36af2ddef39ee03fafbff5a0ee1c6fc897ab5ca672229a5993fc8338770c1bf06f492fa31bacaa772bc24b58857421142c5002526ece8f638f42e1fb88d259f178cfc318dc4ebf6f7727f3011a5470ffc7dc6d96638c1a37189718eda4c1fff6d2efabae061cc25e30328a457324fadd586512c9ff889b0ca63a70302ec654270dcbff4cdb4def7b83bf692b581bdb907ad662083856d9a86fe11c35f34ee0b635cd2b8d09b98338ddc10d3517570e2b4ced0d36b24a24193f5418fb2610e3bfd8098189b4e10cd3fabd10ae5de7642acd95696cb2c637172652f89ea3ae1b2d9818fd81c56118e364c902cc4039161630aaddc00b9779a15005c5215d5588af2176f09d27b35b505a174142afbd6a879211b19566a8e78cadb0595e0602c88440a00bd9d27aad618fa6b46c39864280b091fc218312d8b67e669e1f361a8ce0265ab82e4d03a6cbd87e43e3343080cccc848bdec0347f62c837fed6e9e182adc871ddec7a0d56eac4351e8ba94c99e92947867ee3513e674ce00761a0a6af2207e68c485c40743fe6d289f4fd2565f5d31da6bc2292eca811417d9f0b279e07ff490ba6a5a293462fad9041c5edf069d00a9136679f6f77cf36f780fa8c4185c7b26ab8af1ff8c5e1b0c472eec989e084983d08d0d065ac14b76aac08d2f66e537488cfc64dd1f472e1172c8d69e457bc6df37bc8eac01f4482df3e108c0c0c2c667dad5ad6ef39d1f5c83441e47cd15883d8ae58865dcae1dd1f10504dd017bb448e9ed3baeb9e6272112384ef0a5a74d9a914a59f18f9c553c16dc00fd66704fd45713efc7491405d8735851354ce52a19de0f0a32e27099ae50708a3d16cb8f5833cf4ea384b7e5f336bdb3a40aca03689a401ef2eaa844272d2e5d67264db1d38014060ec0662f9492df2b250629b4e86bdebf30c86579eaba9231325bc54a5522bb661c56d88b9f2a05afc28763ad15927d46d8ab4a1c9f11a25de7d34e0339278dc442f3ac28803d8df4393c0c8821e8597fb597cb78e13a6b5ddfa6e20ae0554b3c82f9b38e1801bcc94f95c3c1a6c82a35c6c85cb333bfa9fca895f2639e3703455fe9ecff48d255a1c896deb399ba8ee28008cae2aef537df09adce937847f13b7918781f7fe2b1bc94d2820946068e1691d71b67c011d7361bde03b04382e7962c8a71f93dc317ff58b416819bd8f4e6dde97ad05da5a869c679cedef1abf5c17d3c37b17f48c1dd438993cf17418dbbf43c460d1eee3a4cde5b369fcdb4007d92e80604dbbb420bd053e560eeecb1c66e80f7bc6a86d7589f26b7c5de199101e5937bd9dfceb6c66be7d32a0f6d0e2de5c9cbb71bac411c8860da41fb0f001a828d8418f79e0db066b24e2904407524b993d7a9d0c51ba2466e17e0989b0bed549b06356b165522687434dfd4f162b2d6e1d58fdf968da42bb1086f889a65615a8aa7e5eecd1578520d6fe18172a894a00fb1a7eb20d81a0e60551ed99fbd3d21679a17cf499b2f5b341439058d41813c7dc4babeed0059226ec3e8677a0032c257c2350e28172a738fd0bb5063e4730869a7a5482f08c6440de784255d387ad811181e748528f63e631053e3a0d215eb1ef42d99266f7e058964eb08ceb4b99ef11f5607e0e31de596e2fd9c78c218b67dfaa293b7a467f408b5afb5165e5772b42d3fbc8940f246292a2d1d3d0289fdb4bfb90bb93ebd5ad09027fbdf5a80e0c2efa57687a5b80a902d3112ffe405c9a156ba577a1af2117f8279e173e8a00fd00400103eaaa5a9dad7b7b99e41bf589f2aa19f83215b6a7b797ff360afb85e9c752f6752094b051b5166e9a1ce30f29efa65eb695c9992952366a03023d1b5f9c35166529a0a304725d0a41200d6ea4bed961fdf9e782ef8c6b4cf4f4a4853c4f936628869a8580e5d4eb14fbf780c0b3783440d0fc1a45ed300cb05d730aa0974432b402bc481b3cf5eb6e63d48dfb7eb88c9108bbb6989aa122b8058","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
