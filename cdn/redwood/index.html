<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65063fac331dd89acb5e2119c64837715d9f42bc7b96c0ebdded156bcfb8ca4d7b8317347f11417bd2e194be7aa6968d9a6fc911fee9d493c2be4e33827599db7b06110e2842317cd89d6bfac15c43a90176b856a7bfefdc1a5e335e4cefe7588b30b243fe7fbc5d5edd724409a3325750785fceee42e204f35207987091b8baff1941ff698161c82bd2211f0fba2369bfe137ef81d009c804fa5dd2ec3a0ebbae48c078f2ef991cb229d18c6175227453a80f5fc9fef71d27590e2df3d3a9cda03f9c1b33ffa3eb1715d481537b100334edec36ae49498821b51fd3419ef25aae5c119cdcdabc7e56d51ea2b41a3814dd70ac990238995a1fc862fd4fa990215c49b89edcc26802120390ff201346df5acb3a91356c1c89e1b3d9fd403ca9f7abf555e905ee712acd1157fab77e44cd1d57743003bb0e14d048a8b9ac8cb3ad9286f56871f0f2c3673ac1f4d32f9e0a3198aea71c4d65584e9db2663fe84c2c48f17f69f1a8bc8dab0a377d8bbf41e127888abf70e681a5cfe07717a0ea965bd29a21a7c806bd86af336a16ad73a2de01cdc0b02a1d8c0b38aaabaf2adf09933c7fa2ac1296359681a31b955327134e6f5ac1f1942a5407025b40c964df05668251e65065767f2012f6a1027c0b5af6e65ab31636cc8dcb630bf41f6d4fcb8d555ca05aee7c209be842546140107367dd274b26ad2266f3db933cca68ef7221b23407fe5118986ee26bb0dd74fb4215390bf18e5449b0fa9f0e5b8cf1b3a1e533d8ac7cb654cbec9f2c93e890df2781cd1259f4471e3c899c26483d33398e2fc71aadb1cead009da600cc1fc041415ce3f099856039c6a634ce9f40c7816f72546507724c1bb6ad530800eec8e22238356489a733fa267d00d019e9abd04fe5c2cdf65fbd57590c3dca09652e35d3fc5e7c52937c81842d0d0b67bfcb2f60ff951e83848525ad0d615082ad9988b60d44068f109ceeca66c2f84be7264b1b79c884dc3748be8b3ac4b51000f2ae7fbc688e1a743bee6f9e51316458e715860e18e302b2a5d6d12a44ac146a20146923c8e3522fa345f293644754cb25b95026432a9453071a21c19f4b523d53c7689abe99043a3a2001267b1f9c8609df9d5385f0b0096d8fb3f358d5bba1567bfcdb0bb9eb9db9222edaa0bb95a8d3f8c1e031cd1d998330aba4bb204e6a04324ace50ba70de404169e6f27688f4693bfa903c5ddc241ea4502528b4b2a4391c2c2a40951f5c2fa13e1a10d51d9972c3f186c53a21ad7a20e334fe4707a01474e022d0c2069ac8223896ec544ac34ee5909fd5de04e9ce6f79d900d5cf77f6af0a1b86a0dbf393511ff505be8b8664c144d9d7c716dd6d356a81cd6271e4ef36e10e879ffd18028c357f683a7f2097eff2a0216e3af349f8060f5957ea0e6d6c6bd5d17e4bd442256e016773602ab7bcd1831a93f0f208c0b886ecdbb2a46000d0b7456cdac4a0b6744a470a3f55e76b4aecd393f1d37b191c8f3d3ef045d0d38aae75757e88818ac5e5e6ec3e40fb93375430b600d0ead9812805753cb0bb70934c084f6f814193c36d12e26eda01ea92675103a2f3633d05fc364f939672b6ccc8c19c3fba978f318987048c9faa811a4203ae20c389b919e088730ecc44f0a22dcc49e0d18cf8d8ecd5b90495f423e3f48a8aed0a701f59944a740b4b1ca29d8654c2449a8aa9e5bf7c48835ceb77551b08b7d47d80ec2b206347ef7bed696cbbc63cc945c0318fdcf89a61d70a1b8f150a3d652280311efa56c8644a32ad26d915b545e0ccccba4882408c0a91f463eb4fcf849213135d83e5de04508c7be8399015d10b47418acab06f419d517e90b50c973b4c7be8bee2aed35d192b4b490128e8704772c9182c6d3fe2ae5e37bc7e095170bd584e5e9400b321e3a10ade2451e124267f6d68bc4e1a50c98ebb75ab5639299cca31fb2a64aed5a3baa2c0319f24d7c9a9cc886ae82fb49c2c2bca963fd1553c409d93db83d4f2747e8feb340624cd3d89612929521f83db3dc483fe1ec03c5605c4e6f1d7343a90be44e6ce9d99fa6e7a48327ac19a50f10c9b62d306371b62ee1d05e95fbc06422cd9d3e39ce642a3ff5c7d85d232ce0eb71239b5555ca86c1df25f757bb78968472305ca0e0aa806c9ae77363afb78abb22464cb84e7b18834025c3de96629c9c55ceda743a0c202b37e87b136955e13884d1060a21f0061f45805b28d4a19e93e9433eb482785b1f8cfe835f8fad2d97bb8eddd5b7543a83fc6397425a340ad42a4b59a441a73d4f2197147e957b30de17d124a7454abf476c349baa550ead7cf999eac713f9f209da7cbb42af383a44c39401a5dcbdf91303a53fca85094c85a080321539951afe6cc6c93c972ad8d14e4633cbaaea092185d4b7973c5c81681f8d6f099db337516df2ab65ad269819b9dc12eba86ea1edcff6f8a4b0b630f23a4fc16e880797dd79994717830a504cdb2d9ef239520f7f2bbb41c64ba270c9c5711b93e0b50ca31fdf8b6fb3e99d89733f42c97002daa456cc95f3062c3942438ea69f6215b1a2c9a9ede7a0d45d3363a035d510491ed5f94a3fd91b9e7fc6b8ae99063a58e7c5de24d179b6b489cf5d4816cf45ac5a3b728633e0fb80294451a689ea2e51170a8b0b196267eb569ea2798648d78427e44d03932ecdb58906ba5e6eee411293079255e37231f77577c87cecaae458631c2ccbece7ed72bea278dc5ea598ba418109cb90efa0e3ee1cad2648b7d0e8d972e8b94956d772d761507ffcae126794069778951a7e7aed6eb2823573fd411da656ce52c8d7d645a31ab111bc2751f4451a5b4872961c34dbdd545932f94b210a9c173fa75a3aeadd9ad13075ec5da2a8a15fef5c7875069f18123d11d7b7fe55d0dc98c7d96b5399c94608e4072e2c9ab77a369894276f3fb1202598ebd2af29cd0db206e602773674c04b409889aa1e19482b5d0ce5ce7d782cdc2dd712d517c55ca39d3d7208f83f9f789ab9888a741acc309435d5c066d7d12f13f95a265c3874de81d0917bffc2462da903a913512b5d1e40f4a8d7dd1b521e6ab25e565fb7449f57f812b3a3b516d4e017a27e78bdf6b13024989cd6a03a479d35e8aca27b3ede4ed2867d26f49560f38c728b66620c44e2d3a90654946a8745e414cafe4ebdcab22e6ed4e2d6696819b82f889ada65f5ea48e4037a700d9a6e8baaa78fca42e293bcdae70b183d7ff660cfe96a2344ebc842af1d82e0c6014913a00a709fe9fdf6c411da2b13a3ab57757ae63f87fdd484f005e27212a13e7ebe954b88548243f6ead13347bcaa9a06a98463fd172a41b7b4994998b0c7385fc27b51e95f938c067f59d5c9b37db9ce3ae903f5378f4e1217fa8b5af485d5f66604b5e3ff8a22bf14d9dcb1983c4f0083a3cc7fbdc89d98c94f1cf87ad4c8b5445f0c93c81d6b80bd257ef09f41affa041b81922d71516c238d7a033c7e7635b573c3da416253c5358bb116ade7bf3d9f388b8ff873a0365e270a445a5e0dbd8631a4f94665c2ac47c60799f1b4a74845282d8415bb7018f74a1a331f61d5910518b3ffeea386310c1d818993af305d4134d7f0a762521d29ae6d820d42818df6f40317b5cbe9277bfab9f4199f3befd19d3ff301d8b826a31053e014b736cab51bdb8e8eeb596216e07dca5fd8453389eb041b3a2fb03d99e02a3896792a09c04f38a08f4ea781d80968980f647c136dd4385fbe61b137b49192818219dacd16a3ae9fc6bedb73337caab064f12d24e7b3365a571d245696aba44e4dabad8c1a62bcda85692a632abf04ff86210b7dc7a95f3e027719da588c176cfef7db3ddaac6a2a40433206cd803175fa1efe7dc11443df4a91dc45457630e2cb8a97295d87652f80c126482259c2af1d2e1803d502319bece4ae99fe80fa8240cddc04e72c97aa6a2f9b9da3bca60341cf798f9e769f7f4b7d741417ff61a31117001e2351997a3addff7ed220dcfa839845f8f452eb558ecc5d7fe1d3e901c2210afb23741766de288c2117af8418bf6f094e7f041cccd6d45388c7b5154a073f671c8f7945917b032c7b0419b8bc7a16d5a94674f4cb2c2dba4969c5d0a38dd210f15dfcf10ac0642549471f00adee6a4bbdfcbe92afc9d1479831bde8303515022651108820616378248bf7d03eeff29122b2b1a127d8115f757410266be8a5652d03677507100b2b5173a9106d00d93dbf9482e727893690bb601452e3b55a014dc5239c632962c9c1e158c6fce86a17f351ab928b3f169fd2095b40b48802dfd0cd043ddedb08c59569c86e01b61f6d9d3ea1b9e7da2243ad73c2e6eb5175688ef191261b91a5be27ef71aa79e892b4189c5ad2d04c8bb9176260b242c80731f5a7d9081969f8cfe91665b909b42744e5843a4cc6230da230c1b757bce15fc5163eaffbdf5457147fcc8d66d4cb786a1c91c59fd610c945cb800d3cc2d81ac33c12069b726042e713b6d0fe085c8753c17c33607206c5d08b0e9d5115514c4b8a6b73793f4901713d9a3c4740d2e481f6df99df1e4f0b3e85284596a98a2dcb56e6e07f12b901b18624a27f22eb1e39040f50bb2002fa270e778a06eb6f5ce0f39a9e48f8dd767fa30c48b0d4ce50f4321a2d489a70d407ca160d34b42f532e1c3a9fdecb24e2a07959d39b6533a59ac88b9c873ef101d66cbe04839f2aa91da5ce8bfd92d64950b0e2ca87a7bef185cb67e8cd716a9dad47a90b636d1794d22f2a66633c567684a1a67df70cb9323349763edee3e72db22b3081920b46e3323dc1829d5bc0f5195cbe32eade7138f8ce40b7528f2569ee8022ff15207a5028497ab35b9c26df252b96e183f0545c3fbd0655172dcfbd2afe30242a7ea649851f32c12ba6d545f980eb8958b5c42859111803b18e5249630842a9c488c7c16e8755fc95c0f5b02385c350c99314be245dc81f3eb0c5d13afd8342c9dabfe9fbd2ca036d72e97ca61fdc30684513ea61670985c2fda3a1914c5b6e0e04789bd5642945bccb378b4f1205f8f3af644bc370263c8b5dbb77a660474583ac2cb4a77cafb701dd36b7392c80df6f6dc2b6847f115e160391de90da9c4e7c7349a396ed39bdc2fffacf645b549e0455277168bc2029cfe9c30405783b493d2dfad39ee60199a08f657e99e6b32c3b514bb4abd880a2f7edb84fcf748793cc2073ff0d67794352deddd16841c009f77d756dedbe532d76dadd56639ecace2861eee995bb8ffe4201253a1bad8a5d43bc765fadb384d4513c849f33e08cfd35ac48495c1677f5bc372f2d628d5aecf1367db857d8afcb3a16465ad6cf2a18d59ec07bf5a3faf5fae9b4f8b242f2b5a778a7e0475971fac43e48bb920cd7819e53fd25329a50ba6bc16e6a11f539eaaee7ee3ceed63c5cfd5bff51ccbcaed1d09f95233d63b72e6c3691f6dce40a7ad2103d100b45ac65664e81905744f3f3671be190353cfc825505146a978af5dcc3d1507bdec38105b8e57e65490ccfb861ca48656e2b8fa4f095726b5bf73acdbdf79bd8a756aa228640264a030ef204001fb021ad9e4594bd345b2d4237054e030a6290f0f140870073b48eb626f1202157babaf0955216e577db0f29aece343110b84701f8592d3c5753d12ed0994c9bac05a3416dd0d60d5b40607aed62bbb92b1c8d03ab5888298a0683804c15d1cb357ba6f53736cca0ede4788de03c3c8648c8ff06a984d01c90cad19047a1e25c8a5610d303a7c448d0c00f370ecf0960aa02216583f4667c76bb0a7da9c6c7ec6dd6e272f24495725a9189c127cd68586cb565eeba7b3df8aebb5a2c45b94e61443af42989c9d727e830b1ace3dd57b5c2f23c810f8c2891511d4cae08c234b01cb3cfeb92fa2dd8ae6539a75defec4a5353fb61ef1983f5b7298241986ddf6a1660ac9420ee6d3ed5f5f54beb31a2fd6b8b0b4a2746ad43ab65f451745ad7f4c1a8e9e32689c3b133ff3c687b307591fb384bb32924976be357a5e1f542c2f3e229ae66bd1d6b6f14c1b2f0ffa92502c5d36e93fc03f19fdca2a7ced9eed15c9e0c4c6f4845eb95493304d2b9e715db98afe640085241d182a5cc7807604723970fbd452f8e124cd209402800a308552862ad7e08a1036e947a1b7bb37ee8b6236dce44940795aa42e6c07fe9fb90fe5fb3ce2e9f033f4ea756391533fd9c354687a63322979f62b9db2061572c1eca73f987c1a8312c05259bcb4d7d77384853137ba70b87cf5194c0cd6cf62d51d9bef1a056ed5be403d2b82ba12d6ba0d99d93aec510b566525f189ec9f8b41e8e6e71449643ae81944f58ac1ddd701f4b2771d729073c0268ebbe33a364f6961fee6cffc08ceef6c2778e4e1124a5299d672a2a531ff7889eff03cc0cdf96e7777448ce9cff7da2be32d9587bc0e3120ca264c6e73b09c8b28b0c9fa7c2b3edde8b7e6055ddefd703f888856cdfb78f4ed164a6af6d453e8db8325a726e3c6e99c8f107586c79f63a3dcb8a7f6030aa227431cc7ae79351ec6263a00e7c3624a8c51077329a292c714dbe7e486ba6b12acbd64c11f7ac3f5fbcafc8d72bc009963a9ca1d8a0e1c383cba5afdf364c3bfbbe5e62a93a46bf9796cf03d763458ebf8de4e019c6fe25659ce7c954ad744b29a77818aca3dd350e340572d775e195601c47342494acbec2e099c9f881729d8827cd39076470cde59e7d366a155fd10d66055c7408593402ca5fc3645b11306e91a279a43745e79c3d6dda4d8654d9f3e3dc2f864a4a55c3c529332d91bd4602732c3d84907094d9a53909cc7bbf16367d8d16977652a7daeefde162459a4d17faa92930f4a85e5fd4171a4f7eac132814cb45b1943ce445974e3982bb7f46551ab2dce536cb676515a90dcc432fe2de61f1df9106d1d94de3c0cdad3da2cce9ffe2a75c25bd1de014708690890185a15c10c385dff3064a18a51d7915a53949d2b89c9aab71ff3af532eb1e402da37c3ba16f15d0595975fb15535dbdc88e76f53210be42fd2f10dc0c462ea706b526fc5c70ca45ffc9561d06e493b47c60b3c5a8e7af38f4d3f3d7eb5dee478ba7eb2b27c24bc3242dbecfbd408742047aa812774fd4e4d42fb6a71ef0b45b1e2b9fbb1e1ed825d8f39a15c026dca37b7784472bfcaa90fc797906bab8682b64ad2831bff3f4561c88f14d92611f17a7289338cdbf5ddc98abbaf39ec34579602b6fba33fe4e9047f53c31c19b5d0587291a797873119d09c6410bc8bd72f242c3db47acf316cb96be614715da0c98a3bca171d275df8401cb433b6c408e5ca615858fbe6daf99c24f03decc23722c06282c6383efd8611ef1e7902331d22475ec457d95d344c30801b089a1b896809a5ed3dd84f33f895c4334b5ef507e08b0a5d96b4b3e01e8c97353d1a600a64e686b92a022132a85a7c57b9554b16b49983bfbf9caa9074d10f9c46e4bd095109494459368a66a444ab5213c3bd96bb6f4d14da64b1779aea96f9d37b1c4974f83ef8471ebc91740c8d0c8a082b76bcf62d4f7420ba5d0d086ed74129e8ce42993879416353d327c4272b359b478402487b703e10d47e8ca79e36ad565a1f8d5b41a990d1a90aacda2539b2ba74231eaff05ca6abd52e013b5d808cb3da2a1b45a5ede275c5870c7bf653f6ddc8e4b8c7488051ffa0edfa7f2b8465b0f9d91f7798e45291b598b5acec6e48eeb3f2fc9d009473ce15cdaac47cfc9948637f3907dd61db53481910fe2e020543f23f917d15187b6ee8d62445b68a65b7a83557aa5e47784d58164a19d2b6734d5752378202cc69fd17b2c77b5268b6ce39de4f2458fc3d3a8feca68cebb6c61ee5e0048aa8bdafa7cf7fe805c792567fbe59ce64d167baaa331c99b28d6461ecf1ef83503dff997f73dcda94f16e3a281092d6dfd590f98562de47199bfdc6002bd8f3363d25247ad84a8bf6a8c6089701e53738be594b093b905bbbf0fb0d0019fb8d9c5a42f308464240f966c066c51ed0d0f23bb4d8ad5e8af4aa591c852505928ccc95b70534612c5d73b05e10ad197d443c35a5042528cbd12860208150e9c6a47a61d02f59b0c51fa9819d53ed9b47ffd9192cf2858f6c62318f1c1ee7dc98875a7dcaec0f398491dc0ac9ea6c7300401a0c27da02e6c73332add89641b911360dd6be76f01043eef7c34f67b834316b7292c13f7a5da17d339f3f351dd23bed190effba2e27629235d21fd6d47fe54869eb6a0026189900cafdd08878d7f53c6e9df33ed5cb6e10697b1f892f2bef3c60f36f0154913a0dbfb6713555b964ec8cde3fb6d6778203ed15819a175261067902958ed24571154c0d6467c3f4e8c07020dd3e016b8aa7d35cacb75884eae24899e551e69ae7b9bbb068ccc8342a2bdf2e0e3e2302d33efce6e075fcc155165045463681508399d4fb13502107eb7a142b7d8bf0a282537d901e67b597da12ea5c52b1ebf6e8e52d88aa4f09b3fc951d490b9d187750703b4b8a714a02cfa5499b17bc13bda4d79f1ee497ec65e1aa6bfd4a081131030c4591b2830b08ad05c89167c7be9be470d714c31f4bfba57dbec719e439a0bac0eb7b982e246be666904c6eff022c63a5b7aa58b48709beb163412d89b87f3bc106f6bfc760c1dbb1e5f2684754c99f918469e6d285779b22835b8225ca4480759a87dd143d4dc8239052c12a915423aac510192d56da09306ac3199d4882b7ce9799a1c84fd60e28d137229507e4dbf3b0cf6cb26d6cc26c6eea967eafc8b08a7e4035addb8c133d023264aa867912ffbd60e750140e9cd3cbfc4dd4d35cbef923915d0f94ad7df6d07952bd902ae0443ce01d7c25bfda8a78c04aa7fa4f5e33f1b4c8f987ebf2129457db21d549768132a6db4e2780c52fde78151132ecc23576eeccee64ba5f5bca6db37cd25d73ef0c0b402fea5f5cebc9857790c06bef0821a5136acc109b39c16cd2924f5346805d83bb2701d969b92e2613ab059bc6fbb2642d71b8239d09dd1e23fc2ea74328d4b810d04c5f09a65b58da98a42db97b6884d3f56917414df5c9a9d1f568e80f86e831e9de506ca1bab3b13fcf16195465579ce96f2057252a37bd24c0aa7704172b8c7b8c9bd4bc3bae84b180a2ba9fda7cb6e10ca9dbdfc3cf8b4feaa68666ff837f87c344806732a87487cb42187f8afa5673609081180e6d107a893f38569d03a5df2e21171f77fb4afd29f934718ff2242dc1c6417fbbddc136429c02de5458fe2edcdbeaab5eb563873a89061ae875c093d991430022b33885ecdd460ed881302acbd0f407423bc115df788a49510fc09127b4f73d8e92e1749d56d984d0f7f41724801f8a8563410cc5e6e4a121acdcd4dfe64c4b8aa1cc16c83a5f79ff4c3ec4a3860d629545de2fc160d12923277c17fe05ce3309784dc9dc927d5f442a0b2c5f98d8f48a3f9155d301fd6de4c945e9f5819785712971c98c88348cda18bc0fdfb7be82d591209563b61539fcfeba07733dc7d6f387243aa1b8fb53140d69a9edd599dfd956aeba4311fefea926ac1638b82e81285468ad5a0653026b1ff240db69cb69e66fdbb87c4ca9377931ac12cb7957d02ca7472bb6084c566cbdc80a8ecf178c2395d056fed9ba5d3b0e92dd7cd3a6ff21f91c8820d0a4436eb675e55a6368261863b14eed902040033fb732063d38c9fbab656b76fa090ea39cd8a464b1ff09290264fd55a975d0602477c3b68e64fb68ea9bd0a7e2e85d68e0373dc670345960951727e23ea6484b841b0613ce59e6801b7b724e43d537844daeacf3ec60d1049030d0d1d88807a35462be0bd30d4f87908bec3547556121d863396e979806c21dff815f2b23fdcd231ffbc40de271ec7f0642cddce3e319b46d6238eaf505070aa29f1ba4c5c3d71575f174d77c1e1395880ca7a002b8332e29e24b6e05a867b841237e6d247b9d7181c9f04e75290f99f877e19cc4521436f3fd9b07fa741adb2638f8ec60f7a5008abf252ba3033539bdd0d5e776a54235427f651b8c36a1d580b3f570257b74513370e8261eeb2e47f62c4cff4ca5820c6fde173e2323827aa5275eca0841c31c8a0c8f4b23bc644cf44dba8b02cfaf65f589ae8426fdd66d1fd7dad19c64c6471e32c73cbbaacdfded2205ef615497d32b85e5824b50ab6cc2dc399eb02bd698c1b8c249cf96b620ad5d019c680ae37733df1353351ee706adf1dcb2a890855235e02014f4819cc99c73e37eb7016088240968b269163c949c475b5f93fdbfbd4c1702eed1eb4bf20891a4f7a891ce6e90ad391e66d82771c51924fe60b318c528998a432749b7c7cf4ef62cf51f88accdb206dde8143b30957e1a826f22e648254db46fd2fcd88e1bf4f6005287c08ef0009185f94762824117547c2b603ea850db7612dce92511e93311a27c7577dd7b5b6ba836f5c00d70fac422c7b29e7866a47861e5ccd9e0294cb1079c1ea67ed29484449b73aff36da7cf0a11a483ac2348cc211e2ccd54cc262512aa4e0be354e6e8b496485f8336fcb20a624651125dac2e26439654557bc60328aeff49b710d96f9afd04b29df41a6d805da8f04a2089094593dc69f80e09ab175ee441730b86617b44593ac26b314cf338d9736f8f9e8839323c609042fa8b07afb5344c57b9997fddb4f79b498e81783a890eeb316ba35fba1b638561e42ebca2049e89ce6f8997501903a409e443b4e526c4f4c5dc7bd84e9cba7142261ab7195183737f80ebdcdd3a5136079644c3a4eb0ca941bd22d771e432a6e83cf97e57f2598ecdc4edb4585d0c11a6614b7b915108f480f9e5724be729d0fa51900ee4815ca88f8abd43c6b12704506c23b1609f4eb5576ad2c8f1333accf9d30477d85dda147d64f0d9674ad49fd92e36b11f3a0f821feea2d509abfd706cb5a01081930d7b8cd3f464c4f7e7da952c5595807f5dbc6db3d5866ea748a772761448461a4d3d59a99b5cde5c007797498282a277da4e66c9147cdd7fe611794fecb1230cf360188119329af6cec71431a01ae01fc41f2510efd82b35c493a67db3be03340d0527aaaa202160f750975cd361b1f7790acfc34b41c17dacd59aa09ca9082e1c11447678e0a9ee436f2756c3b3b68c808e1d68870c2d3a0a6269fe5936aa2fd00626fd1a43b08874f7dc08f7f19af30ee8a755fbc43e83fac7d6c19681137383a33e0f154709631252f78c15f7d4a982a1b29955a9ac5511eae221838aba29a74663d52f884dcb6a0ee1c929862a89c464f94a37050b2ae2d3a03ede2f26708add58d5a478dbadbd9b83f5049b0f9e969593c6ec4f8e16c2ff6ae5cdd97b6974d9d49f09e3b688a3c63894d1c6bdebf947e06561c7e032cec8a1fffeaeb8c3e67b28a0ae304b68bb5ddb5584679465ef0c894e252076250a34960d13f855d52b9403967ad01ae98346a843183daa57581c905dd5c374e41a16b4f86500050d1eaf6c7874bbcb3f70a19584183de8f92ae52111b749c1989ef221284440ea6aaf7ebf12ab988341956f9b4b3a49314b635d7ddfac96fcf63a12feb1ae3474e3dd91f9d15c7126eda5fa18b1151d1762caef2fcd8d6d4e794e51571bb5dbbabca756adbd6750ecac4a53f395a4253237998c1ed2c302ce2d187147a0c9025d72ffd97c3e9ff06e73aad758c88f6274de6850574b7f9423827fa397cbcf62f31f5ca0b337b25827322b87e30f9fcef3a7f0c79e9937021562fe75947c7bc1a9631faa8b2c5f711002780db52d9c4ff9ec7db1edba6cf8705e9019084650c1b21e32a563bd3106a32a0e2a0267227366e3a75fbce634d5a903d105e116de7ac2e07f8ba4c7d6ae7b38a2cd3b02768ad63bd498c20c36dba53228e624f067d262b76c75d6dbea0ff33d07385baced9cdaceb52fe454be5e4756cc3848cbbf60dea04d68753651cde9f3a1e4df5f7dd60ebf7ec1bdea67b9709d989b7410367bf6cdff90e03976a0c581a43fe380201a80f28ce5aa4088461947b36514a5a5ffd7d1098844684119b4613c988387c6cebc8af289856cf32ae21a98fe73685f633aae9e19dbe3779648ae6ee812b517f078c4f68fcc36a693ca410b12f521e5a816494d0287863814416a6f4ba8ec6a96b8a93481e566c583bd43605ae2f598b22f7ff14e797f7690ebe623ca67760f469dc28425ebffb681a1222dfe8b7c973baba6a36b92f85eb0172af021b8a691d82882b71b7be1ac08fe45401daa0505209d1f43b790339bb16860a0750e329c0c5c2b233b18b833daf234adb705e99d57cc904913115006b69af45cdff4852a7b108d2a69f4e7ee1d6b786e3f6d98ceb57611d25eb57dfbac89601affc4cc13e4fbbcd18c23bf106a7ef57ba6b90fa29ed16ded29094b73aefa6ff967e9b4d4a580b49c8233cb7c4258dbdb1ea91cf92bc0c6f257c8a29a88b0b8f1294e3ae42d471d66d8aa1c0f4da34505b13f7b56c10509cf42b9f59f192f141a894886471163522c95d50618fee19d85380c88ec92f398f5d36c84aa12186065bc453ae358b314b4d78a3efe8c2ab2d3b1d8c5c0108a3878c5f259206b88c5bd3219fd99c4fbe2edf472270d1cb98c8fb5d3a8e0ee04075901461a8393af4b95b089507a8a6feeadb50dd5a85e1a8519826ab91b13c408759bab498a944f1053cb57a5f75c8c0d1a7a1761702ad71c743750a6244f9d3a57417a3de29f38141b0a7fb84291bab2a344a85504ee811937d2f5ced10ba88468e0322090e0d12f902b5169fa15f77c488e3bb224d6aeca6795fac5be871ec7096c7441c1a3d6a431ac23c421510792facd3b708298a7425730d11a27992c9d4ada55593c7ba98f8249546927cb8b936834823da05650576bd7a96cfc9bc0387d00d97914027a3cd031af58148a04c5e644ffec47c3ce18f6a5395575b3554770d7b4b94bd7c1ef959d3849d744716eebeced76787a00f0d0253e6c217c36ccf3ffeada607339a148949d6514380934592cca50c33d5e8f9b00e29e0ef67b46c4f5ec5943129f04d114e00311abcf5d2781b4cabc3dd0e518e6f5fe9a280c972eb2616f7ab4ae52cd89831b4d166da2b9dd119735af7b9b7007f82b3646faa2ca00de16f9c4c008500b90d31f8fb37a762876164ca15812d8e4abf8424d619542cb878a4ddc7c161835c13a63c293be054f271ed3ebb134838c80ead210f48b2a96940ec887cd01ca4565cda3ce6bdcfa5f0da34bf67eea2205271e33c876c1271eb87aeee9dac4b9f4abebaf1949eaed2af0a16b02cc4194b1a516e4e1142390bbdbc8d03663317570c4ed8cd0af49055024409f0ec27ca6321fc80f6c9c8edaf59b872f8fd1c27597c19dc62fbdf5b8dae44146dc4e3d8b52dc41c2006cfa12cf1c0bdffc570d3b633ffd1b65f02e822b547d5238c57ce071ece0d584b0639019cfc313625f331f2bf9dd517803bd64a0127b98f0cd420d8089df085517f1c971fc878a1cc7723c986c856da466b5ce3e54af26f97fd2655c727c257c23d0a0633cc47756bee99c134c9153509ef010dd15735edd3ecab4e388c234fefd6af6684ee800d165108aeb11425b977ca8cb095089d2a5c51db9f9441dd9da6b58b72676c5853775d9b99b2e7c321a2c70cf9cbe080546ffdfb76eec2d138b9b1ce3c17fd8aecb38879ac874f09ee8fa72383f2aff9428c3a0a5069be0cb3a35a06d29b10d8f72cc87fb28af7dfb1a8364ebb0ae03cbf853752987494e2e0ed7f9f0082694fba9666e8fd2f8f4e1bfc6fe4d86a2cb6516dbc0a51e8754834af337b0e142c495b5cbdba4a8173117b54c1c1febc6830785f9341ca583697ed0f6d1ed16c35cafa3b168b7da63312662d14713e3cc12ce78dd7b57c6c1fb969f60a3939b3f643983996e4b497ff88ce6e028413fa58030ad3dca33b3279284a5f1a67f006bcd75a6d8ea266b97e1e6c7366e71888b0624f4885a4c1d444e511184cad1945398bec5e9d19cebd764c7efa24e586963697d9d6b1ab13d30def8b198c3fca2fef2978b3602053b46ae6707f5f80a4578237064d7a71462a7a8ec6ebe170e31cf1645d2ec7a6d3a3587d6266f84ea936cd1427458b5381a84049f7ab70c7d996f2fe73656351fd1a76dc2bc36507944f680927da80ca26e018f9845b15086e78c4fc6e1373700596a79ffb910502a35260f66c5e217b1531fd509f7dab8a2a9b94a4bf64660793bfdd425c8a279ecb8b1ca4e3b254dac004023829a95d2b52f0fc2d7c554c4d9b9770e2fd10b239393260dfa72a91f31dc7f3ff6714b557f4c06b95d12c7a0e4263b9640e6aa50ba1f00dfa4056396b80882d7387f8c572fdcb6678dc3ee0540b8260e2593ddfe12fe2107b27b6467ca4f818edafe3d04d8c303690b38e13dc00b979b1fc3e5129254dd13ce8be99893d82e564d3e9147e19c2cd2bd93ed50eb08e93c237ffa39c74944d3772976601a86f03d270668a9d61fec43815c4d5a253b684f00249d97194c4f75acc8d4b9093676d6238761cd6279536e0067de7fb078f00b21363e5fa28c44191e55ea9fddfcb47db3f9fda01625c419a3fd8ddf76fe8c07f0fb5764bc178a427f6141db73a16da68b20e90a2f2c1712a15c6b856f125bbb7b5a38015c643a4b50449f16bb791b1276be08115c4f1addf3502fe5fce96789cc2349fa3b2e066da71912775e24115a0821312b348ffffbce39aea34fee15cdaf926bc6a37f295c1b2e7eabc60e650368fa92cbb3713a4305c03e00a95916fff0b425b0a7a60ad3edc3e2c18d36d50cf31bb3c0798d8bbffbf86d840de3eaf46020548ab5bc1bf9714358216d96fbef89929191637f984063fa51f98a7dce988f31f28923e0e49746e0e89396ebeb2bd3d075c7b19e2537fc0cf3dcea10b51a28bff045145a0c64f9bd12aeea474f109421c38e206893d35b51529d96089f2160be69fab3aae559ee60c0f2f98431de488bc58ecb36ff7f796e309f388fcbebefef61c57f08afb608c99acd1e25f75b705d078534af2f20e523005487632a66c99df49e66de080749ed4fed977d619825fb80226eee65875ce1d0e07871afc9f1e336f0aa83c94c6d628678f914685a19d3acc7b12cba9b0299f988d0611c5a8e2d3949d9c5486d1ec1ac94f27fa4247bf87b3526028933de27c5f380300d44e7f7d57d17790c0e3dd0a7e9f16862c1a260e43de3b9cbfccae0a8b6401a0972688b9ebe051bd96800fef96872638ed01af53177aed89c9ad13b81f93c1db1d5e5a354f6660fe10800027240f1df28469a57c2c8eb9ceacdfe708ccd8cf869b7885a762704c198591b81234a399c5cd9906b08552c92d926c0e6a20af0060aba7a9ec1c3396d7b9672ce59297c1dcc0540add80aa212a5ba7292a73d09b828804af3c14633ff55a953912478c7e23e8605d5de7bf025e89dcc8275c341fa9e2ecc1d0a0fab5160b8d11357141e8fdebfa4caf16ed1c7373d9a7245f3fdcccc2c38309bc48b97cf184c76c6fd19018e642b856d36a98274eb943380551d65ac1e8e2952c1fa9438b5ef800a372267d1079d4b3ddd30737af08e316ae82b9267fd5341419c65146c41fc4f30f24f56b9701e014dea859e15d68925e2d87e942e4fd5845eb9c289ffaedbaa288ba112e9043b2a34f97175acc13698187ebeecb26d0082121d4949bc114c89c4b297a27787b2ae55905b12517d2032a6179e1db602ea2812bbe0f9babf815a46173aa517ac937940362024dd34016fee6f4c2af09859b3fe577b3ea883583603693addd24f2965d2477d64057edc843ebebcc59b8a1d9c67f08934687391b1c7c651bab5e6c2d0d2168b21c6f1e51ae5065c570bbc053e2f56a9816cb1adcff0cde9e75d8945ef9f0c66c9cbda5da1fb88988915d141ae63a8f9d7f15d868e8cd5844cfa2ec1462726ed6ee35049dc88ec66e5b5a1facccdb7ebe669c6fdadd90922b6417bb2c76f8c293adc9674ef62b144ab1e9c226d3fd7aa95a3f9452d859678b2eefc967222a06addf9a55914ed2595f04cb1c617be2c6c179907f71ba8b95f81d207fe071cccabbe35934ee3eaf5682d8cf257b834a2b9c9d0088472745f2ec9394b9901d38ead11b350cdbe9bafdd0b544ba9bd218116299ee68842dfcbe3486af14837283a2f14af6ca4ebca8b6145f22aa952f9619dc3bd777d6240223e2103e23a73be93626dd3d422f99759039d65860520c6e27ace49786fa5a62b9207af5bb3d77ecda046fe3e590a12ca6ba55c430a7d38e12f81973dab62276b28450d252e5b1826071b1ffe8d39e052c0df9a6b2b08bd058a8253ea407d2fc44a44c35258924cea552efb5ab9e222d0ffd25c12c2047e18b78347549ee12a5a4bfae26774f50aee8748391cebbe76ec2478fbf9b824e3c3646e547b8436a038cd9c46c21f6e9ccdb510dc74c5cdece095248fc1ac71dd336a4ef3ee16ac2c2e659bc76f1f4697de934c0a1dbae3780f7e81ef68e6e4077d95fee4189320150cf74a2fecb718358d59805f770bb127c41379d62e20a63de07bd79df2561e5ff368773e652838936ba15b824bb09c38d797095997302bbfcf5de81a98cdffd8f87e2e397a8f6fff164410275864c238336d315f3d16365e337b3e8d21638807f73ab020f7c720e8f683e19063a6387dfb036a9869f14e0baccc938c1aa51779d3ab40d7e622ceb5b990b28ead142111e1e993e35fa83d5242088e8d2b817427745650b79f6839c2bc544051c51ca6993c6aedba28e6e7cc0a5fa85d38be4fccc48ddc76d67bf6b41996d7b779ad76e8333877479cc5a77bd227606822fd3feb637bb5e8ab355c25e375fda293cb69776ddedb4e18e47b3f73104af67928078330484badb6f066f0db2bf3c03a5c4f52c1dcdcd535b741b3b5c4df3137edb409522b97d4f8dbcf07adce9e5eacbdff62d73499dd79262246f3e5c6b27e648902b00342339c3ffaca6694f60fcba9e7e6f0f6288a755b12e7a1be27a69eb0685eae2382f19be9124145e7c92009f776090ab9e015fcf4b8b146e275ae5b25df39c042ac72a05b3a579c29553c4d7e89f205c79a0dbc0d4e2276786919845db6b76295b1c1e7e041377c7acf138a2c8cd535860a99c46933d732d1a58ecdcaccdb95a17ba66090a86cd7039a122eef163e0dfe83d58c60a324123b5770081ab0dee01a35f3731fcdd259e25517883e4d0c77b757fb5a2835e256db462b2e5440eff4179501a73aad43c7d6cd413c955ee09bacfcbc76ab663a43d75b443b771a9de04772d51a74fcbe077bfc63ca71b8f0557c6f7aaa0850b6afac50d7e2307954ddb4e0e39b82c3b87adfc30c928d518b93118ad6bd3fe870b694b46e6047561f9a57ad674bd98cb1bcad86a16af1294e5600884b9463d10d52e1298289cc8970e944eab88513ee32e1a141019830b46ec88704f8a95bddce3283b0838f595f130fe6181c1af58f179ff158009b904b65d1008487a253ef01a9cc319f169054cb0bedad358dc87e0a5b3e3e2dc0f8c8170533022e058adb0fb8bd9cbcede89798f060e4ed8562ca0c691467a7ca93249109f51205d6885884d4e55a754ea7d251aedc0f5117fb552dec7f27a4b15702008051a0e9c6d1db5a75c59ea7af51a4591f5089b556a03a8a3f7aa1cd82a8f556f4c9510379bd79d021de0e43c316b9e627e825646beffaf3c60816f598ffacf131eb97e664049ba745ff6166c940c7eaf23fb3b1d2eb81e85c76930ed678b725e5716827686c2ae07a2a24b5ffd8923bae9b66a022d2fce5fd8dca5611c39bb1d1b11908fdd6ddac5bce847cad9b17932c32ab3ea5db131ec68ed2b93be9d7c4db4672092a889826a2933000a580f2834aa611702f3fd8a389215138fbd836621485d14f99bd636e1afca606f4f358029dc031574b230abf55f041bb18efa0a850845362e8ef753af2ffec3cd3c5ab3c477611f3973375610b41e869c5007c72c6fae69de0ab631bc2c9cd6528b202b23babfddd018f55d4ef6bc7a66d5b0f37dddc1424766d6d407690bd501c71251d925cf2f17e0e91b353","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
