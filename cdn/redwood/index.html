<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b1a2017d44579408e2628c9592a686945444c4c0d8b77c5b06fee0a45cdbc303f972dd53c5813b251ed48311fd82642371773ea2ea9ed50fc5ff97a0d11de470c471db23cc2ddca883e271c9c3fa54175df7cd650c25f130e944dd17544b628b5738abf52c56fdec830956f9ed6e243a145b64759d280491017527c8af136011194b948b6b0ff704481fa9dddaacdf96fbdaa48518000d4a04ec2f7aceb8076c044bac83fee67e3b20704afe795fdabe3c917fd977faae5e275ef59727cebb1b4758c26b0caf87eb4517ff331b0b849cdfe084ca1c2add5d291ca8354fb09e6491251693e36bccf41539d6fb1b9cd02f0a308f82cc80c1f072db1edd207ad95efb90c37891246668ea9fce9424c607135fc7b0ebddb9ad0a221b68f95f4674c49802039032ef9f1e4c177685e26934af392dc388c766f2bdc0b8d13b8f4c2af06e8aaf949ca3e4d6e0e5e666806d27864a1d41d29f36142c3fdf5cc414c75b16d58006992dfe5895bab407fab5aea0c4888f456b20308f8f354b46697d5f7f321ff1f0d405d033bfe57c0de78ada9f18c748dda36fec3abfcf524b7901ff2d403245c0a2e9dd5caf74b7730128d262608ae600db77fa943f10287f40b050156817dc8179d9a29f5646dfe8b863295c532309d8793b02c6dc4ca82f05346253126e48affbfa94eaee63e84e605e83d8671443d1526181f380c31af4960ecb535b664ed0a777bd1bfd1c99e3a8beb98662b32d8318b3bcd89c86d104cce4d90409e0ac48e06103d9dbd3c03132d2f1ace0b09482940e757ba9a15fe47660c5ae3ce46cab798fbc73e1e63e1ffd673fe0cc4fa54377e384295aa0ef8a9c772009b37e1ed5ec7070bac28b33cfddd586688c9cea549d612143477be24f6e5d97122f3947aac56aca48248df16086beaa8d10bc7478b7f3dd0e2dabb6271ece63d48a9ec36b60978c88722fd1edc47b6c0874eb1c00513e3132b5f5e1e9f5e15cec6832edc4aa3fc05919526bb9c7d0171f34283ac16f4b442ac67f29b7acc82c88a8c0011f7eba6dc73307a1a80e325469dfe0fb5f52a5f032d87dfe2089d034c057f654d1ac38aacbf980794d19680fa84d89c70c007b8f1b65d3fede5ba0611174a75ff2f6edccc4b41159caa603eb07ef953a39c46d4daf2f2ea50a920dac17742a7500f1703fe434156180ff15dc9e7f3ad3051ec62c3586f9ccf9dbf5b643ef61112cb22aa9f11a9f6d50a1e6c11c4ac8743f5f73324326db2a514c276b7bebd870801aecaf12eb6782908c08a1ddc0df5d5c8afb55ed4732d33337a2b4a19d61060dfba4808c72637daf17a70c79b812e31e4ea76de7d5e7a617fbdde133eec17ada2c3b67dcbd23a412817cd34a9c85eac8e01e64f667bdf5107d4fb95a1b30f7e1520248d43edf0d40eba051c79ac23bdfc615f31ce1057a9068c35ff711bdc6349188cdd9ed590a2ff3e994a90e4b1d47ce1f97f0532be9c212426d97ed7e0c26d32f2c72f7902a5b92dee35257d160a923e8b5ea91c2a94b1df603e6052bd6e11400ea5b18655f6626a6d30319943350477fe91bdfa3ef163e875ded777cb356fdbe45ac8ca2317f39b9356578f92cce6f25d64e2d76718d0c2ed730d7ebf2dd96129b516ad45329897d36500c9458fa9da325e7015e5eca36e3cb10e3fe592bbd610b666a82ec03b5480baa6128b4e7913175daa1c4895a1228d78b4c5d6c2d3a29a5860efc6e077400a49678dde82dce1fee6b3a0fbfeb2b71310ba49f4d5ef367743685dfbe3a1705efaff2a77d010cc8f42bad2f0e3eb797100a51bcab888bdb18cf8d219b3d46f08f6e5083bd0876e307adae551ccb65de8f5e8e4d96ad03cb7e811cacf48a4cc3b07229ace72f28dd83ec82376da7c91d04467b6b6a4856c5d04ff7c1d1421de8748fd554cb100328b0267d4a24a228b8b18ff022bb5756f1586db574cb0996b11d84596df63ac9834ea0c6a18687b93448195bd3009fb7a6f64508cf4245726a832c989f97b40cc8b7d93b119b881ba5a4bc240c792f48f9d44840997f77b3f812f0e1d4e1627e63d06c38e48d10b9049f3b44a655db0022d95301f9df678696ddd6fe5d9c3ea198f11d398df8533b20d5184b8488d47bfe95f77c8c9b9a78bfb01809ccb839e434c61afc3af5d45c2d81be8ccea71744f5b4c255ad7b10ba76c52620d7873f3c19415432cc4f918e2807a7b377d943daa9f3057013ffac518897a235b3808e92ee132b42a070c6d8c1d38058324495a86207f8d1737fc504d31ddf6cf523ae9c2b042fa6d51432a6ed6790e994257061869ad593b8cce13a1502f608239922ab131235ca18f1db78c200a5b7c5ef528228140e8fa23175259ebba2928a3d46f60b428072b9fce96af7ad52646fb9c078a3d7748d52a0f4f4774fb53224335d5ce46ba5fee0ad346b9e72dc5bbaec3f0cc5a2754871838be8bc55681eccb8b93e9496ef182e273a91d9b920c82ed0ea0856db4ae5e64ce61eb525c5d4b4b9da36d34a405e76669239f7b99d8bc702607b97725c806519602cb6abaa0d14e145272b38c0ba3a5f35c88bf6cb63b0c9667b1f107bb7b0485e3e0d7e7c5e8332434f2bec9dc5b41bc87d1ef81b088203b045cec753a0de046a62d12613612bdbf30477d093b6aba4171a15e3e1124aaf2b75d85d9c72326783152f3962e047b189ecb335cfb1cca5843f58b5425193f075b38a53fd6303c6dc65cfbb238023d3c8e6b3f592855f8d42e88a0ee0e39c879965844103f680e68204cfc35a5555579026da7d686abf23b4d9778cfa2d070bdfca6898a388c67ffb9ff04cb4ca7f6b01399c08d7fdffd04caa577991baefeea390445f2fa65d2e0eae94f5db929735fecd63eb8ff2de9eefe0a1622a05463ca7996c3c535c1ae09d90830b68e0d83ea3459179c9f7d58a02296a1b03f34f133f90ba69594c58c0f185c89df901df92326300f0d521be04c07639a9e4fadb6c0a4d0232d89799ae13c46ec46dd248fc0fbca86cf42be85bb1ee282500a4c01c9c32a06c2040f399768e5ab5e8c1a6217a418d1b16d0c87e5a587210b52b130462062088e9182c815cf9085a24adc84e6483bea765dc6ce4d7c8f0edfe9308e5129a29667152fcca15308841b8edc00ee65003f4f75f30944cba23c2cd7d6da220d034744de2f6c3837a1d2089a5f585b9f1498ef2b4c818dd59b3334eba5f475f7ef7402b23ccf46d12bdf5345784ec8670bdfa2319f7602e29d13f634b1d0c5827468af6e43ab085d673f84ad2902254dc90499a951e74b8d698a111bc95f9e25f2f816c77853021c737b0535c1e2fe1eedaa28aad9e2d66a3a21b27ca09336aba947834d59a0c0c90b86ba3ddfd3081b0292e8a3dd66c2054fcd510316f62dc1fab5b314a5fd93755cbfe43aca78abe3b4365a3a8162849bb7c3c8487b826ef1df095d481fb2382e430b0defc6ced5900c955cf502c7ba4b2f346ccdafabffde1dbd96ed66da2bca19975a030360b046144188a0e4a6b90bc94add44ea735dcb0499e0300f94e55f83c81d36c473a18ad37d6193ad71caf52675145a8b801095c40167c7355cab2a1e311a777c896cd0f0545f2a9b673d700772c06d38a1683d0fefc07d6bc69c576260be98ab2866772c130110783aec5f986cce5abb2845e3b076b30378be1bfd139a5d429b954c148ca0de3365d97d95ef07011f2f098e1d78156654ab2d5c92015a310b243889f6139238de4b6391c38e42359a6e0767b754f1b7d39aa924b8c7a7514e13062c11fb9c9dda1aab3f8a28753866c548062b5b0aa1fcad9d3d87aac53fc9f2ed2ab6e5d45a5e5ae1c43588b5d70ba5cda45419a99138b4e147af8f0384e0ee4e42d8c0328aad7b5f191a03e1fd522dc0351d8029caa902e7e76711a64f9d72f8bd2a15e09a1feb4789609ea484997e97d7e1a388f681a84a32204951002733f4d6bb816cd04b7f94d7edc2c1d3222a26dae61f62f1bac5c0354ddbd4aeacfcde52f4969eda7082b8b9f585ac362fb65039eaa31a6ed02d35af6eab062785af7500dc51c11bdb39bfecde8b8136a4e26e42d05ad3c954d121f4975cfa1889d5bdd2444631e4aee72c6e783f7f378bfa9da8d51b0e645503294a5d2ade24605b5de19af931ed9a667801f251b85261a7af24dfabd4cba4ec7c1c6342186a336c038af485709a716f06e98f9eafb87ee0f04f8e7e1f6e55a9b7dcb66f2feca22bf04349bd2287b1da4266532e8cd700c33acc4a3aee22e77cc89c76c58a7826c0aabea2d2cf0fd60d66d5e5bac9bb8d23710ba6dd1f1f563a83f80f1fef8ce9e1b524f0564d185c16113ba43be50685696e1b109094f8fddc1131fc7239c757ad78b78099c0817abb6d83a7e3c37331820b00f5bb8592104c7a5da92519c3b27b72bd5e68b7544a6f017f490a18a48b10d8cb7368f11134ea8cd439e641310094cb4edb47c62fb28030b0380bbc1251fbebcf55ac12e9de8124403d431af2f0e0e482d4aba0082f5a9f50d37d31034820cc1261a64fd993847780072db7ed69cba13a64caf27697831f2f18f2bbba1a917546c2a80723d22e72b8c95fbc6e5c09b42cc63f93ec7d3d7f38801141718410c977f383a2904d4f54704993ec0abdb6a544badcc7efdcd1a896871f9896b22c882af4f7570be97f6c135624993921e39325b86c636218ada5aef33cda8fd43723b7fa140f6c7a638c6b947047d6d09380e7d3537a1b58d09c1a536a20d87edec254e758b434292692ecba2b25d876e4a043cd113ea951214963ed760497901eeda3a274c79608b16387039970fc4313473f25f133d029206bdbe5f1acce46afac8733be57c4a1404950e067d9252bcf137fdd4091f1dce29a4e15c2c7cadc9d305efac966e944677bbc0d1cb5524e6416b782b15d9fe5322d8f3339837548ee600bf3ffedce70490c6b7d45519df7898d299f8dac72957a36d62c23352d584a61db025e8f924a291ec512d0e6874fd5e0fe44820e23ccb0cb3ee37ce64e53c726159756920d031b2a2cdb685c58c5586d6f89cc7e993d35ae7e2dbb6bd7f5d449fe2d2addb51a763511a47721cf6be12b0df4e50f071d301088e71da45c5bd8df332adb283706663b6d59daaedba88fb8c8131f8a4993b825df50e4d4360ed1032cc0335c61927dc84bf1806933a761815efcf631343437d6d459625b2d41b81e5344c1fa317122ef0136b326e6ff03d35bbaea6221ef715cc1d89db4c82ba1c2f0c8fa029a660d28a5ac8f33646cb49c729a9c99180072002f4c8b1091396950824e284878febafe3916f28445ea7649635f0a8e59badee79f43b4282ba3a48f0795fc11deb31117d5df305906112efee6efd2416a09a48e3ecefecccb772b6297fcd4510b430dadd3bde3004ef19d7e36005158c1582d6a30cdc7fddfde991c17bff40461836f0621055ae687e7aed04b78bf7fbf9b1293d945c86d8b2a4861d132972e3419a0deb4cbb34b842036673ceced27a73bc227007e47d5598fe235d1a16cfc7e6e3d049d852feee8e2fdbeb562a8bfca7422173cccf6d0a406f8519ceb00c46e7d36a701252f3ae586620950af840e023a0d2237471be812ed607603edfe79fad7ad98e9304f6c540a5caf9b34aea260d0df34d6fb5c603e54c6f0765b8ac960c2b50c43188db9408ab37b960eeb636ce5c81f662aaa85dea6532536414a614f6fd52ba3fa585b44b733230aadba05f95a097ba1ca82dfdeea3077a642a66611ebfc03dcfc281d47d3c82dab3c7c4ea81a422da2271cda1a7f5267da668cf54cbccb50f105c076eed4dd6c8d1d7858c20e355ca231cbf2488457456931aa3e5de9604296d9eb54f68d50a16e5641c5dabf250c4d65a76bdc6a157ee8ab217f06b0fa6f950e8bf4f93a1563ae284bdd618b7752a11db41313193d30ee140141bcc9d7beb9f93ffd39931af9342368eb54c3862ef1a71dd6d6adb2d31bcf9dfebd75d5f779a47c70624c6e3460f8de6b2049692774f5978b110207e4459504d70cd7d22c9e572efd410f8a47b243f62250c8d9309d6de3cd5c8f84562587117cbfd796edac37b5bdf80f9ed28fe72322370bb4f8dbcaebbb75d4ff07bbd9db14c335d84eaccf60cf116d9fbfe012b5b8ad03d342d6f5a13c960403285a3a1bb0a1aef82b291036ca24c459edba77bfa5c32d8d6614d871a8d9ab85bae7d4e71811205dd735d649cb610a5a7245b98fe6b3d019e9f8ea91818bec1c8924a34596ec59470b1c78406240811c305abd79d80fdf967ac4a95610293aefb84d15f23ccbcae3bac00d771cde4cece689ef8dc75808296a1bcbbbb2042091b852f499320d56c348346ed8a3563fd5c721230474d599718c1a707ff99a3b60a7ef411335425f397828db48553d7dac1ed1fd4f5d140fe517e1631009745bac10cbd85921beab8dfb31243fa21eaec716610ef1f5f5f8c141e84b53c8053ddad19c4ea3202c896063f73d627c69a83b64361acf82646a067170b074b4ce695dc47b147e9ae0ca49683a57561dfa0d0ffe30224144e1698c8fd80e586fa90c0edd9db7b9d2a7d00617b6888ba3c59ee70ec0226bbbe480567054fd3eaab5d0f18a0292d35a44e5a7025b4d5288795b7dea157536092aaf6fa24e7a880ee9d20850c277ae76741d56be6fc4f51f228e790f8ac5f5708cedcb2f152f311b95bde3046afc8d18a3e3b4a6e999e710cbb84048d071fc290cb002144b477bcc8c5eae537d83c9466e13590333230686456b59822a98f7fb56e14f27f310589d79c2f2ee06753782b478722e852965754759cca5ef9a77a250147b2eca15740abdb08de3e601134f5f3735eb700a995cc3416a3f3d11cae839859a315ea2f41bcd9990b8f2ca544ce49fd6e0a2bcb55f2cd7453214a815cc62960015ca146cc12543cc44c8b43a47144893281943e67a5a123311eb70a5ce645868d737f53a336e9c37a468244c14cd6a994c31f3db2ee18ce2542d5d29629489f3d6f2272403858053fb5ec42338911a20f97223d13d490ef1547bc2ef9f4330c615f6821f9a54e5c076cfc43278bd167b6296ac396aba548835048ba1180162fbecda7c2bb7f6b50f930cc046cbf2c12adce4a0253ed444f220c86eb1db1a1f05d34de709eec1108dc7b074f84632ccff8dcc1687efc6c2bc54b954abfd99ef03ee0c040a7ae24edffd4f6f09c6cf6183c2da8e56af35f3950583e7018d2540c2975f9ffb5a6f8dd5ea0365ee6867bb17de29278cf47d879a5ab7319453fe24d1f1c3aec8b6e298cc78145d93340d80b6b8271582b2ae520f3b5fd4a51200478f361a9d1e0448172926b7f28942b2ef562dfc794b80c586c46fb9348d89f2347a4951db2039fa0f5fd022d4fc6a6e24409db3e296aa0938b4cf9367cb07d6474fbe2f3a4dba95fdc2639cc99540dbf8de1fdad308cd23f9c3cbb8de12734d020f148ccc36a5f64f7b126102a69fc9cefb03c53ebf6f482354a6a5321786a872e04f1de26b545bf53f1d86fee0b1951d983053c8a462ed415ec3fe8b5e51c96231a2e2ca556286216047c2384ef09082d71a4e53974946f2e63e29d361e0bb5411fb095e4c115f3e0de2bf991ad4d94728515492aed1ee0d14b4d086245f3653dac81095e22b4f8c350e95a5659698c12338f12fe535f026afe27764188ed2b1ebb9a9a58a4ff4f6b6806dfaf2477e5ed9f8a92491a198fe2dfe6c58fb5b833d0fc3588ebe2526241ffc3eda6e4940bad797fd67069c75009aff2820eebadcc346045833fa4861b077b5a591a7ddd086a6aba03f678fd0399b4df1967c58838223cce3eaa8c6994c2337dfb39bd300a45c56f46704334c76b6732f53ee153ae36d1903470c23e3dfa4e811cf53e786979e12f92ab889f4baaaddd545105730012ab1816dfbb7b46d3dbabf81476dc24de9ab681638a0e29692667d0b49cf9e97762da3b4c49fb0043ec26b86db53343a7ccf3e332502b4660a22f6250f77925555a66981bb10c193a58a03e274e8ceb486cfc53fdc23fb3de177787461035548426da03fee411b28a4a0cc75fa69e08ee630216800378ed73f36469b3219337ccce93a49bc8c411a6304ec1df82b8908907ab97f3eae5b48f8c457c36a69dbe69644b916901af12602e4f06da5d77bac1319f6bb8a9312019c13f0cdfc4da3056df37d94edd814f53313608f09a27d401051639a08b6d329267a32eb73ad7d216563b33de53b81481bf8589228348718545871fd6aa2939da496c314a54926eb209e26364ca860d76402e4a9242f23b54959d9becd50f15c3a71a275398bd7afc1f316cd2ef7de49ca072b23709ec167ef30618254edd41678db5986ea0ff5fa5be5d2a05b1cac8404fb71bd1ef07f8397dfb318d46135af6c2da082754d4e1515933eda19608fca8b415912b40937ff5cd5be9167c03242583e78361b7394c7f557c20293af3171215c0f276a0887f45fa87c34209a41cb86f64a741e8601b16cd66ec792b828867ec5a9269e11d958f21dc6b03a39b49a8ed055e01b4efe5e43ab530e0b6abce803fed427f80613a7cbd8f0647d001eac4128139322c3b1c8ea821ab1886d9b189b5557466c0f3146157d1c9f223a87c0c05851974a3efed6e658dc249647dcc5fbf72b84d30fe2161f47c75b8b4a583233e420031f887100f5b4eaaa240996308fc78889b688a41ee6ca4889bf7cfcf2a6526677c6a70bc0ea794cce848ba63fdbb4eeaa270bf673ab12a420a87adaeb9a5de3304954e67bbadd7d837f0ddd44e31cea7d63b77b02ea89a5640c1f94319da69e7787bba18475531060589d203ec045426d87ec4fedcd195d377187af1719236f5871220e3a3a03b731c8cdcd5802358d2eab88deb2748a6da560fdf28493dd31b1474cefc22375a8442d36ae38581e92bc82c0e82a3a34898f4027e66b37303eaea1e3566bf71ce895cde44be1ea8a333b3702d41edb3fb124262de1b218a791f56f35a231ff84e0f8bb76f9fe9064476645a68ec4160672e2cb33b2c3a5b5ecc7de886116356ce35bfe1bb3531f418be62f2d10d79ce27224028bac962a9e17aaad07078a389ccb52e4f201e99ad1b801bb3771da337b6b66ab27251c6cb241fce24267f45df0da7a19bcab2f860d4f682ffb612183b8cdc05f50159177e51d16f3bf2fb07e165a9291c0fa999452f5a99356890021203971ec3c852c16b4b46e288f7f0281fe546828b4b72fb4048799f0471404eed4f26f47414b4ec5add14d26bcaffed8945cddfb10ec6a1b7270468acd934602548f1473eb11d6214498e5358d8e79f8702060ffb92093f45aa21c944f6e2e806aa177c4838f42cfba8fd04fa811fb471fb9b12b60f6c07b31a617e63f90d4d763bd53cd430d45eb1d32f46963c009a71d7963c5fae9fe2af7324a84bf9511ca0a4e79fc905a97eb4762d59d76c043323c7eefce7515a599f50568419f290150f4d17dde523976564815d926fb8dd2ef73835ebb707234a44c3758c34abfa45f469254241239cc3d456ea4138ab754aa21b5edec3c83dc931bf30b5bfd0c57943c2175eb11e4087979c044a700388ac0099be3f02a60c2aa2b8c6eefcae3a2a0e5c56e204dc1dd3ce7f25891ac24ec6d097f2fd8e5f03565ee9ce2aa28cf211e016c16d5cfe66ac86b48ff789ac618782128992c212c0dc6d7775586c0feaf79c96789544879b997b5daf0f2b2df0ba2847c298025a50ddcecba61c184eee499de3988ee25067b2ade6b4df21ca80fabb080d21f7e0f6dfb1d365a02e15fa99e6892bf8b2f5e1d86ec6b7fd0801237301377f39de79e20fe8f137e2f41f604ab02ad333db2e5a0056ebf2f2cf47a8c3ae14c2f41fc5be6aee4c3d25ae27aa46f88879f80bed7f535d0735179729f464cf0638da3401306bdacaa15e726ceef3fd34facfa313c3f6b0922723f2a29f0554c50b1c5c59798bf74f76bc40d9c28c7c42e9516e50bafb7d30d083bc672d49be8d390aea795860ed5e3390943c92bcf66b18c62e43b3d8198e974367ea287d1dc1fff807a4a931678dd5ee2031fd1d7ae486fff2b8c6638f60fbbc3b498bcc83d03837d2899694991b1d6b65b1f999e174901c2f0e8caca94bed34944bd7a3d29e6f7ad2c32dd7a1a3812d46136824010fb275d9f041b53ae6f2f7c5e2a8d4dea8f64a231e1e7e1cfda4b8e170a90aecbbab6cd37b5b2336ef2b030f36d4317344312f651cc11ba5d2ca88cbf6bf0210d11d5f7b47db7a48177599d658f886d1cfd38ab267f6462bbf37522f79980d2a0719b5ea068a0e17a208e95b388299688e8e5702b110759b1df01621b0b179987063adfb4fc4f4a3a253aab53460654a65fbc0e25ecff5220d0713646255f250506008b89e60f0ff410275402b6ea58ab033eb35640dc9b90321a2e51f6fbbd94cbc40679a18033e94f7ffb5231c48ae8edcc0661aed224490394afe4f55d7f09730d1bdeced8619297bb5c2cbf8eb279271e3628092e87ec3f580bbd96c093ff8f52b26f0cce7aa557ec629faa74817d201134dabcced22251b48f076696fa7d3569836e4913b8dc94c917976bcbbfb5c076ffac65fc830716adddb44fa12f832177fd835a8c8d01e1d75f937e909877099d17a6193f71ac84348c387cf4a222e75338b108f298490a25e25dfacce0491a3c281928da9dd5fdfd0da50f71e1fc0e238b1a6794cfb792f92234775b533ea998014ced878e4d8c09bf285c99574ac8ddb59a1283ff03cd331841019bb15b51da8d647a668cfbff4de6e291c688b8f325c7191b07d7aee301bbcf6242c1ff928465e23cad865efd57fa7cda0a4c507640f19dd6b439a4e2c0ca523963dc30b17632ec846932150a62822b350ceb9bee1ff0553ee85910e36f46d44795018a222ba231c3269b8ee6927e0ccd953ba85638681e7008dce12b4bae139da83330f733f7e109b0aaa637e47e376bd6b583cdbee0ed0a948f5e108b22605b6749699023cf1fbea3ce37c18b529d6d8cb8493f22988ac827ae9fcb3970086a97d43c589c0bcd3d0f2ad126f4a4dcc787524dff04d78236b71b7baf1fff07334c53936730c085d61928840d970e87eaa88aa891c5aca6d292f4bfa87148f63f04575ecc7f342e8ee4df50b10ac0bfffaefccfe266a12ebcb6b334158e6696674df8ee42a3447fda26661bc6eed56eb71068c62d85bd4f8a92eab43a7d2f7e49088b70fbd38e69a4a37a3793604e7cd85242704ae93a17b20e4cf4db8b5452235b64fd8913e10752efd8fbabcf88b354ad56789de19693de60f2fb2450e62294258c6b9c7cbdab9177a71078511f1d454b5ea6ff77d19c002045267977a8687c94cc7e31bdd4993ff3bb2d281a39628ca79edde99fb319293f831bfa60499cbcf605aacea5cb6687198cf6c188e6cab2d1f4c701d296cd20a6299b15ab7ab386ccb29d40a1b616042b28fac9c4e40cf3bd362efb90bc7ba527ae3ff37016590ed350fe5b758086302f46789f094b6c33ab9c7b02e45af8edcc153db07624e51780707e584d1bd7a22b4086a55e7186cfa7612fee5b2668b5c10bf8e53947da4a36dec89458bb5713831b55ced626e5dec29619f00b9a884ef9812e714cf5c5ab57b09627fdffd90b3c8da6e4a153a7fad6c4a8c946a2c9a24b0020233181f42d5b2bf2038ed43209c5a26210d567604472c220b83cebf99a2af58c697ed640b2c76ca3d83d9ea341371fe4d7ba1fa6fde3393163b5a21b3efeab1dbc405c69a4e75f59b639447098d3148f652b3c42c276aa9218e2c63c7f950c23db2f7eac977a8075747a3d07429b26525488758b3681259ba4aa08d0eeba3caaba67057fe22c7ecbe108b6946285a4f57d3124064a84a6bd93143fef4d5109c76ad50c9a41cf42e55ec39ad13d8ef734c03069f136efa578518760ddb5c6e6baea922cff59d25c97d0c18386ca4793b35fa8e1e9d66ae7c3ee9cb42af76b66743e068688313b509cc25d218617c69115ab0ad37176d37fcc573e7522bce66a33feaeb416539ae8b446eaa78f7b41fae925a078b18c05202606b241a4e16c9718814fc9b9ed6209dd26a7e719ef51be4c7bd754ccd6818b0535cc39a87c823ca92d574288dac37675479c8bde6c0af4b112118eb830ea70e3ddd1eb5c0b98a06060a6dbad4ad0e6bd60f72eb6651efe4e5d2c14a3562e5169b39d8d68ff4488bb3b420cbb95e41b51fdcec3e936c453322f5a1cc914892058edeb103b978227a7a5ea03276be8a8c42f1b20def8688e6cdaf0dfd486e962775678ecb1f442fa07cd6e3abc362fbd00e0d6a1fca8b61d36bfb4c94f8646c0a0ff0ac9e432945eea3dc48a3e62c61e425c6240bb8c9250cd1033f94031217bd653c00cdf244ab3107700079a282f5dbcbc7311d2c0aef1f319cca2d2c286174f396bb2ed1c49288574cda38df139b3eb183d497ea7278d47a0693c66b64a0cde78c90f25150dc7b6fce5a128b425ef7be11b8fac0106effdff53b9b19ecf515fb5d085c141231b4312e595a8bd8f70ed51fcd4a8313c34701655f90097896604972be8ab2f15e89086a45bfbddf45bd603ca9fa2961d4435dddcdac6ad44124749ce486bdd659d398459c2d472f6504aeeb4cd328f2a10fd58c723508549d34b25f73a3db92d8733165ed572e8f131a230d8ae9aececaaac47fdcec0d6364ee56b5758362cb3eeb4b2d98f7497d2e5e7b9499924f0e36887c2e171fd9b0bbbda3eeec7a456a51e030536300e37d1d827d75a06ac0d25fb68b5b0652e970ee040d7d05d2e5649d49b233d1263ffe79421c6f487d4cff0772e778e5fbfe3cf94d0a701b702c1df4af8f32797ff674d0783d0af75c9578beebecedc3da5e677569f0f8a46a30e66db5390e132a1d9564e7e37ba27b2bddfaf6160267d3a03407806f7251d1c34593a4b4e5a94045c63d580da265493811d63e5461684824bd91f218b6150ccc4c59b8ecd8363b4f17e8f9b06815e170fc114fb9f97a2802f1a57ab49f915795c42e62f430da1ba325cd36e80c9846824d09e9117a0bdc379f97f3e53de39ab6d4b4fa2000de290a62cd6131d94c658a77260be18cbe3f34bed037447d7a907758b5ac04c76b36c0599c6d15e43ecf64aee59bb55402f98c0166f09434abe63adf347bbdff8e94e6eaf941817182b05c196331e233bbc2679f39da0c2b780460261b1ad7f2766ba051ec77ef269512ff3079a27644f9817b45d249ab8ba9db7b6169365debba354edb19ea80a5d3be50423fdabae7d5439171dfb02fefbe0dd15d3b7d4e429c0a17edfb0ef5a4adcdb170ddf3e80a25ca3e7846154d40c9174cc8fc8d7879219cecd509a6389d7135c54d8da676c3f5172f5ea95ed1001025e50f16890416572b85803962cadad5f65e797b7c31a0a614bfa450b58882be41e1442360b38dcd1bb88efcc822dcd0ff6efdce48aedcb35a7cc3c7dc1c4063e1529c133e99c601134ac4a07fa8f983c85a941d127479b401c9c8454fa24d356e1ca7f559323a4c5cfac185576dc5ff80e3def8bcc3154124a017fa66a02422ca421041ba8c7b34f6e9b03587e1d40349dcb903c2316010120181a68f4ca22016bafa23d449daec7f64690e7f98515ed3d047a1e6c0412dd2e962ba32ac140b9b1d5cfab9f94f462e2d309568c7eff0ebeb54f82239f1084bcc48dd4ff57f8713e53f365727b8075cc0ca4a99e53a1fa17383bf6aa9358a812532a08bdfe5b82a3dc58dd5217eb93cb5e1d73321f02b21e90ec90d430141f3c267efcd49d7f22122e52f294ea3dc81d67c9d9e8ab360fe69225f00fe6e05894af7d3ee8b3a42647896c42ce9c329c2d84cd853c2c2743dd04e9820249e9dfc1389932ca50639218287e960823ceac5ea33b34ef79a7bd4748457c560f3557071640cf8ead507f103891f0b06664c9ceaebe50bee020c28608809f06d9dafb22717a8786484b85004ddb32cbd665df2cbed680ce26e75a6f7a039b108453d3976dc6f187617214c68687d84e6507dfdd58ef5e44fd28a3e4614c0368fb4a4eabe67dbe2261eaa898921071ba578dc518cc8a1dabff99c62efd82df253ebf72c0e074eefe591ade1e66ef057a4c057237a91864cfe6470a31a03cb3b281e7e3536bf5ad8a91908730db4b95978c8fe7d67ebafdc496bf6694c7afd3c81b8763824932a74318c7944146cfd1ca72b0e103f94842eceb163d8d7b0fd106d713a37c26d5cf3abec081951e7a3b705bdf0dd83f5e6cfe41458d124861932aa9dd5ae7d806dd9766e6caa92abd2f220393146a3f0abe2a80c747ed2c9fabcbed26eb711c7e7bd28bd2e5b0412cd46b77cedf7ca6340fc4ca824547f3f91031fe7567cc26c98478ee9f02e392423ff2f3130e90bea1b6b9fa93326c225b3b299cfed6e50e6a3e29d52a8ec0bf2fd28ab947410542ec037a1cbe82fd1f203c641495f8c9e799dc67f62d110ac3db51b2057c8f7f0abb8a8f6315201902b1e8960bd1f7fa13349bfa2e88cf1dc6b769af2d40ff80422a8f56917915988d347eda3cc4af692acd0627f73c2de499f69f45d3f4610904e152835b18b484c5d293e416bb51c64eed9b5f4e67c0a814da1fd687e8a7727875199b729a47c5d8da317324ab922025cfb2bc2fd27fb61cd69d0a68367c4c81ce0d7f0696376bad41bcbdd1a06528b10bf6e765d0dbcfb785401187242cad7e3bb011aefa44bb52853264d93b53de287911691c61eb9bf8624afb6c9e04686c14e1675cdc3f5315f39b7cee2f583d9c8f83d3fee17a326be9eca82486d2a5d5b2c131d4dba2527e82aa9cb5b5b30f225607b5b968677df46db4c04508f0df4c79db3bedfdaf748d1ec3ea0a5a81f859c9ac49bc05db77899a70747084d8cba20e74c6568485cdf1dde06358f68c179a74d5ced5daa61cfd45e8515a7dba379cc2bfc2e73a248d3e0f45bf630a53ea3463e5de3860da510cd829d5b2657aa5c2f90868f4383e05239f786f749559c95111048641789ba11e2be14c1b1ce740babd4fc1b722d35df9a1f15bedff8c7ef096f1262f703939682a3acb627efed12f9c34a2b6386a4def774c299d4258693071c65314257bb1b203623e5186113ffc00e1656ccc2a0514b1a9f6133c17220b77861915d90b1f89f7a7f1ed51d9f06f8a628e2d669565fa89fe1dfa939a3cb9c7bac899642b062e252becdef1e117b2df2db2fc7522f539d128fdf8ea8d8d872ace923e88814ae20a69d21d528dac15d242cb5b71596ad7cb11a6ab3fb62ebf8b6649443c17343512149f06e79b7055571677fd6bbf8d98f5fead0730636a5fa0eed5209e87ff1f9b61b85de6b0b8cfad92918a29d7f01f55b210be710fa5be17f035cce4cf8455a6c586f2c6b9e1a32a8e1792def149a6e9363492a9dce0b4921362ac634b280e24f37a577fbe59fc3bbe6319250249a951f8ea4eade794f50ab9bd2196aeac6af3c09dfd88a94fb2125c7562b6efb4a0755ce913e631bded6ea94b562482728b829e79b69573de8826f682e56b6a561a31b3aedd8895dc85a4bbc3c8f3dc20b8550390fc65731389fcdfea21bb81683a3f1f747b1a11250dd78c810ea96a551f3b35be4e369c0dcb0e307486a69970712c7594df23a07ca5b7c0ac75818b23d5c8d45a5130e486f1d7d7a4c0f20b2078c68016d2331cdb564f55b3c7aaff13d84bfdfee50ce9f5fa23026ba7e8a866fc8a63e3f4d27f2080c3065c4d4f6630901a43030e3f3a76b3e1b6fc0fb2a28a56f7e24ff84be92a4cdb885333cb9f2b8bcd60d8268d857a4b9802a96fb5939aed963d5fb08588edd0ec68efb8aece8c732f6f4b61695a53c7a51a4631fad396cd6543d79cbfd52d04210c6a626c1c0b15fb462fd14a9c8d52c7c1623960298740454c9009507fcff002df1bb814e5da66ea6a5aeda9875a7f77d457067eb72f5c313687da74d367a420773d5c8d1a1c45c65ceeb149dd1381309b80fd616cdb798087da4953683f7487bafe3cf5008ec2bcdd2f17c2839dc1248394a503251daf0ff51dfd430807e4d347da2fa54b4ce5669d713a260116d63149a032af17d4f3b4c52314754ee9b7ef6f1db2b9c80b8fa28a8ab80d7b106d5b366838ea27a7fd43bd861cbc853266befb77818022649a35b875889fcb58830a6594886e6b507c3427d4598ba87c30255f2257646d534e9113385867e1fd5dda08b808e11e4cbe2c9ce0c088c68bec8396b0fc55bd0092161ae4ef03e5793062e4dcc9f45d9586761bc95883a93daaa8105e7c392564264fc37dad5e97f9d7f373931c66d75e517dfc0eab1bf2856dc5764ee5be5a4db12ba07f9612dd1081ae956884d682a2f2a19b361f4ced90b7fc9e36c14ef8984d01cc9dd724ef7ce149379d9b7cf145c02a67175862035172e4fc76c593941fe3fd6dc201e6d5733457b55a5b66580619b1e171b9480d8c46aa66fc8df2039a0407fef4d616c63b046322ac8a12fbbf5ef8d0ba2597d9ba5f41f807d2282744750a345d2f4abd33ef951665df732e4cb03adac150d7420fa5d3ac9bfd58e071f58098195cc9a0b1934845ca9720d18b7993c1dcf2b1896106cb0f8dd8a7cb52ddadc31fd2ad45ac46aa2b5f4153f14e45706a79e7f3e7526403ac521dc25a35df7f1b607f5ded5837a9dc9d6d2c8349767e51c472c596a81b19200aff6726b4e680508051a26b4ce68fc67c030998eeec2be791c8b1e8cfad0c2dc38e44ef4bb62bccb3b84eecfa991cb49e6a8c176ede1f3d15e1f99466713d1ff4d1cb99b1483bc31083add9a8be44414724ccbbd5e563870d608b26007103f50776e933fceaf6cbea99e77a093f6e6bb6a0e3086c7acee30f5f422052ee829b0f1c35c3778b32a2cf2adee25d1767364fbc2b51cf7467b22f129b2a63129f09ec52023b32fe8f657dfe718d7930ca15c8f97821d56f3086b8d39570e2fd7ae9cc43cb303abb1dba2e0abefcfca596b9948cd41210ab4473ac2b782a4fb1d2d9f8bbf8928ecce4a040565ba3e7045ff27b5e1b9a01786ea25b93596f216535614b3c439f97e85dee630654a3396977cbcb3274cf8359e021c0ff4df2ee181b458dcab12d3b2f010afa4d4531012309923630e6abfd40d3cd5d2e444d1353610d24bd6d314854c42d62cd763a1b8e8cd53ce91ad80b2ca0c6b53a1380b90d5bec5243ab5609c6d0fdaa038140c48fb6a3dcf6c42e5d30cd3ffadc9976194b36abe9d50f2231cb6346618a2e38f1a5275153f38601e8c702195221bd82f8c914e493c5eb55c695f5204efe701771a456239d5a954d4923207ad180e0356bd37bf2a89e20844d631b4b9faf2566abc6df4277eb84c7d2f29b3a6610c22cd21a97036a26cea275308381da6f0add754cc55e515c51dc91c29c0e7d4f65d2ef2fb2748139f259386b9fa1ea096fa64fe3c7b594c635e423e10c573e16662f6bc9bede8dcc6712be99a85d7ba29fd72f2fc1cc0efccd605af02334d68bbf50fcd95fed5a38d086aba89ca31ceb9e1cfcd150d3c9b7070430fd17da41fa27f1bbdc41891db1822260ecf242de7675d62d8da5226591c981b1f02616e20298dc9db27efd2f09171584c770ff53369dead02c5f812beaec17584282e4316f6a85048df1c19e98541da243f8d0186aef2a27fa205501788bf26a756970c51bf01a08b701a970e0660f17425f14e0d72bf2fbb627ec7fedb533f9d04e049a9e2e408a45bb49338cc9d5e9cfaffea7cedad7c325b92da68ccb26b065fa81cc904b97dd4844ed841747c4f05198ebf325e6ffe0aecdf1126c861fce85a3f2d7a52e8bbc7d1cf3c6d8db6cc232f269195e212142761edc3908d64db80d6946e12ff51b3841e4f0188f0edb21ea08ef917f7bbd64d8e05f19140e553089a69bc838dfb2abce45129a07936270f65340e81fd1928236ba98a43957211b7a288f5c0510143683e46a5b7efb7243c52aa973f61571600428abe6f52d90a95c27434c4833e2807479b0ef7bad5d7eda2bc81771220d463a63273b4002f720715c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
