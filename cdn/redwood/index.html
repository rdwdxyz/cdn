<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ef41a57486918a7c4bf07c16bafbaaeabfd0f29a03dddaa5d6d8936df3b3d4552b9847f87ad281c3b83017a49ba544447089161c3809d07cffe03316f953536ed27008599e5b8a11d0f673490507dfc8e17c4a1eb9c4f6316531c9848493add4b875b106fbd30dac730829b037d20bf3dc6c204564d7be94b7c197822b66cc533d82b6fce1d8c3db55fa09985d0a693de3950b748bea39742b591ff7240e196e2742b4157f042b16f6f482fc87f4be4ae64ef794fedfba4d095a7b29e9da49f29620e0f3882248a1dc8d08867d9cade95511534db78e03306f50923033014dbf056462f30f1e6f6617d23d4d62eab261136be53bc9fc0bf90a1793442f579ae3281a5edf7653c5f76c19ae50072976fa095e70b5c2899db98e3efaf68603a2702d9f67cd52de3fb50be31a61fbc298aebe7a6b6f76bfcba0636db5dde1a4fc61bf42d2a0d02d2f9e29ab02c34be524e60865fb2184aa4763a6463a0c36ae3cedaf417d77b08a0de9dd1e0676ea0236ef437ba87686caece5edd11351f05aa8923671d3d21c8e955ce24a347a6df5011cf6f7b23a761e9131d737d63402b4ed5b34a5b35ad80fa74097c2c30b5cabb0fabb8efc2a3bccaee3a43819b6ae1a7a656042f7abc32288e5407b798e421a531dc0a19bac12deee4502f915b0249cda24f645fc0a7651235a7d6cfebc6307bbf03a1441fd5234c5e2a6f0e5782b97eca86d49462eb2de695d5ca2668008162f4df5d0936f0d370c55b86693ddabbb259add6846ecfb79e2c4215d7a8ac44d61147fa012050eb6257fcd977e923d83b41b57ea017fef5fad31525f7e8294b5dda66a4d87e8167bcabf66cb38de319344cd67cc6b4389c23eed9b5f8632407b023de050f7bdfb0f92ce0592c01a9bfb7f0611f8f9204e37e2a910c3981e5ad230f1bb7c4ce991c35be8aaa013df56f17b722b601fa4073ee99286e2c855c265fa9a11f347563ca0de4697933e963ffd62628addad47015ebd9c53ac751152f2f0510acc56cb63ecacb9f5c148168b36a286d9169cfebd301fb1b0191cbc20ca66a3a4cd18fb6447a21c387fb2678c7d3a9a337025907162a4069891c6c97edba89bd49eeea3492df721876e29de6bab54469cca045b0f8fbff398697dbbee49aa3f98234fed00a4172d91d116f39c7966bdcfa722a44d636612a03c966352aa50fd2233ca9b5d75ec5e582ce05d656507bdf75a329e0934d57d6c61bdc8cde1e12a134e2eaa154b1f9e8167da83dcdf8add4d0f238d90a3e0c2d0784462ab1ef0080aea774ca40cf53b94bad5da1ecb81a4487d3253d3ee9474fa0637587ab6ea6f58358d86ce42bc7e2330a184d9c2fc972bab8e7da794a500463975a048d25430f5ba46269f6e8d51fea764129114301c164e1d38e9afc293acc4ff5985006e1c8cc1ec1bfb3781854573f745c73ead154d4e11e0ee0f4e5156b0e43c657901406f458f6320c8a1b9089e9faa4617c3c0c75010458f13fcb6d2ac9ba43aebd43602cf24ef5ea49f592adf5cfd2c182465683c5033b2256262fe7689efa853f74a6474fd03bef2c5a8c62c76ff8defb07458892917155832b4408d42e69eed640f2f73d5214ffef0f9ec5e745f8f791ddad278dbb1ee617b6b10fd96d645350c48f419416c165f67fb412545cc78871597f4e137bd22600dbe37212f6e0d77650d38b96b2d01600b2e9cf7ca8d0d929f9c50934edd7aab8a15dff9ad328bb53b63a3d278a46e0dfbc877521c7b96eb53223e582bc522039781c9b68c7c50ae5750bf36a0eb97ef95d770b717a8946ece30b5d87dbf408a393ad575925a0004f5c2552125ab62581cf8e08dc1c576efbe249a313b57f3371b62f1bfc601e0c3bc0e7b42807baacafbd187fc7b6f9017359823422b93fd62f8b7e13141512ff6a2a63f9626093b276cf92a2c7fd16a3f1325e5e5377f5247eefe7b8276b3e096b4b1c063d61e4c22478a0b23dab585162f86c39b86dd585f67fd8f030fdd54d950375a94b6046379ae03e7f53c7fd05a2f514db9bf3bbf7a1232904834b774619e45c50e2f553327dc2c19fa38790fb9721229e7a2492d3f91288fe03c9959938ae20451fd706380dfb2a6b9f9ce1022465942fa89cbcc86c0882b1d772b6cbf0f4026b22d0dcaec4aa714086a3a683fd006ad1bbe88b0a1e0909fc845baeac92ca039cdf5aa8248fc9ebcb6ed5403f2f2500ea65c25f89f306762e64a2c7d233906738015addc6d349d9f4f9b1c81e3725958db732bde3f26a6adb184f6a692493a22fcfe4e66f724309fa8ebab52545c0646975c1fb860e9ba7cfa6addd7524378ca96900d0cdcae4aa6781e2cff6edf40e02a617e7703aa06af6ef692c5c196d0f571b796c6013ad1b1c5dd6a2f9d12206503395bc72a5b8570a81a4406eb24c07a9a247026852663ede52b8ab78d488466e11b56b450234e21621dae3f19ebda6134309d5b8ca49b8ea8c28ae80fcf208804d76eeb0f1e5cb7a809278567c27fba3268cc7c7184b896ab34c772c747e6aeccb4f27796ca2205a22e09c5eb449da5edd7ebd3e28e12b1f7473ba9f6591a1d7275af6fcb542af20855789432134bac6d9e1751c9d209282fe7f48444c2f1c90efae677135f3acf44d02e18fcd3d665c137dba5540398d052e2c01fbedffce8aca5035cb4427eb4573e71926cbb98a202da4985c8e0fa5f4c0b241d4b76cc4b67ae039b4332aa7233485304eec260c6b0c19df6f10af85510cbcf312cafb68309235d734c1c3924832a516aae78106d482cdc81836b76cb5852b4ddd9b4cf7490e793addb4230aff934bfd645febc968565b2c4c000c5897055ea51f3fe6698f7e9df9b1b3f4df89e4430181416ca510fd0600ad96ddc5f5791dfb4c5d335001e2ff35fda75663ef06d301a258b7493f4c551a7a9eb5c857c84f3473a6f34756d6932834ed615cffac5bd53f974c9242419d973fb22e2cb6dfd5e28b41d60e9ac49a55b3225702a638e5a155cba264307a033779787eff291e0d8e9d79993d2f5a0f6fd39b5611e70e7a200cca7020a27f1607d6f7e694dd2759a67d99e265c5bd13d234769504f56d4bea429030e519d863036facb338b660d463450b1eebb1770721277eb4830722b1dece74f4570531bd6f385f4496c072d55ce77d066ae470545cc01e4cad90df972f3dc4f6094e77ba2b93d5062890cb351ccbfbfc6b5497b0c6b5881fe0c5ac7791255541d5c02ebe0ade518cc0069942f33beb1d6fd1ca7ce3a946b713e70436d55bd8d76926949e0b961b8b00fac0430cf8bb7d81c669dc084656e54421575e13df62ceae8f545150ab12b4f064871a922aad8f9606c14a210e88bfcebdeabd6b1d95116fd44141d3ab0cce5fef41c72cbca6f044cfb6b25b29bb20d5a2e603ce2165b01ef6bb3238d19ed00038976a5bf2c10964ca347491e51679eeb9ecf669ca17d1ad6b4b50371f3bec0314a4f77fe9082adaf85cbb1257713068b06febc8bd5bd79c1c9f5a7e2b0e1f62aadab4fa4effa463c9cef00c28d7a930ea5d20eb1c1cf9d8146880b9566d26966f20b8000cb2b84edfa4ed65bfecf3c72efd0935547a7a9151ad753910941260d1ec72436428cd94757aa6e2d83587541dcf981f713e466996befd9955ce82d864468a2c73726dfdc0baeb71034ad23f7e4eb2881adf461e0b5de212b19412e895c2c8a932c9064ac866fbe358eb994d5da46b216e7a4198421c8f7591afb19915d8d7c0d0df3d90eca8b309be3fc8647fea8a242f1f05823af699c20c02db2c672d81d479d8bd72ac8cfcc67408e45551fdc1c01c81c45443d11cfaa8656b3911668a87b0f028127262e170c1ec73830f0549f773efc9417a014d61f483a4808bca66fd3447fa54283e0d8dee4fe93cc0d56fd243006c939c931c445b2bd0fec04128020e82fd207205d093dd0e3fab85bab2a1cf3a4bfcc87e0ea6ccd099ceb8aaf7ac43f9d021696f16cbbdb75c138d7d2b777732bf85058f5edb585c7724dd1273dde8368a82f17eec9b802683b3e4af703f97940c4b3088d0e8835a44de9ded06a1cd43d2d6d234c8b5e968b9a1e47fe7cf8a5e602092b1e71d7e4517b0a4deec6a4eb63d4a6261858416165a081b168e1027007614bcf024717e59b0ecedfcc16803e43ba05353e4b7d81e9ce9ebdd741aa74292d7ba51c52ac3ae0ff4e01aa9edfc88391b3180e044b9a9d4b17cd3d42481db552103cd22dc492573bce65db674e5268706241eb9e5b697fa01ffc6e172e12e11d39741e93a3925ead54773f0d0ea5b2814570c1ee9e37b0477d862cc304eb172d6c689a43d44089d6f61ed3b35082afe47e4b30ab2e19b416e4f18eadeddd642de94016ac66d5529b4d30987549d4dc5680aa0d479a72b086d4901e38a9b025a0159e19e66736836c6aa8bc8504d5d656e81146f4ba4eac11d23f2fe61e8e7ca73f45a7a9dcaa5a5630920b96fd6e5c50157e3d450c6c21fb51898b72ad2d823e75eb1e5c6b7f3760752ef4ca99e37fd7a15fa2fd729e078a823f1feeb7ea6d652f01ba8b08dfe28307bdd3a1fea83583c57946d53b7d628b2b2dce527936f5066e465e3585d8a74f0f27b2af5e3ec60d3d20311992b40f58506b309977ea75235921ac5c51251cf1c3d8742db55d77c7aa3f01676b99ee6f4fcacb955bd65d9bb9717dcb599893fc3bda819412f9b583f764c3bd0b2c6f494d8098d108152fc8715b5aace41716936ae0e991e5b95502a941b1d3269d9ba32105d8bfeb0c4135e0b7b7aaa08d433ed5339766c1ab27cb6b37c00f5c3995265a92c2bd29f13df223813a5c2a7371b7683771ae6ffc0b6330f563ace497570d67d43bface0916b7ecdfcdf1195a1e22951827cc166dcbd9fb49253345e8ccb4640bd581e1d6b972dc11b2d4cfa6a9c00917dc0cc31317533159af4cce2dae4fc01a0f77ef753260f9ca568169bfbbd4c5b8d3de10b4df127b8d27ad408f19088308c8ae12567f805b24e7fd43e5d03ceb021237ec5b4c305e144803e5153f3f41d8a074813a3aaaa89cb472d022fccbac33bbaad9b65cc46b5834c1132a8e000015fb41e5814c671da5b41b98cf429f1938c42ad646027be69a2f010c78124ffee00eb7498515de49b04a06e98c8e8dcf809b491d5e6ffa5826ace3e32caf9d6e198eef4e131b88bfd1a5090e2ace5b83173319aaab748f20327897d5d8b850d154edefec47cf06fc816b8df0a4701090602d9f5e6227c8930b762b5d5a974ae3742e293aafe6f4aa0bf40c66c95ac09f1ff02ba511a8079bcda171856da7dab98921aff5e03c95af68e7a5a3fc63363e48eb698ea5ddbab4d1a00d69283501392fd8014a266ef13876131887141756f57c277eddbe404e1aae2d82463af08fd2b594cb36e2493ae26cec74167181d45241ae8498eb62b3a8ea4f42fe1af8146ab5128047435eada69207b9fd05f474a9141b559cad42b3c6580705985f6c261ecdf94dc03bcb17e36945d75e09796396d15e9fc1ad53dd3c2dfc04a5565c470652f7ee2146f39604923b4a92cd7c4c90b7ddfb8a6f3ba99b3724d29975408cbb8d00ff524e3cf9d58b7e0285e2c87c6ebc88f2f440f461ade0cff2b3b525fd4ec9924bea935d56c1e12c0395cdebdf710d90dcf03f1653376c5c33e80efeb36bd7d9eb25b5291493d169099dcff27d11645bd19754a249c53dbec0b4e33c033dbbbc371d9f0f9c968e7444474ad1e04ba7174495e0d7c7a34fe8cba804c1fb4adab5e9ca38dcfb556faabfec5c8b9160013d6a65325d97615fd6832916e674a0868cd9de9480e3c6f107b7549163f072707ad744636f57dab003b8f4eb52db595a82d0eee3e066c99ab7d91f2892486001bdc1159a9aecd834555d0481a4a7464d618911f71989abf803968c2045dd819bfe22c37e2dcde407eb5ac2425be47420b6ee91277eef41dc7c9826af496b79aa7284262a3671bab3c5dd9be64320914a0549a2af4a6e2493be11f00abde0143a5aaaeb1ccd53216204db1fd7863639fe4cadc97710f2ae5be05341eb746f93e66a8e0bbfd6ff77ca5c4b2191ff9375c08d0cda9fde083e42a05fef13cced8e2f6dc4251c65c7e1be57c458c6229862cefd1c133a85808d28c6d7324d6f56d27e0da5984ffecde8e27036f3ea54fa4c070a48a5eef957f7e5cbb1ac4b3ba5afda3051b1201e57ad7d276c0118ccbf97e8fa187901d296d447ae425b4b540297b6d4441fc9fd7ff655a6b45cb865ed2c635fb12e13ddc0fcd86d8e84a3d1e925c4292bb7c30946f50f6600bdc5f02cf8d8b3b1e87e4d0d36c050c842b3c04b9e9f8bdfede17c2d6e57045092170f9d1514d32fb512709c924760aecdddc73dfa5aca740c8d500cbcad6a09c263e8272d328bebee26f312e1c160b384d7ce25e41fd4492b05c45894930c7d38324b4611d4cefafc46bcfe1ebaa8622d74711a99bb4b0440608e5691bb550d74094c02407fca2b4e652e72c89580c44424f462988a810bcea7a2387d48bcc18b2ef639554cbacda22dd26f1451e44dbca15eacb7e5c54c9d8fe6f7c2619875417e7ff2f939383cb3b32953c34d4255ed045f9421f72724ab96bcf368006bbaea29cac05fa5f5b4150e3521b7b95a93a922aeb3f34139b0ff7b0872ce2db4b79bb394757e853daea2a3788e9a14ebe91189bad3a60afaf12a950a8e76d7f405ad0d118e85419cc1b7c77ef7a182e979cb547525766c27ffc8dc4cb19fbd202e45d14cd95b31ba15a8dd19c3a17cf36677e5346335c46c71b955f3a65a66d5ec1140037bf982453b7f2cb151675497c765c4e4429c3f6cf08dd0a0c210d880af303c94283b7a2c4d794b33e314248c66ebfd5018eb4616efec3fff8aa32fcdd2594c402bd8f574fed90b3d092fc03769cabaefc3384c5100e4bdbbbe0676544857f70d1d1544c3632ef321aa326bd184689842d27fd89075e82432c266dcac6350fcf352980bf60af6077cae228910f157fd67a1438fe86b44b1dafd2f4b96f95ac73f9b7c3ade57e117b9128ada0bbe89a2bbc8ed9863a9c15042853e0c25bb61414d56ef87a7f739dcba82bae8e4b526cd906b9ae829bee5f4d31212c3cf9eeb38e323bed344afbad2e3f61468f2ce593f487773c132716741e6380f10d5245c4bd84d1bfdfc3321bc13e0898fbb66779b977de4fad5f9eac16b5d4be5a0f8f93e636939c78c7abe2989a6378c100b9873987a9c672d35b65a3875f528fe6c629d1bca25927857f795933bf54f67c83f89029fc52e7cb68fce91cd063b821cff8f08d0e805ece88d829b72aa8dd80bcc5d6359e24eb823e1cd6808256e2d1519ce36c6bfc2cef4788fe5372b03fb96d01a7569cd59f5531afd25848881d4417e31eb414b3285b50f60f1edfdebb93f0764278cf26db62a2d14331cb665986e6d7ca3bac16d0b0f9f26e7e443ecd1932f0cd83c1d10b2d4d6c90a50905052c339f7e8ac28f9cd4907c0ded90d8219666ccc58018878c04618e7cc8e494c1596c265b235fda37837f03279f5fee0e92d1ae6cd9465d6a02d7e0366da63898e32b0a46372b158210a49f08ea0f717a7163dd8cabda4999295341129ed9dff0f2062177054b0b06f1be27855cb3438ee5d9b16fb565643068bf5d0d42a785bc3c04755ca1109eae86a6f5d9a2ff3c1a231a7069dcaef44ca94b813e732ac9e2075c438860ba95e320fc5a00b871514ed3ae40f9c5003947c38159b08d69be87a767cf05733bfa6e645e2debb22027c4340eea6605393685237fc7882c6e687ed7317b003de88bd5a9ec7ccb91d05aaa94b9c22e5554bfc2833d7c7d4adf2a6786fc6ff5e06088e3804e3e73d193893b458cfeaa33f2829e1285ce1115133f00c403560d3f4db15b1533e79cf2c6d04b0ea01ad8e1a97c859823862170c795610ab88eb0727e0935cd9f74c079a7fa9ca191d407efccd00ff899c2c41960afb6553b535dd876d96b6f2510ebc4068ba08177d003407a4665a11df862c90cd208cd1dc3742e0b019f8e08835acde9212a56b67a0ec30707047f46f2653646c5309b6d3a20c3ea865a6d67ff1ca18323951d54efa0d41eeb65ef92247a98246aacdb3700cbae7659fa624fa3aae5298939f4467edff879ebb07567491440f62e1b1270c65658598ca9918cd54fc3f652de9993082a7c0f98242a678df663b64e28b0d02e9865941fb999ed783e7a6143c52a0200fd0fe414962638de6412eba2cafde8b52993dc8280395f1399c0e5ad7f6bef8dbbe10a1dd2ee2dcc542eef9f5f3dd232389316ebf71ee1f73114160a17cd60092ce1201fed14e244d6fd645f49146328d0d6884b4910f3f8d380d64e9b08dc8a1b4e632c1d495c927eb41d54596f87601588b781935458b14d6b09270eb1c1ffe1909dabb3dc09c42ccbddb5c8b488c2fc3f8023b99d1363ee06d9b436718636dff93a0b57573f7399d6f193d2573c2b1b8c462224e8f6f2e8bec10522600d5abe765ef9f8f34e538ea018901b025e04fe946250b17d884a110e55e090e9c2985d3fad5de3766378566bf63a69850f00b17a447035c8dcc61c6ea0ea13db45d707c10bed8531692aafeb930fc89db10036814cfdb731edd9233bbb83c9dfa12d61db579582a2b965ca3ab32b17ac37f56025ec0b5c63b7305180fd87d0ff634b3387b5d8a99b20e31a6921de7e550023c4b8892870645522c5205d58aea0aa3c22ddb51357baa3a4a5c7eff50a2e8be3d321eb500ad6219cc2e1e0a276a7d37961def3ab7b2f6fb994cf4b141053bbaa8a591be64a6b6f8c7762d4c5c62818bc36a854395ca5f6707c85061771119e6df6d778a0b68ed484da0a2a9203287dd93e99eca23a9b8af1632b76eb5d2e7ca2d28ab9102c1e42f9c42de40ad566709f6c8dfab9841920e85fc6d59ad7e4013572934495f62868d2af70c3967ceda7aab78268d82027717b17cba49925572192369b35e5830e5bb60a10a839bacd596af2751c3d5330c63bb848bd9297c05157d3eff9528391991ba160731b542f58631c520da6ba5a8b9b7d980c559e2d4cfab47bc7ae2d45386d4695184627060a062cdea37419cddea7a43c7bb348a5a75e40f13c53458f955566b88a36712bab4dafccde9341364afb4d8992359e7c61313986c068f6c72c6a81e36f084ab01618083cf5893653e70771929d8973ea9d1df36b4421a6fb79e5f05a108170fdbe590d8e561651473582207556593be13973849940c926758e2f7300477f00b795b6ed25529126ed119c7b2fc7459b60fe595e009297e0d26d0b2a7d7a2dd3699025c24802929d63c4a94123ba975350a2e5b243f77bb5ed771c8d4ddca61ec999fd1c1ec5517739fe0ff453044b1dc528671429777ccc033745e60414a2a8b2d422f89d54fce10afc673a080e60362acf3d50f5816e1e08db26dcedef274aa49080f9c101148f4b528eae283ef0cafc54bc1ee16df65fa7b17c657ef622eb5a2a1ce9037d9c02672849be7b177dab22237e72ebcd3cc9159c2f66269dfe1a649404e44b788956ad3d181a50b10344f8b16a9c282f7333b750fb31274fc12a680dad632f2afeab4762140f64b7ecfe2128406c37669622b68cc5e815e474b5b86ccac2bd1300ba8083e2f1190f4e266c39cee8e2c839c0fbd9d6cf7931dada79fd617fded5b51e612ed4b25f694370a3e79d7fb79dbf3d8e07f0f97d464141f1a9ecb956ff2e75d94b0fe27a323c38011459089b0288600de964f4faaa4dc9c0436cfd87b176d10b4cba1d7e8be38f797d8d9a028ff65871de1ca550d243a7970759a3a55ff051af89d8d07550c0fcf3ef6d0f4cb799b6581903b7fefd03abcf1d671baf954a094d85010c1da75a513452a430ce66e62956f48fb8fdc6db78a63429637ea2d8f627c860432ac1bea876e8602d0f20e163750c2e9186c4c343edb4b019513b37601c70adbcb51973edc84bff9d78e22b885b9be4f8a08d086edb1b4b5a6612887a75098727d5e30a429d85a0f3676034550a11b271f03742acc40d55928ffde1fe7789065efc85a8b593dcfd57ecf89a72e2668c70383afa4577ecd32f24b93a6e2840a980bb8ac4eb2312631c75105cec1b0d53a484c89f1db6defe764b65c1f25c9315559c09effd1d9c08ed9c7a77b9e1a88c52b3548d1c3a9a9c481177b52a7e983511f2b313f62cce53b122b670fc2fa7b3b47e537c6a05123b3a2aa99caeb7f7efdf11aa4e9017990205cb6491ffa8f3d907719bd62532e96ba311dc270c8605bfb3b454bfcbff0a8af2c50f1f48e64098d1a7ebaffab732cee066619fea75f616ccfe728d175ab7c6a7b5a371b0e52fb03dffe7891a85c008557c2367dbd3b9f8babe4db98d9a4734667499d0a1f2bd7bd572d9f1e72421bea1b9e7169d79d75c0d4b43caf8a65c8795cdd6e8b724d6d196bd44f24a5626d77e1f330e18f7d69b5130c331e69ebc8516c6d348ff947ad348914a8ae50f5a8597ba0f40bd953cea33d2ca427a128ec90c577b6897bf98e25c7c13240a74c9a7a7b6559e8298be38fa0846d4a93981b6770b00c930d4fcb5230548ea256f9ae7a33a8855fc5067b9b394956250e75a34e5d744eb1f75b8f3faff9c382a01e440352e76d622f1debdbd1280d0a431a0a6d520a2b0b9942cab89ad6571f37f67194e1baa8cd6931edb79cb7f4dc97ab491c7b4a9b72dd71677160c89bdf380562126593c831ee69225ab4d5136015a9f8281df6d1aab90d15ceb89a075a85ed5f810a71d630f8c7feafbd70f2c8a35f4fa8e37db5049e5d2b232fdee8392f446d3c1b0ece103514a24975f96102bc1d782f6c29c123fa1c5891c3416f81755a639315ba6e7ed79428cf5288b866b53005eef8f8b1e43c3439e4bd58cceec8d25b931cf848966ef118c3e7c259a2f12208f86b9cf98f056101c68a0cb3b1980260ca1c657144d901dd4490f399d745567b2db937e2e812a0ecd60aa74666f7ae61ad5efb181cda4eef89348d60b4cd27bb934c7dd9698a5ad1e1ee3728b26be677ffddaf3beaefb06881e014e29ffa8805511aab6161e1183178994bca7b0125419a4f38d35ee3c99c7a9632269f571baa569791ef4202b0f6037f1284fc6cd1dcf11aac92ca6211285968b49aa96451f55997e5f19adf01b7974079d8cabcd86003cd6805741a91e1fcb215be80fcf0a7801de99c0477abb30a456f451da4f08ad63cb384fc5b031795059fa6bf54ba52e8a0cdf36e688d042f1403fd78ebf22d9e87551a2bf6453b1c9e0a514884f58348a338e89f22fe45afdf1cfdfcf142498cda23b86cff7110f7ca821ec4837f2f0e010d3d2dd5ab19f20e5729ac2b8b44d9a79669700c2672cafddadd20a5c59f4d061c388b2879284154bc9f01dab959dff483657449016aa923d926e4be18aa5df9fdd2690797cbe67218d5596752365538481cc3cb879a4086849a91575de4984c0afd7db5f469c5e2699b9b67fc906d9c6df0add1761a8edd3f501443cd8220fac4977ca02fe3c39bd3a8b3563135947a0d62237872b9cd9dd85f7e6df1f79473e3705fe0197f2772f94069379b8b843410144281a79ff33d4369afc77e5ac1b2cb42ada918cee9a1ff37186cd0a701f001b7c682df2879d3556ed25cd1e5112d0ca389cb020997e45f32a23e953a1f71a6068cde585855148f771d8603d5e3266391b7cb662aff78ff35e3e3af82ea356008884cd8c4c0370d6ef29513edfaaa13c0eb1d72db4ba706268cebc6e0212b47eff8c8b73ba2004d3d626eaafb1aeabb70f8e1a10e6880bb6cedb4b571434bc86c46522a3c4ce0e39314db3264a4f5ca66d88d8d90e067e0b901f3192a97ec842d4d9d96a2b7990a2422e7b9bee6766feeff15a25aabf7b85a29db9827b9f5585a6435443cc6200956f843d78e904d7804fae9b7652d6a5127863a9cb8b538c60312a9bb180d86e48eb909fa329957c3b41339e902b855bb98b3adcada9dd9881b5dff32e8003e23a1626f3c7a4a9cb1177213b381c0d63aaed795791d6a23ce10d11f80468c9121a28d56cc4882304b1c29a5b2e2ad4a81b4737dcbcc1c7d6890ec7a9979d502a24ca47d79d4e101506c5fcdf6e805bad48fcbabf4ed4307403fb3beae08c3724b0983dc15c26355f1e34ae781c09099d824ee891f29e0e4322dc38084aa44c0ac74fc833d43572144dc4a6962c82629bb58fb7acf163b9281c6567da7f7b695419b036ef810e0c4d0435a9ba0a717034e85f1dad5f27693562b24c09c01c9a77d38d04c3ded82061f15a04d701c6ceeb27216450cf3a967e639e506864ac26313fa81d6624d49c4232d4acbda9f95d68ee1221f32eac73be2bb574b5f2140100200970a233a4bf0694ebe194c2c124ee55c3393998ad0fbbd0f5f1f13b23935d2ab093571d81fbfe28be90df6444a7091fbc6798d417a21943cf712614f514b7f9b815402dc13e1e89085951bb0fadae4c588bd054a2c0cb8d6e7e340f0915135949cf619546dcee82558f5f4edf0f4c468dbf0fa23702ffdf882d323afc8ff13906f439efeeabf965b399ade11729927c4aa4f32c43dad03c6120b705a752b812499f857519dcffd7fd683ba41b8c30ea5b5c03ff175438ed38b92cadf30cf233f02ac4b524201103be17281f8d974d965a181b8ce1132444410ba90a3ac36a139a2e8a7e3ca38406be57113da133552d9684dfea578f17b62046a00c43c6d5d67fe66685b3b4ea83e01add3529c63b175231727b4f1f363e762f9b02ea9843b7e7f106d23e62793d7ece8595bd061bfc2710cc9935e72c5dca5a5422341a7d3430a7b113157f8d47c789508e6b5054c34e6ca2bb2cc1dc412e575ccde17c0bf9f1695fe5f1ef2201c6dca5b3826fd7270ddeb13edc812ba6229d7ca327ced19e09de9baa5df31b7620b9d796dcd9f99a1afccaa622f63df62c7536c646ff82434806ee45a04b5a8dd6e1766fa3f2248771287160e7e286b8184b04de5fe5bc710b9efa9c074644b0de0afe3e006b709c6d2c3276152cdfaeccf4c4b0e251d77d0bd3f76d66573cb02b4559d0d45be49a9828d446e1bf00250ce252d5fbdca70ae2ad3745bb79650bd0e13c842d89d8f6a8c653c32066f8e370000eb1bfd21d2e544f853c3057623ef8caa6c84f20457c7d6715b9eaaa3877b51f5d2d95e54183a7967406709403f56ee820032f1867db03850f443be919e7f45d87886e0f310cfb6ac2138dda778fcbb3c85f9069754bf9aff2fc92e519a00fd49eb1f98d1e3ca0dc3dc8e005a15a5e750f23cb8c679bb38119055be7ca405c1b3dbf77aa8bb5a0914c318e61030f1b5f2453276b7c6fd70c72ddaf378f470d505d08f9c94c6a7e1da88a7d9d3fbebf11362ecb2f43f8851db9761f72e54c47e1c8f25ad56acf78b00cc44b911b0491719532de1a963822de458c3e66cc795f106375634d4990eb73be8c0355d2818aca27fb6ff04c6f681906331c1fb7af4140c44b15899ac2fe900f9651074ec2afbc8c52b19761d698a34eb1f6a978e316b5af2f374b351184f138a79a835cd1a571456c634b337e2dc334dba5ca9c53173f0cb70e35b22a3b99062199e26f3968a79efd7dab87a01b0757b3a8ceff4e88ece3193b37f17e4d38a21fb2a32d080d7c6cac75aa49d05f7ae273d5572125ee423d02d56849093a153b4729b838a1fa5bc6ef7fe6bfbfb2b0523597cd6206d53ad31338bc9492253c8b73204063ebcea0a8682da7a83aa1a5fbd69d1a4c6e4cfaf985b3d76dc54a217e406fcd3919b8372b4dd5a65860ff04bcd605e614798c40e7dbe1d9e1d5596a4240ba2aa05b30667880a5a0fd218f610da83089986c00a437631fdc8ce4ea135b2edbae3829c3de69aed9061a80c31e833279b17fa6e54a1851ae902233c16685e588fb8b2fb1ed6a557a1ec621e82478fac09b541cbf56e778d01e16bf60751c1cc605a1b6d1bfdff2ab2a0aa4e02fe4200bed709d87ba2756a449e3aa734f8c33c0cbc5f4c877a02f78ea9bd92f9e08bc4e0bd7f4e669b58381ac25adb3ccbeda6d436da0d77a8c88828887e14edcb5a295ff243db72f6cb9570a0c142bf56980fb1f8011187d42d4bda31019c37ce8627f160119902e028a3fa3930df4aba81dadbe737e74f143a7efc9eeb808617757824389a2d3ddd942fd94db61290c7e890bfe158399f6af1f23876491ae0179f0a50c0df9083e9bf783f9a8f209bf3b90cba89b3e8feb395c702846e60f2239847ff3407ba22ec739591cc6aeedb48e0d81c604bf4c21979c793ebc6d1a762782d22268a50a341b6daf26727c16db02618c9c0e3df365a8f96da7ab9a582aa2a8f591f1a840381193707eab7a2700f5b1b093753e8a901674dc1487dce36b0d293dd2b4659a43ce0364824a2e189808ceaafdef69e495921de28e0ca1a8a63cf58a9f053ec4d3e0a523f80971a697f825762986bcbab899332e991574c3d421c5ecc7a913c3d7ae96acde4ad675c1c78b55e98066668da40f5e566efb07ec1b66cdb5a1492b79fa747837844b1a7051df08a48ba0d22fa2f8881148c5b1e6b84b5b63cf5d1957e67022b9a65d18824aa25b49f2b0127294f6668c5cdb19a915e9dd6ee058baff0b3302691d2cccda32cc9306bbccd06e6ff0f7b4ac7a460146e166d7d865c7bb9167162f4158fe17274fe931efda6b65fb75a212fce66daa6ad812505cd305f1df2d895d2997e7b2f27fa948ca5c3dc2d835691513088ae7fbd989dce7501e1b70021a1aeeef74084b96c573ea16f5c5bc679cce141b8f85aee0b543ce20f97baf9d6fce3eb31eec9f0ffddf1e912bb9df8e9f3042a038529f79bdf4b036ccd4fd1e2b6e7d990040f98f179af02a2dd22c1a52fdb0260520ba7aabaa69e6138f49eee0b135f581fbaf33528b74214a14ec2f76d4e5575ac8f85b28c8eaa3ea360876d699a88dfd64c9938f49ee50c00baca778ce4a3d3092e95a250899c9ec1b260ee5142a14906ad12213f1c0704165379b2d27b8d43670d09863400a8c3dcd65e6bb9c4b908b7b04a4ccb45e4603e0f4f793869938b2c27509d6ad00bee9721fa9611fa835622e53faf9b4967102c68c62ffdc042c3f1e3fb4dc101847f81338a87fc338280d23deeeda12deb6c7f2219e2b6d8cd065b237910370f6cd13f015835b8b4e7d46595551bde21fa3602222939a226aa0713529710cbca66f492ade915468a95686a00109ec5d628e7d1c76532a31ab09e7b774365a81616535f93c606d37d2de0c403f580f7d23a4d729851544ed062b81b43fecbad3313084013466d16065aaa8893090a1e84665f90d2bb99e99461c64510e537581712cac41e740a7c471064db7193a8e8ebc67b837baf6da83407f79e62ce14a7743551c2a63109b1cdfc652ee4bb88daa7ad8687d2655df8342e7045bf40784e1783a27660207f59f80cc7caefe47a5fbb7424c646ae8fa605111be5bb7f28a559d5972937cb536750b4cc0a3a0863531b9d3289391919f9dd7da831c6de1ca649c185a3d71b6179f5825a8e0cd0fac510fbde7d82140ab536044ec4ff6059fd1cd83807da70bbd10386d9f5659806111b9fd59936ebcc13502d290324696204e6274c73d2bf7bb6c93b6e49a0d75939f888f810dfe480a404d705a1b0812011ec1bd8d67456d16c1f0a807e8341cbfb64bbbd3fb7c992bff2f0391f916f8085b26136aa86e652f3f8864eba0ce0274b89d95851bf5cba8b9f8bbff7f04559931959acfa9bec46475dffc3eb4c2cde405ec985356597c4497ee1c48c567409dba2527d1a697a03058ef532b0bfcf70fe8b93a4655591af77aff0f894e9f9ff9f656b866ddaaba98aefe4106fb9d3d6f84ec08df3adf6de28e63af0b0779d690e9e76cf2be240a4f38e038f533fbe83c8b6f58214dd8d81032a4133c4dbe7c56eb02a9da928f86732278df71d47ba2e6915d2a3fcd42148006675b71aa92fd09f20659bcfa7098a9141e161130e369d78f63a3fb81ed2b8e748394c6fa574b51b07ae79e83dd54c8f642493210193928dd7a7c96876be564b24591d9713e8b0fdbb150f37fe20fb19a412247b9223bafcbbb436f08a14828fc6bd0594d971c7c136a6f3ceb8d62e091619f516f68da381644788ce216c6d786db74bbdd9c429a3814eba8ab840b149f0ed843028797256d7719db1d5ce4d3cb18b3ab622c3a9e0ac39f7425e323bf6d0f088f7b10884963c248016850ad244f27011515aafdfa0f8849de2d9c3743d0820cd17fb76bb7bfc612cfc422687079e7438207d6f6225a0d69b3eb1806e0c820bd34d2f90e3fb2f6bea7bc759d1a2727597ca0272a7a525f9163665381689480a419140dc75009a7a082f55af70bbfbc82b0f8259cd8db9ae76b1813df3bce3c6b271badbae283d7f5f807179359e3ee0a2196048e385ae622f39a912a859f1ea625f8e294dd1a423d10292b48a01745ed61a97633b60987a45e1abb818b68abb2131b522272e09f5506d7031d89bec9293238c756eecb6af0f25904329d111c5fd76a4dfe8ed90c5fe7fcbd19ea677715fa432cb8d47192484147ceade6ae1fa48da3be3a829937bdaaa223780dfffacc601993fd682ba5fc51c6c7bfaee9d9a91763ef035dbf8ccdb9e71c4735c8769198eca714a7ef77aecf5985fe70e951edba6de7f327acfa4fbd35612f4cf272604149d8cc89dd6bdb32b941b6c69549ab2cab4d1384f786800b7a10bfec2b913ec4576fbdd3f89444f97449066d927c0c94477a45f9000a43ca945ac2a0f4ae28bf7ce85f89459f3c313282052152e096c60b729939bb2237fde53a7204630fcf7fdeb5e2a4a36b708ed8d142b84efa5591608238fb804e75daacbc9acc015469e121fd1f05a991a9c2d4e201e50876771e439abaa34953ef9a07d30f139a846f90296adb209e1b71921bb05c019b2bbc7232ab5943df3d768d42375ffc090e771b2abe90382e698ed1555b7d306c581711e09d6cd013839aaf1c71ff600072791a3059dd2ab3add6864824d7df4aad33c357ab1e097fb63e4afbc8cd4933fdf8438962303077f007219220ff495bf2065114b2107c4ca66a6be211c6bb0f941eced2efc451beef7cd94f4abb55901da3acddadd07adfed667a0aa5baf352f5b865bb11e913ee93078dd1cbde1fe227beffa7a55ce982944d93b335183736614a412f24d8ac2212c0ec57e4cebdaff439772968a07b75e71bff3778f572ec9cbb836c4af43700af009a70ee8cb8d751dd9c37ab50954f15f68e1a45c52d35ee256febd56af4b24d8aa73e16a7923bb9d057f1cdf71a4869f897abc5293053b902a682ef208f0911cfc216c3bf191aa4faaabf1feeec824fea38ba4e2fde6aa18c32fcb58e47406037606c43f085f1635960e2a4bb29ba94a2386207aa86be1d98e52e623b9a647c61dc2b886711983dc34884e4573244c50610762088e408c608d906dc9db135ccceeb4872fdf85edc56776a34028e6611b74d53358d2c1d915bca9d6ba80e2945e40cdf909fc1302815667112c202a2bd369f1e6c22164c4f0c40c6d640999d3bd20308896aeea45d8ea43f6bc44243fbb557c74c3c89a10e14eb6fc0f3e29242804df73344dfbd5412ab3e15baf7c254933cc7bf57aa970c9e5660a18e75cf1345f0609edef6b21db5aa8c3bc1df91b4e87755077dd107e4342e831ac19f722733bbc6abd81a8e1a33130abc220a38117f52b34a81841491691902870e2645757f7ccfa4d6c93424368a43ad4e82a5dcb4c1b3dd3627cdefb2a0ef7c534ad5a73eb8ba88a9aed2a3013aa398c4bdf5c786320b0ddd800c7630ab0df7acef44425e5cb6cf71bde91fc6c5d606eef0a4b955b72865c9c24f574a4b6d96b32dcdada1051e1a24c473526a26b67c54d9a5d0ca4410f7e0e1b6d8aaf093da94022769e4d6b630cab08f351e9ff879e7ab73d2fa85073b09e9b199f02c9ee2e397b2806adab48cbc2d1385d3cbc840c83aed776b2fceae7b9d7df753149472b72673115799311b6d557ef0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
