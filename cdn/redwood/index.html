<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e1dc2453fed48e6b29247e0133c971b367db83a3bae6ede39f47f729167d0afd89837f2b559cecdc996f1b55e3449df17c05a7431bc8db6fe61760bf05cabdde45a1daba5ee6035b0f7bcb14796da8666597d76d4838a1147b2602083c7b7be0bb0a17d8a2c801c316595ecf1ffbb28c55e927075f6f42520704ebdd0946df7311d1a1d52e6e78d11263cadf2cea17aac4b3be6406a88d347d89d780edf3b85d72ba45b3bbe85bdb607527e28ee0b46c836f0f10263de863f26a3789bc8527414e942a3c5449439aff6af95df6ebf3d4ebbfabc6d87dade0991502e6a863fbd3a51a9faab2e3521c523fa802c7450474dc3d749ded02c8e51af0db466cf3e453bad97aaf8e6c305956be5c1c37869e121c315eae79a64eb78311222ab95b4a3dea0e0028de855f911f1b2c5f8ac7bee1ac3f3a2fa6717200daf6ed99bd9ec21c83f9cb111b68d891c29b58e0786dc738b6903d86244c726b2cad9d944190bfb25633cd46d04cace5edd7b14e7b97b424d9f76ace62f5c3459d08a0623447371e6df7a79fb21c91d53cc1467e1efc8c6670ada07464ad8d591b16d485164e1aa27ca6f860088db497f90fd992b04c127b93ffc59023a030e13f65ecf67b2b02628155f34787431b9a80bc54d788eb5dced6eaaf9fe2afb21ce6a5b33072592ee9eee1954c2ccc246d81c7e7004814570ee695d25eea94020ec30abbb6801eb48f3e98ca0a53efddf59a0c1bec78e6d5c095265405f8eb00fb6a57996293d7fd4c1a76e6d8ecf772b2e1c1f0f2fb9776b67176e0fa8599312477ef9215cc37e29f5c99cc6b94bbf9b3ec047ab7c35ca6206783cafc63b0f5b5ea428e67e1c5e8e75ab7bb2fc3a7850f97840ed6a8ce8410e599293a2458a6e8799720803ead1c64c0718598bfa94928bfdcc8993371c3ba6014109dee640adc968e01864f8690bd7b78dea61583c22204d692f52dcf6c37585bed5f1ee01310de0fc9e218793d66b80408b7b22cbfdc8db10ed311980aaab02daa703f2bdfb0d6cb78b14103779ba1316a1a16846cab386ff3d26386812515fda716ef7f2ae8d7a6a086e96e357ca613acfa9c6e38a9e7de576c5e6a471707ea0999207db5975249d1a8c37d18e1091d20d86564e8746b8812b6ec4495def65b92ca509f412c2df40e34ff6041b7f1ece507bf27898769120114cbe6607be680a59c8803c4511bd1164cede8408f1303cfdf5ab1dfd3cfca68d3cbef0c44035c10bba715ac26cd15889879b26cf012a544858e57277f3ee0b89c4571b4408352f135e6d2ceb0ab4cf5e0db7cc7f4990afde7fdce170ddd3127d62ca6572dd3b1e1422a84ee4a9456fd5916f242fd5660ae753b8ecfe46ecaa0113446c11a69345f29918a309d681136d7b4faa9db062e2bae0f0812de6a47b88166293f7968c5b1fe038e1e9455452104dcbc93f9b8495171bb2c3573b6fa158306048435788b5f3ad6853a4a278197b41753cd69f8f5d7f66fe753dda0e7982e3ddffaa4ff3a3d30b103885e2671c3486bd76203430d5766889af2c5531f933ea47dc080c2bc61303a504d45b1009cd50128cff2b46178dac34a785c3daa8da31efd46e193b54be2a54130efe02639310bd9ac7c29f316d79a82fb963d8a198f7424f53e7491bca2627e67888b5c9ff831e5c8027b57d8c5e59da83889789e44bd2434b861b9c5e2f07d2b9a6cecacfb726dfcef883bc03c9da02dc93b2e2ae00caf413f3bee2fea4ed234fa8ce1d75202a27b333b409e6902c4eeb55a1eaca4423a820a9068ec7c1053cb238e87a4bc97f134e3a725fb5b6f1b65d0be13938a222473f7e8a6201a46778f77acf36bf8ed13815c96879dc937b8e415573e89629313c7a4457c700721417973526bc5789e994410be0940aa39eddd3a63d7bb109b4da555bc27941633f9b99def23512abef7afcc4771f7b1142869763384dd926c64faf9ba3718e7f5c25846f2478387a894284383996750ec95101a11d32a008b995f6c73c1c67104cf268c9f6564d7a981687e59cde69e2a4e5b63e09bf407ef99c3ef9fea96ec4310458d37ea88540200f1fab29c52060d0b12831332cfd3fc157a2b895c090d464ab188d7b7e1192bd053dd68a440602f0ee4b185232ac184c7bb220e97ade6c9a9a1028b11a1629f6cd2f274854a9d7ff669136effe4e5392bc290304c2451fd1b07e000508b50331a567295de979eb374dcf739594927f6689d4ee54f9cfc19fa4ed96e07270fb8ebeb4beea571e37cb3875235fb6ff6f992717d3aea70a8a142230a274ecba9aec6d29245c53998a0dc1a0e98f88a78aa9106d22611b5b3b432a0c2106c20333d06f3f3921d2f31cf5c4825a7a917ae871bde8270741241f6fed4c9408b59a70e7dfc74f3d8f200b46adedf2fee623075bf1756df44e0d2e958c9b242957980406765ff6253985dc92d9899c0f7a265175e103ab8127139f2bc8a3f1110c9f1b9f96d2fcfb55582180eb0b0497ae180bedbe4429993aa37ae8e700aae12275bdba661cccb1335bd1e46f6cbc2aad950802b18d1c2073c6534117abcba3b372e2c6d15107a092c67f6fe10bb3b9afa5026db138a540794b406ef953a0eed4bbe114926d27d0cfbc8356a160a04cd0484d2a9cfdbdf26ea3920699f3522790091d436869255489929fdd7577eaf1eaadc79103697fc2bbe661a0b07c6e97b48e37ebc31062758a15e6435f38056293fa543ca58ba3bcd7d02a624d66981b389b8ff47816284a0f666f2fc504528dc718c589d08d31dba72ff4471fbe579af289f18e4e3703b9bb6dcd3b29d953508954e294fc0c9ec05aa8c64719c0800722d3a7907621d8a7da00bcf425760f6b61eaa0ecbbd29135106c573483ec798a6e8f6593f9d31cd45fd0019193be4d28bca884efdd5097ff136fcf9658260a2b4bc0a486f4e7d5634cdee7685ebd3585989e7bde57538d66b249ac32666e33d943a048a26976a9ce69ba819efcab4404fbb5f05044083c4658b6cd0ed29024d08be7ec695804c9681aba42674d89d8481180f6327ee3b392a1bf5c056bd53ced055a54f43317f97fee1f8b717b423ae284e9db209a90941f52f94717f6b8adfcc98bf6d5f5913182fde02d467752e2479ea1e8eae6daa7bd76847eb8affeb4313f3491f4d4946157b17d282f758b8f0778e0e156573e50791441be874b86d7a2aec135f0fd98c10a5b468839a5e4e838b882c746cff8adb9b57de99626e2f3e84361ad4ad328bc3bc15039874a2038e7e964a54b06ece64fde0a7b850a477da5b0ab3ddfc6c8023abeafaa096ab54d9f6a14c1598d669b90fb5c68c6ed138a09eb46eed3692477b36f17dd064c9bee1c99ddb0aac0e7cbfa9f3abbf5ee0524ec3feb2e512bb6d73ebd9c8eb20e38313fffd8a932c2a5946e824eb051a687f50e0fa9ed4ca3160aa30bf5cd05f0483c1f20a786f198324d2fcede82e9220225fca999047f3d526a85471320bbdc26d73da69fb0d9c8f3921767b22889490bde65e058d97687d93c6069971329aaee7c1b02db4c11c2f9afca90f027fb482155ec77ca13027db3ad1c8fad5d22b0fc56a4246fe91fedb2002b03156858e68c39758ff51d192c89fce7baed5bb47213d49ecb4a60a9e44d58e4e96c717e4880c31bf2869261c2c1a436dbd0c215806db5e6b004420f2138cdc16df07bd89fb580d7d54f932b01088e36cdb485c713b0e70d7e2178159f685f30aa316e35acf3d0beae8bad16a3c154f0b1fa5838e3705d7938ece906f22f7f2946a9f610a0f66ff12ff7d8c2569937625024f6532a41b43d1639c05298fb9277b1764f5123035e530760e6a2db92f6c8cb5977c4551cf7b801b8303c71de3cb137a269f5ace8c6b806a86abf37a4d1a9f019c3c07f3cfc0ab79adc0bf24b1c2721f74bae87eac226ee79dc2c022bd80443104c5cec957a3b006e40279ad4555c1e3983e2a4f370fa7f68cf984989beaf5dead34069c8d12cefda0ef660571cf9f3108dde35c216749ec9e9166606697eae4d7f2bd463f7242a659826831af464db739829347ca201aa3424af04382bd27ea7c3117f5a55c6d49bacffcc0ef25fca5b8ea6a1ae4aa55fec618f721607ba383c63978cf5b9dd547c367c0e7a1647d3442905961d8e40e89c34eeb23171b8f18f8c8f0a7d00b55118c8ee96f0973f3639400959737a58ea7912f2d11afb50b717c64e97c2b6f50405e0e754acb3feabb69e39613d317c51c70d33c2d6154dd700fa6c29d46eec99e95a938d70a21dac0f69d7402c6b78d48f1a7170a68bf15d0e796a9d1893247d3a8ba8a18ee91ee6b8eed7adc8287b5dc38229f16b6bf709d355d57c164379aeddde343bd1afab40dff4cab722f4be91faa01af86a1dd342df9bcd1452832eae0aa9ceca14f2d0cfac8cd7aef85e7a3f108f1ce0f76298db1a61b5606f0121d63b34e4e0b86bc61d5455feefeb4f1eee43386eaafd48bbd65b7c145db07386bf556d3440825e20d8238aa21d055930373986e51fe834114fe5baa1556e5f06d64a81f696a8b692b87e9ffe19fbe4fce2e9df7782de2d3af4a1e00bc382a0200026eaadc4d37a2982d8707df3de7133de1ffe2bdfd9d4bf4d246ed13d33cb788500ec772fd1d90373361aa1349dcff160403ddf691c32bcc25faacf72d598005e0e72edb821cca8f0ea1450e161773561848b766f796921fb4e9c89cc44db59ddc6d881b2e0bf7c61806d38822fd5ba048fb2e25b03a20f3f74220d9a8a7992296dc91bb0c43f7701c849839fdc63414eb56d768c7ade20010b0380bbc6c249b457c2e239d115fb4fda602f5f62c993927eeb50856c913f866c6e19d907acf376baced34bf6bad9c786ffac79536922fdc9c2ae6adb7805b509ac3c4524cfb07211c8577ca620537a807e93688476fa76d6999092c899cb6c1a7d1f8a6e3f4bf23c15dbd26c5d5b3b04a61152454892ad6eda2d40e76cc2280d5692f9bb8b7c8a14d5022b6eff9ae2009d0baa376612f57a5c4779f136dd0cbd8fa1f42e717c065b130216ba34dab1420e6daf5df48a02b88de415e2e65862e2fc96e40f964d583cdaedf93c771e6cd0b400448db1ca298ca32a078505b9df88787e304a50ff1294459bccb75e4e8043db9b54350bc590e968e0ed882aaec7f9baacdf830f65355873a6cb7f6bc898c9dea3e3579b06560d8b42bf4660f761138978dbd56956e5577e4504ffb14accdd4f3277f2e59eca9551b0b7aa7e68e99b30dd650a167fd622ed5eca67191ffdc7de37975f240d3fa05c5626e625dd7463a1445d358525458352e0f196eb594c73b361482e9d6b2c82dcd34cc798c722d5519e8b96a2051663452f8d0a81d0cc2451c8ef9c28cb1093b57d4c46c7985329102b8ca05b93578573a0b102e1ae9dab14c184a662fdaa827d051be43279d1057f79da03a91853ad425e177ef6a593d2673340e5b3e7e8a8ac6765868ce2571e2b6d044e13415de14c6ee75b96b918241fbe9d66dd6ace1f1db5a6ba512f6dd521d2efdd3eb73a7cabe4b6f7800a7cdd52392962e68ea05a07b1a0c17b8c8e7fd73266f370e36470dcf697f02c5449b517f6037e63b59ec09790bd2118c87bf2002d046d82f5f21386a7ddc5ecf524d3526a714af989e9949a15f3a386cbba6481f6a2520fb409c545108fc4d12e2df6e29bba30262ec0043376b986891ac2218d1aed582003ba9beb713c863eda17a75403ad7b140355198832b3d52aec01093f7bcd61b6acbb96867612b2e60093f8baca9fd77250843bc9fdd354bbe9317f37a2c8b83d5bd792b426593ae95a2b6278eebc815858319bec813ccb7f8d99759a4ab5136a32f43063cb639b85fc49166a9a8e84ebc3e21ef578f86e2e95b7f105ba60635c4d7e9a7306390df49da4832124d0ccd50700dcedb78a3b76e7f4ad5c05e4bb252bfe87f08d95cd750df740ebfd1ba31c4a83221e424162307e73a78d1163e25d4bd9c3ffb22b42f7ae88d056e61f305ea0adaf7ceabcb5c3a9b50ac38a0b002334586831259db0df6281972b7b89466be51b319fa6cab94ba26eb8d4a08c6c4d1c0fa6551cb3dd90a2f11baf4ce43c07c93fd514976d899b16a3b3a2230174ec06afd0dd2f3f5cd72efc521d7f58ec39920d42363da5549e11cdb30edcc56ea564386366bbaae27d936d54550c4fd79683dbd8a541bed70c4d3fbc34f0748115b21ad945a0b79b655dd7ac180d22299f6fa71f8c37cd5cc60fe26760e76cb824bdb17ad38e9bb2420160d692ec39ded31256555b6dc00ed5ee46165b5270c49b801145e583f61835c1c6d63d6fed43e0f909f66cab5081d357365c86989a5073814170c26b00c2975c4f86acdf1ac6df55cbdfaa65b1dba23b0d22e2e7cb13c70200a61237a36b4d5d916468888f37bb6d2eaccd41d8fec2ecf2f1e36316748ab19c004666b290b4dfffe825fac187982c80cf71f7d07f091c5975a42e3bed18e6774de7d4d88284c98c4b0b9437ee473cc6aba24a6d836f9eb3125439d1f08b142e2a73898db800a9f8de8ea5360cb2f303c53460036ce65cbfedc480b3113f1a16ef222dbff9373c8a02ff94d0608283e429cc93788b5d1ed6d51e6cb172593461f354d8b11087d2212c82fc6334259cb226a7c1ed7e6789441121261c9ac35fdad4c5be2bf3a6ce061431411d9976b3acd85095305ef188a5a6200296a39e69559b68e0618dd542c06fcecca1d0bbddb3939b166ac3a9f72fb944ba81d52d7dbada28bd8090a4ccacd3ebdb160ffdef81c49a4423bafe96b489cf3ef2415dda4837d19f7e6bc39e048bd3b44e245ce64dbcef17cbfcc96ff66b8bc2d03a2b4f0611ab8decb13922d7e123cc6f2378412fd8c5103e0e3df6fd0e8b2a81c2b8d4ff3d0e0e23e25f00ac014d37b0262c8afe8908a26ce36ecb7677b252a0a4ac4ce636023a76916518bc0591d323bbbbaf567fc932ff2535299c3dfab5fa681a33d7af8dd51e89cfdf72bd02f63842154186d045c83882ec789a28034ebc210c9bfe91bc90e2e53c92653096d5e307bfc3a3012a8995f52c9c66f367b1d2bce798a5d50b8de6d6ea9a7f59696edbc9bde13e9256066f5fb8823387a7ef346f98a961b5fe3c53debafdc8057b9e9064a531760990d3874088cd36c7bf8b74efbbdb8b05bf2626dadb26fee471820e26f111dfbf3a9798ba9e88f3d6fc709049da8279cd23e7bbea441465c8e9e78cdc1ab27ed843301f6804751d2eb1f40ea59912750088112817df5ed10da1f1edd81edd3440c2df59c3bfe9654d5c3c055471d144f6d34661ee82f2fa144b5c0309eb19b8531f203fe265596671a44a7c12efe19147aeedb2221b716629a816f620f06a23afb74b09a4edbc0987fe4112624f09a75af1be9d088cf2a31ba9a448c036fb32a1c6e9ddae1879461eacc2224cdfc53b7f87d675d943275c5e4ef2ff58b4e407931597be01a98339ddbd8f23db28ba9a4e1f149c562c7a2b66efc7a065b05c7410996d2b889628070f72921713ba5c9281a6657214eda94da2e9068f383ee101b8055cbdb330adb9d47cd8139e9bbc5f2930ef7451b6549b3b096cc9848cb88b0611fd85bfbb9f834136510b0e0373756ecf434f952660a80ccf473af123025e19275d5eb2afa5499a31e5a771d2eb66b1b3d31c9d466af42046fe18d8bc3be7a1f9cae3610d258c157e4708312ceb5ca327f6a5f07434143ff8a0bae63d62321223ddd73702622d18d55b6a7eb767d4c39e8057452fda2ae410e1b5f25f6498f539e8c712c4f91818abe6f3d3a3919a054dc22c854e3d9517991e484dd7ffbe4964f21a2b19ae72965a09e0802e80e7ddbd23292cfb35b4de2e3321feecdbb764e686a5fdfcebc8007d9657485090fe204cf3b0237369274a0a53185401e0e50c8bbb452908594ea11f9ba85ad36a7e6e9c291513c30bcba688139aa2a219f809015146ffded31fa1a6713a335daec15c0e46430f8b81a41330596b4fad861504484c32675f90ed5bc6097d0250dc47988f7abf2019c855abcc3d50c5c738c26b2a52bb0ed636e2fe749e96432c7b2a69f45d372a9f6ec48c70d2a63548da5154448edf86bcf421f02bc9ec317749659134fda9aa5c384dcc5a5ba254d05ebd43ef2c6738d3ccf137ff15fd38be13757ae5888026b0dff3153d298c8e76d0a216b7b2981ff93c70790b71038d6cb16a6709c3a29739db949f635282922ed5fff4be09d48326b0e3680a05b69cfbfd20dcb3d7d24e2f1dcf23442747cebf73d5e65ac8113992ce5df727141a09bebee0c340cb339904413ad8a642984ef520cc52d0020549c565a8d5d0c7cc9480d61ab17231104fe0d5c5ab129e0c93e789d1a71dc5bd0ab8d2db7c19e022d2535e2a28adaa98e402c7142d1dc6477848a6d84bc87b4b01fd4e69a77a5f638189f6b3cee60347c316505e9ca69be5ec467b42f2070c492e6bf8d43bcddda03a1f97f42085a7eaa9a6782a49305a5cb254d631a1eac95e8b45ff9914d747f256149ccdacb4305072026771c8113ec1be5c67841a973bdad3c0fe095667cb5caf0ad36a5b969e1b4ff0d16f824fb03889ab1ac9e08badeeb298f6f591e4e85b2cc9db116496bbf1c29d24a1504e9c34411af39088a38548b39966cb4865366abd0fa80709286a5fb1f8191062d45e23083bbc20e580b6bf93d877b17fe7f9baae9ff5b4dea0d4c33c57079731002d7ea064d94539a6217185641b0db1a56ec27503c0ed0eee7ca2b7373d4759518a9cac5d4e01968042b93c5b7e254cf4fd35e2b49d38b025379a3be21c9bfce73a2014b1e0e3f52c959fb663abc7e4ab0ea768f9d106b90a2f1b165ed16485c39da987e3419bed552119bf9a4ae0ed048604e0634ea57c3d76e1629cb2b5dd79c84ed19685833307dc7163b8ffceda9220f6857a47084ea1f7725fc6433da1cf8994f52fdb647ff1d0e109824e919180700be5554cbf48368766a56c5855e01d7f7784e33e9c9a80bb9612c8ccfd51561fae16542e0f460438e4904db8cffc0f1985a899d81ebf36dedbe6322291b1e09a1290216c70162024834bca200914ca06491819b050dc4e626230838a000f2f10cb89dc6c8ba59b278ae090e418f8f35b2b61f3b6383cb470746726d61cb675b20ce80cd8e3a7784c5327500d2a096e2a5baa91b1534eeabf45d13fe726f8a977c2774d6102331a20fdbefb315d00d2c652873502a7d44f71c9034bda833a464f3508dec77127517c04b8236b964e9fe492e550200c0bdcb65ef5411871be0bec5a2e58a80ba61e16f4fdbae3ccbb3e0b09ed6c8a21eedd5a997d06c44841c2c920c9a840704824484dd2eb89cdf9748f534a6d937cd3d91ffc92429fc55dfa526354918c3931cc91f6d24fac731e2685e058c9fd9a3092dca656b3913beaa9a3c2d5dc335baf9bac58d1c12fdc4ceee6e5d756ec7b499e4b747ef2ab847d3d738c4d0611759ad8a8ff1ce4e11848f3445847963212d1ebb7e6a9fcb9938e25ec73f3ff4afa49490ae61077a4ee5323850221a6aa1883d0e757397cfbe2b1d8b888549f9d4b6c7ae9685c5d6b29fb9227ad5d15fda67a9229942ebe88ab164524f9e8af18349297fea9894f15eca0508f11c1369d9173374e1ab9d9d288b168c0ffa4d9db2a72f30438939b7abb614d1296ca1b0dfe5f6fd5e0cb3ed40cc84aa782d7a49d7cddfc6aa02226c39295e8ab760f9da453a9755765fbb0473d82bcc6c4e53b14b18decff3c52c74ce7bb42994f556a17444db41979e597f82a9a54fb69ac69788b8606bb3258c73f4b1e4a9beffbb7ac476969c5a86c33879c91f62a70020e316b0adac6264f266b82f2b643191b70733cb3995799b08d741d83bdaad8ffa5a212c6207ff0e54de3f3288dc4936be9c00661611805e423187378d7f9991477b4f2ce453016654c2dc828014fe1c4ab3ad67a17bb96f11cd2f653514be88a139493f4c8d4001e963ab965b8fcdf06dcf47f7c24066577a90d0a4199b1ba695f0a645156567253daf3ed30e2bfe88c21e25c546db0ff6d79af3d08ac188c1baba3a983f3c488d87771a0f595d18388400284d0c02960a46aaee9cf95db6f236cd15fd8490f393b1418a1cd06b15f5e4872685109821e8ece4e528d61dbec0a5a0bd8b1a6c2371cafd8ab6f733846d35d451ffff5637c857e78a580e7c60b32ff3d2459a008820e2022e0e8faeb848dfbbae758ea2168200deb6f799c3fa4b89bedf53086bad632b1b9a29899b1cedabc29049868d89c8ccbd50dd30b1fac37d69f3fea1c497471c3d25eefadbd4cc3034c4bfe42b2924b67cd36afaf8d756cdc2a1274fcd73497d20f646e3910d3840f49952ec863a3a5ad44381864f8708aa62105d2371d9b57588e4c51fbebf0246184c6345b86df990961a6e12d2f01df8e0b729189a034341fa0d614a6299c0e5b24c377831d038ca695d8dfc7b8fb76f4e8f4c613d38e407c049c0ac6265c338db9d01c899df01f63a96a4d6975834a1c7cb0e63e98aea465adff6a71c5b54427b01794c21f93d5389d0d524f1d66368cb0f0e15659604d3cca08ed30bda135d3ef99ea1df22ec6b5f45336cf06472e74bd2d5c0adbf31f60da4ba16f1a5e11d5cfb89161da78cf84b2d794d60d876381a6adcaca948ea41a9d22b8937799023fe4ac437746cefd4246923607682c1cf8712b32ef583b70bbf84802c6798ca92b280931c477a5f521d755cf792172735d7f54b894ea47b35ada15e1cd0b0cd0ca6cb82538181fd3d9153db6139b07376a650c184a5d3121e797c2cf86ca847c0ea191c61b9e31857fcc4818de6c55e29280979d11559a3bc94897c785b68c15190c8e4291de8ba01441839381c312b9ca9cf9b074947fc5719cb68837797c92d2dc429c1d9945a610f657c9651670ae0fc044fe36dc7ab0a5d142cef5246b8e2d5f4162563155d43c53552d538e3f50f4df64f7813a625e70b558d7cd4fa58ef223b2c6e020d430d2868b63d3ee5cc6a09d86276d3f0d399e825afd36fe4ac9905a6c6ac08e795e0c57dce701cdc0a8aec775b384e5aef9b5c8283f747e92b865ee9d2bd301150e474065b21b5c3abb76846ed259559980956679be925e0b2a39dca06d8d2d1a132e90c2ad707143e3ffdf17eded236edf57637f3001f5794f0f5ddc21ea82a2e06d0fedfaac42c013bcea726e0a6f120ec4732627043d097888fd2ab45de98fa6922bb554e51497357d311bb73e223d932e36f3643f56e7463bd685633e29a9831061e2f94ece31bebe5e7a91d0e4c3d15f81b57ce581b436f9dfdf53ea91b9970f3a76ee96f9661d0a5ba5951cfe057fcfc10a260cac017db3d91a419c86b17cf6807d611cee25fd641cb1de051ca676d9535f3f5712567518be34755551517b58c0dbb9468eea2ce645f76cbd4749ea40e4a2fd20e0ed2e36ba634007572e1fabd2a43df161f08c2599fa9e50cbe5204e1c1ed92536986e12d1ca0d5eea4bea7f49e204b77d303c7b210149445089e5f5f63c8ba1ea3a36f35ad1d233f43f16be7bcbf76bd1082031da564a0e3819da1f015507a1163e34116c874c08ba18a2c8099fe062bb39442d9e493018c54c0c3f50478885888825378e90de7f76eaf2e52bde3120832ef89b08ac722e6a2bd873d466c0b29599674172495d706116603f3892eacfe6b710be5d24e10b3b2ace6834b0144d4a9f4236dfab9380aef477938fbc120e395c38a5972d759040f667950d66107986258afd3a17d876508423de7155934edd3f867307e51c64f2942a5b3bfca35430f916a4c40cf05e0d09cd957fe0a3280ae8301c1642afe1807a234349b054975851bf9a73c4c065748cf608583960ee943354dfa03713c262dc1dd2fbec066355e8027c1e26177a7a7c4e5f1481dd149a13d3420f7089beba9b3231cce9746d3ebc5b26ec6edcdb88a1ac1e1d9a6e2c8524508d689d43d04952cc16afaf583c50ea760ca921cc16f01476972bd638a34bfcec8cc213e4eb728158bd992ebb7b6d57811715236814351d57c22a000d1bdd8bfd7b7b74e8608830835c1fc3356b302b234b05e78115a0558a5a21c36bef0184cced1e210880b9bd88de2355c2bb38f2ab3043e8101002bc0e54710c6edb820f8ce08e09712d7dc077eb9c6deae61d4d675b3214aef622e9031840fe6bbd462bc34702f99b6e4312eee80934647446a1d1f56243712dd17f50812b9310e77b4469548607af52e27eabba07b2daa7d6bccb97c4e712c208da5345b2786669060fa2f2fed55bde0d93c70d56a3130b2ab537f02f11935b338bf492b75a668e6018b75994297ed1b4ac5f0e3b58f94027db5660a40a3e09566b21f74ed0cea381ee6a251964d18bb838a701560edf489591ca211a832c0f31a6084d1a502ce9ba407d666954e9cd3adf02fe470287b2cf1bc99cceb82abdde2159e06ecbb99fac2a85812b2d42087e1e57d2d7bd5fc7ed7b986a19af258d42fd51a57534e5c608780b07280f1282aa4e5d24481adf1120474d916ce6746a862f7c8f35c90eb5640c993b7cef53cd1334bb5a86870a0f835f866ae0e400e9bafaf07003d798a761fd3793b360f6bd3c6b4a3fb396aeee44290518ce88bd48327e6ea6b25646161275c4ed847e5f83c9f7f16649e167171a976a9a4bf8ac7a595ef69fca8c473472889dd09d34566ebe87a4524137494031463033a3d13caff9e5e7c4fad40ce021d19f8b02b67810529a067f5ed0262cabddb47bab47df7dfcd83c13da212f1dd4f5d8befba6a2a4f5bdec70f24725f992450071bdf6feea2a46815be7826c2dccce0e10d28dc2140dd9b7f3192ecc6927d5a209c3d037b0409d898c4918248709d639d639fa2092feac3dba46ca50ade76ea5d84590dc8030b69c1c321e649209e4ca030ebeb5d65c5409101be94d58935ea2de2a5a38af76aa0635b19e8a4df9d62f4f017912177656a30dbccfd543ecbf9283756589b907ba4932d0ee54878d884deba708b254d99b670c642c3acb0cf3fd696c560375a8e333902eab29c396fd7593397f944f5c1d430d567b2bb36e50d52b50f2dd99291587ce5259b40e9bbd549e34750cd1214a3d8bddc6d3fc60ca8e00240ee24f4fd080e4586af31ca80362e1014e2a440aba6c21b55b14e3566b393add94c62dff2501d25f0a410ceda5345b8a25620d89e9db114b92b40de83158835efbebd65eb9b68754338e949ad03896bf970770efab1b43a6544d5ebf211c926f6af5351f93c378fcd143b3689485f21f013e1b916fe362f9d90eb02de25640d2bb82d0d8742cabe7fec8760fc91d0a480454a35c87f7fba7c33fc38631818eb47e5ea7474716acdf752e00e87f663b0b431f7dd5d7c86df5ecacd423ecb8ffa84176666510545557c4de227090c44f3b9be40afd342859a45590dfbd85e1776fe86afa3d2804f517dfeb4a75cc63bb453ad46329b16c7aa4173bcbd3ae8fe4b9fe5e45bf7e7c1a45a510da199a64f92fb95e655477c5b05102603bda60bb7b6557800ca7b79f8ddc4da70cd0f73abab55d0591fa08d0bb905f967cda7e88f64438c4431bef53bbdc03f07c829f03da35a940426315325055026a8565abbfbaf49168a2111217686f954bc97d2aad76d8742e343aeb61a1715d1a9b99996cf94c2c778450044fd730ca8bd64cc6174b2f98d95f2030cf26d70d7fe1a11c0a75169bcfb9fd55c9f6abba3ddfdc6cfc4624c48331d6ad7c37d4ba31e12a2d37ea1c68d42d72ffe345bd60f70a205146b93e53ee25b867c92ce941efb442989ecbbafaa94e46040e0766bd6665bcd576b136ace89ef34647590b8d2da479d7d3f657dc754a34b8aec2792a6dfb815d257108af5f323284efc165a67b5182224e3d27f89c2bf3cf6225c3f698c0f28fbe41e87bd4e839b99972650bc1a113b80354a6adbfcaf1fafd0efe38ef7321646c4b3c07445aeb9ae375d8262fab704fc50f7ca2e8dffdcbfde26e6dbc8cbfad1836c52d00a156fb60f64ba0f304c44c084dd8cd435f2f518ae4def0c49e08cf9cc696dc16a7f7f585a5ecc16dac98a0e020d91ae0f00c4ea671708e2816864520ef5b0274bad9266e4dbdea5029e4a8892db1bde8691c32490f12a3da13b6c8af8f773f5832c0befdf32d0808a6e59137f7383a71d6cb232597a7902726b05f271347d5e85f06ee172890939fcf15419ad8e3bfd7dc7c2be6573c3cc47a077dcd8882abb093ae8ab50e5d2dc7134071342b4a277a898d525435a856f120c6d4286e3bfdffdeca358d849d270f75db0438eb39dc7118a389e86c9ecd1c06d9011dc17bad1552cc10eec0e986afb34340d388b96c9d73403703f2260b6a8a5da8c07d9519577ab77b29240ea8351c13ca34c61a5ba90cb09ebfa9e2b566a6f4dd6e86d24a88eb964cbc2bf79f63e76b9c15d230c4051da3d1b36825f6eecd83c0b42d71af62044d8b2af16564f750d7a6999291e35e07a4d12d73b0fc0381113bc1d0ea8a4e70416c2f96b52601329f23c9f8a337e1addb2c90f7396c56e791fecef29a66643c75ee5797ca78d8d8b555d4f205413b058c119648b8e5c2a3a3be9592f4684040c3e92d21729036c4b64f6244f1ad290c37122e5b74f0e74d8a1609a09ea1017b9c0c2f0e35076b9cd0256a30b3999909971736a16a5bd98fff3553405b02da37d97afcf78717f6441864cd0c09a63ba98d3c99b2e4eaba548b369a9fc9c871d053a88ab623153d230723118f04fd07a84f324e9ecc67abd85d16a1aa681f49d35c1a3d13573b968f3d5df6c10c3dd97cb8d10b0bf6c52b805138c7c44485ce97dacc238b165c2b97e1bb3945e524e28f98d3c41565c796307bed9a4b5c465af58261ee8135387d017d17812e64384e0712ec869dad5bef244d51703f75fb075b6138d98e44b4c8c3c389c48153fc1659cdf836e61c1254812e9cc2a669338ea8b8440dec1a63362be6d1af2aedd6e98c66bc7048b5e9d64a8eaff92d968d3a89d914a1008bdea51759eb27029ca9fe70389ef4c03ed356cc0af8820b5bc52fab8994101dc4a04b4f6070466743130c8ab995ba53e577243d6a8c6ab06ae87a315fbe92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
