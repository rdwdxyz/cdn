<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70c3b399dd3b15e227de80498481322068591d43648a207f8aa691a6af86ba382f65178f28a13776206320ed2efcd80574fe08667c41d01c74dc99e041dba5f3167c4fd95987578b265880511205c81b6d404f56e0e5c5529a9ee8d311fbd6f93eceb99a81bd2f9bc6953df80b9f3463508b982f5b1868511a29c645ca7b7e5922ca556ce4aae723c232f4eb8cbd5cc85edbad09c9825712aa84cbd11dd7eb35adbc6df2b562c19db1dcf673373944d7d4a60c687e3f3014918e1f7a64503f9b061bf1ac5af802ae89234272036aeaa6d1802aae5ef6b03ad2f585c632d29f7b48cd783753d8c9f42d1000faa2f52c21885b28fa844a4418832c4b24ac73a01e30aac9ebdf0ecc0e7dd8d898f666b70bea23ade4608db7437f65246816c2f09d202bf737522e5f60aeeba0432c7445093bc429e542a18c255991605f67091bbcc3ef3a53a9ad9751a99cd72d685603b0ff648d41d1d759be385750b40750b120e4eca558b5e6c04f380cbb2e487132d6f0ed53c5e3173b4b7829e3a580af870ae592f37609c800e63e06425338fddd2e847044bb8d9300679a2ad25674bb1b0e1c9bfa1b6d7ec204e66e4fd305721ecb08400bfd46872f99ce39777f45e369f7d7d1300e4836517314cc7f62e18b0aff98215b5645bd46e26380fee6e382b8b317ddd1d2ee807ff481ee432780b916905a122274aeedd15c8054ac9330c583b55cfc09607c99d52c66f5cbd9dda6b0a0a446d8d88518c44b2d29c0e1fee96da3e5af4c6ebeb80037e0420c371e171c38c536ca382a10983b905e5b5daa3d639578c6547487cecb526ba92aaf6f6954f28e36c51101dec617493b021de20e89ce52cc93aba7bf892219031332fc11d1aba3aac7d8e244e61596ce63c88ef14dcdc7d1dbe294de3badf2eb65f29c90e75ee305de251b15236fa23a36d11d7b4f63b709c457ad2d31b4ce6a5c6c334229a9a04e030d746c15b7b9ac59f42f0805c3ea3e4d4d0992a07bc2c193fc4bf0b52b8fd40d82d3d4f964c1dfb7cd68e5d72c938879f42f4b6cac443dd0597eb13057fef5c5153b6fae180db1b2f61f19132021219ebd43b2a806348f45ceeee1107fcf5602af59454e9a3b87963e985b4d368cbca84ab3f62abf8ab5b726c0052a4d95fd182a645b77c9d146a16bd25bf11ec1d4ffd88fe060273d7d021fb0a80a3c095450b159d4c4a9f46f85a58385f589be5ef7545764a1ef9963c2658ec5875f1a3b8e16c9918241817d3f17a23af4b86b5a14475ea78b5478d58c042fa76f9d8029f50f9f335d2f0e858ac82985094faab8b05e9d9377d813f81e1e03613e4ee4516f76523cb5b069fbbd2a939689772d5741d3ac3cdf87d51f5caa83c2749c2236ae0c8073f49072b1c709e5a09d99badde6ed287bdb4625faac62e06ac003fc7dce1cdb275becad4cdef5adcc1f9d7c1262e18110921c76e87f1ef7b96fe682bf082b49edff14db96ab468fcac1f7922e05e124a1dda783d13afbae4704a91f7517cd022b8d32839ffe3d17bf64b574769e35604f67b7704610af1abee3be362d75503d35921943f6b77622ebd10c9f1ebaeeb4a3fe45e8dae098cf1302ee139c3c127175b4d63f54a7c15c7426d7f840c488bdf19b77080aa26013aea5915399e173f8e58fbe3ed31e653c73fc73db8e9250ec1b1c65030b65fdaaca16f2cb4b311c55a947b469a2b0e7844921f52200b1b8d97ed3d0fb87f4cc87851d0ca5fd670ea033738cb85cfa5ed9da6f61ab5b46590eab2c37f18b8df05a4b7eb75b5b51d58da4b3539f44c274330deee5fff83baf3529ed0055ed675dc3402cf4b51b7df6476d3a6e6efac4404fa62775ebd39b06f9d7e39d51ac209eec7bb29e3ea6e95798455457805b059f946b539a2bb695223652e397f63f1706aa0993fd82bb3e0633ddbe51f029fa1825741985402cea53e21372b8bd66aaf7730ca7d0ddac35e2048f10f902bec6aeb3bd3f1d8780b73c10ac5a59859af095a8ffec370cd17a36d9a2f98024974a2469a067c0ce35b07dde4cea2b4d9c1bee8ccefa7d2f6f62bd622ca46e19ec4c89009a0e316a8ab0066c38b92a2776b0950fa13036b87fece61a212d26c09733169ea00766093c36a1d83eddc9b9b5d2fa1cc7dbfa667f8af34cab48a519af7fde5693f9cb732ef29b3c0d0e57becae37de163ec2b9fc545f7360b818e257582d3f9520f27248a601eaf4d53fbd6abcedbd0c26db47764cf46adbc8eed02a1b58e2afb0989ab13710c9bd5b3a59114a5fd139cd8cadc5a7cbce5f1ddd31f32fe11054d92e38f817a59ab007891bf620b9405ad401d9c3ffd5b42317807fbae36739a27cea6cbdc0787b4ecea21f4e33cb7a721860162e741aa3f04915a794803aa3cf485f7f9b24c4cf18dea5d389f187fdd13de10b7005dab16937ad0a16b001763082dd8e904d48e7d9ad1df27742a216ac5bc1ee62ea7c84d16ee95abebbb0f097b857f8ff6808668637492f63837112ff9f7f418ff7e03c3b7e05fb27ffde253f172859c0f71046594889f9e70ec45df2ae6fdda32b16b1b99b3a7782478af800b3c6c00827a278bbb69ab9549b7a94ed185b48a13541c02d663fa45ddb1d3c6ce67f67e7cdcdbcb16cda4be683ea0d5906768c605943341e85444bd737d62ce04237547130f62ef9e1c86fa5f564c5d20a8d41386b39102a4a7eb2cede32f2ea52a6f07c443b3a58e171c2f0cb196053a562d612c9ddc5cb9f87508efcf31b0a1d47172675c66acca4d37960c48d713a0e04b12294e4c6ba154ee549fc739439a4a0b49abbd7b56b1a1259d0a2265aafe8c1ab8c49fcd51ae0556502701e6d1fca7da2309355e34506e02ad44fc84eebdf2f24cfe1fc51abdb377d9e01f054fef9e9c9c6bbfcfd178e41884ea74ce7e24b25f2dce20b282e119097c43f84c4a2d2ad626bd6724f1b2784e1be1c42d5e7eb66b6b749802bceb080a997c7f1e2c62cfdfd7c731b20217b1c7ad478d7058e2f02d96baf149470733c13080f53d8f74fcf98d92c8c8cd5f9b37875174884765cb215dffdb48bd0811a4c748b876d20ceeb9c2e9885c846584fae5af4a616fda5b8b4fabfff55d60e40e41cde229166f85aceeee594fb52b667bcbc98aa07f431d3a0a92dff4ccd89bb1c8377ece6347829d74c1f465ca0587a6be12992e566f825ebcd72f39fd6cf688bf9df14b6b8f94f78bb4ea0fd4197a575c5d87a5ccf0bef18e9654f546245ad8190e3b57802a8fc75d08d8f121fb8230c967a9bfb3a912c2bf6f94cae89e5463b5de3a79b35ed0515852a8f3df58226674bab64e4ca6d3b72dfe0f721d5a5fe786d85f4a8617cfdacd14b0d0d931e1626ab1278455eb892281202f80d4f84d45475eb8abefba1e285ee1f3c54a1efa608463b260a13f87dc1b373aa7c25de5dc24d0c0b3f3fdef4ea5b489155452c8ec6f0dce20715a2491c4a6eec993ec7b164a6e0803bee99173bb4ad7147790cda99fbf2df352f94a92ad62723fdbaf18eaaf29bb82a95c36f22da7311aa2d438f5887a0ffe66f1a1f7cf3cbbff036c9e31b07eefa54f77b5fcdc9e4c118a4c1f62085f3663b345e3fcbdd06b29f190e528ca7fa6f546ab1a8318d4c998bd5805a77c400255f320e33df81da00689f703d2c0759295c35a2e956cc69d335e3fad9c892ef762d7d302c6a2fe5bbff8b1b2a44e24f26a7baecea4dc567812685cb25f0061174b33c97ae7a90b42ff104e24c44b3beaeea54c1b8b06c0b473fe8ceab0d1f6d46e86cd0967d47d085b7d6ecc3abc0e2832050e4e7cdd02938e50bd34eccfc2125cd30d376c424271f43f4a42cfae653b04899e955a015e7ee9761d6f77a966dd7bc2ea90dc3ad2ae7fd1edb9f5b200b466281914cbd0b20a4dca3cd3ddf5917654219d9ad14273ab9d8eb8ab9cf3889225e93208ab8b02f662b2faa50449cf41f14aa0dc33ea9d5594942479daeb1087bd09d96c8deb4c6750087d95a46e69125c32af150fbb90a471686d8adfb09a23b42ecfd280109bc773918259803749f1d5d3af1681e05ce92adba9528bd10b91870530c45120064df67869ca5e40819a29c5d3270a78174853c46b9a2df1aad28e56d912519356a1ee73c46119f5687724d2b3a42a8cf2b9a87931e65d5e49564cd0c9091386741578ee65d01083ad615a7841451d6f898c94b23af6a9f163fc99d05d7573000a0d8e1db58baede045f0a0a1c1bd4de1f6b3585a8624b310510f6a6494b01cadb7b4607b78330c0f795801b95918983a8cd054f0f2366f2d96aa30985b5f82f7c5a8062a4cee7a2d221f8f1ba4826ebdb36e1c4c6b249f70db1300b87a6e97d9c42b1208dd278c9a50c1cd75814cb4224b4f99e65a00843a79c3d2e63ecf359497af33a201abd9b90bc911ed357ca7b17875f7b520be08a217237fe0a11a9bd10c6cc63209751408f8f14dd7d709e71598411e8f4a6f67d8a2def061f0d6555ae05aa774eea41194c604e6f24bc34d24770c649320a99e87381e3dc2224ca41a873561450ef554923b5114841071e60460f265bb82e53dd0ef3fcc1c05e034458e0e4fe91f404dd556aad2f040d9f3f9fca54592e47429494ca7d2b4810a7b8d55fb1637b362eda3b153bfadb3c630cce1916dc13d52ceaca16b1ef35540a60684b17d391d6ebbf0e6431028721943dfbd8fce4de2bf66f70647d7949abfbd896b4613b68a0a8d5ef943d55cb886c062e32f9f1d700595c68bc09e8fef72696913f020cac90d0a55ec53038f8f3f6aa8a0f239341d13ad22e4823a11c4b0679d9a81b41378444d33c96fa6e4db1e1c5682dd846d5d7da39d52445716be8909294825a16b184fbf15852d1b187b932ac9df7ef5e1b4b28a870f3975197c66e4e969f4b6c962b255df196f7a137e6a4e3ff3d38e617e591b0cf0109454b7123cb8938cb35829c8b5dbfff549b81573617bcc4916017f05aa4221984a5400e838adfe1edd140606c7a194764968e830709db51dbac8952c5aff42dc67c0c5e0550f37a193e2250a700ca34f0d725dae0a24309ca749871aafd064d0498a168c878e5475a9165dc160ee56c655315208bc92eb384a276eef4106303b7bed7a8b36a9bf86a1849ffcfdb7463b74a5c9693973a1aa426143683968139337d75b758a27193d7a16dc74d8d62c2ed4423bccbc3db0a1d53cbf108b0418accd9025c413054ed89e6e61aa8e028508b1166d09140cdf761ac3d51a1caf1c21c76813bac60b240acef3ae28f51e3f03029bbab25531c3d5137fc16e3cdb004f2e3fed3b9d30a9530ea819f8ecca49a2fef539ff7af7d2d845e1fd143a017e8e139b4f2a7f23ff645d5afd37be27e769b31264787714ad431834b9ed5e0f48bf17930c6ebbb6def89564518abd8336d71031c78c54dba83c37e0e6d68d1bbd23429d9e57975f44c4d4224124c1c073bc16d8801b18e8a7466887201c1d8aaf053b25272ea152b689cab124a52234c8a68bfae4318547300055218d374bae475551dfbf4b64d7fcabc6e0299b74f797ec841dadad126d07773259710c0628cf5fc51174c236e3fd92038bc96c331c8ce2d32d8e4f41f1bea8dfd3edf3468adf4df1ea248cb9d7a51a1712547f308159c463441759834bff5f9f42e1721779db83d695a652687f6ed51438c2bbc014765abd59e5b666039d502e338c678a621248bd125c6666030a18a9acd96e509403828b878708b51043b8280d0b67ec8831a071616ee107dd60b9ff5746eba617ae1b2776269b1bf9754b888250968d4f7e5dbc3313d2fa57b69b2573fd68d9863852bdfd97f504b2192c8415eb244368f6e323d9fbbf662b60250270d2370c62ce844db5ec77fd96bfc2aefea2ee7b253c87f65b61f1357409783f0eb7a2fca48eb25e3591f84d7569c3a9d6f610756dfea89ea5d7e291f7f8ec48561d0545f5118b4091bd22d6afce13e1e5ef96d8e0b33b3a9cc97101d8343449d6fa00ba90fe604fe0618c3aa69bb0c7ea14befccfd4053f05d0ac5f05269b37201ee25dac1a85978385cf27b875c58bc17709d20f2a3e9467f3c541e4a3b2ad56969ee7d4aa76f6963562af39de98d80c78bad4fa93ecb006279f5713631a29d8a01a40b2686f92fb0478bbc0db0e62d0ea12f4e7b5ae7f6ec187ca410ed26bc8850f57eb51e3c884f6cfc46fa40b3691e72a106d8f0227a7ea285f51ad543d03a1510e71725cfea81ccafadfe42890538fce0725d55cb6cd8b7532831b36bdc9ed8401505f873fe38d35dad42aecdef19c2fbf57f02fd294a567b75292540987b2ebe5896d128f9fe64fd8bcb69e9adc7c1d104d368b094dff9d43b7a8a5af08a58aebbff369164fed9f851a2f7c5368a0ebe1c02030f980da524df60dd233a125dba146de509292ac23d143b251e817ec91c74b8b046ae07991fe1223fcd564fd0befdf2cb95ebd8e6be272f0d53d220e2dd7ba4d28f06005e05b674550536a7a2f8184eb529d6ab4a7e7bd902f64b4ed00238ba8f0898a473b9c91267e53a26dcc1abdfff4f02d27606d6cc352b16f8827b20a76112c538458b539e1d8fe472a455fb5f763f8a97b5f8cbf74cc4ed8bd89723ed2081ab87b88baf96b24c91d5f9daa8f71fd4ffd4ca6b5152b49b0d5496a25dc17a3178770fb799ea636c21cc804df8d247ca60fd34167c5ecc54cc92936aeefda53548b62d31e40dd795979469e7e718232a325312865b868cdd125a77b75e8db41d78115a86150d3a7e88a1d1884754577feef5393e9f7b62af989ddf61c542fb2f03154d4d6a9384caecdafbfeff53d96153387b3b3baf367645f214b4ab18afeef89aaf9bb95cd21b0f39efe216ebd8294de5f27bcd61931786aa67fef2a3769beb7e9054b7c83e43c122702cfc880e86317521963237522f4d77ee643be865f887de338ce16d5ec3d971de987341c6b35f6eaa020be4e3869f6fbc0a9d4628349fc590075bfc568368d8ff09d161f83a6963c579ba888d158945dd27811a70c4dfd467cb31fbfeebbb9e349ca2d191ce393b3f65fff46a93dbea323534f465d5fa9d82e9d0432053880ffb9aa53960705c3784144e55a27433ff37e80a0644906a110359ac2c5307ca050dfdae53eb12ba3cead31bab5958f3c0e14200c14bb116ea567bea5c014501c46454e6b7f610cd425bb12070e9060574cf1e7ee35602bc7b7134eea4bec7b256f1599cbd544f36d2a187266e85aec78604f4f0e0462b5706dc8b7e54e00318ae9b38d3c2e2dd820fa550626fbb0292840a3c64a811f85c8ed391338fe8702953d2672eb3e737648a62fb0b11090132d5c4e310c8e5b95cd27fa2d6143dd8af69de69a0d840adb152b01287aae144836340b3ecba2c3f5ac489aed4f8984c4c58dbe6e47408984d5a5835dc0bb805dc02b64a0cd9a3962cfa6f5a33fd6ef06253b537572865f87c5a0708635e5d23123b5ab099d5ac38ee4a33aba383d09fcf230e74f5623df0381dbc54c3e3f87f4e46bf95a55132a86e30ab80b22753d065a7447571b375f6a2da815f131ef74d939fd08a656ff40e628c9bdaf3aec359dfd128d043230369cae40d4fe0712e3643475c2352adddd4d07d6816c10d0ee324b0dbb2bf2100eb7f1481c5851277fc3d8806a5daca5bba2fc4d7f92e84bbda690df372559f7cbed90d3bb8083a90bba4790affb35575b15a939f1299b66d6c9ffce14e6a314c243c5995503c759b1c97786ce626dfbecc6e5a5025dc94159cd986cd2d5284a024be109259f3fa12f5b8ba0a353c5c16d2c2eae6374eac8f688e56b05ce2e773d90a1c0e6eaf555b434e8ef971c96e1005011287275eeb27152e5f36471fd34144470cef3a28745dffa6e38dceedc6c622078f5e6bc3ec86c08f1f0815756e101c8629c667d218c8079bd502576783d557d1974c02cb546703fcc4517bc6175f5e4cef7cd19b04ddbbce00682711cb85097540ed7a5a81f621f405a2acd79755c47711636a5f4abb1ed48c0d198c1f17a72453f11a0c32f08e55a3c40f3dbade747888e53410306563e48463eaee1f54a4ac8e5edee346cc77c66cc6c00b3c1b85094bbff23a0a74d3d99ea9f5440dd2e1a53d7d5fec0763933603c30a50251b57983d1b91ee10b2669c9e47d6b6aa95d8505907da7a156e71253a29739881fc5a5d2df141a3167d9901cc05f22b7b041839b676a863888bb61cfe4aa2c26fb61b76c0a21f8d9a16e2508265c6acefd8f0db06fdf28ecbf4dc9c3ec070276431614401ea8f818c51f7b57ecf89294387090eb4b5989a61cb68d2c5a0c7a02794d0ffa146281dc5f957f3214bb51f6a280cb95e32e10d43e34900c587058ffb2db5be678e35ab1d4445034291b7c186d3edfb97e9a46d2c3bdfdbaa26d442eb700409ed1e723a8d6114cfbca24191b8efced62653fce1f22aebbddf5d94036fef76e7c8f12fbdbceeb3c3aa6459dfaafe004c4ea5bf4cba92e48ef4f076bd1161a6f59c288a500ac4e78015adb09b95228a515b5667087a9778d77034b0795942c532bb5bda26c2398784f64c2fda340c97c3e90b6647716560b590e890533ff9021276d3a9a207da2a2e9f1f043e2297ef06e369a65697dbfc00e6fe00ed0b91a738451258b29b07413985b05ffd5948201405e4f1be0bc7f36c6acc9bef991401a122cd867f10fea1e04fcbac4acd1de2d7781d31928f0c0ca802198701133175154b54316a9f9d721c0cba1637f03ef4a8c019889175fa2596c6c24f8ef83d09383f997c2875ac4a63dee73468e1cd2e573cb4585c3735c026312983c180bc5b52a20499ab4a0d03db2b50b3ea015981c07660f27716748c549b2b40a50cdd8f0738b44959a9cb4a3dfd44200199a6f4e3c419cadf32c39509c1f6a1fd3ed4d8c6efeffaa8d1e7a461dac0de35cf4ef945b4d843714a0cb3fd571d1ef4f6a0ba7d0043718ca0bfc762c6c021a970eff0037b1e58430fa193b6170be1382062f1f4266119bd4bc81aa9a6fb658406296e3b9cabd3c5a7b5b9219172a636774ef6734e518226a911868f55bbd8128de7810bb6d9e3406ae6961edea6b61cc061c8ecd3bd4c1859d3ce1940d48c69d85a2e0b4435efb0b32f668546385831a7a2cde061b8327e896518038dc8229fa7933ab02f035458e0eb2a858a959e299280a53c3a9ac6d9606eb6126a9561f53d925a576b30104e1afe353dc190e5358987798eface2080e6f4aaa3d48f12bf6fbd554b3617f6d485b64ec47a1c736dc09510d715bfa5b9cdbf5249050515eb4ba093a398ca28557b799aaa01186941539e54a698eb9050ae1f9e66eac2c0497154155ae9c7cf0d16c31a72ad7d7e6cc616d95169bd7b199fc382e44085483b99b1979c898fcfe7e18c27e0a58920b49d4c6e3d6fd52d61bc1e2f4c5099b5592191ca80f3172cefd3173bb22d87c1017c0569d4258fbfd4eaf0e1eaee8f78b3e3a569d357e2fb65c5cbcdce9298e7df2b1f0cf089c5b91bb9d6768f57c64063ee9be990fc04bc16192224fc24fc1b2f80613224ed838c8fe817aed08f8a1ac6b4f394a5303a81df04d79a76cb2f9a2f6071f16b0128ca9709d5017e649b47336a9e3fae657b361fdadd1219efa5fb988617d611e1ea5d5edefab262cdaee286de071ab8c530cb9ed61466f06e4f03c2a62b5b30770d98f218be2de65f32199f07cc6b16722e5f8a61bf1ef8c3cb0a2ea1af34b281c32a9f776b26db95668e7f7a703d2fc1728c9935198350079019257a432850f123bb85dfd0af0037bb877d3a507315478c2e42e9a9f7054095dc2259d4f2b1d75467c1f748eb057db1989bcf1cff2bd111fe07740e927cdd02146eb643a76cc99bb142c9afeb917f700f49e3865eebbfa58d18121e078a46c14e2aa84b1319c4f73aed5c2c0802243fedc4cfc5475544cf2c4cc7deea814304a1d6c37e6ab05ac6db04129d2b3107bd14ec06d9de5e8f7c266b36d59d32d4705ad0bc9e286b0ed5a2ac245192ecc6b2ac08fc2b63c5d13dd5a77abeec3510064a3b84802482fb688016374f22a6c5ff09b1e9563f950232f7f215b93c39f5f713a74ea1e34bc35afffe3ae2c980ceb53208a5ba1739d7449836584b031becc2a425633f671d4a8d042787e1b572a9d3712f50c9e99e85e7b96cdbfcd468b8b3bff667c657805e82dd9e310de0056191794d2f006265142bccd6e133fefe8abd51004e051bf86383e00e547f03637d3c466a5c516829e9ad8d1fff746aec4a07c1fac02fa40b4e5dcbde5d6f952c18cf7a38cd94e6f271e1696315b4e6d51a49e8aff2af23fb99efd67b0689830c6badee69774800ccb7d43d9782b848ceebe4a6e4d2477c9e771ffc9198a6c304b998d936683ed03de15b1f2df10ad306ae6be198097fd5ffe06292750379946fc86d8fab1f60fdf345ceb888d6f118ffdfd018139de0d37a6a61c7e40bfddc74faf252b770ac61d316a4adec0597ef7e36abd8c0c406ea80d4cd0ce5ceee5fdb0ca9403c6cfc872da1bd711727ec8ba810031b446991b79e7beaa08463f828f7053ffbc3da502001c8e53e9999de8e782fc396927522b560da59fe62b579e5e23f9ce5d97732fe4826960843f3a757a54c5b40b0c3665f94c2d3978be3152e7a75994ee2131b01a2aa72875f3236033fdb997ef0cebd5df9b9d7e62c7464d11cefc99dbfd6e42411265cca20ed7ec54ed7579caca8fe162e6e4d8a231d30c89dc3092b684edf50d071cd363f4ab099566bf6a6c02ac2db4a24211f80010c59b621b31b8213f5b8b3b07464b2a45067b81f573e2265be19b0ed734a9039f5d19af9a1a822a5b1531362a44395bbef9850ba31cd5a8a6d22a3f8fde33a461960d5864a3056d050411bf4791bf64e8af94f201c3aeff66f39b7aec44b609d4dc9bd5f9efb22700bb2ee57dafbe1daabc8831d120baea187f093309eb303ba1ddfa903bb15d2f59a3bb8a7e545a6f45dc52082277130960baa40e89944465d0f8cf0c6b5deb130eea4bfaa423fe3715d78b2cdbbf18af77fb8e71e8ad4e5c939803e1f794dc2a6ef3f4eabce05cd4b718ca6cd1662c4b701f45f4f8774adaa7070cf0a8db88422698e070c1795477a53543f88b76f43501b676644d28e48baf150efb6c33c11f353f337a9cc0e775e8b0f1ac1b1e98ccda4190c9df1eb4cfbff067e4f0239db432ac26325033b539527d415d792e9d09dfa7fee432db6e97e790a7011635aefd32a39f3602e606bf5935e1a20cfd5247bee696780affecd8705b41dda8910bcbd308bd3cdb0c47449b34907467d75cc3c8662a6967512111ff5a027cc20fb09a37c069b280d9e3d3506d44eda6c6f627c8d3f834d10179cf885f04c025cec3df79b70290c7b2623ed3ddf77a82e7db6a0cbfe0d1306626065139c30bae4ca22956b9128ac7d3bde487053c0090aeedad3d794422dc219709660a89bc17dfe997155b71ff83acd14516f36c9f05cad8c11e81c210a6e0543f9d2e10fc1c5e76ac56856101f594261e726e4f672dc2a2de929a6cd89bb150bd88e16051186dce3e41f101d41fe673ea158a0b46493b6dea4fdcd1356c3d4355595c1d4617aac60b2463ee06b24fd27fd4c8db3cac141f96489676626e6a6f4e38cfd7a1a7fba9edf296044c701bce6a1bd2751302487e0dce5861019fc1a70eb8ea3d5fe066bcb1941fcf8e1a49da69f05439d3fe3b590a90472fd007fc2045224d72c90643bc48354f912702534f8c141652ea9485d1ca043e49ea6c6510df21a079013e0788ce634752167fce20974f89912b9b5ef0cb6948f7ecafe2ed7bbc1c72a16230dca0b05cff453d16db67dbec275042c255031613ce9291d7423a6eb98a7877c6067b1fc29886dea3dd8c375a0ca8ff48d4b3701e597fcad540a5d68c6f9d5ca5b38e974afa121bc0685fd3ff26fd0131870898ee0dc66c0226ec5ee58deed92c1c760908754d06fa3b8f43da49e47ed2fc28cb32be2626047cb43381654d80914a44264489236f56f5ba68de33d6ebdeb1880ec184a3808b98982b1f56be97446fa8bf70e5516d7bf31f7d7902f4218a3ba0b3a60888a6ad4b3cbc6d40600373fafffa95a0357cc9abec731bfdb12f1ad61dbbdcea44a6b8adf43239dfb5c529244955896e1adf0149e8303373e281697fbb3011ac68e3f3a8ca1436e0633e767d3b620f9aef5bf4e1894ddeacd05a70b83b31ff24004a73c01c55f1b92e495b054290b854f1c456736c88c278a32fddb5693f577d58c5f4aee6455c36800075a1ea83ec15f6c5fd82b74e7f40cfb76330b2ca09a3151165dfab692c86daa758cec45029c5efdd866ac1fc83325437f103e5615677d6d7e93300919c707eb9958fdb8c9f585c86f2507f3de8ce6999eaf7a3d8a6adfc7bfb033d6b20cd33bf8a4c7d1fc20c6141ed61bb51389f6b23caa2704dcf8b3467f14044dc3bf35c0bce5ed8514135f8d99c140c0c13adc2935247e05f8c110d9ffc902bf45aab4272adc0969e81e5b4bd3f037d638b618bc2d19ebfea32575d31eff58d12f0bd4855d913b196240c5e26ed7b988bf13f1879e3f2fd817bde7ee277cac56254a7d953323a8d2ff0ac718cf194fd40a88be61f0df70f629de71eef67a2c8b52610141cb89d513ea630c7ba6a5db7aa700b9746530b7965e66a1bda0318ee3b67212c0724b6b7377b42dfcd876d7eae4f9b2f36fa3087e22e27947c1b0859cdacaee1c8dfa3e8eb75d67adf7b4afbef5772a49833a692d13d130c9207694bf8d2e7e975eaaeb7f14fb2f5d24fcd84b4da214e82ba3ba09ca15e680188935e0668f159dc4820869a0843e76f182014d132337476b4b3298cca7120a52b0733785bdada6155f824d8dce210b914054d3096813d2342e994eeedd08b3673999fbd019c9096040ad1016257ba056fc258294827f7adb965b2d4003069a51651df040045e038af1c504658cffdd16ef3f3cae34bed69239bcb79126f97b999189dfbe9137e1fd9102a3d9d06aec5922ebc215a2135f386b0923302799244e592ec2f62c275c258ce86beda3a2b9a9500610c67fd80a9a68ab95909310fce69f0d64f9a83010c8e3271618ec510e3e3d9282fb60b2f12a77f84ccdde61d6ac7bf6af02aa92cb32b615a6412a0ec49a066e8338fb7fe678115b85ad464471576aec1511222e761cd6151316b0acafc1f539693d432c124ac173fb560bb49e6683d5ba57f88caf03bf9fa8484045451ebf032826755495209ad90411399ebb9653efeb2247236b7475ab7ec8e92aeec1bc7bbf1b9ab1e0bd740a69c783e0efd91f4fab619ff06fd2d6114fc6092b1ccd4fa80ffb51b7ea01ce1913a8947d84bb6bcba6b461839673d10b4a88f042e41812ba61e84987ee6799384ee9296be746b8ade14bb1e6205ee2d25d0c97710dcfede65cce30d9613b471f2d35fed9fae87173692b096c72ea50c7c95d379670bce8b7205e20b2164c1b1e7b7cd3d8dd4514815758c2d05cc44e8ee77e8f6e576932909141d7e67f824c3829dee625763909f0ed14b424aa7facee2b97261643a04184f8aed900809a912fc57da1c3eed122f8f8429523178741edeb14e785c79df24f5450c126810430325b3eafb2edf04dd6cdd2e1b488308521bdc8c19f3699cb6776685042f053146d80b8bbc8cf5f98643ff2a0205cb3186f24ca03a90357d85b347da2deb36c12ed1fde67572b2820ffaebef129c8ec01d25755bacbe383e829552dbb1b1cb871dc6fce415456360c18dcbd7c0c28686d9e6961b4b323bae9e17b91d165dc878decb7835c6588986127ef5a14b6e965cc6dd506c81f64a85cb9ea1151ede045d084ae8b95ecbe1118b8ccdb8d9a8c6eca944501f206f4fa936c700a7b654ad746f9f1d05acaa995a31b738ba0dd1cb5aaa725c78c6d62b081be20f7883cff1e3039eb917c5f90be5b294ac35ba378107d149008297e5c079fe15fdcbf30c2403d6052e687c8098a8381f976f94ab0ec46199ae3105490f84a4cd9688a37a6b53cf73ce9974261daa3b74cc7c53f51c72f6c6a0e02168195ddd620643383e4d8e30bc1be6cb7911514a9fa0ce5a211006aff676aaa82fe6b38f14189f04e9a5a673417937a61f3340970ede222d9163f4ea9499f6357a3c778ce848a8144c223644c27499fda7f77084f73167372633f4c6a37ef8920aae68f9e3fc4fdd6d52b0d2db3faca81ff9d7f98c0e072623f3fb1d98c966e026958d8149a2738f7f709c022d1333a2abdfd68aeaecee84dd0b736ec347cf955863c65f453caa7b8088d2d2d5ffe7cde36071f69eb7b60d40184550b1ac79bd5b344bd23f935a820f15a6c3b9e6264985a625d156d02912864e57471c15b262104af8ee23617157d5b4f03793610b164f41b6d4620c82f0e6d39e0eb6c6eae350636cda9f326932c49d85013b300407e281229eb8714862f24751d232df79cabb4665a5293411169800e0c0c953a43354012de91927b33120439a78daf13c3a335004e486ab22641f01ae748381ad488100739da1396c858e3f93a6848a491f319eaf256923e4ee791a92f9c44ba254d92196d29eab23f095d4414457ba86fce705517433e0bb54a6ad7a1c8c52c18e5048ff9f9315c48d55231003b92f627f3cacb7d00cb672701452e3e629d644d0e48c81e2ff10ec64f6c5cc0e561861e6e062579c7af92108aff10c075ea8a492f11b7834524a0697bef1c6958df3fb2340414057584225f5bd252ab45e7242ece24f02fdd1a0068c30611aa369303a16523a444a03db85d0f98cc1c81578a4e5124df8d4211f899d7f547f2baa148ba4cbffc0173f86e49e9520628c3afb9e6fd19ef8d0b7fd39e88ed4a90b1af644f17370f03383d4557ea4c98508dcb51b58808e3de61775f716d167e333814d87ddb277043d716ec56d0bb0b5ba8ca005c5ad970c629417b5bd15d2cdf6149ea7cefa826feefd26bca1407ce04729e5a74e76cff0a9a08a5dfc6c9288359f7eb7c1a7237997d1a187de9d9774f0ea2538be7f166dfc43af8dbee9f1dec4839fe83ae6d857ea2146b4741136e6afbd02d40ee9e2faf55c8f127fbf8c77a0058a9f71500447b693fa2fec747ee2bcd44fd0d401d18f7f6ca8575415b3fae8f373fcee00e8be82c590c3de97729aae90a01fe906cc1bb4d2743b02016887394e558ade84e678488499e02d21422e328b806bc55d591f146a4789ca4b44cc1eb87ce2f5a02672d1f7758b3e346cf1d5e6d04a0f83b143db62bf317d2cb4c81308a36977e42a9d7e87ce3d42d925d50d331d0b53c21d92ca415533abdb06cb7406b6a357d341acb729cb09c257b7fb87f2603bf4068b738c43c4234820421bca3b2bc86feb141a221705d7010ded16f453ec162b12f0715070714494e30cd28ce5dd0f9b30acc6344b7153a33fb591f675e23a7d0e2d6661b9747b639a6b109ff2fc7d77c43b4ff3b1c11eb411ebe406a80b808053b1cc53b62a63080f5c8542b7ef48c4b42490d8439410a94dea6452748ccc41727a03b65ee9b2355ea186120ba12c2927c0c2f7380754c39aa1d9adcc8f7ded4b4095515752f14f1c45dcc993e16e777f65a5b852e66302874fdcdeb5478b7475a6d5b5bed844227080e4e39cbb60bb2fc718ba3f3135c8e51b58f34c5416fe4c599599df26e0bfc1fdeb4be489f7b0169c68029668759429854fc64f9c563118c1aaa23437787b7248d845cf0502f450fa027d76791da355c9d5c2c47dc4983892bb03e0fd4dbd88ae44d3c9e585edb9afd93756d0cd5bfd03db455a54d72f3f8bfb8ab2c6f49bac447ebffec77c0feca56acb88275acae74f92cdba2f2fea1c28a2c63b7b66df62b31433e90dbe0bc70cf5e042d423ca5c6da5b1b783bbdc1f1583a33020f7cace415238c58ccfacea99922da9d0924fe9402a51bb54f79632c90665baedab30d888a1a8d5c16eddd4f97ab6e491266beb05eb5ecfd6b8282625e9706105decefa281bcfb0458d59fa2d3b6cd3cc071122865499103a63a6df4f006ee0e87396ab4031479c7832966075179b9dad183f6e86800b858bfcb20f9bd890090c9760aa8a68f50d82348dd0b3fce4db6236c715ed3fa8c9fbdf8990a02d13427d03a541dbee4cbe006898a30c383f55c8ea217c64a91124905d8eb56ce6daf5747bf1e836b28d3ca14bb4867628287ce4449b6be24e0be81e22a199a6499e2072a85fd32f347356c76ff8fc79e07fad7108451218eca7639c0f85aa783e4a6ac6af8a19af0ad83ee0a88ca05ea3d2bf5db63e450c4dafe18b383c9700d09d2e6cca68d66357f1091eb317e1e30a3cbeceed42e7946f7851182afad7277c0b1f64bf16a4e3bd681e3f4cf1500545cde4f7585bbc5dd65fd8c6a0d96c35b5c4e89170f39254125c3c303f920489a5578eea047d4ad40fed8d758ae2fd116a5151846dbbdd7bcb5751b3a1e1bf0f83ccf997dd11aa124e52335176bf1205c48b2f8e2f30c63c5b02539c8b2621eb28a19a9a19cbb04cf3a53bbb986bc5a9efcc7b1bef34f8d365f3192ed6dedd3a2ca6404e028548473531a4a8bfc3ee0e48fc05ac7468226e7ebd8e8ce53a3485347cd898b6adba8bfe213b86e7475a4a72d3cf38d0d340425183b9e6c8d8c405f9612a76ba39b1beed38efa13d9017269ef414473d2320caddc1009dc905ccb9694a77ca3693df737115d21ed79b903ad10f8fc5d8decac5538b2bf9f491727edf90e5918ae4e2a6cf1c1b43589b6c482fd4db660eb8f5f1a07ae2b6b5f594afd0f5da6647758f74796bb567c35cbb59275ff145e167d86ea5e033956988a3bbbaed74b1d64ca70658502a28c6406cb1f12763d916f1b52842fc100d6b8d95e059c7a2c42b555769865c11d25e142666ff52c7429a8a1178d52e2011c1409e5b0ff6b68e819931d9c8f69e2ee91e4d1b42b03f5dee56e437606416c46c53d15ef81bef9d3491727915538f5b502a1bbcf1a0a352a6478bc6634e805d53672bf4ad1c9a9ae68e19c685aae1f54da4ec27926c2e4708846cf5ea7bdbcdde21f4857c3754e356a072fecb676e970be42ce6acd3a28f163bfd64fba07f8cd7b7d430108df4d73ebb1ef7994c6d4533bcc7e5d5e77c5a3682d895529ba4a38bb7afd2022443d747a5d14d4f9a3c16396a92fc0120a41da70d8a0468c54854db021ae455707ac57a581455804dc40811e99999942bc3c8e2d4cf17606f9ac6a1ffc2ff18b9e057584570f6e6fa37e0472533b7c97f40b446b4739aca7b595ea9467a67efd1e9c93c96de61e37bae0dc918d8bfc129dc90b6ab3864d886d84a6311894aea20bfe38bdddffbdf71ccb0d38da5b500e2a7a4b6c44f47c06917fd4289ca54d0e76f7b09db4a735d799b0c261fa41a7e9ec531fabea5d2baf9a4999d820fa25c7a0d2322df32c3d9d9d9b27d6423e8565412d3a445aa5b008b389e1dd642215908415c78e5b9281f3bd27d2f25c15c373aa495e5dd2339df9e8861029d0b45fde1eab939b64e3cde44a902211000d5e45732b6f9a5c53f2fe738f8301585b0c06f56f15ef1f16ffa4ddf4683424e3ad634ed8e3a0a522c92627ad8e7572fc25654cb6cd30e33eed2c48fa127b943205f9c58c28f0838efbb1c8b73ce560e1eae188bda2c38c8a2b37c8270e884c964f1256ccfc3ac638e309714a1af13eab099ca06fcaf8878e9e20539388b64fd0854c6afd20822dfc40721d0ad02a3cf514e8765d4c40242a9dc6094a28cb028700d26002e0305854d9cf052454b458c4c4ca02f775cb89d87a1c67c51889747104d541994a7d36702ce99b813f4c4ddc48eb4a34565a50c38f3efd5c38264c0a37cd6881a3986dea05219c538f54b56ab74c183ace2ee5c03ef89612145a692c2d836dbd6d8372fbcf1ff8a9b2893c1095190411a68e2ba8b143342bd9f764f2e03f1e9c0882b828d4f2650d669fa1107f2dd241e717b07ed3a8a15a780b003840dc0b122181408f6a479cb1c2a44eca6bb2462f70ef47db0383c58612027f0695f8c7178c1636a4c22a6de63804fbb96478","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
