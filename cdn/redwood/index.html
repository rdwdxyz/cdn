<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44d04d5cd78c899067e44c90cfb930c60ae86cba7ea4577a2372b4169414b152b50fd9c30b8a8f991f377ba4a9ed2ae988a02e7a962aeeb777dead079da644cd8f4cc5e08d25d1a0e37201addf1ff6303a81b6628765281477afcc25c4b9f1d60d798fa9cf4bd32be408b79dfa651441dec8f787e081201bd090ae54d044cb278995d0d48835e50a86c97b0af47968267e2c85ac987e219f9cdc85ec985e40ecdedca6a56d8e2ea5d428e0379e6764483aba0904f34099f4e8bfb158cb0b083fcd09bb61336c0e8493099739a275c74646f0fdd14208d103204ee76c596860e2b56ef8373263216dd25741e5b7e75018817b7d80a5acfd79b5c43a3b21016da889fe623c5e43588c64d74feb1bd64aefc7f4bb8fdc6d99dfa0da2b2448a19afdb76667f8e08aa012aa971cc4b3a84159f48b939305620e025e14b474c24c0598f30407abed30b9a6e5341c3794c6c948b60c15d213e8d7fd20e2b0a9a2346984c049770859204a10d2b15dec59cca96c7af9c8301d8bea5d752a1411e18881f9080baedd1856ecf049868cf5fb34ac0eedb2553ef0c87f4a8e30a9d286a9b2e6f3d2335423f528ac2e13230895888433f6a00426252c55fd13199bac48414748b04f4d79385a4fd664c42935599cdb29c2aa845e95f71a18d9ed9a95bcea565e541a0a91e5f8e1acc4520096731678e2b3d960212ecc4c8c52588cb8567bb046baecbcead44ed2b96832280a3f2c9876407fcc50c365cce31de96d3d7804aeff543c92986522a4e9a806e90d0b33d4be01d72a42552c94b89b46603eb5a2468b306be3061ff06c827a8cd1c588398ff3bce95fc8ac8bfeada231994daf6354c648f12035095ecfffe0aaae03f487d55827d889fcb56fdb48e82fafcba648bb2bb391d8d30ae2905ccbb8429c37b34f1b711fb10f5637ae9c15eb108a83e90c58ce8bb18a161bf7001ab878084d7f70224f04ec63b7e585ed944f9c76114c3641f54cfd881d5bcd892de84ef7bec6587f7a79e23533d93ebfed4312465c57404e130d663b61c3268f6e2c09e5f70f8f1f3cfa1e7caf07396dd6c4f43c87cdd3469caf64dfc687b06a7aa2caa2b937e8fc86e1c365daef43156a923aea8d7726f974e05cf87dacfdd1e5b8fc2c86f1020531951d45a88866a93a3604700361b6426aa70783538263d71e5aac555e715463d02811d185cf8706f4fde75da0818f05a1132c5410608396434219db6550ef3bac5d63f3c0cbc39de10aa40a18b38b98f48d28b854305b0c5e86765d658e59d9527703e5493002dacbe3d34963880044c96e273cb75113cf56c92771af66b075237eea9f669d7125107a83c0ac593a164b77bbbdd396cdbb35cbeff3a7c0a8bc541012dc243aa5de26e4f7054517e2511f98a910e186e418c11aed511be9a56effc29553a82ccb90c51a7e5572992682d5b23f26c958b959a5723fc1fb4b8390335578dd650e26183229a4cd1e1fa46900402617633a2c2c40186f4f7cdb9818f85e09bf71f7fde4eef24decd0e2992d4b369a18e488a324ad5a0b504407f303937bace0c4fd239d20961dce2a4bcd2d4076ac79788611d20c030309073e82c68c91e8c4ca37ec48e44eea8e61e31cd3da076d6a64b19f31650d8ad765e0f5da297ce9a66481a113f108e44d34d0661b324679dcdfd4eb566af9c5362143aebc3a586a432bd2dde3d4559091ae669c9ffb8aca294fb4a7d70b7657edca92ce609e7fc0d6dd99baef23828148f30edc5d199284b5c42ca6abac7a8df77705f5336d6fc6832e4baa3e4b7973536ae779a3bd05975552ae8df163a737487f7f5fec895035cb7c97f250b4d301925a81139fa7e743e5ad1c19c9dc5744d250720fbd8018b2679df74d3e9efcd9817a3c247e63a0457f30cbabeaec8c778e1768fc23dd1d1afc049026919aa1ad4920e15d5e3e86dea9350314e5ba0b12fd492c84bf3a487da5a86f598e6d0255325a3afdaecf8728a49f3164da666f062e9b75ed76858915165efc4ee59d1c53b0bb1fd39c1680e8b54e8b2f8ad328a5bd21c8040839174e3163890cbba6c2f97f249558d5955132f8e48c3b3a41088f5fc5365ae3c92c589124acfdc7d7069768af02fef492ca44e48e6831f0548ba2ba7dbb0416acb733438791c1d9833922941b62f45ec534f5b721983686d154a84b4a112930943db6c049310ad08b7ea18719ad3e8b63b480d2b910ac05f8cd5158c56b1f7a4a5af6bc555091467b4bee8f6241701019477d182b5d3c3f8297e192c28a9b6b1ccf0411194518d18c6a2b66c1cd3de26f69984b6c96c71db711396af50f8bbdd196acffaeadf5b4da09030a6732f981fb4440cec844c2419f559f8cd1c9b7b21da255dfbbb3e3037fb87213ac73f282e434db20c6533c8223c9f559fb536d128abfb72dc8708922de7f5ef2fc27f3d66d8d5af16728ba2acd363782146a6a2488b315212f961b8816826fdd11e009230d080309e8647e74af414924a4d26eee33e18e60c043d5c1e922e5ec167bd95cde62b4292b67a683f5aec709145994a8def7cb69cbdaafd84c40c3401d65a3323c68bf768ebbdea5915c021698f03bb6badad260280ab89561db407a7740741663b40870181b4b66b9dca4c08c2a88dc572f31829e650b84caa45a58eca100405e2e2ac4d6a4dc5cc58c6d5db1c57e5667129ccd485262b8547c41c713c32148b54bee0cff57788887f189d81e66a6d7b6cdbfe64b16f1380f22ba1eb2c805847a7e2e093c6bf5b2ea2dc40e2f12bac65cb18084b57c521740d05680df5741420a1d6b1c2d49ec00e545d2bd89a62784e7bbc56371a2b8ec447dc9c6690b6d0d438a2e970c62f434a6e7d7119e15f84d82d36411f50d163af4b10d0bf07219567354f1742d5d6ecb76d7679ffdbb4abd0bd93e4c561aca444029ba3eed9045f83a9e3a33187deac2ad2d2edcd0b7ea3b4f85eefa0a0e38078a7d032e4d843942b44f475e4d94969344dabc5607a3bef94d32974f8dd9dc40604baba144793d54bac437f36d9eff13ccc995ff47292cf5e8b519098c1dae9b24b625d40e3281a0c27b37f252168517039c094c69c0a52e9f77d0a83936f6b5fd03dc542040d856ac46783c17dcbfc653691ce9e56ff3460e96775419a3a627bb72370ba0c51ddff702623e9d997abe5e7e9cb533baad46c2d7f706476f29825acf3e47ab229854dc82545cded85c69a8c538886e51d0499d260587c8653f35ae91785b5bb1c9f5e8f24bf5aef1d15c3a86daae41e7402196b5f893ee4fb6bf38360163ab92b1501193bf5011ea3b14ab657eae2bfdc07f4dc4490c5cefcdf3092d74759d981d2ffb41b0ade3ff96007ce416bdf901d84681635a9b331ce88556f37cb33ebfdbdc105483a4095772c3862df14a613aa7f534521f3727e628a5fd89ea7b25a50d89d8d05d04bb30f077e5e5a269e4859b0a28896141ac81bdf4f1c9449b16dc79d4d38550457d62485bb23cd5de0e00e8af654fd35c0d783e5eb00026d55b47d7d317edfa2a67a2191ae7dfd02f8ca2c11ed5db268dae4e88e02b6b1b1ca0d289aef0f5cc800db6caa929f1d57009112867566c687b46c1fb7624607058399a44e6e0bf8feec8404a314b17b230308be3bc120b17c17706786856f8cf8143e181f731682fc27f254407191011ed399456f98e3ea28960dd8b9481ff76f4f352695586659b3a48d6914c21e2add58843174434564f0daf9858129c244a239b2d4fae912d4838c45ec3de9d79c143c66498ccb0f9adfaf29df10c054a54d6bcabe91de42798a59ed72b59ae6ce4835465a817d4ce97fd9782d425926f15cefcb75cdcc05b9bbee80d71a876d1d4a57317c1172e1292c11ea7dcc585cd5109900804f24764f806797218d628147e30ef29f6292c7ca39fe7fb86afe96f4112a5a9b8f99cdeb70b15a84cb7983978fb058d200a9e3c4adbea6a8a99fd326b67bd707fc6a3eebba512390968da1513ed2f516e51724379dc1623eef374824e36faa1fceca14a953046878e846d9fb46914512b31f4a62ccb5722a08e7b6ec4e5b0f964ae8b306c8f97cf265cd5e3918de32aee8d685f32dc3f8ad0bfa5bef333b0c29235d4507ad54ccd1a52df93da510939cf5eae83cb0f1de5d43289dafb482d688d195e51da4b81acf7c0584d54fb1f264f1693b0a0b48a5a678aefa9812e71873fcfecb7885c9f35149d98ae5810f4f2a7bf9f25d090f160fe823e01652583e82b63a776ddc62f70e782bef9d7d2ff7f3cd70ab686d77c1ec9bc2d88c7dc2223e34e024b7246e9930a25bb1807dda93a94766e0c786cca5a080348f3a7e6f65241721e55d60ae726cbf217366141b8a81eaf7e82f2532f5c28c67d6141dfe9f470aa417005b827210072ba12aaf11f0a66063f69a51b1c53b8ff0cbaf032903f048b81cb8846028c3d45fbb87f27f8f33132218a2dd5ac20e59903f6ea9f6f0db5f5a0498684b538e68fd4195d45591511797077eeaf159750ccba2de9be79d6c6d3a7fff1963c7a1b6ba54e9fb053b2d3f7f45a9c51fcefe97982cb6020d5d2ff59415de0858b3d5169bfec11a6b11d80f506dc120913e010e74d1a5d5c253798793a35a7607ad32f02cfef7455c204e25fee9445a06dc08cd389c84438a6b241b55aab0e67a352090d417a7c4c064dfd4f6a5479deb175810236955bc98bce569c537379eaac2e69eb83ee9914cc23eeb9484ba28e50b8c5f0562386e42c3a2587aa2689dde9af312fe5356e6f1598fb10f63acc8a935e2a1f656c802492d963de859437bd4ca0f76ed1c2c9e69e2d3ced1d281ba7bdfd7095955c864fd07d076e3c8e4d603e43a6ea5731f6bf53fb7061612d22c403a63dcf8afbfba6d6926af7ae0d3b7699ad9e4c8df5c39cb256a6bce51126816fab1521ac2abde88626d4e1b722f44dad2b4bfa6b2eb24436d65ef7a9e83979420fe01b492060c0fa628df0b4fd1223d6a60f7ab0712224bd544e56329897c90bf929482eb9f0da64c9e21f2cbceb043d9872a71a86cbc7ba3a0f2dd1732393c41f70aae4545fc3863971353afbe8d801be71eb5885488174b321e9c0d5f5b25b820eaadd5c03c591b503727617b623268eab134f3bcf80f232e1d12c95134a0fb53c8d7b3d3cee49a0ce872e1e4fba05d2e6b6298531632ac7e8e07e780723ccf27d81b45b18370b76c538bcc3ad84a7900231855e16f16885912747303ca1a23c16872bc132c38c8733b9ba84ffdcdccacbf30f7e91b1e1f4c188c82f810102b3aa815f3f839df7e230159fc1fc4fd7d4fd28b790f3baddfed83b932702530bb9ba61de30f7bd10dd4b2128daeb25a1b2dffc919a294be8ee67956505a3abf351e0dd102353f7e7eb6f6a9801f8d04fff327611d5be7240afaf03220d189dc33b245cee140ef664d7e938c7dcf4f2c34a73001fa70fc9df711da079da42f019b5be41599f3608ae34b4f68797f49fa96af2f4812195190416e111020178ff1ddda0f1895fae5a2c863ad4af8c9366b89eacbacefdd3ae1a04f81d736d18b920dcfefa8d5235c9e47dbad507a75edef802a1f4e2df97f826f748ac6da58a1e3f771aaba81fae52bc32a7db6bca762e59f3721afd2c1b74fc1478f3d57a00317ffc137fd83e1f4e0e5f9ff7e140b670fa3cccbd8079bc88538e5c97597258edb2a8082129f3574e5f6c753beb60d294a5660e727cd932291fd29c4e0329a3ab4825aef6ea066edb14f72ff8db0827d1cac3782a60729d421e1e095527bd673841058210ad271dc99b041d7b0275c9fdc71bc2b9144e9abc00297ada02ebb68a3aa5ca3082f0c441f1c9b2f478e1a0c20d3587e9f7fbe91ea79ef9da8e3454a2d07b57b5a4f7157370adea1e95b297022c0d1ff80f72623d85c75e43d914d2476ca4bef0d0622e083093f5a0626c0f9ed2e1b99b0b5d7401b9dadfa5edb91b7ecd08675eab745c981e9298a8d867ea0f0cab544ccdb4bf7893bb01719aa782649b76d66617a01f550ceac68a909c1fcd3aef3b4fb129d0cd4c78572b849a31454c53192fb6c0305f095656b0c1c9a153f131d6d9eeea1af7ad2d240425df96c92b31b9cf6e0d8dbf7cd495979766ae9f2db013b8136d8ff9559e9384b3fcac4d0aef93dcbb59da893a7603b6a6260198b0b55c9ea9c53064e08790cc300f6c88320177a72023e3f7ce2a864fc8163759394845429a5a13d7eca2bab192cf059edf0229d690dc0f3fd0e40326513d8710826bfe5e01c8a9b100c703da335ef5d8c5ae516ad8d4fcd8bb71f494900e0a317d583f5ebcd04364d28ba157ec7f552370f170ef365d9c88559e1bf2b9ca9677701b25fb97dc74bdb652aa4ef2b353a1187418ea6475522c1e5d70850f6e1890e7975c7eee2f75aaf5a18a587d08f60a5dd75be0fbb1312105df7dee464333bd201540ac905b80fdfe7fe370d0f05999087b0ab4361049965963ba1343d841924b7cc20081f71a9dfbf3814cf4213c813fac71606c59f6e237ff9519afd3d72424ece22dea4c909014e154c0af1cac4e82a0b87accd854f0ff9a4b7c1655172f1921cdd4812f1effaccf8df9161865f4b471f36399435e17852dd229da6b7cddadc55364be71a8ca02e4b281a31ab573bd8cd22c18fbe17ca09c01c5708c4467c1c7dad2e860c4eeeb9e8b46901d4fd686f87eb709fea4cf3f2f08b6f613f636d28b83e6c41925eda77d76600284b6677f74b8a328190dfbfebfe966baf7eb989c82ed931e73173394883f3ae10233b7fdb56fa0a320f8824f17430bef217692e847c5b4e5b0799f972f3c31250edaa9f7fd1cd0bc492b240634a98ef5aeb1ee950fa88d7baf81b3fb990cbbe35953b534c5ee9f96bd0c3c3759c5c40712f1b368a7b00d42fdbd14a725d29354583254414199c74dac4ca8698b3f23ed4c6e7cfc29495f102f274296b048cdd5a4ec367d25c88f29e5f2ad37fe1db940983c92157473245f21def3330616c06aacc90171e6c02d25ed7b9cc62388de3d70e18f4470de489587b807214f82673a929bd505bd162c0bc5ca00c31984a7bbe1c11bfb0b1490441b55787fc8bffd417804e26fc2b843e7060ce6d1216e5ed7542e7dda2975cea84b719075a6f090dc5508e337ce02461fcbd0996668ee417fa7ad83f1e0ad25b8734a79c4a3b3022e541ab664b4dc253a471ae46e2afd5efeb4f7e8a491819d67cffb5823818a55bb8e1002c266e4ba1fdb0d9fe8bb9012af2a4b4a6ca8f7827a226f07cad0fa94a09d7f092442266f9b1506329267b95dd24ffb2ab0ada59f90a19d80f75bc14c7c025ef9f0b3d79e4e694ce63caeac9c534c7108fe11abf8b3716c680f3b7f833eb62c8616c0912e9ba091fcef49bb47104216380e1ee7eaaa96b26a398391100931d0d6cd18d661dbf8979286c4d8ff1fa1064949e1cba1aec8ea5fd2380427ab2435f156094c3ca2703308336731c80c125a9caf6b7ed9c21afc8a92b78c02ac978eb7681b3885ddc154366e22d8f2627616fa25c20e5222fbbc7a1e662aca530720d1fa709126d6455ead73eec95d42f0bd78896b35248d9956617a214a69969ac513a3a823be53bd6af34a9af9d7002219d937a4f3bddc520762aa7cf9dfd7277e0f95d9ad592d0536b9bac048e0c4e008b40655aaa9d2aab961c62ed74fbda11224cae76d6236dfd7863972bc92d37993bd4fc741b0b5f06edde5c49b51b18745c8d479c79bcdd835cff33370e5c43953cdbe37e825a1e5f3759aad4d59103ef18207043a87bdfe4d9b2de0e4a91c8e61acb7c3941b7b00d5481ee97dc2a8e2d50fa4483aa2978a6e440d08f80d4f427a5ef6be245b8ab52626ea016361dbbe61a0a856228dfeac5d21695b91f12457644ad138c3b31f6c6c71c16d974aaf73f2bf402ec7899ea47ef14dec9c95d16da629e1beb069224ade39e51c013cc8302759b1d4b3d2d4b06cdf89f31c716c9771bbb05d97fd60beb20a60e3a9bb7fdab034d94191154c6bd53c712f511b4517446033ffaecd4663a4acbcef98f0ae34924891b30a22e76a056fb8f3ef6c1092ce0d01cac02b0294eb3bf3fabf2e8516b04e308236f9c8b0019580a5bb32d5b44c2f8f392ce0077236cb9117d1d67a23a0a31c52c8de195e69384aa3025817a2fbd62a5eb815a081b967f2bf9dc256b48bf8da382d49ba28a9e85eb6418b51dd79b356f61eb0d06edba2eea3a5bb6028cacd68808c25bd389346f2f2867905c3b74cd20aa3b5a66c3fecd8e85a43645dc2fdcd98bc65d4292af76633f88a61a105acf0f48b7567d7a9f1ec6075cabb35d5bb2d2734f283757c5abc92eca23a665ed3f3cbfc0dc69961f9038a471ec801db0e4f042769213f97830f388e2c577c3d852b5934999d1f84606a1c9b9358d06d5275a372b42d8968b69374b7255a6f1a32fa9c0d111dadee3b0959da42de9dc892056414a57ea6ab26a9c49e791485d7e13ad7e06500b4e481a454fb3d3e98bc35ddbeff456dd6b13a14aca1f21b02066f5cde8dec83bd781d1f1cb0355d58e5cab7041448359ea7a8389f669b3c7903f5400d1170b98b89974597732667a87cc1ab5215d6cc31afe98e046c7d448a91628dc331f8460481530c95652339bdb286481754ca970d7b3decf3078daf31320d7f2d268a7e2fa42417f3376374ba0515cd2b0bcf4abcdbb5f6f38fe2bd59fa1fdba26ba5c309a68b4616b7d7160b79d6a92e9fbf0026b8c842b33ecee3a63abf392a022508488fdec826a10e8fb75246f89bce1d58c5c7e5907ee79f176ca316fbd75f62c7065eba890ae72e1df57887223466e21b97fdab8f3329604db7ba562536321904d32aa1d598d26a17d34ec1c350ef89faf3391eba5f45aa64bd90b07ecd409c19bcb4216f3118dc33d2419ab5fed0a6388c62d83170fe605bb2d465b5c22ade5621f874166069a513afc51eaf0a8d9dad5bcb292beb6d0c099161f14e692f2d30c4b0b8414ef842d56fdd880b2b0d5da942978bac33c27391ef806f85668c7598be8a3b179b7aeb4b3e69eacb11d771c4b571b964ceb3168bc5e450b76ca4e5b07bc16ad6fe21fcbea0d83918134d136be4f224e3056ab96b09e091572b61f813fdf634a9b27ea29ffbe8272a37448b279ebf921734905d67ba810036881af4113d52a21d4e0959eb2de8273bfe7471712b227b5e1f1459e26d16c2841089a801b3db22a666bf5b6b8a1a152b1ebdda1e4bea7c7c956b9e47b2ad579d49fb7150487cee90dea5f81b456db988da4eb8305f46178371425d1099efc7d1dd4c98bfde53a9a05b62f9f615ab8dddb7d9f70ac1e265f7c3bff8a0afa7da5e7758ea0c850220d9d369acaee3760c5ce3eac6c205167a87ef68983f66478821b83a3f9caa013325bb11b68f9c51f85737a8e4d97975c1ba1b15b66b9da61b900cbfbddf68bef1a5f39ee006cc77a88f5371f854c7d3ffdd9b4e23dbe4c393d8a3b43915a0e7d47abdb900f494f581264079ed89d90f8c8fd834a3fcbac543a884268b8a99bf31f23e98d4cfaffbb36c1791d4d9d294221b52762ec8f97dd4368e7e674eccc56c3acc322d0aabe0d45b06bed4a9e62aced0d6634094a625e7460cee4b5006a3842bf68d904d1f1e1ea6c6f10f1e2d69e019b31bca49a830536994db6d4ce74fc9fd23bcbb631b50c603bf7ff1496ecab0c8fafbbec0c9b9a454d6f97b0d58577d5088ebc6ad8d0b9e3bacd367358f472b6de1cef5030f2b71f014f912bfe5b4dae8e3fcc00975c0eef89b4a4108723291f084d1efee70fa3f84df761d1dae45daca7cf74887d708290d8e072e5ab25c92ed7559ae022a28dc4ec3803434c68f5136f4adab942872ab33cbe263180848649a5114c41aa0689215007ca9412f3a48e688e8c8605a90cf08af1ad7c8a02dc939b8c5e30f02e09bc9aa5220b24d3cb9e05ec39bf3207111268dcf439e872fe71595f3bc4ce9bbbed0e158d06a390a50a9bfdb43605195d2eeb4a7e3729e50de03d4fbac4d10d5d764443ad9f578c6a00368db4471afde0c542cfd9f33c071f54a56a039130f40da1a255469ad95b9bf6b98e3717c21a8b28a4420ee10d5b3083188f77779335ddba295e95f5bfea986ab1ae9915ef832a24a2080223c6a51faad71db373fabf46e48528149b4dcbef55c30a8da9efd79606f8a7cec57298d060774a720f03a9e78de3aa327ef3183e7497c8fdb08c9887b2c6348633bca3ff35e4f1c3c1095997c23c1ddb58f31fec1f60766a917fa8915d699f186243bf02bde92234c0420ca70dfd5d2715e38db41657065f82c86dedd69a168a5fc128d1add2a1180ff0b061d6165ac96af550b990e6ef1a7d94a8065c0a1f7118de85cc904b7b54ecf157071d16b11cd30315051e841d52ece11f776546c82d9440b9370097648384ce7d4251b657edb1fece9f607c6c865a21f809f4a349a59acafba7a58e86a3b4c9f465eae26995d4e9d9125a1ca120f3490cf6563fb616084531248d80a3e4285cc25d3b41998609603e5dd16a6f3cdbbe0262f6cf570931600a326a969f11518122256f8cdfa057da4f60f7fbc3b1b525b3b8439fbe21e1846534a50e734886b53b15c6c4271d8abb389642ec36a6eeb8ff5ea0c1ffd424b6b37b41ad61ca27cb46c3cbe267000b82e730995ae841f79887f31d7eeb2f952fec6a1f69871bb5a8385421ea26cfaeb513221f51e92cb5a4c82c2aec93e5ec647d363123e42f1b744073ab2cd45f03ca35858e3fcd96868efd895037eacfc4e3b82b3f532acc2c9b9337263e73d01e348283ffea84111592df1f9e5bf1d8ed997023cd3c76870a4b03845507dd49dbb5ef975b8d253877bad633d795e4fc91c1463d2fd8c07ae4fa1dba5ef366b7a6cdf35babf8872af46dc4094fc4f00cfefb45f6a2e928dbb054edcaf79f5dedac0a9c9ce61c6c5970bdfb205b2eaab66d359c468fba44ef4ee823e79ff13ee92392872a9f5e91c45ce4a2d145363eaed85c29ed49c0312b900e3ef3f650ad676328d373027b38dd38b36729b760351cfc819b5cfda8ab7a11ade54d0cd0a6a827e4a6c477c2ea5dfaef67dc09f9b345d56649a217cb7bd6073a7dd04d40474c2fe12a12a009c1bc86d7fdddb4d76d42d3f3f36bad662f2acff556e393311ee069c87a14573da2825cf1b83e3c1d73c8345d10ba938af1327dd80f5997150e306c32dcf8c8f6d49364d816685e67911df44088958d31cb5dbd3f0fa46b329368e8104199b5fde5cb69ae8383819771a23517e6ffdc124669b198cc9a1a2356f967aec876e61e2ee4aaac31c7c10e8f593f416998428b48ae2af195a3274419005c1a1c6c20590a485099faad0d202c801298249e04420ebb4318d0d64c716936137bd11ffe2f73328cda80cdae2d10deaf60272acfb38b84f0dd9763143b0659810a74ea2cdf5d2d9fc610cf11c5071b1a3f92f8391c03be8cd6d895b41a2b7a77fb1aa0c55e4d0f6fb187bb4b577738f2f474956ee6aefe8e61cd7501f96dc5c97b4bde0e61d935f048ae99cec91418b09fb220f14e2eb98897bfdbf411740dcc9227806fb35af26a1959f21c11a2e92025b4cc355bd5d13e289b913ed5f9b03273b764da927d3f899e1f45abc8ea0c389158ea64bf9e4b383c4663454f47086bc43166efd5aac0d839da2db995c02a49db3f247b0c63ee38c937ae8464b6afc6b543ce23df3f00df42b9a87f1b3c7e68fee6a0fbfee008a58326f481bf455518e0a03ad4f116086fa9323d66dff6631d9dfb17c943b3722fa47d67593dad153a91f43a00515cbe5fcf269bf2789d2ebb7945898e696815785ff44bb304f4017475d66478e9ce4586876fc5fdfbeadb8d72d4c95a1c84e20b6688d7d351c91d7f82410ac8e2ed0a17a39323440842e6b9d266dd162b10560d917cbaa9bd912a5f4a491a84fe4c03d2cc990e254ce79daef179e2e1b9677ca2410696321ce5413a91594eb30eee75ff74b0b73cdf01ee74b74e5fdbcc23ca0f10e50c82a441a0273a62336c839a35159715d26af4044a96acb2442d71d97acd58146117418fabe34019c2e76e497f5f229ca1420ee8073354debdc31ec4d48d835c96bd071ac80a91210eecb6623dfaf60c335ed783332200d2c939760d9df830e7c6cf86b60b71cff594c01e0b5fbc7d49664c695b27638c975bc6c84c3937c371bd32e5a53972e765cdd0b9d4c191414a7a8d4d326b98b6ed209221aafc9dbacd3bbbe89dcf69ab6cca5c85956bc54d1d451c82fe596e588b39623e704a85a92db17a34b023f2cd18e876676308fa24e565b765a86cf13ab07801320781d98032271896b0612b0942549313d3f564a50a7c29e648d34d3fc2458897f313994efcce4b060069d52d887f7558eafcb609e0130f200e30cbf87633642735c3c09d1d5f6d0c7feb0c1a5d35a2ba14aad840b27ea02ae1155b4b7d5047789d6ec97f8b9195f35a067877f55f6f223793ec74a534f0b23ab9616e24f0f4b47eadbbc51d241ee713bfc1fdf6ee91c11ef76852fd1fc41f294632cbc738f7d40b31ffdca4166e44ded0d69f3718e5e442bbcd7303e3b816b22d6efb08cb4aa3e58ba5d2a6a04688e42b04f0527b7530e0b2a7431a689657bc52addeb81fb098f900bbd046afee323787e6a41a9452975a09388c2cda6dd69fcc0a7c7989bf68ad2afd110e2d68832a565c1d2d56d6b866ca93786baca60ae8ee2fe1aa3181d4d93d438394eb4e1bd569a6fa4810601cdf74cdc4973da6fd806b9b265b687ddc273d94505863441e4d8c2968c96c27a50e875c484b3959c783c0a9ce2499c49128287b7a7f200d272d0b11b400eaeaa0ef178e98e219406e5eee09a099634a4cdf4728a10a2f16f2ecaba2ba5707af5e5c496f8cb7691ab3b9e6f3bd0579216778bcaa1a482ef0d514475073867b070a3fd3269ff542aadf6c8dbdbd05fed4413dd0ae82c33d50657d903047b31a5442c3df22d9b5ec5536b45a70c3da6564b1a8d3f31a0a298b09bfb9373adddac8a8365ae7bb26a0c5da12eed6bcd49fdcfe54a8a3d93736ca8a9a3d9c33a957663554caa8724958045e63846eb518bbb45f9c051992ad4685640b437e8b8c655c55a68bb7d4dfa9329a43de4fca1a1612a092920395a466264a79c101dd140cbee6bc96b7a7152191aba0f79538cdaada683c56092a7390c451f5bc78de03cabd87d008d5e3bd14c1157ceb350d78dd94589e1de989b190f6c2ea27a4b5c9f8f7f6664088bf8192d55e4c8cffcdf53efaaeaf19fc3cb49b48dbec947b0f0ab6fc8a87bc26bfef616b955d2d48d22141f5d13d089236f1ec22f828ef7571538dec3f4d4e37a361bf5e3ca20fa75a2e8de4223b39ee0154e75cc48b10826e66e42df2e81d567583416f12471ecc516fae0cdcbc39ecd3d4029bea324a0bd52000c7eba031665cdb9fddf6a83f50088545bdd7ccd30558dea7a929fb18deb1aba5c326b190920a3f72d054f82aec85f785b91879ba05a02cf33ea88c911f9dc88185e9760e22bda45eca24679a793c4e36b82fe71ff2f20cef9d56ccd58417f8f3c3bcee8a7ca0f6c871fcc3ad1c4414c89ca9c5821edf1b9069ccc203eb3ebefe7fcb621e06f1511b7475a270b3d387957fb357446a1a58830949f5796a4cb6d9d974ca35f6274a9d46b62738d6c685e415c79c920add51a8f7aa3ffb77a7a8a94e8bfb27483a7a33e277e4271469976cc79e7c4cf2043c9ce7cc537f9c1231dc6385e7a740121b863cb3b16438acd6b51d3a06b8f9c7360691cc4e9e84fd70ee46f189c18e3255a37e3de88f316ef37e4094a207eb31ae24d57c2fcbe79685afa8ac192eb9c414723f3c30a684fa1ef832a877cbb7a2af1d7d85c6b2be600e801a3585a6a343a645560cbebed854a81dfd30e5e9ba4190672db2d17f9e825f081f4e5c06a3bd6fde7b220e08be7fe7869948d5d88964f3792b076d114cc147e5b1aef202168ad88a3b42af722c6fb5131e909e55cd0c611ec7edd080efa9c960cdfbfd018d46f814bec4422ef22e4a7d08e46ef87e31718c79dca652fe8edd111dd15d746fb0bfdcfe2210802ad2a5570131e6b1e9015e5a534f096805c59b894f74e8733705ccd352d093253c0fbc735d3fe4a1345d15aadd5acbd1b0b2ed33843aac50e077d09632c4758ac55ab98b79e62c82e6116d4130be794acf5c343808081ee5467c0e34e0351e788f99be22739678cc4b2de831b803e8af1291f8f3f47129b7dba5e3f345fe682b04a912070e87ba51640b67ac0b8bcf1a419f8525944c0bdb3f8042e5ee6c85e0064744f83a8c07db0076c780f517d908cbd2294a99c1ff8f7c1765d1fbfc6b270c44f1aa0bda14de933406eeaed9b04f7ae6dd7d6e3720b18c3e4d3c44f879f7e6c4a15f265430d41c3ff4346f319a04dc64a6e9100adf72e71a1b54b47895316a5334bca373e380d0e99dcfc7d128e71ba2461e11c4e7e889c8971e17136a324e721fb578c2b0f2f35f7d8b1939012fe47d9bcaf9c9c6e8bdc1f70834a7af3bf9efd46517f468a23ad336244a37dad4b85ada2ba70c488d2f411404efb7d475ded5c4832b251aafb3dc07f2575b400c289086983fc5c948f38ac9c2bffe88bb4a7f8db9594aec4e52ef525ef22898aa5b0dc4da7a9b3d6edc0102dfdbb9f509e6c11c67d1f855f80d0c0a6da726be821ee711a20fcc5ff8cbfde0b128912f471bc7dde7c5ed0e2c8d355ddecf396fcf25de1586ef3ebe9e3b481084f1b709ca8ca68a0931bf3db33a08167edc225ce19a6a476721143f97e683ac764ecadd9da76a203eb9b6a246a9edbfafa7dbf6be889a05263c7070c3b6594dd2e8305f46fcb8332b199d447292e9253862f5e83e1ec4f90082c34a16c6a5831061b3cb4584c44900c71da3dedf9d9dc30dc9cfd508cad7b04b90fb5424963813e0243f30dcbe49bc3c75a2b3ccf2f5c954ea94806eec3f9384600cb552ce22959fe46a0f606a6bff36efb5c0351bec44e43e3711e22a4c3f9b69ef75121161ef25f83faacb1962b9e6ca8a087c82eee2aaf0a22ff9ad3b19dd64f1f11d5278f986a1dc247f58a2b80921f76b8e71dff38ef5074bfadca66bd553954f57467f3c4cbdaaf66617dff5223c57b07183696f764cb14cbefc0ef441cf1084fcc193a88757b313841c9a9d7ff4c03bad9eb48093a9de9df7015dde752287c89f17292afc6b628b51dd3211df7d6b116121ec5114fe20a9a6c5b862278353b2b1cbd1436c2c783e4001918ea31e67b4629e05b94504e6e3c1e9e60233342893cec3ee23195512c3913d603ceb731558e02987bb74ebb24a475341502fa16392e47239288c51bc3a91b952f84e4b286642072f379af7973023646f210a2b99bc8040ed5a0a31befb2060e4d3546e19766feeb6ee074a09a621d386a8c0573f31bbb20e0607e7d69fcfd0b8288827b0bc1df3b9fe827dadc02796effbc854be493ddf4b758f9c566b86c16304aaed371d84c19228842f561fbf710e49f25b29de4df23778882ffa803bc12b0bd236f97ba8ae84b1fd5b794b071439726f5bafc65c1373afa96756bfffe6fd7ca67254fd928bdb10a0fb908f9163f1699d5a6fc44d5787949afdc07107ada41885a37a3ac4925573d1cfaa015451787c4817b52d077844f8a4985454690a7391cb601bae9bedd297af0ad0c9f6fd36dc22b7a5e68a834dd5f01feb8b0799517871c35508f9828dca1386bb4712ecbe31a217f94757e89295bee988d5f564fa8dc1bc490071382c2ad187f5d0e3b5ba6feb51dcc3db4c307421f98d2b3266d630e424aa4404b3e982bbec3ff6a2f6f089c63b44d27ed865b5da6576ba1ccf67e97b058c8e90a1ca62599922a785540324e5a0c75541386611fdbd2d3c7c6c90e37fc6a6adbb7e9cdcc4041223646a4d2f7d9223fb4d2270c569fc6a9d46f1d0e9d60e461acd8044a0150d05aaf21036054966e148a9c567ac8d32ee8805f3886e4ea9701491af96ee3d43229e44dc6b9572cd781bd7454e9d95e07eea5373f60a4c2b210b75e2b3f24d948d99c4fba65111eba5d5519f2aed372f1640c7986a759fee65a75a89023fd198f18f14df26dfc7fffc4b877b478f405703d3cd1a254167d9c98db1fbd12a7b9a63ecfb52f34d7ee6240d64a76a4251ea1a5dab9086442c29546c00647a8ff1179dd0c73a4b8eb7b2d9cf4947e8049f610c3dbc4f2cdf0e6ce2cb2ab38e8bf93edc5b8a22e05e23f62eaa1fe9a46aeba6c1e99ea1c0690112be4cf5e659a66b1d030d27107a12338a0e4e346aba1a3411103026644ae56383e9e263a254b551aee8064b6d2e64aa1efb5b927e76e59716396456120f274092ae3d24c0dc8b6dda4249ca1e98fc506a8ea47c69e58724cf3d9ea7e5d9945877d7aa222e9b554bea7ae16f349915ac387c85e49584ca100f1b9362f299caf1788570e70fc1bed719bbcfcb981df7dc2d279f071b46e2923942527f35c36005c62b9400325ed8fc22f2662c3d81c53690d7e196f326deb9d4789ee7f722191e73f94a0fa8d717b841a8de23bf7a1a71815303127c9884f472f6c3b4689b8f11455879c0abf4a42ad7bf3b25e8ae8c5433dc168f826cfc25985f337b06f9136f76de870febaab15feea9331597f26a9426044821488a4bd8d278b6b855d4d19b26b5399488bff5bccac83f14182b1dbbd3dddd64b27844afdeac0f5c15b2bcfa8037f58686950988f186b24c2b78eb2f22071fe7bbb83aaa59adde0ecaeb7f7bbbc3d19d5fb3cbad6788534915792bcd579f4a4def05cba29778525391d83c47992f1217507c52ef17b36d0f08daf4eabde6d83027af5a6e7f83350c5578d9b2a051927cae35a8f953ac327c024d559ab6d34b1736be047dea3d75ad099a5049ede28fc53a6ee2e7a588fff5dcb7d837e2ab869eef89759d1952733bacc03927502635452a728f2790927c9d28a254abdf82286aef674097ad23099599870a7047947b9236042d4ab35bd83bf44f424212c98fe6571bf68bf48f0a655d0af5d405be877acb52b27a5919e8e4e3eeb3797f20e174813a43c4e0996c9eb545c50b9a264ad55e7bb0ad56b86298287f44edfce7b74b5d213cc8ad7bec2682accdd4d2bd7e09acca9b62593e4f5d8821e382159a807056f3fc75a5e074d21d8d72e5cbae1aa996ce0709eaeb66c7fecc41afe633f73213269c746b038486b0fc96977306682e998adda363eb62d05de3cf09e641e4f97dc79b2e38d46b3c9ea15703004911d6c98d90f60625d734a3b178e6544c3fa33431e57f1fb7af56cf470b70094addce419f2b2689a4bda20e753a2d02ecace051e3a453f2c7a44c9b32b83460f47cdf0136b8c88bc60c925fcdadf2466e3fd00178dfef3c1f7a7de0bbd8f337c789fef7ed4a58db6014a47a88dbecb750bd604f2b01ee8105fc77ef77f6cf95853654c3fc46bad30ef870873719f415b8ee2903fc24eee6e998587d4dbd19af8ac3c657b4cf60ea1a9c6d3ca2dc833b05fca995065e6c3e8533a0d5ae829b4928e54d256974c31a8da688603cd3c335fb47c390f0176cdbe5a8e5d94cea3c3483adb98f669b1794c00e91c08482c08f4c3b7fd4c074447045b70ca4b76e4d6e184cb96ba8844bc3550b633489c352ab460f9d78f95c2f03ee27ffdfa38e7b164ef61e756b0d8c01b436f4c1ca0b9c8250bf48c54b4dfc556e8829c72d315986a7c0724dcc56b22a240749a2ef74a13dc2e34b33b02b650cd3ff13b8e72d32f2bc8a39de29f737e69b86079089c840bfa773627284921e59f1bd32950c11498f6be693839e97785b31d00aafa6ad49d9db8aca4f660b7bfd049120942bd81fdc1b26165ab9f68d76cbf8a707b5d3c3e2dac07b17151ed6f8aed0caf56363c69e8fb98853a250b7f2b695b7f366c24fb914b57c724618a348572ec3771079fa2107e9f6e46ae85862bdc78b56c7d9ffefbedf4d50b9e866da1308385ff2278f45158339e0b4d5afa14d16b84f96373588fbdc83d385a9cfa1ecbd5143475964e6702db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
