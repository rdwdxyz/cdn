<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"067ed82a11671fc6070e57486ca379b404779f2bbb7599cca573e139a2babc3425b53d4be11a3f7ebfd607fe6bbf9f907a5b23716ecab8be31ff341631248b87a965c9449df27f3f7642da90c180478b0c4093ff55a82d9c0b41c1ce1fa726e7566950decddb509c9c10df5b86036c39568924029f2877aacb14964657c90d27a81442c50dc0ae31852c3fc3c9f1a642df2959fa0be450b9264b406e3e3084159acfefaf5aa19d4e7f34d45b5ea64b6b98f039c72f8343bac11c9c2efd3cd3b764049705f116ed652163c85de708d8af75ad402d72029eb2ffdd49b037d168d0f0ee8f893d7d121375cc66e7f70bc59b151840e9c28619ba98e7ac20a2e5b9c94cd7589b3f0d0c2ae20c1fdcb1374eabfa10f2a5635600d8572418bc5ec2abef664c34e0cdb1081095820c04c786ceffc52de73be02264ca26be83ee817d72931544a894fc8e715e298931f49275be4290cbb68b3768d6434d0aa7ef8e5e3f4004307526f7902c413e283f7959bc10d0f2cfa70e8cf738c57a8c7e05b0ab9cda05f15aeb3231445dab2559bb600901207f633d4dffa506710db343ec0d2680c943cc787fa68a8575719084d71cc38d637ec1d96b9a8838b4a4a0efb32f7f4c926152c18659df24c1ac42831f4658b0c17a32bddc35264fe8eec9de9bf34da022fb91363d271144d79eea3e33fe68986d1affec48f46cb9a4ac9a3bd0b1277608fda8933c8aefdbac5946b320d43e003666a75136e6e218ce9f46f99b5b52d11eb68563be33a0958cd7b1144e471a670ffc598d7edc5ffbe3934042e1af65454052b0c31f9bee56a87364cd5edda2f9ef7f56d02a39f6a9729a20f06b12d552d756020f07c1b4036332a63596d27cb7d2097dc19cd0068fa57a85562bec9b99a1b946cdf0007f836b540003a3d7a4ea4f7fdbaa62ff60cd7a69607d8c7ff964fe2056ff1a729db5ffaebd2d4bb370fb55164760e972c583ca44c269af06bd161f25911bb41f701fdcbf1d02ccd7f95d02cd0497e304c39c0a4ea9f3630cef976f20856f63b6c85695dee336a2f0ce95b8fbf7faee3749062abd8d78afdfe1a228d1f940ef0581df70ad1a06c90c645c865ae8fb7d8d19c62659065c50cfc0ce4dcbcc504ef13cdb0831aedaed239a334a0004421f98ed78e4d5cfcbd851042eaed2af5ccfad9211f93b8c95e4362385a322f77c5beabd5501ad4a03e7c9edb6da2cd01c715c09a0ad32a83228ce70a3d046ad8f04d5485e5c1e752c44015746ce7f1626ceb98622fb5b383d0d62664fb58d591d4ff4412760baad6e629d06ddb56031ae98240c7a8643a53d75f8010018e8fdba4ad686829cb067f1de4b28dfb1e4a5da026c7563afc7e835f7d3cb070689dbb86af2ad79db4b477476c9dbe66059cd204891c4629fd1a04d9e2eaef7ea8b4def5a80ecd1d6aca5b70cbcc0d08270bc91904409eb95f8999e2a0b552575fb7100dba43c7494818107b90313c43fa70e091944f294e462d3228f0c27e6dff50d6134f91fa0ac6e350a37bfcfa03a809ec2ba62b575231bfa526e7b85e63a438f729224f368a62245e40f3238e50352917049a37313a14c98fea2fbbb700ab9e6a56bc3043d88f99658392110d8620cdacb7646d92c387afcc2efc1c41d9e3c6ab89411de2d5663da107e41a107e6855fe90c729403c31037541ffc7af3f71d494b16891d198769d5a6f39679fe248842952b5744f6e86dcdc60704ad4297b4df4dc88b678ac6a249f6ec7c07a67ab06b81c18674a2e4c6a6bdee7a40094a1f82fec21d6fde636fd656d86670b98aab9a589ed167ec20cc66460d7fe2a96db2f4b962408793f0c285ec4e9f8a488bea97ec795d0267a2a51d003a4ca0794479dad361aacdf3abdcd9bc6eaf297955433357b54688019561a3214c84389d5d8c76d7645fec9963562f0a15d7e95d3b0dea652799de49d7767b8c59085bb3a5e7c5b6a8e04d17c3a651b5c70b48339e7252bbfd1aa819a6371bb31b51dcc30c74d3b2b537efc072378d80aaeae7e97429ac2018dd97bfbe59eccffc14d87b1687c4752eafd9d9749ebfd1c04f18887ff89be5822c11f4cf25927569a10a15d6cfa2eabc5717c83fdeeccb8f25ef532b7d7cc2c51b8542facd5ef4fb129c8bda7598802cae2325777bdb1cf51b6c93a1327f90351fd26df7c4aa381b3308f174699d026d14af3d1eb82165d2919ebaf6f7da46cd75cc6945c136fcc1af154d89274df3d0f4ef9ae29c2b5d6399a19e29186db9d86df70dc0351f2d712518c4d388454db8ef32a20f961accd18dfbc22f2a5ed24755da49b2f7495bdcaf2030b9a7b261be1fa3ce0d7c36bc616742cc606e069cf71cc2192fc469e62972dc41773b740fded795282e321537c4f06a88294def3e4d12bc9c2388018bf506d34b1911039de59cb4144c75d60149f3083260a1d1107de6c52e0f39db660c31b719e7335b7612f2c0760340950b6b017ff465aee8a2d58117326df193f5095c878a833b9823587312fe388b3d0ce24e92989e11cde0253864587d335f577141c5a23a70bd5521224d2ff720aead06afd0e4d7eb65070a7a4a7807a391232db244904958e8f6b4f89a6da3bbe9859b9878f14ba2b59eef3173bc6c3c411afe9a01a8115a581ffa5f87d0d8203762053a344b01a72ec1ecefc1ede569f634c5fe3e5bbd31e68e187c5085dd0ea5fc42c16177dca48b019b2041be49b6c87e20cde33921f63a2a1330b3b3dda663cae22b97c4e582b87362b2924495bb34050401351fe52fd34c302bc008092fd3940cfcd307a7b3011dce89229a2b599db0e3c3658dfbdb57127fef2d7397f28d58e2582a5f785c46133b154f70d1f152e1d8c72c366a7e278cac7ef85e5cfafae6645f0d073a183df1537fd735468083ec3514d7f47d54bcdb511bd4e6108dd6e74b9fb2d7b0335df902b4ab047bd232be842656440ee117d98c49204a9fc87bdae24b3216b3fc72f8a5d96dd38c2bcde6ed06df1c3e5c4b853915e0c38f78dfdce64b3e70ac36c0d5ba30022c156a066b44e05ea34eb1968c0b40d152b82f42982ee9cac755a6344d600a05487d6cabd5ad24fa4f258f016c9045ef141635e20f8775fab15c368c561d1b2874f6b1ee4897577bc628cef9c5f19288e702bf0c8735da9513d7f2809f437243314653ddcfbacef7871da681792d29f9e1a044d16a14d534e57ccd4ac7375c2aad62e68c218944d3bb39832f539a3f9800334a83de481672629c537dbe318d9a2e77bccddde27dd36010f248309920a643ddb1fcd0707777d12cd43f6689e2e0b3334a24f3ef13a00abe3a045ac8d00d04f3981d4ce81a5bf0f2f7d4ad4cfe33babbc20c359f8332d2bdd45a2625423c04d913be3928c729dcd902494a62c896dbc15757bf7076a63f82bdb2bcca554ffda3ef890f1d71be26b5f32237660c1b71020b944f532888c6444de0c61a61637dd206c86fd59996b09bdced42e90ca3ad29eae77d8ed8bb3f550c5ffca1db6a2a1b7157f9de2efe66b671403c37505652ebe5794002b9a512e4ca91b906c2cd1f0adf11f6f4ce70f4ca081af9619301a1e056b686e51e4b3b88fe1a8be8cff59e80c087b2b22fca5dd82a18d6e3a384a924a1ba7a00043614bc6d361e7998c93b51ba8f833078095e247581adc6c00d13624e42e509feafb15f1f60a1c71ea5558b39e9d0eca05c01fa688852d729ef0abf2c82d10e9476622a5c548c283a22c3a293dc5999e73551214ac9d116410ca978bb6dc54c60ef399356ae69b961457b832b87eb242075da2ff8f74a860ea67b4066d75b32e6a7deb40f3d814e31347e8ef804c468004efe8a2a7bffbf0453b76bccfca292d2178bcec3b707198828c0cfeb343c7ccf4e027ba11da9d1e9ccee34e0d0ec62c000c0fdaf16a9ad6405b58d3e479adcd7396eede280f8db483164331be1f443b0dd7f88adbac935c1f626de5f2ee6ed7916885431e012ff0e98c870d6d0f7ba134962b261b5655e075d4c56ad6c827c29c045870941d9b2f64afa70b6b8271d5367a9f82d7e7f64ef30b9fe9476faa2c43a98c695cfcd6a16831dc32282bbe5d1e8837fdfaddb78d253aec5d860b0be96b855128fe1bac1ff56143204e779d4306f0489e09e1eb0e919bd6fac2ade5304959d49ec99dbc35b78d7c6e89081d11efdb2c75aa7eb29d76c8636e44593c3d2024eb3e34fbdfcfeef9bf31ac9507c14a7cb5c0fd86237531da4db37daffb9dc72fdb367347790c6ec7ebeeadcb9554a8768810903a8bafba14d9629b2dd3f72fc42c257d650c19d3f93148323784d8252d776ea476d882b3a0aa146afb832eee9122cea78f282890a0abbf2f31b810c76655f24e943a8a2b908fff7fb747c53e9c8b9b0d548237ab3afdf3f40e08bcb6d3ca9fb1413124f181603410319f414c1869e54130a41bc5dc18e0f7ab8a5fb3355bf678e28fba220ee316ae722dfefc967995a3e14586e45d2ad8742403797b09448cf8bf0692f0f9e02cbeb43f0ccd55d6d4e095aaecf0c3abc8348e863208fd92faf6b3c26a8cdc192030c241af45f555f8504eaf346881d31ffad0de6a26344ce3780a992fe5c61e4dd739acbeef4bceb622cffad3d6527a3412cb47bf72c39ae9d5ffa36467ad3c6a9db956193681df7bc548578be472f19492e4f084c42320222dedb6da349f18a8dadeaef2d2a3db0d7a877faf2ce938c248d9a7457352197141f103895ffd2e37e0706d556d642a1fefc61766e55fb2fca8b79039affd0cac6562065fe701f256bb45b7fc213a1d7f221e66198c57556cee95d0e444d20a6067f16f5088486108f7002b0d7d3e07a78a5e0e3896639cc721194893b282ef15add44a82a92140c974015a833c736636ece9246468259bbdce1cb172154343de09848684edd80f442df7cf97e637ee537968e6b59326e7917efc24826d702564c1fe92441a2659caad89c4a318ee0c8c7c3ba3e8fc82aad278f67c73b66968eaf31251dc451cc96b2388f0096e876143fd89905d72cb70c84533d6bb6ea32921023259eaeb5c599d024abf8ee638931ff76cbd9f91889a4b90e620faf1d439b826069d1bb652e0028eb135d391fce4802508057871f0cd3f4b83f9b57cf8531d54ab0418d501f251ca8b20409f8e581fe4c7f5cb8742d0ca5a4f43abf3b42915c8c623027b3ab565a02dd52ce3985918bccdbe55618f4338ed07c480848edb83c0df38caf71ffbbf9efbd489f29aa7fcfd7ebb8cbcef4974218eccc69b655fae43dc99507e09d56275f82463944411445e681f55a2b365b852649cbb8a47d8104924038631ebc126d23818a668c413b6f58b8d90b4a0ea6c85b304f675c25f3c24c23303bd511c92dfc181453eda3444888ccfea55880002f9db37ef3dacc2b3c7202f774c1fc452f1e598b4b2d108ddbbfcce81201f7a19ccf49d76e3adc80ef4962d64b2217ff5c11a673a9671a5bf787b1325185518f17cabde6ee26306de5217ddbf46ab4780c7fda9a47c25fff82c9fafb30c0eae774bc412b4fb27c0b933475e3a886d192330d94bce88fbcf1ea30f554ba848361552d51fc2fe1ac1dc92933f2ae6f46ffe0c77ead4a2ff702505ddaacbd3827b39fe74e6bb5c7b53440b6987efd3008ed637ccf39985b47f5bdf0fe2f7d59d6558b315bd7cae3e68826f1163920a3551fe07e1ae0a49be800c567609b69f77e47997bf625a991a61f7ca8938d85e42ba5246c587c87eb6cd5935b52dce6adf466be34731689434d379f048e26ae637fec70448c445cab5b5f51fb53587e19d714ad12b81f57ffd2f446e129ccf4e123810dd5fdf031a2fc6d66f805fc1a6c74766086c857dae04ca6b703acefba629d72ec6f0f33727aa75efe1bd7b487ab5e76bf64e39ddb272c0d72bacb788d49a8a970c33ac5aff7981f166b625c4ed24b00cacde009215b6be31a078d702b8d9e06d63a0d0aa65724bce3326c630ecdf0ebb987344252bd2edb8090e217acc769f9f64cb3e3097f40dc621fa0558cbc81cc993a855e7fa3a5dd92be8e9c434f29ea815b90d45fea75e9b394bc2d5d594329105cecd342dc1ee60e6a1c2c11a5ddb4c87050f9997b29b591f718026f270be881f5caf9c0d01649efbb34b1238a8f54edf61d536d31bc0ad5eb5fea20ed6f867e44260645550181c1f198a38ee4fcd372f914261237b5b66b2bb4bb323b7c678e164c50d571a68707f3d091b72266607a31ce31b5f42329d5b4871b1a83929bf6eda25ac6170fc143ad15e57e97747c0130c5abb1ff7381db50991da6ed5b33fa21bd240996ad24ff0b8f06c8611776f1312ec727be105633bd58a62ae17a513b4e4c8185c41d8c3c20882257eb015c1df731ea4779440c0b4f3b65307c5c98c90af7ae2df228a1815801be01922b8e89df9237a7deb2936520e6461288a0df5eecc6c49213d68bbdb0fbd711ba6b93c4104e2765f489223f3379fd6207ecddab6f37cf5d0ab9542f520a65f50f05f2cffb95af42a5511e03b86c6edcc9b30149f0fd8b5d05fb31f5bab7ce818c374cb93ff4434e5820e5d5c4f5be6c4b180af3e96db20eaae18d33d7a147dd2dcb01d7a562b1a3d0fc6fee2851e5c687bf56f98fb0986cc729832e91210b370b613ad1366912d8d87d9d60ef1abd698775409c9f434ab0520303ce57c5f0778d83c816c2ad617d8dcef72e4ab5fe63b4e2d4574ec3f3a64026a16bac807fe57819f0eb947a7e7ac69583d090352eed8674bbc4aeed9cb453e6ea442e6dc88bb0129c52612de8039af0c4750e7ccdef7be8f696f7b102e401b0059090638d17a3d0a7ba6419f56797c279457c80b0973135ccb70f7ed5c9ba617fdf158c6c4b3e5e72c32d6ccef6558f1c0913cfd1cdc42e70070ed3f8e065c3b0275ea87f2a6cdd4ed65ae6253eebe85efe899e462dcfb6a38ab78ad521c59ca1d75921f12d6454b47398d3c0790947bbd7d76aaf1021643fc2696c81d7ff65ee572d0998821417d6870986f99399a40c02e850cbb1a8c68333e249834f0b659425a6f9c092e46f161d5b4e6c3e46165c82f93e37eb5a7fb9334d49b2bdc2817dfd1f7092d50fa7d773b4824f2cbb81be2b3bb0fcc186880af4654c10824bd4c69f5ae0d5659953edf2aa0e819071c8c6816de88f465c87227d04fc519a9df6fe9f350e5b6076895e63f18ff49714276018da58d26404d9240e2339b2b8d13d0e64e4df98f949e7e4de2e605040ff6a6e329765f02e0cf1a04ab686e1aae37907f23a7a2fe15913fff9a6bd8d71dbdcf25488deb15e42f692db8bfdff4edf4b8362941c39d9aee48cf935974582a2ce4979765dc94f4929f5a36df20439e21db3c773d51060f435bc0ba8792356f530f565806f2124fe8f716183945fdd7a55b84ce58a561f0784682730424f24500d8ae5b6ad3c6a3ec0f3d8f0b6febc8ce503bd83448f11b5dfddc98571a539ecce9b36d6cc83920e04d118491f6c6ff2690749e79856689e73f75816ed1ef3154c6b0bc987a3da04a457044d5c24a51bd1661061d8d50b72d1da432e9047719e85abea45153e69efae4a6c45d3a35dc229abe557fa813d700e8a08cb41c000a0e1b5c6fff4a8a54578525095d8c37b7813edd3ce2b4052c0f21b3a0acaea2796696ac8a7ffbe91a9ad8ce16e3cd2e51d215bcad686f08af7afe2ceb6875d470f91edf621a4dcd61563f7033f242f2ae7a1ecfe319830348f187880d7fbe54f7db7b16d7d051ddc5906eedca2a99cfe84a7fcde5e9fc13b8614308a0da68abcc0dec62fc4fb200c348ce22fc8185433dc590250cccbb1cb4534a82f4607dafb3d327eee6fa3cddd549c92d79e16af12d283bdb8d713020ef03202870f3c103e4ce8325d4f0a2082f75aea18632d0b48b55ed8a386782bf466ebb4a6829c6596c48e815af9aebfc0f23eef675319b4d8ec5ce790841d61e3fe60d3c21308f1459614355e8a64e8eb728eaf53dc735ab78350d068c1cdf0d6af671983754ed5da762e11b4b8dde62ef74b21ab8b1cc0a84b0c3c79618a3ed5a3ecf1fb0fc37c56f75fb2a17a3da3b9fccccd4567ddba6511b2ab3c293115e4f19411326eef430de9d86b5da5630b29c24b7b28b25caa1b0127656b6695700c86ba5d3b3482a4f3ff86f880121ee940695257b0331f07fea0767c0ed5a9a5004f51e9f5336b3eb6fa1209c86c797b1a8dbb756d86b68a025342c5943aa635fd0a4269937f39c056d902b60aa527b8e0c17eb378085bf7f29b0f5488658efe5ad8e235233720584cbfd5017045e01376e1819eff762eed38c8461324b24d5131284e9972fc3cf08143f1db61b9d3005ab9a4c8ca939a52d01a0cbc4c5fbcc808cae0f53d6238b15e9c252bbed90ff8fc43b2c1ca6c80e9136942923ce7a9954ea296c3f95fe34fbffee238f2f064a9c1465f8df2932bce6a432bcc7f0ef96dedd2845a6b8fbbb71e1bcc4e23d99cff945efa2009e7ecc8056a9b4cbbaca214b509ba8f01b6a1a84d079bf713f7bd3220cec35bfbabc4c086b2fc4c38e9a1ac47024eb66d7575b771dc5fc95bf645fadd0a0ba4ed5b635b3cc606d1d8a5b900ef87d5cb5f0574cfd8af9f49929207b666f78c576f639411181ab6066ea1319e152e89968167ea1280f0922e4a2a4ab7476c6c241cb3fb52d303a95f5f31c27f14ddda3ebed09133c65c2eb5c7642c7bb38ae4cea15e53a87e6927300647bc62060942ff7a594883e612f0c364b4662cade6995e2a15193e605cbe88a76e7f543a62c3edd73fcfca9e6a4b70d28b18bda0e9245b44956b4d81c2491d5824b67c69f40fcc60c988d5776dd02a3f6fe9b5950a4f2fa8bfce96aaf6f986e756b860598a5a1dd2e8127e6f1df30f7e41429bf329526de3c8d3bf294c004bc4ff62e22ebc152e778d65469875131f7360287142cb836d767142c200550e0a0331749712e2c70ee7c0264300f48a27106b70740b9f2a34ffdc33dd4c04ee1737628f3a746a472a4b374b6a76335f954321cc1984cec057cb1223b6793772e11fffe3d230def6a60ffae2e5c02fa6a0a36204c933627221a1756b6fad551a0b9a4f101e61aba5a1722b88911ba699be8857376b61b742837aa7cdd04e1afe8be9e2b22c5299194114588ab37620a9bff2af1898c5f786356751eacf4207044f786d38085c968c6cc52e868b06f69872a68c2794e2241b6459a6778e68037b7f16ca61168fcf7ca80da7ef444030bda832eda0f8a967fcde437c040585ddbbb8653f95dccf062e4cb4398bca850d000ca8da2c9ba657105d5158fcaebceceb1ea3321060b178832117eb3f428bee017620b21e0cd262fb7612523c96d543a47308860a49dd0dd362953735cfef554fa4febf4dd3c9be42e2ad904720089a1d3a301f3c2dca74e0b21f6b74b8c958deba8b56456ed06171d7fb64214a9147d25d0b19b53c20f50742a1861c7b0bf1316a6c43d73e9c31f6515621780864d43cd426417dcb8a1a5dbe5a11d835571caae5c974060674d2515ecbe5fb2b20c00d1b09fa8a52284f2c74cd18cc0ba99da80d8d7b094ffab2bf6f0b9e631e327c75b6b98a2232976dbdd80e74e29ac1a73852784362e3eb7b07b207298f701cf879b857166f79b32a5a69ab1a322587e2be72c59275e62be95858c80c59ac33ce10b8e2a1afa38a083eb45404015b4e49e584d202dd0f77cf17e21b87577a9a5d6641738267224f4935b4d04241478ff020168981fbfbe84cff1b9ff0e4713fa919301cbe42c1d40b65275b423fae78a92fae61215a7e52c5f055ac1aa98c7e6d82a6ec5899b74aaa85d1f596f42de4f5f9a9adef039848508f9ae62adfdd67a4127454635c6300c11f871034fa6d44054bdbf9ff91530fb030d493060df777e408e27f37564cbafd23300123408a776c94c2846b2faa5938b39882490e492821be2c9f34f3f9742e66d28922e78320115fe644df068779dc7cf4438750d5b1e8d117c52c530a82c84ff93a25160f5eb239c6b73b12e9154f666420b46269ed7b2752dc7b169a3146ed1da8a17c7b951ab7333cbebc3831065296295f269ce7f2095ddc500f199508258e8fcded62056c284619cc31a1efe621d6c3d74f2b32fa5b01fa0c2b48c5015d72738d5ba2d95935c4520263aaba760ca81946734ccd4c9d515bade623535846cd2652d13ec714e845e23eb13034981a98eba5a93a202781e843a01b8ddb77af4848777223cd8a9b0b4ac3ad958b64c26fbaeaaa8badcd2c8e5353d4dd3ab706bf4c51481d477472d58c96c98a2b9ac8a00768ad3ec81384749761c5f2e2adb78b4efd63a902c30ba111f186f085d630f421ea9c2c2f2f0a0d489a528531437965b1d9b91a144e3a32c4848f028ff71990da35d4e94a502f38c6377545da5ba53d1ff3a00f50de31db49f4385fcc3d884b0b95050f9d3df82ca84e276427b26ce0c38aa040056d5439d84af59669c83429d9b28eff046a9434db6958c2ac17119404b901e5e915f466dd6311879a743dd179fa44111b8fe076279adbca5bbd61405b0d8a7a200f75734b4d1da9ae980c6499837b37ebfdc15072ee326044ef8b0bf17cef51cd219c32b49af69202e890b2e0f964aa3e489dc2e325b807d5efeedaa170f931f1e7c0a1f188a943c7cc458d29d0d470f60e0579c42a9daa0b6750ee04691d17c592d43f323165fa63491abc839d504b169bf4b9719eb1cd5b5897fdc050ffe27d477c85d1a1432db0e1eebe4ce9137cfe47501f05331e6c4730d13c8ee5a6333b3236164ce975b3a4cf585349b982f0c07d31fe9fe3122d57258d5083237997b83b55496afda6cb07e8ec5abb72ee9389e5e07893085db5c414077b789e1afbf7c586811c04b9024d30c333facfdc4c4df2d9e264f9198bdb412dd5395fbe684848c7958a9387462ca5c6d6c6e239290d4cbc8aeffec6cafa70160ed21c69380c987a02e131e33dcddc05d4777f945e4282b23f0faa29e6767cd56338ca4690cdbbf824245832a3d6d8593bd82a085c2c863771ea7f90523e568eb609e1450c09d276e85f27bb5ef8395d5c7a2f62dcf263c42201e8bf2daacf0464f02d00e3a7178a598cc6bf083c4bc2b3f299d7f98ac326940d04bcc4ce5e982136de36f46c283eafa775525dce2345c257814c28604a580a7fbef995b3abedae32080e34d3928ccccdc67004958cef4081e0248c5390f2c495f3a3e2657725412d6736e6f462cc124fd2b70402da68165fcf4bae04db3a927af90a1b823db3aa7fa0f166ef46e6f334bb7801262efe589b249762026a6fb5537b46641be741922a30af76a30e619239521f092cb045903e7564b0c8c384d279cda09044878d41290c4dbe7f5e0b4940e58c85191d025c4c6ae03d812c8b968f7cba14d5480e5aa60ae91c7889b2cfeab3587a452332b08a647ea0ad8dda00138e929a2e76990804101320cab049286d1d55870613e9913b20214783b5aae292ff587f42afa0d6ff381b5737afd2b9b1c745ccd49ca8bc7895c0d4ccaa5fa1135e9c18c8576865ce7c17fc89e75a8baf6b9a863da6edd2b871fae25da2ab7faca6ca086789335702fe052f620ff667b03bb32d4b9d21e374e683b76c21ce25694421f36ab54ab643400debb6c21dcc158e080c60ed7a5755fd6d34c7d14cabbd808ef98cd791ba40cf0ad4fd74c5689591291eec7dd49b0c2338123feebf55056f427d539a9704d14ef467eb9b7f0e433cecac4eaba3263f1af26fcba6e0e6bf56b0115dff423ba48bd5ee30ad9617ada311bcb015c183c0a0b1ab77804890727eb0d9e4be123ecc7d448e42272b99bdbb0c79d587919c478e998ce3316c1b0d18c4577e839501c3b959b9c060099bb2379ce02a707837af31054ca8ab2e6f196f3947648ac0a5be31b59dc10d0f1cde76b936a10088c5c0f4909ed387cb069a45ab6ef894f2bb261d22bf2c1dba2696c02885de453a6c4ee2604274be4db8e2b53dc57591acf779a0196d49327bbe870fda42486f8acb336989f514e58c00ce77be140fb2ef3e261d7572a71a74b8894bbbc04f28a8130d15b60b04e9da342ecda736264403c8a6d87e4b128b89e913b7b8f99830f81f34ce6db16c01076e89aa265327fe2ace657a9cef284d192ffd9cefb88f4f5701540f42dcb7ee6ce9d7e11ef820042eeffb7e14c915673c5f01d5ab9d917ba0a06b506c229624800d7e88065bc6b55cec058b33afc520c800856c10e4a672f5c0d661c5430c809aa47be0fb829277618098ffbd97426f211003fd4b0bf47b70b9939448a356e76e17018210a398d401bc7ddf02e4643b122586eca392ddd3f0607be63c05a09640ad0400ebd34251cbbd6b210a22fcb51b23403836a5c9410ad6a22f1a39b5ebeb785c84f99ae83b8c669be6b09635861a04f55d1e69b45deb9e51b08c18a98d0c2fc3cc0892f8f24eb34b88319b9645faa4ffc897359940cbeb107170d46f8f0ab975d9f43035134954e48ac8924c3991170032b73782c5ee66003a52c2617b23187ba91bc656ab35e64933da2f132fcc428ce52310d470b42c30d1be86c4c3be2c59733c092dc2291fad2bfcdccdfbb7a208474b95405fba27ed5f6cee31083797f40dd426008b1640cb3a59115fdd67b2c5e558725404a29a8945bd2646847b78d7f33902969ebb543eb1317d757c7a1c281175da85221d2068e9875850264334ada951924f8c9cde52230fce7a58a8f61c59ce9a85efca5333e491c5ba1649737e72a1c6f312bc2b4bd7724040b0315e9eec0c8e254d5627f9b48eb31d3140b3b2fd3e7f60375c661b1a075975dfcab53b3f1674b3f55ba19ac752202ca440c6dd15d2e350a0fa0383263cbe6c879839d05709f1c240157facc945a1edc3d024e519738f4a0273dfff29ae56161b47a0a67f24ecb820b79b64f5b8915e4e118ab2effaccc525c10bb300d3460e6970faa6549165bad2746226f0a25b54ceafb7d93925838004af6c07aa38fd1b93af2857f634721ca08d68a2804b9212511f279f81e6e7ef9f881c58d0f7a6c3a75bae55b6fce48efc98b226b108fe155c52e4ec250daad941fce5f122c1566ac9b90816e23affec3afb6e204c205b464604f47a41af3d986fbdc81d312bd3f1c53e517dfe702fdf9286c12ad11882fec63e9ef93b3a71e7743b655c9c15b0b2d99e640cf67db9627b014997a23104369348c2658f9e658f67015c6bce62664b8124dd4d8951926948f47df16c7a7b795d12a15256ac1f1d48f8ff64048cd0e98bd7745e64ac06cff6ef0b6f426b09fe0290da6a0562acb5e59d3832a6c67894e4ec4a14be44f4393eb100f9868c4d87b93d9dc8d13678892165d251c955d18ed510177313446f89aea13674f69b6d43ea26f9d13cabee7318e8ee3c758776642e5f8a0a097753f4e72051b5db444698fd144b95d17c05bcb05016b2b83ee83868acfd9b1af7c06ddb1506095f8629bc761bbdc06d5b74be31bbb8132dd6391827043a11366f62855b815413ab6bf67a352bc5049866483cb63acff11f8ee08340ec413ab5a4304954ed25ec496574e0c6e60927d899e9e11816804f046c11a0b536a41cc55451569164996ea88ca8e74899866e2234470b1a8a3f39331f36d5a9d02e448808655d1c1bb3ab05612652166c2e1c8948136f7c2758e5f4c66fb272e03bab685592b1d25d38d14c0a1469c65d61925e6092d552c6a0fcd8da102656e25cb20b488d0f406ed1fde8ff084ad52c12358109138d22fb6005bd5240f84c26fb6cdc522681a30951946f0ec04b5ae508fce8e298a71730e5bfabe8182cfc8b819f8af1cd74f062696e2fcfdbeaf6c084fc891b3ca60416a49da4b004d146446704259da18a42f15838bf52f1f3726047f6a0d7daef7b1c488b12b22f6739a3f560086ed41b34aca5e3eda1b8d3bfc8699aec1da2dec12ad374e76fb8b2753ded16ee1ddf4c79bc980afc85b2b93023bfe08ef5ef52d10765cbbbec2902fe2e46a3564fca7ba93852df17ba2c27e10e549a43b651aad9fd0c1b8203b8fdf47687cf96a88833ae617a589d4dde9d9284805a3f0df2cf77d9f5bded202e6a9fe8de00c6251a33a22638e4ff973a0aef355f25fbca27d27bfc20de1d15d8fa0f68cf7cf8252538077bab315a8e5e1aeb854304d566200c1589100fa52bb43c0e146ae0d762b6eabfe9f7b8c00af1580527c2fbfb5ce04b09599d5679e95a6975355a29bb218cfe6737aba542f3983ab8a9806caf128c1f981d0a162c5b40a7b16048e3a1e7bd12cd4eb9041871008f3fe23b22b7f505e17c21764b6b250056888203c308df6455e4d6df451274e31e197c08da87b41b72538084d53dbd16f5db92f9f2163064efa203f2853d458419401418d2b30d184d8164eed1f728615f9a2c7010cfa71e574deb150470a310b53678ea0102e5a9354884dbc7e9ec22edb62bdfd0cb8c36557d58518c3b779c8e840256db05d9ff7e589522515c662559cbdb04a16acdeb30bf40b11cea87663a0059506e9cfafb9cb82e7471bdf1222d8a4a8378defbe1a23f1dd4698b6d3ba5726ee273346d10115ac3fd4e931453b024c5c5ea686172003b21cecfec1adc601154949cfe2d7f182f22aebda6c83dd494f00a503976442aad40d6099826ce73764e0565272416f2243e612503432f391960d36879b26af51d0d06ad5e40745f720546fcd189b762de2aa63186bd2d0b98a240e0b5d09f2d6f7917f5aad17c3750dcb5317676817fe10ef4d498131524802dece3b2128d0df1257a93fcc5ffee38259e73c80bd2dfb3ece26293a03c9614b71fb27f90a37424fa4c182aaa0109c434518cbdd4650ed028d8f6e0fe6a3134d65bd07fd6b24526bf0f9cf581e429861ad3596f07ccf3ff7605c4a65a3df4ed660c0755b079c6d9487ed208aad2ec9a686d33a984a204c897253b060caf3f58727d838f6c670f99d0692c1c1ccad71bf4857d08257cb7ffaffc8798fb525f7f95839cc6964d99921b6f8f2e030a019a19fdb97ffb502fa0e3a2127f05c914b6bfd453db12c865634807e897e012181081ff27b394eb3ec62835a18c078348053c2449a6ed66be2a0f896aaebe056e80cee12a40fba4a8eb9465c5915baa46a174470fbe0313834ea19e148de2cd68b90c0ad9db1d8d5f16590bdd2405564b2a4ba7d6d928f69f4e5229d1956f186ce8593187e23449c985825e23dd93d7f6eb19b0574b0a7b8b4dfd2d3d58aac2b66d6aa830961321d11708fa9981840f133182045d5f72c197357b6a7a1f73b5ce2a5b93c90d5b70395eb2fb8a16a496e85ca31ee0c8ffaf7a76807dc3ef37e3cd237bc1fc1b878da61f88b8bef3e5b806e6701d4d7c3bdab91201c86c0692ce0edefe4c7ecce0435af1d69e90e77c2c5c085abf5f341ec0b52326acc443d9f6a589896dddb32f32dd32951ae69faf8a40b86f3d0bfa56c7646fec44b0cbe5a4900eb2ad45653fffb97edbc9fe1f199306c37cc663079c36e88ca23123362f67de4532fd6dde59faffab66c9ec3613cf85bab8bc75526b8ada60baba968117c1724cda56f380d2e70b063e7cdbffcbd310887a1471158ff032bd8759a919709b0fbee22e7b11a72b5edcf02095a0a158579a00d8804b8ed21e41fb237653cffca7b59517c13f3753c2d76edce12238791ee843432b8e59dd0182ccf4fb14d126139d55084b0df3e98390e45344602494cba482bc3139d2ca9b8b1f7941a246785f3a937f1fb62f8fd359dfd6409337f01abf9f0694184a3f46f842df6e3dd7aa5dffdc97ca4aeafc44685612a2d5b1e19caa45aeb63eeb09f96c814590d4cbcc49236567db1319b3ec0b1a39010c4146da3b7178deda24646d0810faa262b2c4d09a0c12add1c3b84e0d022a627741cd8773e94357bb835631797a6bfc24385bf56338364e6670e08655e2102ddb9a07b3608dd4708602790129951975b84300d908660745716d1de0dfee80a22a75d32666c6c9604888b42501cdcac09522514681f732a818a2327da0696dee7e0a4e5e97905e918b7dfd63021b2c28066db80b18b670c8408fcf400d69a5a765ec50e623ac35b3aa4c3294aa5c8035b6aac1109a04cb20de60c412a66081cb33e3a82d917172fe6eea47d87349401f3a4946b7e53bc698d982bc071df532ffe32bd12161532215e1c16deee3e91d846c5aedf00b6d46f42b9e35598613fed21c8a3770ccc090c7a1e34fe0c63e3ad6d61e3029a7a2ac70a8d1297eb7320b02a49f8cad108cf9145cc6ee0f36fac42fd44ed0dd80b5ba70a469ee93c3729f1538b66027db8a065157579303297bcf485c02ae8e9fd3ae06865293287823f12f360165df0ec82affc675765a3b743d4b530dc49e9fb72da80fededcef4a92db402e146054a5914c86430cd1c76ee927d85d5bb8e232fa5ad5a084bd78d2d655bd87752b8ca885ef61d44efbac40a1205b56a769d5e1c607bef9e6a9e6d4042a1adb1038230efe71a75f224d5747bf098fa32c430879d6ece5f19e333e4b648f4ff27c4513777fcbd0b7efbe9e3d09cb371ed0e9649e4938f61cfe5a2f2722e59a9b575b0a5694c605805e137eee34c453dcb33a9af2a14ac724a77bed066b3700bcf9cbf1e40d328157f7cc68ff6eb98dfea614525c3a3b90d4da31073d42a9c3e46a6133a5a77e893fd0158040217c513b97a1b44b166edf3b458f88c0364457afc6896d742faa9b85f2f9181c480bbabf690d8d12f8a22b8951dde1c44d071e130417c61305a364187e7f3b084c23b1154cac26af9a1877c70a4b188ef60e548e879c476ba05150b1bb0b0005aac1581fc75304df913be21b3b0c1e16f4df72bf4873a0cff367fceeb4c5adb888f8666773a4b44630ca9bc620e7289858aa01729bd4970c4a142e1013421c8e404d79fd8e07a91634e8bcd47d19d9850d81021863f23e9902f94c30796af1dc0fd431fbcaeedd9ec1d96d59b6e6256ac705fddc0a0fcd11c9bb9cc5c028ed63371c3e02c3160a00a7caa5a10b87c4725290019a8eaaddee834181c41ba10e9240866b4c2e0bf9d0c801c8dc668d157ac57debca4b60754a56320cb6765a739cb5c5b2e5adecb7e783075afcb504748f17dae630283c19f1812611a0ba16b74dc8f244c5860a365cf92c9c9e847779e9df74d4bf8a5f902673bd128cc7ba815e6081bb22996eed370c20aab11cc59a6590ad9949e2ff3f00d2e78fe907dd0c8a245d7577b9dcd8b1bc7e592b24d26dd22db408a72f7527071caae9bfdfc3e7992944521aefcff18b28df424a90e76b569f2f26fb233c83660fd601b4b0d79fe3de0132e2ca3f166978186da6e62e1f650b43d675227c6307f998a4530f7828cd1e523333d09426a71f6bfcda0b1eded16f6706196cbbba10e1663fdfef673217f6f4a4b99fd4ffd2e428046265d6c017dc582ace9511080f5093c19a5fc586f946c773e0cf6c7ccd4a2ef6762107d5e4bec8a6d7b83a245018b990e41c7dafa2336beda3c0d952b2cabd101d15e3d68d6f267ac48178a297cc3b3b81ec6f6b494c71fb3776e67b3b0d5eb549f0e9c466f324e0a65e5696d406ae676f309189859cc701d5c64bdb06b173f510a52fa10cb6dbe4efe6f07ac1a4c14778286121289dee821f5a12c8dffbdffd73f6ded18d7b477d5e29af02e47ec60633107e43daa02581cb0b8e215ff9e8819f5fa2d9397930b5ea29727091c6627caa4c67174854ce202d25c21bf8765bfeaf8f1e5bcc11fd592198b1324590206f6f118c51c6d10931128614037015e0a538412da4775803ab99a19f8b1cc650960925c5634e9f52cbe21f03f1b099ca4bc8b0e4295eb413c68cf10eebdc0fc5eb15bb268e58adea081c0574c2566606c5cfe2a274c781937e961416460d833d10582f4a5beb95999b1fcb12a4b845c5fdf4c785d59bb46b9ee5966dc1b24c9b5dce4998b57dab15c61a44807c45e91e2807294fef70e6c1e1db4d43d844ec81cf49e25aa962ab7b02d1578725466eef101bf30334a1794c3eadf1708479ad3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
