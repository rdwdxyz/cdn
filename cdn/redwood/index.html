<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d14b3938217dd50b1d5da2d5a92838396f3bc9cd38a4c390decdf73aa2ee1265d37ae1e4ca25d2533f6b6ed0775a18437665febd8ad503cdeb9b3c8c7f33bb3f8c75c4f8ac59d1610423f4fd7e1684af876aa8bc8836a2a601291c185b2a6b4b2785285860017f08f16c0f43a3fef76e7a76bdd82d0acd37362eb4a8e29c853641d473f0fd18cda10bd3421d93a4de60a8d8112c785babe9bf92a59da946c4172d2ae8c4e6770a2bd50406f45d94aa980a95e9a6ac0ce1bb0cc663c136e8afb1a7ef1af20c7e959a9225faa5862781e0722189f7c32d5d062d0600c901865a1845f803f704e3ebb9e3955ff9bc7de7340d663254f831cf7490ede3db64a39f92f1cbc821c1bf380cb3d692f6aef2b36044065d553b2ae295b5c6499f9daab1fc76ef73a6052632dc299e8447a76cbad858f91cb2d3f1bf88c3802cf4acd3c02ddaebcdafcfefb3b3de7f56e5cce6161ed468b4b1d6c91994a46d11ed15db4244b42b4eb4558cbf9c56b0fe6f176f743f070eebb2b17b632447f44abcc8a4042a8027bbc758f85d2bcb8f171c01d76d4a98422560cd2da0265c5db22951c58e85f506c533f6008454a1de703364a010e8fcdbf53d04ed0465c2eeda813a460ed72ff8aa0a5f1c1c6c3c2d2ed1db5757dc2c490f3cd84584ae43c4e590610c0a1a49cd12e7eed6d8090ddb64fdbe3139a50df7f3fc880038f0fb34bc3a6d4d2623043e6e94b6a6e9bc072c9aa9d7280a997ae439028bcf42a6293ca4d7bddd49283103cfd17e874aaaec2a1ca06f5cdd546fb2ade1ad1ef66ab8cf807af3193827c636ccaa32271d749571cba52cc5fcfae8182fdf7c1c716b359842d201647880381224122884874b3fa08bbdaf8c6445acdec4abf716331ca1ef34326cd82010481e2a04ba44017d4c600936bbf94d25d2e819552d66d3c350c5dbf1cb91dceeaacf7fb8c4ceef05da161c18ff8114bc19be88f1d1e8de1e6ef51640abdd5c2b5466e8b8edd7fddf24a353b47f157c298998103832546ca742156cbf1b19fd9b529a3c83e0bfd795755f8024ba746fcee5b98704945b9e6ade6130866df3727ff7a4e000c93e83af641188c89b8fc3723cda843d0c4643ff6e90747832b3daa57b88839369d361d726e1a4b5af87b2bde8e4502d3e9c12b0fb57ff10376f86a0ce57fb614f37c0225e250b5ac6f5e1b2d15419a2e238cab025dab2c932167e79ce27a01c026ab50aa6b1f1c58dffde5f11f0d0f66a50b2215ea49bae3124c4df8fc1b48ebfb666c213a21a91b98bce0954b71d6428894bace5857a3ed17ebf79d7c012edc72097d330dac81bc498593c29f3a78b81494ed569bda03ce3959e57b9755ebcfb938a51ff89799193675bc1fa06c9a4b04b6be105d7a62439946aa6b0a0ee3c2930c1eadf1643c46a9df99ac1e86b5eeb61e8178111b7894f4f4c7b28eea198751b6241ae5118f1ab27ae6375ce34ef10348e00de645c54add5403e818524ee76b74312212f9b0fb98f5cd5896b47e3f6073858f17cc59a94fe067f7ec579aeb01c0297626d0f5b05382939a82174dff793bdee37d5cb61feb19c6445eb2faad17fc6926d63ecf83e239c840667fe05d5d490fda5255687a148e211c76dabb78d50b7aa82914567f2696ff572a68134117681dffc9e4d4dba3f6ecd8df6c3034a30c33f88e1a721e7d01e9b6f0d6bf0b7bc6ee87bf766e6ed4e2914c314e5b2a3dccac728d6dbb6d03ff5c2e168f68d9bb50fc61a310ac216522f57fa990213d6a457eb496a5f889da9a37f5dd576549166b325e1cb28bc90a6f909e51e8cb0b9742a6849367817080f354d0c03a8e9a120a2bd3bee83ef7a570a82306ff53cd2a25cbccbabf1a4d102cf53bedc19bc988be8c7c415429b0f5028e03bef7cd9587008f335ec3d1ae82c2fe4852f716673e1016a42d331bff78a987f3f02baaa2e79d66cb721bf4678a454da5dab8a44e718cdd7992a88647f2c8f858e73f3b0289bbf6d27989572194e4c8d2a89b21c7648f6d9d04a8a3ef9622aa0e77df8abbf2aeb40e1ddeda6219114a105f8cc30ec1e722d0d8c8426cd46fe8b43c319fdd383dc1df4a4afe3a787812f442fc2b9163cc768396aa4b9a1ccccca185bd9bc4b22e2a735ee4eb0eb4f46b196c563d8f6a3fc0bfc3b13d026bdeb318dc3a151f6b9708023764bffc4cf271edb93cf41e459dd1de48128ef510234377018cce72c64e03c8659ade1d2571e798e75c95067515c6afae1d6caf8d6318233a5448e984b1678f6eda751b2f862e3a1255cd5a8b7ee382c8718d3da9ef9bd3c8359fbbe97af3b15131616727328f6566c15ae96fe1fb6a4f526a36a6be6ca4bbf2edcdbaf72ced59572b3a3dc650fc23cff949a83816dd094ca6c6cbb2d4c121d63e0487deb19a360f686416691a60a126503b6db5c6467be09692eacd27090e57ed10beb45d3e4304efc81a7e58c66026099d041efb2b79f46a6f376700b11689883b6a7da6ab8fc69fede5ca8d7624ed0e8ebc671a20666aa4b0498a69bff279ae9f86f840d03e865a9525df6c3185fc69b072fb06951782353264c7c7db76c7358cee488ec6199f0bebd6b673308a5a2f35d2bd654f9b0cf834834f304e71bb1c68cb770a42b078077c16c850aeb17c206cf4adf6eb4bd2cc37d71e1e3610fc1030971caf2419357cd998d7e62d87e8f9f2df7e0ec6b614bf6c0fe197ddb39451ca19372c7be151c3ad460a6aea5b3ecb90a48c3f7bef6af4ef2b4eed0ef10cefa6607b0f649959b2c43baeb0d58933cf62729dcd050e5b8fd957b62394e6793fa9939785628ce299e10159c444958790d79106004e5c570b8d1767361a667ff3a76126a635e0a43d40931480cb38639aff68802f46ed8d7815b43bc7b18dd1dc4d04bfa63995138ca575f47e4a61cbd4f965e7c8fb453fa96ab4deafeb207ae52037616e73374e2fc7537f1091b096c728849ced8c6e0d30ce1482ad84f19919eb18af7be17d3b983beaf44cee384d1e9f68f5ad007c4796d3dce75a0a7aa94e51c631c8f819d05b06aa383362cedcadc7b42b22e5bacd0899afc36f8aa600c5722f9b24afd663dc1d589a3edd8273f0706199f5cc67cdc36ddf76af6ae220d8b67c1fed373564032823fded42bf74fb3caaff7ab81920b22ca4d2d529dd0101d6cecd9d9ef63d17b599be7284802062c6fc4b64868d73dfacc6dd03911e1332ddc37cc55fe9ba36dfef5685a1ccf64642298bd17fae2988c7bb7ddfdf316033ff0971ac576ca4da4106cb0abb03994bec8e9887d77e1ccb49dc66974f49fa0aba4b2fd78b795fbcd64fa606c10a79ac36c2e8778fe0612db11891441bd6fdb54199e5dc9d83935b3a1b6bc86898c4cf1a96449d4bc24f40eadd5f0b5b900f24c4a88a8ed7c172605bee7ca19be01988c203b9294dd576c21cd7e10eadd2c991986fc79e47ecd6efb4cc90b4c0ff3197b4892116e196fb3d4452f63e2c5f9123a45bf0f84a9d40599ee193e55096913e736436829ccf578c0b8e5c045d84413d9e5d6a2c3e280d36cfb3a7f8e2a4da7438fc1441bc23a0e69ea184a4b85cb4f157c2ecb115b69fb426a66a05e56a00c3065550878892e8ab48438da488cd58668acd5c7c71bf1feb379ee63d8b23e1b2954b40fc7939007b71c58ec12a32020e25f73a8eebece90f682b74e4936ca11107f73c5f125d5a761c802e82ee8df4a83285f66534444a50aa380c41dc6e721c7e9687ef54251072f97574ed2bc846a7c7020d3f487801fbfe37f8e22430fe5eb3f347f551c1a57873714e2911e1a35c009049d0a4f5db7db97b89919dd425f889df96e1d7b3be4fde6b5c64560a306d70bbd11598248d5d457e588143fdb0342e8dcf01e58af73519259771a5bd97e397f247289f5dffdeb350cd6f760587ce79f7a0cdf453ca130774280777d00f66493b294f3a2e5f3428ad760a2b09d45a5f1e5e8f8e3bcf22e8db90a637fbd440a843f67a8a2424b1d387c17abc75ad49f4657136fab1b38dd3e0e26e66022665398140882cd3d6b1191495cb5a94cb9bfe24e8fff7087496c7d56b7353c769b9c540b382f904bc97b99bc59ec9168e0094ce26aeb383f93e251e69a7b3171e74819dca6511fd693c049baa33417df143bb29dc539b6f9f942572f53c192098e1db15c9a1194922d00c3418138119db3a20376e7f1a0b278027727072b45bad1b7eda9d69344a3aab3f224a7f4a42b1be526a0ff7849dfbd396e2ee3bccf84e3313601e38b76f48e9bb2c0eeefeb2d3e3849a2cbc4aaa855a30145cf7924851cfc5c6b5f726c816817a1f5b4e36adb378c0d8c38e43731082e33890203c7f6cd49373aa0ffaa0ca5c033b1b44cd65e3e775bb6b4e28548bcac11adfc8ffac446934095a34b3887c0b904a96dc32cae08fa43134f3bc06b60a5654f7f2406c3cf9c4eafd403e541f87041c9a8b23916dd0b46f06702368a43acb50119b31e235f4574b29307a1da8a2d6758f466a0cea5250a8611f51f6759709803820c5888f5ffa85d7e8b2e5acfd3812c8158a917317d50fd8b24c890227c590ebcc6969aaa2ed16163de2412c536d5426ddcb8c038944772a00883a39911a8079d8cf9b3f02e6d4c02c4b79075ef7fe1c3517d2939d61315f9dfa56f1e2b289289dfda48084ba1203ba5e85215be8d8076dad317024f3ccc04790396c365fd98254e5e74535b81687146157bb73fcdd0fcf866cc99ed51b737157948955ab7ecd80a38d6dd6340a1501970836261b93d821b2601fa696afe50b5a79645d1460bf35a1b17eb166fdada2ae70785bf4b46143df44d9e9bc240de5f17efb09e14137cd6e0a75abbf1bcdb31f35817c1c30eaa338cdf6293556f9941a0e6e4e83b1ba18c6a23aa7bbf3896089365cdfd87f7032b9e60473e6a1264b99a8dfc0e99098d4acac554d42a4bf72c0135a5e367be642bb75caef2e2c364d3d1c92bf583c26f76c5db4501b655222645f30e3a46c5c5f43b3b3d83bbdca930dc544cc9e272f05cc923201d48fb2743c1f6917c85d483743d201a9726c03dd15bc4dc578fd5b586d68c7a4c484bcd8800641772ca5526eaed95a73b6bc24ec762eb79163fab9a7d0180e422185b9fe76aef4f031f6ed178073c4bbdd6e8d1b4409d0abe1af2e9055acf6edfe2b0ee4b5f00a60a3814aeb81df9328a2c76e1db84b8cf6a0c5732be54ed6af3a2da6749a208c54e28e3bd980c66f061b77d00e89ecb9d852747037b9084f3b74aeb922d96846fb8e024e1d76ea223ecc432ab740b7fee5654caa337cbf72d3a31bf210c9a3828aafc1430c030215b83514d5da1c7322b03af0fb93c3d2206a44f78d6907ec8cbc1979737b841a4133ca32a930c7909efecf50f5e5aa98ba433186fc644c98912015c857bf0b8d477465de4b628d6b8628032db6ae8a28807527b4dd2c85cbc89a1f11946c8ed80f73449c174f41f99a2cea3a8268f78c9b3b2a97bef0d68ee8240287ee2ffcecb9aa95865b5e67b187e2ee93222944bc25cbc329b8cafce2e4dae04d581f37f79f90e6f2ec71aac2397fc398422378c2944360496c5c1fb8b650e47f08ba188d1f43037550f50c61e8836385208ca8a578945cb18dc7bf07e83dfbe7bf1fd129e4a69cc2da46fc2a57b9695e1343971f1611df5365e83b7c020a8272b223d82090b2460dbc89be8f28881943ab15c440ddfca10eab15abcc1f96e65aac56ba39bea97717491e2416891d64cff10352949686f82b4319f3e91f586d748ad34fc0d9c3ce67b73de72744dea7bf26e5a64cabb64b7e962ef36db8333b45c303b8e3cccfab1f699e3bc3b52c4a1d9a9b1d2cae56da3e0806906e51adfab6147eb7e321ebc8cb08ff264364b8e0b5de32dadabc683b72e2d9c64a538fe867c13dec6fca77b70a952a212f7a05cb1f2cbc6077f9c03e17ba544a0c8df837644ea28074df49682d359e42f08712fcc92fa3a871f86e0431eacd26c5940c9159538a5ceecafc81a6355d54f4aa6b2c7a54d58590209ab7f7da53c694419eacc7e67dea392fc0b49402ee67a2eb4154b21737ee4db4913bda2de696d4f0e4cdf9deb9baa8e2d25e1e8986f92608024299b011a3fcc761b9d23b993878a2177529bbe74c35511a2c710274d67184823e5e79dbeb9e78b85a7aaf211e87c2e028b230c695c2f37abc0835173eaec2b8b0463ef8d32596b57adb5e359b8ea94db23160418d7430c9fd53f72db184fe4187b3a0542cdb2c08471f466326720a67d7b00ebb9a20b309e655108b94ef9e7996bab96f89438f55449783261345762d202364132b792a795f481466069a726839a76bbfc29ca6416b3c9c62195b26308611d8af01de20a609730c8ad8e4ef4882f5d60620727f163f6bab434bc39250646d266a55d97b33fc724c5f40cc8d1d91ac771d6415e5a7da8f0a2b704d7096a5d255ba9c8564f03130c6c4d3525bd95c88813274d24c79639c4ae13be7fc6e904c91b260aa80f2288e0861565f86cd7a5c777b23a0fb94cc57122f039375b85fb1c0561959f16c663bb6e652d578fa998102c05f6efc6d0310f1654182865ed13f9857f3bd4f6d2543dff362320312b8d321821dfdd9ca110217ac8b268a69461c79ea997c3aa636bda32ef62ca27865158177f9c6a5f12efb1b6c93f1535d6dc805274ce3e29e2a7761b93db140456e5e282d12ee3ecad6eac1779c984d54629a0dd3cbcb10a1f77424d0f4e57afc083743adbdc4c34834b7c18e6197dc1b8bcc2d2433e0235091237868d50a2265638677c4b951a7291b898a7c3a61c265e3afc18edf5cf9f2f1750f979d3fda9baad489b135ff807db4325367284fdc0189608e77da375422ed6462b060a10a6d0ec7aacff9de84ea08bf14a16a22b40af48de753c144316212e3be3081142b7979f8c4843e3e51e075b824d6bb0a04b14f07cc2a39016b2eb0de4354f3627441184e87b1d74f582348b61b0b77ffdbd113d3e05aba52c55001c9ae1c44ca0693e6516c2c492960fe1cde66f3e0f58aa9cd13c393d1266acdee1992c881cbc7139527b6975e2291ed36651a6bacb6e27c570b14f92f939be9c354c53ce94ed4f18ab0a61ef96405c8779ae1294bf22c5f4366179f9f843e1599223f615afad952bc1e355d97c4b9000dded1dfbba78bff0b5650b8500ea4ef7879d3f7c396eb0c5eae138ab5aa29e73f870f078acf9afe655050ee09cee521b9905023f47f51c9fd963609054bb47f93cae65b2f6c93dac16e58257e895b0549bc96db05099cba9123479ca9db41527c68db3881964e0d4d294d64db85967a899800f766aba0b0fed23007495ab464c7c301ed59c6030c107eb06196abc8d1f2c051640620cfd5e645d6673e129eab51747f4d284533cb4de3d4dfcee3f192ae18eb0911037c89754ec1e2f26d8d27a33de341ebcb9a5a06145bdd2b85217d732c8a6c5dc797e4d937e85f65f1ab3ec801adc2eebadaca5829adc5bb58ba6b7ddb06d7203c3b5c6ccf02625b4fef73ae5693ce787beaaf579620a14fb4d154929fd2a68300dec59a8f80d8387978ed70a469952494ebcff7ba5c4c96181efd5d845a139c5795fdaa80d238790c9b7f6e3da87d977166414f397f02619e3c17663d1b0cd670e9f359700c59f15675d0a24f65c8beaabe4931a8b9cd896876b6441fab5ca20c5fe7d9519775993d6acf69f06d793bc56c81da39fa6662785b12f46bb67a6e107e37a7efd3ca845056329df9a35491b679a2600154b169b59fb2e2e886bec415d3b2a76482a8e95fd3c0e61e5b5790e03ecb8dd2cdb4d7f4df199ec5e9d494a9b9f7c5e1c07679d314388952d4169ad6bc27bfa392d429e12a23ddbfa451e9aced669e414588c06c2037dc36189e7e738db838b61f2ff5266debe6656ea7a22eb6baef6681b192092ea7dab011ffd9524dc49ff86cac83253701b25379e5ad9f18af4a131d0439bb0d14423fcfacd0a399c303c75cdf02e8a0e2ab9629e6f71b1a4d6db27ba9ba9cadcb3cb1d8be72d66e3262c547034bfb956ad34de8d29ccbc0d7d4fea268bdaaeadc2f23d44f82cc466d8ca1b277bf3aaa5ad3894c11019cf95e8905b15bfcb68c9f9b141d1d885a86e4ec56a57f607589e9436575a8f4580deadd977acd268ab74feac9516a34a803eb8d0f75f9f25a42222628874d31ee1340ef73038c52d5642ee21854b1e419b716f86bbc0fe04d13adae99861f502c903698bdc0dcddf51b91938adc1fe220b274ffa31bef1acf9b21fd720600c7962214eb8e2722e7ec2942a28d420120924296db6383a9e0f2dc42e926ad6c37b4a50dfa1c7fc907ceabcffc0354385928f0d7acc3096affc03d8bd55a234b842da9e99395f69c21d2ab5ac6b5aac24c465171b1e11fe8f2b2c08c0dcfd2abfe539404cd02bbeaa080af692d382d96059329cd8c9e3d3c02005eb1bbb95a0a72abc73b783d63f7372e5901a5f26ce220515270d1c424260273b05e6b576f1334eb53de4895e297ba1d0c471d0bb3c345a7f9e7dc8ed570332281260c2f4e37c24826d6d1c694baf6c2e861b2cf752367a5f7d1bc2c2e6d640f37e07c90c33ff64f662edc946f2eba92449ec4cdbd9ffeab514a073ae3cdd3cd2b9896412a01376ada7d15473fa6d815b78a9e42e1f33237918310fe40e98b8ad6a2e0c72901872cb1cd7064340927274dc566042b3a3fa9c7b1a12d16f54cc2332f6c9713bbbe5548f847f0677d491f1be192acc931a50025c10b67c3f75417977b6a58744adb548b6c66359b4abee81499060e59c2dd07a743f9605c2aec50f382e55a24b59cd6f0bdef0034ccdddbbbf17f3b2758511a252c50c13e3929460db6e97b2bd72223fed05d10ced8b90cb43a611018c8be07420f2b1770cec47cbbceaff673bc5e99cd9a4ee9c2a2b783938add84fd92a7dbd3feb4096a8f8fb442276a5612a5e59315bbff9fe495d0da918e6eea896daca421df6ecc483a3a0537cc1bc98cf1e7dbe96d3d6800177ddaa6e75653f06021aa8d23af701be75198354a77b6230a7a73cb61e33d7532f51b0153a01a34768f487805fad2e9f43240cd7d91c132a8f292e4a162804b160bfdc37a2aa7306da55a840701b1aeb774106ac1dfafe7eaf2246ae7c83ce3c729f6cbc23233356e8dd6a63b58d6f4a1c325b4d01658f28d6d17ac40262c8f408bdfa127476fd1d1b0b18cd53ba8af19279783e2f4c1a32ff0fbe4960f1108aede139d3d08d9f2843a890d8693e5e274805f6e300179b9ff6b78e4419148755ffbf72a2f767245cbb0e64d3e76e32e2b3f61594cd03485bd1d9dbb1d6c28d9baf37d3c9d7a45dad37e6b162c63599b041bf8c0f229efc848fba0c1a9aa6b4e675a0ce4f22de9b4d9f57436e64a5737856313c25d7698113a62c4ae1c1500fcf67020d474c76cf4016f7d9829b1b1cee9b9e13e6721cf0dd32ea7a7d3a38f4730de3485988ed7b2c7cf47b6b9599f22eb24d4dd8b29694ed27c579ba052126440a43db0a46ada82192fc45d98ac667e5a4e5f0b8a5592b7fda729012e638567cb9e728cc84cc92d9a3550d4a53bd22f104713c303072a2999b1062868d79760466b53380b8b05e123037613d58fb0980f30db2f7722e052f263e70fc576fe7be7be4cd69de8d0ebb6cf31aae9e0c947d78c6e79e2aea31de5318c00b8cd2655cb4f82f4b2588e38e71df37a8d97a3f66e47db56c03cb4bc6fbe15a86edd53fd398326d2c2863143663348fb589db87d0b3ca0dd39d1d1294c0df6885f129cfbe5f2bd72e4fb120217b2325d32bd997ed92eb93dc36b1164409b5fc1eef3b0d7bc9540f65dce7fec1c739aa7d05ba50d78de9abb3c9087f2c8caf3a42f12572866d69818231d792b095ed5a413428ebff7a629cd49297c5a201c603547c0b30443b704bffecbd194bd31819f7a017810c2f6644e9091f3c2926940d11267a5e7fbfd22899acf31d9b7d1d3518935f0e23b2d828fea175b13178edb519116bbb2c0c9f9a1013f1127ddcd17b84b5d9cfa834897c8fb2655bb7a32a0f156b259e4d1cc6e0da6c702b8cc4a813193619eb79d6f0e9d253bafe3141456dcc9cc1b4e2aac866b5702bbbae026f7bbdde8c2f3fc463d6466a66541cb1d017ce3beb579aa6df9a802fe50ae623799a71193eabd21663ce61b6883355548bcb19b2e7005ec49c6803f5a98d8834a2b16998959e288a65022f38cc0316a1d869ce5656dc66b8e319f734f5d53c804905e1638993b9d4a4c6c3e68e2e661649927cbf143a712c0fa7de66e5fc8cb26e40e7c3240fd169d35490d9eda24bdd2ef369bea7a56c73752d5208bd643a251cd8d82b1d8c40546bbfb6f5dd4c7e8caa728611096ee8e3b5c8cac5a3d129cafe0971d216cc634e938fb2d95e5f319e3c9c82e5f6192e683bcc0187c9fcc1402d34028d6da30edf689870367ceb68507ad54d80c7f197bcc5689ce030c10e1782510cb32e3d9efd8b7ebcbe89713f98bbfd456bae5dc1c0c03a4caf5f730c48ae1d3e03131ba3cc2443c89095687074a9f9ca9257e2a0951e0e9df16b058ae9974d536ce0afdbf61ef7f7ebfc5480d025cc734c99f4381f8a4c5607386d2e9a5c7c17f82933feac2df20f3a893ac2fa93ddec5f5d3de8eae8df47c08ff085aab52820efa95e2b4333c4f35cec0b00b927d3fea5bb2055658595345d55a4236fb2d58a3c0a7c7a479bff20e9aed895e6933196cfe73cbdab4aea121631bdac3a67c19d5e5c001c619340243295caee0a66146f3d55c6ed2b4ce6b7a0e996b52bdcc0b574c9206cbed16eaa8358c81211c7c36f836154aac7cc0b6523a0f9d1d53859523e4dd70da87aeaedfa0b0b629fe772fd595a3b0589427f63659f0572fb3725521b9d40c8aea118407e6d8692f118e37d3aab5280348c4d262eff398c935951e545dda504e9dd742110b8366e374fda7daaea60d658bec4b5d1ce37139c20332b66b4732314a2bba11f8505e70239047f385782078ae5cc98fd36bd0080b7fb626f86eea6fdd8b05ae82bec952e5e1221eb3f8ff85c2f752f1df294d968adc390339e780daf90d07dde2fa0a3b8dc736e0a0ff13774b414614154b5796aa04c855fe22aa240703736952db34337a04b0b99bad063945f2ec29eeae5693ef6f96dfe58557a96287c4be29736576c4c6c74a96d2c878e1b5b80083510358c53505695b234b7bfa180fca4eafdfe79204165f39d94730f6423e5bb144662819eb10eb7e82d8eb5b322ec7141dbdd2ee31185c4788e5f510f4549c84742c48e845c9c67d12f8d04b5b8ad6d3380697310ea7c4a2d8ada7cd32d96af64de4a66f8d127e06786f0b15d980409127d92f76b6d110762d1c2a888e79d702fee0eea591d85d595ee3547f93b958abe79bbcaa99f450d07378bea64c1b66b48a4f1bd882edff4bfc78c1be336b116091e712c8a3a8296c4efca9505d78cfd2a011197fc310622941165b8c834149f7f0f0ca6abcd153e53e84a06daa2d950ddcce11b3e62b2aab3ff2c201c4d87e3a7310ce79a449da1118fa042ee6d1ea2e18c687799eeb96efa833140888d442d2f85b09d29c1f3bd1bac5ee5c3cb9ee39c63b2719da8c1d28ced7f3a3c33e060a14c7f71a3367d0b2b05e1753cb5f96f7af53660f4d8acf913e0414c95e47290fe4d839953603b4ade3e9229142497a60b5e60d796e9778583842b4f869f83e2f4d79697f8e3484afa8be88c2bd0c1fe8a6670f9ecab9767b48c956efe22635d2ca6807b2a1b31fb4382fe48f18a1dd378567aee717e63bfbb536f5204acd521e279606414792680563b9c45ce8ee7eb0a20de023b4b75e9bdd2240d0667881ff015ebfe46ef2a4a050c41d72f0ff13c1858d49c9c51b42f6d1f66275f0d532bc8415033a6442f4743ee4dcbd137189f5309609bb2a59935797f454f67774a151b241286bb7febbafecea9dc4ad2439a54ccc9439d497a8cb660989839278963fb25ef3cf15e125e58154b64a0331559ddb3fd39a1460917a9189e7e7348014850920248311d07487818a2184f81fa018221a4316052dc325dbb7772222d27e677818bf3473e15677a1eb0b3f0ea19e63714c4d9b01e9c120280e545e59b3bc91982891747d3e7ca862e505ea8cf2ac8977f98a375f165e1f03919d62a30f7d17a9533f67831903bae5ecf54358dc965f95f2fb47e665335c251192a2cd10ba639a94f7bf7c359f5fdf1cb24adaf23b98eb8899eba90e0ac8a13bda25c013e94bef518f62c46798df72fc7eb0295cf02ab3a0080d4078881300d75ee0b173cde97a6e72870cf6765dda8ab78d2603c43942498cb8ab49362f9e58a0f28d2689e8dc84fbfda56d8a9f36fd645a4765c897b280140e745505b6a687081199232c3cc9e1110a343bafe30efe7162819b29bc9d9382f94879d7f404dc56f1a13eb1622531e1267b070a3db080ccbeb08bcdb02b417eb15c58b5051eed4f0f5f992c199346a1f94b99804559e56ae8767a81bca58f384b9a86b5d5dfd1c067b9a37d356fa09133d0c0f9f038761bea417d97ebaf200d1d5054e9bc107c164bdd6eef1c77fc5b34c4a80f084bf497a1432676aac616813cefaa68bf142dcbc2198f5e7ea3db9fe3aa3f9eaff1170304711b980d8ef3f1a235e507996533f5531db8c6a14ff402bce5e0fb88c3c1d4f5a21d8a95cdaa6f697081bef103fe05c0eb6bb0dd764a8e061f40c46f0dba872c718295a690b049846100b42051964b24389c893f2e9c45db8cfe9affcab3fd9007b8f29ef569ddefd51a68f04e018d9985d2720f99974391a4daeeae50bb6cc58192cde8255ec108c1326ebd47835038c610d80bc47215f2be3a23c748c6a7c0bc656e1ef06dbac6318beff52f0c569942a3b32a413369816b887d5777361d94e149086d2f59db60531140910fe0f970b776b5293cb37c8beece3d0e3eed20cbbbcbf05a7c47dc80545747808a1d256765f5ad7ca5b949d0da4f400150b58c4f091ff45f2485fbfe0bedc41869cb4b5b1aea94303fb7f0e8cf71dd2b253b3905c87be004f35b34194a2627b74daf9fcb2f1790d5d0f3efdb593f9b796ba15e84bca1459cddc471535948f46fc631360ea73f20bce131e752502f08e19ed1d5290ddc58006c4c145656f3a3ef81b3867447cc0fcc5369fa6a1356cac4b8b95d631e77df0f4ca2a1dc4069bef28d2bece9440fa3807f917c3c43eec294784f112e8068651599bc6a9ff8ff5b7ebd98d129dbce83c3fa74af544f0efccb12ad889a294be110694c12272962b60b775b95dc696f0f259d05ae92a1bc2f741089d2b6e98e641adc4b860c0cab1eb99eb5f2af1f0a1ea7671b3f0a36a729dba8cab1e594fe49778ada1f3c6891fc1f7c8c5d750cb0c6d8c9ec3dbaa4adf8ac935091c7cf876e547e314b3de6cfbc21c95d0bc21089afa74ee9cfa65e3d410d58efaa61dba397ff3c9bae0326c57d9a5f200ee38771a944e01061b8ca9d8bfcc231749b0b031cd6e1bb115d6c45575edd6b9857a8327d30852bf4c431d55b949e0593532b93f0e2783f7b9008c187f539c640300f5c552ebc418441ea8eb06909cc4cf8d4eca22937d5e7893554a4a16cc21dbcea4f62b5cf6777319497ea5e4a2ed5e3ef6c083eb541643e71cc1d2ba05a466577bdd51276fcfd2602bedc8c14f1f329c1989c3bc7c4d03b33acae8463304f48e14b5467d06d201aa52696ffb5769090d37b4de346f723731b28c3186f913cd1eb525e8b6ae3ace766d19bf0777772940ed3a60ade5b3ac5806812f1bb0eb7dc3f88a557f78316c867fc172bf7bd66671b943d18ea4893f37fd7c2a43f8d928c5a6892d195a7ed4897a07c13c625276f4c0f3ef9557ccf4ebaf895c686156dc50618ac423cf0c0d5867a4f179f4c9ba94c1d55096114093a945b300fcfc095d87d0ae41143729fa49e832a803f44a6e743ab0164fbeeb0b3104716c6e37c39689b5a8733133832376cc3d6f94a9dc21cd6aa91cad052b7809919a1780449fe3c5a591b9f102351c98318b48c10b29b8b8d3a0128ff56eecbc6397bb3c1d9838f84bf1bb7122919630c367c2a4084810ce233c31a1a74d74c22d9afe1035446365097d47cd18427e8438d4c2159ad78fdabb453d2113197cd6df39e353523536d4213cbcbab21b9659b1c02f933e20f893f51e7fd04951d33e1d478f865a8464e14b9ad19d0c40d9b57cd1106dde6d8ae98e33056b9ba5377d47db52918010037efad16cfe6dadaa1e245f7dbf7b438bafb5d2b880488e978ae00d250aa19b30d8481a971c9385096679cb9353bae0850c2914ca85e183ea29c85cbcab8941b4d3a1c46b590f9f8e28754fae4c253faa85960da530f814c04f1a4fa03c8fb1cce993871a0ee77cf4ad32046c8ec308a4bf2fab932788067e8b83407ee92a2cb4e4dcad1baf8f2f7d8cc56ab0c4f219d0552658a5799c54bdaf4782c5a960adb970567544c6b23c019654e8357be456b6f1678d9d7c5c86737bb9e91da831614bc191cf7595e38d9149be4d3de976f01ba647cbaf92beee7d7729e952446979bd96189398bd5f31655e365a9f1171c490ed716d794855960128283478ec338c5edf466a8d24df3924c5f5cd182a9b48d12516cbd93eb3b172fd3e9c3dd9227e1892459fae5e90590af396e6d362e9f1a75f7ce74171b70ac6c17510ba8817afbae0d34c25e7a829a3b5f9e08e038c232765747475563eb4a2a3e8255e686bb55f8b85cfdbe4395b8c0944ae76185f026d3147e91390c9ac70c412441b7e9b2b1862af639471a70a7dacdf381df1a268219cd21ddccb68b6c78c243a4aa9dc9eab0a3b195b6ec34a4aa66c0feb59ef74a43df4fa282d7ac66fd2c20f9793b7137bcc2628dcd2ac5e9798a086484e6d18b3830b1605f3a09fb9a7169b159bb311bbd821828ad6af15453c0fe197f3b42a6cbe8048503b7f72940a556f7ff9570c76bab85c012eba3870d93975c57fff024225aa2f1c542bc19a67c6318f96c456581fc10827aee24c8bb4972603094b1fa92d974bd2cd51e30239d5f707cde56c929b770cb636f969dfe68ae2faf43d0135b590d13b77d975a269f2bb040d36e86c875af69c1f56f3d334ec52c50ccd97bf20f23a5600c4cafd5f6ac518f8aca68aa2a2ce1d9b6a5a8b730995a6b149b946eed50609ea8d20778d80e2b5de8c9627da6836992e210c9e4437a9668ba642fbdd0d68938b9e4dd0e73ee3be1cbd8861ef533abb8c36380ee091d397071e25ee348681812fbc825d5bf5b0a5b36ee21666d7237ed10f75854aab8f82cbcb66b76d66db7195973ca473c65154105dbf12dba4c51429e770bbadbf32bdc46596c7aa6de168472903ab97ac536c7e024adfd1d406eeb43717f320fa5701bd40e284d9f60a26ab10f20c96ea4061cda1690b8b640640ae8db8a9f2bf5923ba1d74ac8a8e5d2032d0ec4302cfbde5ad3d39d99a67351a5a3863e450108d3def2b60c9b1d449afafad595d17ff56926d232dc6f715f405678cb716e82d3ecf2b10a0cd2f40620e161e871f94873842f78039ed54e3af0cfa7f4f245041e8b52f80103af7455f688885478ff179cd4d28d1fcb4bfbc55196ef99535eff260c814d85ffff0e0fe9282c56b8fad901a825497db593e2d0ba4144c7d2739c2310131580f986256767eff96e63cd9f2db4f07bf172ec26e4a5f8aa2ae1aadf5b6e1f2a1eccbe0bc3d13890f9ea47585e9c2290004482103233aa1c86b8be3f9bf44414f1cb2d79766a8765ee20ff5f8b516cae4b35ee512f37c41e7aa205546a34f2608cbf82ecb3699c445b425845d5c6024dcc83537f6e129bc65987ced8d20849632a3195b89339072a58ff3caada55f6ecc241bb7cb86b56db34db9f642061002b833a6628b043b027a9916d50be540cb116c049a1786d4d068d5c54198890dcef61cda41bf84ac47cb5b3ab2c87aa532ccd11b7ea26d7ab1d14ac29c79967b9259c7537e6949aa2ffd75fbb7475ef92775a2f9cc5a5f29f5756ff1e3aa348f02c36ad33038612dea3998fdada0263042cdcc8ee0bd9c2f91ec5abcb156aecbe7166464fa14818f461b603cec0ee78cf8e1fa6b6d59274a5cb2bc35a09717680041611fe0b02efb23469ec0f19091b4046136179f245ce651081d9fd2e424228686a6f9b84affb8af44c36fd5671137dc5d81b291404dab8a21da178ef0f07a72de2c9d06b83e1afe178f3c5661841566c6546a707f2282e44e6946dc0d659ee8a86ea877341cd500e4355a3daa5b0fef54a1d66adaabf9ab637255ce881ff7b6511755f7709bbf879273ac7365edbe20c8048f1a3f3bb338c8e06c2d60adebe4ff9220336a3431e77329403322d987a6020c465c5b8e361be78eaee1ee8e2d48f6d644975b964c0dc425219ea9c5e4e1b91d0d5c8320723d1e66695c97870986532cd48bcdcbdca6506fd9e7517f7dc88d1fea9bb8527c7e0df14c9dedb200753787e4d766687bd3dfd7ba16c0f8155d994cc8c907a9741b7c1e7d005acf2b39dff6ad337c61ebe5dbcdc0b79004a9e147e0a431e6bc82064dc26cc10c5b4b93684650f87256fc587568264fed8c1d3344a7e03b15aa0ede42c2aa2d1304917d8e07ecacd5ebfbbbad60b205a6ccf31309d4df6ede526433e74f3c491bfc31a7060e45a4e7f93d6ca7050ce73ca9158a33b86e2834205250f0a26a7cebb7a945c670e104809078f25db58d13bac105c4a0d560e27364e045f80fcc9747876e58c1b09a2e39db68056976189daa4074d6b6dcf7cdc4e370d91a5ef8e55e65a99bc3cce6849332b2ba2d971446bdc0fbda8d0f649000041a4e301715beb4c564a94a5f9de2f37c92394c377d392f8d9bbb127da8f65e9436c2e128d67dd24c36407cf432c8b8261d7ffc55002fc3ad802dab6080878a95e08a37509993cf4d3452058e7eead788efd808486e3532f7e5dad700427c8d86f52f77510843ef750509fa16b4b743870a0cc2c2aa981936238b26f9e861e4bb89bc675a00019c8b40ac81eb3b57316ff76269bc64f1cfebf17c3c96ffa2ec6cda92a4ec2419d25ea71c44924a2d59dda6297f0219c1093a272bdbf5fd25c437afaa75c1d67b8467763669a66029eec0fe0ea18aada14c133d09d75079a78410e96360b2415d1d38563539e04b20af67820c8cd7693b58333ee95a9274ecda5eda0fa39d3c092db14368d8846aea4a0892b4ace7539a8310de17c64c66212a1f58249c667a0f526511c0171f2e217137332e0b7a4c785fed6c91e3ca33d6db6b7ebc2c6dc2ad11414c1d4f223b55a7786a15fec159d72961c0c4aa09b58a88014b384b3ebda3168a7c60e09057ff3a9370f7148508d8d66fba00521a96881611e29b7a443b5b8d05731fc9ca17b22b53318b75e193a2b4925a289f9bb23b19933532eca8d0b1bb416f2d807c3aa39a6f7e5971339372304daae4566e47c3cf732eab6ecf0963536904d3765e740e62b5ff6407d1073ecda53e835f150091c6034167dc8f3f1b0ff7b3599b574554e292d9bb0d163d9be81372af0bd2d05f63f089f80d1ee62ffe4e52c0de35d61177c0e8b55ef7f2478d3b7bde388b4e08bf702ca0c4cee4999e2c8b27e1ca467dc19ed7e795ae6860856144736be6e07e14b4943d861d072d77375f17c61f680762ad2bea835fe786bdd7e78024ade403ac478e854c0fcda663a0b1822d1f824b8c50864516c2e9189719ce128351407b8d18fecec043b34b1fcfc2ff7b907e7947028e75303aadfa22dc340591088a0cfc19a7eaea23aace942649aa7bb5276c2abdde03db2f6023daae984f6eea8769fb3abfa05c44bb698f693042785aa5ae6c4c86c1446e881122222b7bc4444f33a6f58248fcb44ec6c72c994573ea88e6e047dfb63f50da6894a2753c9ec5c585cf3559c8ffafe28acf50fe195b741cbbe95d60564c4efd0c3804f867daa3cdca9c247a1008bc30c3fc840ada1c8a69bd80298e546605ac5c221215f3d27ba39e0c0f88a18958ae633c77645da04f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
