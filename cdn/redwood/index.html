<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62901b7690baa07861a7280c0ddd0605b4b2941442d576e26a18709260a27150a20694057d34b72e245720c88cf750ca44a2f45a2407fe53eaf4c3caeeacf45ad750826fe2832b67fe3aacf1f0ab498e374971cdfc6c4677a2974dd5d81a776f0a81a5f8b04ec4be26f15243170124f08d72597e5a53bf1663c492e2de8a1ae97930da059c01d759d071f39842aeda1183cabd765ef2f8c55f6ebf729f74f43c8e8ca7d1a9e864b0d037f9109af05852ba9342f7d5cfcf94413519d66f99beac4017edd64a40a0c39263aee3e3dab4d8d87fcaaa359bff968d083f26a151e8d64b331b63d8e851bbce20542f915e0900070cd28cbd895fe731605e4848c4259b781bf686eb98129723711822e872fa48910805f5580ae832fa4a21f0d5d777a45b75b2757afdb221672fc6b5ff9d64f5a033b0ee48ab802bdf7949c76f9421f168163759c3f165d388d1095acfd457ac44ebc072bf0f935efda8c56033f0d00443673a133a710eb1c340b4cf44c28e92508d6e8e59bedf431babd0b9f14bb3901747f1e43e265391b1f66528a04e1d08114ad103992e7e5f3abed9a434825d070fb411f3618c197b74920b5d8cbee3ed30b3350bfde705e39678a3fee146ec6091ed06ed0e3f98c7277d19206f3bba0cbae94b7ed84081fd6cd242d047df3814f1679f6225e8b3ddf382a4ffc22a75570cb80e6d20095891c74da0e767986691909bf85fbf75eb0fe1f5fe71b8e8fc31e2d464db65e280d6f3bb3a4f8fc2a0537f348f4a8eac7578c1e2d524134eeb6b6b05094c15acab48670993b3c4e2e38c83bb346e51a1bda9ec0a3a43b8b3eea1a88dcd203ec5953b7344c4832664ae751359b0a9e1a306037c51c6910d808bc47f6ed5903fc922d83a6ef433018104a8ca1cf5c7f9d778d59f3cbfdc615543538c04315cbe0f8e597c3a7a3d4f1af0427b2219da8e840a778fb33c8a70be6075968221e55447625e7d1a71a0f95cf67458822d914691e02116068d95e75a88d30fa994c99945c637c482b2c28818eb0059af4fc82c7d70b8014c3bda58fd23299baae9639b8fd1fde0385ab8ef22d605a1b6ea936988aa29990d7689453bc632f1ccb6cd700a8751b54167628895b3bf9f674bd8168e71645c6b1e0fa460a9a011644c5539800d11467ca5087207eac1367ba410e7bb1730295f355739f531fdffac41b8a91ce2999a3caba2ed4858585268dbf9b01f1e814ab35817bb42aab58005fa371dc95fd6d4477648b4663e7d665f1d43edf766e93e75dff48f59cef24ef8af95baa5c9c3790ce331d4fafeba251319a5f6b79ab6c906335471ffeb8e7452d1e628d6ef35f68c54075bd3898d641a8a3e5cfde9ef1128345a2abc150c2583dbc43ce0b3fe9ceb331c088cad98beb28561a5d07adb3efba09181056c463ace9837f3a42fd0a202ed75189647e280ef20296ca1d550cc955dc08d706b5ba1ba77f757876f7b18ba36290bad2cd736574ada4a5a850197a23f1beeaf3922ee0d54c5800c56761a6b90ca74ab2e2c5a61694475536d5a8ac5a0d1c0295be4606f473383ce0b65359924cfb2a3f0507d4e82495053620538634d1fbccc44dd9cd88653c9cd89d7d48dc1fa73039e23d1005fdbf51563445e24f90371d0916ab96bfc0229428f8783bdd5b3af6403f7f0c5e7eab51d0d5829955b2b9bb7927559a2bd24a9fea41644caf4470d3c4de6781dac44dcb15fd9ecf66624886b2233d794ce58de932895fb10929174bbac01c3b0f0cbb10fe662628f787825b8733601bb35add49bd237fa068d4639727d09d6d7c8c5a3b318c12851f0f77219018cfc8a563f63dec6ec0fb16abbdb836da7e7268e1fd0e1b37c1731c277103e77658af25e70cdc7651f109c2c0e173ae6f54a9d6edaf263991ad580aa3b7e823edc81ccb592afbe4e783ac73d87d32960a4e833a8b63a9f04e17953ba432f15cad2c3cb8efbc218d9b7f81e847f72a73f606734c0f9d252dc1704137484131ab60d554b1669147ceab2e4a31c43fc1d49286daf80804d315b8718f51342309e08403af9700ec845f4cd583e50d607ff6a259e9e2a99e3f4b6dd550a8ce9602eb17fc5d53bdcd6633437bb1537cc41662b3c20665121f73a6ec70c5cb016e6182f5a51cd4a11d6ecbe94e819e2db4fc0249c0489c714e5208f793c0adc72085a2a89c094cf9c3cc3d4a0471c04c3368ff262f17d5e05f8f8ecf8514315dde4fbfcbb07f6bd9312da04183d35095ebc2bd9c4413e03304b6f88021b68bdde371be142cfe4fe68b2aa52a202504c894c68ed97ee77d4cee3dad589c1d9b4459a40bb43cb8ece4c85fb136ae68500593d3191af4535b1b49a40820955bfea90f86c33e1b0d7d5f72e7abec785bd688013a64c34f4b6ddb571fbf2da41e21fd3407e3c09d9b2e8d10766eda758a93972ffe0b41bce34329bf53e7ead569d502cfc6451968c2a24e040bf6601ff88d9f3b7728a57db4cf072e93a84b8caa62663e4bf127895801501fc2c651a7208dfda8ff861c608774ab3194feab009181d33512985f287e7097dec833b6661459a8c4f557afa0e0f5dd05586cb53041a7540be3765268c688ee7100cf2d2bfbb6b0a02f577a886f49e141ec59445db030ea769f43f0c5f9efac051e6fb8320badff3abe28d56341843d3141c2b584f2b2e710d21632e449d6e5306974f72347c4bd7852e2eeac5b80862802b6e86ec8075d3281ff13ce475b3f98905639a5423392ff7161ed8ac16e53186736b9b60aa0be340ff2f87f6f35f78948632703025a80cc040a5c3726235659f1ee55f71d91d73402969eeab8888572c1eb3e2a2642365976e16e03c95d7603174ddb270d50cf26978b86d0172286059233722cf056730aa0c3020c0f2135122888ffcb67cd371deafcbab6eab47285af8a70a2d31f94974be27d9c891c3fc2a79b7501d178b07a6821f2648d126049915218ca3d79483b4b1251ea60e1ab9c30f4ee30d562e5469313c117086184166657beca11fd6b249effc3f79bcf6e32c5ac6966d33876005cd088aece1c214c7177a3b1897924c1220d6ad1efb18ab96aae4a53a7d99f2b39120f669da6896c566839eb40a2bac8c8cebda218570c53b6b1054bb3eb4f74aaeb39e7dbbe8b570a1af4ac580745b1a443e5ac01d0d50a38395b6ae7b6c02fc47fcc07e000b4965c0b73f68b61f5e0441c82e2377c1ec40a42ea85439a14cb9d2e8a1c18c595b62ccef262aaadcb604ba8273075744aaedfb996358e9ca30010703b4d33c3f1d35012f4ed2840d0ce29e2edac46303979215623ad1bbae3d0707b7c2400ef4f26d1e93b5954075f8c7a1c29586354a5404f293fef7dc917e697d0fae2419bcc2d7761e88e569feeca7ab64f5d28d653539379e8bd0836709fd935f9d6c9e7bb7f90d8c7b837818907b3f6917b85e73743ef9716bfdde4bdb9232abdc789cc1bf5f7a9bc4768e4d6b9950b0fb7fdb59b7f3045fa8e2ba8dc3a469c386fc6f50ae79512d60fdd3f311caa4b6ad043ce0601041201663729763de1efe19f56616048cc0d58b9648da851260e0c705fe4c41fa37bdb13ecd3f17b0dd3172beace47c3c2e314b6b5ce8670fcebf2692530898dcf34435aafc6bf3d10179d529c15ae91a1a1ecffe8366ece8ca900d5fe1465aedd8e2ab333c05bf4301421bd3fd1accd1d43fa8053148651457c3bb2558766ed29e597426c65ac0bc0793fcd910ad4c625c86c509c67c340c4beefb32316d8ec2c4d0828509d8ec5672f02e38c1b6d99ad4efb9a688ac004ba0d47fda1cda81e633625a911b82546eaa2d541767aebcb7da007cfa0586dd132f632df9602fe61b7732257d0d41e6e67718a25dd574d918735abc5b4bea3bf60e2fd2e7161e4bcbc10e02350d32e66caeccb308a78a1e029833fb09ceeb1831bd1444be291b086f7f4c5cfb58932c6ffeb7edc37b580a7f4fe0d6173b6f106f645d72e274cc28d4ab6c8a5ff89061bc22f49e288a9006cb6bd8621bc9442ed5803ecb700b78f67803dc6f2562fbf00e990e27d4790c1f3b9c7b0982d19b58ad93863029932c96701b39d524367373756250b1f536f919d8bced5f1ec6a88603b4a085b92c757b122d3a55d062c623751e5841f457be086e7304c07ef44635b63f7a77625cc8263305ec0f2c1c72b832c6d1169df78ec3ac28a68f34212a3d197d61716cb94db68a0d60fe2f859dfd59360d5ba16ac6f25faf06dc973209f9cd6a4ce103defeaa58a20e96cc6ed79d70deeac4ba10ce702b9f4f4c69f3c33544cea0e71da94194b85a5f0e3a802a963d81c8847cbce1b308de77add4b9f0b0b12e7e8b419928528269cd7cfd0d961965191f18931fe4062d5611f389228c138aca7ef60f757b7bdaa1ea3b3c5bf1139b4bcc545fe6338cdf4ce390bc187486bf24ca859a97fe979049cdc90a2e79e8a319274632be0fdbea83b27becfb1d3dbb296176666d568fd177471b23988204f10ce89d13431cd54beb07dbb6e5ff1a40398c8c2ed45b1a3baa0fdb217061ff68826e2c6865a208619c39e85c03edcfbad27b7b847ff3a6ed1999d5261d0a3e07a8cb4fe4cbcdaebc702913d6234a5f63a896e8c7ee477e6deaf59be2c58fc79d2b4e5ac3b580f2139176a424dc896e060103893fdc7d7999b0033eb416b6f4c3852a6abe82348b80bbd8cf472c93ce2fffd53e6adbde4d96252d535c12a4bc7b1b61be7e9d0329a2bb30ad163a05ff5227adca44c0060547c46041a975f79a331097b3fd7fdb260d3f12a6a84780c124c2441d980872a0d71e8c665a752ffdf28d829c2706130ef83622368d3f13c6779c4fa9748d80bf9656098ef2378376fa2b88637ccf8b3b8527206784d8bb7ec4041465a1026602ddd2568dace1787c966c2c49bcb87965aaae1bac43719fc700d37a81ad205c32df2d73bdce095e4b127b873aa917a73a58acdb0f762be2c6fe240810cff47689d20ce138646308ae256d2cdfd5033181afc47b53ff406e9dc6a75c25d92916fa786a2737d3fcd31e13b1435b06cff21e4ac08eb920fbf23910d11237c0724fee8420c06fbcf903b895b28f23d601b2244c73f193a70083f13d70884e3ef33354c86ccfcf942b38cf74a6976157d5f64f84e043d1b8e029fa03531595485404535a3d8fb6fd221adfbca3d9215a880c8aa7b6ed5150f735b2de1e1cefbff5cf4e5c9faa293aae3d66dbee7961437fe098c359a7573b17585c49ba7c00278aa4cfcb82a470fd0c4060ac35c12dfc6a8e4f6e1be817da1a30edad6537b5e1084b7ca6f14e7f0138d23dce2bbcd2e9787180c193d55ab4c0637177f8fe28a08058a2eff55049a3649ef1d655d506551161114f5b1edd471b46fc66cfa0d7e13de92b7f50a57d851edbe2179b913371b860a158e840a953946a426fb934586a3778b3213bf7d5b6c6a6dfaeb6eced98ad56a27f4dbc7c0459fc5e18e0e48c0f45310a96c21b8e3a5135a98f15cfdcc1bc27bb9b1ce82b4b20dd4271f8b3085d1c38f37706a11b324ba1777a0bb2fb26ce2e59fc07af78f6bddacaf64afcf800eb56eb10f3f431e75ca40401e795b6b73a4c2ad02a857f2dc07e0d7bc32da752f73628a9b1756ab6605694d02ff1481a1b7ff08fe9252ff93599a44af6add464e184b9bbedaf4eafd8518a7f0a3099a871ad540e6e01a681d775cf16d0d553896ca286b1efed08ca06c5388a7869fcdd6842ba24bd4cd9d3d63b0d6f0803938cb72be50d0228e0bc5dc5b404c458fbe52ca6005603d97bbc8784380ddcf54e3bd96976b3f632422b6e5ca18b65694662d5853551ab48729f356ded6c55cab4feb8f20bfa160d9fc203affa3e591728f3422c3d1349cf7b86bc62bf4f10c7e05525b02ca9069e0bcdde5155959078f226cd7b70b52b56456d6f28480fdffbdcf3492e27bd2dfec5e1342950e4d200ec8f8eaef50bf8603686087a7d5cf794120f9adfdc2352a712c792a6a0e25d4d17c28b932a5f60b6c20adaa4f3f180293e4ef973850a53985f975cf069937a0adb749096368c0e2af044b1567822c56e4f03b9e1300525e786cf14f6d5e6c0369f19499e39f9131b1997d471b09fe77e98239056d3022d084755ef61ad11b9f3504bf790b239ce5d9a1721b1452cdef8e50a2e515215120373ad6319626cc30fd17a711db5658cf835c6c3fc2e4b766177d4960e1623d2e737b1e82bb8e5af6d95b53cf3f5606b49a311c778924dc9c514d4de271443e4544cd757181a2f22d8942fe66792f0d1760a65786461cc87ca57e05a500b2c7641f933e1b68b8cbab0a3c6fdaca3269a3cf1ca0d6e239aaa19c3a667a39f1f6d47ddb8ca9cda62afb51868744ca40a514cb9998d6d5af2472540005e8bce53180e7144fbe8ef1713e2092fa363b9038a74b44f010b5d1e94e2ea649e88bffbebb3fd4e03b405f08f4049bf190c96ee0dd736c37bd5349a05f9f61f987a0d9e487b21635f4ca3c6f8a05ceaa3ee0c5dcb9ed402d0dece5ce56f453277e3383acb3d880c9dcbfdca39a31514abebdc458235a705d8bb615e2648986b3b78d0b87781a2d74e80b95dc1eb096995e1525d7180cba84bdfa7e1210fa26ba36c9fb839de9736e14758e96c39c49b999d4c60d5b539c6b475a8d7a9163cd556c80735be5d57e6eba53b0d1ce11c16b7150938df8fa0cd4e41e8fb50d9366481dcb7ef7c89d6f424d379af5010cb05a5d80e49adb0e219919d3b630b4073af1db83b4b1b2f8d44a962913cfdda268d8ab1c06a5ad7c12739d1fb339566a3be5eb985307a9a2d0deb9594ab44c4931b67dc79ebbc53eeae4ac83d14835f24362d80399dd636c73c2fbdff7119a7e877ec1c364f28627a714c467d2c99b4a695ef7ddce082dbdde2fc61ca29155b6d50ca709121db98b3ce8fe96440136c0da6fb78bb16cda6d7ed64269838522f669c3021d0a0b154918f86f41d04aeb350f373e76d1b0264762aaa0f81880354c1ffdb203bcadc264f774ebe711729693380aa17e5963fdf711a666ff6669b42db56f3cf6fe00e60394b1934557e1e063f35946de8597d3f6bcafd350c81812be89dc871aa9ba80f2b1a0cc99fb0b5fbc33755e5980ebe63d0601bad54324cb81064762f81cf83f2765bc862c8a546ae82796c0b7399252b9acb6782838c09b76f5334ba2ab184171364d29a00b4913e20ee77f878c2b470a6a23d923284d0d871a405ef06db17b4074a780d4fff1bfac2bcd56ddcf320c78a08dce49ccffee6d9cb50f17d44063ded314bb56f3b340b5b5b171a837942958227a972823b194cef6eb4f10aaf44ab9cbd3d0bce3582bc502f17ba71c7a38e854c0a41731dd918cae247fa2d4263d1c82de66e61653d0dfd2dd2d0bc593c64ef55351b3cfe3f637a53c2ea672c18700c680402377c94c440fc3a830e11e3b230c1435b67615100ef5677f7a3c3a09f07dd876dd46817c009ec031669b4807684b1bdb02e11d8508339c46858694a42d6500916a5fa251634a52062ba7f56fe1c18557b270c4d66f005c074666daabc4b359ac1c412a1cd622ceabc62ce32d6a1d8b3725669013e25c549a77b33ac8f979254814034dee8b07c75950a23e43f91419db9def89a91b1fa5e27b800436c747d3b13943502f8bf176bd2358c12b104d2ed8a192ca340f5477a41bef4e60d17643696d59343c15744de7fe3bd4f49e4fd1ce305a0edea6b73ad0e222f07473895098c2758d976071e5d29584990767ce2112c73fc928d592e2b15f408faadeaa289e90ac3ac9d6a5353e637ded5db9d8b1830afa568d0a0c3bd8054cc5571abdf06daaa3d54f01cb7d220b3788958260e1ed9956070549290622af424d7e514204d9b158327b93641038588d68ad569f8cd5011631c83cdc8ec6a626fb57ad5bdf2c12fb7266c615fef242a50d00270f6ab9925cf68e0df640c3ada42b792d3d72c6c69217d6ba213f8e8470e660e0e2a67e80745f39e6750112d216f09a481eddd9795d2faae41e4ff251870af1ecf3b5f127ea88f267e915ed213f94f7c4f93eec3b6d36cb82a249baad164a6c2b75665c85a92042e52b99da5d3bab130e9ae6bf70253c573c54c76d26db97d19ee678b2b95e5cf0c0a47f1cbd8f1d9f8467629982efceff4651bffd43844782fc1dd2c15eed1ac8bf77b36ad642ba8dff2f1239710e952a96296b1051c0f63311eeb11503b73f282fa6b9fa2a19ce5276704c436f22bba7a4b3bae721ecef08ecf731692f4997f1a77c88a72f6f1ea7e95d4bed6cae29a1b8b8d4bed2e67f55f739fc6a98efaae7d2a31f598f2abfbd6196566652b40376c7c4478e88f4efeb12473877b388dac77ad44751a73a8675dc695dfa398160a5936d4717f49cf4c531e0a083699ea79586854478fc78f1df9465d6a28cb9d5c26d500d8520bc83b34537122a8a34b759d61695dab199d6fff8566a7affc1aa49995716f0be88df75cdbc4d844b46486fee054c7d20ef58604990cda3ba1532b6f782c9f332637706adaff1d905c3c2c69c5373c4bab80d339e35c8bf8dd783725cfc69e6abf889be00217a56f95aac9d712e3d5538250d701f4ff48649ababce95a16c409e74c33013efc2600d0e4a0413886564fb14f5f19319a78e0349c21684b42d82ee24f25c8e2fa7e53d38211a3545797cf6f1b621225b2cf6188b07e88e33f5750aa6c15e7563966253b6a7603d0b3aecca94e9c9e217acae8d1e04bc2e23ceacfe006a9212543a5077a14a906814e335c484ba1f28acceeada8d8d939e1ad5b13ea1311182d0fb3422f658385cd3257edf968b40937babe6762e64f8e5d1128c9c6ccfb62de59e677ffcfa3f9f66f5cb4aa26d8f4e91ce4abecff09fea8eab70f4cf0934a2b9eca1482ce36adf7c0c1b9ebfac768a75963b236736197f656d67774293dcbbda3e5f8c86036f9071c5086087093e65ba7eddd29b33bfc667b1de3559adb63d47e7dc47cbd1694fcc75b4580d292e50d081200ba51f5391e9015a380074b88ce53be8b2a0f14f08885ef4566f284c30546d9bbc9980197d070ae0738b072f5b551e7fe4758ba05d4bf750ec88b154785fd13b869cf7d643a4e28d15957803a2c2b8ad1bec43d78954b62708c61ab8b5e80cadedc6318acae99930fc72b68e8e7eaa87cd3b9a8bd9b9d7927508844d967ec37c867bf562dad3dc42c53f59ca0aba0045d6f8ea505911ec784d897e8efb93be77fd7c54f374599abbf5c16c07631b9684871d1127490cdc8eab92b29516c6ec4fb4cb4f57434ca5f37b7fa61c557edea1f09d8be6dd75c6ba8c7e9ad37e1ec933b7c0ffcd9ece1c72a71a9f5d48637e920c7d4496cbd89e918fdf83cc21a16058757533647e403a267f5fba63be618820cf74a2376a1b5ad7695d43dd386b68e0375480cc28f7d68da5aab6d6fba5527cb9c97072de1f9e04f5f6ccad238296c52c786dc02cba917a8de2ad22faf8e32d4efa06423e126ba7cae2d2210acae0787479fc43d5e6b23b812d6ef7d4bb85caa1e50a8e6676f3fbba7f609a45daf14ffe3534e2822a3ff134ae8f6954deb15376b5f9d27bed4ba190347fd18f1c2bb33b9a160e20653c15cf8e8a80a7937b53fc87054c5b6494d89d1d5a8fd0c58bb0ea4a06da760dfc2997ec51d4075ea2254096c40a8d72a040cbf7fbdbd1a3d7993073e23e0a4fc70a088732ec354f9d8375f0064df4bf87a3357bcbb5e10c9dd7467153445c2738b90633a188456eacc52437a913ab66072c733212f9f4cf1482b515708ec17696cfc1db5b91114bbad2f0bbe91e0f50787d8a19c398817c1ed372e0508050b963157e85b9504cec78e960f3f2f188baed6c6bb3041ee14420c67b957682fd3b65a377e32309f58d9cc01ce3964e210232cc24b148fa96a4f51751e086b7244719df7040e565ed7306dd638f586f55aac8e9943e594afb5c24e75158b9df11cc35ae7d81e266f1408f714d6f1f7292754e06c53748b2508e8ce46db574758572d72861a629cfc50ae3a5f1cd39a831dfec69c90eae05e284d61cd0c2e1c4d4314bc9fc5645b10a766873127083230cbd69f5b8765cda05ffbaa8b7551ab76fe129ccb8dc0d1cd3c430fdc4f530c22a0e7ef86446739af284e95e9dfa14b448f8b74bdc30f385aba49680e005544c96f20e01d77f2126a3cde50c44dc442f9beab4196abb00a39cd91f58421d5f3aaf300532b51b0d33235a54b6eaee845294fb978518ead8130d850ebe73b187b4c5d4f908deb614f350661106e985ebb1c2defae933743bc43c6e130d0350a6234d038bb3510460d86867cb41fa25dd8417b2347e8f909d9330898a11241c671e95a0dc066ce951e5b28a1c435001b7ac884ebc6b3d1525773bb9e4ac7c38f08aaa5064b10771e274b961add0ca7c52534b8f91747a2ef55e35f71f17872797338c47728806f8e3adf6469de7b4e3a5c7a8e3b461e0988a5f40ff3ee4c73e73a80af256aebd1567cd65790e7f0dc3f1f7f33bddd848d5f0d46edd40964a3e8e44b31be4cc42ca79f860c53290c0f8bc08a73965e29fe948f4a300cec193b7823887b9dd14891058a34aaaec9ce56fade6bceeec26715f80f74baee995a6f78810c8124a14a8c7f0a161761fa67f96fd6f70c361c2daac85028ed867f76865af5d9647fa0c037965e11288108eccd47d62b1c7ac586c58f62d3cfac93d74fb14f5fa0b37f8f2897bc28ebeed0a1761e1510e76bec77dfb441433313c52103665e48101b58f45b989873ec4c25a79e5ba66f09c55e7e9abf583e7fa8a94f518ec817cd8a8039c752fdef3b47cf768dfd6fcbf4eec94681507cf35c7484913357676026c137fcfdd446eea7bd532691c1bf977663a426b5b61a115095189450fde772e91f70b4350a2c81b90a06ed9e8b10226da38ed1b4d7e9da3b2bc1733dfe26f4c1cb0b05e311be9b01d6e1a854d073b62bc5bdcc80de2f40c5727123e1b9221e7f37047b42e1ba6c0f5657bdec9c5c34c24d449ed9d34bc788a283f896c28dbca2ea7156cf889c5b61d4072158d3a02e53fb69a8d38873e1385f7dddb7ec0b908359ed67fa76eca8e55577e91478ba57e56a874a2b3b9850731b7b617ecb3753f64b097a190e783a0930fbead411004f0ff7ecdb7a0e6bed4eb1b9bba58033e03a114656957aad75f4bf902bb4c12d0a1111a9070437f3218810eb97e8eedfb872002686f54991e07f2faa6962a0808d22a897b61de75d969ad67078859a7c4801fa39c90a29567a6fdb65b8a55a62bc359f23664372b1d0d2b05f1f03023d9ce36928d7d5fd0cf4e67cac73ab9646d42a42259d323805b9c666f6eab3fae9a90be266cb89dafb5522a83f99414eb5e6278249ce9ab6f31a2e28965ccc4572a73720fd58a190610fd1d023f66862f0b0ad6ff62db698f71ecb7a915c92e5d6ef54d31dbf8da54de3e73862d08587a7eea9b54f4dc42cc86823dff6d77e72f3ff787ecaecfceb3ded24e6ba80f6c79df049402686a0787a3bb04d410f1ff7712cdb227dfa4d6354b12a770ad0a327dd14f235abec3a13dda2a9c3c7b368c675889bb3914a3cffdf8b2792a45793e11d42b1c441b389833a9e88567c633af4ec1df4abfaec78345bca82f6a241c1e15fca9566fbebd4a46cc586d5f7898aa4cb5720fe79c631f69bb138c2c2dfe611315a1fc0c9f60c4ee30fec8e2cffc42cec95be727e26e6387d4fa48e5e4398f5ade53417c5848db1a3419ac5dea1f9976873da65841877d54427b21fa33a4effcaf00d116a86d905edcea488de01ab76398cf4dead91fb5f5ebfe9f7f6f44c6dafb05842f802c2ba151c38d2fded7a75e0f806270bbea2a3014f1765f250907f28d357c7a43ca185109a26c9230cdc6aee5a23c1df9305a3c37eed8f74249ea61fa38b6fb0affa7049a5e2bef3abf7fd4dd0b0d3bba6e268f16baf59cd3ce92a56096dc819c5c7f67e65c454cf0329f834c570e631a27c953835c2dfbffb739687903a8241203777be76278e6e9274e8b22fca5cd2695293a2c74d92f24664f7b65b2a9bc04133c73904ccf90cb584233d0870da6c9f1ba731a6cd3062482c76d041e18a7e9b946520d07cf78decd1b1c87cd12e735d859d24a62424950ac839f8affb9d05c181771ad7547581ae9543f6d73bebce841c04d0982b6394c3336157d9a4a54d3aed2182a84fc7b4719538a4ad09ebceb4cf06be007ea9e5c42c7916599e4f99fce83c42b3af437c70497c6adf8d9a69519566e47e80922e476abf0b01e2287e96caa1ec2cc25e3c532a495d5bfba89a22d28e74300a4a22bc13be49f6c02572a4337723488b372d9e8d36333527589d0b2314f0df42a4998e32edc36da7f7bd7a23a0f94dea1664a2727b3763375bea004ca562535c53f9469b32d723189d24a1407c9c0c9929e1610ffd1f3b3850c9a980a46e33729d8517b5b8f78ca19a20db7a5d00c389bfc1ea0ee2a3a8b3a6256c18a9ae601ccdd45eb1791a24efc8edba2f5e2445b013bb85c665093e8dd5cf1116fa58d150ace1447de729345a921e1de7c4891791bd899e51d43156f5c60c07b636b070de98b5062f0037988582c899e60afd527086277c348ee5d222bd2cdb3a43ecfa800f7b01f2c78b82d4448a3295bc6a6961b0faa96e089710a3521ec21cf038a7e4f2697355ba1dbbf47e5d2c51e9920ae7db2ce39e7cd5b4d513866e38ffb68b59dd8377686114cf68af0510b3804be1e36e3f2c19969d5045852a6e3337984a33d6a87e60046634abb3a438d1d1a697426655b45c1d0f874bcf9c1133af2727261dd5b59902fc8aaa91cba3653f020c4815d8308d0394422cd5d08bfc36d32aa134ea99e5b0a517f5258bd021bcaaadac11c73780754dc007dd4da1e706992c331b9ae7c9f47228ae69fefbdbe2ab6ba955826a57e0b28e65a5f0b2d202b094f6beb93a5bcf54b70fa6e19a9de545cedb6cdcd9ede0a28cf971b49665d76ca76d2dd987592f928675f8206770f6688b8bfe493f555477570201705b7d44e5adefce199c66894ed0bef809d11d4c013c327bb4a9066b5acd8ce6dc423ec070713c520d67c62a972755989e7c2c7bad328a4562e14222585f459d5e14df1aef420a1e756d5a944c2026cde0632213597af4b3f654492bd36fec0d38ff1f3f604b44be45276ddabb83c8b58c05bef20daa7cb0e0e848d9eaf98c892623900533cf9ac27148ebb3837502201528e99e61ca0878901de9bee6a623c50080ef91f26bd6752100a8e03d85393e51869f7d4bc25440cfa5aecf028ec3c857c45b22472ed92f9abf3588690a232019508993751638fe09e37302ce5667f9042665cb73b66f752a2463621880a22e1c4dd08653bbd79bca3e9e20dc482bc9ce74d7200bf5228a6240eaef50bf48cb09fbb6c3c097b249d8b75ff5332ab860f9a05019079bb780c5bf9efa49d7817bf742cc877d6099a693a9c64c8b4490aa5fe514894998e664053c5054fa148d62b4fc52c6831f91f35176e4ac38c08c116e601231b4612bb661389c2cec2e67dea12664a79ca48a227d2543f47054cf28ef0ff16bf90f7d070bc1e3633c4fa0713042793c0557b88463c49819f3a333a5fcce5672fe3488305ecf138c85f1f815bd1ff598a09439804c6b1272de951a7c0544667b108cd9cc1ca6d96c83e4751923a71107cd915cdebf45564eb7fd3eeb89d6343e4949bd3e0d3e404d7ed8fd825a13f3050c4c72b7a69f561d744555f59392ca3d35dc95391f38aa01eed2ca584e8fa6805b6ebff5b5ca6b3bf06f2d3cd76f4d3bae98d0c4c6dcafcce5e356743ba12764f03f27247de3ecfd6981f8e3e090edd25344d063720f5f93d94b5bcba87bf27dbc2f75880bdd57a58f7f4ce8639f9ea75b699900a4cea85fbd625dd6cc699ba76a46b0ce1ef2dcc01b7255fe906620cbfbfa79f227ed4a89f5b449e0df165bbef3ad6c41d53b5d7baa98d6dbb692fba7b2147e849b43dd624af3663cff1b2729db97e0fdf5b0cec500299d49547aa371bd18a3fd31023a2bdb1b8d77c4afd582042f8076c0ce9508a7270c9e4e3d1f37fb46eb4ceec8b4af86fa4c554166d36b4d220131b020e87a926851f0c94301ec26a8af0946495f592e006ecc266f43b4ab13ce2ba52b44a8deb239d312606c7f746d63c3554c9b7005839c9f21fd3694b48bf16bdccbaa45bfe8f39ec10e9c995dfbf42d5aa164a7516b5915a9bf3f5700930f633b8f95361c18086d264afe10dd70ef8978990cd4de70c9352faf3533ffa193fdbfacf328b246bc1f8ea3d9c22f3186e7b340f537528e126bcf8e7a37ae03f7410976b36f476c860ae9b1e89b62b2816f60ed61353b6413f8c05f50501f3bac6b6621290ff4554cb868e74dbb9301b2e1ac6ea522a7d62303e7294499a8d57a8b1c6969e75a39fb86ac56d3c0dac9faac923f7421a437af4342c9623741c3c75d1824e34115ebfdcc85a7911af8f57da103a9d7ffd6312508b393713843f9de1a51b397f9f05b070843c1f3d1aaa9fb735040a1a804834f593a194e2c233891b6e448e67cafab2a286ea3daecaed07818c8d9e45bf9c8c4bc49a55761ced8f614b462cb376a948ba07f5180a019eb64ca9b792d215e47bed9e66a095a998b843c418acf6d1c514b57cf8fb7e712b8b16513329798ba51737efba2655321866ac998e9c4bb631f9fbe7d0ff3c1ed354b32dd020f248ada9f160543929365ae152455d52ff46e4da234a706fb9ef72548976befb6da5b636283b32cd3f505040cb5cbdfa6c3d1de4f7e3df3354d86bad8ba2baf07f9f1f101ab6a6652054600b5ae5e0ba929a019c18a17ffd694786f52975a06ab006f5672942df7f8b74b05e6475f82ee7fa65f11be4948871a060cea2e338452bf3960a97b21e70b2517d256b636713b1287bd87263a7734380d7a158c1008fa2372aed6df03fb4a2a326cc42c1e13be2d9edafbaf4a22922abe7f158257c8bb0fa95b1235d812473dd81b250ae31aa57263ad2881d36707b1f141cfbd764d52b5955ef27b3125b99af235a8378343359f168cfcf5a7b5ed20545dfe8e661d7949bee50f016826fd4d8db6adf106b78ea8ae6970be136932f22a984a1d96ff7defc814d7effba120d038623f30a9b5c54a68913f74f63cc4b733df8fce15298f83f4f911693b3902d483b554196f8816099ed96df8d0d63854801e71617300d7882743183429f9b6a0a2d742dd3a88b915e7844690109fe7aba275a0e1a42099bb83a3a2ca68606714f64b75301f3b9e222c1cca5f2e48f69e33049c06ee0c1e70c2b0e8cda1265c61814f4f3abeaf19719e20752cac2bf607818197d2e42f5cedc5cf9b1221643aff14846843c188e3f099679e6b0d6f7fa8eef837bb0645abe6f74157f3d94c0e390099bb57900114260fc8ac66ef10fa3143fb2983078c5a59faf1737de8772f809402ec4852d199cacd8e11ec6ed801c4e880b1a013cb6ab62aef8df0812728508824e9953229ee2b7ea3d2e9f7fd0fed0304b2bd09f3ed6174c5a536271c5d3ee3d8edce55af86b94eb79268a3753b04df0d458be40948053782815f1facb714d8626dd728684efabfe11f244b54fc5a6465843a0ace49ca40c7b34c54ab4c501324cadebd0b7f2d75cc78675f5135f4d2e57971448d4ead7059747a7c2082506bb6378f266e67f14cbf2d36d74660f51895548c3ebeae39a1682d439dd1c110256a7755f8fa4cdd1455db6e730e6f4b9e572ce7e46a5fa9740c0fe3aadb5af42124a678166768ef6d13a57c938c52a5c85fbcad2eecf5a996d2ead339fabc06275f2bcf7b6f605234df5eed9685fafc5f392a483d871aa47aa41382b5f46712b5532c77fcdd01693f9379928cbd544b4ac6f798016e6fdb9a17d5422266300a5d0e26271bda7ea5c2e874678521f938c15bbfb96f77d0ff5079c4fc08681c979d4767a91166948597bc4a38a5b9bf7b3164eaf733cd5cb60af9e9885c25534f294fa5aad87aad622a61682a6f17476314b86d41ca87c22d2075916f8a15d9855fa5dc643771e5e261581d67fee665e242c11ec8fa72e36180c1359794c10557359e575ddace2e151088503356e5a090c7071156727fb83f5e60450823e56861bd2d2577930310c009ca7ea8bec611f786a5a40fc5f0b003d98870624dbde9b5a7967aa1cec24fc055e2ecf781a290a173ad8c51258a20dec87da8f7ea37b0d4693748b50137c6c3fb4d8c03709a42c623a5d6e732f7ee911ce9f06a31e72bf77a199a657ac1e055ac410ea4dfc0354791b1e86e3a277bbe7593ece4bc39b810fa7239916c1b48f5facb564b17f53bbc3bc1f7b500ec1df6d031602d2375f6ce91c67f25912ffdd9335c753320dc83efb17e32d2e095e18801a5e310634329b6a1ab70194e1a5ee01a737e0d434de7cc6ad77437a3e3c7b924b486213355f084408b1aa47e715134dc0cea9fc7830a88ef91d77a9231ad989e54f30eec7fe4962034a74ed221f3eb106a1984b7916e7060049e6ed9c977839c11052c313d0a6af4c6231679db0e5e7aa293cd24ed0c78ddb1ba02e138e9f2513b79cc47be3a71408b00f17f1f8776e2aa2d0631bb1c6e328fd3866955fe6651399480f8383443c96e91daeda87e1563850fcc94756fe8323fdbdb62387d72cb3d356f289594f52defce42c8b41cf051f0ed9f04652912290a622600c1c55a765cd168d3e4d2c693afa53d4ac6c4115db2493aae789b11ad86f342fcc110b4e0c8898341ab469e41a55b793dfa93f8e79d97914b88256f92430bd4f62226b8a106ef724d705c9d50d32ee4f18401ce7056975739c9773125b7f489419d871a0e5db6d213b33263977e179740f1da8225a206741e7ec01234bf8e98b6d7def69c81fb89fbb11ab69d4c7c4aa6930178b00ba5b991459912e8a2d5cdb652a4f0364e9bfc2a7cf3685639cf8cac5cc139108b3c140d8fd482b43ae14a688a5a9868b4d58300a842bcbcb0a6d505d50fe258bb20ad81c4034dc961dcf1fc79f3bb6ab08056a8eab73859d70cf86e710fbef3e78ba06063fab6b76185f897e206fbbab8b43d04db2d26df7fcdc911a552021c627e349499f3a61a8f2ad82ddb0dd7c3e6dee627a96bb0067755df3252f1dac67f4d45c97e5248ded2c574567452a2dd5137528d917dacb5d383abc3293b9b2751bf211e30d0269f674883160a5a35a4fa18911b10d2e170e1ee43ebd0e95da88ed03e7f704fd32245e7aefee84c08c65d29740d9b3e0a8f4f9dcde6b17667cf72bbb3dde0717d3cb20e98a696bb5e0d16938b06d99bb0bbf314c54ea97c4ddb2ecf7f003e7a2c33870b80a5e91980780b22e24cc1f08cf088d884b08fb44e8617bd9c3103e4d45c2443afb7b6f9783a7c294da8bc5f8f43fafa833ee2417565b985922919373a647c0cc02c42b4107a2c35cc6e19e7aeff5f8ffc08263b8f4a2719666a4378c4206d4403ab6b75920ecd52a97866e3bdc5f4cad318bbc3efa4f3c8a09c6ff0be29bf9b3dbbb1102c562669dc8a2bc3ecda8df4f6339dc9a2ba5a213b92dc91822b1175a37103a258a3fc2092d41c3c18e0ed1f54212fa0fcd40cc054804825905c6e90d3f2c093f3d7a434cddea7cb3ce5d9d5eb5b422cfd32118aa9c5189254d1c08ae376ee48f3c290d22d2299978b90be3dc287390860f8b4ae9b4f881c5881c198851aef1defdd4928965ba0301e0bb70246d0f727277a644d0a7efac20be5687ad7d013588bd135cc4ec323940b198aaec5f3adec798b8450b1a5b1cd8f115b97d248be8909c426ef3273523a60199952f5b3232065977c55370d9806b05857821e002698dd66ab81e841870fb44b6abf001d233609f186c45329a50fcdcefb7dcb8dc125456c2951701b129d3d23e3b78c03063a3be804872b24bdfe7f0db4ab64965bee12e94eef1cf27a13dce0ef9f6a72e8dde0536134a88234f088e74a3066495ffaf002327189a1efe5061b883ee78a6488e8065c3fd8b17478d0e9d8707aa2b9cdd4ad7eee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
