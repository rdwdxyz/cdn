<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"608ccd35b01220af3cb12dc56141f9a306f00e78340b6f58652ba1bd3b205cab084ab154eb0bd7b2429c8927495660b1b44ff9dc9b5d70e967c5ae8ea501da415b1360917679f1b48f00301e2dd8519cec29246e880e7c830d182ae8becc41e6dff516cde0b35c1bd236b1c4150f0499aa5273f82fcea49311e80352028f6a36ec281f2d75179843314c352aee30db2fac44f104e24d8116eceff461d42f84755a45b56c836f26bde4f96221cd102ea7d566cad35247841a8160b2c35e895b45adfaaf6f7ad75f0dd1b621cb4abc4c2adcd3cd5dd9487c267dff6f214581cc612180746df4c7ad6671f7877ef1519c397b485939347e58f5041267d3ff697190be6dcb25b35d32fefedca99fa9e4de854ac2bd4bb22d8f6d03c7d77ffa0a1f1df9a1d07c5cd5de290e8a10017f3a8607a584873eb0c8b64ad4e1daef194f1cf666f1e41627333ea558fe7de596a238b90758e0fdd03530c56bc53f8d211a8f37f4035008f9e0c738a9ffae7611cf9adba5aca2be6a144434a2ae690db03bf0e6d4ee912d0ac351a3777463a0b7041c830823a92e4721588a18f9615cb8db46d41dcee6947d2f10728d35a0db1dd004e0ccbddf4ab5845af267e751b83867f7bccaa68ac909a5688893febe6368d6ca1d5db4052cdceb83c316760093c91386403c01dd764e17fd8e3b8a4fc4bc2ab78b7f4a9e1c6fdafaa68efd53d7ab5e83802195d0cc7452cf19cf7bdfd4e980bb62d12bee316bc038290a12842523d86fa2589c0814093cc134c670bf617143e52eb5d4b9ac9d9e09e0f7ee247199975e71cacb68d881d1fd11e46fab0d73257839cc7b0810a57c7b69b3bc234aa669c9d387a75531a555a906bf42aa014f4d6f9b7c1a4ff64ccf8240ae76aebae94aa99badceba75334fc8a8e47206bf35fa73f3f8e903f0295e67e2f74a9572cdac00c3044667da5a4477c37022c631792493c193191edc6711c933233345d6a311b881efef38a00406df654b002d54f3bfc7f39d53d40b53629e504ab4ae01b75d73efe3fd0b12b81709e93882b1d2430e15fa24e9240ba6e93c8141493e748855e0e2722eb9a527f9dc3b6e22d939352995c4eb1d2bc4d18fedb894cc42ba5229751a5f9dec724f1a6d52cec597e52cec93de2a761917aca7e8168d31539c2992bebe5f97b12fa6a44b4952ec22e41131f508e62fb988413571fc5cbe96d7a09fee8faad10b52117c069a10906fa2e5bc8541c447216299c710668b46a725585bb364e2a255f9cd387f27c9cf2acdc4fbab43d339bb2f597581c461ecea9c2db487d6ee7996bb386f72604fe20da01a39d2cbd38005bc1b7798aa7365d2dde6e44aedbf80e365a001c16a93dcd185b82b898ef8de5f0daa007d9b6c4849d0e447c68e54f65d4d7c061b75e2f1d5b0d030219b7b7c3a307b2f074dfef7df3d4b788fe7dacd267a004db7ecf8cd5ac90ee3fc212a1123de224c0f82e3f283974cb8ca122ed872362d870588cc70dc82fd08c8daae2ac34ee77e0d0816b34db0be3ac6ea394777937b580ac21a525a44ac819f7add5c26bdaf81b8f85c6422da13172d0226da377712ee58fa5f1a5d9f17f1f94b8e109c81cd07785ae6c113450441ad4b382407618cc9633c11e56818af024f94b1e72dd27a917362fa0073ecaf528393d3018f61f90a18190c4127ead3e7498b4b9c4214815bb3c93f7fa863eb054883962d64cbbed8fdcf7b3b556a7f21722e41dd9ff5e340f0d120e0ef543c05719048c68e55d0d47571aac6e85672d5025f5704e566ae32e954ebec88d9806a5e3d08ba1e981d01820e42cdbb02be2af4f2ee3c433c446a3146004246cd851631f59b4fe82182fd9f43e36d527d35087428d3cccfb0aeea1944e5679ba955f5cc4581850ba9c8537c6a74043e63f4016f8172e9b691a7cc3cd1087b5d77885d02987a369805ff22044da766e8cec2366293abfce11bf3e612d0297c8617007c841ef9e85f08a4acf99c8b8cfa9aa3871aa64fd9c08ced8f605ac3868b549e38afbaac08374e5335c510b9a81e3a2c786ba95374ee697fd7a2bb727d049816a98e6b9f889a489920d418880db9b9b3cabc0192007df27d70bf955ea5c958433cd336d4f2f062cb80218443179ff3d030c0d35c7b894c012b76823fe97dbc9706b0ddc490c66910bd64e0ad11099d3dfb407c4ef80aab9aab241d71da3c34443cb5456fd25f73b6a315f85660a5adfdfdbc9aad793550845af60462305ac0da6b47e66a07f976ab222e6a9cb8f5c9935b3c2184f2ca20346eb9cf025bf87ee813d00c4afb6ccd20b550cefbb6196596a86096b0132f1c7d325a2d4bb5118177228553a27cb41fdfdb02db8404d31250c5c74ef4d827e24f9ac9aac45f564dc28bda11390bb85d0e248cbaa0b8e7b3f541b930683c72a310318624800e8a1d9a921ce1fddd0371724c305d19afc96000a4c0e95113801ff852bb04d3f3b3165c1e38b727c7d8834db3081935e9889816f8aa779ecb6ae9d95a491f503925388e917a80eb7927c44a1e758bc4c9efecb1eb0fbf1476f5386051e0a39deae3a56d8fbd1ad4d5c703f51ee16889eb4bef230fbf65084412d148291fbb0264ede3ef58da6a7e7d2b59a9a7dd98483baf20d0eb732afec0fc3c472d95d2d141ee82afbe5241d5d255634f0387b0dae5bd26d651aba1d444b5f21ec7cafc837f66fb46b9c32be267ae63ac8489bb5029dee87731e1710f89d34225bbdbdfc2c3df49908a38f714020e79b6ee1cf34ff9419836e54679755863780b272948697f8f0cf776b54175d2345645bc4984d23eca78247165f747db787eace9f5803e8c42e70155235904f89b79cfdcf865bc35cc024890a515e212c5d1a1259aa58242ded427e097ba8e408544c39b1bd6d02cb1555b22043a37dab1524a7670b3158b127adac726ab3b3ed1ac189842079ff06094ef71710791666a7cd0bfd4ed42d6bfb6da477ade56b339a1b2a1eb2b464aa9ce83f14658d95ee920a7597ddfaf81826af234a2d0b3a424a87379c8b85a941c7e64d5276b744a2ee6c74f6503c6dc75c0c16c13908659dbe553960050b108f302394d38d81f33bb1da51b21a0088e917cc19a884405dc2c30b4e48289129327a5ec0781e5c1f817b630467254fbde8ab8c7a6331d08dc9fec235a4717c4ad9f2f055006d820909a31db03999189312bf4261e036a1d55ec0f936e2c3f4e9dbd7041e79129885381a77072814bde7304f82d6f844e396ae84e983eb462453754fd92e74f3cf34d071c907db0efe680b76a9a76700fcfc1d2dd321967f2393626e6671a7dd1776c839b2d8ecb203f01a82768f8011e9f5d5b03af95da3bb9ca805ab704c57e3fc50d30fb4a5c2b0543ba98b6802a5af822e47f690175416355a9174ff332f0b76c557d2288c6ea51b64f440277ef67c23722f558ad3e442589989563afeef593312100555825f1b732c52a4a3020ba89d063df7edd485c29a212ec645f8fe39f207756c007e80fc098ba18ce0b6e01057518181436f69ea39d27fa14d736d3e91f255b710edb7cf4406af77a326a2031e18653645642e164fb47e8b6359b7d4f4c8595f676332d568fcba1304a37bccfcc869ac22d7c166023418bc24b6868145fdc5aa7c6a3ab7b759a9e7a1579128b13473ae5a17d4de0a62fcba8f62d46cdc28350e61f820899e889e9352187775d96245f5fde9b3e28aaf6dac30e6957168ff283629e57ec19d759f7ee597af3570074c0ac2ccb9b15426708f17b4b37e56e00acf8b7698c40bf583914d4b0fb1753c6e9b8227aac1dd725b0c88ded8f47605fc4b393b994b38a7bae2bb5672d3563aaca016502dfd3a583e424301d32a3754627c26ce59b55b29eb6a5ccd6e01f8b9bf64b342330aef4623a683569e23dc593e0b61ee72bdf34b6e0c615e59eec53fe4ba2655b0e3ea0a751b0cb0c4a53b1255927a0a3510a9a92ea6ea0418d8a854901bcd4cf931d229b8198afb4f5ceebc6b1c61a5cb17750fc64660c2e3a76a6f209fdcedb74f6a8c684bae082edd24400d3dfbf2e492af8bacb33dd34f8fc3695799e45d2d27d304d4bb64815f70e92b95bf67a73dd3b14af05fb71aa6facf2197cd78d54791cd639bf6c018f6f307258cc918802515e96360fcefef1590b2dc5ea73454e7af036dca835c8f2ae4ec4554e30d0821d5f1ef173b5a2b3845636a06387dde9bee598970440b44a0ef25d94742195974622d6d7ee373aa4057d8e1d78f6a238874a512b74266605daf7c2449ebc7f2b08cbd415172336f53f98a82cfb54f360a61fd37ecfd2d7cec80d3ec5e437fc92541b66efca8e988ad5cba73e5d8bcea68063c632dd9727f8ee7c4d6fc9d1c6b779b86a6e88573a99e19d284f5ed477e0a6bb4bf45aa173b8fc33b11ed7058029e8d5a820bb3ff1e488210d25c3a265dd520164d0a7420c5cb305cf85ade16575b26ce5eefd9026c7fe9e0876d45c5567383dd38aa8d488b0934ef4eb67d8c74dcce30877cf291f61d773d23da8822c435752e4b59e2526a29b85bb9c2a784feb37b02f59d54c75ec31fa8525e7b71319694a85bd24b498aa6ce3eca194677ce550c77b1a4df037f3b71027dc5c683063e90d82ba11921c5f3828db14c8a8dcc99c6908469379398205c8bcd1c397a429009182e5aeb24e55acb1f28e5d377a67cff1edceb2c40d3df6c7718c31e6ea52e2539e3f6e46d92d43b3771fab38ba625f74d73377671ce5e2657418dcd8187fe3ca2a4c897a74fe26a02db558e0c4229c56bf66c8b8aef602205b0388d4faf1d94a23c6c88bbcd90e8b426314f7dc1e7ccda96cfa8663be33cc6207f2b8c905c4b992d524f84fa8dcb65f3d952bbd09ea08bcfa15dbdcd587c1f191da792e573a6273002fc72ef6cd59478d75e1e7f238aaa8ef569e0a6348af1266741385f3d71bca6703fe3a694303edd64d00f047301b698c1706bbbfae07f1e24f170f27f9d7c2a195311fa5f80f3a46f94d1b9615624dd1a0c5fb128aa8ddeb0e912a70ba51ad6c7d992077642ede3817036ebc575fd11da4fb5976fc14f982e1d35e9a1c5f22d7cd4f302605187b0a4f62587b8567d1d74a7f9a0a514cddc7a95c540c8aac3d8f64266353c88acf6ecf660bfb4c974b0edfc5580888a0983ef309f9126659d5001748aad2639a8abc10b0abe03bbab01f39f73dd0c04843a45978c497ffdac594272f087e8f6fd4ed5816cb3f56dd1795ec46045d233cb6a846bd8e281edf8ee4927fcb42fb92136c35481d7e087629e5813d46e49657dd9e7404d22f4549c5dfcf0b56a1d236adcbf511dfa81093257b9def5d460a6d87ee59eab53db9ec64409a40e533eb679465754fd3ec80a1551f0964ea4a1b1a4c0cdbf99f35606dfb1d50685c37bba721f1b301a61e65dc0eaba5cc9585f2e459b3a61961e7daa82feea8296082862caae80f9c6176909b8d9777ac20a6f1e7296eefa6b3d713c5f933a47cee3015f55829c50df03ae53d3846f7538bd500db2f07574cc72e16f4c727b7af026fb13514443f025df1a6de460230b025781e9ac69c2d5f10876fab3a47f7aa9a5d2753342eea64c5c9a045192f8dfc7a91ec57b9fab7a6b628ba84dcbd0658792c82c886c55b41b0b463e1fa2700c3e2b93cd66e380be2a02ac951712139792e96c18929fe1725af020eb923f880b768d4301d5c5bbcecbfe58bd5822fa1acaef87f6f671de2f3d24fd915aa5bc2192a4edec7bf6829d62ffdf007e813e9a3429ade9dbb2e37615e20e96eeb5b01391777b5705e498dba7e6454ea0264d88af6baec4bef8eed85c66e3c886ac989ff165798dbf3322bea249d4bb2eabd39eb98623bed9a16d1a9db2a45de3fa2c2f2f4c57d74cb285dfee3dd2613bcb2ed2cc8cba6c5efed75d8fda83e416806789aafe696dac0620a4b33769e80d36f7aef305fc73925eb63de3b771b3ad98fc30ec8eb8e1850d819a834b6f26b72d7225d7366877964e17775d1de9e56b89cc4b4fe1d0b5d42af5688aeb1c2192a693d0adb8e5638f50aa98c7d9d51354348e701ec5c0e442107315bad2123c98eff7aa0d9dfbfbfda212fae24622874ff1329430b8534dc10025ffaf5c78c41c1dc91f1981527f178aa9372337c781319fe8e338e078ef57b35f9c886160655dfed2c97615e77b122475e61b1dd99e959f18913cb40deaa1cdc0b8c9745157cc34eac4d6e4f2726ed170033eb9bdfc3b8e72a860c98c0d2579e828184a871e3715269e568942d967ec00cb3f4403f130288ec5448cd1d5adfd580010519972a52ccb3d2d838c2da1f828ed658019d0e455e423e2c88cf613ce9bd1d04f1763c236514ee08c5848fadc20f7db00e3bee1ad7a23fe7c64881d58ac2b0573a03378fe0e8771a9fa70cb78f86707bc02e5a230d89f80c1630d9ce335355be61b71d61833bfb24b0440153ddc4ab7c2475862ee9f015e4aeff0a8e6a4b297611672bc67db646e98297d5e53572363286cb7dce565447a88174826eecc26a608c5291b182b0e645a2027d972c97cf63cbe6635bac5655bff77f63f83fee817e2ece9e5c1cba509653656b670f4a373dcd73be7c732652a8037c62a65ec81a03af0d231a39d08c2e1168acafabc50e8b11f0ea0d4ae8720ad9a7320f7fa584c9e79f9612899f4df5a67a0d4633f84e02f9e2d3e541a51d65f05ab7a4ea0dbeddd7ecda114547ee01eba802bae4a0ad77bdee2a33405d6ac2d85ef048a3a9bc777198c3f6af889d8ea872bb18bdb703e2246f035e61003f00174c53067b38dd293ab95952a63bda60bc8124cca8837aba1aea15f40bb86fb359990932f97ff7d96720658b69112cd46618967d25c5951a43dee6b512c406148df25c92513eb9f9c10f2983578284b57202c4cdd8449fb8d29c7cfe8e8e5f42cc5fe5c79653741e402f5e980191546248265b6bc208e2dc72498ee210ef00a3469c5b3157c69fbb36a02b555520ae0d57cfc683493970c3249724b6a469e0cfcb0879faaa4c64828fdf9964a5cd4763c397cf432814c9fa688b746307fce66ebb02b58a659e25657fbb52115d26d9b1e28421751810655c14ca4454ae366967edca4c553841b9b6be79bcdf8173d2b3b7c8efc88144c70ab804398d61b5f41bbbe2e9e53a5d740ecfea2a014d47861071a0bf56f737582b01880cd9fa0105bb543e3ed2eea0e1292fce8e1bff927908e5d0a6f5cf88a13ef84722b0ca661c895b1f0effaf1e96bb794aa9047f0f2b3893382e702c5fc6825e8826541f2810b18da853d2158f68ea6fb21e0188862cde3f2fd168c7ff22535a0c7a7aa3658942b895b2749ee8669e7aed50054cbd53c13c1221c9314b99393b7897f2866cd04f800247ab4098f4dfb6bea5f355b39f881fe9b66d8fe2f766c3beb1ea8e458172b430518f0787231a3db740d26ad631532321af9ca1dcf65aeb0cd26f37be73fa1912173e12b91db562f2aa09268677303d055eeefc85dbc61a9622fca07d2b808e2956f8cf5d050104a2e3ca3a13422c12f3816b52fa194cd2f8724bf6a06377d7566bbe9166b4ee9ad20db1d071cc17396233ddf22e236bfb62ff4a55ca86d2f41e252306a1f14f717c93c6673789c4a1b19869a83480d6a3af2bbd094ec155ae8d8250567d6d060a7c649269ea7427a961968934f2306e988f8ae87b8aea43b2fe057645a536496978cc3f8a29087d463b5b398a8d3528c25046bbf851d1c6b4b071ce1701ed3d461f30da56814d1b3b377699e52f63462d0e1ffe39cc3e3cd748dcbf7f8b30584e256bc7313d00c8ef37e177429d158f8b1809887a8b1d79f979cdf2b406e6331a033e0f5bd5c267e3d4f2e48df678968c48726b0e7d7c55e12c5c0c5a9e8c5dad0c09a24a2b08bed9bbeff3e255321893e9dca01a3bdbe5bd78f5d24a2a338632ec6531d596ca12bddc2fb0e28ae4e36e44836a3255f70cda3cd5bade80bf342fc2882bf99e21f8b7bc925bcd8fc98eb81892d643c94f9a8fc23bdec8ec5ccd3573d767b13ebf82f39e1c1074e433594e15e75948010e41931eab9db4a61c0c1df6c9faca72458e803e10f12826a229de596d48c29586e975baef144e247d55832c1d822dbdf32b4466634758f7d2180cea8854cde98e1523bc849e5bced2366d0c153eb2df2c47c0c90686be52350162de89c57274e4797e2be2db1065cf1c058fcd33504f820c292e3ff93dcd09db3d0af0063cc90cfb3a97574e6cb337a72d9b2222a9dcf9e40754c223e79cfda55d46b39b8b00eaa8c7c32679d8e266aeea14c5f838f4c05b332ca2a54250f33a5e5bedcc754f79f1652be90ec0326bef4bd5e215f4ab8dde8cd5d301d293d154bb1ea74d1d1113d17730f43137f333753cc50919397d6cebe643a6ad45cb370f174ee6caf9f41c158cdd4ee5b88666a59e0240b9574a0b970c47a0e2319ed8a333b59dda5f7abc620ccac7e534505039e005e4aa93955c1e2d9a3c1e349117f7be07be46abeb1c257eba59bb94006ec7d64a1d588dfcb3218a0467cd3a9393166010b22b1115c403fab6ce21beb5ecb37b2fbea9e66d5c7eb10bf2d481f20a41836a155c5941e9d225028aefdb97980d5177ac6564e93c3d7d13729e6fb1a29935f603ac4b886259e00109ffa60e2e3247c363b27633db0124829c6797c2af257c32304bbe9379384a8aac81b9c38feb40b30146f386e6195d55dc36cc65777cba24a718475b07210387c1fb4351f411d50dc96f968978cea8611f8175201897235eeccacda8c97a7f09c1266f2c6708dfc125c957185d6c87130e3fb4a6e0fbf0e4e88ba48c19bc46edcbaba6cd26c2a9f747fae6c0b9ad62dbac10e1144b5214df05f3d90b9a40c4cea4b05183be943709b54c0b17b28542025e74c20c4955fe520a20599618108bf21841797bdaa375fac344b6c9149ec4c1f52a16584fae72f65adfe5d2a2fdfe557ffc631ad12ed8dffc4733eda0270b9751bc85adaa8e6e47a0e87be524858880fb87ec1d1d5287134d47dd71c0fc42b19e3d70ce11e690e44c218cf7e6cd67e1c30d710214aa9dd862971f85f31b6c82225b0ca6af92aebbe9fa9508e8a1de0d93cdc1d5f3f5dd5bb99422d5667a4c2cce78da0f8fb9b2bcf27623d24f6f6ef832c70a5cb044dfb1f85ab53fffde78d2d8f70152d08125cb0d18c5170d1f9bbde3ea33ee327c5afbcc78af45cb4f199a136d712583f75f14ac46a87daf86e47e88638cc2f63cc248d50d0462066d0caedaee0cb31d6053817e3cc8cb7d85d6301db67063b84056285ccf935e01a2c9e10dfcd22f1099212db42a4b2b76a51c299e0a548722992497b37031a4e0cd805578a5ad1465bc2708cf44df8d4f98586918330bf47b21a6611ed5ba54b471be85f9265f6d879a9fe74e76be9866af0e38f48f2857bfd77ab26d697506e27ddb392b15c6e690ebaec0a7a7b8eb69d241be82ab402d710c11d048ebdb2a7da08f303a4fd858d598703c109fd6b84e9d2d8c0501336f0e0a518e685385a8bbd9152e62539361ea0d4624ed3f21bf9194111a64c1985a426fb9be6e8114727cdfd6aec5c951acac766212f70eca316bec478503095e0256fa0057c0f4b810afd7b3e820a734f8573cbf9e0d0698395d7adc986b2eb24a2253cc421a860470592f9ffb74d2db19e8755b2fd5efb69a1a4281109f5eb87a7348ce1794d85386a9abcccfffa60aa6600d9ec8e8d2a57f5844cc205c47ff8ed6518a250a0b2b1639672ac6e6c606ab9ed23782213a81910bb5176410e8c47641e4016f3abaee008ddf4464c1302095d2b7f8df5eb0c10760a46fac7197773450b63fa016edb2c1b40e73edb3f0cf8bc14dc58211027789f119629bfaf4b56f767c3ad350fc98bd0022ccc657bc8f3ae206dc1075840e58a49b3e779adfef9571aa7e64e6863f0787e83e1d3d45155e6e92f465c5b5ee0d7904623253e9dc799db11ae6bdda0f496de6260eb5d6fbd66b11c8fcd09d1a5c4dfbce9606d94d8322554f5c7d7ce5b25ae1a1add3b29ea22893da48e2147b73a648d0a92a43b6ba0326603c7cac2d8c9779dbd16da0f0603d67c8ad4d6e598518768ba35c8839e24b2366c53fe45cd6fb3fb614e1e2b6dba3c52c18c3e5abcd6b896875c5fe5abe54ae4e2244ae31100287f6731f9eba478d34ac81393dd90568f2c1a6e7f63c4f5134c358eaf5f572fc6e8c59f3786abd7094b965c8f514e3db943c0867e5ca608f76c7026a70ffab2c9bf85a14540dd7887fd0b8e9a9f0326437c469bda1902b5388667c519b9ac4398d7e9e9dbbcad5335f884795ea35893dddd817dc56407989f84e7b702a0f5c9463188f3f9be35c8b0d60a088fe34e1aa6d222f0f0e1720d540b9315c2932a49d16cba8a740a0d0deed03192aa015e4edc6a1fe548cf23fa24de83f12c15a0397079265462792602922b340763bdc25c75ea4c8e2022bb0c5f6e7f2519f61a6ce576a6134e690467f58cd9174663c5607c118dc703d2c13d1be58295ea419e6edf22ac93875416769f638771c2d0939f0e9ee2c9c921529b077d644005588d3c3552b249f5f7b19e1855bc251e8862a2892099d189a921f464b045ef8bebcaaac344e60b82522d5879c644c4a7de12f831b1608731406bb95f5acc76868961b927e4e6ecac970a4daa333ac79c503d4acf918c9ea0ff23b37eece3bee9b8e0157c8ad2aa0698f396874734eb2b22f4587d9faffaf56416cf16142815a44ca14fe790483eb39daa00f4bef1e24956a6b3ddf3e82d8b439306f0f516e3c2ebc40e68e971f2912382e7b7916162f9787a52b333b05182a7caed3b3a6f52c21a2ef3070b3c78bac9abe9d9040f0700ee2e9e60228cd55717b7fd42fc3376c7dc3696685d823c353fbdada8059ca05477325e887e9c1fe8b9a8d69f62d8c184048be9dd188b80e3230cacddd3c0687fe5a4cb3328b6f227a270f13df2b4829e158c92b3b2e5e6df184faee924c8116fa96b40dc1ba7f7942431496905a92826a2b72dfb3dae5cbff85bbed2fef16214d482f57633cf3addc53cc0c8330d474d45d934ac9461cc261abfb940ebeb9e283537a92dc1bfe3ecb1a427cc9d70439706e0053a8f73421cd96d165a026d97f95bf4258b67bc35811e9c50f833e8fe5314572273e3201a82025d991744f710ec24e12890d5e0318d436bdcef00f23c402cd33b3198b73fea2639888b048d16300e355ee3416b58cf58b9962cbbbb03a7435fac39b7a183e24977cf5dbd1104dc4e220fa170318954292ff3371a6778f88827a6a268beb3cf50f193afcc59ea0c69171718a048344e20190ada467d12524a3f2ada9b92f0c9c13b0c7ac4b59ef403ef3fca5eb891316089bd8362ca0d23ab3a7a83f4bb8ab571832014c29eabb0c5ce92804980454c7367866135cf88e344ff12145d9bf61f81bf7b696e33406b9c3561fdcbebd1ed424962d498a94b418a48eadc72656af47ec751a041518e64a64a20a543cde5a721b2b259bdd2fac6519f36fca5a76b61c5b18f576b62cc01fd4ed68ce0dd597a837f05c845bd27735035458f30a9586c8eb67f41a9cb9b81ba227faad8e211e360f7081be70708de324441c12571dcd619476348f97e760fa8128cb4f53ec535d9125bfcb9d27f943be4cb7f1af3818c1c7cc59bff68a6957094c574318684e8deffcc039be5bbd33b086fdeda28e3466a8a74991b214e966b523618cd11c69ba021793dd00963169a327fd4cc26c0f44aaba484e5983f1f94588447f745030da39daac2a013ad37dae0de7c9f8c8ba53d790b42f771473230f0d6e860b9b99b90801bb76a6394ca11f2935e7c73896f5824326b101a309d9bd962a020c70a973f6fadee9ea571cb6441a5bdc4b53955636d4dbe49bcd099afbe96810650cc379d11a0cbefcbb6fa4b572652b39989aa326998c67e877409729e2ab1da20ebc258b11af9b94e858e2dc1e6def4b3ecc131b07cd492646192b7748f1ffdf64c0cc9ad198119ec14880a1e11b78dc1b120294116dca7d9161a8d8231576d211ebb77e2fe1265f662b014072588efd1ccc5cf7ce82dfdd05a34b2199442bc4f3eace60a43fbdf320321ea4ede63e941dc1086334f3433b74a46c8eed33b62c586d20ba9b8e192d3f6a583a587b6770b490322b1de9456c94eb8536fce116878e37afc5edf78bc2f11ee078876c3bd1fd7a150b91f8fb08824d52149f01cf566098618b5d2a00c3b3017d7a9171607466f102620bb3a72e4cbf6f1279182ca85771f11b167a298aa960092afedf4aea650b6b13c223a93cc994e66c34012ff4216103d57646b5a6ce747870439f79afedadbdea3689cfc4c7a293de08d3160783ae714cba5022cc3160dc9f228bb867854d939a98f937090836d6bcd0381505e575c123018c5540209674ece1328e9ee4bef4baa791e28e762555ca761c76a9517598523f76a3e641f8a9d922e6c6a489c3dd5e67ebf3b8ae43fe0ca9848f9869258d403eaf34f78ef37a54db4a0da39fba0856f2fde6d040ceea16be554b431ce265e05c83998f620ee90425e7dd1ffb8dbabae75b47a174f1271105e3bae7764de84981bc9eb422a88ffd5d73556203c5ec551369a100a2c51a3a9368838df6115f1dab3b4f34148b2e78ac449030ff497548be8e6129f3f5187a1226a207ee6035759965b5e071b7d55dbd9ada0e94e6b57153aebe3b9d4ea53cc0427be6562cade34f15b8fdd747cd8ca6671f457e8b51d75cba54dd77aefc49dda45cde74356019541ec75b16031165fa918a9b9b381e12afee652482d9aac62c608332cf77721eb9bf119b99ffeba0bcfff87684630d00c5d4eb020a4d2603b5056c277e2db5aec87062e5828b14ba39e803e8780541fddc5cd798e4ec3bc3bd3c5d5c9b91d9841d225f1f7269404d68bbb976e7083878b98836a6500daeb76be3d13b76ef64183b46bb67c2d09b448eae5ea2f9145078eb298ac5331a79eb91867e25a121c996f9d294c948e51a4d9d8b670fc32ff44d2c5f36ef8a615a75acbd525beb2214d54d1abb2db95bcfed19348ac0c7ab46b2ca88d604708a82ff596eca4465528485c5e8045743f1a1f2a310f0971c554e97778bb5a22df2aa673bf5e945e65acac547b9af55fe84e85f677bffc6686411b9886dfcb77448a49d4553dc90997a1b49911814719f3d1d27192131240d31d77031c9128bac5fadab7d251703e98cb39a3434dbd3a2da228dda901a43722ccc97d0fb749c62a064b07031ba92050c39074a516929212d1272a09f6c11d48febfb205acd373a43a4069792c1a38c3b7166860bda59bb4ed359a585080a07d273a5bf217bc02ebbfa6bf51de8da1ada3ad8ecde1938f4f09f1c4360bc1ab6a49d1a6b00daf95a410261b96ec3aff004023c717033086aa41c497f9809bbe6766d679429c13caa46d1ba95464e164e7600c8b2939982bbad669fd070f053eaf67cafd8345e42a8b0b47b7a9ffe20046ac4fe8462615964fb9376bc4e6897fbd7d50656f20b01c355c555e332a53d80086d0f21352aea1e53cc63f50ede1cb19d2f08fe7a458a1c4333cab8daf5f7eb200c7078144ed4376b281c55de7e5a0144d54ef35f197ac5755cb83c396742c1135b219f2bedbd13befe04360d8d74ad42c5d43fd8d6ac4248e83cd5fa9909837454a091a35243ae79113a509f08a4a2e5d453d0498a68bdfb960751e96538a09279e7f6eccea467ea2b3d096c035b861ee10ad33396d87724e2223d660345e09ecec9635d7b654c74fe7b657c181056868117fe4b2f0be0c59b2e4a4d1eb8546c6d2a3e527d3b873d1aaeb0d8f33772fc7849139d3cab30b5d2a54985a7b7c6952678e0b01594d4fea58cca32af6c6a71c9cba8184d38a61d4af638645d0a568fef2b873cf5de2f31d264e6a350484a45464260fc650ed9b470151ffc57d27ca35cc355eba47b62d41fe5011957c799fb56307a946664e207b18e912feb4b1eeb0ff9ac093d1cfcb437390314be785243202640e2145a91710effa7dea6f789d64512429e6cb4250c20f5af059a0093a86a83164f0ece181eab161ea191b2b2757571438f341469f345e0c109d7588bdd36e38f2bf4a56abf9db2ac4d3269ce04febe56fc5df62bc29925792453ce4162702b4343da942ad3929b058e5070e7f62e3bae78526ef5cfadff09d07848ab9a783fe6d8eff842af5e5540e5d2fb3c79ce84847628f3e1a39c9e82a8b549e18a3fee52a08710b4fccb221d43ee69f015fa2bf56e7387e401eb022d33f2623f5f6df2541fb39c880028d48aee074cf22074c0c02c0621a3744e7ee2c5e06ce0874fc65aa71eda60c142aecaa4dd77a37c47948aeee358e1ab74651418822896c06a6913412ce470b971bea7852fe7d7ef3bbef344e65b3b28c93600b491067ebac5768869fc57eaed51152bdfdf48bed575197f15cd10f1eae26ff5360490cdd94a6ca6ea5aee3bb7e46360ec0aa819aeb759c3f2216f355bd9b9cc2344b443ee2ba3cf84e37aae2b1994f4bcb56c7ec71b212016f01398a66f9a84826c20944b23b97b930c6701d4d2627fac55b3ea424ae576cc771b40e3c75d0cbd52804f3e135844949e98ac24c0032fe7f431a36e705601e509b57f3068b9e9225e6e0977ddafbdfa1512b6e1536d9c586b86be27a0846d8506055f89dc8204d28bd130e9f6bae87c02e2e7fb7378f43faa23a7a7f708dfa27145406d24add6f9caec12fa258d1e125537b6c73f76a85b8c6df695f86230d310b0e2475760fb917d4aaff3c935bd09a48eec63d3cc8d4283e310b7fa78f6d3ea4624b644d49eb493a7bc4dbbdf24c5f1c3580ead933de2cd5e7c816d9d83372b4a31711dab1af9b6fba03ea09ace23997f59e821e3f49efb3e167d2db7d1e633ae9f3c4906a1ec492929541c8a926db8aaa26235faa8e537d088c685a3c3adf1c6330393054824136c4937333a9f2628cee72e7b273f30fb20cd2e614bf6a0de22c77949774adabffb00ed04d4dc45e093379b51b54d0807fa1802797429867b44181cd4e1381b842d929cb85045b8b6e7aaf14f3fe41700b7a4ea3e719101e5ae5d537978da6cbac99e7df5f0e6340c5e6bf94ca68cbd94279e6a689577db3f0a2b72f4c06d05e13a5c1ffb29112199138e629b4c419e68d5941d6975b83e2b85fc4e731ccdde54a2ca1b8720446491ae4471512a299d9f663a8fa007f1358b046cc4b12852f178365210e776c90bc989d6658bee9824be56619f235b4bf379909705e991849c22e03b6c39c907063d57e4ee7a4a79497933dbb35b6f08998d5287d858e81cc4c140069a1e614bb0f46b17b59e8925096b0bbc0a69d71cdea7d3dc8e9ae362477740a0776f67671ca893cda6c306d37a05926a272ded684cf91a3d972d2a37834e514bb55184c62072e71025b4018b8f4aa0d5daff224b2f7f1f16559f9886853557489e7e4a24b714231cc978a90c686abb834dcd0ab8dc2133595bc4e5703d190e1d20580ce33497b0b1dd301db6ab3e243c4fd50f2f0d254937454965339ada6ea0be147571f6f776728abcd2878e929f76cfcecb5e96e475ab17ecfb58d8a5774643051b0b6c2373a4fc29719fa6abe73385c454027db65486d67862de900830bc84fcfa8b0ec48e2bf01f0e0db1995ae82a76d55b509825767f6a741137aa5741b264b83ddf55b7109589a2803fe9d41e6e05a19f778a1d06f0fc77e65c13765983d022e9fce059ae5d2090146eb8a812f237974b00a55df94adb51a9fd7215294eb7286af8ced4f48faa3df3b5c38c4e7333e6a98e47fbebac7db3d392e42ace6480637a2807524ea46957b9c71c9ca208581fdad4becd7a03bcfdeaf986f5aa2d391b0530b314db4ca1984969c7d9d0f2996f6f5166495fa1eb15affa4e04d503b92cf95491ee37303253247defc1e76cfe5ccb6f84c07d4cae4fabd22e036f41f73a57c871e10ea68434cd8f8c9800c45e761410ad9860cfe0daa43cbf0f5e38d487572a8b4e4d28d59805b354aeb7968c8144cd6cd898eeacb5f7b32a29ecb486fa82d61a9c3a3869dfb02aac788b779fdd00ac7193a6f851138ce25ce1e06abc07af71bc321628b8c176f0988d155860ab433f14d385fc8f024ba21ab7e17f945cb3292b64f0c4e1e03e216c68347785e2265a37c53b61211e642ee5dd56f6ec374a1ece8179f6f6b9c48847616036df1d7131d417fc4e0d22bb93302b9e006128961da1b5228709e31dfe76d79c3012b53ddb7f152e7081d901b93787367655fba3189a4db72be5a8ea5f0968addfcaae00f86daba1758e5999a606a9cdcd7e846daaf9e23adf6a1096760fc93002bb9712d1dc99d5e9b179da92fa30b86be83447d782294816dac19abf681cd6cf4b76a6154efc45c3c324a21a2c4f2193a6a1f342a6269c91f51566e78262393520fde787e876486bd356306376ba36bc13b04567bd0ad34576244b2d510345a10c9677a0fa81b7622f3d1f0230660c958d1e4cdb4428b4443822cb66dc80f241aa249209a5ed781398fc261148d3b9d0b00006acbe230f3802573dbde9843507bf7dd4d3d1c2b26cbefe50f31605477a8da406da37a2ecb655b01903dbe873bc9021aba82c41aebcecbf7c1868deb09fd8f80f3ef924b47f37530ff1768a4eb38380aeb54e44a8e7c9fd8d70f0be9fed4a69c1c3735da9da8ee68e6fd6df1dbc6e3d7cc2920e3bd8689626b388482c741402d552547d301496a1c3404e07eaea962cbd975bfa1dbcf0c1a8831810270241bf8a55aa07ff57ccc789b534bc20dc220cf21556deaa8067124fa7bb7929a7df8b437f29672508c4cab30887708013ef7b73f049195ed958b937ca49274a3ad3b5638078184ffcdc907f0c0fa267647890a0e6c4f582956be9b95d2a0dcb54be4fa27e1821464d343e78420645cf6359f4722f9d7599280c5498d58ec588b4fb49b568698d25bc2a46052fd02d87349f4c38fbeaf2e09fb54b509a718e0ecdda35e65c7d7ae3b60174f0e591f2e4da8c17363a9225751cfe733297025cee54543a545a53054531756accc11a37fa96b5f0aacf2787b3335951ae893d77f34cec7256df02bf0021bc68401bb17bd572d5a1e4d72bb71c235d6b4cab0041bca386ad7d95533d755f1e77102cfe3f92fc1c2c249ca0b2238e97bbce665e047cc2fe50a711191417cc7b4cbfa67ab7b0529f0657ad4c16c98463f99619395ca1138d8463fcf9fd7f52baaaacfa1c97a355c275352f869699b33078112e8ded56b2e480352493cf1bf246ab4949a9a7c5321747229cdd0ce500dade87aebe55eecbececf8ce6be3b1fcf36644c5f10821ccd0b2ebfeb765176d60e2ac453b32a48821b5fa5d3c61ba3323edca2b9e6b0bcdb14846f71ef3ffb59ae59804a89fe4c2b7ea365b18bde65cfd765bbd72554687067bf8456e049e52bc4b0eda6e0e692a487fdc666c58aca49d2730994439cedeb841580b10b649421ffae8e42d786cb42855ac2d826a1263d302e2b97e6b94de8fa57bc08fa9a51df6d7b49dcff717484443b86e9527b0c791810f1d8ed0b33bee34fc20cd68f14a51e17165a472fe8cd03ea79f97ae8219b1d8e730d8fed83f5cad57dce152247b9fa4180a848cf8bdb24a62984221c7b3c6d1854933ccd11baa5779de31da0a0164c000e3e99ff8e3b76d8fb14daceeba7f186e7bf943239220c9c1a377086391e9e479f8fff280e8d95f19486ff98b87b278059e07db780a3ff0edbdeba59763b169ef0e530b7dd02e8b3c4f96f18f66e612155d9972e1aa2bd502b933d04bd91648138aaa50735c8b5a2b32e8a5d225fcd254294f99d06f25d35a0929c7459f531a0f00f6fd5dbfd1861fb24b6553fb33cba4648a5be0100422446612daafd47b36810446b833883110453ecf700d53de96bbbcfb270318e15e877c455e1678d8c4ec9b351ae89d9098bed0a3147eaf8fc693c8ee5867fefb7f076b28dac7924b144a012d242767456ed140c76a36a820e1f21216d158","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
