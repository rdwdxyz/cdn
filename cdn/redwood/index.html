<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9ad9f66b2c1877b20bb7608551cab3537fd666085352aceab3123a64c7e0f21dc45039738a5f77ef85d4eeb2920709757227ac302b3eb309d1b9aa959404b47f3e06dcaf1b8a0ed8728c951c31445f2bd96507e1a48b1299a77c75c71fa51756cee860e692cf712dfc22cd869914a0aab0630420f08a0dee1e095cd811cdb84a98c83fab58de0d9c6411dcd0d611c3d03249112d35958ae1e7cf9c4651fbe39f5b19a96c0171b9a323d77ba8db2db4f0315e971110b7654d351cdd60c890568ff733f964a79fa5d3deea5a73f29740104c44592a15548e13de81b3aa1a439f765d0571adc5897668f76f5bdf67b4f59c618e3dce74b4aada8ad4ec76ec29ecf62a8b6a3416ee03523c2aa7d0b20881a7883aa8c6dfb6b2790f57c1d47b2d4b1d86abff33219212f93a4a8f295f4507dc531ee5af9ae9864c5aa30d17d4079206a9edfc8d774e82b6a80ae84e18639ed405994f112822cf57cc5e052617d50c822f9981ca3a866424cd9d77691a488fd0d4b36e47a3d2dc7ea19ccca79ec01a40a8b05d09f8080c248c700e3e9ad496f0ba9d5e200b6e24de6d117506bf07e742aa03d7c9da2570500eed91cb26b1b3fb7f3e88f8ea49115b4de6f5f319ec49b997dab85ce68844ad300ad56766b87107fa2e5f9fd4a85d4ee20b05d6110e6acb7a86c7a0ae11c9240211b0e52798d4461a995c92adc1788e13a6a45ddf91a7ef36dbe1eb17fd4b6060254706bd01f2faea1ba8655955d9f432bcb9e6eb51b2246d874da6eefb6ff08ff95c1968131ed2e5b6cfdbc7cfb2e7438fd67c01983bb6a7cc3bc6452778dd84fd2448d11f8d7a486f0e6cdacdcf032cd5209d9e25110628143ac681098f22abc63fffcabdda586c0d0a682fbe830f3212695b29382612d3886bcb7c596cdee7170e2fc175b79af57b7f7123c390cb6a63c62ffd12e6b95d612d6319f58b86111f70b314dfc92a7cf2eed095de0c15d0337b98e43ac737afc0205c6c4e9033ac42850dbfbb4c3c220d6c9eba096c76096061d10bbee7cdf0886c844f69441e3522e9b6123a6c08d7da78f60571d40b62172af1927ef8b6ce00741896a9fd7cd7a36e497af0d6faa60957453cd0b99956ebaad31830f8c10c72e6e1389b9dfd831da177408fab8ec8f0ebedf368c83520bbad265c5e9d80d2af4aa9b74d8ce6703de4a14884d9fcf546a58140814d60f6ec3f59badcbf4329e7fb87686cb297ff9f882061fb9c2fb594ac07239ec942d7ba60072d626bdf2106b164efc258b4b990de31ba1ceea5628a0f5d5409ba7881dbdf7428b4ecd01055fc087fbbb98037fbfe893c4c623d1cbdea6eaaee2fa7b59f04ba42e971d828b7e14f2489e94ed64f9cf8dcc944fd8ba58c278d2c63a672c055485175d72ca9fb441e2e6c91089f7fdc0d111a470c1893ef6567f35b010bd53f23e9f87d6f5f1d11f8861e21c36911689a61f44a6c7ba88d2f21f03eb3bfd7fbd59fdc2bea008ff4f3c4c64e2823fdd76451580d6ff671123d9bec15afb008d5fc1888debd13a16b6aa127aa7619edb5dcc63be1c631edae99d5a64a7a34ae1c1dc77c616ae23b9837524f7c6f0276492fafa9a5c91f2764dc55fda0fd33478937bb82a3deff3eab4132dfdc887ef778bccf94a689a7726b044c28d0a1fe56e4b7e2d2518099eb645a1eb54d70e8b002210946939f91e98ab3003db1ba28dc3dbedd34d9a0fad62b10ece98b6b2aa24ce80baa20c6c3d9972d00415e26fb9769d9f6093b514a931510c61bd6938b73385ccd41dc15d6b9ef6acbfecd559474964d08dad1afd8ebc161baabecd0395d0d3526d4f9bd130e4cce227290213bbf6f1340e7fb1506689e03fc5065cb43b14b093114ea6be9ce9d87c16967b58fe75b67035ce20ef37ad6376e2639ac056e85b3d6183bcca863fc38772065ea8f02c2e1e1635c5048b381944824e9c2f8e30628c1b55233f6696bc0902711738f7ffea34123d2ab97018710881b6977e6293bcc77e30cb1b06b496a3348ef708011b67634c2892dab178f62a6d7964d7b66dc7aba5c01af56c9fa691282338853110735d113c871742972fc47b1d3bcb70f760eaf52d337ca6d525c8611f69d49a7a7f17c7e6fed64bc1846dc359d0fb27eb2aecdff76679170972c398dd5260d3eaa17965191c4701094fc3f3facadc03d78689193213a81f6474d26eca8dd95029ef930f7f0682fa5147f7e1961e244fd909b9bdbbc6ed2fdbc9e86a71ffd0355d754de674acc5401e97437121328fa8e877159d94ec040fe2e043fcd8bf4d1a6723352f84fc674c39a0e33736bbf1047023d9edadf02b03be9b27d1e63580dd21e220483bf8722cff410e61ff8fcd6b53ce4fd74be988582f8de1d15f7873f5e7c8af2b6962d1b385495ec4e040412191a8404fc39f27981e632343b47d5a8ac45d71456a50ed1a314c0a2beea4227ece705e4dd5cb5f0282b4dd9ce0ea9dcbaedcc16d563742001848d062bf87d42c32a05f3611aab9a03a2e542170978db3b0bcf89a490e484a31d87803d6115bea9de32e53bba7469a2aaec87ec139165d9d7140c8b2ef482c641d9faede2c3233a186f9e41c179585240d0f6ce61d55dc38c8da59e82f8f9d26a066c7f6b9c35f91f3886350626c58cea84e95903b25f96baf49e5425a1f57999bc3095f90ab8eaaabd19a3eba6af41d81af3e9e31c9ef78569b28b65d2a969613a80ace42c14a98800a391f567e4ac77478b572cba4aa1d6c6fc953a0c9b1ef16e313ca4ff672de2c18588b6a265bba9f7aa1b0f5ef051fd1dc4c66308f86783e015b249bcca023bc85c2408f98175f63ca1b3216bbe19d14d30bc25daaf4c586273fbdd93d72e0cfa05d39d452178dac49e0b01fa7f814d1e5cdc425758a3959bcaa804d48b59c6c657faae164f750823b2b3e95276de88a2b29ef8b9a2546c8b540fa6e33e1079256082b840a0d0e833919578d3de009ce0ee3caab1674f652a913dcac640f10ebdca3168a5b3b7cb057a9705dc277cae341ce713c1f091879bfa0945b05881cf28192304603320957374c56240f303686392dc102014394de06373cbb85def82bc84c14ac252be8e9ef231bd3b5735562f7ce098278a9c4ff08d843fa011e261f2a0f63da5b500bd59644f600f9b339ce8e1188d7cc5c3b52573b8efe4f95eee17b82a8187a7cf7d28ff417aef3edc18a442f95ce69966648dbd04d5960ec00219ff88a811ef2424c45484351179123c55da903424bbaabbcee7db79deb16205efdcb4bb26c775f86ebc2bad6c5b53ee99ee7cd3b04ee1fea0dc126d2803d5b379b2d6980c2b378c1cf89a62d7a13fa4741e55c74d9ba64c2269b2d7b336ef7d8648899bd8704dd6f376c4d87a22d8173203f1314d6e7f8a6870370fdc1933cbc828f23456701c11f19cb7bc3e40a17753d7c57578f4a09cc570b4473f197b705a9ff19946587995b94c8b1524855fa14718865819e9889408c4ee1802109cacda476b13c7299d97e886451d49c17ac26867f773662c33b858c60e94db0c11c91e1681631f751751ba3b8c6f7e0cad14a0799a683b3c3a8bff305fafea1c92afa4847a5391128fc3dda2f9a45dd59f7a95d3fb4cd4ea8f1547984f9e295c545229a37c1fe6939da86e458fc4eebd29fed344b6df5eca2da7a5f436db5beff8bfb66993bbe3ffe0ed57b7034be97b0e6ffe912f7cdfc5dd0f2e78f74ded6c826b1acdc11149950d28bd2df7887b187861a8a6d3c71aff2c286c0d6bc30794d58f4fccbb90f99f25f2e317226bea3049e0d937ed549f596232cdac1f90ddc13c37a54e7e6589c46c1f29cde2520bbfe7e5754dab2a9aa1d1afaebbfa3a882f912491e43fa08d1505a42b54b75f54f3f979e1013882b1190b43b7d188d2460eda8ada91ec0a781e14340fb8130a898a0aaffda10a98366b3d8a6064680d1481f2619e9a511dcbe9ff8897db1812f4cda1119e6503c0d0d4aaa17778ead9cfb63f9040a1089a8a47bdd6bcb6df2a1ebb6a2d8e4350702d4b58030e1dcac1424a6b7fcf88319112cb1f35eb721c3787e681359f1f763e71f5693aa7891fba499111230d821895c19901f3d312cbe6162c5866599d20ac31486eb2ec0ae18202f7908a3fdde9e543d2b9ae9b30f17913a262bf1ca0a47a6505f06d79e782e4c40b5d19f928c761b036773fe99c97d725c5ea32440e60d22ed060770608f83ced91908149f9feab199467cc44644b8d153bc0a4496ecb20f5ac14c2690d42fb5485321032d7ebb2286ec6d64d65f2764dc714ca54a3ced9977e37b61382d496e095c75b3d70dfbf85d34c1b3e709e06aa59817b4050a1a2eeb522beec68c337340c9bb0cf484351bad485dc3e8a1647dc7a7334ba0dede276e115d463ae9e6281d60cc4ec96c2be3f464eb6a89b6218cece8a2c39fbdc39ce7b4632c39140e72469c91c813605cde8ef6c3cea80e80560e8f7f550fafe0523e965fc27c6854d289e37c6c0b563b025bdf544e86d542637b5e51c70c1c17c5508e2a0cf6b90be0c313832fe55147c86fdd20565269db515f7ff6fbf3700bdf052caf03a55c29ec8fdbbb485ebb349d22ca12e7a9564864979ba6e1ef1f4623c13cb8cde644fb93e720ee8be2eb13568abb5d8ff6a3a938ca4ee32ff55b8f93c3f93be3150963dad07e92a718209834543d3441e7a2e2188a8f8f228010a3c5918e25bf4ea1bf42a05c0a5bd105a575e4b3e6473c452086b3845edb292e800662d2f3685cee6f1864557d3e38440c96344292d9b10eff0e475f96ab395ad34f476137b7a72a233cd8f707f9c69a837ba52bdb22c3684a51793b9a008c74a2708da604b37fdc02906d1d14a4aa5e7f1a7c9e5049b80f306f18d41451f234442f0a241b8004c1e36f9e8888499f27bf424c083479b3d6ea36ca2a9f8437401299b4ea4a9d3732579d6daae4c01ca337deb605fbe2aa92fa9790724ad9d10aedfc8454a53ddf3375fcf5b0efc39596984b0269ebbd13cc20a60c60bb007173ca32beeba766b14e5bcff7a7f4928f83798ecb6888a7ae435f9b78466fb23cf4365b60bb5cc7604a82fa1bb6365707816e515f2f01cf9d2e31ef6c0e53d34c08ff0169896f050b8bf574fbc5ad5a3248c4c9462f661e93621c3e2b2ca24dd76f882775049048890a8a00cde21723b052d62bb552689abfa377d856ac06a2985df2b27c575503f6aa633206930a086acc1d2e16e13d3992f3947b094630152513c065b929c7f8297a372543b7b6939cd1b549757940adbe95021d97c18a7f3454db0714d43f0555d7d555f86d736f493665dfb54a0787fc712958a25fd8ce10b8d62669d9aec5f0cbd72849c7a4b065094fdb475d99b78e43bbb9036c4a8f3af93cd422d4d6383483187bf52593e77b666fbea3048146f2d2ae7a33e7c6ae43eb15916c6a7bc2c2becc0ec7e37fdf72ee09f2183ece64e3f7217df4f5ddc7ae1f22e9145c0bf0a8cddfea525d6b71a520ea3e4e6f2e957e7765c946db1f89042a6bc726377ffcb5278ce218ebe19d7e86874ddbef20980d429e67616c2cc7ac53f3c87c5bdc2fae1b5fc6bed5417b01603d0525fe2ae6aca25ba862594074ab5fc1dce4851ecf0ab380e9441b4787354157d890156d4d3d09072d8d5ab0b698f1d8a66ab05da249304e87ad6bb5d8568c60773dfa3e42bdf0ef55d38240151c85900379e29d0268e5ba932e89c682b60fec1fbc2e15786f20c4961492023d061659a433e19c531c11ad77975d9044c777cb2946334651ce4fa6d2e94fda1601d7be97d55e6b06278f73745cba2a0bda880457c4b96e49bff8ae23456fb8c87651537c2bab6287fcbf02dc174ece1ce0c1081ba1f5cfa8223cd9325360d246dda581d37309246cb7c8e9ede118240441c15b880f34f21dee240b7e10a60da5c6e1269fa75d5547abc5d7d9abfa72e98a4becd90095b42ed6d568c3ffa8af1089ef135d466f6b1e1929b869f423840489ad4d21916ef5ae316a7954cfd9ed034e6c585b4cb768086103ee0eeb1582d4c5a745ff32b03b5325bc307267aac01b80cd4d867c0d930e13c4d2684f009464fa7217da818cee42dc546e9bf9a40dbdc0c4b3b067190b63e322ef1a8154e6fbbff4793a1de4cd762f67ddc6935f837f6fb88ef33c03db8abe3a4495867ed82de3ae53508cc631fdab6838e58a889490ae10f0ea28e2d80cd73c36983cbc6942972e2ca73b330c0b966daff191100946751b2e978d89f3dfc652985c28913a08f08b046817b52f03a90a4e4d5c3e199510125722bf816808d9d01329ba8e71754e05ff3659f020c24629f53df16a925b313565d2787040cfde1d2bea19b8a41938b7c8e13233e42db42b0e8a0ee5a515c90900665ce6b84379b5baf5dab060cd2c260df48d4f1acfb3233c8cc0906d0ffc209fa5fc99a40c3f3e0d39a284c31c123322e1e7b7f4bd3fed2818fa3e8a2fbbd47962adb2d52806f9a1e91924be80bdce2268501250292c730c0f4ab00388c4e54e0ba9bbc3b2b17d71f94e1c0f07cb14fc9138e5fab4807ab440ffd45bde2a8804311f186346ee916d1321c6e360100973a68f6addd855650912b59d7219974deab900fdf6117ea1417c6d72f4c811294d41bd8bd73319bd3d7239f183f95f5cc0b1a3ace6a615b65231854026dbada5f1d9f94ae53e2dc7815fb37f362f3e297a9b15757b6df90cfb7623c154f339cc9a7548676d8184c6ddafa2844e735315854b6f14208b6a9995411ef41f3035420c0fd7b8e1657d69cfedeaa48ed973d83cd4d3d317f0503576a33d8ebd04a105907004ce9db8e52a5cf1e7dbf244c89bae407cf4ccd5a9f2388d63d409f86dae8df4e7ba032297ff86fc2a3879446e49477d07833f2b9e71ef9484e57eb37dc30d407743bf79498d124c196acdecf56b6a30139e1fe1cf25f2d0b3b1d6e0db1cf23af46d6a5c0d1f589d2b0ed5a369b42e3bbf90bd3e2abe0f1e4e4f624bc0e67f405ba1a5400f9a11a5f0de3f2f53efb867287f5cffba9abc9ba9aa733a06bcdca65fb9860d19b8e37d138be0469d14507c184de79252e5e4535ccce5baabdc52e75660117a2818a4a3907f75df081669d7193c6b7ae2fcfa90de60a026b106a718e55009114938f44e87682e7fad6cc26a09baa801442092c1be6b5cfdf64aa11a7e5269c45ca020ce9891e15f00d8f27db5891af9ff0e9cf3b510fc800b3fa75f7e275b4198ffa85e8abcca3ce089d0451d80fab6c6743ddc39786bf363cec5f07d7e68515d3d9953600a9bd2e10c7de966181b826639dbff36f1740658458568e3690cef2feef372ee7a9eee152cec4bf765a62189b950140a8bf9233e9881606fce34127a8da51ffc63eaae2dc7c58209e83de70e2e865a2d26daa63c9bc69a3c45020d7eb33f04e25d8ba88a60de1e89ba7923cd8e917c4825527ded7f2f863e6ba5031e60dee480350f95f3ace291b04dea941d577828306abf470d0c8fb700846059184651bd78c1d24a22a2eaf069be11d785a544454cf9b8bc0b278b15a21c95e3c7e8b87e3fea29cda08c05aff4ea9fd706825b927f39ebd671a1fe9a424b1cb74beea4ed78cdf5e3e861ce6f1e7aff123d5c2ea1cb5b3bb5e3f54f98bc877f66c20bb7548076efd4105e214eaa9fbfbd6bb3500b74f26dbb30e9cd6979643e77c01c88616031c7c15ddf512629edc5f53c7316921de2f975da2b7f5c9db1922a2597eb8e42943111adb69db7b0a1d2d0b0344cdde81b43be05b910034b116c910b9c73c90cbd089258fc65b2ddbd8467266c618e850548612e3c3e5346e27ada1d25694d38df1b876ff9eb908b592af8e75381938d198fc3e43ee358fcad9b7a2372c9aeda86bae2364588022cc72d8fec4ae334828098097620d09631949d1e6620c258549db8134848dec1a8003fa101b9bd778437708be0a58a23e6c6be3e6c2fce83b1e1ea6990339ac90fe4ad6e0f763785820dba61840b17c02781a7f4b2c89f9f35357438df505c227a6916ec781c9d0c291d4dd1fbc0287de20885557dd3444456d06f703fcf95d36129bbbcd3ed76297a512bed3265e8dd3a0388c722e90786449aea2d16b497ca6a03419d3b78aaba1c17cb82c47939f84bc674bd1c03354f0e0ceed284e6aa873b1b38fa414aa338cd50d3d033b0d8aefb3a56e0fd14461c6172da976d9fa5df259895e22d868dc75c9191fb69b69a7a8f252c03abaa3f50d6bd94a2af736d9a7384ffca605a49c38599880915ed42171468ae601caf296cd9567e4fa8048c3c94e274bd9d94baf4430a543e4146cd4df95812aeaa6f72a77a21c85912831c8907b1df860118fd4bce9fa4585935b56b05a9293ce16272dae66ae5d8fbc610679f01df7cca57f25383b03373a0999a5070efce2f72b8b940b6c8a591f37509fc3a92ebe9400736cac2fa5d6bf792d97c139e5b4e33586573f74765739dc48a4db933f65feb1cb01711c6b4abadc4af35ebe64914452d24bdb818ec70df29175774eaa1592159f1829a1786085483feb816d9bdcbb344102923ab69cadde9c70565c2c0a1796023ab3f8f58ce391508dc7f2a6a07134a16b5b2555d9dbc71d3e2c913e259758023b20e73c12ba54fb46727289c8ba97243ea0df4792f5b26a75e0e69fecc7ed392977dd62456a2ec466b587e6cad78041f4423f96ac6ed12a6cf05bbedb69c264b65523348c6ad8a6e10a20fee69fc1fc4149a2ca6b2ec00baea80faf7bddfa52b41012f094bb4e3aefb06fa1f819d59da6afab8c3d1f5e159cd2616ea665fe56f86c562a7f7e8da48a67c44008f34751d24890ed22b4e439bd02b67748c532890d0c080abdcaa5563f13e634edeccf405e8dae6239e920bdffa2b7099cd1144016de6fcd544f0e0560278f2f1f92445d5b5be609f7859cc751c89c093d3a57bd32b4b875802c17c08793ae889dfbc3639115b1da743d9233d3eaf865e6ffa452a749d97b7046f8c2d5c159c5c4acd5f7a9a9387248f147f4da9f46366ca1303d6ed22d604a3171e1385f86853cb7f687e4b0f24d7929e7d131eea657ffa16993e94a73699c9876888d5a93af154dc9202bb5b4bafb75c8825045e5876b37f5678e428a5ff1b1802def485face8fbdd0860da8581639d76611da7fa03da4297f8ff2367c1040ed02233b8df6df60efaa08ec870e275da08c09246b0379021c58eba594a5385ebf7a05f72774f8a45622c0caf9dcd4e362c3c172fa9e068128761883f880f8f86ca9cefb0befd0851fc57263103d0918bd595505decdcb2b28fc0f1d165834430d24e235dfe88db8390951d549d6f3bab3cbe83db1a9e6e50728459311d6d2d414944771260cd54d5b8ed13cf7188a15ba80d50922d5bfbd2272391b64fbe214413a70f84c3678f4b0f7cd7005513d9325a16103abe9c7f57608bdb1047551b668bd96a36d1b8764d9bbfb0063f8f91171440fbba2b319f8b0c391c44d273e8b74b96e8a9700c7354e8a13ccc8d37036da1d98db43cb1dedf596c27e931025e54ab4b10397d343d2074ef5d269af995b4724eeaa0a70fdec12a08937f3cac91fcb4674aead1066a0cca931a95d2b678e6790fa557af89d114a2ff36286f3781310b1aff24fa2016ae00a51062f0659c2a2fce8ef92b1a3bf4708aaf87bad136b7c54f9a93fa20306134ee2dc84895aa258241966d6852a0903d197e6f7261bdf0ec77319d9a4a0876244d805d2e3c383ef34fb730d9df428e6cd8df428c79853a42d8c15658585be64aa69b983823dc1eb0000c0db239971589724789d51e858cf2b693d42140860626254914479d93cb487dab78126a7f153adc6c4c55d9b48fabca95c1afcc78fc7d8b7bbbf5a077546b30343dd12806f5743a060df684c468b1ae3216e9e86e474699a99db4e2e1576dd5a10aa2adfa530566485f8dddaba8a6e3c2dbcbcf93777dab624471749381faf169fb54cd840b169351ad27289af1c312ec516e3295a627f53476f3237c58aa2a1aa13bd3bf448b1ec8649c376ad9088d9874676862d687100cab9685fc4f5947de9642ec8209b354c246cfff2c94fa952e56d27cc85114810bf0f28cc26a5d3f5f44d6a1f645d38dba36705bafe978706fb84cc25549dc35205e4967bf37ff805a9d0d41f4b3be9c104b22d2b61c520e2e579dc469f3bec29401070461a6ab320ac90b2e383aa8e72c7bcf456331669cfb39e9e07315854a790b19facd77ce7977cdbcfad8501a61ad202eaf6c1b210006c823f1014be9df3df4dffb412093181c76d00beba06d04748bf93977650e276590689c765493cca8d6ee6a92cb1e0e39828dfbb495cfd741128b50ba7b1cf010851c09f7ed5172d4326a3ab866dc6f3ceb57504bd997a8694340a1fffa2e32bba867240b22f1206861027eb06b2d91b68604ba52091775eec0ff9c8a8e504692757d2a3d6a289925b458c61b5a8663d0c9c79e9f2d73542eca9a128df433bd396919257e5b91ae7e3d03949feaade300994d23f564b0d1723316651457674824efe0f852e58fafa65ada9ea261e58fece90eccb483203773d03f49d86d8b796d28658e63d9c2d57ac5472f79733839b43f3e87569ddf5725a0d793692fa23643c2c5d11c699c50cfe420fdd9730a427203a42e1bde1e7002d5a42ce1bd2590da300b6a5bf2201b78a0e850b7a10079ca07c3f27981cbb7fecb7eb763f70fc809724cf8a167821ff64fcb929826850b31cc0a8754bedb97b2aa80f77ecd9fbe803200a6bb887185b2587713555961edce0daef2d443e068cb94c42598c50bdd79a3b3afd0de6f33a483adacaacc4b47538e529938acb2c7aa64f0d78e295b3874df1b71e227bcae23a7e18073ad61186656516f30292adf8767d1257f4806fe494dd11368ebdc22c22ce8f20cb991aa2de8a1ab7be2d4d37cd411b31cc81e97758e9211db104b59acfcdc455aea074f3804f21a6ff6bd555eb8ce2c284ccf86659c634335a11b532a46290198fc7772c28541bed0e05ad09eda52be42314548c31c6e8d9f3bfa22e61189068b5db9ade2f6a3bf28a5b4ce6ab9f7f92094bdb8f77d30c5078d67b88bff3b280e322c59192fdf61503cc332a389a644dc93faeb53aefbdee228345a097e7d47f2f043d4e6890c70dcac9b77b2c53e4eb0655d501fa48dd01e13b3d66988a043ce17dad8530a140274b2c84201cec19de1215a61f0166e4b1ad9fab4961f80f9374e08c8edf12a145a1262dd083efdc1622de1b0bd29a9e23310e388339b4fff857937c7ca70ed6062ae220dc8a073ab4b6668cee594a85ebc6b3839002b40f07342f2ac4b39bd41a162625ba66ec2388fcf3e4162a2f27268cd950faaa0d76080d4be265370d1c0ce980b3dfc5e5247052f500d68acc7a00796e81ed65a0f3372f92b6145d2b13f45ea2044aa78356a2569159c010d1362ec5978e9f30b4b22e7987a18a7e185d4576157251d587892f434fd604a31e74aa6f5dff33c6c1bd5ae74d69cefc4174ca10647e93a5a7068a75e1e5a9da96438aa0164a04ff6bd9976ef06005906f515e532200fbac81b533930f058c2de93b39a9c9115eed6d7070cb6a07ef6233b97fc3e71e5c01f1a916225209454f44ec1f5262aff104e2545fc9f7de934f739b15de1005587b6ec8660b4d0781a7206db1402edb620789bd4d189c23761fe6c551ab0880a967fbb15fc421749af51fdf004876c0befb512247ee6e4eb56cdf6c79f2794caacec03299f99344eef920f96a21a39ab72ac4f42907efb4ec37ca44165a7e9dbf3c554a560162540e312899a131a6850e7a09ce7cd66e63d72a21c56a1765165d05095a1196519789e84b3b93a84abdda989d4eaec688666cec8358406e6da0eb639f6261b2f645b4283c7c24a9409d327f382fc6f44157b2482d02dbd3e6e5e23f6daaacd94c067bfdd35d6afc04d57eb4128a1db011361f099cd0ccb7c88923d4fa1a6c6f9b2deb1afa0bab50a083043bbb27889a8793bd64bf90a2868212f0d82f6d0c17c2ffd5de4f686fcb0dbcce190ff4e06e6af4f21b840335de29bee6871ae4229a1c70a8037f537589936b30813cf093147d302c04904629ccd9e38dc27f5fe2e08921c2ca59fe25651b4c712fc48dfd12db1330c7c349013eadec9507bb2300d80be59d74c606117f235824c73d3cefbfef853021ba61932d47488b0c9f86b3179433113300ea5d140a771caa7399b64a50bea1ae3ef6ffe0a5bdd302029a9361fd30aa6c9dc7c9fbc222509a9968e1a02a35f4cb9de11b59f28329be330bc814f8cc4fc9638899f75ba8a6ab7306efb29edd0c060ae122d376ef460a1098b62de6fccd9ab95d52333266792de90ebc311b5fcad012fb22a5520d538f0fb01f67f5bcebf9f84c3d118ddac78e3253d03fcb5f3a60e45c072300413eba87a4ee765e94c32189c8b86d912213a73d96bba2cdd6e589aec588a8ffece0f5b01636baa046d4f28cc1589af65936672d5cba76e0c8af571e3265e4c88692b907f03975a26b4866b6f112928342ed4c3198ba2c0c2ca315dda87694d283b12b773908b6152691619746cc878c7be5685344e301e0c5c05f0ec41f048474ca235e69aaa822ea97592cd39af6b4caa4fa8a5ff869357d74fce8cf35c175309502c09016196b04b1d4aa638018572593d24206bd824ca84dd67e4969357ef661c11a873b6be92085f2801d41ceb3ecd6832afcf444b5f2b75029340c11b30c8e60556348bded0f46024e4852da1a65d8a5a434ffd0a24e6f321d5bf1b7b8ac636c5481bfe2aecf42182b6c79d36da08128d661ecbf3cc2652044bc4e8e80ba453c4c31de8d70f93eafc003593a0a4e85e83cf0b8f917988913363ed05579171b306e7c37b7c8ed7d009adacae85147d48b82a7467aed348b65722c6081e3faf97a2be323298216a846b5532f7767f9ac4cf7f9226e3f7a48ba91cf46001674d3f9afc2a1e202a356713e6c04fc3a78d3d633e7fa5d4f7b827167e62302b56119860afcced85cb445a762ef37bdce2cbafdba69e2699d181b9d2ed33228ece2e51506be03dfa80d16a20659685b5e9bb0241bc7d22c75c90ecd90fcac5c1d11bac2573387b8c2a20faed20294bc316f76290e832af123671dd6c504dad868421b6b4cfd826292d79c59c5d2ed2576dc5383389475005b621dcb4e9fd0f9684cb1d536ea4517b177196542b1a9d2fe6d4db31f23cecb67068fd4be572cca0a5b352e44845c68f0a71d5079a2e5c4d4099495f80c33041ad5d4c38b66ee9aba8e9780931c22447bef13c1029cdf25c02e1fdb78c497a006500d883c5840da6379cf05610dee0d40de5d1908eba667f00358af06b4b62d4e0047a5fab48192e72d0fb5fc63d2755734391b3e24193b03d98d70d43ec992d8762c3c4a6bd85ccf177f66a48377529f78e04caa870761b000c1a6573bc31793325bb64c9ea589d59a80fa9f10926be2055ff2db91b5065aa635dd27866decb1be9aa6ca53b8ac3f66a6d98699be7cd51d87adad0ed9e3764870bc88e12a7d28bef0ed2c446bfb0daea3d2014eb3493cacef0394311bf1cc16425bfa6c5407b5d404bf7977aa1f50594aa873efa6d5198613123a88050021a51245c843ff7a053be743c331f69434f208fc061ed9cb9f20aa1f76fe905e74c67c45000fe72592e0c9d4fd7d71f903f42c9847eef7805643b496fb10ad8540b640bdc375551f6d8e5210de95139671363d3004383d03caa4d554f29c1e06270e746e4b50c7ec08c80c4cd22cdef71f64325e1fa8e9429ccdf37d58a0092b4b26a0699a1129e847494b927a5a5f60791f2229a761bda48c3dc89661263c99cb0bf39c16364dab9a8c8e91276a17d2197a8da479b252d82d8e0f176b6de9dda08f2387689314bcfe4288e50ce992b78ed95766a32f364ddc4e1041a01ba85da5729ff2f579d7e73a8c6ea2bacaa9f57cbc24d13237030a806ec924e84c1da672e7746e1b92075779674b86c49614cb56080bec7d60058c63bd90352e7a8adc53c095493f110a4cd983fb14882ba34c169450b73a27bc8b951f04a005cdf742cc484278db8dc7773b26d56fbb5dee3311e5bd1cdcd47be4ab260cdf7c4c7abd1f6d5a699ef9863736b584b05cea37bb063cc35b0c61ca5b5240326e3fc2db01f6b4e505df60be62abfa9a47aed5d3743a621e5ee8b37dc43389bd01c424cdca57a5c104f7883bbf638be18ed1d9db25e70105137f8d7c258de58dfa737b7f2b4393ae947ab3dfe89c5b566cd740c5d4c3f96097fff9b935192a31f7b92d38fde1f81bd3ec0022e0a0d760201b4df311994936c6e6abe431f56377bf73a00c14d7a7ed6fd247c05ff356842b4fd1b16f2f652bdf468d19b7a3029378c6feaed4d4a1185ebc52b73ed8ca0bac68c53fe3c507266efcc1c7b80b9872402a186d9292ef9de9032accf2d55fc6065834e8bbbe355b383cc7ce58307b96150bd15491dda2de3fc0003351dda42c4ef91a7116bbf5b70d02c9d556a68df56e04dafa74e45b245a7daff497684b36b29b7464c255125f76506820f4b5fdbd0ce57a6ecc9ff00954512ecaf2265b4a246f864679522db7d2bc2f4db31a4de4565da37eecf55ee2dcc12dec606722892add76f1c6fb60fe214a179f4d61c42b9276b8d859d20e7c5792bc718a274e470c334f1e7934e34035f6e59b9557dcbba7a56de82de2b882266ba170b16b89073cacfdaaacf09f2f7e456aff57dcd7e003dcae665a8196b3229a8491e10d1c64b951ef29c6f9f22b3c0191ac7ed14d4aae4e1d795b397edee18476326be26347a60f95f817f8c5d14fbdb44e0ae880baa9f798ef61c604f83b7e3075b7854f87f169a8cfe5c6f6ebf9aaa0615a401f4e13f3e7cb0d2e5a27c225911dd5bee1560d09e4b9b0a67efa3fd6c8abd721f7c25052c223c602e766f4b22fbe2fcd3a513b7f4532a3b3856ee61b06f7e360f14fe08d360ffa11120b21870f794468594e040c5c0e2277beeb59a62d9c17c16363b9991b98240840e1912f684ef98000c1b49bc0ccc0e21bd038a7318522eb67dc464e037d3cc4fdd7159b21ee4b710e4818df8310d5cbac86c261d8b96a64ff3ff93d65934c978f3f55fa61f5be720e6ba4b0ae33f40672ee499eae7189edde5abd8b1fb6bc0d9ea297a755e230987b564b1ac93d561f2455bd9427741cc26de3be5d4a261a56d371ea9d7e7861f5bc5ef09ee413f4925c8253b2912ab9392d1cf2307deb686beae1e7eb5efe070499fe258f182751b6b756c0db0a8d7e7e9b85621f08e1909aca9fa16b005ed94968a181f26272fc8b91119321f144d4ea811502526e4579e4d0dbb8f9c21699f437b0420f1abfcb59dc3fa4c13d219ca0b6be69676265c70589493e63f9cf451f643ddf28aa585fed69ccf85bafa7ba5425de4d1b1e64b8896a9e72d14a280d35a33fdcc2edb38a60fbbc31cfacafe97662ce3ed6efbf13f19c41faae6fb3f4f0e7172ff0d8a9d73e64abf4841ef9acd2babe208cac17c1112e448ee6d340beb0498d939f7af321f0ca4733d0253f34a15f5fba4863d22ff11ee3876f7b94ea6b20ba12d0d4906df89ae60f3bca10772547e759f5811db1365b5af852abe64f5e99a6171e605387d6b58efd4c815f104aea547f4c562584e49a9e97135ab7f8eaf85f3e23a05f575f3685c84e072f85301552be4e59ccc80dd7c22a91e2b05fe6934238a59a01aac57fc69360467d6a4b5e72742b18e212eaf41ec34bca0779168f6b593811689bb5d7a7f9dcdc513ec7539ccc9de09cc97e48f651b651f9dcca44bb54c33e7b39563502764b21bf86365ab4f861216765938084b4d01bc5b8da4f74eb2163e37c135b6a5eae645c306af6d316b0120cd818c60caa171e6e1d1b7746a6bebe0ed0c3373416965485488158b2681d382aed96f693142da24911b985b126b1c22b71dc0c7b781cee1aabc601c1a82635637ea341b5539d4648b8741e3638dec9fc66e637ad99a4b7fb4e34bfeb1060aadda5d982f5d9f59762572d2b243d1d448869f46cea2ffc439500e3ef4021c21bcfbf9b49ba9a2c076181f14fcb266ea10353e08621993d2fe0ffa768d0602d356052433aeb74dcfe88f9bda5f2241428f82cdb6a12c894cfca5ce59dadeb0b95338fd58c4b2a1e7f39097dcc2b7f415c648e9811977c66c1aaec5aab60d142211210875253cdfb27cfbb36cc050e84ef42bdb86186e543c23f57b8ea84c4d93e7e541cc8a7e94199090df44f5140efde6a4bce19738f6049b5c9ffb3dfbf4adce64a031817665cd436ca22a702cbc2964bf76334f0f2e37072f01da198ceeac9d94321261c2a5002db9130ece89bdc46bc9c7daa728c46ca1ac03d631e0c31e7ae0adc5f1a939584025940e2bcbaab8a44a2291089328a6024653410136b1f94a5ba2433364d01bfe055883d74a4bf86b8af84759e4d08a0d2d9b452586052ce995837f146f0abfe93cee0f7733741ef4d7dcb8a13bf248a91fd05a95f39f0380398048b550be31dd711acc8cc1614809527f510beaf6d14a5459e6971abdf357dd1043918d2bb43684c39e7e9c873b42b85fa25fdd3fe18937818d7459cd56132a7ffb43d98816161d31908d14bd0578e18ea06502620cca72c5f24429ca2a8a7364064fb50ee32b49c6b0d5bf7f01ec7ea3f306187b76560ff8f2c84554b0c8ccdaf86f1e758a65de464685e003d04f7dae5c6898e130da3ab34a4a0cb90932bf9664fde0636cb11db20e9db3148439e8cdc1b27f95429685dc58954e13649bb6b12045b5ea27380c86ddbbb0aeed5df562b0d990621dd172f9e4880bd8cc48c93e0c11ebc6a37fede47dad7471fd34fc06f2cca026bf6f1e498fadabd06752cc1f006bcbf1a2c62902ff8328ab0bebaced70760058ce33c91f48c7e0e226325059c83528875f3c0fcce723c0d91a2b2061ac4383c5f839dde3cfbafb442fb0c5091f3e13c80005eaf8947dc04f7b84c5be0e78624334a497c0ac888badc2e5a04719dd205d8ff269398ce66e6dbcf1c4f83a24678990ae19c5ff3280ba756ef122d1ea98d3b14b8f61398516eebbadf17c474f4d36aac972fe7894ce13b42e21f2df62248fc66bbdf6f245bc615e4d40053349df33abb02f798709912fdd5ba53a93a602796420f80494b4aafd329db4031ffbe98c184a0f622d0b28bb01f202dc63439444b9570664942538db7ed1a8ae88f0e872d7e4d978daa5e1272efe7ff37f73b24a7ed8a93c64467cd9bf5f45363c020707605473237998d4c7d1ae5334271f0437ef18fb32a908257c932a6ce15b5423ac67c260e056ed520d44448d08c4beb2bdf52ff9face486c629c29c3e99f433cc97c05d9b08f26d743a3112284c2f01ae7c24a2d91e08f11f6fdd6cb19aa21544d91a8e813bf4e908aaae425dcf553bf029d6d7221766e8bd09d209d74bf5af34d0ebde4065950f27ef023e7848ee69ee99961a6baf3e3d161880ce8017c4ad246a2fc96a1202fa4920d3ec2afa98cea8b4f5bb60c76453096114e913349373982f300549ea32cbb1094266781578e3a0f1c0f5f67596d373653f2e66cf4cfb9577273f546185bfd01b6f3c4e0c75a15a3b428d468a96abcf0c6bf11dfc7c28146b35fda627a704ad716463b904f78c061300d1779138ae16b89e3b8dfe905547adda18eb7be05b156535b2c1f43ba46dd3b0611a4371ed270c546a32f65fa7d8e7dc1694bbd1a75b7abb06e4966c2ac46bc37358ff4dd53b6ff7c67938171301095b2eb6053830658c42f5b07e2819b673264a029f686c5b2ee9a65925098e04f465f87aa489af6407e16b563ae5772bb02c63d6deb73bb764d7926bebaf4ff6bfca080dc92b3be3ededf1158be5f895bf9290ec6765ddea0dc09ef9148ef6a843b869da4abf30c3a6f68c70895ac5fefa436abb14c6ef905f55021b43ef436512000817e513a8764a3f16d5c1362d8484ab59338f66eac13d769493b7be2889a9199e3152a3239522dfa6f906235788f6da3669565e1273","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
