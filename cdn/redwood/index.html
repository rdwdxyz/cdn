<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2887ea0b66def15ab17a8e899b51bd2e7bf7cbaf6793cfcfb9d52c7847aaa46eaa52080f83491db0e8874308c0bd75c73dce46d4dc8713eae585445e2106595be596f8d7fc9ebee0c09935c0f88602088a395f2f494a41ee43a418189f47eab7154ee2b116047999e504338954c50287fe82acd75eb03c5055dfea07830c038a1b68a47bb42850dd4c220d96b361d04ca434ebfaa60c0cbb540a662502ef964d0e13bb090d217b371928b69d031b8235c3d52127dce996a26c638a0c9901a6975c7c1c37c0f371c1f966c183ea44703661422e4397adca8fdf509810dabb0394d4eed8beceb7f59780abe3ee6a82d64ffa2b1ef2a20c7741d6d3579bb7781f551be7ee4bef812802ced0cf5d84329e18cb76ea9d6bbd686ef8e5bf702f797615a8bfaa1261a094ff5d85997159be03dcdc84934b8a9587afa3b9284e629b162e8a015a4c66059a4a6a9af9ab37d7a0f20f7e235f990d9f3f4921ea8945d38a0e5db0b88f5ae16ae1c1e9f43aafcfa511e176ee771574a85a48c542756105452550519d099b5ff10e81ebcff78b30f83368acc829a07ab2363cb82cd763ab1bcf317e2d904605a178e0e9b71dafc3b1b53c5b9997c01ff59575dc8de0058b61873e851b8e93de5c391bdb6152a45adc064026f9ca9073077896b0722d8639ef076945f0977f08920d72346b4e8fe3c297f488a983da9145d06f351b8296146d54f456bfe1434af4ba383e7e3aeabdc41c31ff3c22add4b0ec9186ae99b9272b4315a989d418b5b7c5233f94141e958f64b15b0afbc55982c4d9c5027ba6cef6a15e08d8d17769b4c30f68314b533bda14846e4dd322d3b1c181156269e93aaf9401bc7c8055d40918e746af1119cf2af9aff3e87265092a89a79e2c618633a48429e0b82e7f163251e87848a0cc98c6193452fcc1b4fddd75e7e09c7d6f0dabcdbdb0c2e0f20670c4d22d08fc5bca1eb823ae9f7f24d03839b63ddc42052f92108c30481109fd4c63afbb0760d5cbbccc434ddb76e4150aa8f1bf673d1b78e1925d242a9a7d9b3972ae949495e54c65b7901175a8b53ce36565a3170cf2d8c663f6c746f03041fdf8b220f368ca4fc1db16bc6cd1ff047ba159f21c71f832390502b3b8583b8be539a428b59cc61e852abed3c1b1de1b7fcff9c249a062ff401b088deea6dc34a6a621e5a704b3a1dcea33538b42afad24048b7905ee1a3f76397073de3a51eb4188e8ee0c820864965cfd67009a91342f44612f466ce45bb7ce3c168bd80069c9bdba4d9d2590bf8e06c8c972acd8f87986d3f5ac78947ba7408c9ca7b48e1573234688fbd2792229af95bcdfcc8e30bf25e96065048e80a4df08ec0bf377c00972a1774703b4a888ab249ad9001aced82645407f6ee9cc8585513b8c8e4649dc950c4f7c5c74c82a63589273c62ded3a65c97e1a1bcee23095b7c521e3cc24fb7efeb049305fd2fb2776c0eda6cd2871384c66e974a68ffa78754683790799b1c51fe7215f87a649b80f22e9296d0de43435863e964753d4ae125b395e5620772c7294cda1b163c9df50412af016bb10d441f8f3cdcedc34be1b7791ed66a6b4ec0030effe11b02b5a1c770727148ada3a12724b47053f8ab340a6b7954ef19cbea7ea9081277af3af93da04d8cd15e5975853547473c640e41e5231d67b25fa7ec4ca4ba79423d5bca632cbe0e1e6cc8a56562a511d2dba009ffea9f914d12696771900a519ef779799390789eb501b71d0faeec6a54d9b00f7e1f8d2d3b567e4526b44eb76f3a6bafdb79b113c48cb51ea791773a86df0943f162b450c51a22aced4774f648b23f488edfc547583c584e34c2b5f4b726ba7fedf2aed3f1260657faecb287472ec2264c15664593199578c6a607c2348e0adb3fdd7afcc02029cdf2af6a173a26f36b1883d5122dc3bc681be6806869a82d7f0db2e2424f988652fc7eb9f0882d1e3af31d3d6e462150df08aa512419667596f9dafceb867a5ea2c2e4b790cf0516ce9cef900fe6a26cd9ac741ba0ae5e12ac436afe731e580b84ebc78c5b7974a27b7b9ed0387f510cdbaad8b13e0312e27307748c45131bbda8291432bf0a574bdb1650bb2e6eca0aba45de53f2b5d09702173ca8e026d580554d87e005f28563cb0d1e8edf2d31a4e6391bbcd370a462c4c8aa281f13ceae1fc961767279221b00c4c14f9e81d2ee993af8b0f818a5b39a8c4881fb8c3da85f31f35316661b5ae6bc4b5df28a5136df15a434d668576e8139d4d9d6726828a447f8eaad94204761a3f231aad91f449eb0e8391a25b5f62cd8234859fab669da467874ed7d598340fb21e7ae3702d631af53af6b9554554cd689d14312f381f1005d607565f4628e5e971026ec4a1ca6e2635c10a4418f6b891e77b3c3c4c8f61e90eaee8155aae691a2d393952a78e9ea525c3f05a50611b030482247f08f23afa2b71c34c9b2a40ec0442f7ffed04488b57945806569b840a49059414d48bab7944da68f1d1f0a7d80b421897a3ad0a89177af68ea1bfb5fc93914750a197809931e5736251c0cd83a4a18bfbfb1816f41135ddfd1de4686874174ddf9849ca0ccd0cd2419d1e367a5239518180ecf5cfe11edfbbcba89b561bf907fd1b415b5e9b0eb9b454cf14e0bbe1a96f87c3f44f526b66db21e34e306eb4fa8e1efbce2f39e7bd88f885181511f16a1a59fb6ecd556cc14c3ca6e0a7cbcbede8c3e5c0bf470c36e1c127c4386c2e3d44a43f516b6c155f57eb614f1dd9ae0bddf5569e0472977008915a919a6a42068ad8f42733989cedab4b76ca05a49f0c90c9789c0e490dc7e20aedc71c4ec48c223454836799a5a099521660e8f4b9938eee6ea93f246d832d9f9a0dd55bbb8cdb9bfef1692aaa73a086b13e51ace502ea4eff734c6e2cb9efc4342351381d19a6876405188a81e445a9d50dc3848ddaeaf639ba2930d2586a93dfc2b93148def53fcad9cf3a733da0b4650a458cb524eda75110f55bcadeb6632265be18ae6c9dba918c6cdaf44278009255420badb7157e15596917c23866827373daead9279f9108d4dbad967588124fec887d76154bdd5e0d50d23226089890b0811d48ae9a6ea6fda23635800b866383d1d54831c83b1c2bb9abc37914a5534f59dc1a552797cb8e15e3a0541ae1a4502c959b4867bafc583d15f270c28fed2884ff07e07ca6ba49396160e49edf57843ec1f87000b162dfa212351a79d50b029eb859b7c3d803e0f530cfc3fcc85fddd03c1f3960e5b2cb2f21be67773da3985036c69e924088989bc94c8d6cdcd26e68fc5e5ef07821cd7281ccda4e2917256fe87e76266f574cca6525e1988da7fe33c576389217bfdbcaf3465f3ddb683f17460fa4bf9d853d54e1f99afc481cee303b331c372a64498300e36a83a17059592ee259f69d7114679e80144f8c8e3b6ded1f0e8c04d925ca26e369e2493e5912eac176f5995d407af88744a73224301ff9af6bd9545ce393451c03443b81b6fcf544afbf7a11ee92f4f86349e3f9d7ba89ffbc10c68d530de793539a4086d7446076945c79a93de24de2b68371a17dfbd32f625ecfb0e0d301dba513a449e27b7adf8937a58ca3588a933550e6adf58e2bfa3ac5ffbb41fca990a7a496c0b8e5cf7684536dd1d7aa8c37aade0a3a46c7c23934ab9937a6bb721fdd91692b67432ef20a6c0f3719a491794c562f0b682525c225704a818b6039ee93f3f95c4bdf8864ffc15cf4bdfcbedac0d221aae27f367d1ba24d8dc5bbb8c61cd6f49c7ff5ee4208e4be1abccd68bee7bbd846de06e53d2da883684bd6159896c05c0137b1f5152ac3583b4cc1cd8d4d57e63d3b1d1b10e03b36448a4aeeed0788f9aec34f2e784829376d53f81eb578aa77f8659a775fd0068cf6249b3586e88beb72f7f88af828f4d91b3b54bef7cb0c7191fc7c9088471299a5cf1eda9798f418cd6dae46e58d3232928cbde30e3cf2ff2b440663270c3f7ceba43050ffccb19c58ec154956a36dc2acd7b86c12fb600b85b15941ce12b3a32279a1dba57fc199bed2a6286ebec917cec72cb3bb343d87fdbf1c09eb3f64e77c1cd9e85218e1b03654be7d9f312db50c13cad67e19dc5e1365a08c7930a18e876bfd416ae67e16136cc98543df4d67ea1ba3d28e23c7e7cbfc9f4e3c60a5039ba740813c4e5c0941f927d9620009fabe929843a052b2db750edf8654c4f397d87075a33eac060b777c21c5ae10ffd5a0f28f2ea95c8ee5021a69327e777ac04e3fc2603dd3658426c8ed124c17c7df0b475e292ef8a3ffff347c282ad646f2339f84e5cafb08e77bf52c2e2d8906b475312cd893524493ad8ad82478024713748457a8a36263226196e7967eb3acdecc9ba2f7130bab561fd7aaed6617f06c43ae7251b96eaf4de405a78bd289663d1dd5677a36c682a91416ab404f709ddb5be4616c9cd7c186311e3ffaa77dc5fa28d3cfd73491e4b9e83bdc4959716043e5b844be3c8fbf7811865221075f74b62752cc25234beaa6698e279f7408c309f162076008479170e5b89a82d47f2403775e8b5be51ff76e91e611eea2ced300629537f597883ca7e19b6218907eb634ae463589c209ab40313bcea16f4d9d0c847d8f4ad41632e6a396526b6a0535c6b8dcc1106e90eb7d035e40d9844e2da4fcfab5984a2bc8368d5c1431e172af64c34bae5d8fd7e5f3a2cf3fd1a3fec0fc018c1e190259d765d48a8c98ae08ed2886ca965b32b875fd0034fe2417c3055ef557759e5d093294afe61d6fd1bfe89cce762f6fce1015791df26969b6e14cdbe1272beffe40ec84b8bcab6535f7a66a87946a0b0fc69c89a22b29b70521b9e20a64fc76b706d0f1ca0fec954f524fb007e5246e67c298f3f3784753e7658cc930f118c9d84fcd4d27190632618a04005dd98cb83f4caf1819134088b5aa78c42bb972ea970329d13abe18c849fde52df8236412d324b278be97c433a54252ddd38e9a46361a658c82189bb34da7d0bef4482cf0ee066db09e89414d1dc3138c08d500a20083093fa92f34894403aa1e6f9131d702510bf5889d28e48f3c72aca44fd986f4ab9430acc92a35f3544bbbcc742e028cb571d93b278d95124403bc601f3757578f61c76b18db987e43b2033f0bb8a83f02166331791c0c49e6a6ba847071892657e9eb089634d4ccfddd0e047fb7a69a8ff2c64a2e310d52db49ee97dca137e499b43da9f73f9e0431e40a36bc4732ae362cb715e82c4cd65be91efc8d771664cba8dbe864e2bb9065f431bfae9a0c6728ace71d71786adea5d87738feff6ccad412740c615446998ac2dec9ba6d4d3cb7e0e9f6a0bb6be6bbfffeddb3841eb8e3029b9fa698856d8c59c7bcb9395181985446cf61b7836b128274a61c278a41b96726ca97a904b88516107f754ff8dda9bd9c9a70904b604e5087847df7dea4e801bf819e8edb6777148f2bb44a15c9a6d374e45d7bd8e38e7c33eb82e3d2aa723a55caed3405e94df396085fc417761c036d8ce9bf95676fe7af48757d133d4e9811aa2834c97b686154837d14d4d98f6f98cf867b630eda2d694cafa7b78716297317a190e3034998271cf223c1185e6cec539680f430f06c60ddbb817d81ceb7d41cb3e0d3c7e783c378114e3db3b351c0176196f3e36d4b9bc2843727c1611f1e6788170afef9c8d3bfecb3079a1f6c14ce322810b717843e50c0abe4d4d4489a4cbe1b00075bb29dcb37278e67412181c8b8d1d0660dcd6919b0b186d2964b1385dd0fa3a616a481db550da1d39ccd72fa04f4ad4d7323cfa0423ce2813e2a3e97260a3ccc19a014327e9dfcc60abfd261e438c68a52cba885fb516f46cc7dd91f170caa79a185186dbf78f917933f8acead2db3b7464807ea61d715c67e7c1a92caf299a485075f0de6fb14f3202ef7f29f51f85c24f4901f59c7ab2747aeb8658c2f2c2ed5b459a133d1fb48595b5f2dc3d7794d26effdf6f830e9008efb2f3976d21fc65e1eff5a5f4a02cb73d4acfe9e6ea30fcc43a454dad6c02601ba138de8c398b6fd44adb66661f8e0938b6ae8346f990e157c7acdefad48f6013ac251e74c51c223866ca8b680d0ff1d0e5bed6762811768fb6e7ad2956fbbdb8c24ce8794ecba272432ed2322085f567757f57aad227f940a356ba15e658b40ad192f39ba7f337a0ccfc2c90b84dd732dca4a229812641c9911c96b7727fb7ce223f32c7106279318b1057638b89e97ccd468993bba25cdc68f2db8ec542eba5691dfc81d25d0d758a5ffd69b285cdcbf5d84441666758849ea504253d5afd4a4c3cc5e7b287fb9b9b8aa12b43fc88d0bbba2d13643df295e9368f6006a64b2488cb9abb95d5fe66552f1a877b0cccbef64ff046064af4b6dc4c894844166a61d526aeaa1c80a02968752ac319a77be060424c6c9b4d764e87b470b2f727597b4b8c47c406588ecf85ddbfaff146844f61e12d7e0bccedb63c58afeddf3fdfad89dd75a9c8a9b882b48d2c9d9310ecedd4b7e3de97ccc41ee382679c51b9b9a6c37e3d697a657c6a811ceb568f9770839d9a97a2213491f53502f83d5603ad68646b629355a1dff3ab704848048697821e7606ef5602719c3a60b96228a1de8fb76b3c85903364427a6b7be5e8e310580984b9ea3d68e00f32c105d29fad88eded24bca182dfca97e900b72ad1df427fd366dc96e23499c15d5df6fb4b68bf9696068379629db699d6ee555e2f745ebb84d24995df9236504365d60b6296eac17e02e3416b8f17b5832ce2a42168c283417d374572f1c659a0e498a8898e1c2f24c5778dfcaa7051942812eec169e9cd347fced5866086b6c5aac8854f0c9d1d518ec4e6a30612d6596f6439e0c4cb6cfe63f7d920d761a75799fc3bb9016166e41b0264fbfe00df6f1d2998587cbd4d0da90c4519d5f484c6284259385c5ad5c156316bfe0b36aa639508d551009e576864521497b613f5457c9b3a00257e4e5380e803778345c99cfc7ffdf00e2bacb2c8ac9360027c5604460ad5e32052b2ebfddab885a2918c204ccb0d24e61dbdd635b2094a2cc9e710b3f8ec93eb759e28d02554ff2fc5735806723ccae793dc5e9408675a33977cdb324f0d1d3657c982108095495470c1be37a85f332ff00cbd1fa9f8ee743b1d705ef252999b42f27639bbf842821279aeff1ca72f8a57d52d1e650a5e24000ddee0b46d95eff0683f2344c0e66710d5286a43fc257c2fa96cdb63ce395ffbb5aa7dd5e9b38e31b9a51a5124d34c4927c90ffacde964a88e9e874cc9329f4ce16c1006fd3f61f21d614d4b0934b2002ef67f0c860c8379465e99246b4ec1a41c3a02391365833e20b843a7ad1d213801d22a6f3939f42f1104e1dc96bab01884a317ad4b854e9e9de6c61967ac9b3fcdf097e6bec47780145c23334f4dff2750548b0598b5332092a593c4974a2c74a6185c50c917cce76654fb9d8d2d133a3da9be64e797298e7316813a7241e8bbffb08827168437cae450331a40863d156716ccc410860200946e424640313a1a0c4768c6c638c645c1df8efaa5651bf02f7d3deb5be7fcc737e29d3ce638fabed2f52e03853a48da7905023f5ede86b124e7a3c4b1bc8e7ed87eac5216af7aaf901cad88a72259027575e2805eeeba725a490a1cfac7c0adee7a6e345ac02717f97c68fddde029862ce5b3dd6b94873b4945b8052f24b1351c085ddf95a65fbe282e0a17aeb6f079a0b108fdec532a744d8afd388230a1b9b5b70da164a140e6617a846e6d0fa245121118a73b3eb78206bdd3eff35919075a288a355dbd074faf440bdf10243ed8f1bf7de1e6c5dcd2518167168735f19b20b45b2d3596581dbd95df1553dacca26d2fd94ede9d987187e61b35038eac9b58ebb9d6d1e868f6bbc8ca04346725a3f311599b0e3150f1f654a479f8a152c61e76ca0d2bfe7115c8f9fd5e695d2f56b7edee10fbf72e8b6f42236feb876dd3cf9c3fcdfffc390bfac21fde273a6612f5418ba859cfdb0c5c3b07a65c66b5b983ac5be4a5a3db3fe504b1fd95d6e021a8da252a7142c02ba76126eab4a98fe9c24848993172e37e0ebc2b1669b8c6aa5c3299d9b26da22943a89b2cd4bd38846f57ec55f048bb5f1dc94c19df4e89efab147140a867d8982abecbf7463fe041859844b068d6fdc2b0bd931bccb1c37e02b2da3dba443cae29a5638ccc6a78c7d20cba33a718b0c6d52ea3053fe7d73fb6575ffeb6ea9fe44399a5ddddd82dd7bf005ad88bc75746fa762c7e647b61fba0dc97619d6532cf8a271b96d08b5b2f369e344ffe65b445e88fb3834e1f8e56623457ad9a2af40558fe2e5f47c09e4f878847df327267fe995e03ed682ebdcbe83e514242c42a35e280b07ea1afcc95b587e03dd58462e24da9446b037e2e0cd70cd08a97bd33cbbeadce7abd5bdb61e0837ddb98ee94188767da8486766b9c7cb3120a7dee4c53d818377e1b3ef3f060cc1900f4576748a70d641a2ba5e81beb854bad97ee65e1174f82cdbc8375583cae5e01c0f3953cb8030836ac97fa4c6d3158cddfd247794d1890092ac2772d1833f250b3163c0e3fafd2efb6096b90b6de71ce4b226353193d2881bd0c2b53149ae29e753c10d04146253a780de121c3c345fa71ff1a6856c0ba20f97f2375552e5150694b7139f3545d1e2e12ec3bd3393e4043319cd66ea7a8b806faf44cd48c5b0180f570027b94e05fb6841b58d6a36404478ea009fde7f9a2d5276184c848433c4341e0b6587e57f6424042107f5f6e7f84122d64be17a20cad72997bae194ac3ba9ba914b518fff9478ec2cc7bd2f4edffdb5ea801c8926203989692f22c3f93c1fc4e2650b4f889d1e6bec066aa86b6495c36e12188a5a69408d408ad16fdd353dc2fc55f83be57bcb0000292b300f6eb5145e6e21301f83313a34bcd9d133941a6f3155d209982015e8bc29f223de6db9b7e9acb68e13babe4e9c60fd3e7ffc07ba7140b27645e5c613e3e6e2c7faf503442dd57d336cd62900755677b30d1eafc424297e6d93c0efd4400afe15ea11db568f1f5486ca6b534e1c2535b71cc8a58f223f9b8d160672ef4593de4a0e858598993fd6e715ff0bdd9920653388786d9b806ff497470dd0961fcd549a9a5e0f4bba1f085df3aaeb322661765c16ac17303a1106cf79a871d7471b004e281502f9a80505326b7717050b9d9f96bb6bdaaa70ade26c3cb05fddb736e1a5df90f025870a7069b258957f4289e89025b9dd79836d803459f199536e497a77083a3e7c30988f3f244de4250f81f25e98043b6b3688764aedafcd3329641ac90de6f1bbd359484b422df74f71ccff4d52b6991190a756bb13763a31c82e80c07e68a8fe532ffc4c333cf3e2400fa6d791e71e3edff17121d6f07ec119265f3b5981189460d808bc115b27eb7fb2168531a7f9018088fca17d1e340a0be8e55473cf0b7dd1172bb0c4872b55f6143c2e293f387eabbb7c761a74982a37792b667d9c0fb1872b405c5fc36d4671049136dc02a851b036d661666409f9436d24e4e599ea8066581d14b859931c476e339a2ad2a9272b922abd3f4042f62df72980356a612fabefede328fbc7d1fdd3fa1283f4f289a635d8947b5c051382fd127053ef919053c82c7191ea44b9510640fb2808f0d77de8aa661648eb926377b43e1856889a79c4789e1a5ef973d61bbb654c4b9dde1c02836e1f82d1894f64adf241799413dfd2e9811fdd92304057b0c6d757ad452ec56e91cd0e6c6dddb0f0215649abc3f7c6be3f0fb83257829a824ddc2d27c2370b171127fe0e776dd0969cfab6dd3a45865c1e7f31c0b9942d4da25ac0b14da7a6012b2b1a935be0ec769c4f6a3103cb7472860c543606dbb0fde88b3a39ebb64b58e1ac10a275003400337e4ccb5c5fd1aab8126794f46850a697b03815037e6fe4704dbaa12c18eacd8a627b3e4d2501a8ef9c4ab8ec80c7fc28fc16bd8466fc4952d38f09a4679ad74e992e0d1f1b7893d3b7ac0e85e10a30fe9318ce5dd85f066d6e5e944f8fdbc00b646f43d3fe5cd681b25d295ebdc22c47fd1859d31ec7ee0e365361f7a01a530514299bd973c89e1ef2a08a827cbe976339f6193603180f819a2a78aaddaf65137020c230e02cdae122817b0a977806d936b0fb17f0ce91ad270548054394e44a2cf932863fe0a27faea7fb0507577817551d893f850876ca9e0068fbc49e0943208d1d122049cd08965e4d741a439372717a471d43ba942beca99872f7d967fade6a7d8912bba742b3d83a3b438f40d490a217dfe2eb2741f858bb4d1bde1aab1e3f16ec712e815bc7df7b8635734a066b0836868b7baedfb25997726e4c21db322b49bfae18785fb39d308ab9b1452fa80f00e96581b5c5c8db79405b879f0c1f93ec0043fef628d3b0d5020814c88e2a95d863c6f9e14ed8e2ddd3979da6e677e58c7808625365ff05e9f17a48cea07fb00200cc8f454bdef966a6302efaa059c9a124b23fc78424075348e38d7775c86191ef0a6d84826d4ffe4621136c20ebd03782645afd20926a5468042f145465f4e2932f5592ca5c8e795517ddb5fff03b6b30c6dba255d10523d10b087885b8ce5d52ccb90c82e111565b1e77f2d92a3836eb7ba1cc4122d5064fa2baa5aa9e42b1c5f368605ceabe2c10c29c994ab52cb9b07b557799c471e3311a98a01905d010e8aee8849294569003f91e9c8c74f5104d236bfc27055b99559a599e2a8bdd8a34d13bb4e72d01ed45d8269ff7a6e446b9b9048cd647b5f281d6e4cb1d2a919f811089c6fccff794e858817e0930ecafbd43141ef1ce2162cf8d71015ddd9f636deb73740e2777848ca7a5edcb42fe44e0c2a4f75fce9b9604a2274573661aea5c2d8304b3031a80a97ba8338f39f90dff3a86c5aaa3b97b45ff357ca692f3ffe206926d07033f821b73f45bd5238b945c68bddfa4e5d4c99b94dab48d51d968b41d4e52a712cc521969c2a9c3c7a3ea3b8bb1aa64b26f2206ea83d53ffbde5d528a8e3afa41b1e29fddde04a36d0c658492923de2b74743610733cbc69a0d00891b5bb7df675b5d2724023d333a4db800bb3db737b96c600ef52cf4d8e56e2722b8264e5244b19e4afac77f7ae31ff2215b82476aa2bee2a00e7ccc22bb093e572d3c2adb3fbd048a8b4a294bf56588d0c9dc8c8614d3650214bf73cbeb314e7adba2976809aabf19bfc56b6d2bb6bca80a39ececf8f5ce8f0059fd418543accd8c6ac85c3f1fd6be1a5ddaf242e9ba4229342017897ac9ab820cb52f3d02583a8edc21ddafb6873e7c6e27932bbdee731349c728ab52381fe9f837f2d520cf4b934a669993b53f149852273bee79e81d9b2ab3dae962123d0f9b5f489dea9567cf65c5f34cf242df500b21fea0dcc8dad0db824098fb0cd96ccf0507332f9c68f4632e93c60f46e4f2d79ca50a23ccf1023f62f31e222fec668cb71dbf1c6f72a28cafc00a1296bc810993f096c7a38abd85f631470178144f027895c3b039193423373c79dff36efc43b3750ee40c8aad59eadd3372d51d5a6bce9476675a040a1fc9a21b6c1c64a6e71498e947faf8c889d6baeb493b1ef7909ba87935828ed7e741697a0cd601c5925f00c1de75b8697e209ef59e04277988a0dcbb5c42bd862b84becd41ae434a1398fcedef621067ee3a7319721338b17f9e78bb84ccab3b5c419a302cf37cbc43a482f1cf288c8ae9967ba020e376902890a05a2554ed41d458433fecbd5a5acc5d0a9f1021754f724bbffaa81db11df6a9cdbf60b306d3d8093aff34f5c1361959666b0ca8078c5d519d561a1275bb9f63e4847a1a49e0723b1127256726f42babe0f557cef26e3b97b91b0ab3fe1b23b9c676f56f15a10e16e528ab9fd4b43ba236965507a74cf0d464a65fee3b579ae3ae55d3f42ceea1f385f9edfc1f09239ba95d6f8e150d4fc1c8c2c10a161a56260c03032075845c072a8be550b7636d577e3344644e38af9540f5ca12cb1017db7bf4a532f781edda5145cbd0119c748b5ff88674c5365760af0a15156014539521d9da43a4c5037cb25097f283aa70cb592e212c4a4be8fd15139ee192c269427ae0cde1c5a5ddbc35591169557a5a42ea65aada47cdf6580d9d20ae651f1190cc1bfe67e20f1d1c7665ad18dcde09fd9ba07cc033ee3f4f18d9c6a14e6dcf8536a644f4bb021fbb9150603d0937e9116b53366b80ed374ced725a2b7a8d946b584d024b9dce488eb3fb7570e4a082074e19530199abd130ba6446e94bc396b9f29ad9e0a9c035a739313f17ecce5f27a5c8c4d52bec778829411ad2b3756265724911cdd7eb847791fcee7851fe30fab977aedc281330fbbf0b1d219f56cdd27c00d4572aab8923c90d75ae82c504ce4880bdfa7c0fbcd4511161ae045f54aa7a223224a73ef65e3197b9f4991fc4eb4e7b67ec1f63303ec85c0b60d63fe5e8bbba19b46e5e056eb244a07e75ff88effc7db292bfa2a6ecb0b9edad999bd9e997323030ab1b22c897fae1aa9ed2cf1f34fe6d15cf2fc1e82af930add0afa685976625f7ea79f783901d77210dad874745332ce844fc392acf10d6aaf67c431c4ae2a7e2bd965d0f4fb3d7d9b6f4d0b470f012e0a63ffb50fb762956ec130ba14e99c53609d1dcf1dbc6d53b48c2cc1feff2618e8c736438f948cb8303524282464ac86485129f291150b670999fa25488964ab3014a806a8c3b07df8ecf884424c24a998a185ee507290fbe7ee709b0790b01f409942c062ce70b01b012d44ce69cbc45e25dac7ed8af0605b798a082cbf157f8e232557fdd39238e119e8f652dfc37597d09a872a88d81aec30120bf0619677afa5696d52d5c3851b77d673fe8a5988c91a4cd0b69e6111a2c35619c31b3942306d5b26174de3a67012533eb598b9e3e016d3ef4e6b07f06d59ac2238c48ed94821fac52b98d25425c7ea3f1aa65457208470956d36ff20888fa04c455c66f460270c7f1d15c4cd434437f9580c6ee7b2eadf8a8623dc2a6f1ca339d3eae67b6f4a7d4483cf2f8e26335d3c33972796d3359a08c82a9991f0fc1413a71e7f64d50a0a6971b28d18f7b686cf23134ac699a80dec374f7dd6e6e13bfb139f887bc7c6a1129065ef11bacdbeb643d6aca908b77cba8c26ea6fbd9f79beb760198651b6250b375e5e9bd63ead7a9000718b0b115a900f8443ea3db02c20e178877bd1149e9d06b55dc5c447abf11fdcc1e5a6c1ea65d7f3c5e01f29f7ffe3b4f13beddcdb0b88940b4686e6d5d46a79a4c4c81fc25cb8e0c50581d347f2655ada81e062cb8d20974ddefdb7fd3b666cb622b812feab9ea32ffbce89d6d7a7379ab3d7cae967cc56bc79951e99d2f9faf1e2029dc30e0163921c837b93ff902a2d264ae4db23607efd390486ffc0ed2c20c873a8ffebfbe3e84293fc424c8267f4af00b405ac58f3a1b6f7bb768f7f8100f39bf9c8dd68196e4dbf043a0ad581eb7f2a98ea3be74f208ac15efa7453af3c304e54e625c6f548f2268a6a38f6777dedd628efc4f70eeead397166bcd47134847016cc55538bf73cd59fcbe831832132e42b7b40d4d08793605c184fcfdb9ab8bf66e71a585a044867d569cbf8b101afdffe11dda98e09704685413e4711b7d67985ddea1cc41fa121a2e96f651c8fcb6e057130c727664f903e88b1bcd7d1e245ed802d1fbb0131f7cfbc40b8608f60e922ae031909116628a2027cff8858ed4ded5214e5f04139d3d8f69fee517696a8def053ac67e19e8e14ecf905f29dedc12ce65abb54548d1f9213dc3eb67c66e0e472687e98aa2e279ea100e994c94d4d47da16b53e2889b71ae0be6a77da68c789bb12c245c982cf2c39a51e2166a3885583093a08fb52243ab59e1bf6bbf5e2eb0128a79a1da98fd83aac380463c985ac8eeae58e8fdd13fc66496671e3c495be780249f3945021565b1373e8ec6daeb8ec2f4b70eec19a6a315e377c3bcd77ed82655cfcd462e3f676488a46739020ca7fe054f6c5098eafe884407c4d4ecb1cd0312e2a32a288bea963638be3c7868546a5462f8185c6a6212677d220ad1f9cd52f5571d9b91033331c113992cf6d346edaf1000b4ec2a2ca03b3a69db2b0f1f1b27aad6f532cb9a0fc3aad69020fc32c79e09e945b5369f1d62bdf396beb5f018dee05c6696179e52f1a5097b32514459384a0bcf3385edf072b5c643fb3e9874b38b7cccf3ddf51f98b263a8c1bd3920312215cbdf937ca57a93a97e8a12b4aa525672f4f7833b8cd71f2f64a17c19ee7e90753235f8df497516f89f7c7757dc7b57cda3cd7db4055225a67218ea9b72048ab4be84d349d36ea75b7b4588431ff0490cffcc3fbebda8c341593f6babbdad8d3d2e57dc72c1d69546e87d33bbcc2b9554f30ecae7eee59d0fd667b2ba58531068a05255f8bee155369cd91701a871aea4e822239a8ea6800eb07481371188a6fc3aaa8a28abaa61d8296aaf1f03fa5d33877b5a9e2c5c2135595cf254e9be638c94a88d19f8348a018ffb46681d1267f903b7e97a520c5886c92131f8757177a149f8a7b4bc599bd020d6bc5242662556e08e310495aa205a705d13bec5b054cdefe9cac4b934bc14125ee13eea1f9bdfdb98b0e49e707a1cfca5b916a2a0fd8ebccd523745d42eefb1bc30654f1285036a02ef6367680340e43b656e1e76d05c1c1af2e6b42cd9102883127e75516e7aa31bd9a9adff6d28a8985504a3585b24128a456d17226f8b329d48626bcedde30ee809ff376f96e766d20bb40544cce59921f785b84a73a7e938f6675a0871cab16d1de272bf2ed9822953f88231c4505040eb585773321207ec446cbd7a0bea3ae46189f2781ba3493f960d02482f0ab964fa5d342492f500c2e9deb3959748a944436c093a9b29e1e4b5bb629f867209dc00eccdc81a244b9f4b9213a6c1951eaf79ea56d1f07b2efe5b07ab876d7ec1f5ddcbff2f1eb57c15183dd03b0c57dc710500258b99f78b04314a962c050bc94e1e2ac55cb10b1e9b1ddc56f99d403f105237bda71c565f24083912a34055c1b3c7bffd68b812dc9154ac1f25d923e04f50e38b1ba749d6f6d6d7c04f0de615a78b30b015053ff2e6d98d951f21c59402c2daf17923ac80c94cdacd9c73d44326d77d1f80ca73c4d77f45f7f035572d394ba3a53c6eca83a5919c256bd0589d1e66113b191a1f54b9790ceedafa5f1533bbb13e5a39e879d5b76249c8de1436b225766d69c6905602429635430169d7956c19ea8be2539cb16135f0910f241777ea64e3926860049c660ce8410e0d3587832e8f97d8f9c260fe1fc6c15c5006d07291e460a0f4cae871d4bf8a08fea1e7e1a51c7f895cde9f7b0ce61eac12ef96f630584818837b2bdfc565cc65819ea626fe16b516048159ad2c3d96d59e82f224bcb3a82c51d4e45144cffd8d8ece2b816d3ee64a879baa9f83bf72ab8c73784a54f5956a1b6ca2cded31ceaa1459951343acf70794ad6f1b05a5ad07e572e831480b5555dd6e214d8b4e36a9c1b62d19c99c3789612fb88580a70fdae10ef1c055307d950ea8824dcc1fa3be73fb7b531b4d17bcc0fb2741f1e5655661209273ec8c38f344f99842a62bb19f297229422aa4a7b9f246ba63443c58b06312ba6cc93276819412fc8197d5545cb749cf4ef1b25d75b6c2bbc9ff2eb3527fcf0a419ad5730d08ad4d01421e2063c8f6455bae6b37e9c399847a3c32c1b084c45344af38d1957160a5314c89f20e003eaa0c6d22cd4347758bcf028d0f1cc2d81d0ffa04dc46c56e8b51df40614b59ed486ec6020765839f263350ce7037b9d409a6300da28149140207266c3eb1607a0cc83212921e5efcb266f4d20c18f31e4224799486b5cbc3f0ad9f24d0bb82438485e6e8831412417b602154908d5de747f2ba8066fbdc91bec67aa6249b8cb82b156d4fac7fe0dca48444558ab0681b83d79474ee3333bb7581bb5df5a58ba54300f046f36aa6decef2aa2da1ed3b93f55cfeae1bd279dd31c3f285defb45fa3e129394257b4648a5472099d49d006dee576a201018e5c47b849150f1f3cbbcce8385261c72876d6a39266814356239f594ebd6a78eb234a93212040ed4158b565ca1ade91e9d3fb1ce41e7e66d9c51b52d94849c934bd6b829308b27b2325cec31362b47fb8e4157ce44db292e07e289ed4f75f50559b42793ff2357c657683cb164264ca55897186379ba1863a6dc722222eb861d67ae2766acda8d93f307d867462ad5291284f19dbca2c51ddef44136cbe7862a21e4936bb22aa5bbf6c46b2946f7a9696bca2b8a7cb3aa35ccdbb244730c2007ebfab113bcdef887dae2b70c86a4969e0308e6afafebea46d2b569b222ac0db8df515b3c1dc321494ee663a2b55e80cf6de956fde638416d621ed903cd2dd433a471ca3b4ce8bdc6818ad2f8082b34a8f7e504bf1f4d081e3e90c69f0c67a871bf09b11864b9528bfcaaf89212d5ded5c2279867c04843cb2f96fa81ddf51c1a12cf1be03adfa25987a51f19933d1fef73484a70343139c835e084ecabc0a536820ca32cc824e886cba9f3fb55341de497a0a6315a847d2092313e43a9dd113b494dc64d17dbedaf1feac1e6af0ad71f16363b5520a2f69ca940c3c8b5428adc243a101cf20e2f2c48f26f1c31ff497804a129f46f644bb9152eb74f8ae68103e2fb67122ed65807067f68858c8017ae75c41613cf19af70df55400046c1cd2a12cd2d198879875a6aa8f4b58a311f80773737a7dd13fc5f84974ba1ea6259dc1310f79100f9e898f08e4b1e38c5557c3534c3a5fe28110de4e2f008a8f5068d5516e9acbf0ec95d8de6bca5e62ad638c41f803511c2b894af69b943483d85c7097e2b8a06ca7cc92bf264defe7dfefbb4edbedb4161519dda460947db35545c4f9ae2ff0941597efec3948caae674551e15762e65e4175c7c90e2b178c0ed721397d56367ed961b770bdb2195b68f826d69d032139d9ca46e6823c15bad9bad6793d663d562447b9c4dc88cd597413a11274981c74085ac34a21f895c6670f86f449fa56c97876c56b1025cb9e95c12d28ca43c0dc1050d59ef3f6f454e6dcb9af620ca4284da58cb775defc8221a8dc73b2f4d29ad3d51f449206f3fbfc02535670df0ea7ebd5987fafab44ce42faf65f30d7424c8e749279a2db11bebc3b0af9668b0dd113ab6c1beb3cf5785036c60f404c09c960c81cf2c30e49582a71fefa06cacc01b917890e8ac1c9fac844181713786d59f4d5443c257690bbcf689d18582552f6cc14731a15926a5540dc4fcd3055de55b8f89cbf81f72e15f344d3768f8f140e1ece39cf8fb58d961a89980fa90192165c65d04891b68fbce943b057fe2caf3feb54fffcfd4849d3d31d1eced74999ed46ac818ced4ebee314b8cef0fb0b8c45ccc5ff53c88e06e3f55324ad89b1ed04435a535c92499c70b17a8633bf3cfc5c0cf959087d80d0026edcff91ad24f4d022f856e4a558db993e77af649ef09aaffc18711eb7bb4f547cfab1c7728133d571cde2b1a9367fdc4577e071002e2d0e6d7f0292c1f1f89e871f9e7f141b00afdc0d57cbbfbc7eba60cbe0c8ed94a86757ddc5f26ffae6214b6917c3b8d06348d2b333319167ff9f9f0215b85340016610992c5a194c769da20c6562ece0d6ab1b53b6afa3c9365cb4cc0c8be013d3df12eda5bd9791cf5a08a51fd73adcf018b69408945f28d8dbc4767168dccd6146faa26982819d26291d2b7fc3fc67b392b95ad3a5e29d5b7531adb698bae7070eb090d3981a0b78973de9d58392a84d734d8df0c45324603e02105aea16b8dc45787fb69df23306a9fb707a5f01b893e1cee2c2cdfe99d9548df76ea274a3d407a51c9fabcd3bdd1a6945237f1ea6706e5bfbac80931c437a0bfc18492629e0d6e606673b9a90f8162c05743c6dd85646640fb0d5c23c287b84a9a005b117de6b2bb9205dfefd56bb39aa7a08192b92b76b36c2eeabe5f60bd690bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
