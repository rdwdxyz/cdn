<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8163f02732010241239a17d49249aa666be8f9de8e4c23062b6a1107e9494d505f7f105e671c429aac7bedf23bf8c89816ac992fad097270131727adb5d31a064ff73ff4ad939e633c4f6b9972ec8d2aed86f220a09f2da32c8c215f3711f32907d43ba93eab5ebaf035d5fd68560bcc37442c8de95cef518e3ea7aa6e97d945de4ea2097ec8193264e754ecf633b6a980a057c3958d9f32e58ea2c0c454eef76a383377e0eb4d304b2051bec1c4c41dc06499b5aa80bf973a21bc43d67fa059a9ab092d20eadd8b2615e3acd978669d26a76291ec8de92973fcfb4ca3cf47d37af59a072ec428dab1733c171e0f045e10ef2c21ee1b293ed33ff2826cdb710d24bde1284163c98b65e56d61f0c621809c98b29ccbb939d754d11e4f066db078be275526d42fa277d7eee30ce5a4b960452d2d65158df5007fe7ef801f248f9c8bcf0152f736d6ceba04fbcfd030587ebd23c1938c39c2eb279164f43670378811e97553c6b28057e907b6acc5a762a765d18d11fbccb732f4797d9f4a7cd32885f84da1eb708a23b5d45addc4deefdf5ad40ae3e5dfccf87c4fa0c1364eb1e173173b3b85ec17e36e33c82f5c16d835a308a70d8a392a1dbc3527a3b637863afc1656698838377983d79aa0dc5b761974ac70cb135c452ad369aee51a8b3e72573fa6e5b03723d3d6af14a29282a7fbfc7b00be74615edcf6fb32b0e7d29a0f1c5759ef23af2e5c3999e55fd45eabf49eaeb4ae16e8951529af13092e7a09904f177e29a68c3dea5d6f1bb5f53658c9a66d1df126133429a0dc9d91ac5d901d3cd91c0f9eea4c9ca4734c302d95f28d6bc98dfddf0025881ba109499e5f0a81b05c849d9441527569248d848b6bac816b31bfb00754d4ca9763e896843326712504c56a6c6424eac1510375cd0f33dd7dd894cca40b7b8d4ff6f652b6d43134d9707d62160dcb5808726b2424789791e4dcb138708bec8c9758eea642e15414e106c34981e0aeb48549bbe0b5e0c5196b8e3d62c2967768ea2e2d4fa0d2fc79fd1e4345f7aaf8e4e2b8530d8337293d97f75b3c0c782dd5645cf8fd8f557288b6fbb3d82b54a5ed829365d113d55d865425987ed967c9b20c69162f99f9b00392e004cfaf0d94754be6131b0a6b5e17c9ead26f3c0dc2941cfabeee1b85f2dab2e8668eff292b88dd8c85750535fd71bd826d0886c4fc938e4593cb64b5fe4f8a00022f5c5a89f29d02460b73b2a531759116faa0bccad8217010e3cbc6bbee75697f234447a5b0230cf7ce21a582d723becfed9dfe99c2a48655852f1b55dc8724f68b8eaf1399f722fb5d8999a1bcb4c92484189c359a00437c1e7636dfd795ad431f55195d360c961818eed39be6b531146d167534ed8a8cb1f451f5f9fba4ae9dce33648963253006365bdc7938c7de2303032c067558a170e60648986c1a95c93858b1aeaeaab82ef6a8582549a010ddf596fdc3a7a8fe0a3171cfacc898531be962b61f7504767ffb257061ac66abb7a2bbaedc7094ac9b29e3fb1c6cfc2cbc50a1137bba5799701f3bc38851f21e086a42b5b6d4f189eddb92fe84ad71bf125fbd30818ada273c11d93a11a063f76de673d223e4ee0b68f6e9ff22ef5801ed1c3a48862c9717b2fb487f7f1829a103cc5febe2bd434a45cab53cbcb3eedce7a79e85f79c2740cb86ea956f71c2021d3e890089f67b253d6e278b6effa7075df00a3500e59f5acb10036a684ec8f72b84366b1d0dede65462d4bec566049d29d2f2b269834cd60a93f9fe44ed0fb6a13d40d5eee3b2fa3515b5e60d0d0b716cdf3df6fc0b8c0b18aec052f6199a7bbc9a5716e4dfe0066f99e6c88f8c8ae2f7610849c9680e686f6a3ba59996b33aec6dec369f5cf477940846b736aec796f7cc378413b55b9caa565ae159ff441250edabc98b00da12516e81945c42d3cbc20b383f00aed6473fc14708a30b31c8f067720383a4726b0e1d3793e368f33eeba32e82c41dc58ecbba71bf8ea08a5c2f814334690fbaaf3fcf166efcc20c1a6b7a50e533cf81c3e30e23b487b8267eaf652c1acea59234a3bdeaac7a83aee157b746bc217e6d6886778bf33323e284f43c997e0317a0f8373e448020088ee2447acc72c7d651bd0ebbd6a26e05cc7a680cfe1e46c124edac7bf646112b81cd47d4dab864521c3c7bd8a882737a1f4c0d5b0a9ac4d93d92a06d06b366d918310564b1d3f299b93f24f044bf60f48f12eb56739425ef4156184320fbfa7e54968a144514e4e9284b3427b7d13a36458b338b36780918fb70b2c7597b2473b3e4dac91757782bbeb163e62d22e7dc1326393cd8f146fa926a3e3ff602a5325ddf5524c5703781aa460eaa3f67041e6c8d50d55d478e88611909f43b8525c3dbb65a7cdd5ff48fea44df6e714ca4799dffdc9846104235ed2af1976309e926f1ad03c5c271ae349d72ddffc1cbcb063728d083b0150077f38cc773c8dfed1d851cfabdef2024cb986c35a00431d89fea3c41dc4b4568065f48c4c2632ae8576b17394181a4ea92e030c60eace502b4d4b4f26c05298d91d88fb4b4372ddb54029a8ed8bb7cd011f4ea7598b76c5de1923fa989fd10a24446c8b88d7e566ea81c9233eead6bed2ee48ae91e820fbf71d6c8dcb2eaf721da625c3311c0fa9a9ba7a1f270f1ed72640cd53c419783048cd37f6853884d16285131bbd9460661ceeea336673b156d7f81be237b3179ddaf660b5ae3d1cfe413db5d41fc76ae499e7db0743aef7bd75f1e4390789f0e8c6c226bac794c2f678c2e276df2385ad45620664d37a79eda394512498c35e5208bec80819a3b548bd6cf757c7d35e5be1fa9398272e672f01d6d093a2e35d46df1666759410cb8dd7c0ca3c39ec41507e735776c11c751c895309b8c0eedeeebc598868bdc4546af51052845db66ebd7b3326eb9965b91f13e831fd99633817f629ec768cb40e252c1f2c9d961328ac945b183685aac938d46c405bf2484dbfdb3d4ca044abf83183a9db8c5e1a13fe1be024d60b333675b147489d1ec2e880515268a60903b919764ee594c1cae418e4a1536236b231093dacd97f63093c195ce5f1f6e795599e8842be1242ba335000bd1cb482edcce52e212f0c16b9850a1ab0ee10e2f0362c60a5c9b4d90a1fa9047ebff525323c9774933ac5809b2f0a4750dc72393097f5a6710ed3946fa032a1f86a54aa5d0dc9104cd80dbbbca1968d3f8d9de6b34c9bc56f2e1319b094be52011c085e738827a7284eb92b74abed3aac3f74c39f3e0b7dd0f5d0842c86ff61d05ded2c321309ff4eb4c35554ecf9854bab4dbf1917174aa728a5324b0366e3efcb6d13f7072547f1f7d6aaedd7afb3f42039cdc1bd6e6181d7a81c1cb85318b12ea77da497e05802963a8030e50c10157ae1d3f87d2ef97965849604afd987afa05315be5e64f8e7555fd79c470aed4fef4debd6b113790941cb176a372f176f1575115ca1aac5d4e7b303c2cae6298adde637fd63edba4a15705d8575e3870e5e77ec856a6b9817b588ef5d2322dc1bacf7ef1cf2d1c30c4dbe2e4741fe9ec3e4aaaad53b56b2c5264c1e2d547febf57e33f51081a2e84c690179dff6729121abc51fbeda15bc692df62c02544655f59ffaf9e858d76c317174dcc52ef4e47bba407fc34662bcaa284e5a2434c165f86da11c84cce1a858c72a0d8227a61cef45dd33ac508d30ebd366538c5ab4d9a58b90057de19fd5eafe8f7751e26fd958a95da41b408b9d5834998e891ca1e15a55f8446a055ade05a8289a2def90d63211600a840a826fc76bf9d1be33e4db269afea3615a6cb3950678100571b54c1f7df59552681c131deb84f7128ea251992d53bc3c63f8cdc5289f43b8ae115f007343b1014eb3d42e2490adefa1e174cff56b7af5423a9f422862764b38479c583b45d97504fd28e5d4e032e9df8cc51bc9d4f53902110ad96985c0f7418e4a33b58c486517d189ed6fbf7d2423ac11233b1ada574c0562dca6afa93b295a4c28fddac50b6926b2019a4875a401727b6b7affc4fe212910eebaee8aadc50ce97b2454e7a8fe362b3f9c1b0ead025e5871ce75eccc66bfabaa11c31b3cba7416c4a7d7f78cc251d0f4c87d699b3baaa974fd41dd9817bd5f2dd7db51254df1947204b1129f28339e36370ddf68cf151c9a50d3b9a9467ab54e4ea916de33146556a9d87bcff3a2a61da4b3f49329aa87932f7fa6b66a6894113b7df43ad00e62bdc00560a4e096883741630cc9189ac03c8a203f094af22690e1df962289e3a8e1bf0104c167adfec98b240d07c391dc8aac64499b3c22a234bf9aa08f4d34ef5afac6a6bd091c9b0be80307ccf4cb149c29bc086791e21fe691e59a4d64d55148d035e8be581add7efcd64f18da94836d3c3dff5c79e282ee2b35ca91f0072e84eab309e3fc68e085c20934d30d852c1ab2b69004bf6ba3cf60989c5b8615313b5c2eb6878dc60994d95e922a9ef243c623931185515ab8c6c76501bba6b7b2e2635e3e5b5c0c948671ef6804da6078f3e46ce567e8e53f3f46282f756245497bad0be25997b00cda43a93be96f97da286a503de04ea2d96682441d3788ee31cc6c218be5acf065e6a2f3f64cbb01d4086d17e15b39137b9d3407b62ffaf641943c742c53c5e2f1fbd001ab467083306d721ea2d3cde9e24ca57c6e5b6b645c9e5ba7ecc8a551827a3e1f0cee3c21870023452919f51b36a2e40f2a13eda3b2a3aae64fbc24f534fe69db7acf3746e5dfd3a869ced039528cd3fde8e677775c94e8f7f1ff1bd2af5e351ff8ea1084fbfff97e45d69cee6632cac55fa9aa166aaabfa0c9f30b1d6694a61c913cbe2c2c89e65b1f9ab8b3fe75fa5e814bc5e4108935f71bd76b45365dc8aa745916512a260f8e38093177b6a7e216e9c1e7e41562c217e3d7373c6b693fea4ab19458d4cb886f05e97a74c257f1f9da63f089df5ea710413f8ce16f6692739122ee3080e6754f5258c9577c969538aef5a4d9631c4b338a97412dd4c90c048060eda7385244664d33819bbdb9957827fb33d5b472b812be01e17a020529fd01e2ea75d319a7ba8c24f394c0e402f11e8888c37e9ba9c3af2aef30e4f0cbac008530ecc37c1d7c7bfbaa60be4848573e13167211863f17404dd206bb771b5c36be69aed0554005de5f85de887ec79ad19b4631dc910c49529d4da089713ece64e5819b86879883b8f1edfe6500d7c10b5c34882402ef700f17d51d01b2f7bc8e1dbc38807510cad6d40ef20fdea2364b210a35e391db20bc45c3a17e883bddb355131b9aaf2a4eccf61a17a0441efb2db1dd65dd866dd468c6ffed34cfc32458c1c54266ec12cc5c39d3dd2e3d32bd662c02dc03c906aa1556a2ef80782169887cdd6ec4f68b16fa844abf1c208238ede79ce0f78257cc6e7ef80c90d6fab0ad9c3120ba7d4f8bb9033bc0e7ee675aa4e3586700dcbd84991e453b802c7184fc4d0385fd53f6dbb0d857755a55c58e78d368c3e12be1ca4034893bf8ea092ce6afcd2a4e4ae12dc302e562eae03213f1329b259f3919a803a5e44547996882083f1b422b7f83997437f8740c864d8759ee3347e70e4f3dc5592d249d4b84383b83282526f9863896ddf2c03ee0ae0f115769122887597decaf209f0c4563870a90ace75497c729d3c999a0f76bb5297c30fedcd3a979862e40ab743d5934c25eab1c8ab751ea137ff6423ff6a7144f605aacd12b16ceac956a5e6a3d22e13043f311c7a4e322a2feed22ac28c026438c76e7098ef8b2251321d422b91cdd363be17ee184959e987513ff4266293ba07f08f9235c559df555fe434b952bfbffe0c1aa07b4c745b4dfdf3feed6af66ce84a53a3caeb1b177ab143379b71019276774f003c9603adaf3cae5d354bf26306f176edf95967a4450a51e8306c01317b336aec646de31817f80372bfd419fc979768b473762ce3942992e9f9f6ed8d5b52beb8472ca8b90d572fe1e229ad338e43d0a2f1b40d07e195e49b7a75333795b27d7b7402c15e6459f6edf58072dfaab83da7965972446afb593d5ffd374fdcdcee8b17b23230ac73241845fc43c919c7ee0d07cf86b259e5b02adffc0e1d7a2c5b03e533126c216c3d6af839e8b278e3e8c898c73f33ba2a4583c64c4e70ccee9610e0438d6000575b64657fc118c83e41cf1f27525820908ae659ee64dce9fda01fb897ab0ae0588bd4fa2d7324b19c9fbefcea70f2bd6621887283d5c88b6167992af76b9eb2fb775f62829d21d76b8e53266bab04283d3541b10dc3f7f92ff6f3bb813c909a26b15f8593527d048e25a105b1876d388e775b6055daaab291180480a74193ab9a1c5872a3598153958f4a0c496484033b932c96aca00c0d42db0021c609e37db31a0861ec641d541fcc0e1d5991506fa7cff8459aa1439640ce67024c4d836c9088ccc082c0cdf075d1a8e3bf67220572429c8756dd2a43af4c71430dc1f3f9dbb28df49e4a3c1432565b2d4376bd97858ecab1af4053e41e0681c327c8264fa6a959b6c742c53b4d9c547841981afd72611ccfd45a3fe6d20869c38a2af55da525dfb5ffd66ec4347b4651ee7a06b48dba2b4cabec9ca21ddb57a75f7b35966ea7d14756ed05f225356052a73fea7215d58b29965f14acb41a20effbb45336b1e4baefd389efcaa6b2b2f7e06620378b96b81e7b2588b4cdde08718fa6fe138a9089a22f0dea6f74810e1b867d36638abcbad811881146cc50ee3bb84f9efe97d7191e02e6e4a79624b406048417e665e7a5b1eb5171e7d0bcfd3cf25f429a45bc05dec84970496d7ccb1d2917099f1fe1f757dd2abd6b3683a8a22c992b49168f8cb9fc2f582f8665f195ae58c221f0d36fffdc323066699d8432aee3a5af06563d1c3d181f22628a4503998ded2a16efe78831f60d4420d4c43539ee2153e77dd04d784a4e224131e79dc2a50e63e6f114712b3d0f0662a78f989fa887e513e09757203c0c8544fc928756650e9c2969ae1ab2b7275bd3963b1c444359246a4bad79cbec75e41558a16f75b065f1312f25a8bb62e90b7f7960886cbb04ce0f01e9fa96991fb004969508996e70e9bd991c1a6aa3e0978e9842b45c7d742df14dd5012fa0aa0fbae730a88c36ba5bba3a501f66793100d039dfbae0c000b6f2cf560589b6cadf3d53610b8899da3e04cc95858f93495e0f36d103ed47289774f8dd2c0138c8a2a7e11ed31316a0600892553915e6bebf4937bc39a40274db2d122c4f50c9f2b859f0e1ce1ed9713291efc813c39edeff5bc0822d4dc4990e6f1a7d80484652736f99a8d0ca82c57c25bdddaaa7d86922f031398c0d0afffb18a4a03fc16b93c72b5285de9ab88c5ff6779de0cfd00ff3ca7980b09b874af243360149b61639d3168e6d65ac1e2c926dc1f31698b3ce0a73a50fe742a7e134a983d885873b50cc11cdd9699eafe1707be14852dc2890080ac6ea8a76d49df280c8b05ac2a49f98cb2ebedb45f2d9313641fb0ff5ae04370bf0110737d8214ff232e5ad0f274bae090f3ece04017fa86fa42dfe4664120b351ddf1fe1dbffcf1b00ca808a66e2c34d0b6cfbaa0574f05448e6d31e5a6a2f77f9204ee3ab9707765165fd7b58105076a5d0c8f7fa2cb35934353bee8c392db5f15c1ffd954cca07cec8903d4fbbc610806bf3ba4857e4105251a9e0233436ca751445f796e7a074f89f94fb0d53eabd1c6b81a522dcf87527998f713daddc757897211d3b6d76d3d5293825a41506f485ab6e5ae51ae11093c30b9d444f10a6f623caf4d1f3b9bc0bd233685cb0c993521e2ce6ac70cf1b5dbd3c16b96548d35b0dbdd1e2625f3f4aa5b0088e1a3273f754cb8d46356914909caf7c6d30ca4a7b569ae1615b14369d24e6f06d6cd4e0237877cf5388b030f58421f4e00abd050f79a5c731c11c4e45a7c6a8aea3595bdb1abb34a39fba90ee5f33be43269a1d5420889277be02165d23a91ffe9e85ea5391c636efe605c6debb5a5395c4083d62e085d91ff46762129ba3d55dbe1904afd2260173313e10f74eff9f0ab04c9ced5303a85320b15207dd207a784cc9096388651fff492ec0f3dec6519420d812ac40fbeb6e376355420deee43042c4fba486eeb0d34029eb2d91d6a6ae4b2832a0c694f10c0c2f3d2175cc8a27b9e1e923060c11a4d3e039e6d930d429fd9a7bbde617fc9dc66af0b8ef809562b22143abda1bade29cca67bf117d9d2d15c758daf10d4627a913273ae84009d84f580682b49f2986b31f97fdb7dc10182da9900a52ae82806df1c89e0bfc22a538587c2e93f848bec614c9f6e5cc36600663eec25d5b5a251486825a47b40357fa57acb21e83483c3af19f07df8db83b36b56f130d04b4bbd7b7119d09da6be470a21db9719d6ac9cb5aae2742abc24960f04d71532639c263522e69b6bc598fe82d3ee0c64c6c1ffc06b3558c549c70bb04397d73e4b67c780a0c4586c2d206ec86d25b213f9b8d03bdd13c709b67b7e74f730ab4e75c1b481e071d0f69f252a83506ce16c933ff394960b2739f5ec5d106f300469d79c1fcc12e6430aea6c6581e9c667b2182edee8403c0eaa742640fca30bb7f0fa680cc38b199ac4905b54cb2f705e5c626dd18e4942a3220ca0094e1f1c015b8d18837a4a2dc86558aa9738c2b0c5821a4cfa13a3b62fb56a6f6ed82564cda554aa34b2e49c0d86677d84dafab12f8eb9561875fc0b5ff2e1dcbf75afc3c5879a786e4fa43f6247ddafc5d7fbff8971b7bb1d8a5ab66b796486ecfcc15cc2924d75f7eb88639a5207b9d2e09d936cc80b792552d0fefb897deddcc6452d1d81f58294de674dd31b2866c054c5465d44764c2ccf1e280518cdae2abac730cb4aca74ea1aa6d8e643bcf8694ac317a4d5960fa2178ed297de19466e88ad937beaf42bb9d214edee6e25de8b29d3df9cf56d2bd98f7a71ec2fe1d57fe8930415b657a2ae17023f998c968367904bd3b08a435d004b12b9bcc4ee8e5d54d0448634e7cfe387b00c8d2547b81ef34adc5de2aa07c61fdeec8ea6b22e81ba09acacb1b575dd0ea54f4eaa8cf39bb5ed8f8037768f987cc12743824dd7809fd7ab2e073d9220a0b0846eb23b7fd70ad9f378b810771f129da2c5dc905d48a421db6b5e4224a8dc52bb0d32171f3460b4aac302efec92c60bc133d0a879e74825e006523abd340abcf4e3257fa0e695b56570491e776fe878c1783419edfe1db03eed0562c03da87a70bc2621cc9e8f712a2d32559bcb93f807fd19d096e20135c50d8cc59cf895aa619439f5100fbed2991aa0874f2179ace64c9df04e9c41678ff9ff6f0fa1d9417a09245f522a1fe17f0344258edd2d54b2b361d7b0a9e2a29cd4ec88f02c44a854c6f74c610870b0348a46b6f0012529a2c3058d70b750d211b88ccce4bd8ffebbefdc4127f69e1da422503b2b409b2dd4ad10165825965a989a54a33c8f9c8a4c03175a161a7c4de205cd0828c879d3a8a684fc285a24f752cbb491b7baf53c323142d6680de2096a001c89075af0531e0c1f712b6eedf7a71b18901631ca2707e562dc975422a04ac3daf5374d16f1e3c3ea72b1127e329c79a01e24f8d2eddf5a6ac2786a2b74a1ad45eb5e07f5f7785520651837e7f845865428ac81cff2dfdfbadc132f8ec5e97a17f31ff15356f5a2b477269f3ce448bf4f914c03d67c470949d2c3204e8bb261351f9fde37a1ac3a060eb4178fbbf7bf7a19688147d1ccf8908046e42c447f3f6356a9d1db60ad0ca0ec40a96dc8986dc38de1c7b206853292b393e6283294a8876ea6bae74f6e7487e46b0343e2455f7703fcd55e4e2b244f14b5e906aea170a03c1fed198e772b967a5ba6b2911c4abb56a5188dd5ddc7fa5915f28c565b4c41a4cf2ee2e24d22ec7575bd4abc6d2ddf95a2739b562bcc2b1d1a51f333ced3940003192d3046a7c9d12fcd7608da6ef6ca11012cfdb70aa7d09479e7f46893b31c5a767018fb4df529c76d610c4612530f6743adcb7982482a1931c8d2d098102ef22ea87b30f145a1a09edf7340395cfd95266c3f0e6142df84451032283c7b342236a67e4ae26a5f5e281f24b7486b3c0dcfe375bf8995b49dfb2e255acc273ecd91be7502989f42ad5a83bd16829d644b2f67414461e719e76716f09f38f7d6d4874de8fb66a7741f96fc39eefb999161f14e59de2d5540c499f5aca0436175ce42561e35f2e300301cd8f4a6fa3d3e64bbb39e9b3613cd2bb642ac12f16c4ef306b3bba30f0de7ee48c23ae353f6e761081664cc51581acca7325e1f17e0c004e9e9498d607e9056c974732320017c761b5d7a895c6b266fdd88914d15719f614c60f66c71caeb32826673d7606078eca24abe4ffdc2ebdf18d83239388ea879c8437e66d3688d3808f485006929c154b002feb1b2eeb43f5556abf431eeab1f23dc5a5417e8963ffc7ad78bf2fbede47dfe17a675c7111782c91e3474a6740cd5fa1365e3fc15696f6a2f9c81e30c23f0c4ec4aacba84bc898b747f17750e766c93eb5283076535bc0b09a295ecff5d68199d7a89fa40cc6bbf4d90e2ce8b7eaad61d02a241aa6661914eaf834799ce14dafe75271e1e5f2be5f62bbe81e017959ec2fe0e5b15978d9b4a252702866a6bcc937c613a9bab7ca4d61cc9cdb1ddf0660ad55b8e99c0dc69f481d9fa24aad67f56d53ef0c9da22df6673eff9d6b36a75bd40df9b042fd7bd6d7760f04671f76045ebcec1c9b7951a537966241af12e49c6ec6d5fc321528da2baec61f4d1fc94e2bed05f24260bd4703abe1dc9c0e43bd663a74a406c9f2c2e8e91987b68d42f37f3519da3c39b72ebebbad968ddccfa437e588a4bf6c634509ec9f9d30e36b3bc2a1bc5021d6bd1e7d132b49d8ebc191dfe503fbe43efc2f5329aa1ed4c0103b6c459dfced4e250bbebf65e5975c359ed88302c6d80f9f1a360a2cc29438053794e1471241575f39f6b5b4bc2a7b3a5be341db47f15ebcd1ed033890bb7909bc5fa64e1615ea1a61c152b5d75d012a2b7ef12e10948915515de5bba4e702fb1559b308a77fb6ba3e2feb75a2caf4005a0d1fba15aa795f70a1f6eb909667657c854fcd6ddc081422b157b9a612acfc3ebdeca237b196b19b57b887fbda36fd50b11556a3046816cf19d2ab2ea69fe11de7353be35c0c88b0b0c1500b41b98f8ec7db671581784a0308df7bd1d97d5607c05dd8466282c17009085bd7fd0959235498e6f98606edf585ae4ab6ebb78b11b45aadfbc7cb08fe0a0797d3b2161f6f9ab6373e67814077b813f8737285ca52b1d105d2793a764a62776c545ff09a42cbe08bc63703f95cfe1060625bd49f2750abb95d8e42a3b8e1fbb83adc7c5030366616c0cb8f9139dde97dd705a45bf81ea8d2a76a524ac408dabbc9c8265768e3bef06975fd0ea91c6214c82b25c190931dd9c79275174b557883aea470494f7f0261471017212acab8eb4a941ef3319c0e8258cfd97f9a3aaed366c4406972ba9fbe2e58478977061dd5f6249378791e78cc90f6762c49a07b38a85685cc0f681b1bf578b30605b74fd8749a29f4a8838c731c3f750cc22c7f673be3dfc4dd24449944f2327c0ea16eb903ddcc1b76a1b2a8218a73a92700fa988c3810c83553bdc9423e9aa526b6892433db1735dc6f7c1e47e789330be8b9052e48eb6000f5091f3270cad59f8372030482ebdecab4ca0220ec46da1318e35d4e4b2adcdd8fc090dc490c5a87cb9514c952c987d3ad2b9528f464ca7e4c208ed27def5be1e7142681389ee91e92bfd6b8e3e414b8037bc221e6ba37de845a8b21d2391431a51f50e79b48b7797ea8c9eece0d46f6d8f87acd4e80b693f7bd8c6e34083676e08e2174c5df2a3c3add31b70872270f79dd87ec1ed976188909f2d321b5d23ad971073eb231849e3a84b6a8d171bb065569a8a5ef1030c9440e82823cf5d98d88e65da6ca59e3c05981e3886206370b79f7124c7848d35a3ab29d6afd5590947d83be070f91bfd0b6a1345f9b94d5c2287f293aa74940a80272593213dee921742b33aeaea1e209e0add39126678e318dd52cb825fab22b443a81c9b803416e0840335cd9a7c8253a5789df8ee9421556c2462abaf28dfa6fcfb48b831803c07f2ee0dc4a0972fe1dc51f0f0409cf41940a1d00d43812441a83bb2d91fac500663512251b51bd078841a417894c2e9f96b6eb70de055738770789802c8816a1194b512c1b9e6c8739fab315a0b136e9ef0650ecd2362fe33ddea98e0ae49a823ca2d495017da8d491839825446415a086e8dde387f22c6d4a84d706874e0a48e586a1b0e3853140ff2d251b0adb3156722e891147d2d87cd94298890a558993dc9a1ad325e739cf0dd61af6f716b797a2f700bc4d88f588c7177d9b7dbf492066bbdd44516d44e5a9337870130cfd98232de2717d9bfbe1199fb9c85301186673319347711900364c7955eb8174b7067cad7f3b25280c317fc3eafc1f170190f5713c9b4ceffe7695330ea4572a52c676857f338dbebf30527cc0380bbe28893d7bdb9bc8cf56028083bd4d228b988f4d2e2c7d07d1984ba0c8699386b97006013b171084a1195a1c1c740d055e7f1abbacea104b8ee7b061272feefbcc96e0ea5bb0a52c44db76c9e6dd2a10a8e2a65097e92878679b0af8567cfce14d0563503b7b0f7b6e4010929630dac6be09061675076b309da6e6acdd9fb85166b4017599b8136780bd830395c862d2d482fae8186d76f19cba7c290340b7c02e01c07b65d6ea86de2c7d3c766a0dab8bed6178014fb220cdbba2979cd34cb04b2c01926bf8a9b10e4df8c5acf71717873b6038261f6b1db34119fa3d448a7cfe9e89522d9b41eca8f0c902fea228dd55a03a7111c941969530a4ae65ed0db8ab6a9549dc1f01c8ecce1a61030b4afabafba000ce517589da2ce2669c39d3b8bf69c330b5cb0596f2a6d60aab49eca46104735b0baf678a2416093fe5e097c959bf7c6a48e41030f979b0a3555e4ef3f43a9b92772cb6585f6f60587668c23b85e67d0abecc14a16e8d3131d07546f0287069a7b1981ef6f13eb265370bf33d4321db9e502fd8256f5371e181cee04a7f8ce15d8818147d828babadb7a182fccf621dad357d371f7b7bd4e9119a70c969aaffec1cc78e8dd7cfb1cf2775adaaea0a555462af68b2ca3eb720a64d63015e7111e1373b5f44586889e6a3b43cc04991c4840465c2a71453c9dc25389725d89442ca99a65b6153c9684734d2927c66d0d542d96ff64721f7b07c53b69069066c9db9088de259113dbacbfa7d994d022ffcf38e12358c845fc64bc806d50df39d629a8418b97eefa2625169855f5bcdf4727e7af126a17d2c0766111c758b2358d64f0a91da029c6c1f084781706a6fbf608f343ab447f7778bfdbb5e2e251e505d6940da159d6ed88d038e234e3ddd3190dbfc443fd59a5def955c453638e43b203325a7f46faf0dd7a261615cd2084b112c61380667da86619be9f7efa762160ea3de5aa92b0caee04f7c43da6c5e4f10dd05acd0a75ef077e5e23d3ad3d2fabc6b3b71e1197ef5106dab46c0377f85984c0b5c652b5177fd7076804215461ead59a26e9e39008141ce34c6f4beb5a50d8fb81d029077cfed95186d1372778b7f3b160b17aeff1689af1af190e642b80383af698efd87be066da162060a616fe3211e19bdff70a140a21d435b5ba2a5a15564d1fd95c63bb962f99a9954a48dcda4970973bc92bc378087e4ebc7b6feed0364df4ab8350a814e2768bace562394b9c5e9b80d1ec48597329e89c6256c1cf2fa2c992efe3bdeb5c5b0e91aa4ad989bb4dd3441aaa95f1077bd62053f15bc9961e112d571e435bd20944a5dd29eaa524645fcdaa9e2ea452f96ba70906fd165a8182158e8ae46aee17d1862c15e8a1d36e33a101fa1da3b01b22a7e7e401e8ab521ee3690639f463a355994ad3354e3ab31ea078c2613105ad824c2a7e2c3e7fe3a1ee8338f716854a5963980d8c78b558de0ca9fa7487a6eb64c418f898702c45f6661b92d1c31f200766d5887794aff2fc2cccdece041f4838b2141ebe33f9e7995dcbef08b37afce42f5c40247bba81923ae1c37c47c9315092cb90e90f363dde1f76744289afd125691035ed69573a90b1c73764aacae8b27a99960dce68eb671e74c2c4c897da7a841d180a9034cc57860cc665b54d72aadb4aacf101a740bc34973f00bd180bae8b2b1a3b7adcc579d35d0b0e0c936ebd043de62dbb3ba8a12a85384e47de0fb1e87975cfef5e8dd511d6e7fea5b77a70fadb4e3904304d550f6e118f8c0aa855ebbdcd5feb85c520607bb0ca0f5a28a5df6a2c30580896df7418f0c06a9e6c0a347061ae3aabdbba4bdf89eed3ef03bb42fde6c129b36554c56995f155da66041b59032d80fcf4b5e8a5e15ca67bec9679d30fb453bf49a47a452dc0415956c8d3a8efafd7c8d93caa8d14030d62e3f7194e22dc54dd71c492b6a3b6e165158068ac67f4956f4c55e5fa5f57de027c3ae5700914d0a4c95bcbfb86b457736859651fd0972f499baa037565d782329aed2e4c0717f6d3d4a3a2299afdb713439bc371ae07caa95760fd772e6435f66293a4388f8bc1506d93657371bcd9a6c341997926976fb93e95fd486ccc57b0fd85707a04617ce0b8654d23f67e07e14d8af4e2a1b10f47f77526d729969647a1bf30f898e4c089f8fc072beca1802d8b7249e91ee6ee6d447e5e3e8ecaadca45f7266fe484b5cbc890c1be0d987997a18a3327a1ec689c3595a94aba099274efda4d01870e78a0386d870271c63d54d1a5ed7015f8da4611bcf3a243cfa802a935c283e78a96fb1f5ccd1d4c40b293579580376ad9abb85c547744a42d89df9c1909fabaf868acc999f8eee80b69f106be4c7105fd668d01ce923341552764804639359d57d1c765608480e045741ba217674b22828b0cfba7dab2200ff3c4da9a908b772a7444c39083207b6395e4d883bc17c350bea5d70afb007b2fccb380973cfacf16306aa13533c94515bafc1587ea0053fc4dcb59f38c3f76172956597b0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
