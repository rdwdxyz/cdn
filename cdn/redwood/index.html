<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a519db8059fb18db47320f3cf3cd5cb8e374e57bc0c16aba62a487b5ff58b8f2c75ec30163096dcdd3ac751afa5a0b9c2d392548e760b157e8aed1faca7878db09890e0735323530230b5b1d76ebc1ef4f9c6ceff2b755ac439fbf6ad64816e7df5c00767de4e3a6862fc92c8f8d03f901c75bf8b56ecc737ac16631518ca37c54fa97a9be634bf4ec26aa24a3340e6af60345ac4a7d919b446d1d3b34df9cb492200bba695aa2cd674924a168066ae557b6b5a7bdd678d4f4e36a2ee5dc5e710fcd85445cb77c00d78a3e5aa1694a454da8f581349eb3e963987d957ece4af532b42d3e57de782c0935e15d047ce46313bc1c98ec523e8547ef17fe73a965ce9b1b07362230131a3c1c4f12e3d668f76dd05633b928ba71782cd8f8f0af3bf254fcc7a5239f3df0c7002ba7275775cff3ad022a3cd28c59b7e0bd1b0606c22fc510c955ee368fe12860b1fb287d2cb8d4ad4c528248e9a77ae42d8ff3156060ed6b9935db37d6dc1cdf1262cf3313cc77f69abb423ce0690d30f96615cb8e86221e912c4fc4411310198edae02bc541188284843247ff1c516e1f3c464cb9f427801f3f8390f81b229470b2cfe9f7327eb12d28a3c55dcdad9ef68a118a785e5109500586d4e1749df807ee066f70a183918bd6ff4e86df4503bfe5ba152f686c5da48db50ed920d645774485d5e764a5d22a62c82b2284a49b9a78bc0c776bad2b91b607b3d361d55681a50f3b1a4103fbb26532f419683f8e649efd6093739935e4553abbbadc43943bb7718acfb29eae39b1f0fe2fb1c4273f056ad106a8d0f14988521bc1d1c68505533c6d634425303bd73825a3127de3fb3bab0abd2e777d14f52670a7d45657f80098b872e0d9c87744bd2bc18ed17872cb8dc2954ae2292786cd21b310df01c79955f4be1d11c5cc0e4425591ce29595054f24a578d1fafea68cceb9278c9083a3e9384e3f8546e21a5d003587746ed535f138122fd538cfc54ce877c623347e65df5e5468dc124ea5f0534b5f79623e09acf8cc1c64b05f97a08b799d219297d5a627d4c7d79cef1d0ae24eb8678b7f08c466d34e350e9297fae51d054c480589ddd511a02f085c597b3639402fccbaf2df751bb95067f5effbcc6d4ab7f03bc18d594525376ffb05a14741f0e4981ba40f60c9f4ebe94c75004b98ec27a8aef380e349d7b8a970a92dbc970b18da91c7a1554ed856c3903efe98e301d47704838d898c82d1c5ce9e88b5519d2f18ffa1363438464b14618188871ed55214f324b23a518fe0f09d49cf5276705bcc7d987bb8152548754a1f2d5154ea10633a1e818184084a2e5c9605113e8aad968effd973d0b614a9eee3e00569ed0790cc5cbbad8cefa515e07aeb5ab5d70bbc6d4ce15ac19aac62d721af37c432ce2d0e16f075f3804c2c6ccc62a470b7963d6a927af34d21bc7d8a27d43504521520049ebba0416b724d8fa7ca70d706d6e24019bcd2846ecef34aafe8a200414efa8d142b2bc4fd9c8cc50fef8353503b1b576f4479baeb63342a25a230b794b79bd2fad8c471de828e46ee60047d181404d28391d8715468cb2acb3863f577110a2010c9a3a7b593ee893c25a3ca0a4412f16b3c45e9b6c70d72de3804af6013f759ea2e8edaec95e1eed7a94a1be3a143a3f4c78ec2b733aa6f750a7f782fa1f7fff12674a617f743417ad4019568ffe9dc62dbbe5481d6b2e9de8899e531ef5ea0cd4b6d2780c93b21a3c8cdfe0365247559099e1b2c59c2c85b16bffd25b3a08f6adb7b92414e5649f70db8e3b00b3b19cdbde254fd4dcdb7293ce287dc551aa2c6c182f1bdea6a22d05944c09c0bde5c85ea9ec7359e532430eee8d2f4ba5f510860229aebdfc43ccaa7b58c6c7993a7a7d2a3b788238bcd34779aceac75ea5fa2b43f7c0fe355e039bc1e6a458dfab877dc056b6b1910f65687a9a189c308407d824d5f6a1884ed9c72fe33ffc34d1f5b3052f25a12d0f0820d92b9267b30707a3c6da57bbc1f8926d20bf47ec1d06addab9c8e1a6b3e916e27d2425a62e26ad4625532bf9daeb55242a33c11bb6633bd11b37f8e356dc3b02f674a1c2f7004c262e6148ba0d0378c2dc9fa427b3f914676f01a04c2910c578e96a6c8df81f409a365aba9365c43b0611a8f86d42cae5b91691e15b7b054ec7291d666574dd350a9caf3b7f190f8890756a80b9bdaeec1b4a29da23f15a1316010c34af3ba7a8058e134eab5c1be7071260b9d4c131b75a261b53827fc5a4c5622e57d3f9277d7520d5a12526c6a36a2cbb7c71775e095f6404792db888d281f101a318de20172ae75d52694d734933b7025dee86e8f73b9e5290345fd3d6166b93b2440d49eea87207d8bc499250da05fd1ef90855fd0ff07ac6dbd0849f292d3c013864727bbf6df489aab35262951c8bfbc2041ecaf831feceb25b3764573a02ae0fa5012d1afd1b3f23183a3d5121851317a1ebd8bbb90fb1844b0f799ae8cf72614e967d775064b8353cd56629b3147e0612e8f8a9dc3a8a9d21feced5d6ac8baaa788b8730868ff58b9d798d383e6532c70fac2153f3a62cf15ee63bd6230e64a84867f0f925cdb6f50f7368f02697c98a2f5ea6edc5554c8d0b48644f3a41b124d804253aaeb20f6d59e317be694066e4677e73dcf8ebc106228f4776fdbd41ce7b142a881d79ccb9d37f33387eb5b28f4068e3573a96c09e13cac96fba304565dfb60f1d46f2b1103d0348d135b32a4bb64a4b4ae34dfc60b2d3641dda5de77433ec8f9b15e641362b49e0db30be0d1874cb69d9afc1f28ca29b6d7a980b53437db258e8d083df31ed202af215cf272fb2a40f1e2f19e3c65695a47ec6a47aada2ef80395cdd34957d327a2ab6efa5f27f32785108066068851fdbd50144e125494ddd80230ffc133e727c2c09af1a6e0a0a552ba9e455c3a2efdf91352e0d5d867401ce6c03e3f7a924127ccfc07a29d91bf7d08832ed900ea3f9615db6bbfedc436f97ec3d1b41b988d10472cf4ee0a3109b2bc6240a4df925075849ed452739d3e407aa6be57458d0dced1dc6ab20be51eac8b7305284867fa5b6e67eae17baf4efbf5cecb0ff4b99576ffd6523de81b13190282da5b73c2c17b0c071eff8e88ce7f28e9b35e0c3996476d9e9723c05ba6658f276d099bdb588971d7695829d21d7a38f32e0cd979470f198e47098fa11fcfdda192e2538a606edbd404c78bf7262b3b3fb4300b67722e9570d8476a6cd9f941aa4f3d9c960d9e3f0744b94c582f327a30407e44d91fe569998f2774ec7fdef27541c91f7aab20d6d36e3a2d5f84fd513e54c102bfc1b92c2ff9d33bb7cc896b6c2e3d2518cc1bdd6a6f6e9ee5765da931bb71e9b12e9733e114e51cbc16b2db91cc18bff4a30ae0cc71066e50071a38f3afc5daaef68fa54009aba7e7a45ca7cf23d9ce3d1eba5e81db83e31b0ffb97f546730900dc4b51364bdef7ff80d72ac4e037f37297c94bf668c1b8cc641ff357e957fe731e20e8d02e2dbbd38802c45d9c72c87ed330908049acb8912604d73810c9203f0e43a2754afa3ea1cf7cdc9ccf6e12cbdf63fc740608b92f0d052153f05fe8a695842b1a209422171ad776587a95749cffa7958b22c063f26af8446ab9faeea2621f9d3b3a2e125e2dfd28bc53c2b125174e0b4db383ff4dec03b7b2dfdedd5b7e203650aaa60e6999f178230be8fc1e112c55183f8eef90a13823d1c58b608b546ac4abd070928576e45f49cd688115a0bd6ca61e3756fc495619fa1c0accb5f7ac573e8f80ec572242b75c063c34d59a2879ce0420b60bd295b90803930ae3aec921f724f152ff5ae016964d55eee662fd58a5e59ceb2e0e966528e27db672c79bc68a5739ad0be085d33cedba367186fc99b9e90ff9066ac7d9c6396be750e7e8b5eab13f6c511c65d24f276ad86ea325d68ab6c9bae037966c0dcabacacf95926dd0a82aee499ccd5322e2bc9975241f71e47084662899e6a3f5206ff802af21620968693525668dca77cec4c03c02f9d74360771eaa3f2d1c398ea39f57fd00108517a116747195c52982681e26f2fcf3e627612b5628ff231689937d99877be01881645c24eb3b41cd439b8bdde0c43b7b4b3864afe332eaf29de47c49fe020f1c7cb830894d8320eca65c15b5575007b52f4823020b7364f7422a2de876437cb44fdfbc3c3ff775d156ced8d688a035f341e4ed231c90e3f069ea7970c59753ddd52e10afde081ec44fcf9a7f9198e751560c3503818c47016c4a4bf1c8513ee4fc55b6b68b824afab92cbbad77bf807b41a15c7d130c83e39e09896c05e9f40f113c3fecfa2cc4ddae21e46ca4b5f24c80f4c97ce71e14ce6226189d73311607f522fec771fd8068a76944ee01fd30f83b6179c12f558b6503ed1aee1eeb290618172efe4a71a1215dfc59ba619a4e7074946b2401a07125b8b5b37fe4d3924fe3cb8ace114c7d95a4f861222393bee1f9214a568e8b4445a8f5f016b32ef820845a4aede8e3873ae20e45053ffdbcb1e81b6160cef4c78902cf942f705274dc42538c05c7d95fae0df9d39f4e835f11110f47c81e06687b1bbbcbea4563c9136deca1852f4a0e758aaf21c19868db2ec24774866da5e8809f9e0f179751bc73b9c10f1e4457363e76c8280bd2ff18bfd3c6f1a43a834d9fa7d2cdb054b8f275c7bf68f04f479aaf2b500ff6b2bff61bb0d371b3599691cbe6f89d9bea46e709ee7970a301e4b102d84e53a50fc4b3a9f5843a4ba1f0f6cf60196676acca096d60da1c98d5f1826c09f1f26b7885533e7ddbfd0be33266f79bad66ed5ea385a663e947711b20b7c269e301a1507ec35679cc38bfc3dde877e6986c8d124cb1d2ce6133bad19b563fc072f3a61814e148982b58248e5013cf8c50131a7d2feac753b64a907ba0bd68969040e51e763afb38dc02abe685918c243aeedfdb1557e126154807c842c60f153cbec813a973980bd8019376796e73e2654488393511ed5353971345dd1efde9c6d41aee7ea35018553bd957fde3918e8415360a829273b067799cfe8d10d5a5e746f7b91f3dc72c2ef57d3d0a6b090a3a189082cace54c0582943345b0fa8370f8dbabc5ca5f1308cf5eabef5eaf2945ddb9f42f621ff716ecf4ee02f06c3426f48491626400b04b93ac547b78b3083ddf56c37f19da0983a4d18760aaba3b00fe4c88cac23e7bbba73a5c954c1c2cf5f3b5ac4953c8940f0be4c081f8eaf2163dcdc98e95a4b3a8032b8efdfe3edcb8a7237d2ee294fdeb097f26038aaaa4408614144cee49c6cb0b5fc897e369bd90c898710472e5a207dab7b746381003153f5f967f7850320feff7541b4df587c8912a2fa32826a3aa0a599d61c686fd09e4bf4bfc653ce437c99d9a6597aaf551ad28b6e6b947d9919dc3d59881ca22b5310d5b0f7314876e7c1987363e2c325d7710e97926700307cb407f01852dedf477a4f417a9d3d91c22a762938020d5421d528cf9afe4cdaa5fa43dffbb7c1ebeaf247ceb91280a161d865ceb506034bfa1aff7ae89373b4285d3a3bb1c6dd188495f36fec3f57ad04576778a3cc9e4aac96600dc9132334c17b3157f1f34e3c0d70d4caa994cffdc040162865e31c13fccf58719a08ca8f39bb17471e2b072f7a26c03473429b956b56aff604f47c456c424ce4cd08fc359c20d9c13435ecbd8d6289dd6ff6766d634b7769fc00ddb465511c1188db22c57b01def427c0b20bf76609f50c18a8ba0bd1fa6f182454d1ef6bdf33d5909c1bd9aa1ce655c6f4985e24efffd3fb909a61c47d291b034ff2746a0054ceb6849c5c4e7cfadd66cd015f86739cd828ce5540a4ef0d0c67fd8aca07274619207035af4f8f8145b123976812f1e166ece6091c4a4d19349e9c77723787c78035293f844b748e9070531613e24b90c029aa2526ef99d6284a5e4b48bd9f43520fbc97f23e47136768aeaaa4e5ee4ee1595c32866b324ae70d5a64201bd5df611937fb58f1ebdf4ae14aa6245c57bd2545899aa9d2a4bca6b2ff22e761292d8e4244867f1dfb3510f5966efc4974b944072f4852499e2f67aba86720bb3f1ccb8748436ea54677192fdb9cad50b8009ad1e4a742c5c01ed8bdafe32043fde208f5333c11403033baa19f490a8273b40afaa44735f6ded70335d9bd33a0f992a2960f532b8269ea45c4ca9563c9d66a2d36782b699c1ca6a7217ba558f72a45408c60160b4811e3a2ff616cdc62c75dfef9c8554e4361a1de9ce6ffdea9be86b225854a21a4085c7bcdfff79bc90b96e43e4e0d5d6524401592b03cea92443d03cb5e07aa8e41eda192fd8de0c700b314cc107507df528e93618315aa5d9d51a120ad08200e1a2ff5359c4e95909dc23590623051fce95da4ea59b500e25adb3f98b9cd0113a904d181ae8fff8c27bef7db697e798c5990c010afb1bffed278d242ad06fa0382931cceef36d02d7f49aa406a1f6e0a94b52fc3b344105fe59df6359684dc3a0817f751a865a7a230bfdc04202f85c446a259b4b07900aa7e65b865b7ff0c155cbed0f97c02fa8ca5e4697496b5e2f12fe33e4383e6dd59f65f21ea0dff9032a7166b9f0f16ea0109a5c841b4d27011d6b16ff162ac952c98976903ec0a9d6de6cc0954e6d581d460f97c92361e2cec1c13f41b8cde35b203a1280dde5e4340afd0f22e112b858b1ee7d73fbcc3053aeea1456193350dc10f24612dd978e06c7a763a895abdf9e191fb75ac16b53071e02679491db019cdd5e369c388d0aa41ebae69ea5aae987a450369469d33da6608262b3a83452837677475a76d1cef72a3d13a1b2b276695ff0919050b5aa0914c8a1b12f3a31cccdf488f99d46793caf12a7e78c4d92d8a4b08954034cd49826364ea2302af7abbbb8916ebca0d46787b285582e3ff52fcfe3357935733f3f44c77937a20d3ee6d6143bce53f0c6fc66ba62c40d12038e689fd0533115e83ae2abe04340fd65573411a11fa001bfb1229ab3e37fd52bdc6bc5efdcbf930816445bf82cd7d744708d7d7627d4171ab84c9b18c49cf808e4552d11f890b9e681310d6065fdb84a84d0ffaad60aef27abe7dadebb1618ea8849ad5504508d5f0562ae9ed15dbb7c0476855966e899273e2d6ea63b32a81f40724c3652b059996025369f6a172c36930ca2e3d4a261306bb7322d7929f0df18ebdd401a42e21feb5001f6df8a3dea30d6d755f2246931b606ab58ce367083051544eb20877cfc52e82cc468182e2655fbed0a75baeb5f3c6ef6678ad65b23dc7901c9978353e74deddc3b79a44e70c33efdeb50647edc2bb57774194daa90905783b3df7da1c151a0bc636e7b38bf66dadd20baa119ef4f69580a39c06f95c00ae2458430b90305d13856baf4d732ed11ed5d43f75dd314c4f52b197283e0ceb62a331d4d37abc2fd382d99bb7a0a8dead4f5265c0a56f2609c50e24582c800b68cb1254a7c31c92c36903337ff0414bb1987c2b21bef024c683e408640090353f311ac29d711c042ed35dd7ab32c03d1caeb8be9173187a9c0c6cdded559ff057454cac8479e6763478da2328ba6a8392e5eae13fa0a105f58cacd6bed0aba7e0c9a7548e4ddd380e5349a60716d2d260feee446d7fd644865a3cce3e8737bdea814b6ef220716c551fe71359a7365fc1d07b709a805b03b0be8efcc9673b2195dc1220f4b8356aa1c5233b2e52e5b96e3be6808e6fcaee8c05e42a190c2c21df35635bea17e4374c4e11bf5aeff9d0368e0031ced003c9a05301fa5b7f426fd380dcaffb861f99d5676ca2a21e51e71361c3f9bd52e2d667cdbb12d2730b75181d4f5442c2dd3690f4d752e05666ff911c0954f92416f94f4862a5901016f2944b9f1e07be43c5a85b7e0281089d81a436221ea193e24d4337c1d979d52399f4cf4ea1d792ff825c5928fc15e647a54ce74dea5a42434113b98311548fef6874ee911f1e5eb07f362aca2496dc876a89907ea9ae044665cb5476deaea4adb4f781643a0f24f49c1f8aa7de6da549f543ea0f07af84b2f361c721927c53c070ced07d3f66f4245ddc653b488fe7afb6e9f1a60abcccd43e0d44ca77403a9b7d71c4567d3654ee16d294b1d968e7bb00bc3ef5ef7de0b81a0d26c3af9c3ad1faef043a03736fe35e855a064994584676d110210b12916c978dd87bb5a2280aed94514dc12fc6f83a325607e198f9c418e6cd50e40b0aa492c9a45944521fa34039131d8cf8449e0deb8020c0e12150d41da9e29fb5a9584a4477672a0c2d64a6054c9cc2f5ac74b64b4bd147af8985a84f6e13588280c0cc331bfec6b10aa5181b3eca70a38db5dfc1e99cf7002a6b1966f0012f726056d5f8275339bd63e9f15bb80c01c27dbf061a564395ab7afb5a496aa5efa236a2a958e356ca5b6915f0511c038698cafbffcc33afccf7d38084ec7e3db3781cb2481717cf1801315ba25bbf66ac712009c17c6443d181ac17be085def81e5d2c3b0bb50f32eaa26ca36422469b872f1bba90e26f8ce6445e433fd91aff332dc779dcf6342066c4a633283bb0f1a60ff444d95c3ff21c375229aaef64bd5c8b74ce44c8cd669f406b6855c51335a933e341c0706c7fb16ceb37f1cb4e4a9fe10bad444bc8fccd4962e6ba93e63259aaf8b3bd30fdda7cb2b44f29ce88262d7199dbffcfef7990560078ba6e70bc546efbdbc391634e188e63dc931d6632659478e520452dfb641d852aedac88b5810c5f80eae2a6aa04631a1ac49586351e8b79a432ab33fab6eebc39de19d8794f9ad179df4c2fa75caf5ce9c700c8e9bedf19d62945b88218ab0784942d70b3a39c62b1943cff394bd694196c5a576bc49aaa2364c01fca2362be6bce34bfb25e57f606f9d6bebc1af4590875ba7b6f50569d5da03708ac55cdee66060a69d0565a28737ded57c131fd82d068f8e8969ff35cc45f1235f140a5aac15d0f7cc035cc742daf0fe751421228d7711248e3f3531348fa54c8e776ddf794b007ed623bc1df75636869bcedde06ba3124a4cbbbd833dc086aeb0f4e8e7a1410e7eee1433855e71b58996d0b1179f0daf968bbba26ab446eb3372e4b61c3022bf1dcc18d261c46ea1b35518ed94e780fa1a0d4f91c597cd08cb0332775851020962eedc9c438ceef603379d53ea8c75df089329628bb67f69c19d28b87ed75db671d56992868d9a7258f1eec6ffef8da82bdce8deadc5cee149c7c2d308b2ddbfeb93c5a2eb2ec38158ce6bc3ed3d36824f683e633c91362ff46c977e87dcaff807a93645995b812c38e0135cc7a6775e3ef39bc94c19bc4e20e1ba19ff2001e440afedf5524f224640745478cd505c0065e813ae4f6b9faa0ef8b84d212faa32e41b8bff92ca4b838c402f22b233260f0fcd8fbee3050c5a4267cde35df4f9cf6cb51aaf384a98233e816ddd7a98242f42b0cab376630f46f599f6811fef6f370f05900025eff43918fa03e3a711ab456ec78f295655106f7eb18cf1ac89618528ec1d5a4a70a19967edb643c940f87236460c5123a7791c2c8e3439f3cc2470d5e3c7b1e17a14381280266acf2fbb189d939e6dbd8ff1a4bbec1e2260c383b9942b8ba3493757adb479c020600c25da394ab1b8f90ec0032801a4275cdb675915353a173c3e1534b61e485b9d286aef43bd776a788788df157f829d150663702ae823b59baaff1f452cd0bf750834408efea381a2dc863810f8be75f9919899c5dd7d6d5430838fa3737eb8fb29e2a7ca8cf11a2318cd7780f4012ac3a8f769d21c5051c3732e0ad57f3fe79a380224a66c5eca1bcddf1865ffe1f744f0f25e5ff76fb70616a39f12972291f554473782b8a9f9da2305d3dae3a0f8f3e189af8c803ca2592248ea92a5890d2960c6141127e0f0b54e5d668569b2273e8516da7a1a6bb9f4a1258b21c7b3a38bab7f21e375a2efceab398b37fb12c3908267435004b981e47b1b1c0ffd986fcf476791614440dd4ec86b825b144b29c706e0a7a0dc21d3e735b59a56fda83e664f15293b1df72db3d8505d83591023a4a7e9b6f1259f999c0110b7d5aa02625299e8e40624c738e847fd175bb312c640c2a31847ed9a7156271397c87a511796257e025e5596e13780de9c1a42cb5d1943675c2f099c8c0c6669599379d428dbb1b9fc21475487768828dc7892c442d663716a29adc7fe42e32d834b82d4b74af26673b490896168ddf1027175bf240ed52abb482a66973a6bf908c011f91b286cfa301cef0ec5e6f9725efaccf776ec50671afa61dd1c38c9ba6278944282a43c1cb999a54e34c2f69dcc0c16950a614b3ea763f25c03ed077c3b81cf9a16c5cae6f5e85aa1643321a6cf01e862c43dad38bb82af7a6ee027a50dbfa5d19e310843f69d58db4479fe5f1f91745094dff2d76ba7b1aa7303c9d4d8cb00b601206dc8fb49d7875689fa7641c4cd1f8240e73b24e65fcd91e503eb4e9c814fe9b158e458d209b8679e762aafe2c8fb4993db14d348bae081cc397d50100baeac8984e154cb6543a2dff04848b9576af0cd3173636ec27a0f2fe7c88c83804f0ad289a324c6d98985ee304734cbf61a2b96394a9816b9a4e33a024efac158bba7734c5616e962efc141c0f8c5a91976ef5ed5702641cb47c70c55668345deddfc82c49f745a03238c0bf74b5f8c8c98c8863e5433bd085c2923b9faa4cc0ae0ffb8d78dc160c974d775e81ee63cfefb858140978f407ea3c09822ac97ec6e29b9bcf7e0823664c789b874fce7a952d7b8912a723c6f81f58ef13258c80739c50756a74f6b4f4adf3c6ca608b75d923a327797fa5c2acbbe9e8213d72972116f113397fd48ddd711fd8ce7b6062c14f8b60b324ebe165288975101090e3ba5418e0984dd519b4b8b7c78c5515457a56ce3b082039f13cb84b041250c072437aa3f2104fa728fa62e9a1924951445729255bf26ce4fbf803274203f407a1fd7ffbf1d6544b8d44ba772689629aa50f52ce143fed2335e6f7de094e4e8a4a36ffe2773bc1ad144d27a7b0bc63913fd855e9921fa14a93f92b8661f7b0c4b323f0d8ddf1425ed674be19a8678e48b73e10b13a349ab92f8cc5379369ba42a400cbea3e1357fddde14a2dc3d6e27daea0e141728d2fa248d1ba1c5ce273ad310298166bb03dc2529eef3f4178dda2730b75356248024a547d6266902129f44f9144fe1ef7dcb1e19012be18088ed653c9ac60ab42d79b45b86d4e771b981e3b3a661dd5e0931d993923990c0046b8d99ab6dcf8fc80acff0806b990a5734dc66917f72ee8df613e8439f8f4be24c2eef96eea5a6cca599d29c10b66c5f8434da90cff8bbfa0cbc372c4ee7c681bc6e2694b51bd8b780b5487298e7748f2cc6e183a1c39e4c1f3d7a030165e106ba8a67403eeced14fd767cf0630c955ba8cf3f38e4be2d866935ffac4f46ea7309e84c1f0a0602d8b145dcc674db559135826144d21f333bc3e52b0acf53334eb80c0685a22aa0c7147aab667799fdbabc789ec00b6062d4c41456f173736cc1223f991d7255d8bc7161652de27872511cb7ee2392b805c38ecc419f9e2483241aa1c737c7e0fa164c1287df2baaa16c43d10838f0d1e5003dd57119e1a9d8dec6a31640d536cb64baf5d19d1953b1f38b4afcff06cb1018bcf2a1d67173f143aeeda6b89b860303aa9db8826ad854984636efb23e7b54864dca0d371aaeb0f3a5daa21cf8ba04bd4d588f5f0816b4ce5db50ccaf13d3e6b9aa918302af5f876cc6209462cbb75a7d62d226d6254cf1dddf3d9362bfbfc6e75ce661fd3d1dfcc36f0a476af52ae774e8de45363dc6fa641457927670ca6cd2047f1f36d1e8472b9d2421bc07baa6193d43e5a7ba583a66401c0f954f00ce0be61f4128968c3cc0f12c27edc847213920c19a5cdbf27b84309a50d3d215d65056a2f3483a254ecd2f7ee077a518d0f87e688c44324f9741c5830c8d9cc1496738a050e1837c7a0587e01829fe4f98b604b14e33e3af7702f222a5c51b67b5aacd4be82916f1a901b547169300dce757170bf403f2cb34fcc4281f5c0e15eb77693e4a03c441e30a98babbe0c9a8fcac017bed45a7efc32d67b612851c7e2a25e7223a40c6893cc9fa4e7bb66bc99dbc994442ccbac2b0ad0dc92d0437c13f8f0ff842671ebab06ddde157af9de3ec325dea1aa247921a99a889576eb8a27d89968e8c572cc33f1eeb62b4b4899ef49711d93016a7841e200c0b941b8e0014ba6e2ffea9345a547c59940ff3a878f3e2453b4f6f9686cc02dd720318ea50a8217cb900319bdc088fb196899eeed60f8e2382764fa58d47dbda26bee010a966d87bef00170a0de8581758e09dc9041d1b5d33763e4d29d4c5ea7644a7a504b464649329d41937a8ee515ca77493a5701c7b639aa69c8a47ae04863fe68aaab58bcdeddf951b6f082a42015a6397d00992e8ac692b5bcc1bc2b19798ef7c68bedda29a81d1d50c2d6e43a6b2324a37e966b4fbe3c9c607652c1b2a96d860d4c592bdad214b579eec4352f07be24bd37fce155d1384514a01229799c29bf57e0dd3b6b106109ac2ca11978f2bee07df441e4fb156da5d1c9e7fa86cd78d349ba8e4c22f53711c23a4d56e699516a13d8c9bb244839fe3d3af72e8575d939f792c905a04122d42070edc23a1de7696f07b2a8dc52aa2849fc77e8ab4032e196cc55c4ffe15487c33196c6cda8839b81222044b02994c109fd75769b759e937198f9620c0e95d7584396bc0c7a8ef9691c4a66cf8714627f7413ff72b7c03d4bde8836ea88f730f597b38b952404c32a3276d700e96845641d3c6912045e481eb1c900572297a15a6baf2fb442f19de4c8ac59ac814e05e084ecc7d28f96371154a9efad4933ddb417719a56e12feddc47da3d9e3bbad745aee919672e3499aefbaa24ad47991b52967cbdc5c14a3b2501f6228bce9a345e7e700519546af6768a7ca76f3966bbda8a8a0ad766e7a1fe188b956afd943d320c9e7a1a181cda15a4ce0e4d32ba956e6de172b3ed9c9fc7328b315c5626f77dd8be14bb5332f787dd01370bfb7dd3cbd9df8a7cae91e4a3e2198a7ac0f55f0cb071204639cd4fe9845a5da20d99a24e0820f3b8ecdaf5a1c8fe0cf71ae8605a6aa73749c3c83fdc83481295bcb6647e830f8a429266073f5861049cd6b52c2e35e2ed4af66bcd044fa770843522fb06d4ac8daeed7dfb6c988693a8669fb8e411cf824c615cb0f2f32bf92a7c262d7676f04d80d1015ccf8e97dbe6b22abbb5e141548aa34ca3b14025daaa5c304c98dd68a81fe91f80b70b45f20a846c2c292f42d32c8c1a219dad59973868451e768010618b706f9d1de0c45b4ee67d7b6235a6a3db970f75f42c2b097a73045e228306199d35e5a1d72b3d4fed1e9c7905ce52db0d7d657fcf4d529746b7ef5d3229a275af7615a1a398ed4a55142bec5031d97db4ffc40651e9e10297d654f8b740a4318cd869e8c93435d5f5cfa3a6b6ed16402a9bbfc8102d770ed7b7d690c1cbbde0761c26cedaf58b9332f78084779e46df2be0c5c579d89703ba03b63574e410c460f393ceb418186840ee6f2064c09d832fd48ca0a30f0916fe2c1c50692dc5097ac8ee7357f2888b5b6a5f3b310df215d1e7a07457e020489c1e4d42f3bfee7cf346de7deb0ec47d46313dafa5a716543678afca6df9f05686ce2ad917b4cbb1d7b4b66604c3bac1233a4b94b5c26948a26ffc0274c03e0b7a3317cb7bff48641e1072026999b7cc81feeb17ca3632623fecf772751b31d5add3e2090f0164f8f6e2cbef2235567351ba980ae7fca9aaad3185fed80113a5508bff39a9642489eb24c39e7d39b8bbf5069171f09608a7a8be686e6095821b010e11307b1a11f41ed2498211e58b4563b07ff1e9bb1a8efb33c02fa302437e1bc7b4924b17f66d2c67f7564d28af0b5f4265186a00dcd76acbce4afbc5325649ce24290cf35ffeaad17d8543a78b87a4d997233c6fbd3467eb4e8b7ad65b10a3ef9ced9c4bdad7e942c42374cbb26e4cde14056bd9da370c328e105a67ee5232d0a98e9d5e4ef4f9c2625c2bb2ac63de3cfe63550f3c68370ccc64e27801a9b8047dbc32b425b609cc79421a382bdd4384a90353b59d4f3806211a4975614e064fd25373839abd0c4efd453096096313a9fe39cb70607c2021a99e02b42c1dd74e48d814cec8afe52a7c41db83fbac8d1486b09907eb8e97af0d4ef6cc663c7abf491e908dad1690b11a9463c19dcf0a4a584a5b6e5493f2e5366abfe6af9d4a5bee7afcc9465d10d7a414c6e5d4bbad2d87bee924c15af84d3081dbdb7be866606c4a4345594650f4a9de43eb0b6c91e9b6b409d8ae9a26ee7b158a032c719f87320d864624c85ed88267d274891d6e7847fd5d089c628e0334704959c212eb7f672950784cd186703888547b5a14e41b7c311bf6a42244049c518bdc43c43118658390987d42abece77fbe159c7c19e840eedb3ff566247f494f46c673dedf81c5af4081af7dd843da87e411d0b86fcef40c856f9afa77cf99180aa3dfd91c7ff26c46ebea9625a14122e87631e77e38789f00091fc7eb7d9cfe2efc18012355b2bd4f6f3da4d21a0da4fdc7286a5384fb875433b3a157f29be9e3048f1dd3dd5846107bc013e10e9a76e52737243c357453352bebaf5527d7affc2080d80df8ffd23a0fb68539bee50fa425655624c2871dbf4f2ad1408b164b433586c695491ce861d78f8230654d95da2088c0c0feb8d47d1fd252948c050e9eee604978fcbfcf3f07ff42ae25ced663c778668bd8eba5abfa33efb804216e0909ec5eb2130b94c228fb6c53567e1ef26c016eaa41fa47dcd99dad20c5878aa7f180a19ec800154f6e511becf40b8a2497f9fb3a2b66f1d662575b982f0cf9ce60d1539034754a464bd25112b1dc9c61379a402fde8ecd0737f2399be9fd8791eee714e3536a809213f50507f6609003ce4a39908ba2560876118786d5e55c3095b45faaad286d704de4476682a6aab7a7a72319c42559e1af19b23ec9a5123622b2e4a379cfa4f707d4ff8767e6cfaf781f8e7daa7302f2b9aa728fef57bbff2998d2a6f27ab7a0e597341b7907b30c804fc2d092ab4224e425aecdbff462dceb2edcd3faa10e249b2d78da09b5daf60d88c51c11465e399fa1b21c16946c068177bb78ffc63fce5ed616a951e90ee56947ab5992eff3c6f98c16e1a58916bea8a52d8a8350d0d2f38ac0b00bf2463d06dd8bec2c03f7d9e2119498acfb6f4909a98862e0a8e0fc0a452591588e254c1dfe5278afb4747602cc65ebe7610e7c7e16222ae9b6abe22316117811f54cf93453ca6f6be2495fab92f9f3154125924c5ddba0fdf7335ca4cd4d693ef00470ddf605cd30b33f1d398ea1d3e56470777733d82cb73579c8f4a74e956d8592f11df6921b3ea3fa41f80e0d468c73125d77e60ac62ff24f99b967d4bd24193fb74dc7dc56e8d4c1b50b31c6993a9b2b8a18daa67449e406627e3a37bda71fb6d21f23c2d856ed60fff76db5eb3dfee0f3170ddbac10f263299b422c48c983445c688f504cf4eb57b85f814627ff7dfd45d63e3c8a122c143ee604e395f1bf0f9414a0f425aecdde95ed3bf1159c50c7d299a8b724e7d94bb6348dc1f9921e7c21b24bc2b0f7ae91a4797174ab3dd9cd881fbe3d9b8d4fba4463d870140fd1cabe230b5e84248cc47fc4ad778038ce6bef88cd715062b9c26b33f86b86cfcb0d1a5ab418e2dd1af0d216c0fe29ad0fe9eee2720f10df01cd3ec855e0c250937d392f6731838c7ef9a0fc32c43a1f6d59c40ccf852b682e0201e59eeac2ebec5ecad428c066c4f008539a258c86f069323d4680526ccab41b9db5e1681c5d44adff7bef584cccc3921880bbd74e6fb21c58199ff12d708b9ad90b3807d293c61d80c689498418ded7cc1a4ee667b8bc87fd133a16528f802bced2f17125831c1010ac55871fb5ff033db09dca7c7e572a726a878b3606d988e122dd4a8ad89d51f1132d3fe77e2c8a2f741fa3155d95e62f1e6d8d1a3af9ed506bd01e8eaca6a1a21027c77fd2049961bba4bf7becf015fafd56b6829640f3c51250c1b6a7b471685a547e9618de3eb27b745e1be871304d5b48601e21a7c8695686ad999b49ea1f1e7a7a186958b64787121ad59ef6e6bc5ce92ad055950f0ef49dd547f9135a9d11b253608514f10e855d7f72bb32fd207ad3b368abb46293a1cc5154b429e24514be821c8e03887d015cdc05f0ec15f6f5441cfa107047bb51245bd986dfcf9eaeed8d4c5e5086cb7a6065a0708e98650230d1867a4ecb1eef92012a2f7b4dd2fb17efbc8c1746cb9b500743c6d2f644c3d020864cc7d7fc684bb72ab38f73dcc3c67a4133b541c9fb20e86e60d696f59e6df4784bfacb71dce96cded3aaa6fff4d5bf7ed1724271b62bc7f3a449a7d198c42de5f85e222cda78d4241ef66675306587aaba6b33d0ee44c453d0d4422ef319c3dca012359148e98e43ccd30542e0518604d4c222d350c10febc680ea42422df53b5d24779da872cb65eac7c2b0bd3c2937c82017962c4a2327811e47c0eb0f03ba2c142b7e1a9b5bbe94c744c10fad3dddeb8b82459dd2b4fbe546899e9b52f5d66fe343903cddee306887a7fa43b137f69f45e89d1bb6a84acec7a4233394775b0aabdde00ec126671e3801e750cb72539df7bbf228064101231df06ede2ba7766efe4787bc03c656b8c0ca86f3bc354b1e278527339078f9990479c56b0baf258000fcc5332d2b0dd1f5a928f19d202d7c5b83482108108565bc58c4996949862745fded8e8d6ded6537eec6590cef3f66f46a0b7c15aebffb3571b32ce0c5ab7e7fccc4df30f390c322e3d7d838d4b2ffb7201ed743743bcdff7cd626fa09bf1923c7e8645e7b0cd2e9969bbe5d74b34e6eac034ce438879b3e195a017c7b04994c145bc47495e451268459a8073cdb110e2015dd0c74588dd6a5e28fcfa63012f7feb065958221b519c08d695d548e8e3451ce6fbf8a9eebd6849988008cfd2a5767c00c409fda0019ff36002be9bf97df8c0bd2ff82a6799d7bb1197b75128665f608b0b749ddefe645821b879e9c3e3239b33986edb69bb0abbe3935097d102f46b4e3a1f3f2a11d813538b43f3fa4746e4daebb078cfc15e283d56cd9f8326298bc5f41c6862ed150b91ba18120c01703c80af710d93020205cd3b06627f5fcd2d67947f5f3b67ef64c3cd8941ba91534568235e4043bb7e43a300ef89f995948c1b4fc0ba77a5341689a71367221f10cd2b302d3f1cff2d65e9aed48bdb86ff23823963247b2aefbd5825cd8d1a534d52633fbfec7d958b3f6c698d9ac2d49a9b6567c1504ba91066cc51d2acd1eea02dc2f5b23ebc3a4221b9b4a585e4952b5dd8baa726ce0009b1e39077dcba511d6d60ebc918f24b768218a0205c20484fe8fe1f3d4f5cc11eceed8bbc78e77d4a54b8b059bb89564190378d39343df47b5120d42d9f4905d54bb308304d7da3886c0dd075df4983b9e0bc57c6d2aa909821d7cf6955ea8f37c7e2519ab137bca2ad2cd2f9ba7631bf0060ef35bcb9a1efd713e70b3ba76ae5ecabc4e9cb29120ad5b65ae2bcf68a733d666e5669237ea17a7cc1b19ed6dafc7f80a588fd6695510d2a22a101228e4f2c8bb261f98b4b3b929db0df9aec776cc4ada5048e552253b207d6bc7ce009a60007416ca2dafef0bf5b8563ce5cd7253b2bd32e02fd80774a9925925552868104de870a79539a6d58ac389cecef840b16dbeffe9ac70e2dae1d867a646d2c99cf21ffd9053d2ff54c881e2321e80cbd7dac38682b634689b7cd0e2421e2803f43d3b7122312cc4620ef2840d40d799bad6e237ef3946f8e6c25899a77544b859a70d96656d998653666864dee88d097fee200cd34e71f18bbc3674f9a5b8a0c369643e42bae8938e2f3525fdc7f19106c252926c1c23adce7b5b60c48aad9a1a1f7b175a6e8987a06100019906d133ff8a6da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
