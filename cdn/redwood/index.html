<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e417186b2318281aa512b80ac0123e8b42b709005a24692cb843d0b11217a037c9ff1cef9eddc997a3e661f6f44901d36926f18e8763b4fde056ddf75a5f9c15edecddf37d9243b5135ddb18dab8cb6fb1f1eb04653afc31fa046d96ff36e4b3f1135599386360d79bfb4fcf4d7bb7bdb331df48a3a8f8ef88dcc7c13ef1000264a6295cd11829ad57abc50d0171932172f5cba1bd85b4bb18a0aa1079cc917436a5137425ca74704e2cffcc9cf41ccdbe1fdc10f9df944c2bdafb59417bc42913410fdaf8e3262bb844a866d41f512034dcb4bf261dc69712a01f74ada960ba166b37ffeafbd413351e8f9d5e7300fe45930046dd2dd193118b0c5e52adff1f64afe11199c5adce069ed89daf933276cb42da872f2fd288b1a8f5f564c2df5a849094e6a37d36ce94998830377c66a3608f26b8ee9a78d85b772b852d55abf396def693de5223c3bb4afa38d294c5d411837ad6c37bbce4b616976608d274cdd8c10d7b571bacf504b7ead8c2ef4e13e5dfaa375acf851c3de9fa98d3fb1949a0e559c13ae538b688fcaa50cbde6de3b78603ed8a07dd570c7e855aa873a80438805b3a0c1160c89e3408fb45dd253f4cf88247efd76d56eb0fa28289c5a4e8836a30419b99050a8df7165ab459cfed1eba47ff62c8c1c29a985596c188dd16a5060fa7a57c17a9b571bb85b910625b549d591d37c913f657c21284c1e3e13d810373a68510ab05e1052d649a7aa7ea7b880f125b7d2aee40872de50c28ecc5f2678fcbe9d066776b2ffbc93a17c5563663507a63c89c9b67b17d795eec6b5c711e8e853e551c6012bcb5c620980cb7ea19b946f3c469f12533b63787b827a49067d0756b25a7e439bb07ea8c19cb41ceaf3ba6b38c882f3b98d6431bec77dba2456dee41436e829e0f4d2b26df7fda80bc8de29246e7cfd9f821c188999becfe7d4c515b378bbfee823112702d70fc523849cef329d05aee44e1e1b4960410eab410d505d81b02f82f6c68f7346271676baa641472430b8f80e5017c86ac08d43c6df36fb88a48f587554288f7ec5cbf2323b9ae675dfd76fcd9305703747207d350b618346f34a31676303d4c1285acaecb06cf9c4ddf354ec737010c7bfc38cb19e4f9a550d267b672ab10bf4ac5976f89e1a5acd15072a428c829e27cbee61ce252e0e7eb391fe77606b7adb28ee1542ef209cff8dd5d25d1fcc46f743e1e1cdc8f41729f549a4eab9f5825f66e15332eb14c3b680f7229e59a1edf2fa56fba6a5affa919b894449d1754cf61b3ddea47bb5b83b047dac3c8eb6179825a11f3f59ddb8df2c6ef9af435898907f0a9c33b604ebee04062187e25fbb9df4b7edd24053b2d1ed164e09016a2916f96b2a5eefa33d941a979510498cf0ac0781c7467a74cb24244f3a57a97d3b2a4851b870f197430601d8f65784cd082f0dff6aff8c60537397b1f3a4eda4653f724e5152f0ea45c5cc9abe04b564e42c63eb373ac96291e3cf3c92f834cfab3af6dec6e12a88bf3de31178fc67f84c7afe82756257ccb83e52a54de739c20bc2a83e910d0c2f1cc6a4ddcef7cf3b5c991be19717667526e08c3095d9854cff631b4497515dd6553cb9a743329f92c182fd8621465b1a4a3cc251d1c07650cd951a36e51f53a344a36fef38cbeccb349aa8ad541a6c1614304bbdce82f3759c31e55cfe70d4d1e554a8d3cb7e77d1474fa4be75ea55fec4f8063f04174dbc47cd28ed7163d46e2dc53a7e4044cd9c23630963d2852df3cd4c22124b4d603ffe1276cef3c47338187adf2c797c78a09783067851c3803995bfc0f4dcff570c5cfefa4bb58c194f588bead70fa550789a6a29593402ab5dee8b426770a0f88954bf15f9a6bdfbd127d2943435a94bf74fcc47d4dac3d287979e099badd912d31c8cf9f829be832c1d19ff116877a5f7ce6a8efa26cd0825264ab5339302d5a8f2375f23fcbf03fbc50acaba35d2729ea58f717e6637037e1914adcadb68a21402a56b5c43495600279dea0086a1c4e6467812e65a6fc25876eb50bab009f26f1f23974722a684313d7768c46cfcf965471dc0692e48a9aa4305bc140d94f032c2c99477b1632d7de9291d10c87aaa14c9020b7ec91bece4cf1915a72585a984bc6729ed3de58fa7fd65ad4a1c3abd8772438ca9d6bf7a7287048189e1b8e624f6868e39d68ff4a2866dfdcef57d7aed53ee1e1f9d83e48be2fbd2ee3aad9805d5d7879fa691412deac6ce69a76738431ec62ea7d23527039f9e452c15fda185aa7349ad0fb202792fde890bd554e8132da5993cb933f1f994365aaf62a7e563f77a126f1b31c3a9d8528e87024c104a72ed75476a63de4fc3dbd43e535e990b7c6ce977dbe3b3d4ce87ba26ff08392dacdaeaf40617b620e5b6d3bcc53f89ef2a3f827e2399a9f706d12a42aad125f57f103405cf5b8a1b752f24821226b570c3d5421d68282728970f23ec7453c83dd377cfb7f077cb9916fde4c509a168165be01b311ce3b4294020320b68a682910fb28f829e2bd8e053043d991307a6a939bf03072e74f4cf36d60762978837bcdbee2b52a2563166e982513b0724e750d38e2029959c5fb8607d41f2cfa8265a4234ab745cf02db597477b03bbc2bf52f72e66a897b868fa754e8890120ebf95a59d55deb86930c20f0a7ae461dc616f5d97bac9072ba2da2100e8e479be82638ae850171e33a26941520d15d609356f899427f189439e8c643485fdd3d8a42d96de54b555f122ca6cdba541df3e62a6b37997db8972051b8f93edf948f96f34183c9fbc12eed3948a34c5b6c4239c080c7c58c14aa2833bf68bb91ac7b33ec0cf9c80db0076352251d9d5759e5223bf047158426a01ba5b5f8491c09d3ea9aa4524bc9260a2fe77b9f725a4598be9b1ff38a549bcdbc8adeffd5cb4832e71bb13d7fd35489fae7f36f13329fe3ff188cd4c78807766f17a17b4a4f603466649822ca40b17507f3b0ee739a6357191a596b8b734a1a5c711b5609e592e4dd8b1cf1596ee222edcc9eb6e4d2b37c16f1a8eafa558925adfe01d10acbe565b15bbe43fe3b5740b8d58b6840d71f9cb8919e1dd19a5f8ca393d5943546339e9d4a1a7a4f958daba7f03caa3c8f6e52bbd23ee5e95a2fcec9654688089e35236d5974ba2640d75d58fada040799a485a7c831f25a9027af240347d05cdb02e2752270e6d36ec92a65abe897c50223b9538f0081425b848c8ff933c0d683d35a1729901c360f8ceb93d9a9d10ad16f4f46aec0b19350020f39a62b795904fcb3034ab501420430ac7a7786b51961dc4f9b086b1ec0dc53af004ac1610cf8f797b2eb76c62e9fb68a90573ac721d97c2d9bb93912ff8eb8047cb9ede7a81e3b9537a4ec120a0cd0de39caf7e58e66a3bcaf86bf46bf8ccc442879d22cace737f6d92ec8ea1455a134e2905432a882bfb1fc5d8be0c070fe3e96cd6372adde2d6b78df60224c8f883599a147eb60f0e02d179d24a07b90eec5ba1b8e859a3146cfa5605ea2d6f990290edf9222d4ed062dfdc44bf762a608f2dbc4d33d77ac0309f9cadcec1841437caca039e753c7351b8386e1ca13d0a1b6b80e48928753324fa6c539746aebe38c0d676640d59791814bd7f23b28053477d9b5c5661a8940b1df3b1fddceb0064f354ddf00fe78dc137e7adf198435e51be014d965413c7c24672fa8f19336d0b8ad816f247209fb8ba7ec75ab6928d19b2b23c896afcf3af1c82e2a87f415fc37e799fedaaa592a46b4e1a0d493cb8b3173cc149f124c33481472ac0ba573c0a058bb38bf4b8c813884d73f1b56cb5d4b3c2d87f61fd3155a26bcb7e716ed95ef20f828a25fd9125df9ecc95deab08b5373b5d105aa8487fc7d73e89ab33bbb5f29544a28da87826e03821f1cb67f226c56801dfafd11109796fbf8ba3cb729ea74395851b8e042524036310fc60a6ab2f68976d4b7ae4e5e9954cc3a0b39e940f529de4c38c9084bfb7ea51278b845517e5a49a2dff77158fd3de70a68df42cbfacc9d7603fa9e905a10ac6640aeca7ad11a596417daf653a9733879545f6243000c85ba09fbf1def9c23d6d1b61fdf64b146f94c1480992d38ac627daf63ebd148eaa60598379f49f19a890368758248789a88276ed1f98a295658dbe1291dfdbad5902f635d13f25453e7c1596f0a8c0fcb36d1e21abd0568d61cb44a68494ad6d44c24e37272206092b29d94acbca1d3aaa07792106471b61b1d7313798770c0bad6f922fab56d82c06ad0177317c63fc4672db90d662c2bb9ffa4931b1d8950fc7f9c1e4573db3ead47252df8d47f54d37624c5eb157ecff13835b93339f2dd2a5e91d460bd8f405655a057646d39e37762b5bf91097018a576a443d5fbd47d2524a08434b5566b03b04f462a09aa30078830d57c3b642ff3d823a644f62250979e029ef5db434ad40715e51d189cf3716a4ceab5b4f9fde8956860555419c39e463bf3d510a0c0b942c2a855bca9e9a07e3d6f89b26de75edb4706a075efb9616afca71dd16d2f6ad0f15f1af563aa3d74c53f49b1aa883c464fe50f7d0ace4070e65e8b0c75b954bb8f80f236266e6107b9b1124b886fe62b5da5616e016dcb1e8333e0c06d3f8b09230737ee6244335d7a0baf9b01302c8b3fe398a1ea07a3a0e8c9720298f5c16e663ad9470060cbfc18cd0de4cc0a7b84627906ade6feee9ae34a6b98324e37b46a078cedd6ef7255d0a7b4df95605dcd71eed6e41f684026d4fe77765d06653af2935e936d0550817b6b47c304e8c6feb83d20bf0e756bdbeedf7585fa93ee1358d947eb18623f63deb2546528f5ac6f11b21015eab80f1fb08b5135c9cbdb3ff27bca697beb9da5b878ba06ce596171c17093b96f12c3fe51da07a6b0befd9ec594fb2203650c6b3b8fca281a2936a5e3cf14f5ec2647ba10466607640f1dc5e5283a3400dc373ced27abb37a5d40b879316b82cb05baf01e7219e4ba8c9ad75fe9e56585b41189e378cf507e9bffa25cc74b72bd4aafec819fb900fc79c9f5abf1215b5dd1edf8b887c3b13036d45afdf515ac884029453959b33bc800643802223fb96c22e2a3800360be0be5a592dd029da6a995caae163dd53481f6ffe0fdc80b6181b1ebf1b63d6a27a41afcd650c26c2ac59b32d1fcff71b931ca389f1cd0a704b33cd802924ed5e9adcfab7c7cf62f50bae857a701520117a8086c879b7693e48e22887519b0ecf8cb2eeddb411c9368b6b7116ecc99d6da831ab7d763208001ef8d172072a64068aa6cecb8030fd9353bc808faf49478a3dcff1899624a0261aa59e24142a9cc081451f70793ac836716b7d7123cf6fcbf9646e587bfc930026985907a976c8855846978b19fe9496d2eb86d2fa045daa0028075be399d9dcbfe105d308931037a0875cc7c8d6e40987be67315fd8016b0667aab1e00661fba9083949acbbf52ba66e9d92cd105e206858fca46be283e55350637423dd0d153aaddcb7f99441045e0319d7cf8ad63a2367b69dbee194878cb5e91333cb302125dcbcddbd57084e88600be2148d79b818603d4700b7161b5804bcb964a24973b92c936975849f791bda2ed7bce5954367fe343a76b6c87a2eae6c7a1a6211061d01d679ed88db87d4769009260b0cdd2a835e5665e73abbab2ad24ab2ccea13977c89012fd9f0ffe1cee2c075ee18bc1b6611a45e7e4db6290704e1fc5b5a0892c41ae1e101ec1729780097cd1f6cd68b1e437cddd17078ff60adbf0b906f27e1e42353c55bbe952367a4e5bfd9b5129d5ee4f2b81aab212ae732b10aaa8c331eee95d844eb3639e59232e32dc396361c4618da70b0c60be94d43b01a23084a02e195206fcac4e1121b89a753f3af3aaba2a72d8699af68b20474ac5c4215db4189e14112c1853136b2891d6cea3140259fdb191d99e28f944c5de7c475ca1e2b738d8d796f0920dfb4b3529a0f382c3c4039fccc550fb060bd49b5941cad71220108057fada21e3ee6c9909656e1a6be5cb71e4b75729f86170d7438f3efa4aafb17f9afa2cff3491c3997fcfa09a9cb976c1f89dc0fcedbbdf401c118652bddf841d04cd7d6fb5e1116ac4f84aab336650b317ba244956651f670981723c244f29cc0b8a20f3dc0395ace0e9f21c3dc8659c1c5b852267f283ba01914585de7ffaee391db8ece7127b80d80e09a470eb7514def43923bd68413713bc6e67c9bd4a7e912b6a717e6d1e7bb2c6e137f49fb7d586dae0f02232c5899a53575ed6950985060c0e8a247c2e634388008bb7d14565e0c5631888405965061132b4a8f928596a0554cc7331e388462da9b222f899423a752af0a44e1759edf2603a85bd388bb6991135a053dc9e6984fb0abadc1c0cd58ee2318350e004e7744e3c22dbe2129024b4ff1edab8803895e1ec4e505989c6bb0a86e28129e47e013a21ba46be380e6851a962827cf51f8cde239a5f7e53b62f4c7c1e9cffc918b469de49367b632e3fe2296e3d3f4f3be3a57222f8b491e469079d5fdcf96d593ec8db87c1668d8cbf1f7bb1e26385ee5565202c8c2d120bc84836f8db5f631b9fbe9a4b1fabd400f1468ccdbda6db3c31ae94137f0229e907ef4e6f89cc5e266e859f022a0b2777f6b82201c77bb355ccfb41c09014576a544cbb4c9cfd323921992fc55edd3f1db989b85760863414da16b51e3799324e71d779ef91599c019bb43d8df4fe40ad48d06901e4e232fba8ca73149462c40802c687a35ec07e452c748f696aa279c9604bbbf7778fbb75d337c7e2f854abb9122f0caeb225389bd169c93925c184eee1e270a0fbff5150df3a0865fd4fcdf44f2110d5bdd0f2c6fb6602bb3015126305bc6369aa0eb68ad0893fe46b25dc6f74fa448ad92def6ed8a43cf61b4cc26e47f67cf420e9860528ba01e24e638261387a8470af5930c6d6647e94068bc952eddb9b5f15d2f61524d0099f6469b101a30f43f7295e194fe56f33ff2e308bd6e9a74a3d608c11fa77dbfcd2e74d6e8f0fe4857913e8cce4df5d55a5c87114b9762060f458abb77a11303d356fe7443a180559e11e57a9b96382c2e4decfda6f65ad8f18bbfd2353ab617991f9b5a0ed52c4963a12dd1d357394b59f9e781469fd951a3492095ff3a3fbff6b8b45ad1f8db9896a14be1ccc502a2b64f620dd37992c8b294d82d7ec700246475a1c73168c2a879248f575001a610ba94cef29c8c0b5a6136470315573e1ac4400ed339b1a73d3faceb3636079916e6e82c92f2bf120ade53e3bd80070932e5992eb288dc0c685709409ff180ddc7887a03b26ab75efd223a9ac67f6ac82f902b7f39bd410afb991c6402759d84102ac50069a015251785caef9d1b1c9e5aa5aae7302ace6470aa5a4386ae0b2c2665e17e1f8b75829c5e28f72e0ebf0c37b39eeebec3ea7b111de3dd38d0b1f2b23aab73f5ed639ca6415692db576145219622f1309bfdaed7397e2e65091eceeb42f06e937bbf97972e36a77cbb84863c564760d0224ed9244060011d5a31dfe7ea26c486880a4bfe5c0767bfccd82292ba95a0914b98195483789577feb9e9307b56dd6fb1a13cc3b9e8ef8cc0c1061941890602ecf14c4194bb8802729dfdb4c5bdbad82bf1409220c0d5369d90cb28c2e738394c7d0355993dc6daf0513e6e4a3cf43beca216f2d4eaa95edbc7d9fd6dc9da3aace13a38e77f373b8eabb5f5648a71f3b859c6d65a062355e1f9fd08663df63046dbbb5013a1218c2bb3d87ff12ed99939d4fa4d829a86f12531ecb546c54b752c5a9963cc0a194607da4e483dec89cc9393d656ca0d80399b246d2f7a3ef1b16f114a48fb38251ee968ae1ad2176f57b2d533c11defac54caaa6e82dc7b2acf2a248f8956969b1522ea8cbe65e61ae2f468730f3fd014b20926513834e3e319f4ed487a0b315c8d93582ff167b50d465b951819e248a66e596aa603c1aeabed241fe84a9e7f0ee8bce580c648a0d4710bb1d0542a59039dd2efb011420e39fdf2b848182b878cf3b071a73a235a7b7b43da40f0e8a9c55452ab6d544693e0a15901464ea0713a6ccd1d173be99baf285065c2de83c2e6f8439d84aa72f572850351b3f714b40556d57a86103a3e5621a4ecd706cc91b7a06ccc851ddc8d9f7e658ae02f9a4e597bedafe00c65171296d382b1c313058801ec306a05dead31b04163c416e3de98316b6fed46001b6ad3f9bd9bc4dfac110b3e47b3bdd63582b12514318e052052b2938f0635417879c58dc1f14edc21ce7ffce65e45500eee3db9c84318edb83627196a630854f802370cf3f16b0f5dd41210c4700b2449bfea09196a58733c96a696a7b9c3b5d582a7df5ce469db57be309ca9906e554bd85356882c124cfcf21d2fa1024ad6c096b84c832b2aba3f90fde49bc2a110f90bd4af15e07a67c27bf3aaef482c0547b01d143c0d5766de46ec5a9af4b0c8a7e3f5ffbc47b84a7ed85cfdda105dc482b36e6cfc5d03e6dc7fa3966c087ed6fe1bd9e84775341e217bee0ff0adf876a672bbd3107eaa5fcf2b1eee096c8240b4efe08130afaec605d7c5f836fa7d70e6d3e88866f9754a3095e89ab122e1c6a4a3c86b278164049d9d0c56ac1cf28260cb433e3c66179cd8ec7a205c3161ffa34bbe061dd164784e27d64447dd48373a8cc6c7644a52a5ed6efb68927f7412c3b09e7794b75222554549f7960434eee88f273669cf5a0931ce2541d72fc1c3bfc0095f802441fa127f4f97948ed46515fb275b0838ff1f66ba452363fdb930b7d8a0848c4b05d0dbb159a3cbade80756e4136273740523eae9068abe0a39ffe6155d54e881effeb0e05423718db325165d988c9b5e1181dfa9a7b4b830a744fd9803b2759fddaf1b4a56e57632ee703400efdd4c54c2ea7708cfb983cbf09b9e1673c6054a3bceb0b9385fcc35a1f917a2251365eec01c73e184dff333a69c807a4e6a407e8c849fe5dd89130bed653b87a3f7284e8f4314d4d6f3a5665fbccbfa508fb1bb5df8bbe384bb98795a0a88b8704b8d7e307a39c40bff16a1d575f625b1e556d22714154ca9b07cd778624e8d020a484006527c07f9a316f716b78de914ea2f1a7c3a5f4d1b2190bfd927b61a14744215b64dff46c7fa6532055d3f3271ec59b0e3e8dde0599430ac9ed7d36857f968e091782e83d26a4777831d241bc1d215c02a84eb31f2b831a088c24a2d84b3bd0ac156cd488afd8e82d5c944c4eb81a908577e36e4b68257c2b256683039722e81a6906c1fd91501058bdd0ae57dbf960358baea2d9603fac4feb5643926b8dbb239be3e1e3195b7dd6d1245a05a5f51dfadc8700d5d883898a8cd4ffad2c5d7ae63e9c3d414a063dda45d48c8e10617b82cb3cfb9f82809bcbc8141680aa73ddde2a249d9645536918c28a24c106dc8e0ba1941145247b738b56355d16452ece16fd1b46fe2d6bbfb277db91f72aa94101728de66dd765c2f2563943e517756a38d4d8be2bca5edfb259a1f52f88ad9497f2433683e2e060f8adf2ca2561628823e066a0a66f0c51bf6cd14eda303f3d186a146697525757d0c2a06c0074abed80faa316551ed046a6c83bc6e5fdbed5a5d99cd3b99693f3935492d4d3d9ff0f73c61d46ad636d0a9e4950d376835952875bd66eaab03f792443eeed99d0bdd45a9848c6005af853efe5d6aa26d2af1509c892771f11ee6089f54f327cd508c30ce581d8fbe475201e361d530e21902eb2159ec4b288f572f1fb2689dcf842af449869806e22120f7d18d1297dcff44199499c5beb74482c0bdad4941d361f94a1bcdf39a7cab93b623061b6e4fda68b42b40f17479cdcc7cb9c42b214b3c928cb94faa84b261699931b31e356711faa00e7a83c58455a4e7c7d4e051ed6aaaaedba9c6a9a6122f3b920f8257bf33fa4fbca2a36d018cad684cb77fc94be873271a39ed10cb4762f199606932ffa992ac2c893343f34c3feeed35e990ca5e00a43ce662b37a56967d85e98e2ef1833a258a7f9b696f0caa34fc72c454387b3c7b46319a3f8659aa92e683134bcfd992d4d83b5447bff996f5c584fdd70e5706c3562fe5e5d24fd4bba2cdf862f8c1e7f13427062f5031f3147fe2d32313266b971601b8fe101d84c46be0d879551f2e3f119aeebc2920df32026d35fcb9cd374c1f1823c10086b18727619e5c8c0307fccb7dc15820e4132d584016139cd08acc328070bac729c1de41c1ee94343d0a864430508c256bd859cf33909eac853d3e4e80cb795eaeb772a00bf980dbe63045dd52cb873fed4c78ab8df2cea76e7bb32cb42a3a3bfd63d128be4dbd119420933bce9a2aafc4c7c7ad3ed7e7fb44d79818935fca03172451a82c9aa96014d7751428784753720d90545062ca95a58df88be6b08efa363626e8e1c3e410c2b70e21b54812946896d14f5bb22128fec001ca7ac6ca0bd01a3b7b4d013eafb125c848423a14fbde75c132d69358a80a6e93cb042e28b64f012da31f39ae3cb348bf427b1cc493b90125adecbe8e2a49f0c0f176db943b247c84549ce89b7d0099736733da2ef9b61dac05c54bdc7b5c62a22b3d2fe04fa33d7c6982313e576250e0142f42015407079e805a1cbc74c9678ad411dec3ecefc83e2f03dcd60fec476ac0177803b03223417dad74be668f4151f05aaa0621c1d3ebf589011b2319057461b37a8b3d63a19a01ba2bc75d7898cf249286a62b19cf002277599462aa4287951239fc6464007400a07489d14a832caa6c46aa82855f5545e6b33270cd86477f16d4709ac814dd4f1f84dd640d8222103518a9c8e9c12e7123bd074980b9847fe8cc5552b45795599760b2ea6f3d1a23a6e4e73246b1ae68d5881ee67fbc6be72b07bd1baf5a145faae36fa005cbb4f70d5d9a4fadebfdf5a827e94a7325dd32cbba7c5e143f02a2c7e5906a3b641a8c43a023a450e2aaeae58ca5d43a206a71dd6601d09e8b3c8cc47457fb21d9183a49fbb818d5402e3b779378ab60d2eefb6a2c3c7d1b390c4a15c423b45190c6766ce79444b8743717a26810aa9934c422ba6a6f97c317265fad22f58fe4c4aa22a5d6ec74c9280bc62e18f915328e3d8ed4b1423cafd685ebe16357613661d770030970399e0efe353c7c4a05f262437c20a85612ff1687c714e54fa4dc3e49f1e281f6d7c1c5c50311c4851fc4467bd3e97ad1cf91241b7ea8193b7dae6a149daf20d2389fcb501bb40c9d6acd060d281cad386f997b615ccc4b888e489b0e4be7bae2a4af76d99bd23269fa260e2799f280e80bb2252df110acc915e08b63c6e67f46a11d71074d37bd2883b396d8d53e025c81c7292f8eff9c532c66a015785344b914ec32566cc799cb67d8eae1926b409a4f93c039c020f11a22d3144d730db26b5c360ba19d11b55159053cb59e9658d9a28fd17627c9dd32b89168fcbd1ec9e84f2002a9892f72d7e32be3d5cf1ce4e269fedcf4379ee8eeff7deadd69f1dadceb1720a66799674ddbca58cc1fa846cb9e50ae04119d956e2ff6a4dcb2801b88a9af46455de60fca3d5e08bff18060315987c8dafdb175296380a068df063a901a7367ab04d3f67ad359d37744f2c3b84f02f05ff0e40020ff2a8ee2f32149dae4016eb147beff2adaf33ff3a53c12a6c679d41151af24a6fc0b1fc5099bc297ee960c5ce6d0bc0e19ca6c877ec7f4a78354e588c4292957eff7ea0e9592ab325f6a1a329b9c81cee35e38827e9752c390a6753d9c3bbfe7d50b9332a09d589f8e375733394a9b32d6dcf903dd38761c187339901a626a6d17df9849964b2a0f859a55d56d6eea7c3df754c01ee30667eb83ef483ed6afcc0bd426f3451b41c73a7746f7f076d083afd0050a26959946b0d3f7208d4a5d6abd13d60827c3de035a7f62d5d68e61c4c3db2b4bbf6c5a12bfe856954a76ab7eafc686ac0434dcaeee1d9524fb4c4c965739f3ab5c9fb72b58c6db9f8c06c28fd113b47a4e48613361c41f25935f892bfae115f72a023c2500395e0f61f0af60a71fc24255268c272a96f9f8edc5ca88fabef768cd38a806ecded5ec053e0936aafacca18c17cf49e07219d23721791131a3d088997243f6cb89a3407ac2e835f681240a9073904f1fbfa38dc3b6c1fdb13c2c78e83603056885d4aec9f9472f9694260d65d8929ecd26a45540248a8f0176e124fe4e14d4e6069653c176aba6ffe688d6be67fb310bbfe9eb41f68d5180ed215c43c99d04498b3a4553674d961e5ad38983561607e9bf6a63f5e3014f87e57698e0d07ad6eaec5e4341dbd0d5bd0b434af5536014f0731b2d0ba7cc95296059dc090acc0b04d34cf6ffbd0f6c379fa1a06cba45b42ef01dcc571d19015cdd6ef785aec35f00eaddd871d6872019460bbf91cc428467c5546f191be36e532000b94464b6bd432945640768b65b00fa051db7c7bba87b26b146e6776e66af45aa1492a26b3cb0371d5aeb50ca29a75b1cd31d3429c09f20a0ff3ecc1f632e8aaf4817481f1eeb7262849587b01c88a66e8f7d85ed280a839aa920df707048e10d7f88340f6be67975c90fe4e7f4d62bb9611c85788ecf64b3cd79ba11294423fbbb8c9ac823a139cddc4362e2878e9741f4036d246c94d54ac8a673cf788a5acc16a7ba19afe386e9647f4fe0e2f4aec6d18d9a15a9618f29d84a83ac173520f09f18517302512d5f0911d6173379475d73f7aa84cc01776fa4997edc714eaad4d4ac73d77101748184e6f2325dba244d18a470c83622e5152d47349084b0a7a506ec0cca3414070aae54aced744b4df0dae5332b8d5de10af13261e8e70e2d06f314497d1d44d63225d0ad183f272a2d15f68a6b58a753cbccf34ca3d84978d464eae64eae8262140ffa8698f058a250bc381ee8c316aa7a23c24d5a04da6dee5567440a2cfbc4df8e8dd95bb0dc7e17baa3b89311ed0e196d05baa2bfad8af258f63679a4f9c67503b5f9784a6a274216e442670888447981bb25156b7579198497c8c635ddcadaa47db75edd69e80425169738d62c6556055b65edea6c60ca5cb14240d8d4cfe603a46946f561ceb1658e3763a536e8b9b65395b9a01133a964add5aa8ac526cd44e56b38239d633768fa482e51f037008d5aefa7ab85e4af8004f2b535f69b97395410b5eb108b197bf2fd3a3e62245f825e978f82ea92510b96b579788454313f4eb157985289ef8bbc7a5efcc206fe76046c463ed28f980910c47c1df28e93364e9a6fb9c18401897af0fcc4dc7d9759ba84f08e21edcb29abbc4c89d38841a933a9bea80c94a91a4e64470053a88ea2460859778559d1916f87d20075bb99f72e0e64495ed320c4486f3bd364a046ba438326f9aae19c1ba16b28801e6d7ae0b72be2d25a9b770cea7d8187b5f40da22de1f793ba1c3380c452a202f0bfefd848424487c65566a92fd9ecdc0073272bbf2057843c384a170a4a51a831220d744368c3d4e29204ada6253c867d82b77ada0051fa188b9d664bccac3f9e73ea9b956a7c4dbad54e29fcd6c3a2d0bd903200784610d5d45bf7286a34e70adb6485186ea450d181abb657c3e3069478e7ff6b05d157ec36c0ac895b5a1f6abcf50abf805a1d2060b3e1bb4f52a19729da0d6b849793cfc67af641249f62ad475befbfb0023c5c223d100e392df9a5cc7e326303494403f81359195327e0dd14ab773f1bb39fc9d39bb82d3fea19d2ae954b0c8123b14619502350a10895144c45804b5848d2ba6caab326ba2d90922d1264cfa59a216a569e9fbd0e9528b6101a6a5190583c879fdd1bf2e554d0317115bf2ed6647c86ff50ad4282c82820ca16d4fe8aef4ba1bd485f2157b96b22dfdb78731bd07336bd01cf196b8b2a7fb709e7ab932d1094cdd6d4dad23285451293b39d63b6b100536315fd130b15dfdb8a0892ab1fd1c7f5da86c868261a4063f739b6799f5ba334370352ed6bd658e8d843f1e829a9f1dbbc2d51863030f5102821cc0fa1daf80ea4bce96ac2c5ba993ca8fa438513583dc006e3b4a786aeaf7a1542842bfa551d18612e9271d5369000dba4f249a4882d100fe365c578c53f6fcfb8d5f28bd178552fab50e3fd0d101646e4fe66c89a5b5c22832c42aed8eba6a843062434c6e6ea8bc84435bd3923182ec200f07f1d868ea374e9032e6eed8b0264abbdf7f2133065e4fce51f7502f187e21f7734bf5b8308f3fd26a85eb9615db030e6bda6878cfaff576daff71c0d9556fc6d8ae7b525a2038e31b85138a9f3448bfd3fc7f74fab4cf4307d4e74dca88dead555873da2c2310394276aa57767703d645830e92b57097b2e727f2033991dfbeecd7497e42e96d8827e63d606060da733368a9f52a07e85363a5d81832a2711ffbbd1eddb525813aeddcf910f42465178e1857377ce2982cea34e6e18181a0ba58af1d38b0e3208d5f75e0b8fd73f1d2c2d7b6cccec96efb1bde90d5c15e96ef3337fe531695ebca7cd928c8b314b2812067e2b97ff69d9d9642d27ac170e467afa4fb2322082920e34e47a2182af3c8d4d4f2b47e10865e58b4bfc31ed15c559c789b104cd1da13be64c562ffc57ece5077bd7ccdf624c58a16a72a79dcc64be13492042039e8bf41870bcdd85661268ca8d242599917b4e9f207e7d51acc5c6384ab57b51e48696ea60a4a28d5c36a03cb5b9796506d74d29b1eaa3c3d127790a5eb4d102708c5068e32cf73c16b5a1a322a44ed8d75139444d23e3f14c329eae00dec0bbd0c45e5debd816838da6e4fc8fff0491be2e9c3a530c4763be07763806f20af58c9dbe03aeb6c2e1b081a94fa478bb494cc3fa5ded0f9fee01566842e5ab7381349347781715825856dfb97096ca1c1f5ed26fe0b13f1f51144323afa3754a2d90a781c1ad76119c46de2320aca76e67847e2617ba1edfb6a4c37985035322c3ce86b2a3059d20b486291a11ca60108e173352d22748c184c25b72ac482c05ed5a5f196e15dd0c1e3ee8569a46846233abf48e25c003858a32c320c49eefb03395d4809e54d458053d7e5eb20331cbaaeadfa2a053a338c8d824feb08a87154c5485e135bff840626f2478abeb29f35defda5da95b8a4f894a5ccd3a7a25861fb023b3f8243ae7ef31d99b457483a1ec449add5836e34dda9e39d93ca53c9967615f940cdf4bb51fb5b80415d74b1e00d0b8fd7a694cb030f41168127ce40d2274f1d4755b0dd37c4bc1ec76d29edda3a8f8e55f2b2186077731549cb6e8eb8bb295299e27d5a9a0e30d2e5f7477d69df8c3c58e59c492476e2d4ef67b4965bc0adbebb22e9f029df8aedda064d9d74812e5916c57e04c90de218dba035cae48ea36c857d72c1b76165d2bf1512c7521495b43bf1597f99d7fbd8e8328db3c0db63625c1e586d766ab54a270abe8ea14e73ef34e7c60cdaadb8d412d649d6416458c0b4651514d5c10e3352cbbdcb3aed966ac767fedf0168aae65ed7ea36968ea9189974e85875b7aed5282062cbe7665c9dee0514f7dcbca2f4a62670de04237a252a067999af2b683169a778a5508364a63d5dd539992a0df7622651c2f117cde4aa34b1030bd76d6f45eac923b9195702a49b0d070dfac7bfa1f29102fef53d44f9268c55e46a2a07c015a9e6f1ba5b25498e443dbe67deaa1ef9eb69d4caa867e37ec10dbf8bdc3fb6b878a5d41869a07138af9efdf1911d6577da11f58614ee66bf4949aacd5ab51efc68df1641192eccd241821b9ea08ca9be04d7f2847a235854b12d69892214471ec36742fdbb501e2e6d3562477be7547e94136a8b27955b7afad5438f7fc2d2fca6c36e53065e98ba899d236a51998ce5e83139700ef084611b6e1469e8fd949cb9ea0d545c39732ea39ff3fbbc7c44f529d89f5c131b6240c3628c007be06fbac0a2751449b72bf5f60964a8635408a4783b9af9a1362835bb63a6ff5fc4247a157f64a5444f1e6e9673ed32b889620b046b3338a3f0f55560556726b1257f915cd1725c949085da5494b703b301d510ec924770af3cc58897be3a855e766ba4412f5a2f7111b2e194474481568e247439142f9874091eaa725e2e16a3cf3493fb8d189b81ac97bc6eed1b5d902a4fe6712b5bde4b056c2a26c9744e000f6d790cb6ce7059598762b454e3a5867fd177a4de51c4395115f600e61914cc6e89da98fabd2a3aa408d24b6353858f290ad8339ad867c8d4dbbfbaeacef4fe6f8b4c1ecd8a72a044146333b33dd9d7beb72d969523edd9e127ef38d81402754c2017e549aca2f4a59dc3ccd2c57b41188cfa855e6c1ea5332f7f5f460dfcc47fe69e46cfb600137520c63f857d50147d3df0e4f851a13bc5adb452ba638723b2f93022296728984debea83e207d2a085e8a2ab782667d96e40efc6e15202a98a7877e8f1e35168bbb5fbd95a513c7fa2a1651f90f1dab16d715f4c34751dbaba6d7d97ed683145ed5c1df8d5afd15ff030d9e31c210d4940fd0cffb66e702a56da37644de0f8b323a92275ef0b1cbc53c43521df004967acfc73ce09b493cb0da74681691f19d54a4fd124e0bccdd2f75d68c6234a822bf2e8d2b12820d0060450078c022ef51f0918e5dc60768b8039043bb06f5e3213e9a599f15ef6cdb660475027e8ac2b3989f37bbe65db69a07b85e54613d97575e83b5df74edc4c8ecd080289cf8c00ec46cf6c1f971a75803f86bff4d14bb741297e6bfe841012620e1a12c9d9dea48bdeab6c06d50ee8ceb081c2ed06b0dfd0aee99027342bbe303b7cfdcecfa8ceb78b1734981c71df0c9b77f873cb51e7e6a526e759834bb0519d36c49367c35cedb60ae300080cae23059bdd16cd341b92d48fc7b159b6188123d2165dcd39b8aeecfdff67eddac7bdececf83d728a29570e69eb8b84601604e5342a9c5b45611ec05dab162df67b69c81089c2659ac97ecf171ca21c1afba37e67c9c8b30112d82842db4d37306e294e2895602135b59164beab60806d5a18a1c5fee8d810080781128ae7bf8db326a660f779b291977ab5b44857b492605083dcdfadd0754995dcde39fcba5c8bf3b242c3cae6c55aae4285655829898f5c1262e690c1e9a043e1adfeb719ab05c94df90fcfc8be575eeb3df0cc7a2b83f0bae57287e42212c1e6751c116ec0688847fec219beb059025b59945d4a4e1d5615b6b0316c73d1766ad7a584f3809a19e457708eec777ecb08db6408c4638e81ce71f64459c9e1ec4c670ad68ac315f93b56d3d169decb49ccdc785a938422be3df817496affcfbe3454a49f38ac1637a6687b6c1898ffafd2c65e7fb9f4584662c46e565e66789a1a61aa01c90f5c12d90b961c8a88d57c62a249c5fed5c35954f679b2997678652d885e8d042f49ce83c620ad509298625dbb0283598c67befe4f9fca55e99a5f9380a037f51ed28e8f790fcc14c5b6170977e751e70cd629de96ad8d8b78e640d255151e905c928df1cdae3a837d4d91065afb54bb66780e6c29ce5cdd02f433a013e21e5f6a3b9d5904c4e675dc61e0b45061da6f38ad9de6c98b40d7c4c39c96572ba5c51121a47eac17f680997fe2bf9a3a6520ab90d876896caf8601b497bfcb99201c253729b1345595d9e6bbc54bf74464830be279d77329a9199e562a4b07d1646d36e18ad413bfbdabcbcda995c051752941264b5905dbb61eb60e2338d2fe8650b253b1b04e5d6738fe1583ced4c016589c3d4ea54b498b348ae8590c36d7a9c7fac68dc335870c52bf37e362a9e8576a2c8183342cd90119891984f3208c149301684178b30e78f1937754bc0e427f9a585f4e1dd95d63fa29b9c532f10582ab93da6344c0d499dfe5c9c02ae6cc813a19066b0d069098554367f740038f1b9217c377b373bce9f2ca41b4fb00451b90a2ced4d47a67a14add60aa9f119cb1a3dbfdb4881002bb05b489f0ef31ad2068ac905673666e6312d4176c79d0e04dafa95436dd7678ee128f07009a33993b48e611e479b832a9f1a8549b9a4f643f832444e475dd941f53d3130ba0091b5b43d5c58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
