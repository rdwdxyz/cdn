<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82bf7bd4caddf5e777c77381bba48444233571185f755ff18503eda4ad7d068da6e35274da9f4150777961996d5d0bdcdeb1084d31a71be2503b8f4f0dabd28f90c1c3aaed4374795d4e8505ffaffe0d67ff041c4f03401310038468ce03915a06045dd1a6a38976af8ab97a74a8074b1f4ef6ddd5653a3bd01a506a41758d66977da7b7a035d853abff9bc67dba1309ef03d4ba47a894f9f7b7887e0e75b03e4463d973c7f5d2f9ae7bdf5c9fd353d8280d1d8cd373162c51fab97c3a6bf1fddc52edda80bbade8f449bca1c93d081a6d93353a9cfdba103c9272b53960ae32094c55b0ea697e6d49ba0938a04a70734b4959e7333c5be31dcb799731d56c60d0c59e650a0701f69d9159fb898a6eb13c62505373e68bac7b00a307892081465d858b4f4bf103b42de33ea32e00cd732f8d4826fdd204fe19c08212b460811ef7b57be53573e04ca2c8549c2c4f7ebd0aab6d8de953c22061aecac57d509096d99f61378dc73387071a63d0c7a2cd6f03475f433ecf0ab08e1b61992339a955317a9a94a05652d775e1f9af61246bb20b91a40388f6179a317bd2524b75419618779aed22eb9cec021377ad52b247bbee71990f0e316c65c7918579ad028c548c0708921c1e728e19d5f1623787699d7940b26bf295f0f3c22c520a6b768d42823769748ee528d767bb7be763a9979b04c12f7fe185deb0fc7e8e86a66c2f5e323a272116d5e3604a51cbb9b01fd26586f2c480609894113123bcff24dc3c8d9efc81df81b73c6c8e66b51e9c038990dd42e0ec296f74571839b935dfdaf517a070d489a5c41de381e6729b5e26dd72b6d7d3b0f6801e59a96e8b58ff67e386f49d39091383bf50e6807d599f30f24d754c5cb3a076a8a3de4d3f236874912973327bba9da3d4333eb968d5568b7fb82e7814cd148137dd38abdd17b12aab41e97985eaaa2776d09d72ab73ce30c6e019b2618a1326fa77779395155d31836958ec02ca15c5487c2b27aaeb70c263aa8942dd5bbd6edd22a8a393bbd9433472a673d0e7b9f5065d70f01ac493a2a46e6e8ca967c333331dba57c4a35443a0bd349fb29e376420ac1812fa201ac63154d1b2917b9a33809e2b6149a93a36615082283ef6dfca3b917762c420c0a499aea504bdbaad6078ab425664dda4e205ef45fbf1b9a4f70f374106160ea370bbf85cdf42152580d8dff5ad01b77a4d90fb03d1d8e72b2e54ae7aab8e3479e32d8e6165ce007938845ee3eab70fd715898d00909b000f9f43c51840627df32ce813c1281bbf49a33cdc905805bd8bc5124ca1961229f6db87e68375cf7952d4d59d0cf5abf33fe9f505f6784cdfae17dab0f307c22d108cf2522f76c2daa6267e7c80bcc6cd618d97f226e3645b1db02a854be53b7d399884a5db49c07c1304e6028d5ec9533a8564be99a226a32d811172b68662f8a01d29082e817cca5699e88e551833ec4351bde43c2bb03d539157d53edf9c9e557cd182cac38069404c233f606c44f0bc7a34e46a04ecb2a2e3f6b767d7b47da5fe38b0e2fb297394dffd1cf216a6d149274aa3cb82ef59c73f9c09495bf84eeb23fc11ddf5c247607f719a9f7f3b32d41808a225ae746dc99e6eab25e6f9008403be4f7855d67cf8a5d478705da59cf8bd2d66edc9794f26789af309c923e07be7e960da78522deb55b6b5c7d7a4f2566fd8cdb14b9c6e7a25c336117be274e0f0fc4c69063b4356f268f85d78da44da496938cedd4b88408fa4b9ed1ba67661d6d4560bc413a9a47c515ed1c16599d636cb52aa3bb13520fdd8a40a66409444cae91f64105b2c082ed60f7f75d00f78a5131017cd95c403d67d5bb2a0db60d3c098d4ee8c5a8710e260d4dd30bca9654da7c028daaba28854f1e72114f3f8308dab80562e13588524b3a96334859abeb1710ee132d74040c5f5def0701f4899ffa1ec66a7664a9b44300b88d9701bfd41a365638ab98e2ee0c04eb094259954c9f8fe1b0e63a2666ce2f37dea85ad3e0d8807b9dd1f244982bfc0956c15d6f6d5b147438b7a43fe58f0f80665f6b7242b721e6a790c4f6db8776d32a03935a3c76aa2afbe8f9c63ad94971e04ee22dc70d5d7945dde4a918d5665a27a4b8fbda4e930f3a71a4f34baba6956ae41c589c3674f7d33c9bbdaf714821c5a5ba5482aa8821287766f7d79ec4c4557c8749966446531ae64fe73832a0da41e3ea18d6916aaefc6442df741c8d8b26a8d5a2b6f57f85a35dbacd6ae0fcf9fc1168d1e6b748647dfc29fefab60e5e4181bd9a20e00178d8f8479cbce9ebeb37cfc45771b5d5eabed4d0ea3c61995a7897f5475f3ddf7778f041c05b3cc08936eba3cd00ee9c620cd6b2f84ef7ad3270cec88f077ee849f7d5d043e6d430780ce08d43ff57ab012ded0d027daa0aecac03ec64e99b7343d30f0317db7914300428aed546f184460b5cf71600ca410e0beb3d63f1b10bd9dd5a7807faaf6b52f5b1d281572fea1f213cb3c6f3a7a010024e3a0fa04d9c5546b6097c302c4380c0b406ee906bea8b9dcf1c84547ace0ae5fdd47aad90ea6065e00bf04d0e9009a2d39e18f72cc4a42655fad70486812ae7d1a0c3a6aacb8c0b842fc4ad0ca6badfd02d17477b46504a8259fe4696f925090b7bb4ae85136f7b920679d23447a155f513ccd1ae2c8f32390aa37314ee28f06b8b0cd228fd8a24a0dea78f6744f637ee34a94c6e4bc52cea8dddeb4b07085055f872694bf6e8064832bdc7b653f0b60e4cfc0443bb94a25a47a57d46d80561e4997c282f94501cb38ae03a7e99a557f23be422c3134bce842dcc91a7d6d90d2f7dd15cd266560f748b996214dad4b2abc70675d75db924d136eb2874777c0cb512c85606fd797b776be3597922ddcd069aa40776a4158f16fe04efa9ba5edfb1a370f54c51b7db44fa475b6e948192316e4a9239d242a7456cd9a796c3f2c522873b790bef2ce8079ad761f730d7e60f4e4efd3c69a1815458effe89f6370674cbbd41d2b2c17a9aa5c8c25eed079d5029641c265d23d7296d29a8092a48dc4d2e0720381f32dcb4392aef715cee6348ea951b70cee016de2b8fbea07b351934fc136cbfe5090b382ed870532ff2cbd1a64ee879d4cff0954b3ee889c2e411732bdca1a11720e5b3c15c89b879abbaad7b86fddfb5a22af325888b606b939a409188f292ba17a6a3ee6a96b8290a45c9749898559791b5fbe7533ba00ee93861c71498c456255ff524856f7fcac14ea8a39cc1141624d1447fa2a8bad73efda3bc464d82d23368d6558b273c47f69c62fb881b812be001d70ad4f020479b5a0888cc38cb6dd48815ead1b2cdb10e6239457762da1794f8ff7ce444b8f0b6583f0ff95fd3c54521530c0e10878ce6d8a4bef2e9b6817ffa21560ad1e521bf738707d6a804e6a9665616a5545509ecc1647d59114dd3a854dc7d989ad4434df4f940efb4bcf5f120fa185c905ae5025642b63cce838804d7ae9e9af7abe3cd31dd1fa295897d9783e10d0e5a19614590f682d2956451fe653fe44f2a54f96787854f4e5b0b090d1e88cd9f239b73bd15aa3d3d03129bf9a8184eec4a0f8acd7c7fd15a1d2b074cfbc2d2b9603786f1e43e3d4c016431f61c9ce6813121047cb029853f151f4ba0e839231171198453be3112325fff3215bcb58173759186d2b283a428e27464b1819747d2693543844d13929358b03cc4677a48535479968ffec95309ecd3b12c8c5b28ab2c310da00ef0fa9c7ce45e1f162a33b26bdcfca612a6abb1ec1b6f99a767b61ae1bced3322de88b65173368d7ecdb28516f0ee749831cc5d28d2f73ae52c90ee161311edf0880a2e4037b427da79025e89660e3a84db682099f6e4a9749a9cbc7290b941fa9312d56714db34b4f408b756387ac9ad962cd52f7e56289d835107153d212d63d5451206e7778429c106be218ae53a921956ff638bcefda1ff399be86fe10bcbd5930ecbc5031a1d3c5b9d88f83d8cbab431598096a0dcc23897add8d7fa6f06d474a89566a8225e21d02c566b091031fa2fd93e94846004a4345ca3ce6ea5db3bfa8a7bc799820b7c5098e317127185e8b01831c975a8968962e49679fd3401edee628430e94b317a61f3a682741695ffe68226093f07cace414a59699b19cb9217d45298dee87de45cc96c03b6e080dba89146e8c7b158729f106d7b6454c6a478d40982a6b6597c967608301256cbc27a35dfed54c01c07e90020343a7b16d60ddc3ecbdb75aba076566337c7c1a8302a68f7d4a2e419013a5ec34b45f117e96b53b626d3044fb9269fa1860e2dcfba469ea8505f1c68c1aaf83770a358e39df3612c86f460af4d672333c7ce4e9ba86db6c3ec7ebe86a7516f65aad0c298524877c284cf1e11382f4a5c002613d638be41434f10bb29952ab3a861a2f248759cc039a8077586311971868b703286d4edd3d285949c4bcfda7b26e361df8594ac1a8b88d86142bb6ac0d039a89975033be2f28c593fb3b202f50804bd8f922b3db4b6ea69dbcf91f9018096c87061cc2affba24abe40b41966e2c6c9342c5f70563bd7a4266d4726c74832a1cbb259104c06a619d17b38eb13ed821989d57cac2daf10862735db99aeaa4ac2001bbd2f8b8b4d65e2397341832f855fd71dd502e3a466cd90efcb6541651397b561e9d6e776b32d87c5f2f516baad08f38e9f774124f5e1d59034609e49122ef428bac1431d13883949ffb8ae06b3fd560e708c17652d360e9c4b94b26cf66fc0d35784b42547ec69cc1ac2c978d497e667b824afaca2667eba463f8f495cac4d37a07ba3973fecc48887ca4e4f910fbeff4550f2877df9e893f4741800da3b74033cd1fc88bd9c0be25872c13d65d655178d50842fcae171b0a8bad5c5197f30f18b24204b9b4e0cb2b866dec17251b37091a66ddf5757b23ee6c6679a9b174af719015764b043a57aa7245336d291a2d546106cbfc8fb0b76b62eefde8ee38d6e0585159dbca57d4c0bcaa3069f7641e7a65d67c3daf36f1b8d4ee5a871b7f85c9a97f18a962323a80bec8e13687d1e13f81b64edf7161c7ae89ca3f4396aea1d6ca28b95f17ef4a3240acb73efa078e94f6d144a471370feb36cff342eeb2c0e015a1c47a9483bdb0dc44dc4c85fc2fcd6fcb217262d6ba3ca14ea7b8c9f76589b6b5fc5bce4d88360d7bded872e4d9d6222707acea8af7b2694ceeff44dfc655461e3b3299d3987ff35f6adbc3e457e439614f5376836a8eb0fbd49e980855137f9b0cf7dc3de885a4092d1acfaa856fbceb4e837e18c342180fe9eb789807601e8b7b362079395925a0664f9baaf963c44bb504010d918df672fa37d1bd2ea42e47ab34cf78a77f96de25b9ea4d90124a3e86be719e23d350434c948ef8fc77c4bf626c3a43f4c918bec8881d45bb5c18b487c0cafdded8a44ee9f85b7241a5f6b2afde3d329c6af2b1206eee23af4c56bf324aea8d4812fc2a02e5e7eb152a393c642704c9f055e8c0cfbd2de9f53ad9b1a40ec8eb20dd13d78266267d063d2656fc638a10afcbc5aaf413caffd35a25c91a3a9f6c03e3e8ee4c9c5283546accdb9dcd0d42306ab9f3e929ea35e5f0a96c3cf4f44d51c372ee970d14febf828224120a5820d944b792701bdf58adb3e131c03a0c83b9b369767cec2b2092f7a38ee82f854572e10f12610bbf3fee8d838bcfdaeb4282d67930e566ef8ad05b5719297d5a0cfa640c9f8da12dcfc76b6858250200a3d4f2e12de4e8a1d2b7b28d4f5d6ad3c56ca22cb09eb9dc6f591eadd5a4be8b0b08c6edf9abe9b27c30b97d99975131b85eaeaa642bc2181230f75c86dbb07073940777614027525424e63dc9e4a887bafdb0d206f31b0b10c50abc4d36df6b16456638590727ce17c7efb6474c4741e81d1164a1d5d6142394411a2e231efa20e39afbf3f678ed1492372c17a82ce56dde0ca9adac41f250cb036fb192e06273b215af84bc88a4782e5dd4cbe6f2d06fa4bebce1084528fd119ab0d800c1bf001fcff7caa3574fcdad43cfdeb3167097104090484af91991f9f8773208003b1edabec2ae6373221b16dc997163eddb7e5abc667c62eed77a956c747c4940c39685c5a8c8ad17214159484d1e769b0f2a5f46f37ada5d898e436da3ae025bb5ef2f78173e9706bfc7395d980fbffb652a9e95a5c72f806db431d6197b19d8c5a8f9db06f4591a2736924b02658d014fcc360fcbe7ee48efbed55045a155d66505f0b58ca13b460f268bc7bce5729668b013b4b3f441c6116a6ee86ed3bea33e914e4c0f55ff6ef6c3145eeaf9c2ae52dc50e9ecb960aa860801d858be908ce7dbe0fcfd44381bf10066314e00e1b037851178f0d656f47aa81688a0822b19f4b9b1ed9ec94518f2791a09315183fded2ba9055874736d6d86b27a7f7549a1a8f14ce71bf13d7ccc51241c9468e8c6e553a4b7c982998587aadeb5819c1a85b33a4cf4d8aef7dbb3dc22c7a839b237cf74fdfbf94fdd967ebb9df7ce2e17bcdab77fd8b474417cc748369078577cc637db37703a888c3a1d135e88ce08a7d290848c07eaea244f4bee768b669d84b2cb09201f7a7050934618640727594d0eef7b8ac490b32bac132a7eb879e0531cd29a41af1522a61748c2c88fc2b83aac7de7bfa0738799ee06fbd73d67e7cb30783791392408e2ec62322083f3ead7c24d4aef7579da298fc94bf5ee58075c529527abc552df41160e68af69742ee2d9728b66b6eae28af3968e9023dd7b5826b1725a9925415d2f12bc08c4b6cd237d55705ab7d890635d3f8504f7ba93dce700ecd47e05463eed5e06a4f4858cb2748562f0598224f4ca56925bb2dc5e548eabca5bc3b516a4286b8eca1c599fdffc486474eda8b1c134ecb1e3e7daa50f06103f26bcc447ba6634a2412461d53cdb72340f9078710c348f67933aa9630a942a016fdc0331574c214fb0d18e683ac816e14ba82b7c3921a17cbfe1c0f0978fe5f650759f0dbf7de76bac42768712d72752c53756fee410bd69c62399ae17ea8d5dc2d03f2a7a43e2f54da757d920261626e4555c9c02f68a313bc572ff669b735980ff61386f474dda448ed44b138c3ea0ca22048ea72f2bc6f1a30ed49fde82f579ddc2100e77af19b80eccda49d1407529bd863a19907adb6f75704326a940b2dc3dc221f94fdc6127634c606cca702ab0e7f9f5ca14a752e910d232754cdfa02cda6fd308b6ba16a82c4843b09fd708e51e1ba6b1f13abdac4c6996c53a85c879e3d4e22230ddf65f9456da6d6ae1e219cf48f77f7c1d952047a7495c2c88744ca65c1cb0cbc7392ea6ad7ea887f76fddcd75d05d28d9b60d177e010caf7f27bc8c0fb902e667963fc98d9ce1656945b85668db0ee4a974962098aa6c72610e7df101c240bb862a3a0a705d34806f3e9f7a39047dad030cdc818864aea5c6fc916d9d91a1117e768181ae2f18c3c5d2f9994f8aace8875cf7f486cc7800b19583464c78a66dfde2f41d5cee99c7f61f368c9ab58cff25fc8145ad42065855e0fd16505f5e218b182289390d008c426d626c73339fad82cb3e34a1ac1874a98569f296216326fe25d3d8ba37079e677b6847a86a1faedadd398a15ab59a94d0b99d6626db752eebed799c427cb51da9e924d6437e9a52f7793a7945fea181c0e1893bcb9e8a016b91f7d83fc6d40e64a0fc28abe53f7c6f1804b3fcf24db000f433d3ae335d7bc1921b509058b0eb3625ec0e01cf12acd6daae39cc0b6cb1f918b0699fb9c7487cdc9a965952c46a288ada56f284bc484d90053bac655a96bbed50c8130ac000fb50d70cfdb661907d684e7b544552726f8b88a98d434035e73507a5a2090d5668e8d055e04eda82a9eb0d3e5c50bef25b28d233b432e50b9172245e75915578ee2724455d471df5bdd3088eb3c630fea2acc43bff902a9083c4dbccf75f081c3afdb1a80aee178987c4886dfb35677e151766eee07028b01151df9a40e0b33e4df48393be748c5935903265cab57e71564c8478b44c8b977c2c028999d34541be2e3a67f8f648ef4f45c83b0e4c94c174a5d43661cdfef7d495f2cdf0183bc544e3379a54ffa9598ec81f969038ff4c4ca11df91321bdfdd79e80138beaa757a8e76d742295100dd8a5d9dbe62b326152d8879e0c69cb75cdc4ec2e2593a84b157404fa65ed44210acd5ec1903ca7c5461ca1d54123fbc1e845b73b952cec7436c80021fc3c581e2e26376999403c322f782cebfb14062ad418550930d0b493ed3df65c9a9e31791bc687541ae5d2a723ee4fbb99c992751003fe1a1404abfaca79c6b2057b46a7a5aeeb214f6c60264fc53a0ea678d99ddf24ba93bf9bdc44302345e847d727e96b37818efcd94b4dba4c99b7cef52f97e50fdb68bc91e06780f011dc5d20de45e9a71fdd35a188cc8d0c3b568cfe1f71b7c324b90ea571e252379285791399d747b5215a49a8e356c18e2c0289e0d60acc9d80c1d00cefaae23d57be15f214009c8559a465fbda57af1b28dad71194077ec0988555a17196573c176c5055d7599a930fc1bc7dbc2f79c97c131e54144ef0e05d35174a56c941b96f447b53b8f0988587f98fafd19449d2bf12ad744510e78211e191cd73fe803bc18c0ce58a97698adf683638fd3953933414041364d0b544880a34a5a1c399b8330cfaba21e23f32076b8fedb9e33fb3efd96f674fcbb72fceb7a069f4a9f474d914bb9681536ea559ad8c8bb8b0222bd5f35cb3e53e97deb3d86cafebcac12ed6517d65a90bb4a4b8d2c15686adf24ff7085d57a1117abffd3ac0b6b0d672b65791a19818a72eead0fb95d60ef29adffd0fe22eb392c4b743c88a4ff680338db17e4dcb7384a21f05914449f8c6c25552405f3aa78e9f2c57feb4e1646e493b2c15b0d7070f52e7919180751334e62d45107de32cf0b81d53370257fff9787fc1b943c5c1aae7f86bc1e392045bb13957926b51dbe8e76d5568b3d29e609ebd68cf24bf663e8e13b613bdf5f689ef818ebd8727067689b68858aa29f0b1dad07fd958df24c46fc6e47f4660f141cb6e8e9ce89642bb7164d06bdf91531bdc7c6c7cb8dbc26906e82e32aa342927ee822b4843e88659b45ed0ace2ece9dc0a963a10ed36f24e83244a7659dad6a9cb11c1247521322822d22344760ce0cef495b8ef6f9139838dae3edfcc1e8cf65f059c20143181c709ca0d33326d33ca1c8860055fb69f801e5d00254c11c9b691e3e393d814c967811b798b976b59b00ca3ee06cb47b2f1e619c889fdefba7bb33bd1980da769c071f802f8a3d78753d845054567d0bb2fa296a16fe9d539892c0124e661504de1957e9e7043fdafd28913cd5c1f2adaf4572896d9e320411b6b1d4ff1800b2b138f8ebc3d5346cb3ee61f8bb161097008b1b2c3784c2f65e2a99206ec287eb3c4ecfd8f8e67a0e092b45111f450ab317bf6ae8eab16ef4d54e347efa94db1717d7f76b166538076cf46739b2ff7e959169e61e92ee80914368572eb05882812736ec302ce0a5b0ae43b6fc5c977597b6e3ed594720ac1d6a6ab6771413eef5b0b386bf9f0c510992d0e0598a15cd9088bfe9ba607a3cc6a4d3df83e4371b57d436c271c7468ea80f86aea20c542e5ab3035932c4e78b82db676b32e4079d960664837642303b3877308149639454f4baff84d27bb5eb6c1d1fa44ba320531b9b071a8d00de2815b243439281845399ee101073a07dd8730320c09dc1f256de5eea32ab72e320a4e2a24c714cd703774580e1bf5e95105faac982c4424b6111cf50cfef13aa6e43329f01fdf9c18ef3b8d0775f01e08eb4686875a5310159226a8671f17ae776a980c0a147b2111bdebc4d228c92749b13fac3ca1b08668d0e3add4e0170e985ef9856c9ca5d4d471ea536cd1af7fafb9358ac5122ac8ea93b599c5e892c83b13d901e2a7ae27c3f7c8b70b44d0ca29c87d741343df648ca08e54624aea4d45014c0e0af89c9feee7339eadbaa615b51c9720fdd465e680389ff83e371f6486ec127ab4cd5a135008b371862ebf37a34e3459815face8464f11e1005ea67d60ec2cad3fa06feb33ab28c9eb6c30c9a7eb734bafb65ba3e3c1e3d49bcd59a8b897c48ad26ec165c7abe8c4bfe69182bb10baae98fb8de807b2be657c442a33cacb76168ebad85fb6e4af9c3b5950a636a17276d762ed79a6a25e20de2116b9ae733ad27e0dca06a2e5dd87411bbe00cc3626ab5e065dcd776e1953469a06791e090294ff0d590daf5caf4a69e0c4d1af7fbe95831c5ff0dfecbcabf86cadf6a0856ecd2c08bb71e48e9dadd2de316aff72ce2087d4ea7aabdbc76a89c0333d901b3a3cce3d1d6ef0183bd15ce3da9aff84ee32663f9ccf319b7eccf1a47ce96bb66980397a25a882624a53bfe7a201532d8595fc4efb4f454f9ae8ed14adae3442e4f71c664f6272d0c768ee76aad9651cd04dc4561c6206a65279b6c61603188f756f215de6ada5c5fe2eb4279422c5ff4651060f89302d58c1c319d870754c3a8d055afa46f6888583e5f0a0a1ddefee1ff283fb4c31d8f4aa0da885a2cce79ac1a6aa7e3d5c89c1a2167b72a08fb8664a6717d31db37f79039391696e8262f6476b988cab3da07bb15d18d188a17023aae4e09dff04b3a56eb60804a61c4834429e1dd63a72882f89f6235f2ecfbf9ededcbccd29db70d97652f27f16f426510199baa1b68123fabc546c907c5c2f2608ebb7a55fde8a924833948730ed9b084b0aa976e17f64c8491d689dfc2c0541daf589c8b31e6a81b75bcae2b44681c6676ab2e23835366a5cc69b41d0df113c9075f06815a7f6795d2ac3118fb2fed67395b6ae02e9f2a5ec875797a4013e5a27f8c495874b045c1be640846bb5f08dea56d902e178adaa8b7569315a7b54b6333826a9a2ce5385298a1f97dc41ce84d1fa11e874c788db89ccf9d379051ca59858d44e5a918bc549a8e9f8012a789504fa6595e9865b8942dbe5ae5c4239ce9e92964a5b6f25dfd802454440edd1d8ed529ab46d85e2b3ea7a21df2ccc5542f9284b27b48e9504d550541d17c5684ae4a683e80396b9278107bcf7b2116f95be2e70296542cb00efb40a64e04ba0dad56a5aec3b05301773627699252aada477aaea2ce2b40f8b419976d0e7f63a3a2f3e740e11abe6e92017db14e2be2219ec81a7c5d9dc38d91df47d5e37b25a12c4f539899087d0021cd9eb097e060c5a0cdbafd576ae5b858dfe0c0b10838729cc3f69357da36438a99c4f952697459da3ce558c195a7ac97de98a41ef27e73a65d09c329c2ce4f48e50341854f4b337df902db5d73c43dea65289d8f0c4eb234bbd78a31bfe5439ab4b9f5b44ab0f69e012766676c9b3961011b32285715d749340ceb346349c5baac037fa866b743750f8a8974025957fdff7fc790b77f6cefae58a0bd836ea916ca891b04740fb9ec4b7e576f3b01f8eb9606045b0d1e5a02ebe29575a217b21f161aee24f950b89acf68a29606736350ea56de40b4020edcc6ba67450866ddd5c2e578f85c39e95de1792c88cd12e360e7f8660ee3156c0c63484099437b13dd5ea0d520b67f04d1b6986d5d20502687d8c5fd51946703351351e630c4a1309423ad6c44888084d8c7cc583e5d3a70d95c4b5bb8e35d2089270fa698f923cb9bba932c3144c077a375cf0d009680bb2b7b6d11723ca65d1344e22db06fdd5afbb78a7f4e1f0241611424afe2309815e906d1c940a32466405fe8c1cbacce420ebaf556a15e4509e475b5bdbeeaf1895629d27b048690e8fbe582d726496be5ac8425ce28d34c09e14eb11d6b274a7606f2e0a827df2558b10fd49eb0e5fa3ad6935e32d12f63e8e69e139d43145e593238ea71f838feb04194e89c1c8d557a6c6c5f846fd8833bb9540c17b8380378617f50b5a0d2a59984a846526f9f070a689fe6efc8a7c200708ed375c421a9f97ab4554698787071556773ddd8eb7eba5a8d2232e8dbf644ac862714549e52649536aa667f17123667d1aee3827d169166c9469b2654e8612025c0f2baf1ea8d515aeb70d44c1d113a6c83c1f624afb602e4a1c9819f001c9af7c4b9d4d3337ed0668fc2bce7cb3de35b7a7b36fc2eec32de4bdc6efe27ae10c0f475993d42f59adeaca80b45b74917e0655820ece872e33aff89ed0663e56d0be70da5c691e3a3c74ced769d604a5f62a2c0a6d6f9999fee721a33713d2a554444b06aab8b2a6480d1680d7ed8f69423dc29c7270147c246eff97674cb52dd0b74fb963f1600d015e065b0748d9bbaeb223e7ba42fe9cd586e203e1d69f9e00be9b50fdf2024364fadb6488488b240a7792e2e3b8b7ea87957cedfdd5ccd14fafd57adc91371ab9acb8f9d82cd638c38f94a8659c7cbd21772b0079c65621c54a015f08baf5e295e60df138c5ca613d6fcf1a4ba8b005d7f47c0ce1c120cb38a1b3ad0929e6b226ef23367dbc0335fc3da6d244e1d28933fbb00f636c06b87cf8a53ba28be768618253b4b59c66c96037951386dfbded6fb21399a51c70d60c0abbacb876dbfe68ef6dcb9e65be45196e22bf53c91146328b90b1bb7fdefe0678135ec6edafc7c100f38cccb9f493880a344641aaf23ecbde40316c35bb92b5c6732bd1596301e21c0f6154232962b0c72a177a16c9b4b11a3eb33a5945f678fdd29f95bc9c300a7221d3298cfb295cc2636d9041d864283c19ff9d936934c9646427d517d06781a59664cd376f01674b04d9edaf3659c715af9bfc4e32c129836230d29246fde2d20e8dec7749aef03918f06bfb62aa5a3f8d80779688e8f65207184fa0026789f6b5c8e756d3837f8ab28760876c687d729d33d066522b04bf89af95a7126ad998f259a55b8876a1185cb8330c7b95da1a98eaaa3664cefcb1cc6ca8d2eea263fd25bdb87d88da2858684303f9e7e2cbf9c09a08c1405f617c09ca052f54236b94a34a551d5829e7d9537364854fa106be4bc30229cbd3a56bfe459c0b5f26ffb3f5c148215175105876b1e7c9d727cbb1f885bced9f04c481fca39cae5eecfea1f0775888666c7a2526ad22226fd481089eaf07a999199ac065b63d063cbfba2cb3479b9a0b8bde1d5fde16d215c456e9a57aa372411feed3e0147c536e1b9c11269f8eaf1bc15c4136175230dbc3f202c873d9b60dcc35bed7b22bb7c366abe55fb87051d6ffa54f98758a50aac570bee63908451c7015b744121e60ca43a770e63adc4559da768a2346003a1b0a779a580db7183094f434db21c4e1832348e51e398f6c004c499402d45a76edb3b1a6242730808631548008dda25e75ac80221598dbd081bc4713ef394cd62046be7b6558f289e4dd83d1dccdfe78cebc0ca2fd509bec02b9f29b1b81bd67c3aa52940ff50d5980805184201e48e354c46738088349c383128c2ee810d6825a46cfd59cdc4b6b249ab99faaabfba860be12c632fa4f300050880c98e62130f4a8eeeac5579f44216d4c61566b5b7e67adc821390a6ad3476c17190bbe0d5c4fa63ef3dfa19902d4dab6689acc9029bb6623a912b5dfe05f28e6294e9cbf0a90a566b22d40f5fef0d26d2977d0a1da667a48c284e613703546f708f203952503cdb952a85b18774c27c6523f6ab11cb11a93f14eee99c28e07da96de8e2228081c8284cd5c7a8197af3431465fd2ff3bc60ae79e54661ec7fa8f8b9424b258bd1bf0be5ea409721834f94630215bd69a4d69394a1baade501e24c9acc59d7c67da8c3eb911092b88f0a47ad28efc909e11f8548d1dbe44667179e8fb80fb7522a3ce1a1ab521f37b6c1b0fd1530fe4e1dc76f0a035eeddfa394f61052426f522d076b21054fa67195ed05ae6c8377ea0c8138372325ad08bbb4313678ddb3d631bec17b63b89a7f3c4c1e57f6b118b86ce70a9b23b34e1cd0febc774e4225a6b50cf1c40bfae84d65bb29693a3d4675d98c98fde6c1ae67a4f9e74f0661aac5b01d2e8f8351d0a5919de56a6db30a2620a87d194bf5280696648600f0f2e55f94d05912da9c9c819f32d0258ad09c8ba802a1b4c466082bd0861f5c7ebe1c46d21b20b930194d752d265e5ace8b2653c96e24ef3804466a34c7b8e46f819559a80c41e2e60842839d19b506f127b2d4261eafc133f46c55e52d0751962df4e241c0a8ea28b31cab120060edf0c4c1a3466701917744e3733129c5f8be0d795dbb82b60fa16db97c831330c841e40b8f4e610fd4572d6ecc1560616b49bd91b0a049df8f9cbe5b0109854ddeee5669512acf7deb3fe1b6b3bddaf329d8a642168089c081896aaaf46bc1298811a17063205d5ec15abb5e33e2df1166224ee5f93fb1aa683901689418ede64e32d628c1bd534cb6ae9ca1cd2865def02a323e98e25cd3063dfe88df3c4e55c42a2b70b6790e8658d8b06abdcb9c70c2362648fa9044087941e0da9a3f0c4424a620f50a0673d56fb5f16aaa3f30e76ae0458e10ca6de52942b5b340d2e2e076b6148efdb4658c77dea516a738f39183245e7bb5be81730134cf6a07b64eb484023ab9e46fe22a13beaa44d5672cc22e63c1f76135932b1850c1ae9fd733e22941c98553abc222df479d6feb1de6ec0ee9e573710912d979383978028b603f888669bc435892f963273d8e50be953a17bd88c576269d44b56f52b7b7cdd99c6ab0f6287e26ca74546315feb12e03ed7088ae4655a2b629ee0dae4169732cf75b339373edb1c7525da56a3974f04635748d2697b861149eb2e662547b5810ebb885c6cb570369162ea41e1f526d980d17acdc02d3bad18a56496a4d1075bc3a496f309ae01e75619ba6fc884c8aa55e1a66094a8f67a65077517bc4724d120873123ee9ec7956e0231915ca58a4dfc5d1e65d592ce200f7b2b1ceae17bd359a3989a628be5e1ab3eab5dcff5dcb865300033d35661e3007722cbe0cffc8bde4726e1ba7a4e9b2fb9569b864333cb8c8657f6223a9faaaaa3c905c97a0544a097bcf6b9c0b4b78edceebabb4551e75bf620b0b693c2017fbe8174680c09a1680efd518136d7893ff7f249f41958a34ffb1175677b683492e987cebfdcb9054c9c181d9a7c095ac5f4c731d30b63044412380b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
