<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4a00392602da59cf4443e25ac71a2af24a988768b5f3befb431cb0e863bc353b8ec726fe37b8318d6460b50fa2eb4c11bdf9818a4bf858aeb63a0f55421c51bb7d01a4afbb46a101d68e5950cc0ec7ab0de7cb83f40ca990afc6380ed1ffab1a6d7678cc4fa09b24c5cc05748d5b78f9fb1b878aee823938ca1ab32a2e84eeb0a79553d096bd29c2c53a088436f7fd8af0c03376657840c2f1dd4c36e284f128bddd462799890dd9a33e899ba3a6fac3fe4689c3f73b475ae70d7e309c7fd9a6b598e7cf108d2eb5a6fd1a7db5d9a01a07241b52f20db03b78524476c81594867c5301532c2fae63800ef8777177d93b80c041c7b37235946991061d05fce8917f903ace367be30cd16e6d7ea58c50f33fb6f803fcfc6e9b8edb6edfc6e7f0855076370028fd597e61fafc37f5b5bda06436b60cedb13faa35f7e3fd692cb021565e48be49c5bbc7c0e76c07d0fc96f3780571e1b7ccd97bed37164f0a42ad77287b269781a00df4aa2c70116a20e7b3ccf41bb3806365210d63ef10d4dcf327983334c09dce45de47836e9ac1a20e40db961173891112994538b307ace7097b5fd8131c9a33b3fc05d145fef98aa9e0c685e1f018880dda9579d60f434f898da168cf90245e30f10d4677ecf614e3bec7bc88b40f24dd41b8a23f5fed6bf4cb4d0147c9abfc6f523e7ed382bbc050edbe095938c65a0b4609b8e0924081f035528459a5926b601f7884e8d21f996b3801502215e4cc4427536b996e59f27ee68d9deb3fe8eb41f5305cd17beb10a663175d6510bddb17a28953b7ab048f30f3d06002644056ce487b2da19ad747189a597fd2eb0df4c41af0b6e3e2fc49495ad75a3c1b35f343c7840afb43985814d685169459bb87cabc6717b3e5ed4f0034e7261a0cc850bc6134757396ffd11333bcff0c90c089cc458a70ecc73dd169849f1c38a107607006c3ea8c0b1f3f67f234599d53eca7c65053879e198046a1a7093f1704054ec3c68727fa5b74bdc0445fa4a3d553824ba8e4e0474b3339337f96ad8c714ad29c9709bbc8f32142e91ef3b59f94114d62971c5cd034aac3c3ecb1c71335fe497583d9066aef86051f2b5ae6b56362ffc4ee301998116948a5cb7bb7d4e16663e718d9c8a3c4fd28f6aa1186816124d272efbf9a5f69f2e00a474b31e8b8b7d0cd0db0feab3e3929494fdf0fdd5f4a57574320eba7845d5aa9aeba5fca14aba97957216e175cfe8871dfb5be20ec270d11cec42b01b4565e34e8a6a6c97b3237bb17c590612a943b2d2eb7db193021d46f5637cf79b07f395b9cf9099d111314f86c87b37ff0c0a53a4427c7b387f9845c01a095f39a956bf2e999db2848ba1af724bf7d625a2b16776fea8cdfdc026655a74313a532628a55a48ec83702f9586f2d6b4aedcd42922c698c09433ee4b911fa0e7610bd3c4cb5cee3aaa1c2c96b4613f24f2ba200c03f0304f86f959bd600fedaa051e3834c3141f3b293914428d7750db2fbfeeacf348eb24da46e6578b636b6f019fbd25eb24e365b89e843fddaa4043acbd519f9ea8249f9d8f02dabe04deffa110d0549943745b3fb2e0269ba73d2c0fd36ff95c6bc530d9e8d8453fb0e3063b1aba5952cc217932bc292482193dc4638aee7ab8932cb0465b01d6c23fe5a50b1f0d5fe1d3fe3f8b65437dae13d33a6e2baa0f96164fc8d753125f0001128cef8ca402401a3900103b0bc9a48d5e9f95166aa93f148cb8dec707de1912f9fec0ff3fca5b0aad350be59bf21346b7df3bfde640ebd7c38895b6b4c7d01b5213be746c89f54dcbfec266b19f405b7cf0a1fdcb0f45c050b0eb438a12f711bd1f835ae1c7ef28b0c683e3848781704e2918bdbbe2ee88dbd1b5633029b8757fd1f73bb4a97de7ab0fe3be0932f1b310beed4a91d95e10926b6da031e166df02950696fb8f006e0b24442848fae9770e3339bd54fd6a16562e6d7686608972501f1e4cd0454a7584b23887832e6758c4b1d0edef1fe03da271f3e3e245e7f23df69dae482fe3a9d0703aa9f215220aa6d9e8d1aef7ccda3e4f7b7d566a6b03719d28a75ce6d6d690e4a418ff68d30f679f8fa55935992c26451d2f4d5a06eab8660dfe531d43acb7b0a6bacfc7b09caf0a4e4ea9451bb61ea53ecbc1ac4909755c64e69ce2321000d6566c6a818a87477c9e62deebef841d886f5cd0d3b2163429c66dc05362af1e48a67d5e6a524286a8a1889c7aa43f9a148c78e6aeda87a8f63f6adc46869a81732cf26a7d979651dc35d2a25dba43ac42c01f549eef7faa00739ec78848d0c66a5288e5233deb0457bec5e3ec62c0669d3361edb0f2dd18c188d1c0fc8ac6a7bb3399e1ccdbe184102c32c59ecfa7dd0e189b73be72dc5d3056ba334331abda1bf2b2275f7b5103b07f0f0362b450986dc17a9e2f2437fa3e698f6c255c97fa84d6e6e0c369f68e504e91286d50ffc0b6205a5989efde8d1ed37bef06cfef19a2727469a38da078f882e80b3b2c25a721a1d231ca2935c58962e2e772d8ab7638474715f46827e7c81ccdca4f3454bedbc789ddc8fc59f0800ed7c1117468029d8a7eddac4eeddf7318a622ccb05c756685f77e4748fdc58cd170de0f93b415dfaeb54da3cca40c13b4e9a7f06de3ed9492f2efd22ed8f03560e1bafc661f4b26700d6d7b23cb4c8d888802d8dad5c6513747c5d070df464032363af3b0bf18cf4262e46efb524634f2278a6d8ff4fb6bcedf3df5c56a1a7843ae4efd22358e4946c44f5cc990f26b292d1d6bb7479d84876dbee8912a2bb96e196f2a86790ae4ca022c6443348c1a94594d1024c95062e0b0134356ce94f6b21c472bd770932ba3bf827ff03e8afb19ce91dc9e77eccd6489d7c00952d0453d93f7ee5a84effc9a81fb41743d0e8beb229bf000301a2af73cc6ef7b74cea44223453066e8b6c925028f4f5b7dca61060289ca784deacc648c9cfb408e61f04e1fb0cda3076575f74f1799c90d0e6a7672bc4741dbd6a8c3722b013b3fa589beafa83004f8b9fbc264b5e78440bb8a7273ac58e4e733c138865deb89bcb6a33906ee0a4570ee51fcf3c9c23ee19683fa2e879dc75d09b9ddd59e958163435702c1eac6842576cb7aeb3f9b8a1f1ea02271c594159698386736e8967b443694e5919283d52e3beaea0bdc51ebda11695d15a4af05abeea6fee1501ea35bb0df39037d5caba638e2c76e9e6ffddeb73e2e2b68baa65965a3958d8ca2033cee784dbc3aec8275086c86d667550298610db0dad5e9921d38ef6e770a21c6627e266b46d66a5d82d4a6c18dbc12ca256a4126cb1c3b55d6118cbef686808e8adc2217ebd020972370b8c5a0b67e339fb12faedafe753eaef579d4c465fbe302e983b99a2ca88943843ec3d4a4a98d3cbd8e41d75681ae6c81a4ed0d958bb846ac9e9f7c97dfb1627aeffcda1ec10fdc4fc8f95d4c3af932da4eef7f2c3830aeba9f4c8e6e8712ee7ff9bcb4984675105774dea0f29417ed05f04fe914b4b03ed6eb6c9ca16c9caceb0c8ade6846a862b03d510871532771dc86fcf72d1b651edadae15360ebd052caaf2904f888dca3a636bc6428beaab77c7a7a36c2091ddfb3552a0130e667c21856cfa8db9805a23bcbb952e1ac1c10f0ac9b1a7cc8971288afbf68ec2defc97b2bd0e7072720c7f339da34913853cf6fc745f63aaa9c7c8678ca25506aa17314409dd018430acc416463bea3353a813a126a99ea278f591384822c0586f85373df7578fb5ab879608c02e908d85d2ceaa2846c05383e4356fa2ca3b13a51ff9b3950723e32ff1285bebdcc4e547854ff0745fe2a1576b5cd9d8e36466b3aaca2212041982ad22ad60277dc58689b140fc34f798318025c236396146ac09cc38ed69d0a8622e29d9332527f9c77fa54d41fe3eb3ee9d6a4502316818040611d08011c3f6dd57fbc8625605eb8cbb9cef594839dbba56926fdb350e4dc64cba89fe810f9fa10f6a254b93138e665e263ff90e643c4d5ebe9f00b08c9b956b6b4af1074684bfa195e7a999331e8ac24fc0139c8298222e0d909762541863da64de51509e6c05d0df325697e0b67b783333dbeba6d08bc5eaf50c61ae1ebc72284553770d4910d288339d8c835a322588aac576e7d95a2ac04f26c698514000baad8606c21c0fbd9f5738f2d0c21ddb6a8d07ed41d5034e967a3243399474a4378e9c25e2c73447aeac8f5111fcdb99128f1a7389fabf5791447edd9b93e182ab39eab83a30f4168fe7abf644c77cfaffb1bc87bb76243a60f9b676fe84674b750e1de4a075f34187d22cb15518cff025ad2f54746e3243a50273557dc970d5627b6bb6e2fbf2f1952d45a9b86e37f5223806ebe92fa9b0977f386d48b0bcb52ef0be987020f30f34903dc404d83c835e4ac233f1bb9b3371a5e48c19ae0eb883d151039e2f116915c50eb5315b1ebc46530b6b7768d4cef91242523d4e4d6c55cafe0323890f1d64cd21c75c43029dc40428448e6958b677bbf66a688853c19e19a54520bebb912c57f4bbe989e5dc428b08acf4b8067db4afff40eba411e9872bf30198f873c54f9a56ac78cd0eea477a640611eea1acf25e52c86365c4a870979874694f7404ec56ec02574c5bd405b597192989b948bb118b70694103da247d4457cab6d06d19f7ef1ce5b2fb56c170e6564df398f106a76c1fb241564b868dbe3817e10bcc58ba7daa3abb922f4ce92ec1a8fd092ccd99f2dcb09c2d8fe01519329631b5a2282070a48db60f0d48c99bbc3e61c10f52def48a23b62a4846213db90d940b291312be358e8423ee7340efae4e7104b13d3dfaea501b4206f7fe742b0f74353b3be541bc7e991f312c7a70083b61b5160c32fac3686eb80c975df5ae337cf38bf84c5d517b5de6cc8687b6db0fae5c1c1d7458d0ea031a9fbb4cec23a0ecfee4347493aa56ac485f911769faea6321becd3505d6f7e1b46ecb4c0a36ddd60d3987c1b8668f1b7194cdd468cfefe486aa427d3739cec968e15f81c6e06dc7a8fc551f84007ca37417011094d96364bc18ac2212c31344445216752182c8c08baeb319be60cce6b52982a5d05487fb4162b1b524c23c184d038739cb9e61c189adae246b9ebc40a4328869f2c2ab202411b040dd8666b66583f6089dcd7eb2df9ab8f01fc18f5568f254df28b7a6f5fc246d71a0c2c912206aebfc9cc8869e1cba62d6d4c7c6553b7e3fd84bf43a05d2b63519e171a684ae92a40f555995e9a706bfb68444022a144685b91ec430ed1b870cb1d586fae1ac711db7d3cb475c9c6ef075bdd6550b655a97d7e8c7fba4a22f6aa923d42eb7f5fa2c3b5e863c384793d8f40c46b734637bb83ffb954d22053652b3883a7c5532c920c8466a2b1866b3ea945c85cfa3d519ecac361240e7ee1099add4298e2491634c96d21a27938c5b7113e84eedbf4f627e3f6339a41a262ae1adf7c9465a356dec70a3c7d248665a8619e4443923a01936e2743ff7ba9b873b8217a6195e7a345d4457c89498696ce8cbe8510c1a3337889226547e1d401ae839ebcdf43b3030be83d8117e217b4c6b085dbec3533e8450a6925ac901133706ed4b6c3d8f586d93f37e1534d55ee42774ace694d10ca12ef1eaa57fc7ebfb47eb229aa9897c7fda88502c8568c82abe2120eefd77d165dd50c23a27c1ecc350c0d7ac8c93532b41a2b5af28a54bcf521cf910993ee40372faf7eb8a919b77777f66c60f1dce333843f7fe35502cfee68e1e0b2ada0088f7dc6d2d55833e35762e7e123a8676554b8e0db2c2a25d3096404391d2d3f29c713a9baeac4799673844706e6c2dc6a4a84f11f1d73169d5d07935b0cb36737a20c950fe87090d42a87592452011c3ddd557f8fc869ac7286e169510c97bf8cdce4fa7470c820ae5cb32dbbbba9a57827e84b7a5dc8e4ff04fa8f597db39e07b69dc2e1ca2c827f659e075dc9f019213880b0c1300ae76220850cfd49d76cf9e40b348f056a7b1a86980179956719219799f7eb81724e8e4bd16d3e35facdd00d97cbb4b419213eb11c2939d9b6d5ce53b8b3ae3f3b2f7f1cd095719072acff7705036a44bfd823fc16d411e374bea841252370ba23c2056da5eff1cc31c5c861fe56e04c56cab9b061d90f2d0611685b8e5d68947fbc87ff1105b6fa678df2f2d250c1a892a4365d454bee5692e524693ca84367ed3a6a3aeba66f3d8b7ccccd28afdd7177dcdb3ee36a9572696c3b6a1ae14419bc74477c6e91f466a5d3e62cb947b8889f4ed8df52029394b71a9cdf843b554aa6d9be5130cb0078ae5505149c4b2d5f262fe8be4ccfda9e69e6ad33c6830e71dd6809479b887128eefb2e1c614fc6439c58aa5a5e34a97c1a1d968dd8717e94c148655a5070c1d83918ba439a78eafe3ab073d7aebf87a6244ab9c8fad3a289a02e84a802331ef15e9758dc3b7921fd3f7ee2d4952595ea55c8e4fed44d8700fcfa03770d9f45ed6735a34f6b88b5a569adcc5f80915680b1ae0590e85688da2b5060691b5948f24b24fbdcbbcc62b83ab9adc97947f746e801c7561f7c2ecf122bb0927caae19d2524b829e8df0dd788e333ac7266a27446c084d0e0de02d5898175737efbf0957c48dbd98c9bc7e33e475087119ab9cd0e819cec30c26c2803052d59ccc8bed4b71ae054ba342526cb34d4190a3439d8aeeed94ee846f1affb8d539725d4500f8c9cc4ee1f3f123710b5ea14a1a44ca6dfc2bce330afed9cf99e32c5278a9427883ea8b1a8f3f467030f2a3fc84dc168009b9070a6c993102e6f0fda31abc54efbf736a6bd8db0faa6641dcf0e62195f632bfe1b6135856fea0496d6679e92a12e7ebe1f74ffe17bb3e81ef7cc3c0e2a05b7956ec4835f669f10bac5e72cc56a48926d10aa5d33651c53c614637fc15124fb35882e8443352658e5eea6bfbb5440b13a141a2f3285da6718a91f1a5ba87ab63c099395243375e64d3be4049274db8c078940072128c0ed07c47d22643b26335b4a8e9799b6a2f6247176ad811428f1bad2470820ff6369c190be602aa4fd2d52de839d0e1e13412a3b05491121a6a4e4f53840b20b03a407ffcf447ab5757294e56a81d5510bf52a0a2ccbac8b7c9b439a2e447e8c4b00e4e4015d0ceb7b98911eb571c5817245fd18cf72581d61b3fc89c2f9f5543bb763bcaecea4b5b40dcd5c06266ddfd84d071e6d03fe586740640d1af3fa97134bd58b2da2424948046bf4e123664d344d7a0caa13306c1841e099b994b68790440ead83f1fa0087696c6430fdc86970a804571b70427bb21f23b05b3ee5ada460a9cb8a2e7e2c9ef5687b9ec190e6eeb9f3f3f04b5c0f2ef5abf85029c2bd702ced3269075cdabe5989e37cf75328bc514ddc52dae55a56f1a21ca24061dbaafe5a696e73366578f0cd2d11a6a9383237c953b3954df74af57708a3bf84055bc1cfcff249db14349d8a924df182c06259c9f42ef7ae8663f1adc38af36563b050c58049ddae8103ef6d5f816fd1479de1b25ca6014bcb6792d41a52d3de3d161e48a96ef4e1a02a970583329dc37c49d50ad4200f87b113c44ceb7e696b83fc69f76c42db68c0ab91ecaf9ee5dd375b81a97cc016aa655e02090d646f8abb4e4c13e1817ff4b11a2f43230ed94f8874d82aeeccb4a9415df9808c5dd071660253ad4cf985aa41dadbad4ab841b33e6b78dd88954dc097e334868777e014d9616861c0703aa7af8e52bfbd8a8e48c9e81cbcd90a1e5206401cd08a27aab9d4d626bb90af44aa8d82f73f747c5322c1043337ce12947f07e7e2f116f3807a02368f08c10a8097b93ab61f59a41db02aa8b62d382e970ebc2a9654db71bf2f041d4b20df25294b47c1555bb0466961616f48f69752de30134623f77eefc608064d0c5ed70db76348f23d3d5d9d0d0501ac7b5a76e813282b2b9d3e2e8a464d7504ed0809a018783ac02b3c96dee71fe9454ef63460506cef93a7d5bedb90a46ec31b52b4a21ce4b969d4999919406708fd50da8edf7df2769e12a527939035f671940b39927eef5db314152bd2f5b9e79426f660cef18b7ebb7d89a28da01e26b1d87583b3980e3683eea746ec86787449045b4269e4f7deb545668f37a5937773430c5f535c77ad086c180484e267f9bc01c8757107f13ccfa4f4c2dced896819955f7e94b5fbde8f717754a64eb407b1cd9570a7514ca46bbb606d2c273434cdb7fcb97a2d0d87bdcd03c3376538c3ba8992b17e7beaf0ecbd05bd8b50058d97822364529f6eb9676dd419d933555a52a59a6c7028240a87ed8c923e4edf72ebd3b5c4ada923215f87d0f7e4dcca2d97f4466331c09ce7891fd81eaccb67083bfd3fadcfab20b2754f77e6c1b52a0c9d7e87577e4454ba80a13bf3907eca69b334d75ba411dea8166ae65db35587242c2cdc4823f78bf1904ed70cc734fc25a88597d32b0f3a4255cdf65b67c0802520dc7cdfb8bcda2ac24c4aa1e2dac4e09dd6ef89a6d8479eef60339409626d12faf863dbb7fe296e676214e95a432e870c425c3ebd20ce3dcbed8ef02ea7eb00567a8bb53361e876058dc6c2e5627364e964dadd12610af587607a0836fc4693093f9d7627518644c8564ea9ba370e50c6ae19e7f342882e8d2f0589aae211d4e5adf88e8c54f254eb2840e8798d274dfe8375836e0ad9c4ae769b8a703ada597c3e789d2914cb8264867e6844e03945ef5854290c6dd18c12a0b38bec407b209e6256eb7677768b84b5ee47e9a06fcc6be891ddfe7e06beeec79e6afa61f8b5f18d33aafea0b81a7ecd5274d3ae2a9b125f74a6ca301d5942fd2e361ca1669fffb68c4c68d07b4d75e5a90ddc8b7dcaa1fecef3c719676b5f32c68d14199b772b0799a7d680ca8f7490b06a6a4c013209055347591cf3104018e0464c0cceb32a40fb48de0a5703150000ccaf0d2720a75278132555a13a60bbc67bb2f076105eb3a546fb8f096dbb08f68bbe9c486ee692bc3fca72920975589d3ce87c24c35d47be66b114a5e7f14c1e0cfa50adf9164c1df544bf30d32e956e18d44ca046618fabb2716b513e73070732cb3507e8eedb9ca79986bb7fdef592473231fe309a89738a4cde17c668b3ed243311d2d4c225f7491f8d51866003509175912e5194f141bd1a55ba63b747efe6f89dcb62fdff4631313327024bf302a2c8e81196e52431b6de49086af269722ef7e34ca6c3be82da1181041081eba7f2f1bc1b96cdb39c4e2bce9605c598fdc9828571609bc719984d275308971cb46e926ff20e619423a5cda4b5ba22d79be16f8f3bc5084a11924b65f7559b784bfe146481d3a66a217b2d22298fe23ad339b1b4b33d8c9e6da4b9238691729caa16b8f6ab6bdf70019ee04bd28f55b35e5fde200f232ca23334245c83d92c3cfe307385904b865026c0b492a3ed7e1a6eed0f12af9286244bad7b8b2550a0c5a693f0326d984bfd648d0093b6010fb8b839f7d5a5bd6edde516c2212d72ad8348fa9ff7e78a4f571abec5da9031aa44024a88abb2f266c64f76715bca11c79f3c77522588b94e6cb2dbaf242fc733c6841d1733c6c2dba4738d1079d4427226971d7db9774a5e8d1859c8a253934b70fd3f3abb2013f17ade2ea746a66211e085148c59b858e3f1d5a7e7187398a3b6eaa74c5472b8af324b97d0fedef66ed997e8f1fc90457e27130a09d312439fe42d5b784f39e72ab8eb525f17aed109247a087003496867db7bd2ecc5f097469dba9c096bfc993e3a99a802e7b2056558a2174878ada9e043ad399fa6b250206b11b0f204e6fa86e4dff7d06b3eb32092d517463b2063ac5f24b96b3112d49926d772655d6c66a67c823eb856e8ce976f5ca7721854c73c01d74298207cf7e3950053693a7003fca20b4d1d3f58c2ace4ec0d1d7ad2ba8148ea1f583083cc8481407e467b26b7c94d9fd4ca2d66c8d934820a7ce2e5441a3237f44e7210c77484d64ccc3646e0f5b36b6d52667bf467b1f32b90cd93b4a3b8a75bfc2242aa90e9547171661d890e57fa8be9b9c4fbf58f030e0b6e5ed0484b4b228b6a609861fb7279e81ce4ebb92d91ed36410b341eb721ce526946f2e928a5d0fc76148c91628359d692a17f543f6200e6e46fada24fac7065fd135ba913a13e58fe83d582bec8f13c7339f05526733ee0bac0023c9c75face30f6b715b862ef0470a44efa93176dc4bc383ae88171f33dd8052f07f379c2bbd037f5932fff425963690b6d40bb1d0535f8d26623ad5c8b350baa9fef3f260c003c9a2493ef3bbb9f767763dd6008a2e836da9f9cf406fa3eaa6006c93d6fa7e17e2bc3efcb3e2e65179408c8a678ca4a4086e1aff311dd355801f97671ebf07fbb33cddfa515168c2c7d8178005563253a808b06c8c85af1979932427dc9c5463b8ed76ccbf452b9f0a67d679d7dda104307bba5c776b8b4b91ba7320e824c28ab8b9cd2b49697bc74f1e1e34a56a5cf2907a182348d5bf048656490d28dea79454621a88196d89598d56f9a652bcdf86349c3335c10094516826502e612bf794c274539ee0f484e1cc92e64fa89f9ddd1992ad82bd28ccbc2ec98f8a6a22a07b0a368ec752b65ada481fdef9efe6604557fce4f43eb11c72813efbfe15567afe033bd84d208eff263163d91b5c78bd0798fd8672de119c8f7849d6e27c6da58bbe0b878e7f192a4101b37d4c670c5882dae18d0bbbc21bc1e47ab89fca66e2b38c7fe411c06d3cae8150ce5615aa1505d94755a6674cc34b21bf05ec01deb00d3d6095fc5cda7f2f6ab2aa1f5b37f4de1b6bc7b414f569c1136f7bc674e665959fc13f36b67c769f9d709d35d4259c958251d27f629c860ce2756211683c2adb73bc67eb972cf600d434708c8b43ff62ccd839cacddc8cb0bf1b81aaf66d02bb3bac7d911afe2b843885fcde2c2eadf83a82ac88ad15bccc5e69570a164fd1847cef0cc3f22f11279a91842881bd669f3d9658e3f94f828c5eca75bb91bfd526ebaed913c61c1bfe172419c94755f1ac2a7e200386484dec3439f9b5fb8ed7e32e8483bb6dff30a81656b2ced6770fe4aee4636dc152a6d6c5b653dfa927c8633ad1270e9a1bc120f06552fbf086d65a1eac68b522e51cc9e37b2bbfaad12eb0705c63bdf97886954624cdad65f6c6ceed5664e49091d876f1d0a73b0298de352481eca563786e7352d2510b76f7e37f05e8563783edfb190e6644aa82eeac3a943b29e34a99a55dceff75429059c8f0999b56713d43cec7c12f4a0373fe0fc985a8269c9b8b3012540d6cbe3e3217b95de8bf0e953c73bf956b7fd58d60c7fbcc2e177617a9e009d8baa71c6f1f4305a36c1998b757183a2d5257ee78f8cb03fdce7a1925d69d6506a8ab062e39a2cefa4fed254448584a0f93f761d9cd8a808eaba5f01f4bf8ce3c0236f0afe0b141a0fb7f25e910f246734c36d84a9afbd57befe9c265fc6ed26157b04a17e60af2f885be8f02ace7747c9fad334e3262ee98d55a4823cceec9ed9c73d51dae42952ee6ff84682599fea4d5208f14cc296f16a56cebf3ac240cbe6e3dda11f70541715976c2efe711f215d1310cc99aa2239a2f1f6e6149f02c7123242086d50b2ae2a1f47655d6f8ad20e32535591b4c3fa67c23334452f0c4e6f633ace0aa9c2e30d9eca11c93a6b85ada716f7e0a905cb39c9dfb640a9fae2a0746ec9b4958ee913664c9daebb76aff5101466eb1aa017da54ffe7fabe14a3aeb9d9710e7d554edfdf8ce9e5eea87d1fb7b167c560c3739895f4885f15cb6916ee44f9004481c7bf43185e6b9181b2b0fb39de523dcf6e4d2ca107beaa057bd923953ec7104299ecfcbfbb8c576999493d8df9337af8f500f9e58b59f693039fa5c51be734b7e7f4d5a4cf32e8196b5d39131980b6e4ee643fafb9ce7ee6e8b3a57d88f43e4a889f38b1d25089c7cca138c784734196ff87e49873b6fd235159d1e08e6d19053e6e9e340b8869238e8040f284c4503eb10032dd469a28d891d1356e3e7c13c8a81facd19585fb79c7d87b52d585d5e93fc385398a35fbae6dedebdf87e162c1684d55397b55e2c9b27bd55770fc02b5ae2d31e00ed6e262d80a38c29171255e88feb61210159352b0fecb88876306b24fe85c6f19804a4619c125b7cf17b7baf0f1883c892072ca1a0bd8bd4104b495c1a1ab53d416cf78982d8e62762b005e976c5402cd37c992d8c56847ede97b6e33bc788d5ee8840f99d4daf8a77963dee7233a959931028572d41d049b2940d93a1a6ccd30b9cef01bd89cfd999276bcc4e0095b39381d72e9b7edf5fab8ff6ab8b84de0d17087b75bae66744120928117fcd3286df44ccdc7fab57de09ead57904b2c20590e8f8e476db050dbe20c30d983c78b04ecd0560dbfa87bbd563087c638a32b7f34dad4340bb5c4ad752252eb216c2eeab169908546dd7e08f314cea55be1e85b559d212b76f64936210930c1dabb01846e10ea1b5136988c851670ce3da489675a6d5efdbd90c193a987d7332c7d8429c55a5e3bd4ab0f1cc29fdb7ec3efa3d79f46640bf1d283dda2684f58aabe71b3e3d831fd4b31a6f4c16c9b005eb732ffbee707d9ad60a6a063bea5450bebddc0194bdb53080074730758b54527b60a24319e66d5ae536da9ec99358384c372da39315b400693a50bc8ff0156f5bae4b18ddd888f891f8660f79e9bd638ac550765b037286388fbd8f32defef6cd3ccad9959a70b89a0d15b90c6cf00f80bd9e6e83756874fa62dedb06b62310b3597b62262dea0f490662ba3c0074da77272bec79043ce62cda043eea4324d4f63974e70c22aeaa2cc3c89049fbba60186f1e296def633229f83522460c2bb6df225ba76fc0640e90b70ed052c2e632ec7b606da2cfd0ea3d61752c4d5404f95d62013a7f7f5b457486337be3d675d66e935bd84272def381d52c262f545f5b5f4e09e56f860bcd2b09b9b0a8d57d8f5def95afff9eaff0a2e481a4e564a3de896ff0981d4b89db4b4201bcef5c1d341bd59c4899321ba5c694a99e340803a577032738cd67036b32f7285fb88f122602952535139eb42554dda2c399cf815afd4555dcd7ea0b0726c47a4e976c5a1bca0e2fdf6d24738988dfd0dde877faba6f063e998e0355395e8a0d39fe378e1eee3074a65b86a452b48818810c852a346832afce8ac9aa03b8a29e7e443e1d6a46a496857ba6d8e5537d91c2175705c2d4962449390ed5e9fda1298d4bcde602300643da3b7233a98b270015630bd217589e585cc0da054a6f4bf005cac1ff6d7706006197203ecaf3c2a96d1ac990ea81cb3d6dfe1ca558a14740ad26ea9073ae81c26a5fc0badea281a3b9bb933d4cf21323600ce7116393f72394bfeae47bdcf588a0c69ee946557a56654f3e1afe16312e75ccf765a915a5af5a69d4dc13f6d8ad5d609631bb48d325ffbd4fe1cf419a9dae807e9607a3ceffd648ff13141133adb1fb27325da5a38aa27bb58686d7dd14453159e589dd193e62e4445ae3d7a19f8b1a67fef19b37844737eb8627ef8b8fe8e68e400729f7df2d0eca404b618d20c6a83975c8a1366438cf96e6769f441c44e7810380b7abc57f96edaaba57d7c42ffef0bcc18ae5526bbfbd37eff6ed73c7e783f2b65cd1fc699646c8120c4c1c35b9250b674d185cabfe9437f35207263a904fd876d68fe2b77186c5b276bad8ee2b6d92c81be7e990407e270eadfdb9e7b7fed160b54bf5fec729518c0fc3e443a5b2b988a3056abe9b4d34568c11be9904c28674610a912140b43d4c1b68f40933943362176a1a7152aae383fddbf74261f4ef7037384c4675b75806031eba65a1467163e7b4d8fd3ec5082283eb187a9eb56978124aa3fa18d96b8b0d4e1c1c1da87b968e5fd60dc39bdae51a672847264fc9198eea6473c3d0492c0a5a8658384f2b05459b08207c18bb7d8628d625a749cd03bed1b7afb6f2b80e338f49ade7558259aa874816ffff987383dc2ffe907741bc0602d155584c820c52012e4968fe41a078a91c7df9685a4e2a60ed872d3f5cb8143d799d96500c778016fe1913b90c091b4c5e9ae4ee3c1a23ad92686e333b93066c1697533bfe448d5f4a82beabfafa26dcebfeab628cceb22bf939a360e7225ae4d9642bda6319a370d98cfb54b10c74bdb7cbd5dde33e6c6dd0bc92db3272500746b2e1f68132e9bc12d5e2d147c3cd1178dbd28cf3dcba2a447d09e1a7c6ed31f9eae9d7cec2e995252205cf4a4c2cf89bcc2ac5e3df8be364a411cf71890dea9172cf73dfbcb76e5b1476d4cde11b80c9dce119bb37dd9d0adaf61c25986958573ec1718fbd59d3bd3651024af738a8ab9b779358e020e7436803e5bdcb45ea28e1918d4403a4dfe8f890ff4178495b3807d854c49e5fe686b96e10628879fba28992f51ac8bcc54f1b467e813e083ac789168015ea24818572468ee0fac46029cd432500eca1ce2772c903175b9049e804ce9008a4b5f4d30b29743950b91b3f846e676f958cbbcfb6b4675d2e6a1322c1cfd3043e0588526f5b2ae92c01fdf5f2e6adbfa92ee3a5bb75c8dabee812e52e331abc3f49836013fb49e22ef13118e89062d489a4d6ac383879ae1c7ef40a0fe7f2c4d39cecc6b312961fbd98696aa803241cbaa8db0bf6fed57c6c357d7340afc36596732656d25c0b984f5f1e464e8051914cbc72e35d0ba7745ba17773219b581eedf7eb19915f0f9877f13a3607074199143c39380069432292088c45b0272292a8cfe77e4c2c1822543611ae6e333d0efde110ecc581fe1654e5e2b93cd35a87c0cf91d9c20f2f46a410d4ac44f6b16cff7a1bca539530d1da9abf8580516394c9575f9e1e292eca07fed6daf24799c3da24fb3ab85636ea9192dd0e4ba028e7265787ee3f4a1fc2bb1a3a5ce6b2a14a4e021f4e36357564568892dda625b4fcc664d7f5d40e3a066c02a805c3171a324632498b05525306543752be2af1d4b2347b4808b02202beccf39a8359ac7fb45378c0f9fd783b2835b18e3d39a655811f60fefbd05829b8fdd8c52953844e954f71f11ce3d20ace7a66d675f2a41990ecb50297108c7ddb9a74ae0314c3e081d4a9f0577862eed96bc43cd58e4979c10d8fc4880b2658dde88a441240363c7d7b8a9dba5475e0ff0468591aadb86a356e550f5939217d9fb288faf324d2164f69fb73170100ecde5047fa69a6004b23964388028ba9b7b729e95a8924544c93ae7e45936dd204e945f0e25178dcb2a0420d8d7ee82d12cd982b2b2038081adcba7d0ade2f98f33436b2e9a7b2cc229e3c7ea7825e5901ec85c2aa585fac4432e4c468489ee7a0f15d51661d49ace00d7f75f56141dc71147d7f5da46a9b81241fc89538f7a7d13e1e4713a4a12e155893bc7dd5985c2987476988352ad535343d2f84f61e621ab4a0b2233bb13bc818100685928a181fe6174a6cbf1fdce53917b8ba89d72e8a7c8d2b01e2f2e32a5013dfe3289c42f06d328c2166a7c74ebcd907e3cfd6d0d2fce4f9c35deebe7fbb92375ebdf703e3b9cd6d83f1d68cc8833e24ca72cc3a2d4d1b8ddc950963e450def0e55a66c06fd7f7a204187658acb0e13663d393c28bd62a9c1a8b74a225e5079c3ffaad12d6fe094da417eaef43fc05da0da7a3439035f986d349355ed03bbb580952ccc437e29cf092951c4309bbf217f88896182f1427e446e4ca8a70e8548de31447eb0dc2ffe841c202bafc6e1b308f123228b086fb25fc60b30a72db512039defb3794e78db10aa33060d748f5a7897b490f746ea78825a274233ee5b9853c7362e288d02ece0f503f3f2f4cf08fa4f255a5d769723b5c0e89c0d469bcc65c88f296153dce9adbd27371d7053b1bca170dedb6db3bb74bc482b3fd8743797c845be0504a3aaa33f194ad64f3418a428080f23b1e907eb84bcec45603bec89de97c51b27d5ba4e87e1dcad19403c9e35b21079186ac0f93d545e60b7e837f336e80b5876f26f68ea1d9a96e662735cc06269ea4457e1db948b4cec1256303758417f745eea857d5c9537dcbbd8ffc5b2dd92fcffd3bd0d56d5d384a7f6a1e729c376d0625bc4892fd811a0e146990535bf6f0b44bbd53379ba986776188e73f3e9d3d13a98e277a9cca06124c5aa4c8415f77930082136fc9006a48622aa4d02655fb250e2e5ccc0c80353b177623c307fcbde698a4e353757214b72ec93a5b39da0af3faa618b479b4d415fbd186670a6ee9a62fcf9392bbe81f6aea7e52e0cac0769e485522221e7206ff225e1ff81d239aa81473b914ebab0126408372a0fc882c78fd7936271a1f1861ecd36cf3bf8e1e9e58377c98a4004cfdc68caffd8a2b125df7162999d0b3395e37ac1f1cebf78846c46a34221ba227091af62da7f81dc721ee27cc5d55fc6e1d7fe7b4c7fc6bdfaa06dd39851e3828c564ff1cae6edbc06afd9fe4248a2248e7922d7c0874b414f71cda3806b60e086528d5d62478481bf8f5f7b32fabf342c0a9cfbf2ced077530a7c67e61b9980215ac2bd4099273b9f2a3b821134452bb23fbfda1c3244bbfeaad9eb1297724ec39fa3dda7495db382211b51c6465bfe943df187d599245e004d7df4cd8e0298225bd0ed2792eafa4ccca0a9e443722cd8b35303c8a5ef4074d98dcf09616c3d8f18c1912ec61205e910ee60884283c7c1bd640f72c88ecd9f03a8e706b1f7f56210f0a49a38d5520a5ef9062f1cd00370d678626b4aa8b17bac676d428f729f63f385171d523a229c10c86ed828d23fac3c5632c855cd6bd91be244e3cdb9a9ec83c2fb06ece5db47b31bb99021265817fadfc67c0ef86aebbb138d57cc5ca34510dd800eedef58691d57f7931eb38aca803857b714f3b7796f95e9d4b33463fdf3fe119be66130c87a2ff5b51664cbce275444dffb2ebb469fb9ba4d1837510aaa38cd3d5a7f04dbb1192132dad0d422e975ad818ac7d4164abd7632003f6ae3c27f4229796aebd35eeaeb823b790bc6fbeb7cea8769f0687b528808dc615035c0ceefad3c3f29d8b3b23d70f5d42ec5acb3069079e1b90ee7846bf15f2465ac01f1194372dd6d8efe9125880bac54194b838c84612f1061419199e960a4addd8ae59654e33541c80c86d161b03450a0f9c2af3f903398478d4ae6abe4c1a76ac58f33b24cfa8f1b13986878bbb3715e90d170b2680e26d773b9a37b41b024ef5b364bfb9f04b6e86cfca1e7bf5f3379a32e162073aed00da4dcfb1b342960e2d220ccbb2272d0829e60b6f7c1ca179ea9aaa83fc61b5477e60d27184e57ec601fd5b411ac43b45892d26cfdac4d19c26a701cd998bca9062f85fd9083ae1fbdb99e4b65e98dfe6477bcb9e79d41eee9164da628571577ba81508990bbeb34c4b0efcf58c7068f9188acc221ade6b7a958b9c8bd4f670b6bf1aba50b8b69276db05c92f96ee815b2c73d555549abc4878b55fa8d0fc0c934098dd90739dbbff023fa079ee9718f1a8500e0cd655eb6879f0cf2a26ac28c008587c7b7444e058be20ae0c05cfebb063c5155ea5fedefc1e3d7bf5ef10d749ef466ce7816f836ad0f6d8f31785864a01194b824b1f64f94ab1becb668015be5dda0a9f3a7fd5ceb2c3ec08416eaf3435888ef486b0738e076583bf88750b5c09dcf6b42f9c38575aaa111b376454c0e5e60ae3358ffcc3283eb89ea242a6ae1bce223c8d0ca22921c0e206c7f5ad13bcb08ee12c19ead27a8c66fbb89d17c97b323cd0037ed1310ae54729ec27de4ed61ed6fe0a29eb6c418dce557e6f38ed2c555473065440161400f24f7870363f65646d28015ad7b847a04b4f64c10fc33a9a24345fddd88583f5eb06443a2462282eb6f1f9218e7dda6db29d35817b0303004241d4dd3ce2d1dc0e9ca909bf32c140748c2c5800a5660984fc81a0651280f86a6d5b74e22dd01ac45bc3e8ecf2facdd684ad8826cc5e7a884ae8d18592a84b44c246b9d222c1ecbedeb96e9cf39b91fb90b199a5c28a41646c7dd653fc8a9115b1c7fe60391","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
