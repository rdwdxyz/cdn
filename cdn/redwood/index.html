<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33611b022bdec29b73fd19ccab763511bd6f87063352da320834441ac766c7038e9b0e8cc09b32f3ec34d10f4d2cfc0d8f43e504a65f13cf7765948f6522aca35385ee76da22f3c46de92be7c1049c8ac1a793e38a52f0a9ae4c1be18deecde91e2d7de5803b4f70eaed18ee56fa15d84f4f159f7e0808ec660cf7640f8f722838622eba2343d6bacdc8678fb665760c10948c9993c99e895a642775d4c0b503853222f6aa6c8e1281fdc387d96b71ab3354d0ca9c602f8372a6d56e515ba8398859d286e057281514843930ddc3ace39c8debd366721f6ea3c79ffb5e58b03bcfa6ac9a8a499d3cce9bd42245c12e0c6c75c7189d21c7de820b64ea95e22beb26b0613a4553fadda3ca0e7ea5a48fa952de13ce56e593d9f91929034ccb37e7b3f350bd9fcca88e115df18278e7d7ffdfcccd2eaf1dc24ed7e4cae08936975494cc1215510ab01cb2656ba356cdf55c11445bff0d6b25199b1cc77e4d187349379389f42c503cc0891d0aeb88d421bd75c660b54e82ed1137da74ff3cd72f3c33b0654a2e3a5d029fa9ce659002f45246da98199a731faf662e80b3c45488d9adf85065c1d15146ac18e93af2b3d83e88a20f2dab0e9e1a672b95202f3b5725f7571d920048f1a0059715082e868002956997b9bea39b0d5bb5c4bc70e65c5e9a5bd05a1d5fa2dd71306f13a7f2693e63b024f70361e363ff12d17d705b456dbbcb5b653446a6c25e31a0762bce4a94f3e26d575316b819a0d58ca1ec4b3f452028b70c8d65b640e5fc2af7c3c380735abaf7cde434e941e2f0fe3f95b7b6d280a53f5396d75ca34c6fa0dae6f863ea314da700c660edab6849b7d1fb3fe142de1c7b24435b1be71ff287ba31b32baec7511e6f0eb1fdaacdbdae03cbb9242362cebbfc21f77a568a3f6b99740a1ca5f99fed742dd022621260085f70f45933845b2c535cc11d7c121dd343b61c8f7a5879df07ac259b6f9990610ff6a5425db195c48e39634d3cc48ff4ee720697a499de1289fb1f1630e5efa9caa914d5161b0601387f05e2f4e6bab83fc25fb4901737b0ee7ba6fab4ff3ba86f74b39c018bee1f327dc7a63123abeb196d36a1d267930dc3c8fb9169b65a63a83038e87620d74322666746cfe21f63666f97d4aaa9046e76a1216ff97d63e2eba11aa20519bd5dc7dd229b3129c137252478875f847af23744b5c11e257c5318c9c86598e422af0c9e714d1d05d2887e48cf4c628d4e7d2d216631550fc72d3c40b6874ad75860d2ce815e4d768aff587e51269210a83050834785d416300f4bc8a6ae56f99f0704dc4a28fbbe76a316c5811a5e1f9032f59b1214ae635fac9ea7b41297e7fdb00a2d87af2168311bdd1ec2c719ac7aa00a1980cce9f506765b7fa98005b9982fcd6a9482251694229f30763c21a17f7336a2741154dae4ff6f0c5613598ee6ae6455c0dbc2edc5ad2ff3aeaa08624ea5cc6af5d88391239d50c18d81e5add361b38e0fee998ee2eecba01ddfe22a111eda3e9f85aedee34bdca8bdaa01e765d658cf72ec942cfb632e98ba607b6494330186b23c515620331c5e88665c03397d80b5d797607130aafa35f3e4ee6bebd32297905bb965300174422adbb45ad8fb9e0a7ed58a68e0ea8ed82bc7f1ace35652d2ca210d7091561d577ed1125369ad5edbf36d5882183fbdab0250cda096c740c89b4dd9aa8de9d048a688da3b5f1247c5f485960eee1ad0f6f3ea29d8f774e76540324de23c0fb6c42d95003ab7ee9cdca40d2b9a74a91202d060cf151294eead3342cca41bbf82da24d604617a79e93ce193f2ffd695983e5b99e69b23cf6c1d25de296dba6c6e7e4cdb93d2791d9032b763eb88a5913070c126bc8a36f92b791052f4791bf78660efdbe2efbc03a12fb5e5dc521daec2b4053c1749bffc87ffee361bd50069497120aa14215c7309cc82af1074318b6c1a7a9220bd3bd863d5f47575e821150660de8c86990279b6d32f74d23b797c8d9df162d5b9c8927f0340bc21da3ec58e72e55bc705a622945097cc2789e6c9c7b2acf6d983e4f44e808646baa1243f42b2739155f9af034a1d8590b4571cf99e06ffced20ccbb8a91aba16ab1cd31c8a9374686d6cfc704371f2f89737493698320759ffb9d403cdb8543f9c1f503c3be195161ff38b935c192b67df2c87217740da9670f2acfd4c83b7c343412d8bc20488cf250dc2de6a0f8e5156f15e2adb464ac0c7ca2e0520b3448ab55c1b42062a8cf1adb729649d62a6188e32af45ee4f29830013b5feff1c34ee2fb478153fb58be91148acd810c5b0e2d83b7ae886f3500754b8142042be5a7f32e5873f6372590793cb52b33d9f5d150a00734d3dc5099f9fc57e6a262af54b42efba497e5f5fe5f42d25e2e6b8c9c171a6a474fffee28fcd23b63b4911e4e9059448cfde9fd6836d2e2a70202744b1223dc4fe998bc9a86d5c6308ba8c3b54960673e9263daaea2d3a8601262849bee3c3db4a7f494a997f4e59816439a452759e4f6ac567c320bd4cf531b84cdfee41b1b4ab932e31670f737b6b20e580858787aad0343090be682002ba06aa317297c49cc74dfa5d2e8882969de2096e9cd1ed65ceb529645e6cb0e2b13303cc55559d74349e911e9475e1ef92bd24ea5d5869c887dfb5ef5034784e9aacbe2391431069423e59e6489dbb475896d6c368a0919085c63efe5e6f100a5041af1cceef7662336ce1ff186293f25fdb46d36a5f691ca6ee5ba81d3d7ff40ac601d10b936c6e025ba3c53fc8ccb6fd3fdd544549eb18d288d9f4def36cb579df5ecb7425f59fac7ff0919b9b8c04be5a00c8cca437748b5352c65dab79ba50f191aa7fef5c6700de6a622931ddfb8da29955b449f98ede1e1fd4c1d409eda9ebecae3ca7c194597aa7201019eea4b9a9c749111c45ab3b04fe476dc70b46980c6cc462554c56f4de35efbdf73a3a310360e984d576fdf65172e0d035b6e4a83b96db7b8276d2c0da0978d9204497f23d676b304c130f9a97c9c702710a770e34b0af02456aedf62d0e70fcd405fe9778290473dcd810e68f0cb882fdef87c6e51976c276dc2a714237fc22e156f9f50e8924a52d24b289059c3011fb6d0e9d2a0835d9cf7e703431bea5d0b4126c8afe7e413cb9ede2eaf68f4415ccb3a1368f29164fbc71984e1641fa6fc704e940817b913861429583bd7adb88013f8c217162974c95c3ec73969f0fe1665a59ca5909f8a0888edc2638bf6246cad5a71ee595211c0e77be031aa48ddb76624ace943e30ac73ca3d5f81dd045de77e1223fb62037eeddbe09435052e5f550ef2b64e8fbadd77be5e6c061b1f107121cb7e7276027824eaf3535966d259be3996002565a23fc4010c581cab858169901c8ef2d88e4e6b7edf907975141eb6f4ca3749aa77d8d8a88763951867c005118b0c0853c91f0a35373fd465e0f726bc9b30e3550f2707cce49fa2758e9a14652d3a127d8d6a9a22ef44926a828e257d6bdaa0d41fc41fe71f417f8adf6a471c51c2a87b435f75be1958d0ba8fc5578c193dcb981e88cfc25148ebcf03684bbb782ad76197993714a76fa660196daeaf8e6cbb85974461346a4fa7da89f175d82b99d5c6ec470c43fbd735d2d6a545c2fa45cfee0c6522e0e636e857eeaf5ac2f07d5391796a388b63cdcdefa0c3567b616c05d64c49460ae9d54bfb034750a20ef052fc6890494f5ec30e73440cf1ae618e4eb3d13b38ea5130d11524b617edb93a5d62b644436a052be4f45d8e3464a2fcdc431fb76e9da252b5e6891f0c8ce0d7c610897a57466b61c54be1908a6ccd77dd892a07c7093ac6ae03a7631387e3a221da5ee12d1689207785bcbda1f4560fe0eba57aff962c614facb8d57978917cf638e6035ef04f5ce400bd6096e08b64f2ba67726b3020fbb94578baffdb08451b0c3e9fb3ba6ad594450d774549484172f140178bc7338aacc4ea1712f409d915dd6423e4ad1c23e609a615526f4a87aa8f2f97dd7cbe1ed3f0080416a5c4ee56c02174a37828c088e2c518a90cbe3fd08768c1c29ae9566b4cfa597482010f0a3e14b42350d55edafb5cff633a09240901301bb268bce37bb8e419c6de312790f4c0c6825997a87b87ccccd56c646280cb4d43a744f6ccc22104fbaf0bc395a69da182dfa45230d6f55e3346cf657be5ccb192d560b75cd1fab7d3b8a2d9a0d909fae2478b0d27ad2d42aeb5e3af2841d4d59473e5adbc13d69d93eda3353bdc4e64ed7b066d463212b35b87e650d08f5f65c437393ce100108b81464aff08a4813952b327feb4f8b2db464e92f868a56a1fb75c68c13193f11fb84d092121c8ef666821108225fdc4de597076aba6c90974de75b0d146da95d6fccae05a49ee8cf85560113e4c27f2a2ea0977c5fd60e7c6ab78c6d0b7ec7aa62ede0b3fdfff5eabb0cc5e3f88cf2193dce43f7f7d58f216ba5e776f4113c0d24932111bc13ba155c2df723ba78c5b39a33cf37736b6aa95685ab10f8ea1a551cc5c7bfa7dcc0cf829a43613661c40a8bb6cad3f66d886932b55ca6bb28c2c61073e81245d8b7954483657ab400b1e9a1f83ceeb583cd56155c85ace5645de45ff8e5487a09d84c9a058ad2d328b957b5b12ee2e945d930b399acbda5c02b28fcd1f493fbf54e035a5eb7bcf4d60b9564f8f26b0ece4d6436af74bb6786be3dd9f1be801d206fee2e0f81cbd3e592aadc9d6cb908e3be6fcf25e240c6d0cfd7e2c9e1526fe00ceac0f2a8f08b07196bac6067573a4a2de6d57d94ab6ca4194b98357fd598a9a5ffeed4a0086017ce716e351d5c62b0cc7c36e01f0affb47b18dc432e82d2e7ff25ab48d0470f9d67c0c8dcf07a8b3ce8362e9cc93b6a5bbde536c57c8df3e20c13c2131e6b586c28c910f694bd5847e689b74496ebdf8de7c5695c3d9abcdb274aa466e42ed742486ee48c538bd9d28d58bfb36709ccfdc9060bc9ddfd09febb8889256eea0515799adabf1fd99eb600444d1adbc495c4e8bf3bd8bb34d59390790827acc7875825d7d2ac19d25b79aca08f9ffe06bbd0fd9124a25fdceedf0375204109a7f12ae18afd5dd83de63e8ff617a2d7cb8c9380e6afc81a089a621fc704a2787f7c14c9e65c4d7d82efe50573e046aacdaed896d4fc6d011f6d707ad736e0dd1caf09c3be793b4fce3591ad2d31ec4d69270df52ab258df00d59ab040de54137eafa3f9ceca6c76a650d603c620e51e3e70c794dfb2f0e1018f8d16717a6bc673ddc036f94facff4a58e28d85332e6d044a5c3c28b6275666b194ad2adc2ce9ed2023f1516b2d7a12c7efbb8093a3ef0b0df3d6a30e99a3b5e42f017b28fe937cf1ff65a67c71abf5c70dc00880be79458c27af41dc2d9d6d485328f46db44c5c88e92f028af4648384e80cb1821b5c194745ee196eac027cab3114d9d855541afe835282a37b3bd32b1f003ba8eefd69f6bdb84873b6dfcac385a69e0f987338a43adb1fae2a22bd9a6dc7c382912709d7a703c5828b864ab714223f32ba768197f095266648d5b7c0e5d7516565be4c0155ab5ff1ced135a8c559b7e90604a2902622fa0c3483535e579541e7eb7b4e6c75e147a4c1c6806d1a4253605d048d069e8f18d7bd69ac86d7687cdd6b0dc95deb8585a9ca6f333f6f8f3765adfbbb728fbdde06761562ce71690abce0b7e2fedb16a802440d4114c7141d9ef228e26a0144527ef76ff20a6cf00e31b9060d645ac776427786c415333691c76dfa3bd6ab10a435c21d92cc493b387efa8b2d136463e6054db683249f046ae262687a91e11a6284ab5dff8c32ad3b075a3974ddf518e6d4a6154fe11e3445e233863728ac0c5f80ec0d81721d3a898a74188d85b70c41dbb117679ca191c8da08665f179e86417253cff6c71693444d3013a743b5e74bff655c17e5e1a125d395ef841f239e091ce13b49b1ada5dd60c830aaa22672ff29d06dfa85cd816c4aef9ddc5036f3aadce505c4e72fbef55cd57d1f125c9abf5cd8bdbdc71c8a59a5c6cb053e631eca51d6e226335e5d748eeb616f2c0dcb3755cc254dbc8da632b1b690dc55ce25827dd17c806b108d8b7e656eb19081710c0e4ee1215be82482989652498315b80f1de31b336a358ade44d6a385af8b3a0ffb72334c60eb2ce06dcfc682d031a6455c6d8a60371500a74f791cefd6ef26a645ad0f13376efc5db098afc373b4b4b06812f441cea1ab0da41b049e232f7d54313d40052bba6fc834e6a166033e56af81fb1d995f94af2634abba5bae56c8a50a716d2e5a2c5bb6834969f58341acd9cfe58d6a646a3df202cb4a57125a2048680bd438f4acc095f464a2ec173bda2c3db01e1455dc5eb602ccbe786c8debc29d8c183708ffcd18b3fb99866ed9a918e6e3cf28dc2b78cf710e82c677d7328d1ebfb96bea6b6d1a2d8480a6d14cadc4e69af3d1c909b0a10c2bf54932e67c2a5ee826aa34080c2d4cb683c803da1993860c57536e9df2eb6b126c900e100d43b7241484ada014ed9365cf11c6f7810e7606f63909ca02107e71779d0fc33a17c6dde9512245063d39a3c9fe5660ff580422fb8d8d2c0df3c580b130ca9090029b5481e8ef1568de1f33d1fd5df8fe0f1c2b55dc0d59e9c8194117ef79c286d9ecdaa5a1efbe7ac4d598cd9e794f73b940bc7b7b798610117333801f4ca951addc221a96c54962f0ad5c1324656f14dfecd71c86b2e50f14f71eff84dba2132bdc8f81e6582869e83f2cd603c4e289b23cfd0114b1650de68a843739cf584b72eaec84c0d2137c33c66a460749c95d6e5decc25ff0e936b0e5747b494359a7c345ae95b963dcb55ee54ec25574339d3d39e182dd5edf9e0b595233ed776a5436b32b24bebcf3d95e794581163ca26b2cf24b2a39e9eb5eeac9fd2894fdf1d23fa2d5a82ca0dcbe5241e8415cf20030417f29792b606ee53b4f5c89717969ae8fdb40c1c3958fd3534e45380120e514c1b994fc3419eb2522a304af1c445d997fbb0a33f342e75b7f3a86a4e56a4aeebf70c089f30539424e6d87a01bcad68f4dd06dd471f960c7ae4d68e93e9785eeb4bba34fe9e0f950e9f347c497f213bbfd0e562a55c067e3151a5be05480bd78067902bd44bcc73346509091018e7518dfa51ddd93f2193ab2ddc9578003bc32c80284a16c6029f8e265146e14a476e26f7c7c53532c3a3bf78598dc914cdf94e78bce74223180992f3b63e7b98ed3eb3cfd53dbbf6853725bbd201aafdb62fad901be0359fe401a6bb47a0d19e535348cfe5c3ac761bd3ce54c63106c54eaf9a7eecfa55a9e061dd63133b8a0e987ec87403354fcd7ffc172cba34d05a1be7f0d8455c30b2b1f5388ba805846841e1232ca730ae8230a908c86c342359b43f07e8a4f1f3530f1052ab84743a41d5f2925d425125242f22066366a859e0fb443735bebb17801ea9251a58904551f619b481e1dc37d431846eab659130572cde00a9319f48c192e60205f3dc89d61ee84bfc478d81fc8df3a76decb272005b63758138d87a486ff1d8c6bdf9565f991ee339ec2e990c1ee4ebeadb0ff243c2af78d926521e15a1f03f743f16b7a1258c37015cab38322c8a9d60cf11a84a49b8ffba5654bfdd206e5b7f01e96bfafcb6c0a873a24a08ed9542bc719fc0d7e8fe074d7e35d884bddb69bec6299e6d5f0911e0e80f31b55232f2cf4a9345e3cdbb0a08d202ebbc2030b96a12dd459101fb0e58b92cbfadc1b9b38ee17687901451f26f45b40572b99e10ac336f85a8f87ab03d21de5a18fce8c18a7921fb934ab281b05f7ed9c430a4eee48f8f3232391b6933623c03ee4b9d3d3b76bc313f95751f3711a1b74eee1747cbdda231617afcac51220f9c3926b71e8acd87cece1e72707011af18c5f34cfc0b6a2d5b79e2b4b2812dd6464e270a79d6b8bd0755f77eaca402bb1f3767753ad941800328ebe68af4e1a0100ebbec15a65e46a3b25df8ca85549ed7dbc87ec69f0f5def9bc90b24a4d7fc460cf8c2c264a3e5ffdd6b705253d406388047f1e75c3c55184afc400f3d0f0554a73b91f33064d8545809f74de393ad4efe7743a383a4d54dc98f290b6a7f137f4404de33609c24d6847a739402dbdd28acd06faf6bb33bd72d2626b6d30dad4ab4c8ac36716295045999aa849a0140c93eb6d91e1fd31f8bb4cfd7fddc4a29510941c0936d1332b1f304bb46ef81ebbd0205fc40112b2850c41af1b424896998408d4d9265f62bedf3a3fe32d348a2721ce0d6ef79945e6bdec3418599ef3de66eec8656fad2bb109614cb067b5be8e43e40302c13f911f3603a2d0b5342002c8eb496f265e567cbbc0799c04edb43c500aee46388c3de08e484f876ce4939dd3098083ea04fda3a8d178a13067b1af29114bc6993af42a06f3313bf3751084361edaf0d0579358f001bb315ea6e899f8f415443bfc6ccf8da95284ef6fa50ab58f3ecf13383e2544108fe8b80fb3dc44b4802a999d1671f52cbaa353e038da6a9b528f8c6cad100e2dfccbf6df1c332456c20a1db9af00b9d8baa38b41bea7d867c8a80094e010c0c0e0d6a62d3bce5e2ea04dfee7c5c8953a14416efa726b3e9c79eb3fa2877b4ab01a4e50b171ef2d703405f82f2edf0209060c85abda0a677012c10861a42bdf89ad7519d75ac969b3ad48808a4fb9bdbcc6ca7d3fd6c8a13d04776cce1fddd9f92456dfed38e4df1185ad2bfe727152d6b794c3eee2acce5bd2b9cda838b6cdbafb38d270fe0bb50c7d5ee452b7135873488081d56b49a325ba4020b168592e0fcabcb39a526ae1e69c32c625d4ec5cb921124da9faa6a5773932b48c4feb0db58877d4a4234d71aaede280b4b17fe971cb5da66175b4644b78a46266d1d2f64ee7b7c10dc020d8231c0af0d3de266b88b3d483ab228f2bde54af48b5c16f2f0c80f8f1f08bf1dd4437768ca488107fab28c5db37696b7df82be0545ea65542f86b753341b1b68c63e88396989c2ab81ac33eb5d5f4d596382dd8a186123deb869f14800a53088712da79ec3aea3d00350daee750a2d9cc0c8ea232979bc6caa3a4da8cea40848f687d80a1235a2aa17e57de9dd79b4a5bb61acb01df842a6a9fdbfde82691d077abcd7f6eb960d4dcfd94d1c411426f4791a888cf306fa4cf2117eaf8496df79acdde475564bf934ab58bfd4f04afed6c3f1d1dbf267d1942d603f04f686eed332533ff7cd2a7881a58e8a5fd3f0d12491f82b40c97909f8f0875efc9fa5b330e60e540ed619fedea2682b824d21099b090f4f2dcb625ed42e9b8571abbb06e37b8d662c4881f7820d43285b1560ca70fcee8a98fa738f7ab494d940bf51f13b759474193226eed9c62d2459f389c8bf49f554f0b3fd9d1e6423c6c43af2f6ef9ec38d33e3164bb0debe3845827f9ff62445f445a7ed399fbb1403a8b86b8403ed6f328168bbc7feaf32e1a37ba179f8f2ac53118b50d993a895f1600351b0fda633e49eecc6d8a3f475dfb2bad05e55491fe4f577aa0277fbf06957ce10956e18615eb40a21adcdf8973d3ff3205902425e62eb1127655f8e40ba49ff4e63c605f07bed112747fc794b246e8136ab97b0dbdba7dbfe1ac49b498442110cf77771973781eed3e2d2d749a1b7528aa17ab89c99c998081f75f45b86ce1137a0256515a883a117fb09d628e4062bf1a47e194ab73ece35544af13530666de82e4d6668f67de3d2a0664b4f1644b6b93725475924dac026604e841cdd2115d95a8685914ea6db0b6652ecccc064ceb87b7ab22931d2f94ec08547d4f2209fbd7693385db8ba502d71bfd6c05b130b2e9d61fb67a30ea2a8ba987d84fec631f60f7992d600086db8e4a52785cbae03f2916945a461ba1305446ccb151177cb70d2812b858c1ec648aabb65bb9502a2cd3d876c008a98d79b0866877704138cab71799be42f52a91e88818811fa1b948ec8c0beb779a10910e68cab3b2cd3ecd54d6d157b51f61de82f09d16606b13a0fd8049c7aa07a8ad06fbc7d1bb032c0819e6a6e7ec1f498c714e4c9968cfb13213dc464e7ea7822357b081a41886429432e8b0ba4dfd461a95da1a65537fdefa8fed42d457616be77600b93fcce401e8ee30b9a1ddc3e7ea0efd0a600ff19fd1a9fa0d5ab7642ea26739ba57c7865aabf53507028167c73b4595aca32491c530981c4fad37fc5075a08c049a1bc49103216c1571f7f2b9e9a36e6eb7984e8587ee8939bb38b41de91b4e99e9b5536ef63957d40fa8f9335930bd0167c64630cfc9692fdaeabf95bb7b729bdffb8eeaf61a2ebf2d169aa11714e26d0935b4f5bb9cef4a4ff4639cf919ae8033bfbb453b27f474e978a9e06d657ea6d5b3b1f8d1e28d8edf7c20e0505413f479ef4807074a3e9782f99dbb35982744d6bd3035a0714708f28741ca61d154e4d6517d1fd9cab34aa5a5a415b506b89a640e46cd462e2e1d136e83380fa45e4d0d18453168cc7164afccaf21c4078a67d4be03249c414409dbdc6ace8e483693c7de02138fada32d89c647a840bc0556824a3bc4424bfe840803e2fdda4fbcb9973d8d60f24a991b615845797d52714a898eb5f511f4367a59debd48c189c1829b86efcdc5c724a91d294a186a130d075dd874a7338192021924119038df5d2d8804047d4249a7f875004941694dfc8caaaa01d31992a4a5851285fcfae1cff37ccb50a75e620bd92e1a5859eb86382e6d27d453dbe8628a9f6b470cf082cdf769e1c0bfee4519f09e5369de4cd8c3b48ce9ccb81f15d6e9cbc1bfb4a009c25c709bf6e030401a36a10027612dabdb6e9989c4cf6d04bb59321cfe17daa834c56fb54f298091425b04dacc4c7df5a816924416b740397c107f012aee5c73bda9623f99f6dabe4d484766881ce596796397d50d87cadf6091d476afbbc0ce997c40f6b2cfec80dc34eae35c7810382d77ac0b075ac441612c6589ab2e36acc1a4f6b96ca5c1309b9d0b61e869f5142d16917d3eff6e2f4fc7b16e150cc26496d897d4285be003e4266676f41161f64a1ed0f0633a76091e3c371a8ad19bec4a5e297f956e807e5e0803b166e4a48f50a5d901953827c0a39f18165500d42d435004fb9bb9982bba35eecbe36a199c20c6b6139b24de431216c0cbf9d2d1d45a6bedc4581cb8f5a892cb26becbf11fb7687ab852d7dbadfe13f6867da67c811558ba4b1a2ddf2493754653928ecb683be95f54ea2002125afe8c384e98db5b5365414cb8ac4929d4802a84e768a67d94248e1003e60f1e2b881b68b09c148e0716df83d6d7c07a50eaea97363d32df82e278990c433d89f72edc7246625fe6b69de3e3a82517ab21a10e437e7f0ca1f24b918ce7b301286cf41115c0570f0ac3dfc97d9e06406a244c0400dfe8c4e1cd78351cb422ab87653b087757bbe38282106f5504d5b3bca485e4cefdcc4b953352fe836c0abf6ee03b6eed3919e4ac8222e30d1494406ebd8b5f6cd560d18891a4dcf5dfdeabcae2babc1058d45dff5d289404c5566fe1a4ed40fbfc1fc1c23a5fb82eabd37219a6c5cb9230f90e66a65fc5fc20050d9fe891f69b7bb35767bfc761ff4cf8f5e02764c1cd9d14c463bdf9cb8c693b0c517ae017eedbded6aa0c27ea859083f825de3213a3aeb97ad7ef8068b434242bdb402493cb1c85481228cb7ce41294beec9a05f1a7af7b94ea1a539f402c479ce38e45d6e6136c3e68ccd58c5aa0d8f0d09bb3a2533eb15effd12a86de05f64c715aa3a8cab5172c8eb045ae2c8259d57871775989aeee20e0d01a0a6d08a98c17cd2541ab47e13c10a16e6de121168a1b39e8ccbe520047445e02a7d892a86b64ba901d29e0ac4f15f1c1514653bed201ada088f0b737d0182fd20ac59cbed4d3edfc5fde003f156219f36014b6033fb6dfc5c079d50f813c9fbb627130c1faad8334ce054e4eddf6f3cbfde7266cec0d555197e67f0f272911e0c3345d79c373108b3ef630fee90f6ef5451cb90ce88d14d70c0940f0eada6247644bb22781e6f7eed05e88413cc27b3005f6cf8367ca81d38c1d9ec096e01a534c4b10934ee54b94ae9830e737abf13a32b519d94e7a01752b802f4229c7f09d298d12c96561ceac34edb5b18bc56b4b43d6fd4affaf444483bdac51226680f907c14c9a94a3d44667a7be5d8b4fb2b9f821670cd1c3aa8b5f6fbe66c0ff61b2fc6e2c23f2cf2e80ca0b60a526d276d3889b8ed2c78025de38cbaee75c4541fcb1202c7f1a1c180b29cb8fc4a90f9d68926a391577e585bdf2864c47238584442817187b6948ba4d0fe12ae7356e110413289719ae424a722effc47c39ebbb7df452ee64b35a9acb6a8d0e9f5f1215fb54d404a8c77842dc569c18205316abd01ed3cc0d2dc6b6a6fcc267dc38d28e4d929b31a0fb3c6196242acf89f199dc616674aaf8ffb251eded11615a0019ea94f02c5a6354259fe1baad0ad8677b10e8b8192cf28ff77faeea0bd81b25d0a3e34003821c0889aa13c76f0d9012515c845c68ee69b45a424a85fcde6496a90f6ffda80a2450afb733d7c45df1faedc8fd14eb46d16bf94aeb598a4daa4157d3adff7f0aa5be85b47df5cc0cf85676bd8f59936577c3b9614524f44a007c4ab417dfc69a06ab3cb61f69150a2ef08e6b2a6ea0c407f1fdf1c795acc3f03197e663c29c3f58d7d4d3dea4f28d720590315a3dacc72b60de652217f2cc5a17d3ce92a3cbf82e9f508c46d3100eac8717c51da376f98ef6f6f47908f718421a7e0a0cda7a2692b8c35623c42930105adaf4bbc1086632728fadf249d3d6687fcbeb4de69b9ca24d809b73498d5dfc8b74d251096e05e75ad71acec2caa6ad5dce69229b44d8b28c3ff70d968f00c0d23dfc8d37fd6daf79bce2db77e0feb4bfd6ccff95cfd83cf4d013a439699bdc2725a745cd0e5409d9220ccbb2606bad2afc1ba2eb6a6075d8f2be5eb5e69e314c834679dfc64c6491a67bdd439a81ddf0061c8645fe11fea67f7375ba04e11160c3e053268584dd22f7f40bdb57a4e081b117b58982cd42db839b63b973f2d742aa0cb8a9aaa17244b8652be0e3011519b0bdeeff0c13b937897ead4c20f7a306d14df796c88e1999f5c0834f6934a31e770f03e5eccef3e5949ec9388ee18e19b7b08c7eb4bc693349d22f4abc1eec93eb867a54bee9ceb11a0e9dcc6966303c207000b5109efe3099577bba5cbe835a7a8a3bd56f9a78f0ae7ab9a95d0161b4d337a831a3c1f152fc61ba404a12b3072139c9e2736330ba837cbe514226d1976c5f28ee76c9e0eab7381aee066aba77940d6175235b97f58363a964b342d34be0c03b0f3b438fc3ec4015013bfe7442242283168dcf99f5635679e60a469893038e52bf31a863b198cba4f2e2100145d735e4cb85bed68e33b60728524ca813e33f96a995fa6bb034d1a8b6c6517d24fcdcd030d72e09ce7ac0ad7b9df11b568041ec689a1519e650ee9f75e54641168b60ccf7047b136b2f2dd3c4f72d4f866a14cb049640d307a72fb30923bb4c2bcc500a4e093eb691d346aeb7dfa467181dd3691d2621090e99d60667098850335dbd0982ef3bede51f1e366efe2b5e8285a675993f4daeed66d3340e5930e5a6b6fb2844671690eeae1e7d230b8eed8eaf83694fd6d5345464eadb18bd91e88895d5e26a57f90b26881e5db7cd6b7a95a1ab7aadb0f51a461e3d53a7bc2b3cb768afc8892116cbaa0f4a16a45710886c2e9c5c539ef7894c950f303b7279e28ac2573d28e8fcef900f109899722bb92fe37944ec6481d183b2776f2e1c9f0c79fd12146eb34152117b20724cd5f5dbce5c8cf9c9bc440f01a6c5d27b63f21e0239fd5d3cd8d287486e645e0287452902b669afef99226651aada2ce482976360b5fb38bd45e63a1938daf3d4ba7df1a91f54c005dd08283bf25f8c7fbf54ab9d5a8518ae8630a7a2d909e2be6de2b8bed77c767011516893dbd999d4051a2a02013d11e1789b841fd4a72bff9b247e4b214a2be5b55f655f55560a286e50b0209155c5f28acedfccb668cadafaa498616a75951a2ffbbe84288af2f6dcdd0b0a74982fffb86d4c76069f423fb31c569684a28f47cf927f8cd9ff6b166629c9d7af121e66f4fa741062f9e60b6a29e4335f9f47d2d3d437ad003f7f558678be24a6923201f07fcbb52d0b332c30969cb689ca396dac78dfcef9333fd2f605e49de2805a35cfc56c7c06d2feb4451538414156a7c9fb3da470ea8c50d7dfad4317372e4acb5e0d4b09597bde8b2d746f624a43cbcca8390e1ffa7700b17d83ddaf7691a9c98a5773f47f752afe7937d5233d9486cfce7355f54d2137afe49351763ffab83635f7e092f5f9be6587e18b682a78e865de3aa35caac16ae8063ffef6f2efcee374645af50ed0cc8b8cf54b22785c97bda7655bde231048dc9f5885b44e946790897e9d539213dce806c6430eb1c3ce0f09ccaf0de2f4c6660dce651c6c6d5c8a544c800a1ee6c7073eb3d898e928495b9963e6e1f2923ad0c678c44e64e5d2ecbdbd5612ec98b260708a87d99f44e2a6e2060e96079ffd8d999ed54a928c1d6348eb91eeba70000d8b43b8797d470feb6bed0379705b14d4dcc2f59e8350e5a59f33845636f89021770b5aac43b7855bc87df427769cf835cfbd203cd01938bcb99a1e8626a98ba4745cebd5fdfe586c23fcb53e885d4d81b4d6ded15ef96badb50186b822850a7e41a2e0df273c904591fe2725beb079b6f1e9bc27dec8cde1b2034fa50d46d4d1a6b25b2dfbe8c8d9c6a2d04866ca2a695e2e7e43fde080b0ef2069231c3fd2011ff857e6ec23f8c21dd9114e31825d524cd6e459952ec2d12c985d0a7b79f66086317a2b2c5249c102cfbc89c23a81e944fa1f0939eb2f3aa7558e6d5d97eac3efc2903f69930751767f101345399e0f4b6f675f8273b4943748271209501882c631fe192aaf8d2ae1948f242ea353b34077eb7742934872e991c5efea15930a6307b1a69d00636e878804247ee26e92ab50c536939c757b97bf2a5abf27545b9e09667b1a446a1ad84ba6d34ce5b4bbed152d1cc641e47bbf6a65b9ca81b9adfc4e77b4dd231948348e4328b0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
