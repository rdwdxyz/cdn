<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03ea48a255ce4edcf3849036ce6ae4117b031daa46cf8e3c97869544631981201ba827981cd72ab859a781be60f7a949677e9ed9956eb747660796c0133c72b8258d05cbfa9559bc0d6c3b49ff7e34f4b5a94f18ed7ad9f9d837bae8f23643ea336a1d3aaaa7557d959924f639c235692517d09f3a0eec6bd1123cd8901149cbc1a4ebe6e768776cedc9fc10bc3a0e719f53f2d38612e40ec2af7b48e6f3ce4ce3fec14668114364be36af57d12c4f0c5dbcb8fdc745d99d1f83a77ff5925b56d22c8e16e69a92e74fd7d6ffeec6725a5fbca7a6f34968f125222f2432340295e20b59673fc32b3515479a7cebf906293c0a6d1272cda17bc917042863fd9c8c9f6ccc1faa6ab17adc27b3850a1e1237f94b1dae0bb10e4a3ef74dc9e1cbd137b6c5a35fee22cfef3006410e1d8fa01f4bdad8e45a29debf1d7d0a680c6c47aa477c2627ae795a4689ce8bdc70626b223a0bdb7d792abe9b148e6ea4da9f99271905d20ffc08bbe33d0e951e8e139674b5e6628f1039fab968ac6b2da6d8e58ec114c0c6155525c21da2f7ae0a466123cad7fa2e793f0d6e1f2c242d322d238c423210534d680ac126a04d931c91c1e3621a94e58aa066e0da2697e724e505a1a1a99d2667c1809ac5981d99eadb3e5139b7529e5fbfb4446722d6e7797c68511e58bd40ef6b7c32638bb0688bfd502a39ffaea3f2ade814317cba192ee9f623c7b6f8bd431a2de0e7e31b4ee47eece1448004dddd533c3d88f1614a24164f9020644b7047027d83446cc5aa3686f1b596df99b1994eea95de7a30058d7278dfa2e7988e8a64eb88334a2a627a3c69e1084f57f351764f1b2c2a0f5a29b33168a47e01f17f84f36aaf0c933584c9b591964ade388a8a4ba6d395d1b6019f1bbfd61338cbed9f420967327507731447c3bfae1ff5e16cef0219a522af7b08983c6a3e9185d3061d108e3abda5177a396e6b7c733fad99a89ee07b7550106c3e35602c2b1c3fc12381f1be915699299b75f51b918610c213cb546c971e266938085b92aeafb1c607ff589970efb50b9f3d51609efe959d77069a267da2ee0a309aa64e589eb946bcb8dee086e110e5a7968cd319f2bf7d26aecf53b2f47d714f47bbf4605c7c56815a4ada37ec27d186c8ce073d935ce1f2e62daaaea2278c1dc3cc4007268525dc8d20c990c40c41e3186f7e3597427a02bb99913275fa7f004342f2393a9500b11a41e65d36c29d5f5bf397a44e28536af6f4e09ba2663dfd778eb40d678403e90be0f9212dd4e3c7dbf984b072a7c936b1e20b80ed4e6868fc4d6e828a31c835dd0e066c387d08df939ecff8fe331b7e3d65948c9d3b6c251936ce3103ef8f7b2ad6cd025ee4ee780ab7e7221534b2795616d006fbfd8bfef6eef463d36a81ca0aaaffaa0b18a202394fca3f1c6bc001a165800b4e9e1abf942185449f99c9c715d53851ef3505c4939e6de4af6b2a4ff818d8abd6f4b8d22bbc188131d0fd9115ff80677304e77be1303bae2a604bb50794c31b57e88ac2ad55387c0a415a4ccd5d3f87859bf1796ea31bf394991dddb7bb2f126b46a38ef2f4a30cf09d430139ecf03ca849888abf1d0b33024ffdfc556bbea26f1700ff4578ed4859cf226520213eaaa17489483b65b730d6dd2d47a538fe039d257a9c549398f84b8cd45e1b9e4abe4e4f838528471e8a060b8de3b75c9ca61997d7df10777fcaad7127a74364aa8ef701ca3f12a42ebd099324d44292761e3f4b35e787c66e9dcc592977e9264091b1114af1083b48e81b25de3a0240ef68ec94c0fa33d7709f79abf8c35106265e84dc8a0176c0fdf62eab2f184fd2cbcc6243be7a677ad92afbbae73008d11ec2878bd17b0a330d5872835cf9ed000ce870d0dec79e4172c4bc289f3d027a91185ff2ff3b05576c2001556671cbab810eeda93e2d030095959cd401848118002fb4cc66ba89a815bfb4af46d84d8022e10adbff70e1bd8fe4b919d6b48601c7c6d3a5b63a6647ac410e484b0aaa310d7737e4cbf56563a4df5a89fd211c3a659220525dac69575e48f310dd7bb90c029ddd08d774cc7311d5f2778782aa1c4b879e119b7794cacae587cf2d723fa2c256bbbf63feddd74eed9c8d940e2f053bedf5bccb242ffaec00e6a677d661badbea5221f9f0839e4f8045eca40b0fb729ecbe032e2eb5b64bbf458987edcd47beb902a9ddeb0d9daeb11f195a556a12470c04bb2723e9db9dcd3b78cb4c65c3883ec55cb0c03ac5f3b78d1b411e3b7b6b1b11efaa20bc2d29eb025f696c65870530cae55aa498ad026756588a1a206575c4aa2c694712938f90f8840228826f3bf13433fbadac036bae2495e0587e3110b983e32ead28aad78aeec9032bcd14e4ef454e6bd528eed5744c866f73df23514c09248d6f8d94864f0ce853be94b5aa7eab862899731b06d611adf2b83cdc94b646177554c607f6a63a146603a3e1d8648a3be54473830382d7fd9544269cc93e1e67bdd6c31c317f0ef4f753f422372ea7bfcece6b75f9c36a2adcd88693e0a9233bf753ab40def0cfd6f190bbc36987f79d4ce929e17a18bc38ddcffe314532daf176006ebe7c765af16c870c0fcfb681ee5e6530977de49acbd6c09571f54f2e648c17be052772bcea65b30abf48704de278b00774287439d18edc507a40cb65f4a7d47310e8d30c4726704e16f4f9cc14f7c5af604c6351228fa582729762248b4d384cb772b377f836b582cee0d5a916bc6299c7d747e4d2f7bdd936dee36f097c9104e775d21f4b6c4ee5121dee0c7066cd38081ea47c5869e1951116bdd5a81004e53189057fbb64ab3d472c4f680b8f1c09e30083a605d0a3b0852123e1efebe740309c7a85365797dc307ce02b2243ad030ec2b0106b2ff689ce83a109706881f14dceadd5380571acf546a6e78492240b1a3c585310dccc8e816281e62a9f00fe58fc36dad8b742633e6bbdcb3e00188d51123620f3f22cc667d7a7a22a85b3602e02460d0bcce886449f2cddf33a2e99733667161d9ec0564bf1bb438ac48d9a4209a69a23ab546ec498d0bdb3cb3bbd99050d7caa432c1a123935ce1ce27695ae13b0fd57d6a6d1b241a06727d7d37000f211319d688687f6dde6a18781be4837e2fcc70cc51b3dec8216213d0c28c0fd47a03060aaa3cc2e112b2728485af00220251a548ad9639e815d07ef476af7aa476d7051ce3d1e21ef58c00d2abf327f54b194b13942779a9784bcc9d64eaca732f076e39559b9099a286792c88327ec657462578e5649d2754584b85d2a5b2c9f44ae68686156478bc1b27da58a770ea64fd5e6d74eef49b72e22be51a22323c332c28c1d6ef6c4ccde261a8c7cb139fca6cc846672e5ec0bfdb30f73257b1dd55f7adcdc8b3202c887f88d6c28d073524fe5adb5324b19b9489c3af8984b6ac3ab12978bfdf4fbed91233d75ffad627f14411e084c11974c67b1058c7134fbd5b4155b835bdafea1d6f0446c4e1ec9401bb0d3adb538808a79f47987179926ec421385eccc1fda8eabe15fe8f68cd205f0ee44178771e9bf735448cc8b7ea4a8a184d429fabdc8041fffe87597187eb174559ff32ee7213990bda9a7ea5a4e104c3e57a4305fc270ddf643b21bf11543860e66f57a9077098b0424dcd0b2a0f76b8f966bca0d97a10e984b865140872660e9fea4af3cc3b84636affafec3ddc5c01e6eee2d7151aff04faf145f9a63ab262a28f04d44aa0b948d8dae51956d30a588aa359f4fd184f02b325aa32cad055bec6ecd33274f85ff348215b26886a1715ac2950a28490b5b21fc85e3f0aae1ed4f613c5062f19330977c99052b34b91d51d2a43648edc6633ce5dbcbd1b838a3119b7b3ed9510d0a0f5673f3fd75552745b567cb96b9eec9def037d9a187adb3bac8ea4f24304e53da1121fc2d4befc345722c6a558647d63d98e374b31b9779229a65c42bba8d33f57773ff98206c614765490086dbb02000d37ab1efc0c994ab915becd0818d54884e8811d608b594cdff1b8880bb76d9bf094adc5f34de307c973b5f9c316a5c26a4a01e9fce93bb212390f9c2f2be71d0783a6f195cfcc336a24b669eb5a406aada63ba6c123c37153f6d301df2b50b052d517c6aeb84659a8ef0e1fb2fc5ec8de40ec26b75d2e50fe4f1c0cea21d2178213b34dd3f3239b63c643913c08a89f01ce4d2d40763148b1f87557db8a535400b3e2f2f4286f86d19f247398e343f8257089ff43dbc5b9fc6b884b82f27b7adf101a450b1bd04e658f889f20eb9fd16017225e86cb77e146e246bd637b4c1116a30203f1fb427a0fb1be9cc4f2f3e57cf28a473346df7cd54a031ea49d0dede96f26d684e5b1e094505b89182053d27d43f58d6ecaecdec624eae231ae07b43f087d4064cf8d5fa031d2e7f4ed8c2aee6d5769d0f9f77865a9dd83e22e8f4e52b3facfa61dd81328b3f3826cda7a7bb3999bd6d7e1c9557a026549f6787a2d790a9760d75e4d95a56cd194b8d121cf602ee38eb60741558bd315232e0f900f349c3df6c4ed302b28c17f63a4d49e3c13f4f2f4103972464cb56807e8749b9f4e131c23a717aee0ba17b7ce9a3f82e9346d628378fb82e06a06bbd6e84503251a07720db88e652e9945f06d9f06d4e4a387bd2002516e341bfc996215559e9b1d872c2548760d5ee1fa866b4074373a863035cf6ef07eac733379dbe2c0746f0219802c7e446ac0f560d8115989ef12ae797d05f858806b3d912e57bc7d46cb2eb74321e9bc3ee56b2ca7e9efb17975e4e0473651902cb1a41e113b0a26365f82aa3764628722f5e29f7f9b6ad9878bbc7f9bf5b650b68d9f09f3a967647fcb749cda8de72ec4cc402188b70b8bd83f650ef364f5ca42f4a2c973bf8a41306d018bccfe1ed388f6b4bc4f792df387a5881af5bd6906cd595b668e3715e2aacf010ba864861fb1705da0ff362eb31b4e977aafff61c5e56e5f62e3222d9b50ea8d9d87dace2216d10b0c656148594508d0d9a038b8b3760829ab8fe7707e5c4cd0f6623ab070e73a5057aa07159d12da823bf29392df19e4bc380c9583b4ac711943267677bc2b72a8685c5f24bb4afd19f6b60df8cca4a7de97d9f38471a536086f41d465ae6ec9d6bebbc912a19a61925bf43d0f9b0b746e2b61bd1cab096fc354d5acf32a61a4571ac52a0b671cf89c1361427834f7d9fa692019640e0630e01b9bdcecfd81e4cc0cfc7a44bfcd554e26284bef6ffadb6c30ed6a01f60a641f77ca8b70ae5ea92a2ce6f8a737e378301410a9ccef8fe81f4a5920bda5e304d75272444644df1cab063505c6137e84026e5178220ace83053bffbf578af712393f047cb2d7dad4c1dc1c97fcd51d774afeb5527b0f117cdd71613555d256f88c2c6e1181992e34e83d1936ddd78eeeafc499ba5e26328b10c93923dedbde12357651e9eeaa08989fa3f19c4c6eb1bbd37e9f45689be1038c6a1ec665a8930fbc39f6a0133604bf2e90d278e69d83ece7b71f464ca5833632091e68470c12e9a908d8f2fcc1e5d442c21a82671079a187fef9828f36c8695a756dbd2fd8f230308465bfad4f2b730374efe0fc2290821c6122f5ca3b899cecdc8eb73d966dab2402cfa05b06098100b14bf090675b6980a1ac6842d940ddd2fa5e27ef0860f14ee7044385fa551baa1b3332e0928dd9012d6a926d58c4731eca4d5c1c610dfbe5a34600496b72f4dfb413d6c62f45bce63325a821e9a606c910b02c567ce041447f2d366692b7a3c9e0fbbd827385cd3dd630e22ff79433488cfb210251b7308a5db19b2908fd32998bdbddcebfbbd1b73f1c2a13a927e65eb39971947eaa76530ec40761ca6856fb40fcc73f09f1d184b712b7b4729bc7b6451f713b6a3161b194d574a3f67c4e6aa5f3a9e9de519bd4ea913fb586f648fd8acbe6270683aea49e3c42f3e7445953f7073ffa2a5808a14bc6b434dce39eef43121d130779e89f5e5b66c1b1a5600a6d51475f5f4a6de71a5deb6e454d1cae2ee334de73e4db52700389ac8020215b44f8ae5015e710d35455691c2f7ee69795b48914cc174f88f7f3703eeb592ea19a27e0c86717033c5f95b7bac3bc0b69efc3f091953ea4c1c12f7d5c8864700a8d840ba79146595de632e3d367092cd8ab551268816775d76ccd9bc9e12474ffa4048b0656a822bf963a203bfcbfc03900e1ffd2e8e2a35776a314e85a469baa2fb46a0242b10ea691b9dff506ac17215daff593d724ce54c2938e489932714ce3b068823c780be84bc4fb358f13ae95391a8c04efa3e1d7d76622f46f00e5ca48f065b44f9bc210b24bcd899d03c7ce142c9fef4bef957430882c7854d18f92c593b8cfa91a7ec8a04a702fa4d9645f28bcbc6840aca88adc0ed725cd1f38afd445709930fe8a3590fe430a8a923a71820f59e4afd1cb7ea1723d694b556d9c8485e299a62474de807cf3a479f4f1b2d170db1ad923831e6d1204ba5d13b564828375c32c95a7c6439b6c6f98f533613063831aee938ab398fe4e8b4d857dd756461b5f72c0169a0b3ed2e2c0a961c7ec1b9ddf49d6c21e3dd58c69d2cabdc29e14a69eebfeb5a4ac75dc5d1746a56f07ab1c19e87193c6d95f3a01dfda861ab8cabf2b14c97d21e7ecd8e45708df4b6c4384b440c90f231a470e104e4d1a5e6b74d2672338a3ea4a72f35eeeee2168ffc93f9d8949411b40a87616c359577c03105e3185a102d8ede62bf7a8f94e5b10c0989760d3bda645da8dd351ea6b89d2861991284b541c39320dd5f992d425202dd9c5cd73291f1b1f7e114f472fa5655b710f6f22143ee776e0134990d59b1dedfdbab51f74de5cb882188afb9f2a2439c6984016a830b99c257cba198df2fc09904ec7fd3e58b961ab3c8cfa9046eac4ca5e06da19f4e113f3cd566b83e4ade946ce9f1ba77332236d4ff1c5d6f46e86be170424c72426db51e5e8f608564581606072fa53b1769d18b1eefc4dfbbf2143badff569d44d2ea845a8177731c854eaae5f8b13edb28ee9466aedfd35a69a3f563068e2bfe06a7aa421f7dfbcac3534d29b20638ff8a9fa799a50c386bcda39598054a6695ef4b43d8e782e04ac59e50a33b2a575f17ea0b4ac6b72be66473c791cff0a13531d529c61ddf3d85fbdd0ed14583a3237293e0b8a03b3dc737e8bff80471f016f5953fb0874423ee4357b2ee200644ac83c820ea93f0e3393000397c7a2f4da633e0c68ac41c975aba35c04b3362961877d5a44ba36bd38849a08758c5a1e11479bb1a736711278ca8f978ac72d4b7ec4be0dde93690a916ef48d66deda55c69cf58a818540c830f20a9b248a852db704d2f2db598bb7d7e4c209ad2b97b060b33851bee7e2e32ea9713de3ba90dfa7c80c4a5c650289ce1635975440b54e31043a0ab7f0aae01494be97eebbad87f576ead69ba2af3b5a367f5f3776d5a7b501d86e76d97fe5dc6a8da7def00c94b54fa94882dbe9efd806e028010ac1b9e0cf77f4b7133b73e10704fca75303826ed85d14360416681198822a45a0547bc937619a8673c7143cbff95595ac0500b82284dfb3a6a9063fc26b1e73141721fff46d1fa0a37403b35561d37fa8f02cc4ecaca67ff7c1e8f271b07150c05642be064d21b26ff7ea9774bd387af588c3455f4477ac8edd69865978e26ff789e8645a8523bef547c5d274c51cdddadc7700ccb80d5ad6bef5895c038e06cb3b93e2d6ba9690a792ef61b109ad195705bb3287cb3dc3edfbc468f8670057d1f351d27149fc0bbc8aaa2e4435eb88539428f70b0ce3879fc80443145ad247d96399660d86d7f419cece3b73e2d43966bde90fe11da63e7e8ac93997f1c1618603fa0e618a3c30cf44b1f13bc9b593951fcd45bea2b17151083979664bd5a7b9047d7c6bf11d40d3008c8ab5a17be47176a6668226d2316ab3540e38a7ef7144a8a840cf8d6d16c6b354df7b8c4c4a2feae17d4500cc6884e1daa7fd7c6898dbcf3cf13589259147a39c7de237d3f3875a60dd6ba1a4382a747c82414cd25bb5d2f85367201a77f52ef4fbc7e53919e1dd5b06dc24292da8b7ec634b6b1188a7b2f67f010e7f9f888145e9ad66fa3e3cbef76cfdb5d0168a39a637f8d17185c0aeddc8a1ca319a7ee798aa80e9f654f29addcd2393189830455070f533bbd0e17aff041dd86d326d194ae3dfd0094429275a4f7791ae031d96461fa587e42ace1f59915cd89ca8255b150004ed6cd933af666818297690a3ea51291eab2aaeb6f6e283b7c37b92c1c2d093fb05f38b538e28772088e1ce3f4fe3ff2feeba571a416b088511fae09bda43ac4d48efb271f60e635d789ed372c138f3bd979b8bc07bd301cade7978a4af871d917c0e5e9ac41575e54066a1f10748efb537652a168ca53d63096a7aab11dba0578a37510db587a3b070a56aa51f8e89f1f6e3beaa69a8abd7ef922c0f74fb6c45155e807a11f570a4947efa6bd00c1494fbe6049502c46e164f8b53779223c8775350ddd9729be7944db69234c1b95f0eed6f0c7b66040f9d70be6a0f965200bf747150b9b20d9bad9c3ac99789253dcdd378beb6e3f0a1b0f892feeb2a43b2444bb45de598068c379623d2315e90037863779660915407ab564c8b84d927923608a965a4d7e9e7530ed9cb91205c0ebd5c060f511818cd7a21ce6bcc5d50f053a76052ceb28b5e1b5c2684500732a42123a47229a775285344b71c04259c3f5d779465676f2977af71274b115d99b194a6705fd6626c40119b6224a9c28f73966d5bd25d88d21b3432dbf8509b71bb75ba84a7d796b1898e5c666790e1b5bf19e7766181a91f2424348d27af4d12e189ce14b5ac93049529f179620e7dac3876306f6b10260171d14119afda97cbf6b2918fa4f4143d66848b8d13a85e83a2fb7c820b0550f01be05c3a352350cf70ab09e044594a2aeecac76a6ce98bb79852e8709c7e881f828be7fcbb41400d99d9efdb7112a688c21d78ffc4ebe2aa037360d575d9749f8c6af1722b1f371ffe0eb71d5f47d2816ff80a68b36a945201d5063a7c92dff23909e2031190620da3e1fa82f32e1757c6a935270c7f8c0c7e6e8fa7e3b8f43c8a1e23b1fff9a4482b56482441772af1fe947c423e41de4e0b5fa6010cec07031707c916424fde0f589a87175f3ed6a9eb6870316fa0b82423f87bf6bc796b9f33ad1558cb10d96843c5423f6376dd6e7d337ca48b71a2a98d96783f72de040d0a8166395f4ec311a0d093609468d05c61044ccf64dff6d0eeeaca2745c178e6466db4d1a1d2998723680e995849a4e6eec5cd78aaff8c6c6bf183d71a5b1b41a0bc2a8f115596c8e5d46feb1a88156c3fb27c9f06441a5bf89f0e1308606de6c5cd7ae5043410eb0a75305c8c6710b43fad3b96bcc4283e641120aeca28806b0bc4eacd66a8cb983e4827bef5eaa05d2f153c42a3db01fc59c841459fc3735d5723f4591215994205610df3973aaa9958ec446053ae6a26d0bfaabdf26c5da89929d4809bc9d74078da0787355c6c938ef1164b0c85342ab81c2b91d98960dc915797107906c3b61455fe888366db4d0f63640055136dcfa0a2533fdb01f921496700f479c482f9618015c679850eb50b4399261e91829af116f410251bd8db37891af2cd2cdb0694ea747df4ba0fe4eb47e89cfd495b42439d232e1f21a5b58844f835e1b68725b022f93ce824e11addea2692a55a4f0743b4eeba3957c3372304deec324d572f6cd755e73241c87b94cad0612d5b20fda6c56a86f3ce231fbb3949adbcc497602fc494b64aed0573a4c42b984387b3728d60edf000b3760a1b4b00f316828ff4793013b2e9698bf9d92ad44549b22866055c842c0735e85a4c08bcdd057057e012809f1ccf21e693b7a8db1124fdf099df586a540b7e2ccedc96178c997e9d69e30799f027d2fa644257ccecb6e28ce6d577d676e6378bb7eb80ce6933a92a81325f4d149055d337054586054e8cede5932515f6856213d2dedcdd6c5f557315bc0e454ee3bffd6e95637cdf48ec8da34b80461796f4065b56782e2b2002f76119c4c05f8ccd9c73896048fcb4774905c25decfa746e4310843f914dc13bc1b7b36c867b4e735858ab6e648df479e774798fb145b4058f950c44344a5d047b735d4bfc28df1609e76d5f8173fbdab4530c8d90be77677c8f968c7664392940fbe49f969e0d7063626410df76f8dc7a0cf28fe6dd3f4e3842cc44e4f48c5e7ad20d7ebe3cc540ed5d43669056c7927e36be04cee1322383f324917b99822fb8c7b6be11dbfe363f56ad922d3b6ea7b0ad5ad820c3c6c714a425742ffb32feee311e73f97afef82d10d77a8f5d53f8d1b444b202c1adc0fdc0d3d3b0177cc4c1dffc382254adc6453c47371a56097345ac7abfdf8e1247f36dd8178223c68552c63d6acac5ce8684f4920e913bd9ea45773937a22ef8d2788b703a6280d599bc7207be5bd85c220de1be9ae2f40dcba78496fb5d6ef975408d33cb428ccca82e651b202a7b3688229fc0118ec98f342a2ed156bfcfbd65667837bf700ec2f5fe51faa68820d32fe1a64962a1eb6c4273d6e3691a804fc2753db7d0c17b9f115136914e6f5270879079485fcb2828c898afde68bdb28f2047e0a421cfd2f9d644ffbb44a97f8520c749f9be8d7738e559daadd90410097a13beab67e41c680e4d4e6fc74871abad933faa973e3f67b0feb17c6f4114c3a9cf80f3beaed3fb0739d50471490010a5dc8200b8777e73bf3061c7396bbeea3f089f03841160c1d1de0d7034e6ab59200e893310b3a5461cd9a9bfcb0f46a5556fc0257ced69f68fcc73a2b81a88beb93441dde6e42072262430bdbbb365a821f6b2f4bdae3f4d4e2e909802b225c38d745818922e6af85e36ff4b57a54a42de592e59eef2fb5c4c0d21feee0517495cf0f6db1928f530c7bc15be24b8abc2bcf4547dc191a335d88d0acfa166a2238a0442df4b31f6aca8a135d739fa7583dceedd30921ed59b1b6fb0e858dd9fa31c042d7ccc25d4f1e881d31138f0fa7f54c38c0ba92b30ff791ea0659e6b4784c5e1ac450485d1e14aff043afd64c607d6efdd6f9b690300b1f7d8d452a625bcdf037c68aec952a0e5f02459eeab914cfc37e11deef1535e2321764ea94bbab07b3fa1bc11b5ae15c3694579d3aec26bc9113fb0ebbafe2800f59165c7fd1367b283b70e5a6133f01f0fbbc9656274a40cba6849f08c9a48a7838cf94afbaba845c93d2afe26687207e3802bdf8c0876e905ea1d5743146139f99967de2dc85be415ee58b60eb176cc1dfb148b6c5822334bf417756142317248539e825ccd76ee650fde708922a82d545e1bba4a9f4d3027a3456dee779cfe7b5882a6cd6d16774f3a3b8b59ef9f09ea1687e7e173ba7753d0f598b1b301fb101a32dfbf510412d6b9f300f8486c888807ac699c687bc2e050b7ec24cc011aa8984e9def55eef60fe83f15009954ad4094a83ec238846c89768b31c9101a720ba312db7362608f51cd09502a7194cbb54b9c97eb84865e79da9e1b53700e581c21e95b9ae8fcbd06c708f7c598e13c0a0cdfd1e39c15e1a6c2367620c5defbdb09f16ac9b733673b84d3cb5a477fdcaeeaa8e4e43dc74281c64f8240bccbae00f76e2a496b4dc5dc4b4d4228f94a270aa71a8976eafba45809b903d6f86c6d4373fbc9a1d833ef8b1440a9cfa7a4e3210497beba46132c14e3e09581382db19d4c441ea7b91e049f0251244b2bdc0e290b4769785990248e5ff5f6bea160c25a5cf95c3c7188419361eaea20e6b10e339e5f7cd7c9ab0a8fc8b8a5d6cce9fd71beab41654e8f357952961edd02f8557268b5116e60650b1888ad692aee89f8414988fa9e73c7d07efed5dcc2adf39e9401605181d431a7103aa402e80da7a4cd502b387518534ff09e62acb10b8475bbcbe5f47ae727829f716675adb073cfd3174de8b05760b77690140939600291b65c1b106b0e3f607b0ea4567e1cf2935400e9ff0de1188f23b8f836535117260607732a4956d4f8d99521981725ae8312e9f79d064582229a2586a12c179dcb5234353120288363d0c47f4ffb4c8923839b5ffcd87dd7bf1f3df2c83e73ad7b7e5539ad085e6f71121c9bc78bc7d86873197083ba3ac91ee830e58a02574ab899f96dbcda73187d787625f54aef8be7e5c7b0021614797e669c7f5602a9877525a41249265822190bd4a68ef82b0ae7aa52a9195fc6049fa7ee6cd8e6e64cfe14a55639cba86811775e646f874a03e4e3118d70b32ca08eee325aefb5ff2b1057816754e4822848312ec355b620f6023932f1ca5c3d5a7a5fe4a905c6d109184f15e31ce68254d57603537876f467d9360ff220d541932f74e5404569fe9a641f9461885d48833c76cc1cbbf15f899cc25acc126291ab1b9412c5e7a1164e619283968f5138cbe50ef7877866ab0b37fa79bb549653445edb5fa25484404ba40216f9cf02a702b10817fef4d6a98dd8f08cede0121220803c1bd27444e075ee82b19ab784ba97207d81cfa519f3171d9cb110d79ab12328e7231cbbb41740f2122091fb152a1d5d91d6d172102fe7c2973e594ce930d05393c45a2ab85c359b324d7a23bcfd9bbffb6740b5b07e18035cfde735abd4e33789d886ef80194507442a35575fc91bc374e8837eafafe556e2632177b8cbbdd2d8f2281f0e3bd9de714f30ae7df0abce7a9bd38ba781820e2ace3c424501271c936b11c123a90733bc9b49d2fb23f8d89bd7740306f259564621c6f55e905f5f015de0bac4449713efd567c9355d99eb026796705385ab5a32cda9d9a770ce84bf30dc8e07c171030bb973a380cfd5b087e578faa7a095f85219591f52e39e7d10f3aac23d9faa05d779801471781ac05766f1873af8c7b56fa5ee12ebc91db014920b8b9389f91e086c2c47af879403185ac59e1ce570143a4f93c13e69bed9fd1e756c9205e2dadd93c4f562adf53b4b80696c417bf37b63877f159b3c644d3b446524f56687f7984bc9f5a64274c8a7acf2aa0ed600e32f025f2f0c57d8ab0a4fd9947712e8184b0c45a4ac7990a60f4bb9e88a9104cf7ba0fca6564b8784e06afb6e8c5bf992d9ee75e02d95dadeb5dbecb9497e2ebbeeac647d24c3bd53ada720a512ebba460556ac096d706af290effe32ea27521b1d97d531a0f19e90259d389a2a259e2b6ff6471ef9ba6182b2699505c1b2d70c902cce68dd074e3bf6d1391ff04d9412dc5fb9ca44377381ac45427f2d08ab5db17babafb27697a4951d8ed289363076552e0feec0017e03f1b7bd29971d6db315a5d5a959df2e8b04158495575e547856a01b29044534306216e8408747d5eaea7462a33395737da26d51b7d78e65bb8923c5cfff2e6f73a1aab721a7884ca20eca02f8f99778e6cfa2c526da45d1c4d0055e8a36a2922fab3f543c460d83706ef83aa8e34c57fea694ef4aabd39056bb1af0be49f0be8aa7a83c633a77046c078e9029260e6ec21090ebbd4356d47824d66f1e6a544de429f414db898bc8a4617463f05c98e28f3c7d9dbce06ac4263451a7cd7a9900e443252bc01856c9b2e78464a2ccc4ca2f7c10be36c6c28b542526f97144d4f08bea9b9736aaf771df30e1d94453a705fe147c921fa0c379011699366a31964131b43973adc0ed415d2a1e6fe0a623dde0a878f978265d61d8e0d86874a2c023346e0580f6c8ab371c58a5e7b317b12344550bc98a9a417bcc34ffe4e0f0a3ecc4cceaae5139775d25905af6b9455dc48aae87c91d3d8f927650262984c1874b718a303f99e7d8945c388edf5a6d30c1574e693d2eee83225b874f7c49e1f8210598497e220c5354bb15e4c6fb4f8fe0e3ce0035ac4dcec24b130e5d9cbf02fe4aaba9554c888cf0b93b3c2f776032fa9d6a3a39c4cec9e50a504717e52521bb8a6714695521d0194f35eed3776ab5af6af6c3a946b9e4a862341057226057b7e4ba44a025b458c01a45133ac0f5e4020acaf3fd92861975192d18dcab4ac58bb8d9f7c7505f993325e4ede1f8409b8e58a8f758b0150e6081f959bcb51fa2e1e24f09d9d806922db9ea62344ba81cb2c6c01097f8027b2b77b28e9adfae71d2e28aca589e96c804e223615696b99bdc8d2736d20957c3173be0f61c905d5e3840c884aece2886f0c2d5368c458df1be6aa2eae5d13a02970d65cdfdf5473470b4f5f31a2f3856443f70e118cee95f3c0a252be08f955f0c028688eb38c62bc6a2b8e421de93df7447a79cedbb6eda9c7b71380cef230feffa78353c3a98832daae1cda488c890eba4a1f244aa35841aad57ab92640520fe1c732009179524687e784426d026cea8098ddf7cb06fe5068cb19ddf50cc45848e77bf8d02430b77b99ac7b3bc48a5770b7de8379822f37536d41d0eddb47976599be9cd4a5936702eeb75a58be28dc2c8e87e9de9e242d5db24ee68173f087da623b40e89d8a91da6d8b51e845944a19d154d68ff4fe8442066545fb74bb409b3bab5d14b25a8777a25714d958822a957d2de6d71e472c90c6503b02083fc74a51a855f2c42292556ca4906123688ca0ea59e5249a2c46353905767a658236b44f2fd4b9dffd84b8d5829d89864cb814570922f649257eb9b9fecb2c9dc59d490ed17bae40e0c9fd118edbdcd57f1bc232927ce71049f36c3f7d5c0e58610723434fcd3a9e654d0cc9ff5ed0c1bf4d44a149cbc77a197d6f528d8c435115b7ce490c21cd8f7bb78a22e0e5c548e95d6eaf859a808335cd8fc06f2180fdcc96a52374f0303184f5259a459c47bdee93e09a87cefb9e33b8ec50409a60728473049b0e83dfe3303aefd610907b6dce47d98e0eea3b4310bfd09b440387b892af268fbdc9d8ba416d8f3570ba70984e375de35556c1bcf5eb0d1c07cf1462673f6bdcd4210a7da0fbc8837cb336cd20769d6546755c8ce736c6d0f2b8ef611f2a81a165cecf8b9140571f494a1db92fdf902caf0cd60cadd4c0d9f89fc906a6eec78cb235038e63085f79f21b4e99537243ea67869acdcb5d41d447c71787d422a6a46aad85132a62de26228ddd76d17cb0f8eb1386770b76aa8e68029f2d1b438f3e845ef2c91c5b0e4a12ea04e0ca09ca7db1287675294dacb7ac9eba322d6288c0d548d4fdf3304dde9b2509711495fc676f1853b281942d36418cb6e5d3d226fb18a0c2b1a78143a4a46e38753b0fb9828958251622e811b8868ad0f82ef10ce9570782bee09f49bec69618a08d23858ba6c3dbfe6ee720ea89bbb55c4aa8e161961df514da1f369f60c75b2929ba88b7d4e9301494560b14e5c4e87b812ec473102c366ce73919e9cad290268d18537d5381919943e8a551854ecaa5ba170aa5ce50d29b50884c237c058d79c5df930d220520db4437cc504dbd210a2c9511e515b735f65ee5e37208b5a5937d9adb2ba03b544fb4f6c2cfc9d7ab4afe9b45f61897712ec50f58be06fa48cd488788457903c1b7213563193c0abc9b22cfdc31a39fa4750d5b74065eea11e4b25fa50abc068463fa25fe3b835f6cc173c27f667f5bed817f8ee7ebf7b3d927501e72e6e56126f576fae8caedec538b29a996c6128b0f26a11210e107a4ad2875ca8de2bc5c431d7fe1352d07bd4392c8c4bb8675c8b3bbc69d9070310e95a219af50835991c56aa20e270322a4a1aeca7928a54023f071a711b89c97be86eb7d8f5dc6b1c131dd843ed609f432e35bde00a05a3aa97e7091aa26a79e3f4f3fa4913474eaa9b02a6f2039f8a08fda34326b3c2ee7c655a20e5778d93eedf686d7aa59c73f29c4d031c448ac339490829ea7b5692cc994ded8e0f29f9ccef2cc4ae6cc547f66b58b1a2b4bdb5f50eb3dff9198296b54e84ee3d8ea7c1cf1894bfef2a69e32841f621d5a5e1a496dd3ad7b64e078f9fce493b0b8e26a3afcfd9ea20ad41c57ef7c430ce2fb14e227e93ea1deb2a23c0ebe3a1859f034fb8310ac8be8adb731845174b7be2f5e0376ad175ebfa2a73028efe8438bdf5996304684cc1019aed7e15bf39362d425aa7e49a56c00052b2efc93ebce2b4b59d8a13d5c5aea19eaf071cd02dd497d49e48ad5bd19080341aa8fc711f0e7d72f76ce29eada6b33571b162c61fb1e48a9ce553b732f0058e399765197c5c92eeaaead4e090655cddba5dc7a13dd56d7bec6efa6fc39e88785584cdd6cfeff93e1a9482be564f8cba8aa0c6d84f02ceb9ca39eec94036060f4d53c9739884a26739628c38dc9e43c792b1d8e63d82cf95e4a384179b1c07ef37d8805f4b356447f1366de7e15281e30b85a2cedd187601131218d740dddb820ab6609720877628a9acd9d7353fb37acb732cd6d248552719de6bc83da62b1c13044454163e0d275cae6378ec367d16af5212251e3e211d84a63cce74998ae9f1d5bc2c3ec012be5c91ce7b5fb91b4fa604ef0e4a880eebec5d27135d85e0d37320ca6234b1cc639d2daf32d5a39fc38838d190dc3d7014ce35a19687e9c1453e271da60187b7ec8f98160778736affbeeb64c599814acf0a607c875aed52514045ce7bf165794c07707b0eb906aca187881890f0b832a74273da28090fcb62419a324d272cd06aedb1ac7607bafce52e9c4ef53976b275ae62d503cc557edc253be57eaf7621a0005380e8ebc77176db5ded6af3e8c56c6a26ea98518ae557d556ccb2f0ba19a6332dde505f714edebc418f574b1bb42fafa4f6eb7a11e494b85003cdf5d3a939b891e7862e07286f89b466ada021b8531a423a803381673df0a94afc400ad26981a101fcfb3bd054d9c109157df05b64e72082ed219711574db630926c24b4358287c084f5bdd751321a3c37d0a45e540b71deee0ff4456cf557fd48e0838360529c27bcb0c8b0f7dc7b8fd9fd13237c0282e65a092cf37a84bf49cc0dc4337af8cf064a2abd8e3800095c4657793310fc7bdae1bae346f37e9f4349ad29a3e93da5c3d50e58c70ded3b62e73eb57964e73f14cd5c17b755cd08d4e825b9c595b04b09fb743bb0022f0bed7d80b485ecf412816c9a018c55ea01ad3036028383d3b7883557feb3a2c81bce4a63fdaddc60185a63294af1c7d46742cb6165c6072d2cced672778da114b5b2531785cdd284ad5af1971e677419a316ef211924206b7b5b6e987f2b137714ecedf5da03d7c0cb27886e5dd0a513c5cf02d9373a2263cc013e5083e045a5d21c134cd1036886620916b9f8ccf9aa8535e6392220d20e10f546cc035f6010a11aa902a7b94e6afd80941cf6bb8c132ad92209d9e0e78ad130bd1be10f74168e51e189b05a78dbc447cfde8f671fb5bbe423f64dc6491954d4e4214e6085f6faa8ec3b760c493a3398754fa8e6c184b1c07af81d5a41086f3f3ccf12f0bb323089612124add693aff56b68df9e608875477ef597cbef0c9d8e724996a4411ae0597e929346a0e30aef9daec07eeb0d7b4021b50bc98555b0a268e924bad3fbd917aee7665453698e134d8b37f18fdb379c4876de2cf377d1093933721d1ff088e85f488552c07cf36f57f6c2e6c3d9259aa1deed6b85b877ec2d2f0f3198773a12fb4d8a983f84899ccc6b5fe03e82086980a585467dd2957418219af28be9de1faa1a8f65a963c8fb6cd7af2698cb9c093b48771fa7ef38aed549c180ffe34056beda687290c334598f5840e68caeb7f315b1feab4d3ec6f616d60e4a810b9584df39d983931c60a690eacacce496dd8b0f28cc9027b4a70c1857073a05c4d3030da20ed3a4eabc0da7f4a227d00f1385464cf76953b27c32c5bff244295a26d95ccac743b4d7398816d1282e42b476dfbeccbb2cfd48f089f9bac7fd8e2c6c526b8d809cd89c53437e453f1a06660533a4c4e407cefdd50e7ddd56858bb418a5117adcf20c5e60e3bf82c15fe77a5657f2343fca37718cb121403ea2ae564658061390f24fe024ca117c166080e10b5c9ddf4063dbe3634ab2af868be2f05c8349951c856ffb986e4ed4adf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
