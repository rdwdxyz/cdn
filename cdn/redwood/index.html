<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d70fdf5fecf46c596ee21502e11b4ad0ab45bd4ec6712269ad5ef99001ffb9a5790647ba078a36bc88acd1c971fde30d04038d6ba06e53ab7e783eb1ba430e412d1a823b40d0ed8eb78bab565eb07b21e5a85c7b2cfc44d0f8638f58f1531e88b8488bd1215ca7c04aaf1d59ffd7dd11537e8a58f7a04b9b05c86c10f387caa464f2f94cb1abbb2457fb174afaf7de03ffe716328bcb9f8862dbee26cef73ee2779cab91d9f2ad5d4cb571da6b185ea42a92b641bf4e85e566dc975e838bec7413efc49cfea37c1a022361204073387e2e063229633451c5c96ef085504981e82ca90ca79298badc57f6bc8442fffbe8d60b7cd5946f2f7b28e1ff775884256b935da99808bf695581267afe7e0373da5c33a6dfd1f04ab024716cfea9492a3337207758e190712c1bb8eaf97d49579216371176fa9258483f813bf460e94b9d794cbac69f8a80d80ccdd224068eccb263a9925322945c31268dc7a90be289ca8e3d276d882f930e4fd2aa5403616bad6d89e46a4bd97754c72d4981f353142d16506a3368ee2eb4979fb7b976cabe610ac615cbaebfbee542e288488e0272f1a780f45d87c5362ad3f559be7079666c00673db43d514a909e4a8ba1efe4b0fff6df0abf2d3cc87ac357820580bba587acd744648ea59f1f57791a1183e6f01bcb31b9f34e0c50b37d6f9ee01c05dbf07053ae361ca3345cb58a53d1c08544b04ccfc72d90b7de27c8437f33b458be3ab3b6d07bea6fbcaede2bb02771cc418b5b4f2ddfb533dfaf1ec5b1c3a410bf5206e2b55b6a9a00635394ff3e440ab7ba0a9cda76faee0e27ede0b68ae4d97e9c163f5dfe2e68a573dfd73a17d0e53ab5ef6daa908a4a09ced6d56e03d0ea495dbf9ebdead772329830f26d924ef983ab94ea3d260228dbaf2f43faa2d39517bdadb61f373ecb9e40f8b769e0a393e9a71e825454a53094968a8268fa8cb2649f4a0b52bf417e363d015e7fa2133bcd0313748a3df7b17729d5456b17b61e7dcf0a078a314339d3d2b14606b2be46aa57870886db760a4981bee0880772f71f019e113e6737ae8c3540c84326db2b7816f69876eb0ca66616353501b63e277446359404ce1c4bd2af226c59b5cfefb84371f1143cf61d61a5170a2ce6a28cc00d7a29c4c742d64f0de0bcb37b91d3a403ec781e81647bed5cd7f1577fe6f0c51408de45cee92da533cbb91af0be2f05eb93583f18dc9fdd340c509758b41d235763008a49fe13b4494272ba15cd1427f60eb95e55a0de061979237eac518b38d529b1fec73c1b976d72107bb06d987f90a412a5ca57486617dcc4cee4950ceae3464bb2a4d043202d37a3cf19409a3555b9875a1ae40c769c1dd61f4d24cb91364d055986b7fbed90e6591355774ea5737125f91462f741311f8c4fda556348e95d668a0d43d36528c28c3725d5b3b441110ba6b08e1978c5a3073885604987458459791e8c985370f570cec8408a6d973254bf88e8e6047bb405eace903e381099eea64f49aaa04f2d8602a6888c11e6c29aaba9a98724da85c290a0b238f991de409bc0351ea8a3212bb81b84b756a7bdd2d3d79f8b2da7d9324f5565d611c626db8c973337582ee97fda0cea3753c6162b41ae7a1c6d734bfa8da81e81766fd1c7e1e8576f08a6ab79da7e8d1fd71a9392ac786c05cabee2e4241757ad140b11896576728cc61ef89fb0b80e2e21f0b5122b1ded146a8c21e73a372f9fcd41fab298a80650b1b954d17bb18c3cd5cc2046013c6053acba9d67062171fdd9b2900db41f7570a09b83946fed16537d0013682cb2882c5a54019e8afd4ea12d1f2a898bc20745242193628c5d7d50afa1af43a0173c2bac635a4facd0d3e76c96ac0eddfa004935e9d93d6063f49d2e7a4a2d75dc40f42820726988276d4c1fff978e9125930dba89c9f309e48e1e542fd56bbde42904a1453d3f79f8ff3af086fc063de6110382f946100b6b39d70751ac9d5e92700ce67802a2977c68904f4728500a4762091c74dff462189a44cec586951fe5cfeeef74b40c61d33a79ad52899a9d5e6ad0bdb29b8af51de29d48e4f34443b5229a6a5a50e42089c050a6c16930662605723d7bb4165e84227168adb1fc4f693da76ba7250e57e2153a8a875ee7ff99907d4afe973687c70a5cf398118adcc07e42e01da28075a4474ff0c78445d8c113be607675d6e194980dde2ed45ba597c2bc913593b3e4a74d6d3147e21b39a1f82db7bed2b3fcf0b619514bf22d06208352a22a1fe3348728a2dac3f17cc4b177b33ab7d99afe8df810be53f7b8919c91a21e5534621ffea5310feff575b2f8f42f063a052b6edd458913f25f7ee86ee1e6c54e4a497a55deb770ecf7e01da1ba2edfc947e01408fcd650db36fa19e8acebad8eb5f978ff5cb49cfe2811f411244de34d6b057e1586569dfe23aa2b8731fa1081158afb1d53e0ae8dc15cd6c10bfb9a98386df9fa11ae2f9d3ad63b4b8ca651c4fc85138728dd8bfe77555bb2e3c5d103976e863cbabc5db9034688d2851dd9a9eacca7e1c67968733e4b2a28309a090c63aac966bc490bbd97a877f4e52bd49f090b68a1b097ca9f7c4d15074ce129666fa8b53a6c0a01d9fd68960d0f534e6b42f507081f87d4515d86e2078418eabe0ae0e64dbc7daf122f576fc82362ce6acc9743e82aada51d7a7e18306f3001415f2674c41979d0cf14a4a7918534acb0161d8921a00cd51f7644e6a4dee8c9a01051a47d3c2117b7d666f1ab83d41d94615b82559e28d360812c603102932ce88517bc4ab27545985077f44edd0b213bf37cc44e807f4706dac7ca29b7edf5f02452498c006976b67eba5247d4394eed85295a507dea4b6690b82d045365b884dd59218580d220bb1d3cff0efdac7f043abc7471885e5b058720be5ed2a518810b7a3a278b125039b23585532fe7302a1ab37e3b4bb356a4f4d9a2312f5b7f495add40c96e93b89e48f453064ce186114686e6acf18268466847baa7b1983cbb9475df81eaca786d0da04bef67544d41ee50a64ffa0e631cf85d276c1591fd91fd2a16b9ba44a25f61ea147bb50e37f440bfef32b9cc75046b8d62f6619ef2acee9a46fff3e668f30d528b63f1948959fb6004e3af6ca0b80268ce1bcee22e43a641bb9fc6045a7a657e572ee35dc121024c100beeecf892e9196cdef14fd6a87dd3aa385e515eecdc3e3a5d4bf4b648030223ef1927b7a1a4800cd66c830f8577f2451bc98155981d3eb3df6de1b42ef7a6c0649d39644183a67386de6e7469e13d7768468a28a2be1ab8030ff27a37cb257e742a4c7879b73487fd0ce3dcc4949fd43300f5d139ad87f3af17fc470f7bc8fdcecab6d59587fd7fe5b740f955d1b69ef63c7583e9730beb888ee8574f5f1ec79eae9c080cf5d44fd37dc3797449133a3906023c330522d33ac6d36eb170b569fe8673e78b3413303efec9931d9521cdd21425e98fa38998ae1225d295377a5d47adae980f2e1b757e8c89d6960ed2645ae9596eaf46cccc7392767cf35d23fa8aea505fa76629212cc1dd743e1d5e6f2a707ed7a10ea003de753988c770cb6b6350ae90b253c4f799172c4590ee1c676c55893396e46bc32240f0fb289d9387dcf49658dad31314ee66621d746dcecfc45e36836fdf350146d48770e157ebac18719235dd045a3de7ca29ca53e3f402e0358e35e2117d0e638cff8b08424d1d57923d0c4d4bd176538edc4fbf0524bae27f36ee5b25980ddd18faa42bd1e43e6f5cf165921c330300be7e203723e47550780d51b9c1b2fcd712edfbcfce4ba849a292158de12ec9d106ec4c59b5fb438647d061e98836c35bfa975492ce335a32260f7b7afe660c23d3e7558fb1e4a0922a310a25594ec47166a43106046428739e84c4db54e723922798b2c1a6790efef0b672884b290db290c2ca84aa3732b046f690401c110de5c3a5dfcef43bea35a1fac021dab1fb6d448f3a1e50a14e9a2e42cfac12d86eaffe11b6f4776ab0a5a5561afe6e2f4937d9d958b9d5294dd99d1c62dd7019f8b40957db414a14b12a87cd6a3dbd20e7e31b1f146a758fddb1f48a8aa046f069787ef1c5058dbfca8a6ab480d35fb419350343d9c05e0aceb93c7786427144ea15becd47431063c7cd296e1757a63475aa1ee028b0285b047a8a754c130004eaff823360760de57b39fbcfc56614c283c1b8283a0194f0e4977e25a273035a2953f3d5e5110b75b4e2fe59652a01ba70a383474168999cd5f36508b405bd1811e248389caad9cd20f0de71e1ae1912117613dd95db0b64ced74c4c3fb68bfe3e023b568d6f5938378ce5535de4c72408cfceef196ddbb30e6f1d59fedd7d3487fe5289b97df8f125fa297ba6ed6453beae109d3cc807bb543ae37d99d0971a6e1832376c78defeff7b4d49a937cffc87eb3905de5fe9589fb5dc4ae56548a02e9bae8729c70a4d4a4a0c4f11a97b94f61c53da4058cff4f99e91715f80cbb98326d9938f5dc78c995aea4740ec20a0f197a761034e0790bdb01639f4df3e297732be1f7f0e99942b5fdf3d51f976e6a76e600e1d8c3ca98d73af6641c744311e48f0111745345c818769ed2aecd7d5722383706529d08209c1eb4d1dd4e238b31159405aa7efd3445ba091feedf495c65131363013a0d33e977945393e211b9f4552bb5ddf2d209c6e151b2505da82d7da6ce9fd72097fd5e8063331a3a8d78af3cb3cc226034931b79b760b56e21c36cfb027b309cef4583686f0efeac4f2345d4a49a68b2c562d900b202e09e50501345fc98d793d23030981b0d339c97959afdda727370c8fddbdcbe5bfc6239d59f6cc471637f223e642c8b745e92da2417f1a4418d14cc2ba5fcbea1c7be1bd7d270554f43d415a0c7d79834b6101ae6f55a0a09cf09b2beafaddd14ca318d849405e9f2d982fc08b031d4a0c18d389d4514a5f94fe25ec765aa5226c7e1d1348a248d8163ed321d4ab9097496adbecb0fb04b69d3a57a52ef26b315bdfe4483f561aa97b27510931e3003f2eeeea94ea0e1c61aeec2d252e22e5445936147a02641fd9bde219fdab1f402a47ae6543aa75d4a38cc114880b52f3bd1f292565acc871b6180ec4c62bea8bd15d02f491afe3ba563ef72ef5385f1f7a60f1fdf4c04c24ecc23dfcc98133908ca860cd8f94c7581708d1f40a4fec244774bdb3cfacf3f94dbb219f0828e6dc1f0ae38f7b437442b146e6a9aa43fdb20ff7f934b26f528ac569791a01ae140d23a4864d0f645326fdced3eba379e1de1f5f196e1e3819216318379fba26e7d586ee524df83ee80a15cdc75dbeeae70dbed273936d2171d11bbbfbe137ec7f8e70486842c12d65aa848203386074a8a855c12ef5c15a6e4150e339917e8eab09662637c06728dfa4baffa01640c528c63c4454eb26d720454386c2ab9696c9e41b9aaf01db7bea41a018e84cec7df9923195207caf6f7e559c6eb644ebd09311648812b415780af9a929ab528d7becbe4671f9091802a9ddce8c9e8c21e8bf64385ca46af0e2e54d93a5e96033aec3e66bb3825c0e01d4aabcca6041f5fedf9bb3bc1fb2533af61befb116e4e737135ca7044d0d89da48a7754a70c72385245880eb91b30d9fe36db71db407815619e5573b125ae82dc39275c723167d5ba5e4b8a2887c05e90d24f4a0bbab9d09b4ecc0b30ff686cc6bb507f9666c953e55446c9af90f6ff8f160cb2129b957e5308a8efd422735063b5988f3f49c87a36dd3b7659ba2887873afa0fbc6cbfb1aa013b0d20df66bcaa085093af27d5de72425cad0ee18d49d3da68ae403ce890dae851a56ec3888e20ea5d29f76686d7150008257442429cde075dee197a450303fb736de93e1dc70e72b717767498d7e0320e53ba98e7083741451e98815800a99eb055d9c0c2b751df89b262f9c1ea41c70e0688612e0fdc0eebcdc1dbf8cb8faa9fb6ba1952925393890bdb78aed23d0c936ec47c8f976e7575418a65048ae41b688316079f7dfd6b85713416ed1cd5771f85439c3c084f1cdb926cb328511640e505f3a1fdc38e711c42c7998f7af9661bcca647c2503eb4440b84e064737966cea1dda644ddadd90ad02a1e687dbef6bf12415e7e807e70c359ee81582caaff4294fcfc083d1ec16634def505bdca277b3d8357b4e0de1e8acee02df6da084cb19d9b0b54abc5ae6332d668c1fc7f96b9826c0f6e6c6762949f0c9120e5c8be3ded3c859b53c514a2abbe965811b3d522f2d5cec04c4ace197943aee45b53fd178549220f29f11d09148f1f8e08785e07e199f1cf3dd612fdaaa55c700f1b8b4bc79aa018539e933d8e1a432932d3d9e4c13e68f8562369f9141a8a4e4bc30e3c4588c6e0f197a9a7eb532257ae521c516cc28fe9c1968bdd00bf29ea640e34fd331b34c42ce021c2e0da2ad7448e2579b186cbc623f1b80a39d4a22b220c327a81d234673162fb14d886a98d4a4908669b39d98caa22812031309a301fcb5503d96be37059a8f311eeea4795669bd226bc13254eda1ad3fb63092da0bbc733ace43d7cbe8b4bdfd0b801aaf7b3d2d319203f3eac730617644df6d447fceadafe181754e140b9697b8251232ca8433a6e6024c3cdd74323564e8301ba19a99600fe3a746f2c51133a290181cc219b3cb3814c3a3be4403cdf5f8f48ad6f0662479db6fcbc5e38347d1df6bf144e40bd47b0d2a120efe13284f15eef82e671fbad0d9d318527884885eaa05362a34fe1b89fb26f92dcae3eb0a1e1a727f7a04c276c53afd6164ac340e58fbcb6d97645718aa50dfd5931b339102f126ab3f800d036a8a262ea2ed6d25567a45b3e8653aa9f135769153cc8597b37ac0254298c8e91f24246fe5addd1daf5cc8335c81d581f534736464eea5ba7b87d512c9de207183777c534a62ab9bdf63039331dfa191dd5c207f4333c1f0d424e29d1b97304a2c6862006ca6653da8364c7d395c4ab4863aa9da26f20fcb9013187761eb43b7365a84026b16bfdff5d78dd49d271d41b507de073424f4f48a66dee81baace29133260093075b9f9664ab6ddd809fd97ad4b7e4078aea992e1cf98e34bf88e1e435c4b142f3a893d2ce575361c07dcecb666470e273ffe5cf45e41d0bf617ea39ac40b3f8852eeae0e0786563c07652b6d5586d29e56ae400c2748f1e9d09f131d9a08a45f3aa558949ca0d0a74a2257da088f4369c38ef8f94fe10494cc533fb9e4ffe32d315b9198942bcfb368ce3251c544d5dcaf621e681fafeb2a0968de67106e62c0bc59c5fdeadc2614f482a2d596e4f2d336138489e940043d099f4d059c6ad3fe6abb0cac958c704611b8d7d8a2196f79685b2122eb1f7866a97242c731dcff65e66b0b6b4ec0e3dc6d7c7dc7782d7e707fd1298db447d61fe88f722cff53da0105efc58a79d47d751fdf641311f73eb5129d69797de86045159c69f9e7313b753820165e84f7a80043e68c16123f72ffbdc6cd3530a00f992202991f638c7dece3213aab0790d240ec551bfa5a4b2ad492fcb3eaa9415214ccb4f070c7493019f8af1e453fb706910ec4755dfd61e2c2091a8d95c52d2e45f21f517180fdbff522748fee1cff7bd827fe0e8d8e3e56e396ac7a35e3a4c75f67a247540fb01b8dee80783aaac06bcdf2d21bf00cbce878bcbbd6524dfbeddcc4702943780b4483b2183b0925c158c604fde2989f15d9c81fdddc2404003984034b30f0441495fbdb2f199d67603cde558583ab77d8be9adcf56ce2d3944bb0bfc2d8bfe9d1af2af575e11fb1d04abc9832e597fa572fd47da0cb72f7aef513c51c9dc41f45f4662f91ecc66e77beb79e229b56ee0c3e7eab3dbe7862bda9d09fb758e817a7b7553d27ea761a77cdadabaf1dbd679c9a1aec0a48538bedc8282c28bdd1c611b1da5408623332373e9d219a0cf3f4cc93682fea0d2dc260323b7b3330b00e1927aa8182aae33b03753af21ecae7dbd9d6a8d378ec8ac2af29ce619f168b3539b858b3237ce4d28eb480ded8ad3f243c931c94bb73c8a4f70c3a35b3a2577cc246500b732bc71c59b497e86a0cb7f153f90aa20d4555816a9cc88f72f1ed883d6e86411f4d27f16fab702753611f667b9b9bca3246c7b3a63a012155b8a3b9d937eb461de8e63520975982175c7f843e0ebfbcc843fd77e8d6f4fe63e8d3f195ca97b27f8af6fcf3d4a5851991079e3e34ed2691b91b92be6be18fd6890e63bd64cc5c01e3796fe2f19c07e9a975aea07060a25fed9d97340d28f4c103ea6e95497d4c9603013eaeb9e929611de4a6e6dd5f62c52b4bb43f6036f7ed1b93397c81482d5092533524aaddb1f1803e1d0d1cee49e36e777f9e53f668966bc9537e79f70231ae885039f2ab3f3b7f76e747655bab0933f693cac370d6f3f04fbb8d234fc25094642564565466fac76c79f4115550bbaca85260e0f2cbe3a5c21a030f7195df4b34edb41774ccd0bdfca31d888f5c7a9b049246117af17e11fedcd026bf46197eb3deeab68b05a24a94a749dbd4d043fa2af4ea064aa1ea572532da44061720b1a6bf81cf8a32d350c9fef72401d1ceae302adeb202d4d98f0bb57349e9c9f095f5467cd8c0606ff6fcc12fc92f7e3232239697c36e18fdde451f56d234f1bbb45dd4484dc82b368adad9976bc7b4f3d2c64e4b162cba4a46aa86a8d7644ff3651b8ae39a58cd1621b8e4bc4bc28d8aa6863443e81eca44b740f898418db5cd57bf56d46abf093d45f55ba3e14690dbbd185bfd5821cab264d41cf4e2c47e6cd562b81249e79af4ce48d1e69301e599d7e3ce7581faf4629cf37ba57ebc213e3ff77ca15697e02020d0e1ac89c9857b3db714be83bf1f7f8f8140950b198a09eb7bcedfd56baec98be5a1fc9ef3a1ec5ca3f74645b01a418c73a185972de57f4618bf478a0099c8addda0f60acffadbb05bfec3a6aeb3d953aa45aaed4675157418f0ec6b13f3945d968e70dd8617b882cb1ee0bc44c4a22fd0d026bfd9be9c78514a06b196c85da6aa08f4198b8f4f87d14a5c26a8bce97c40ab13abdbaf9ae41e9d50245af140413b5b4f71df5f887435e04f06e051308d3cd741985da7553a500e974b4effdcd3074aa7003486eadfc1e3487dc3a8139e345c8d05ada1970779c9bc8872de453b4254e87b186e0c7ceaea3102a16ad508efeae99d257749f3362333d08a401fd621c10eda2322b2d88efa8e0385123602cf6ecb88761aa43c1a2c18c68f55aafd30c15acddedd20a721c68f5b1588bdcb473d04d222147c1ba57b49ced13c84267caa424268051b74636f0454a3ff093678a42e5846d8e494cedf9bb69e2d013cd8d1ce22d7257bb892ed8816a226f86798058300bbde108d9184d5c64197d61337d8469f2da01cda5ee02842bfef65e135555ee5c90f2ef9a42be4aca783470252894b4d6312c62fb23cbdd84e1b9b1487085b1269ab8678bbea25f574db90da980a02889114baf93144930d19c079a639103d31dd9d55e5ed7c0d28c364175b640e08931e33c23801f8276af0c33bac5628447fb3ac96460a18c33390934f43434f5ec5b90c60ed358232ca0289bd4342d1c1f12ca7a319399f4fca5e055f52bd691b09583cf3db913c0dbd71a0cad0e3dcb1fcbb81a3f523e31870841f56415fa716f2c78a523cb343261d258bc260d831fa9726b48d94a0f007a343d4885f8116ac0fe060e807ca24420e661336a8bfbb94fb8f95f3f996a2160ddd5281f35edf4332954031fa01dc7ba04f72136ca33591e6c6136b0c0b25d84787b7561425fb13406a9f50cce01f78ae29c80fd0d611a3496bff2a578d650499df1ab2fd4e2cd402c8d0411919fe37c4f385c65c869af6e2da4d907353f5148edf375a03869209fcae3bfd8239cf0144546e5d06d8ae1d591f58f4aa00b731d1ec087bce8c6f9ada6d05b79374c2865bbff4bf2aa8c21a279e51de05113e9be837d345703b354902c5a8515df036ad1d60d4a2e947cd2c0299623d397c86f912dc264c7629287dfb5ba36a5fe38424ab4ceb6e36bc7ddcc1d1e3986f9396531c2cffaf049717ea52b4f19cc5dc8f4513957ecb4031b431d61ccdc92aadfdeeaafb1280131bf805c1cce248c386ac4faa16d42b52c0792087c609a7abf8368029b5cc6d881fe4f73a2bd153c7dd029c44b9c80f04b6dc7199d7cfab53cd6fde7dc27ebe9277c5ee175c320d5924021fc20205879a310c3ddc8a32a881845e7b693aa1c42bc8052deca270a522384f6bde40bbe31c034e6b92f433713b8bac71222586b4f0849c50bec602efc35d77b2c2edbc03da6dd61925fee1b5e2008a11521b8b177c6d8a85145feac8f927cb6d184b820b4f147464d8c19c82c04bc682fd217be7337d523685eabeae674fc78cbc0facea52f2bb0c920413e53d624c22f7deead61aa57836dabf8c0c301bd720629c6aa7e782ad80fc21046a6723cffc5ffbf38096ea7cd8d1bdf4d4c5a474d628b17c322a8f86ea0853a247bca8136b91a94eee91ceebc36afd9202166a26e2e630df161f8ad2729618b21234f7351341659980aa4e1155e692c3004675f7c1f392806a6102cdc75c93e1cb6de6a2b678bc709b367c87309d87f7cfdd15928c1380555ab4c5983566f0895b63871f6e91e4913a6afc0f12b0c79dd9b6212e574b67f705a1b42c4dcc20123c5d3fae799ab04fdd4fe4d0a8371775452c19d9bd157f3a3dc080e9ca359855d71b12d1c6664b82d643131db66cb2d4b84f15977e3902b909575a6b624feeec886259accf71dc47d209b74590766e45ffda7b4066a4b20084e0a0d952b71dcbf9f57e1d75c1ba6e7fd74cc8452a2460474e8790a6fca7f5ef6114788e8fb68cd2cf665d04e5272ba02deab28451bae04ccc53b6382094b2053dfef727a92ea244601a07cda8201b72aee102a03b1426e74b9be5e72601cb382d3a685752c229cf1c84619c1610210f720e534377e6ba51fa8a9b4814593a227ff70c5b39f2f167f99ed43b4d2104e923729d4f867eead6fc4a189dd1f55eb3e386204c7aa2ededd34e167c6db04666b23b6609de5672ac63f3378595c01462e00a5cf78946faba4049158405791014c094b6f1e67c73807fa20fba589b742c233527184214b7e2bbad10662be71189ef695dee6944f2654199dfa8aa8e25299eece0632f4f62dbfc41bd2e40e494e0ba98c2df040b51bdf28390b2dba52ebfa73a62eac4b6d9ac62d36ba300d483fa4449a0453b2302503c51e49e5fb28fef41b3855289f0eb430141dd45b3f5536722fd6da442c5c7a83a29f019c79c4ff038b4e6a4f8f96c277a42341c7a990ea722a4599e5e5d6ec4600d7b721d9b478c5dc5d5f7c14174e32e7241cbbd4900a2b672a3a17d2eb747ae5d92122d4f83ec87b060c772872f37b3fdbd2e45569ecb860f4c45444a8c7b6310914cba99b12df51a411b5b06846be250fa5047a75c92b0227749d02e55813b947b7f785ec40f7a7af0b371e113b7455d1681d7cf2b2c8e26d8ea58826e94e632e975be591ee33ae38c641c5cc2b1d74a4992c53b7396393861772d53be0753e07d717bd9caeed88bea5752b37437f12a5fc88e5ffac7463b21e6fb01ba2f4aadbeacefc38b46a53fc8ac8e05da842d866e6e2a09ca0c2f2e2641e63132152f6edad7f39bbe0ef64670b68d7a8bc0a08117d02f0b4715c0fa5b9359cf6f90a24ee794a2bd2393508bfec3941ef5d89c4373966877e6b5ccd902b5b61929cc913b0144d935f3c3480e70409d5277ee2e8c544f1c41bc400a0232b7a7b1b04e01cf54062a3c5b55eea65431c592dcff89422487e3ca94c8660c34892a9482a478eec70efb146573b35cefc30bf9860d738ce0e743798dfdda946d3ea311f472cc8b22a9851b7c875b6e0473c7c5754a9de98d9410f016c04fdf18622f3ac6db90e8ff9802745de1e40f76ff62097917d602d3410ac741df3b9bc7b9bcc4bb7ca97f6ae097a5efcb60ecb764ac16540948d49c917109f27c9b7f986aa791b42dd38decdda533f8682c9ab8e64368def5d67527e85e34c7318a42a39fcb10e91ae39f0a5059cad57d4cfb17c4f93176e916e26925e50627342f4839438069398290aaf84dd51f0048588a8e04881c52cf4aa85289a4c2d93d54324031414240d9401e0029541e573c691e4aa92957d54bf013bf65a8624d52f53ad62ca40f9bbbef99aadb7f24fbf1bb50ea41e605f772d154b690e3a372923ba1f2966f5b193ef14d2586a90f2717d571a86938dd05a1aa6dfc6163b016d264031206de8eb71a70effe36ec06e6712dba674c3e42b3ebf79b5ddb8a216fff2843f35a06d8a03d4ead717b5aa9227c616d8ba1e0bcf4a81606a258d4f802246db96d88e93bcd8fbfd9716cf2efbcb1132e4f52ad8379400c1e1483241fbd1708e6503ac9c422d85fbc84c32f88e3e473720147fbc95b155aad97981d792a88b1114dd3dc33aaa79ce63c4aab3ae8442c3427955958aa985656fb33db313dfc3292df1328c2513580d0528388f5f712aed4af870b9f2ba5c0f916b6011f25ab49226e1fc2e0b1753f760311b494f92403df8a8d6ff0048b300df52b89320662263b1e8033e59c8f854606641124575a1354a656e91dc85d47948fe193c381709f6376f80c6f56e654ddb42a27a1ea49ba198dfaec7097633c168daf229fb8c29fcb8e372eb95a8a4f6a259f4ca6d659b4173de7e7bd23b0a59cc74102de439a340f375d795345d145eb7a3ae15cdda01d30aad0738722d8519045cce7b591f4a01480b8c07a932f6a1511ff7859ac5d79340cc6a83fa14bcabfb807db4cb4e348e91b3f24172ffca1d02de7aa9e4709b17961ad2c8f1abbaefc75f6666167c93f23d0e911152ab78763c5af24c7bbc75312d1512de5a87adc773c514c48811112e7945dfea92a15e2ad6f897a221df5d7d7b18e5025df72cd11d9f19ad5f029905920727fb805095612adee4b09af4032e2fbf24cbab7468d574ef202cb3cd23e8cf975dbf18e3acf2541b8ef5c6c17f1e52a9b105944a6ad87b4a9b177c30feceb25025d5b620a9721015e8401951b13dccdef8e76bc0f30c407e6fedf4063fb66c8ce82e92b36ba55eb389af105cf99dda890d354b94cd05b1fac359fb82631615a20877ea5a70964ca3516d289915b60074c32b7e8798d9d1087695968367167c8cc09c8f9ba7fe604efeb850afca5d084cf5e61ec75fefaefbc01435329f6c4429d7f430b8df991e06ee2d485ecee87fd294e22f6504375c57a29e381c950b11d6494b3109c2227664f0ef6eedb19ab5bb5c2f331fbfa7c6610145bd346f930490e53c4af4df3c37a325860d8b5181158b09ec40999688c3668a503361f65c457666fbf0b6de237da71b6c882bef5bcb038684c76a628b669dedd9d04ffa3b328250b5f613fb6c487ddb2f2fc8c085dd8deefd68d1ad89e3d11c85906ef5cdf5cef0f64f2324f1f3b76843ea0986dab52eee3b69e462effe3b5ff3a779df00a4a58609ef353dfc9a90bda1d205c542e30b3fd6b290cb0ae5a63b5dc5d0f1e307bb3331a587c8a6b03277122902a11bf3eccbe3dbd32b2e6cedc03353cb7a3f9305f9ac16ba20843ed5d5bc3d8fd18c0905323b3570bbe2efb3df47ef747fcd31bc5604d6380f90cc298f6c2b96e2184ffaa4ee8525e1940973b90d3397fc3669b0402520b86d9f49a7a4987395456c471d6da16ca499de3effd72817e5523eed913a340b2253b85176d9d151452f89e344e44ed66cd9255ddd18494f81bb0c5e06083b3b9fc96a05f75c6ae3f04cf652dd5dcecc9adbd3b2922a42490e7b57eca57a9b3642b439224688c87dfda4d681b91eae2df4ef705ab4efa14c2977da0fad739ceae3147c911b472eba84889216185ad026d9935a7139c543a1886312397228fe3a61f64fa06b36472bd2c1bcc2639964f42d8bafc689348479342533612c76314b6d096406e7cafb7d8397e4486ded1a6b43eddfe713d5dd3c5b9fd3b830c21be8eca34b40603ab68ea0b32e2e07354a7b7830096a9aeb7d463cea95a62a5061301706e507a3bd0b7c773ee870622560bd851ffeccb407d90fa46b08d2201590b7e921ec4ba05e2d7f25dc197782643cbf2a8b132d44aaa2245cfc9cf5075f7f9d9152f847f872073803b43c1039f5cd4134379a86d846865b089ade4ee3b159f18d3e9ef3a986e901543d2e494422d987cdeebc39964ff33afe22115857171af9dc7430d59458aab2100efa5cd0b15a0747efe55a9e98f2681cf2769a45ae0bb2853ad9b05c8349a80fb4614ed0740abb3a7294e1d26c55364e2c8204b8b396d0ac7a9995a512be2ace0d7081867139f3fd9174fbda21657c9d4e1840c2a041919c98d220d7111e6ffbc05ef327eb4c58d82dcfe9478a1465c2b7db6dce5cffa1f5b3174311b27956a57886fc02051ec935a5057af63a0fe495f8aadba453d2d834771b29fa8572ff67008f8148320fa6521030f714b969ff48fd5f476870e756488dda8b6df3a0b5479ce2378eaa2e2f86c84d9f4a586b83fd5317b36785c048454f85a0842371edc1e46180b2e10c3e2fd727b473f7ff2651115fa9c652a17362f86adf8ca87a82166d1efa8dc5089be2f2a439a5b3f12d3e4a8b5e2a14572f8396e8f7440b1bbe88633adcd61b19415111293c6a2eff71ffc4cd83c0e34988d5cfd43e9f04c0b221081aae419c503e40193ef2de86112c773ee4e23466741b87f82eb5bf4e331a9bb6e8f5ac08c756a73a11f0e7727f643b8a7f7aeb420f1a4b71246db58d311c9417e1215989198538c11f88d83321d21f7c143bc5f50ca419d177153bdd4cee40aa0f3e637863986c6003ac45cc37c2d635ae50ac1505733725077a8b79519d78533cc3dc85f4022279881eeb21fde3f932be4e2a20e42edaac373190cbd43083c3730c2fb8a2e93010b719a32875b38887469815be9293842c1d1e7a4c6de571a5c6339e51f640943e360e83a2c92504b854ced1890a24b3cdfdd5967633ce445f4f276a2493c37fdd147d0fb21864c446aa8f39648dcdf2f24daba86b89d082ed52af40990c7b37126a9a2f2e543d4a40c4d0fd47b1f9f2c08eff1126cf20917a06ecd2b4e6f0a9abfadd779067cf0746001c20ac96b9768aef15ef0c62e3729ae6091678cfeb79c72d75b9f067d244f439792bd0fcba5330fb84ad2ca1a9005742135edca5e59a875975204f05ac3c4c466f948ad129ca99ba66967a8635c6bcf7b76a49ead0797e04612b4f5a36db705bca3b2f5957161f049afc314343ffc30a23f9b614801df6fcd09d15843ccbe8655b47f1788817538f45bca63fd32d0f286a259d24dffe6b75337948661e7c0cca3206e2616b97bb8752d1f86006065939a7f9d6ceea437cb5dc1965803219de8ab24f662df7476d2c28be9e4115f0d7487b24fc8b96b8f9edccbbb1a3dc6de221ca53e4d9ced11ac1f9d348c42cbae437e862e2f9658c74b798c9c80bf83a2801026b23eb411a1c85f666070affacf51d34ca9d85f12560b8ef3af7279d5ee49ffbb564afd053f1309bdd678302672f8e4b90d54abbdf6ef55178f9326f2f627bbeab7ab52fe9a9d247b761c7ecfeb8ebfa7ec00a229f2a579858aeac80758e4412d1c80f4b253a1018f4f298d9d82bfbe95c7df5e1ea1df2dc4424ce748712fac20678119453fdd8766aafd431f1daf0f85ddff817107196b70f6b0ab6fd06a21d602d2987172dacd34bd5038424861dc2ce7e7cd192079d3bb2095aaf099f6e9faa384e3205eea3f831bda331de4740c16cc0d4264e28bb84c61a9137d29ddd83b8bdb8918a1c0db93bc5911eccf7f6281eabbddb6b0f481dba30555a50e88b5c874efa0c1779b9fbd55323e7bd9499c5c0a0759f33f837c97e2d0e0b7f7ece743e324c5c201f1f684867827eba59cec75da17800b12224d2c4a6af953252b8cda4485100620d22f75893a59a8544bc682b80b7ed2c54e0a5d2eb847e3b68afa633fd2fc8ab0f53a8f9eae1576c4566b52e9d6a5d6a66eb4b0fe49cf5533f174d042cf830999f335b86ca9e936c668005dfe784fe1c990a2514e7342c5686e71b90bcd0298803b880306d2310724f1f734fb8f0152d72cad96e1681435086008513b2aa4cbd0895710816956976ee1ea1d9970c01e6bd8a19fe5cbcf13ee722a5e8c0012a128012d27e7e854efb3f1477dd8889dd1702b7bb2564db22b242962baed4805f6f5397f180912070b411495afdf2386b1a5a8f7809c4a4b5ee90e0ce10873437a089b85a3c888e6cedfe2c2394f41efb1f1f14527bb9bf29e5e7a8fedaef6f148061c11b44209854bfdbc503666dda2149b5d37d70b0d538f3c34c33d96e7f99423c1d22ec3899c52512dd391a0c4064839c3e9ed813c777c4106417efc7808832fdccdd895a169e5ae61f89a284da2d705006e3ec00fd532c6c14b32fc7d3600ce62683524ff0f631ac9ce7753832930cb6ea2ed5431f348fc92885d6b57e42cccce18c97cae9a41f3245b0fd405faf473af9dbaa8c2673c5dc5b1664dbe95e369e23948155b4a1bae19bc8808c67b9070d5449cc5fec981b4176280cc05f4131dcdf996ab92b68bde0bc630d01288af74eb870cad579a1b23d3d87e6b266270dbf2f9c61f442999f9b441fbf328eb7331c39f6ccf54d97ce0b05a6689ef691fd9616d91030d4a8b2d82b03f42d3405dd2bef12d313207d0c3d366b8017c70c426ded0a900a5652b887de3f41084a011d06484edc1afd44521b97529b961149276c11e0f20fafa329d469d0e208a24e7101b13bdfe870c220f09960e904164f8261b016995effb59e256696ad1f634db2db914dd52200701d1ea584afa8aa8d3a653ef4e33533712a570d6deea7bfa0e1d9d461a1cf85fefcfb6e96936e4a991f5d1e5f733d72fbd3c4e095490a6675977e8a899a7ad5aa06bae494a30180364a0238ed3f8dcdcfa1cd59b95477b8bbfb0455617d048fb47c327cd3000d7974caa620c89a3bd92bc22ad9edf7fa66eeb13f11196b2306c88faefbd8bae78893c395fbf42247b8573e8052d0a1b7fbf0f7659e089dbcf0851f82627679b8099b276bdb0cf6ac7a77321daa2f38992038ac189871b219a38f455348370767bc318f492f0a89c1ad6bf7a9dfd8194014b07e0407d75e386cef88efb2be1645526991444566ced8a064ba8882157b608977c57cd82fa91ce61e97d25c4410c81dd315e4cc90a12dba5beef455a7cba5926781082f084fa8ec9e8544c78ae5daabf42ea4a38a82afe9db5ed0c47637ee89f334d9841c1e8759bf7cef2e294aa95e041a33327ea1869572b5fa7aefa58dbb5d38df09cc4a0e8bc9402bfdf593817e98f574fa867e829abd5bd4f99ac360c3a6430c816bd7eb6a6e3e094a6a7513a91c09e0980b49893b5fc39963b1435a8e9d7de8960af631287a18bd9c930af39a5b593b64b92db02e65720a650e00b012a6e75701b257e66eac134b69c930b0ab74577ffe34cf27025677bf173810b13a90f619fe2b53c4b09fc34ba9d0d01e39757afe4bff5eac4ced98a2ebf57236a73febf2495c1fe973b3a13ad80f876f45ee677afe1c7cd94307d8978985fdd486ac64d56f88371c59f75a0b747bbe364515d5f29514e75640f612c7ed4441f0b88111d0043da8f7a936a77677a86e9e35cfc927b6424a2a8da5cc0e41b267a4c208b8226f80b69bc8f9476817aed197dd8b622e578c44382b17ec14e11d17f467a15f2854a05227f479fa50b498c76fa21bc9556c85e561530d8847e6751737557d181e4c50a521f6f7faaf283a98401f6709d0f11f73d5e0365b22ad4d89e72a4824276291c5dd5e70a47d76b8ac2a2372c490bc4bb2b89d39909c1da0d6b34192962a6a4adee75c534a786e7ed6422797dde87126c5316a5212ecfec284f974e1d8215147b4246359e7be84a74a67936ea99745cfe347bb7db104223bc40e692ac652d9395cdf9bf7b622ff2102d030b59663de8e547556833e828c57e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
