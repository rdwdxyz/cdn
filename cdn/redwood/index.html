<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"290d7b643182760338665d4fe544fc8afd50b054593c2d2ce1a757a221de05bee69647ec23a082aa76b92a9a0f035ac4e7d3d2ba060526d62c369dfeda05d11e04ed816a831673089d78d7b081a221e97ad958bc43695f32870c82c1e0d49ba9c54fc0cf78238a97a1c713529684f5838c84def70e386a32cb27c1684bf54c596c7a0279d998729b4ff2ab104fa6c94fd51849a83757eb0003fb2cdd046aef0aabc0783c7c2da7d11e0c7c853d97466aca4e3c03418cddc09159ce61a394c6f7e54659608b76c5093e0c873cca1a9f75cd5a89e7fce215e2b8f99480f09abedfcbaea52c7a61f00436e016091c188dab518e07e90d8fa1da89f9cd2a6cfd948b798d8a08b898bd1e5c16c405bd436d762e2b75ba893c2f1a7bd83cbf6cf570332c5a87ed75c9f50f8ad2df43fb4dcc663398c2aa485c25cc239b1984893fff6f190a462b3a7a7369bcbd45c5103a723edb0f18cc71971259ec37caccb758216849d0c6e631d9265aba17711a1e5c261f8c5ae35b971650ad37849e19da47c33d30403885f664d970cf62ce5dac0db74298c9ed82bae49d5b3989e5be7f3d114579fe54b71c574a035b6b66fa351b1e291a9f87d96df7dddd123e8fe0d0de865ddca79f22c5409ef59be312127a9c0d0d78b7491cc737a71c14b65e362d16598d04c0aae001fc6b1bfbe1a6f1a7781bb74b3fa54dc769b3c4beb6a8711c1822bdf41506d38235d36dee3127a4a4385beac097c4566f44e5eac1d5f863211f9f9fd4c1b508e428f76fbed46bade21c64cd34b25ab8d60a1e0ce319a9877f17c0796b97c52d561b29bb0778ef589a08a030ca43b6f3ec3f1a5414ea749f3541ef853e85abce29d988373bb72e70ad5370b121c00e68b6391f088805352ab248dfc170e4e91f04347b8a4996af98b1b27275a7778a6282a2887493923127e32601b823c8913f622ea8c0474d3b14b567dd23c2108a4ba70ef7c91b04aab8a525ada7efa8fd09b41bbe7f202f366661ea88c02aa68def23f0b919fdbc703c0c5a7b0e5ff01aa75383708c3294347863164fafc1a24599d22c2cc9bc7d967f6d8ef025b93516a97243d7a990d57423dabf2621ed85a2a78001c3697dc09835ce346256eb097d31933971caa98f58e043fb6ededce482ad6a51d96b6d2714a6f29036cb5c50b58ac38bd1908f9c049977e1a663da543f1ee8d0a18a951eb2779fc6db290248f161635b608ef0b9f5e70d02088387fd8269939d201ca2520a2fca0503646dc9894a5446fabcf5948ec00a522f1d73687c66e3f72f2c665dce4a0be6e74ff76f875cd7d5cc1f03c35971e8c4855a527680eebc8f886cd77484db5430dbb933fa78ca6fc2839831fa89a0bfa05e8d36418dfd9d487f3a54fa15901e576b639c3c2cdb8e36660210cacba80d4a7923edd892e5c851b092f4b4ec929916766171f93f97ec36946040630a3703cd2188734ae8e4febe40e7afe761299f33c607f9ec862bd468622d089ee27c65c0420e50d009c5f2c2db4980f3b97b1c31b1fbd7057ff933ffb6b99d6de797b33b65a70272dedf328406f51ee32c1fb7597f0a05e3f115c2c5b26b7b5b62eccae1d9a17b08654b65671108a942fdedda38aeec349ee2c94e77518e0bc4bc0b763f86656589886e1c137648cd6ee1b6eeafcd3d2bfe3f6b4c64ff3eac904cc062e6a69be079b4f577d92bc16100aa818d3c7ea82df8dd9429101c16a434b01638b3f188ffed3dff7439d9be593c7f476660b0aa1ade3b176d44ade98b9ff4e6be5d9a61541c046b357425496084461ed89bd99c02931c81e00d377a587c5ea89299dadcdbd8ebf5165909db060e719d18d3d4f709a302432cfc0f6c322f3fa37c2df5a08c391f03c62191f5c4fe9d3baa8f34b48cb34ee576846e05aa55b7f38471314d8bc9ab4bbf65521e90a10220c51500b820683bd21b24143fc52f5d9e01fa615ee2663380769db19ef6a6bc75f1d2df82f07b98ad24d8cae4cf207aca51192246e24dca564c81d47c7f8011866d6452ffa776403559b501055e92221640f208f1975c1a9b6c2b88a86fe671523c302e88facb1412bbcc9eade4e53ad04957b98bf8457e83da220b59131cb1d86714a9e18b449d7ed768c8f3dcc28c24261af5d11c9cef7ef74e33e623411956bb8024220e8b975924767986f01e387224228ef107206141435056145fdfcf4ce4a88e8b3a2ed7580bf9754412af2505112e9e98c1d8f63aabc9961af5dc8f6a79c5b2fb12e7e543581f6380ffbcecf1e78a6febd5770998f5c3c58091d3f153b33eeed021a010fd6b24bbcfbf476590c431cfa3b0ecb6d3d797c9c7456bac64b36b598e037c9e7f0e49e0068a76f91f5e5f761178b8e3a9edd4016d17cd34211ad659c934af2579fff7f3fce2eb9f6994ea457c8703b674ddfd67dade8822f8d321651cd59bdf0a8f40fb6840707edeb456a3c95cef2e296a7f7dc2ab2e1474808c3f2f176b4d11b2945dd0cd01ba06b5981e6aae6f3ea2615b0d328c8f5762c35273e4431655f7c389b8caec752b4ec9a2007dc40644fca948a87e080146d0c3c53ec93f4f424730ea68ae8b80c00ff6f9363270928d436ca5c45feed48178d716a822061a53463cf7131486c42d18cb3b65cc5f61ffa38a5931b38e764ebe95858c5a844bd174379c0c1338c40da2575b8841bd358e53b1ab558da22401cc7329e1fe66fa8a75afaf3a91d70069f404d2a8f35fc16e528cdc32259e6d3d44f67e9ae9dc7fd9144fd7da6ae39e6b8ad8b98d7fdc6feac5dad13b134e52ca22207051e99980281146c6f7df2cf2cd2d4686ea1689f0f647c6dfc5870faa5dd78273f163ff752e39b88ae11c02f5c468ba28982e9d199a1917e57861076d8697f2d58b8e0210863639a68d5d467ee8bb25c753a8f9ebea727c691cb3b2a67c55bbeecd15171b569bb6cd56de9fcfaf0e434467781593e1e4c310e57105dd665a0d78d6405126f0288c6d0c5f91f9a2296a35ed427813964a5e18cb25afb3e36c2281868ab36928b4e6ef5617ccf02598c1cbbb116f3d67a4d450abe69ca48447924878ca8f694e49be496bd27bb0119a6f96f544005770c6a7000df74f430671e5147219cee09b9c06554211ad9e28fd65122038499ab8be482ff9d4b21a87a73889386c4a3ef163251f633a2cb0f518ec3d08c284e35306b421dcfed18708ff772a56058a122c969fded6030ad428486ab26be1f02fb4b07ea92b22a330cf05aa759b76270155a6c98c49d6593de8a5a5972039eac2b3c3e85e904e564152d35f1953860d8b000b10e0956042f121e1b0591eb0bcd950c0e21e48a387c42c6fa68660edf52ca91f8f6491c0531eed3674ee85fa4b1f3fa675aaaf1795554eec62e016c35b8c385ba1e79dfb58b1eb4f97d774e35f0ebbc58ec0729da3a307cb3a6707817a087514b37a3aefe31a74227a349069f438ba845013ed83bf82490e08708e167323b0be41b8b5064be8eb28e43fbe6c98cfb66cabb7940564299c5cde76de38ea24312957e6fac189943cd02859edfc626b6e02708a712e25bb036bff6b59a35227826636d400b58fbbe2917f471378d10344c22c1f66ad6544802f0736e912a8c1b8e57cd6c71835e59b0f7b9bf7fe37d0d4528fb44074d05e5fac3f126de1ced334d6237f5b2f4b80f2f81091bdf9b323b273c2184e96bba9ecc96f035babf867301016951666f255aef35f4eb330b036ea0bf316c64fc16c1050dbbea6f26e408bd2edafe0ed3870ef4212c049c5c973a8910678934c4ed859c27d1e152dd6b73173c0afcc759989217d2228e9814e30987305f23d8e82e7ce53860bba0ebb3174514ef329c1f6df2a9270a77345f33fe70e1714c6ea4dd68bb8e40854111c28606b025f0244121d404442d93e0da592013247a162f015a8ea35b5ef720757c13bb0e55e19469b5c6bebb22e12e174cf48715d110e73b59f02194d4a878aa3297986571e3482672b8ee5707c97424345416d739950b1bc17a1eaa96dc91251c62467afd9d116e8a8df478d3dda3a721d4b129233618979cb63b7149bab24b8c65e4480dd855d91e70c88e352236f5698bd535ce39e77f5a085a272be86cd519103b8277aec68291129b23b87cca0d2bee4cfcf30e8304f71b678accca587bed423a58a151e90aa046c3f08748883e1e4760329667bb7821fb9a4598b61ba13521d129cd741855879acbe771e48c71480f8f09974d50f749ed4f29218700d3ec612f41e7cedcbc35cb5f4b5d7439fa45366bd9e4dffe7f79aa902447978ed147f0031c3d58c93d1a746af91188eea7c698e0f57f9709a8154208821e576e9394580d0fdd57b03ef0bb4a2bea178dda4417204f3334b4ddb33e3d83c1d40677dc7ac1c02350de4a1583c9198a883d9799e7832627abe426a8a45c744b4ed81d5af9534eca82f9abcdedee48f93b4cefb35357603dbb7cc339c50ff35302b3758f6775b41ba554a929af79e9139c83bd406b021ee856195c5bf073f91ead50b57eacf2462f60391b305d190c94ea7dfa145b607cddf5dc97ab313ff17441aba88224a029d4a4b61d9130a8b5d41b22b77cb14ed97b704c357af5a95f0ad4b6df290e1f960270807f9a822b13d8bb446ed552891141374f497c5a0fb77668e2435995a44832c61d5f0216ba4c14b73b88280f94138b06190f7eea55493faa305be91c98b350b1cadac14f505d80a25bb96f051241271ddd043cf91e4d9e134243512ad3808aceee865171836c0b71e35935d15ca51a29a0e3aed32746d89030e513a4ceaf632009ab5a88b259d0cdbbb250b34a2e9a1d82a5c063c25cb8418c2b6e50a09c516688efd8ca3e6c924cf1b6f71b7e764a3d0dc3c639bc7398b07a968c66f7c2e336eee6a48268fc2aefb887b02ea5881a83fdb3b82d7e2a6ce833b8e28c9b661e40e5d03e793eda355bae742c3135a360477f0eb62b4d9ebfbac04e2cf2ddec9953f01051aa1b879ad1efd45a2c2e3178c175c4e61b36d95da68afec9c88e0752817c3550eef779e2f4e297de16359e99a1ff55ab29432f5b51f71a1d4c7be2203ba8262b8ad513aac82e6bae2657f030987f15d8646d5396fecb13d3cbdf9a184e75cbcd9b3ea112b3ce192dd00c82c28e0ebe8a76b7ab78c6ac342a497e066362c01c85ea843b104a655d13fcc36dfe4ef7c594248a3cc6d26bf92b21bec2642a3191ac5e4662f9c3c86169bfc49c22e6b91b46dacae183bebb75639fab352b7ffd8a2dbd6e4f37320e996a634900d0955d7123dd1449585a7064773d22d34a1fbbab3543ca9103f17f03dbbe657e154528ea5b1a317cd33effffccde06dd4d04fb4021696d9ff9c4f4b4fff1857755ae3400cc41f65b156cf60351376565a41d6113dd97f9fca320e914976ba33d2ac65e43c7695a402693bbcbf630acd6b4a72f515511019b4d71942a69368af2b70c48c47a699ba46dec6d54a4bad85a68c4476507cdc9bdc4dda17c16e2eb2a394be2c186221d488efed749b2c8a6ef762b91b0cd758925e77e45ba075b203ce3cc28115840a932d63dda3a952923cb3a759624bfc7745a66be5b1016db965b4c29411dcb4c619a76f162edcbddc547eb0eeaca3fc6def830d2334718319cf14b10b315e0f1008bc07304a3703b9c6992418069b1495152104e0bc68008856adec84d2c0990b66a16ecdb6f3ae13e56566e17cc6e6d629530926151d5044f09313a2ff2fe994debe7c519f18faa5da57e0558caacd49a732a03977112de6e1f876877940d4b39c1d60286e790c43f26107685606bbe5e262b4f166857a32fe51e101614e711b6fa610c637b5dffff5f4e02d8a9c2fb6bea602363b2c55c92bb1b0904949e774458494d6a0aa25f652d5a8e94179d7416393768431bf7ca24b115e8628a531ef5afc6d75ef0921bbef1bb49b38f16769c2786c9320998a592cc32aca555866f92ce5858aa6afd5c5cf8619b51fcb4490f56d12c521ca7352b92b6c262836532a473938e491866ace5fc30d27308d4e6b8835856d1f34295709c99fe9105ae270d118c1ca56f094de2cd90c00f3012a139fca0f98ae2f35d1072654d73aa30708ad1bc6e2df0b82a27f9a98e1a68dfa98d7d85eddf2e702729204459ae9d6107dfd40347c7c9d5d260cfc6e7d634fbbf9ec27e2038f5a5f0d07452794316450e8f3cfe64426625ae65ae9f015455d9564884bba288cfb96918f8743905e2016c667477d4123debb0b553d043ef4750e371e5188badebae04d238e64ce4440984adde83eb83bfe6d5f7ea5b5503c72927a6b3afeae7af62d1cc913536b3b170530f0aa0e0bdaea4d8ae228e56b884722b5e8515b6cedfe3a12203b115f401b8717a4c96639f4d034be91bdd54d6af8a63ae1de721c3f9fd6959d16012023f074f1317641db9da5ee9ad787a239d38925a4eaddb54e2b3a949932c018a2442f3dfb1c06628dc56da50db601c9f21e0f437b27a2d6da5b3287f2baa96db06be74994580c676f9a2ce3223ca203bdcee009f4e1939c3b9bbcdea475f0722c182b88fdba1ab7e24ce801a3bf1846a0723daa8cc4fd44a68d909789a3f2e34ab093850982bac1ff9dbc41e1e2b4c51febca6e8081de82caa0c610f4dae0b7790627e7cd6b11367c9f2a4a3bb1933e45608b9f1c02916905cbe1584019d677036907dc03df7025995913022cbb8e328dd148d9d818ecf5bcda69cd7a562708985c14485ef1755f871b96110ca666dc00fe481e921e1b3f4b374256ad4b449653c815425d8f9077cc28ff253452c4b481146322ea060e03bfab9e524022181af20f442cff1bd9f6b43e38276680f9256c48fe90757e68ec6d070def7ec2cb90bd5c45e11b584726aa53cfe6c93440559495e5edb0aa674dbafba3048e5d902431189bdd8253febc1798b807bae4bf6037c6ab7cdbead75d9cdd50f11dd0e5b81ad4d598066b0ed298310d3c4ef97e938683a8d43913d31c745f08ae0cfc11b2eadcca614fa11901d754a86b80dbe08002998315e9887676e741c19db6faee5269aed01aae6bef15008704dd084b238d1274042ac2e7c65a3e011e2820bab4912b1ef35f67cc15eb8a6a06806fe33f31e4e862756f9f190c1f6e91ea22bfd0abfec89429a1b6b4d69490da12e4a3bae67ba9dcfe61c7bc4b11a14b83f26b7cae4b162ee1188da589341fb2cd09d990908382191053576426fd6ae04251775f0925f158f402fe03f1dac61a87ab6b465eef03e35217d8be416457b01021608069ce1233a45b4d450a9b9ba966672fb8f0401c69d8624bab35700e698c86e664f8b0458734246604c332dd643ddeef3c65b08275b8d131f74d42d1828585c7a401c149ba3de9805857f0add7dcff92f1d478c37c084c5b48e87b97b0c84a7a3b9b35efdc846630ec1bbd8ec1c6eacddfceae3fca5397ae33bece1d0aa2be67acbb7bc581f69e6e0d3e5f66488f54c019e33b784431a738a9150e5b9936d11bd2fddccb1098e7e7c7af96a5b83c407f1d091f38d0c0f3997317004467ba2f478afe8a70c3acdda75af5c7c7278b4f8fd6791c2d6a5876d8219be5d0016e2c821b9fe1981359b76209d9305b39129b854e44674dd92a25edf5db67d8a401c3d69ca58c84d3ebd77e81ecdd48a235e4d51efc56b75dc25ac0f0344598723d1d081a51a185ebdde766acb5a23391a6209d16574e4f705486152a10f0b06a5e9985603b13ab0cf70708616576d55f3fac09a096712c535e0c9d17e58d7cf004dbffa84efa409dc87206fdfa9a87b69f74f6f468497e564d8d349a9117c6bec93ed04f8efe442cf092aa2a2b2509067b7972dda056eea1da3575b7dc35bd1731da6f392b88ba9a8480aa88a1500c91974207f70f2f2e51b990e4e23c8b897a8a2abf857d40f08d91c2bf35781d203392a6c8823f6186bfb959b96a5b7ad52e4aca3616e5e005a3819208d81c88a204b87b70285c13b8ffed7967b7084e6c0f35e9c1dcf523a7533cb1f1113339da4e29eb9c2cc912b128d83c17efd9d51483affed59d15821f31cd00e7f36dbd00c30cb23555e31772f3cc470efee9316c3a2261caf936971b9bc9c7acc94da78c2160938e864fafbe7f7c746c2d9725476ad6f35f7ad83920294c0a168e8c9b31455187cb74f291729d9ffcc96ea49a26cb652b2edf239838b45d5231547246704ef88228d9475907473614c95e10810d99ea64c033991ff6bcc5a0932d3307a8fa3e2a15cdfe268cbca2a2a1b9426c0204cadfd434969393110edd1eaada34d71557792a8c744db78cc51ac75a49350fc5bb61d0af21a4c41dbfd031a4e1a3926be0e1a4d11e1701076f545ae53a3ce14a8a02e4e1ff2a869dce38b280ab99ef17958ef175614d6943838495189a0cd9f0307afc9781d3b23663a4397638bd68e0388c1e378ad48c5bd55f419aecf1ebfcd16b307a919439bfc6791a307b319fd20ffb14831dc8ccc96952b060b03057480365d7e9b06c0dd58c89ee69ea52e1faaf7db3140c6dd935b016884581a4b40065de250f4f6a620c34305ba7a4cb465e7accdd9de36a3228ccbfc1bc960368a470f1f634fcc2ac17ab3add1aa34c042429e88a2a52d45decde3db284a50354333b617fbb89fd856ff1f0dc6e19e1f293700f9568427cc2c74ed7cf571a9f507c258e37d5ee4dd770bee7fc583356918c12fb3f35b6760e943db5edb48e4fec8361b58e0ac86febc9f652dbda6bc58e809487f925cb3ab5d6151aa9d866e7f78fdc074cab984deb1ea5e7846ba55aa09726be1639269231be53e2bd331ed0f23f945344b1f5bdfc3b0f4db9d77c39ecf58fc5e1f2c8fe650f0aa23dabb4f20534cebf198b395acc70b9bc302fdab2bd7f644e1f7d9022c043010fd84eb9a0e9646c70423c233914610f8da1baf412b2a3bd75468f4f64848ff47ee5319424ba21435eab222c1b864e6dcd8c5ed93d1c9d1a4b33e7195f0eb35b20933a3cee5561a255f4d5e5f13edff6d53be0a25826890e8d89d5dbc0f9559742628d08469e99ea21af9642bb43d28a1d742d255bdc28c3dad6b9c3256222b4320bbe4503980702b68bbaa215bf7313cd7bf5789da1c568a2db799559b20f3c4f1d6f5e93f5b7f8248bffd4c9b638fc4098146320cf07d377d398787853a0e37da942415de9b53e3afc07b9dd6981112dd08d5d1e585446acb4d29babef1e5b075749ddb4e5b47e1352d30f3165178bb9b2e51948d1f271b4bf18bf61473f2d86d201c40f3097956cbbf527e5540813fbe017777ae5c500afac38d3973edea63aa350b1cc32513a5b03c240ff690064ade106e0ec9e07060e004818ad5739d99fb75d4cad7b561a01ce25532a22bd26bdce87216347b4f797c1dc2005f4e849c34e3c621f0e7e807bde62964790ee261180cf5ddb7b53c1e7c655727976ed7cd50fe2bf0f14350162ab3a74626dce926ab9f15158fcb8efc97f73d3ed41308ba3df184265bdd9cdd35009663c13fd19680199f74f48139b3ca65b128f6face089f15f88953dfcbb4a4f01d58b39608cf1550456e54f58cf769a18cc05fcbdef6545b0a8227eed0f04e70b155cf1d336f4f85213c7f1212ffe2f95a16a71e8dd741fdd91c2f92449a5ac88776125ac769745fd48033cb8f049b1247a7103e19daec65c177afd31ecec1ac7090f78aee041469583c3cad9c8be364de8b8f48e86b6d1c8c3f262f44e53e1503f1690b2a21eb8454ba2f0e11dde07166b541a78761a7fd69e41fbc63fc69da4eebcb20d5515e82ca0130058b4d8cea0f297694a3fea297a350576efca15e752fbd532e678291331f77b24b21e5486ef71468e3f7ef39e6f667e4b368e82992dfd58b3a4761379cb8ccbc08b8ed16d765a4d45800d80d2fc724e861d0cdb17a7d23eb382c564ff53f6691c4e33ec1a10fd4d3ee0b40d680476078f9a824960eedbb3ce9c0e04f75a3f90024f4d788398e82e06320dcc076d667528566a01d95232ce03243452e76c9fc50b68b0fa0e4b72760f470710143cd95f060b74335dd1419a972b9f014d4ba808528069e2a803335bddc951bd66ed085bc67210e9595d7913d1deb9b809be96b84bb8ebf734e26020fdaae12d883986577bc8c416f421b2b79bc2a3e1ea9cdbb4eb691093d8ef206e8be4687cde2cdbc9e93cfd7740cad23c0ebc8f96f84065ca426e39e9a48fd353e6b750bf10df295ed29346bf37b5a13fe36ebe8c0fe1f28dbdaa9edaa3d259059ed4a0c6351445685c1d4bd47dab842173ed0d236bb0623076e0a60970a8f3f893213326e23a3f9a9f0b63f0155f1b16170ce5e3f2fae811cfce40d74a2c6c972e8e35452291c50d29d09ad300ea3b086966e1773263cc28d223154525998db92895c0f10b6109e5a1e17ff57b75ef3237ae7ba9755b5a2a4a483a135cf6c8c855ab4d079438becc097faee1c318bf866105ab85cf25897404c8b17d380b76badc36bb1db8b02462b9ff30e3d53f849c76b10eda37884193e7d7a300f79a1d395d0b1f2902b211fec967e2e447e801eefe8ff7910f4642fb53d7769ff807152dbeab64d99dada51f54798e7632698090937af8036d228715ee0de82d94a978d04d291d263a4d109fa8fb4218ace0c0514ef71a6f678a22ecf4492d25ee9f6214892e3e6c49adc9e5c0a88be43681713decc4365f768f0ccbc385e5315492f7f7bdbab2018758c09d707349ec99aa9f01632a833ae5ef7d54cc9b9d035409a0dfbef5e154ce04bb144bc9f415c5d376d1cdb7a83cae37424b280a0860f2a4ae2a6538d105348c8291e97b03cb46219b4724566f30f96676a261bfbd1fa82baecea53e10794a6df16c513b6f94bc3ac2e7f385c93c47850bc74ea8ff38407b8e0eed06c1e7e807503a0ede0348f299f9d5f30539594d022fb66a8571860328f0fecc30835000cf8314c6f22e4ca64a798519952ee354d8fb4dbfe179431562f5165136e265c6f19e04bbc634829eac446432b946f9480ce7ea1de374b01019605e8098549308363c79591b05b2fd407e867761b315b30a7fabcae009ea2587e3d37f3a5013d6cce48c7ee0ce0b2ba6a9c56ec389e4f99409d6346b907a91d91ec1c336a9ae01f13489667b1174a80f5e040d54aee104b55dad24bbbed1d72a4c0df2efbd2c146e50026ed9c507ad0c7de6816cd4b9e50b361ddcb14ceb6014b2f3c790353e08fb6e846c5e66816babb82eaa7428e1e15afa19feecde2b5381abbc64bec9cb2c3220ddc0d9194c2bf7a4993d0ee4751d6edea0abf9cdf897a0af022a5185355e6b52f099b6fb62b13c96852f9af8df4681494ad64762f62722258404d4b95e2c811c53a6984471d579c6dd1c499b6d6deaf709a25a400bbb386a3dd819dcd26baf1cc63614c13b384042426c42ede0ec153ab59deff29f4d82d386f90c84acf127d843a176dd193001f124e84b99b774154c734c30a84f3f1087c26aa28d18d55054e0536cc6d18dfe4a9de43043c754f5f7d5cc5037a9ab63aa88c5f16a7f52afc9b6a54469851138eca54f47896f844c659f99c7c4f4eca90ab9551206c5afbe0951c30d81bbeeca82c94139d7aa619de56331521b80fc04a306982cc7faa996b3f70f2ba1da30622b6cb843d821543a54ff9130984856e55b6118fa275f49baf549b4e722eaf35fa3667dc2d7a6ac46d9dc501f7bc62364780fdfcc0b9b588b74e01015fba6a9cacb38a79a666e93db2fe942d98fff170d6a40604785ce9bc59a72335840cf79153db325be0967b2901c32885151693ff6b891ef8d26d2880c0ee4e7027867ae47d7ab857ce34679eabcc791447120c7781d213abfbec25f975b511be4fa9e605f5c42967b79cb9e6d4b9faf96d15574cfb0893c8bc6e7721a4afa938353b7e8539ab120f5b049890fa57d2ae8a05a18adf10abf328acca5bdfc903e0801c86dfc922d43c8ba1eb3c07eb2b864a326750cfa710a06d0947edf5461c5099277e11d75c41d8e493cc08c6bb23467ec0b424f7ff37aa5ecf5b5b52b51a5d7ebf1446146dada0fa9f178daa1ebfb26c53c7bb10fa03c91b7dcd785598f03d0f9906b907de661d02837853010b005187f0f45e3d0606dab14dfe540eb7ba39695703e4b0f68fa7ddecd2d901bfb963397aff6b9c5aea3122187e5235716b281c27e0a3923918affe622e5452bb84713ee027a56f0dd59b75cebaf669bcb524921b59f6096b928805d5b3c6c7775631448962f136a8466f650e2377f54e2da2300a60709abf59f6f8dd739ba0d28a6405dc26817e21a24fb4289b627c7497f50691723e2a75284f89bb0d66f4ee07c9322a3e527868938c87e065a1e285342e84ca385436354ffa8c816c38b95d14e2df7cd01b3da8a18b64eae16b351cfa78ebf0899b779e6765a706088340a48a31af87ccb124347f7988344db01edae13d5397f043bbc7953db96d8eee1d9a9a047b33695ebc97d550c4316fc3f4b4ca1165b5d863ac986a45af913c1bffc846f339252ea8c23ae4d98d66d24c6bc8021954947f3d078116e5672f3861242226e42dcbd2077cac2ac17df64e4fa5cfb00f13de80f7cb1a51c9c24abb70ed92b049e516f5d101d33fd1af28055a88505a1c26f7ea092815bb697ddb1366f615891c324bb5a826f79b7f400798c751111ba5a749c64a909b5f5bc4fb28ebbe43692205fd4fb0e27fdf7214e313a0422fbbce752b1aa58599f57746c5585ff08533746255557fadee4f54d319f03066aa65e62ed5df51a79cdd80458c35198c91c0d16cd746ca7e2928d8ef8f729dbe2bf96b0c3ad33fd1c3d005e0e9a48ddc4984f62b032c5abdc9b8c8bcf2264d666d7b70ed209edd5ba2ab3fbc588ce0349ce7767f7177e85a8d77161a50439a153fdf427d437610c4a73be7a9b2e13449f30ed9673c7633f75996d4efe7233ba53e79bbe56b5e09f8e1eb233b0a7cda89bf6a84afaba2f7a98456f221fefddb633584d4cc9dfac0b15c5a7688894d5e91154cd6a8bf57926a575347df37bd1549b48bf89423260b110e799d99a4fe012fec3a30663c4f602144fad103090d1f488ef1590c47a56a8ba23a2da42d9bbe3caed3a9100cbb01771a7efc1b32f69ca6bd5a8af358bb3b69435579bad230e47dde3428e8efc30cce348136a68d01d2aed6600ae9ee25e16209249c117b8e2c3a3f1fbf6fe98561a7410810c17cf5927815d616057d61bed010da61967d4ae485e145d71797dcd698c3c135970d9facfb6af249a2960d51e692a08e198086b81ae6dbd686bb879eaf54437f01c86613d95331485e365c1694ba9c741b46bd8b6e2a27565174cfab3ecae447dc1ee1b150542e17434c4cb1619ef08a826c17ec06efd1b1f11b63a65533928b4b3d7531cb0e1ade6b90070efa463e7f3b84005546e9a22f6acbc0d50651a712f28a72b36e602bc8425eac81e71a7513441336db52cc45ca7d48a48b8cfc30ae65f155a5efee9d9163be95fe5858cc6788ca8f2b88aafb0cb84dedf357fe1aabbce8ca9a1739fd209d945988b49fe08a82dbe36ffe13361ded36e629f07b1e8cee15f80a1ed4cf4b3d920a1e01bdac779d4601c7e55dcfe02449fe4787ce7a77f8a42bef394f5dbdebe43facafe356b28cbc3d01bd83b1b361ed054a9a167c9539c82c089017ff9ede4477e8fbfb74ff99f8cb70ae54f5b00e4416161ea907f56b3c5379d4c504c3f179e12b36b18ac2a9c8b8b613b5bda281f88d201776946dc58d153dc46b36c2a215bed6fd9496c4f2206597cbed2e9aca9594e63e9aac9d23c4debee2a6d7f4424a503d1c2382857c505abd2f2265830786c0d98ee7c55ea0f10ffca5f46992bc8e94ad37d1a384f1c1c4c7136ee170e42fcbc19c4f27218ca5ca1abe99da0e1d290770c5e263fdafd05f2f0d3de2e8c8f056d1704ef54cc3f43c0b010deaa87b0386ed638c8f5b2787bff2e2ce3b34286b5d5c099f8c9e3fe51253377e522ede9ca8258c49e1a003ede13a69f022f5c7ef85f13045a95092fc284a11762c2fb1bc33a06042a68df70a96c9bf3916e0452b51a50a14c3a2987dcc6f3dbd3e3245bb8600e0f8f5603b7ef07ada96d723c5ba00f08f18da50916a7cf4387a143a9f3477593697fa405904fbdb94e0938afe06836d93649f98dc1816c38619dd5bc11d5934f7ed431f5d3a5a3c7e145bd00b6174adaed055916f6629e0c43cc9ad881932420b931620ba890d8e712545e541d5144e640031ca2532eb149731fbccb2d28f5fa09d993f106def182e197b605d51c0b316bbea004f207276d246a6efd8c09d312c14c49d098fcd92642427e9d7f492efed6dfbe0fdbdf6c92fd9faae513ac0ff33e98f6f00e64c8c92e0bd98d5097128b9b0da34d9f0700f6e9401f3cd6993a3b41640cefcda78bc6526305589d66ac93e84ecc161e4b6217186b381072a7ac90e6d15256422f973043ebe21a735d2373c3472d2f113e6fe9a9b4f921d93ae341711bb40663c0d24eb65364c6064a9f2d46bc156c2d05ed566491a972a6c0fec32e83c8f0bedc64a4f2284b4bd3cb0f45c3c9f2b20fbbee9609517167000c7a4c026cb46ea0b5759664be7442c7f8256edd5142dc09b398e7401ed4b3cf26ee90aea52438ea597a73e030bdf70c538b6ccce81212594d10dbde0afa76412b408b79c64aa88775c835ecbb6e3bbee313120066fc1d3593ac40ba8f0d2d4d3ca64f19dfdca5cfb557a72d7d21baad037806e02f33b2d49e7c417d3df108c6f33fb7c6ded15abcccf3761f36eaaad1ed4e2c85009de4d216c3d9b6ce630cc57a9d810a777621a4ea1b2159a0163f3b1e4ea8db0430d899908833d9146419ba008bb4c2840348ae29e39591588b6ec4e3f9ec01472b963ef83138b5d1368d1a11233401adcbd2e32b9d3fcaefe5e1e6dba7a05c9f7cf6f04116993d7953cee212de71b0a66c24a4f583180f2471232337f4ff6641f0efeb930c46ebd74aa332bcf00164a5968a9b0254e5ee90fbe79879d577aa834722d937dffcaeedfd7086ac4663edd4a38b6f098fbc499bf83d69ca52421b34049b45847333627b5be65d261a9dd40c04222cbad05e47a4c0342fbd38bb730b38f1d705ecd894480a8f863822d0321682163dd0ac3f56b3ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
