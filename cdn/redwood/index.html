<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b982490706eb60248e58e7b0876209a687ef75bb10590b1c640f777f3883ef78471427eac0733d266a05f45629a2327749e7d917827bfa9f7ded77ee601f3a4ff1ff5cad16e3ae88fbd7612d7e8958006383a2b119546132975ad8f74e38283b4952363bc7e4ea0e12e044b18f974a27e7ddb32fc83f05c418509886881b4ba6bc3786d941b50a20ac3f42691f53986e78f7a08b5653d1296367b10ecba8206fd9941733c9c52f6a532716637a29ceb795f6cad13a676cf91c30b653b9bff728df6efb01b682dd45b4c97028faccf9a09fb058b4376de28e088cf2ccfb30b8119effb10428006a0170911f81d86e709511f056330546f4a652428d84c63ac4701638ae0518518cf4dafd9bcd99ba198e70aa5c7ed208e76d9b41856b08b56b8adb21c2784e4a9aae2ae72df1e9af6082a763b6384528871d1da6e30a4872769939cd87ab920cd024699f45fc4499bd941542f991d426c66d97f52c722bc39ef115365a3f3a01a06961f46ce66f3a63c9d03e04352d7e3382709f61ebd8e78cefd484d368b0f3a75a90e5be5e678454bacdf6982a49f1ef2e72737b4813c9ffedeb4cd7f3eff36e6c10f80749afc355109e40bf062b22523a9de6e496ae67870c2930b2d652cea10d8f610e877bcdc7ae7b3cdeb7da14cf101af9fa8d901b39d59e9a6339d5dd6e6c56ff6800086679651fa639fafe092808c5fd75cb0c5d51e2d2cc5a29e6b322e8aecaebb2ea4b5fc837891a67319606314353899a2042396e01ca0e3cbec35faf022851a5db63a393b53b7afc829cfdc49526275bdf2c2f3a3817a1e8a7c89b52a84cea0c17cb0e083d5d9a1da5c7d8cc5acaaba7ad73f27d65ca82c0ff8a0e60e76befd512dc257ecf8e8a838602d5dd1acfe9e547b0d66af01e6722d25f9ecf34fb171c7d104931fca36682c0ba4c0b8ce95a7e63862e389341ea131150201c7dfeb87e2ba954043bd04fed15614a5969dda4b51a0d2669d5caceb0af282d62626c5907aa4cad3e9f5e8b8644da3a0012a527f26a52f376cfd9c4856556d7fbdde534dfb701b68a999692288c6161c0509a1c4ead7abe4a8000f363d1d3a35ed6e789f4bbecf641551119a90977de54f8baaee21418e5bcf180a46963c397f6baf35e82c0cbf724df1be6b671de12381b791340676a8e1e0186b3655ce7255a1f7225b22d11fc4e3f7a67ae9129ee9be34e1e6293b2b2518f00fc470ea0639f94173c3c62a8d40ebe106d998fee9e0b129efe582422ab807387bb5b0491d8493ea813d14c4cb2868aaeb4aa159e21d05ea6f8c59dbaa0dc31edff309b6bb667b257852961e216c584fa974b0391c04dd1c2c2b1e1d17256fa000e50472c9437b315c95fb374caafc8004e3c8dd46d9d7890df26eda7f499805a3bd4b596c9dfaa4497e9bb956154d078368757eff9f340d9567d213e4055b96f5481b67336e12077efe3e1886444f6273a1cdb7e52a5a4d1d71d8a200ef03dbf7433bf0bab1f90125c54c587b91823678b42ccb49675d49683c84e53778005597cba05cc7e81be0dfe51cb69505098f9447193b625fd96f241e9bae8215a050a30c4e962a786aa8089f525aca59e6dc84e1c419afb0c26a5cf4b8c94d506c9a19ce09ad65131ac8d682917ed0f8e9d899973c7fe72b5c3ae3b8e1c57d7445e21d9c5bb356c0175e395ce23ef1034573dd1278bcfc7bb136ae181f546cb03f95f7b4c5565beffaccc8684fff679463d0d8a31e63521d1b1e7ecd6872232c209aa367ec08a97e61e32ace7e435e8217406f5de9fd9a3ce98b64696d63a8576ee46e2dfd18c17f977d38fd8ba74d217485dcf870e28879ea254d1b971efd2274704d6388d1bab3c99205b482ae018512350cfd153ae3bd7378c7b806261273724b7d79fc5b3c4873fbc0f9d7ad8d4f6b3712076aa437fc4b8a7d8eae444b78fb7eae5107d900a11022355ee37eaa6e6500e0465cdb6ebf3e2746bba973794d84dc07d87fa32fa7efd58b3530799100ffffadd6784c3eb350a2699b68dbb2b42810f7b9a90128c974812d308adc9aa1f4d0e9f272a0f4d1fb99ef6d534c8dab72cdee7514b7043bc56c95d2c325fb2b0e04f826f848be20159791e4da347ab1ff91b8750ab0316bbb831f34dffe19b9d1caaf3e0532aada6b207f2cb9066b07b5da6314647916ae7f654e4083b3766c4449d0e9dae296445643278a27992b3f792a9946b83a44a085ae3279485e5128e8135f1e6fd9c67f11580c1ec9f6d6c53be7a41e7a6d68b32ccab612e108210b8348cb9d9070936e13e871faec74477cf70b137eba95a8f48e2b49b142cfe66f1cd53013456ece0cc33a37871e408d991793eec8a69615b718306c750ef5f7a1a77aa321a27f2c7bd5bc037cbbe8a1c1e4385ac9ca89a8a218283ad65adeeb709736837554c5296df32cfc7ea7d4d6d8b51f1128a9b3cd87ffdade8cbaca716131e5854bfd878d859558abd2128568c45941b6b79a9d8d2f085eba7191267eb09a64458d88c4a218b2a70e9bb6630c6cb69d8c35bc87adb1f7a9596157c96ee48e00af153008878634967a1f4aa9f9aac02aec9c044760cb31d185cf4d0cad7c227b01edc3fc895e1dec8704abaac57c0bfd6cfc0f47719e64a7b0eb390610004567492cad100d8b164557632d1398f6292685a2be85b9870e29b23134095bb02eb8c85f22da7e06795315e1483dbe999e34d5391bd03b9e411fd28c8f6e128ab6f30a2770492e04bd89762dffbc53c1d020fc8a2900222e6022fc71e19549cab84ad40134d8cc05d9a8509ce33a6ce15e6af2d11deb35373a785a88d3868f674eb160d224e5a2a3b4ea351d903bae2c4b3f41e1656f967ee491efc92498bac3304dab3ce07a3524d002f8993e97243da10d6974491f9c299a4ee6d50c01a23f866bebc9ea2e22274df6a3dcac779c2652f3253c98eb1c23db492631ba241b87760abb141df1de6c1d2c467cb67e585df4efbc3a82789b8e4cdf37e2dbcda23900717724b84dd2f439b42e9f0a1d3c0251b4167b5a1f0834509e534273a6734bc794ca073fc18a0f892fbc1ccf086737114520c9a73daf1c0a796da517b1d05fb9a342f3c88f0a74e9e09960d51e4fb8c97e50fcb36e79ca79eb891ebb80d5d17aaac5727bde51d2f65808bfd8c522e84e7b385f62ee82596a0b02ff211e5c9efec5d05bbba7eeab2f268bae7623a90fbe8f6faecb857f3d15072597d50a891dfbce5539fcbfc296ca0dece811c34582c4a9160509084abb76cf2d9d3756ba85567a1fd13ac35f037ec415e2595cf145c7a1df5e4f05ff8f7d3824fae430e198fa205a80278747574b83caed17e81eb6b41408d7b358c8ff31603ad87c3f218c3e8d81420042f25c69cfbbca5d64e3f0c37084456c8707e9aac731d0141bfc7e18404d73db657023be29fa17db61dd7fbf541651a2f36f8e276f260c6b39213675220af49ddab50cdb240ac40bbbd70679592b64a64ad6790d47f9d3c12c4c598fd60fae95d8e2c065979c16c4c7f08e1a5d6e29d4cdeeaae697cd1caac572f64add3af894fea78136bf065805d3484f871519921fbca8ff900d8b9e0ba397c20cfa2255ce9c572e3f7ba4d3f9c48c8ada12b63bdfe8127a7e9868e42648361c24c24a8ea080368c33d71e00bd3fcd76b468f8b586c40ee5dbafb7a4ee9099dcb9084abd778670748d33292c58242c179502bd40487a0d0726122f39d43379fcfe13bf94627323290c150b48bc24862109a19b6b72c005f3ef6d663a4f3cf240639bf781aa00b343d15680536bddc8c07bd6eade7ab963e1e05f8f7f39ebb99b04260b2fbe29c983cf017e6f04cb44616fed23d9e7636343dca6cab71d4924c2c88f9797aa7379542351aee578590f050c52919c7d3a3eaa0835e932492762c95a0a21c0da178068e1376a673929a8ec1a2635077dd89870f5e2b2b2ce9811a1c1ef0a808dacac77c6297ae90ea52acf8815715c198ac8715a9af969f1405a230496a169488cb73674505622a83b34c21b68f39a8532ae7760e31613d6eaf2c56c283d4b059173188d1de12bd2c75a0f25bee7577b26c919ecf6d5ab1db7745c6c2e2685e8c79786b47d908f533892c7b3f38ab6b1afd61c38828e7e56b8b9003d6fab8c783524fac64a06924873ef9704a998e5971e6b4b190abb8b3d2dee130034c2d599d54cda578651e5df01447c3f1b58494883c5580e3be7f7824372226194c72b5d76b3f04bc3b3474e32832e665a3fa220c029ff92d924fec151f1b3748fb4a48a1a23db1657c8de53be7ec502f481dd69680efb849e91a3e45566c25be710df61cf5c33393d5e7c466e3fddb63bf8e890ad5e7bde93ce6ef6ea6e95990f00bf2da9f84615d33093fa562c5b1190a094e45aad295776137f6c9160ecb95602cd7181d1ea26606950f9ca507625d1cb5095f349a5b292cb26c300c68d2916ce20b5217763d2071c3f7cb2800489f723f21a39b72c06cd80cc305f64b48560e03ce663188c1eb0da30c1ae442716f4fa4b8098d8933313d810b715ba9d3a379f047a7bcd6bdd15fd1189d111f6745b3e4c68bedc866d1e0cd392a1478c0d53067a9fc60c28e786c106d0f2c58600b7cb31afb19b8b6d07f61d219a71c606a8f1120f3b2d1d7b9f309f99654aabe378ba438f71661fd8a5ee73ab6321d3e6738427a17bd89c3c3c6244e93eade7203397b8fdd6536246588687d7bf3a3bd2def522fd732d10a828df1f465b6b347b1afaca5d3b958cd0f4b5f5c8d74fdda70f9fbe99964e8b13b4fde524aa65119b811e99be3e5a342813126f381a0d60266725408b610f1e6dd541e0642fe15f5104391f5bb2d813556c03766310abdff1d6a9b4de1a7e9442323fe0920f6bd855a6c8c538f865cd1276cbadc7a4a727368679ae332d7a8da5d9e4d29f3be6c961167465b652e1d667438e3b8015d3a925e962140721f27ad5f740c22441ececab8eafb063e73b051b03b6a44cf55e3e2bab6a8043b0a11fff6977897e68081c79d1facdc0e76989b0146e7ef85638930293c96fe246492296ae0d8ed8bb314b8c67c2786972e67d48049c18b3fac1bff5673be8bd0388db4771edb84408fb7c7751e43c744d3de24ffc3bd1641a5abd6c5ca562e2493ddd691f67979679884f8ff2e43b9346d0cf4be0d0c45f7fefcd6d41cec70ba69699b58f4a83db7efd85f9776c68e663b126b99b94338dfce8d795cbcf5396df163f17a8f02c5f7d31c9642a9da0d7c3f778bdf3dbfe02ae041919496386c22a3fdc433f91cf3bacc08daed5e6d96f25ba4aa1c302184934006dba05ac768e02b04d8d0257796583fdc88dc230627a6efbd1d892b5d3d6323582137445c3f9041ffd734e10cbe32d572b0b77a30271bab38cd62a3cb4dceffe841141c13d9c22ce0ccab0f15fdac8cd55ef23c9a6ddeedc49faf7df8d3b07cbf9225cbc7cbe9423ef0c60d9accbc3ef605e4f12e49faa342d4e22853c495739adfbcca349138cbf09d0b5554457873affdd618aa818377f3627cc3e119eecbfd382bcec19d9db28fb1f0507611d663022edc2a601f4b32eb911acbcea6a47d6c8cde127f7280204c86a1592ee7d08522ee7fbb184fb1aa091bbf981b46aadfd4b86e0de1299aa9cf42e203f61166c28455a2e1513db9cb8a6fa0ac02e5c14fb66e5c3aff77de50c499b595b4c703994976ee7aca6c6b1507fb2dc826b002a260ceb76866b6b27ef71032b679973f2eae6a478d17b13f80b07e3f465b325eb69506d25e00887fdce0a323e35fe56af36518fdaea23e56697e08c5286b0d8d80c0169eda244b96db935327aacbd64f315afbc3d34beaf25dc2a5ed4b584f8ac34758ea99c772938e08d72c2827944ce1f51d7b024328d9465d3fe4b4a3c6eaa22e98de7713bbf9817a5a720c1fad7a8acb46140bdd1e185a3c8bda5f7747d0df6377a721c32ce6f8a52b1b096aba7ccf6c9143cec60af9f336abf2fa63cca29201f45529a28d3784a7eb1d584cabf896060f310dff9cb1a92fc291bd7cd1c789f206209a68fefe2dc21e4d1f5fe360e8260397b36621a9ffe7205ca2bc1807b14ea9b7a4fa28360d7c55e888894f67faa8f6e34ce60ea2b49e70288a76c88ca437c309bcba61909c6f59591e945a573f90a073675e2e74a0e836688e2ee6653399728115da02631b806f004893c0ce073f8a9541ff83f29299aa9fe78158d1d78da0618b66aec27b923d040ceed70e6e809d695d96f4073fca51aab68c75f630598a91eff13559c40d661b761ad10a1796732c2daf0601ac4c5a5030e9f9039bca1a3e24ddf36fdbedbbe12f282e8ce6d829779f7f3e1b9b866e3f40054c5122981be951e7c12f02ca115faf644c4c412ea110d70178e67fb303174f8241b19388e6536d38ea5a08d01b7763118da525541469b54ddcddb9297940ffb89f4a4b1827537187e07368d89f624e81fbcf8ddf78592ca5c7cdcdffb288f1b5b62f0b57153680e05bae96c27e890eda2593d05e6c930349dbb29e65cf4b247d1bc512087782b5bcfeed9e95a997961522f22eced1eb2f6cbb10442c82a618c90711e3ac096d4fd32b6460d10e6dace273a7e25768977d7524be81627674cb56c3d53ad1497fa07f980b67f75c54abbcc92d46520539c4ca507b6f53f8b677ff37db9348ea2b620c25b6aed96e21b12fc8b22f1db08db45b26ce6d3bc244836a939ad1273311b99fee6eb8bc9e86ad572a1afbf4dcc26d3e68017f3f916c3f354aba9dbf50f5b4c4aa34ae63a5dae964391e1bff0338595d248d4e91387a5f401d1d9e74906329324109a11a7657e0d270cdb93edcee5f1461de24db80d38647da5c7db166f70517a9bb367431dbaea353039bfe276af98b5457bc1d377711477356fc59f4d67f974766bc55495414324e1603243400cbaca5124fadaf53aa2cfa22b2334d9b55981044bdb6a27f8c805a357baab94c66783f5716bfd936f3414dced1b642fa62e2443409ea47a6f98bd120ca91a2e1bd0dcf13ec394741bd7dedb9305254288eb3939ff4979e43c89211974251fcebc94f6a2b5e1e97c23848df5dd2d1a26ea14bd5e94d1da658df48320fbe7296f2681f8f0b74549286d01d509b65f131b9ede3c27b68f64a0541b2772aa5b736b19627f0d47436c7731a6e5de665bfe6edee81c6a494f51d183fa13057d7b0d76dd369e111de2650dc5615be98b02954b21672feb903fbdbda16a6b8f89ac358652519a65cb35b9af85e23c14beda916f1768f403b4bb5bc5a9ba4bc90b9843a94caf88e96e06b6559986b7f48dcd5b2985f778113959dadace054544e6371f79a7785d5cde347338683c6b870b96edf4bde32a6dd8ac58ad7c3850086c581ff9543382495d436b733d5441365986a7c0ee52035c427a511a6e99e83bbdb1fe3f1898836a5ce38fcb6d51a3c4eb08ec94ee83bf02ea38a4146d6a03d603c166dd20fd641735d66733e2307c566ff00dba6b81b72eb0737613fb54b2bfd25d21e600fe9dbe352a9726d09db9a1145faad1e6746ffcc7931977ee63dcb323a7cbfd8dd6ec26c93cc4fc444b2e6d5b9ebaef3bc51a8fde3f82aa867a589a7d1044b9f26067303e68a89990162e9cbf2504a3fbf4254820febd0da115bc4709596bab0bd7f9efe56112ed6a5be655733b87ab03d0a51bbc31dd1298ad543e0e4ef62cf780adfae9af08d286b5634675218874281f3945b4770e475b0afe75221e39dbabd8fc8cceddab703ad13570a898ba0d0dda2f69e72e9b0e7236795d3f6a6fb0e49705dd1cbecf182cdc2e649f0fbb229209aea645ca9bec2baddd239cee38f55944b36d1a9093801e9d9c9a22993a9cb45487702a276c7dbc0835fba2a5f179dab9a2699c4fb5611ae7197b0be73d3d525d171ba82c5f8fcf2d4687b501d14b5c6b15f26e21d141da869a464b6798d752d5848d7ed945fbf88ce8f939aa5d837b24039c3b0c929bb5de1b3e83772f11b65fc4ac0b488d9a67041a5763c1f8450bcfb6cf541638ca28a2c8b30a04711a1e0a2119d61090fb83f9919393886c07f7141d67595662f3937f9060380dd059ded89a537b68f716cb5b5187d497fc4c8265e71698592b1f2b59c8e7fbda578f612e87481894356d8e6d5d21cf86cabb69e484852ae6bb43403c14580d5f8a1d24f851280c929752dc0e9a02b2254cdf9c320f339e9f25423237c0eb8a5756e061773cc554fe409f264629b7ecd0cd70b93d125e63b246b30c8468a3980b68a8451443818d099f5eb1ac31bd935cc900e217e288745aded2d67d30d29c2bf87e839a067f092819d09c054fd44c2e93bf785e348ece02fd07311c7b39374c50fed51d912a909913ffbab27e83cd735e4fc82cc16b13a933bf4b85aad49c68e767359282c4380950d0244f73176073cebcfe4b660abcaa5ff862200744c9fe96e5e7b87f84a7f99589a83a69b54fc4263a350ed75f6d5c1f78134860db282db0806ea178801a64652faba72a2dcc353356935b6820b80fec507c47f1f06ec5cbccf7cfb526d6cdb051d2b0c9d4961ee6a62749e4b4b8cae7422af637d8521a55dee4bb9ac5a041cdfbff70d77eed97c6f9a81abcfab6f521d47df0c471e2f6633f034b1e73453e45ebf9dee90e07571778304dec943411f2454aeb05b6ce63f617842783dfac8c9121dd414aacc6670224006a14957824b2ffebb655c59b82196340b39c489d1148046ebae2e7e1a24edc273c9d268c5104b627ddf7ce87760eb40cd5075b46024f17414b5313aee9d5812078204eca1362f0d4730a6a12bd66ab5eea6cac0db4ce28be4d461a33b22ee291a8706b9e017242da6e584c1247048de1a2f0600f55938d12b299030a096514cb0085776dca9c1556c5d7d950101734f576184e1a1c31256afb4b2c4292a497b380ee2a627522c782ba0c26f1b4b6bef07e6bd7335a39f646e1b1394281b0c0b02a369445abc33c5d553a1092bd14a6b47398e84b00aa91be63eeefaf67a68b5fbd40155a8c0444de4434bad44bacd0e26f71f62e576da28502dfe3a879c81ad3eefb9332a5cc7ae4d0a5a73984ad6415a7917b72e463be7be1ba6a01bde544b362063f175acc3db003eb59407fde6e276a7e3a05890e7d30b0e394fad9dda63a4da3e987123f80c24ef419d95aa140fae75ca9382a6b72af664c89298cf0b4a712df0bcc132fda7421426d831eb7ca9080bd926cb0b1f00b5d3322623f570222c0f7f4135780d48775045403b9b8b91c3ceb6acb446d6eab5b8ebdd7a6a9573488082a1c224a11a0f97bbf1b4bc0b3e83ac7e9210809c5511924e64f664582dbc8e6d55672c47351827e51f79b6c8db4c1dc3721cddb6a64e0b4c8afb6f83fee194984178073f06893076c44a48425d249eb07b19db437908691a6924c282f472f50838a6432265ff8a89af85e83675af9df62c4c6f24ae1f92a8137f0e6e4b9a142ef0701bab104fffae8e4b02e21391d9561cec1c759a042e999dba8f1e4a471ab293064362e919e65276cd3eeae08eff06fc7babefbde9e304fd3fc04e932edaa0a13982e5654ac07cecca7ee1d35ae93709040342b1374069244bc417c83bf47dee07bf92395ff07a75ce9811db60b36c5f6d88b4b6f3fef1c49ca22defc435f4d4f4812042398a9e17e8a83e47ff71a19dc1837b10f42c970f416762bbc97ba18304ea683d0c8d2c717412618643a631089de0b1531840c57881d5bc148ec3b526ed6ea30ddb2575bf76d3ab337aa3440e6060f7addaaedcc0aa921778df27f592edd4f459e7aa7c3b940e9c40270b18c8c9b2f9ccd9c01b7ac56fa5098eca52eeb22ea8fe17a9e5afd55792343ea456e3d4db461d6ea0c13b7707a72593732f8c7c51dbc92bcef274b481853ee83f54238f530005445491ae8845ef8a1e7640740bff5c7d157b3e485a111f784d37061e04d6f4e077f6d9356e82d1d242cb8f540429903ea0f481348a38c6bdf2cc94b6933b6807a8bf953ae46fa748fe30aae0ae9c21b6bc7e5b0889dcb2fe338a5b147ce19a00fb110590698d6eb89ba62b90d0a9afac64c506ef28ea88473321166a9888de64e66146965b13aef165107aef67c127500316f8db19efdfec7004da8e5c59f32127235b11c69108fb21d599c9eb025655944d794516f77af1cc982edd44b531983f529c16e051256f6df70f8f50cf14af0772cab6b557e7fbd197b71bfe17e8e081f4a58b27a8299cdb63cd854a57a90e3e4509a6bbb411f9913f554bcb1b489dc4a04e69e69df1faf0e7c54edc1ac4b033756491c90bcece803242a5dfbc4611edbdc7ba05ad317212246bfedd02663dadbf79bb6f5b224380d8a8d77417186319899adb446cf515e8e250e04a33b3b698e2cb2ad6b92ffa09ce1430bdc3f65330da11a82bb28b416cda5c683256d60b176d4766688dba3e80e0eabca7ca8b02f7c97992338619e4cf04be303427c0adb5d3e86698861ab63e4c890a375509e029ac44a596bb0fdf125fe08f32395310c74f8eba702d77ec3d51daff1b8ff0a0818060cc460f39b040067ed08fc0d268f1b84cc4738db27379abd3aaa1e1456bf11b6039a58c65e9f37725d2e512b7588e35cd15bdcd6c222e9377c67417dccf05f1b9f29b8c999a0b20f1db321045cfd6a73b0c7830573b349410adf29cef22a7143eed74e7265216fd479b6a693e76e0a5602d8e72fee0a0179c84a4a9d5536bda9a1c349cf28c7683f91927d09f18c044d29cd140f8deb7a0c9120659d9a0a0f9834e3c138d73612282edc81358720b74b6a5b01b38dce5d354f92dce455a864a2632517ada359e0961c34a5fcbf9a84270ac7fc43191eeabe4f8c1c7435728ae015978db2102cb7636e432503f116adcd59c7eaa4631874fa06af2c3b18ba57d318ae026af41650e5853fe1c8dab03d74a4b3fc5d388d9a2212a2fb871dbed4f7381d274660e507a5b883b51c22a60aa41c690013c55cbf55f313a9f53f282cc77795aa67e89298e361ed07332a4948eb8323542577abc210d7efc418fbd724044fe77e44178aa0b989cf276108f3969989d7005bb9dad8ed4a1b1d7c0c37bc867b6e14e31ac68ff886300446e642badb6b9e2bfab48f2b802bad7997105aac42e0906d0f9b9e6ebddfef1e99d8f90059e1e1069cd6a1c114c6f627518ef0b6e6bf289972211507a5c1055fba7ddadb3b77e6dd7a46c71b4cda929aa91018508112fd84cdeb3fecc407cd5541b08999153ed2f0cf84d867b7f2953263c983628d368c601dc8e309764b83b250a95484d6e59e07f018233f8e78b4f6c83038ad2c56bc92dfc6f9097c9c2b518d6fe882688256c42b739c23edb00f4fef078511ef29a821fe105e6b08e60f377b222c23363d63b64f4da7a6a5d9af191f117e9cf9502ddab04fc30c7da3c8a0918e8d3e3a9b396db5039489f9e2881c27b1298512a3cecad00caf10914bf3ca364a7909539a8b62fdba3dbf4ee37a10d7b199b68eea2b87d609c3e31da10a8fdea7f3df8ab922bce08b4aac2165e43ff40f38cd81ca57a7b8ec06fddadb87e6a0ce1f634002ac74f0a678806034e21eb6154e2ace75c0fc2bbb26dd7cd2c6a959d2439a2758d00026a63bfc053c5e23362a4f2ca943ffdeb5c4fe928a5298943c6927a4f1ed4f5435e01edde39a2b1de670a1cb79e7d09862255623be1e58a2462fa6161a5fadfa7f5c380969ba5ef58b0c39e421aab5c443b9c34d1cb8c67c6d3bb1c880e888f95dab3ecefe430eb6c583e1245228f0fea50055fcb1ba60b0a541fb3cb52222dc61dc804bdd0430f673064b50edec6ba39b0e68b889ef1570c63a44fdf997792735b728d9ccb9e363398d3e599b43a6027ad0e6fd8e117af644c9693fa480d95fdf1acbe0279bdfe01c0affe2948cd3683d4c52837f5e0a8c08219dee12e7d244035384f30e486265aed53785731d0c8c17be8ffdc8236a78cf5b288ac59068034d8e735aa365720e2ef1b52e6a93c4ea6932e78d7b1622dbd0f371fd028c093fc21630f7f48e7e9a778df8f7dc160caf63b63bd88bf1de85403f781be4994526587f5766aa4cbb3f830678c0757103481a4d3c0de57f10cc1fb724edc5f3d4301205dfbfdc8a0b14483983c3b3d70a13ef03944ea4949462715b3c5cb1dd84fc86d7aa6ccab69960145944680867b6b3cee5611e76f3a08c1b7150f3c9a5ecc9d06a8421d7c603beb94bb3a5d410cddb9e481371df9f8298a4240928ead7b6fb41ac981117e93284d9f891cad4df12b787bb5758d24aa271b7d15b1704fb1912833d8e8e750f142771a992788151d3fe758ae96fb6812905e14a746562f48449e77ad7c690a0cb48f2c6ac2c51dcc707cb23b26f74a1a370a6cccd3f3cc359c5ce4efc6c2bca87aed5771dab040f8efa8ff351bc96a3158029ee4634b3c7273073807eb5fbfbba61871d302905345a5d525236631285c31204a15b8f21758bc344f5dd4bb0e2e90bad5106318c4949f9ab0894da39769e686a5d5dc8a7a62a0866cfb75be189b70ba6531783bab211669b7e11d08d3cadfb8d2c4ac4757fe4944618dd7a059ed0b218f392be80b0ef39b0e522e299821acc8d97468e8a7eb2996b9cd36e573c34a433728a10f5254e9c1dc119f240eb6816058c166bdd03b2fb445b7bb1e2f883fdbb26c69f91e65251e0f4b152f5812bcba6170662051bc40f19ce5f74fcbd99ec007d10e8f572208dd1d1fd1790e7e76e98791edf85001c1dea0a93f423404f2a499b191244440d8e84fd62123eb79c2fad7fd1ee9bc962837ce0e4b132e5d072292a651781bb2557654c78ad211dd2114c803c096a36298c359324d10bf78b375f4196e37ce1191915b8335d4861b24ed0f3c305f3d0d09115bcaa6ae3cb3fcc77c78c48c881c76b1e87e50fa4b8d10678a6c2e2695510b19669c6a9c57a533ebc5d6455321966e6c5f49437d41694725ec57234ef59297f42811b791f1ed1af5de5a6939636191434f43173a21e725459ac7c92a883a6a3662f3cc1abdc43bee10ab2a4bc1f05f87a3eb335dd089f729e06d394724aa2a936d5cfbf90dfee3f42d3891e89e38e7168917085190ebecb6054731d6115f18613f25ba53c3d33c4b0aaa6644b12c91a2ea4ec52f086376ca5ca09fcb133b9d32d7cc1b40d00940aca15ba80554fe69a79c2619640c01c1c11e7c750fc959cfc76574bb20cac2278bdeda4eab2af477066f2f1b8ec937a5f9d09cc05f681c82a1d2a0e81972ec829f3c4785a662d3a729c37b1f65d4fa2f101ecf66b6617357a5857c4b951c22b625e788cc14304bee3e2b383b2f80e6f48b289886a6c311c40c053b5f8de57efcc51aed3bb414ce1e66f15899d1fbe122aeee44d9f7da696bde311f90b12a1da48bb58d0f3cb13a21b73943823cdd39d3607d7ca9caacb08a47393cca8f8535e37439b9b6eba7b4ce6ee9f3792bd3b7d402e7e319adfa1c99ff6693344a3a871942903ce625044902491cadd11a86e50ee0ddddddab7c039681a21c21d5c90517b927cf65f6a16e7983c65588c7edd71b8153befe94a205f53ae81017d83b53a0ffdac205947597e8dd92d7eb2c728b7968154da2d3cdc512d1b02498a8b464958bbe80870b95397234943116c0af4c347be9c3812d4024dfca20dac0446c677d5074381c5794ea6d69fd030db24e97ae4d327821686521f8c9054ac6d69343e7367aaba32d1412f1a9b603c6c8f8caf73831443f2037ff6d7188828f7ce159937a16184e96cd21b318272c7ff6948b1e7060aa5b769a291ac977d866aa59e1ec36f10ae478cfa21d18bc40b98b3706e81d3b6d745658494b76017d14652226e34cbaeb9c69b50f550998d622eb654495b7cedce5be563a4372c2282a05f1d57fbfb153d4658323de05193b781b00a93efc29dd73183b6ef4bfd35a44a423e62c4eb52dc8095bfa2149b695d1136ea37ca4b83fad59d0ecfd7c07c5a21fb9d7b4d9f23ec84feec2f14e6d3878f5bad2e2f47b6e57f08935049663ef07ba56ce2a6c85219be60209b0314a206bcb171795242916395a85dfef7b54595840df85664a96dd5b0aafaa6dd388a61c501a416ad9dddd29597cedd7f4278e5c1263149072de68a89eca8083488e7fa765fcc099be5fe80955aad8d330b28d47a5b7c2d2c6ed3bf67159f4450cef86868244667828991b692e195a6ea385ed6fc8c34c141de46e3728e4f2b559e630039078ba0bf84ca536e2abea9ee401a5a71962d870d9ad04dc06c9d85b941fd66f31a74908485f9293d91b6e77ff8e10ade49e6be78a5de82aaa4dab5f26c8663261e8dcaf188edd04ef35c0f093a83f87f2d0952ef30c9ecbab684d1e1afb3a37fcb29e14564ac06d0eaf39057e4f7d2f88c45c6021d31080969145e337425d5017ea89d253042a1863a02591f03368f416b948745738515638f318c3783cfd7e216fe52f285068b03f53c7ebdd7dded660a410c49b86d994e7e882d8185819c224ba38b53e68edf8d17ce0d97d341030b02b8d977564247614afc4ee60e7c0cfec86cc3212304ea310f83bcad2d351b8f3a08d621ba06cac668b1093be18431455ec8dbe038490731419e628c8df3126ea3b180b4a2e4f8d300365180fb987f7e952f8ecba4ef2ecd787a46c052c8b6a532123573b89c21556cafc2eab88a87ce18951e28cb585ff5af6dc42e32debdc79bf35701fdd48209db8c09d3b13a5527d6bf3f8dbc9e0eca6c2c7d281163215fdeeec5ba3fa919200829cea04c70f344d9208ef2bf60735254280c79ecbeba4fc4007e95c541a5e321dea81d1a0d0c61bc8ba31e4e375f93b941c06fab8072765c6f5755ac1df892c0eec1ca58203a98827ce37d7710397c7c807193e51ec248ec027d2da432d9dbdbfcb609ebfdc8f4517bf881261f88e6c31912a0bf6b9f8c029f9916bffbff4db39860d61cdafce52112d109043b1531e48c2523a75f8336c0b63cdc74fce3d011ca28d530343f9b62a94fa3301e47c6bef58a3934359e011906e6b10fb1650992dd655ab2ce7118b9aa27dbe3ad32bad0393187f64a15523e270f3f0e2b8706039fbaf1e2bf0c7446e47f2f4b012f632c037ebc652902e0120448f75d9cb6b373457684ce647763fcc4de24eeb5add6ba5def084b8d6d8fa31f189f70cc7635551b3552431c5eb503a2412c621897a7f5f83961eeeb89a3486c4c104ed30913bad5cd28032aadb9b2b5373a0d81a76aba4c917149c3db90809fc4cfd275f169c8f042af9f7e83875e13896fd757df6c835b1286b3e1dabf9dffe4f4387f62223d6db400178af3f6d417a5b8699fb7fabf397a6a9347210e042ed6c79ab45f99efc0ab0938610a0ecece0558a7040a2682b7a124ccad77bbaf937986ce9078ab65e56db0acc8c344a72faf48b465ac9f8392ed61c03ed8fbdb27fb5c094f49c7e2e575603343b938b821213fa2ec9262edc3a1374c02b7eb3e3afdb89c4beeeca84ee04d6f4f325f87ac7c0777414005856a9dbf987c03b55ed476f580fcedec1c43e894e75261921d2d583bf65eccc381d3d999361d6bc615b014ac8fb0ccbc90463db5e59cbb84c40678cfa3622fe856ba1652a0aa97d840c03a0c93fec0d718a585cb26dc33907a3a7d7dfa0efac4dd4117b5507a4df8a0139eceb2dfd495b7f0b39357a4db82c9f243ac5ca61dc133e0c1ff18e8e6b7256def49314bfb8b56fc8ab75eb135e844bcc2dc8237a7c457682b9448b0eecd9e792b97bc75e67dc2ed4acddd3976d426c95d4c28701fc8b99e449160a8782b409dae000769c68b3d40d98421dbd866460ffc31acafc21386a6394e7a7d1b5053ada60ceb86fa08d75e911e19363a59d1a07eadacb9d8a6f80e241c1db84b6143699390129bb628e0a022c71b78f6d2b5fcfee397c24d30ec884c65ec3600efa517123fbf144fe0dd8934e626d015c8b3a67d6089fd6b26e616dbaf501b550f423d8e7722e44bb01f077d036fc69bc841061ed9fabe1aa958f1b43ebf25376f2cb0a7c3cf7139c282a24835d386e3d10ef5e8878b5f4e1c05cb80185167ee25f1398c9d4275ebd490e1fb2b14e9ce3b03f2e0954853608a2e968803ff69dda1fe49e404b154aec58b7d3f5b12858d6f4a24caa504995df6f8298cf4e87c3db7df424bf6be90b866643052ddb36e09c6f361ac0e2c0809fa3dd149a7ee2dd1162b60b28e4e6dfbdfcc1ab8d8184a32b41e77ef2ba3e07290b11e15f1ef2e1916a2b22213f5c6312780e341992b2e88856de496c660ad3347795e30efd516fa4389279991927ba49e2fd808cf4a784d2d456ce82c6f979d31c1d7b1f45712b8d51452674198707cc8fdd09b4ad4b1cbd3a26ccf829fcd82a0145c850144f27bfca9a9db25e2c2753abf3b2d09c023a29c21ba43631b78b384cb5321ab1c820b45da3a92fa5831b2bfc23bbd5c595ae394fab5d3b164497dad4c91d01f77365a65b3cf056d3460172467481917d803114c12eb676e12a9c8cd7187a9919b93c0affdb419e1f524dde7679025e1bf31072e70186a3e3d4c040e69342021630358735244690560e7c27e47bb6a1efe648afa552f5a8fc21658383cd6a03cab4d9484966ae6aaf620b19b72aca37497a03cfd46ccec42bc4d079bfaa2c3448ab9fb8668868f7e08090ce2be221962a0204aef6e200e0e2eb7bcdf4699994407fb3e7bc4d8fe58665d825aa5705c06fe884863eb1f1bc543aa710d6300f6be67d9fcf4f21da0343e420e9a2aa81b3bcc0746227f94ad556176c839ffbab7c70187b846e4b35e5488fa7fb9c06b964b0de78f321daee12e77e1dd063fbeb7336bf3328f1b2ccc27f67f78cb094776efcd9eff3518892b7d626d34234972fee0503eb7a9122f57fe2f2b8ed7dda5c7910ac6224b7cccd45f203482f8a366245dc6d5a0690eb195ae3083c20023b2f4e9b530eb0891cffe7713ca9cc083f09f53160110ca3bb2f0d2a985ef3520f6a2eb34c5f83e2cfa9254341b4834e0b0f2c08e997e7eba3a28f7a9f5ad85077ebac19445c9e6302c0d6ba1ee52d2de433e0370b63194710c277957477c6278d147f003a512e1cdd8e401a835b577990d172e487e1a1f3b85766b6c2d5ae04b44bf8e46d8665cb62f4300bcce574a2fb6a7342887b7b95a028215ad71c808bf08da78f4ae3bfc9140c93002e9267e295ec1cf3c64a9485d0462634bba0d9b426ed7282c163927d68842f93d82214869384f0eeccad07635a7d59155572fefba9b61136f16523929b7155e6d7e1273709d4c399426ed3c3e7e9d724bf21816256dc11ea91e2a8f637d48b46c822731f590db1552dfaf948dcf4b8f2d821c2cb3cb344e6d9772e13a117ba21c098fed88fcda71edfe8c2bc49011bdc74ad88890ec55bc251c50194e279fb028744a80d4fe0c9f5b64479f3995c7c85fa6611da9ecc8a6748edc54300117fc1141d533b865a5bcc109733a0a35644dadc80af82503d3f92b2f46b984ee9b2096e43ec8aa561afdedbe221c08126b3c2f74b6a6208686b5cfae0e0d6b7dd6bdd7a1727742e148338adba3be4a0144856da374e9bd724f4c8b7a4de7cb9f7a761e6559df4686e7c2fe4e1a40e161be506d2a417a85bf698ee9e7616208d0a0a6b90cd501191740f7f17bef4cd1453a41074811847d818f9cf28caf6ed5dd016b72f63cc15a931060ca7ebf23153dc7977520f94a3a84390a8662c17a33bb2e5c1e4a33d0776129abfd90efca7ce3512823d8a883cd9cd797ddb4c4357b0c5599e4bad56f0533be2ab3e2f1cf274804862b08cb0e711ea6799ae647436149c5ab618774021096f0b746b26f5d38cb5e882a6b5cb7559ab96219b8cce5ce838606fbf44ab6d94c9982d93ad88f1e8edff502e175cc56d5fd19302d53585386ee7ce29b730d6088d876e9952ab2e5e359cc8988205fc219778aad2c8338fb820c65381a89a0db27acb77002d45b85009e614ed860b1aad9044345a07840400b28f626ac281767aaee9c256dd784dbaaa4c38acdf38f1bed43ec372","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
