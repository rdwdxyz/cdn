<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03f5926cef73454adb04df3a4c882eb16e0f227706df21e2a28a3f1fdba40487c82ac8f726360f3f109dcca7ed68732dba5863fb05b0acf9a763e2fff00ac1c395cc3c48488146600d30b31e46ff940811dc12a247225f86229275bf5b9adc1b275aa3e4ae43e072aa0e448c6f9c1fd59d3f54d427041bc28880e357876d4d602a3b4cae23caca6f59148e6277ebcd10784c429f11dd3b9b7536b15bd09897b94fa96a1c071ba8feb9f98320d36d64b02c77a6e6505173001e4f24181019e86e59bab45a647f0e4f508d79b5618fec0cd5457a2ba58a59c4706cccd4a3035715bd37509e1d562cb1dfed23047d21978f2b60e8ab0cb1337ed67c25cecf2304d2bd814206dd6a7d9a9289d462ca5fe2105c45351764259886d3e0288cb5f81e0e14cc09db99c55e3b354da722b3a56ed11d80e10bed88306d4b97f3ad871d4f81d6dc6144dcd31ef0c436beec0c77042bc83804b67702544653e101c32f419ad391949d88da246f56612b37277f34cb2d3ad7493ed973f097870f3441ca53a80ed30ff64a4387e4ec0933fe990c8be61585eec2109fb6dd6f565070e6b9522bfbc5210b0444ca53f7e2aa0a0b561f8b23fec198c794a01e509d5ddf460e5685360ec01992d56ab3825667a9e5ea6c6eee1903f78dc36e6d35c1cd45b143192ae5f90ed4d8327f1f52a60edd4f10521339413f1d3f79a249963e8ee7c0fe8422e2a9470695f4140c8bb4eb18833fe6d6a21728370771feebfeb7ff01f8988648b312e45daf5a34ece74da7739c886cb1b3c1b6b33a5e59e62588be6a9b51acafd14713edd3e7dfa8d482ff06a55f2cd2cdebf065424edbf14653ee24bb8b9fa983cf0f2ffd0b60eb9589f470af2ad487ba872adbc00f48d07681886198b36b40e56830be45ec83fa34fc2bac54225bdaa020558e947cbfb0b92287a175536ce903e17bb7668bfd265df711aeeaf53caaaf7a6d90a10302839bf91d0d59f928e53209ef7b9be05f0f4e22a086ffec104d2b711a3486044b6f51254b0369952e7317300c44f812afd672cbfcaea7eb6b2a1649b88e26ec278fe124a29809b531ab1bd5df527e4557d1978460613e80c5c00c0b2cf193df40c85742e75f31e557142d46969d90171bd3168e346d0e92af91db6bd696c599f94d16621efb13670702d571cd807fa8244a69084bd506aac0827d94025a65cedad94008f17bd171cd14836429ba03544ab45ffca0ca899456dafac9768f6fb5a1a04bd62a22577905ccc5d1120c2b9f211a8ac8c9e9bf739ccd68ae3b6b968da4db7a870deb2140973fd63aa1ac66d73a074bb811c43cdc155e0365b96709c6f062f6aa9e401c9314f2ffe0c7aa1b6a0168d8283bfdc5549de35d3ad989a678602121d173b02d2c091f2a18f5e99e5bbd185a7592bfd7a214c3db7697710d1a8e55c251949ba4d9fcb71052c315091eace4542f9504f7d52adda9fdfc41137faca5d707aae25957689b92999017f287888a4d133bc63dceb0de7cbf2fab014e64b6994a7344efd47aa4ca856b4f53047175405b1f1a10be6f7ca19ceea6f048b43592bc0b394aab422ce3d2be3264ee5cee1d369087b040aeb45e8b4828d583cda72f574dcdb6797304e85c62f6deb5252e42aed86a4553bc7b945d51f3d08c1f4448056fc2039f39f560091e09bd85c4da3076944581b19db79bdcbcd20a7cff188ebd372da9da3d5d382f0ca8cfea672722269fe73b8cee4e4cfd768effdad9d8ae97377300f4da353d6df6725bb00e324cd78a095079e3a848888afb4ec8f8fe8cbe17853c805721eb3d90b10b5240d9ccd1360e4748737c74072d82abbb14be762552ff14cf7988d75732ebc97196c302408cc0da66c688a1ba27ce2b5a7a6bd3a3ac8d2c495b35039c9d085431b143838995905f02480090b8093709304a80ba5e1ee16fde4fc259265908dfc249c7dd0a871e7bfd44954888edadce33eb6a089b0aed7a278f1e9711a49054fa748fa9986e64453d60d993960bd7972e9255ee42182c2a1ae5f012bd30b58c2562b87723633563e6dbaed10a93468d3ccfa1e99243bc94c386eace3c11d6a5ff8feccb2132aea97e8bec221cb4fdb346e767c0376f9a6519625dedef2f0a72400a152b72fb58b04cd7fe67f0f9ec3b1026cc76e174ae3d0eb503596df80ed752b1cce4ceb2663d9605c7ad2d81438a50f9545e77bdfb060b65285ed9618f2991f114ddf861c9c09b5ff608a4c133b7773f9cdede16c25886ed926371e4e024335f8937eb873961d52e3bd36638c94dd657785643c152101fd815f2afd313932f6e05e0a38d0cc508d25b53501d88d893f25a4bce5a43756ea51be33f31b37026ee1792e996ea9a3eb29755073a971ee0a27c143d7af1811a44046d6b81eef9177d8892b7133ae26165d3656ddfc9f7736d54d1f6cd3c76941189b69c25bae923ff6b398b46032e266fc8b6a31308df34b4a20f0655def6f3ecaf2cacefcf1a6014822169255cefabbf06e16796a8f9315522d3a2493419616de4a4f9ef53c05a26b757c62936a2b29da49da740fe14119376fac8aa9ce762cda4b3fee65c8b3acf5735b3ebca255a2c775148c709f6c6c18bcd5146bf8964df599e2e0356c270ac6d90262d7661e0b30ea3dcc288e630cbac930f697f05d888949b4a995c0e92a6615b8722b4b2b6986eec6837bf30a573cb4b86f4a7342d616228a3f35acccfa977f47fdfbdc051da9d669712f24ad6c734e0c77a1ec755428fac607605fdf51e215bbd2c932b53868a0e165d2d8114a10412fbcbb9f64b87b1a0c15be32026fdb4499005d17b5ad2b8073ce3f69524b8a5d96874972405a29481b5cd755a5e553c0e2a2e4dbdf89993ea275af4131afb9edfd6aef5ee4337c96e62f7ce68f1ca6914c565e459cafc41697538b764309417a38ee9c5e4e356784b71ff772e582f504e96b7aafb990e64c300421e4b1055810f58a5af0671ad9725fac190c76d2c9afc75b3a7b3fa64a06eee62af671b914999e938f4ebf6bfd8fb7abb1789ba786c29d62ea88ba3e2063fc0ef1d6a7a346002b3eae2cffe77da6ad56a504f3700cbd3cc7e8b312b0e4bfae76ec38e56057b02738b74c0c5ad216c6d3751be1beb3013f410c8c40d308a9385b853ab4299952c1a451ebeeefd64dbba057de5405f13d8c7cf4b64f6298ce8ab76260187d4e92260e88c377aaaf7c4b3be8378dbcf075d1b67cf15707b1b2bf84e76f315bb5849ec5b1b5c49d6f0c9849be5bf08bf713b06019a03399aec72d8fd4a651608f11c620c4f0ff1b39e59e28f93a509c197dd03ec17a4767281f483993cbc2542e4d309da55e7e7a396f936f3059af8a3e7d254d21492f15fb829a797ac7cf33a91526215b349691742977fc63254202c9eaad23b28d485557098b3d48153f99b61474c12934d3c54d1cbdd2a85e4441f25e22504265e836e395b74c8fb8a1d67130aa662db87626887b31c5bd95f6c3c48c8ad67b142c1e44764c26661c6a7342d1623dd5d4bb73bb50cbe6b46fa41fb481635ba5af3ecc665133cb6a4f74735a697ea5c8b5d2159ec2a24a5c700572251f75e0e4f7ebc1a7db8aada5b213a652a76f55396f3ba8318409fefc92053840facc822881fb5cbd6c7dca938d0570dcdd254adcd1078b3eec26ab98fe1e39b9a9293e64202cad887836ee77c081d6984756ca96883bd78d63e1b02a1eae4c9098ff6d1a99cda54fa85de98a5e17fdc80df203a5be8df5a76c4ff7ced049a615bcf7871d69b7d98f8ed0ab4794dda97d6b17fd45e06f3a4d4f29dd3b387ca2ff218531973f7e51e0f8633afa52e5234805553e02e09bbdda362d89e2f1d7914a8bf1ffc70ab201b661dcd9b371c13f796e23000a6b7cd573d114ee60d19d6abf41456c45aac2176bb7a43a8ffd617404a54c435386c0490011895ec13e17b0a979a042827df17c7699639e965e131ae455d43cdd7b65274080cc73c672af748c7cd5e24092c302bf7fa2001c4db3689fde786a7eba3d6f7c75360d2a5188320545bf3edd208cb52e3a466d98e30418de7462b861bb85a3d40559e464979edf50d4ec3f95a8bf4760dabf6d03ee5a8235e8ff2048106b5a67c6e354f60bd362bd9a90f672c968e8671d69c0c79d5bbdc98b1d9980130f2d8086828433f0921c961e0f949787b5e50e66139d33d34e01ccf809f6d2630ab26196d17834cd0bdb8fef8bfc8f2b1bf1651f5e305bcb72ec6b3a1a2f8cf4023dc4da4a304ef464d7036815c63c273355291d8c9ce5fd2ab4ccc75a202a9df9ed015a423fb9bc184a03741bfe1f4ac7e915e34c22f4c5b650121c1104fc55ceceaf4c11301653e8255d1e4a62c43ed0a11a5a13c68b9b16609b4c1da4df15599e8d57806f85e37f33ccb8dc5072cef6356df1093e2ccf07787e22f88b7604d20ae1443d1387e8c21a0811b404212fe290aae4492cf5ff9f8a34e0ad32c95ed3afebdf8885b0b7da4db9ddc20d1ed5af318a6680347c7b7e3b760183e2a6a4380476ac6662bd8e96911f8b832568b1b697122f9c1f68cde24da5dd39e00dfce1e9deaaf332719dd92c17c03e5d5bb17903b533b20b94ce63ed799784ac9ad7cdb60ef724ed4c05f091ccc45fbfb9807fba4c093959be66d4c5d8f41c18bc4abe713977e52afd424485fdc560fbf323bcce207ebe2894cda119d7b99913b79cbcbc82956d62f96250c2c136660f2d6090769b9b0dbef83a7917ae938f2f44aaeb35e61e844768743eba25578bb4861fa30ef2bc893ee7a5fed58aa525f6fb250ae79cfaaf40ffb812f1e22b896dfc0f1ac603d8f312a0027e9afde878612e1771d5939c9c4213254c5c50cc054b961d6a57ec0a88be4ee2fd3e2958e1e79c964afc6e28f903290cd65cd8bce78d17d6d21817236db81cbdd761647daa1792204ed05fd2ccb0f329778a5c9bbebdf32b96a4b787b2154f6878e287c6b27e37e849b3ae6d289a9df99356cbc115b54b9de304ad846e846890c633d5de61167d9d54b66790614136da7f84c5ee75b0d526258180e78e9876626952d1907180104e49e2d8964818544e6d7cc1a47796eab9a0aee41faf710870ff2b89818e308e254ac06d32799bf80cc2c69c69541fd0176cc0a163f84c5be85815804f4d4eec2a66bcf906715fc9d5eb019017e73d7191a4d849805bda69b28f9ce3e3604828b56b3bc30ce31e49dd60ed85485b9a5b6483a025f6962bc675f8babdc6372272c1c3f93c967bc4c10121517b1415f5457936a09bc4f270d6bec21635ff55cdabc6fa84bfde21d872cc1a6015e1d0bf658d972a6d445ffce791a7e9506bc74bfae0fa449209a3a93cc6385b72c644042ead2e8fa168a77a34c18ecdef9a5ecd641a3b3c7539ee4ce795018c7790ec49ebef7498ea5c12ccddaa362f65e389be710d97bf9bb2152d22d26392505349d2a8f4cade961a6dbcc2d8fe7516252825829029abc66e20133fbf0c5adb1123addd566c216388f2e9b2e92d18065ece75591938a9a5ddb26ffc2aafa4df647316ddacb35a8423d88ab1e82f131cd01f58df1087d4a6ce72ca7cfb519c6706a810e1e4c50adb10b5976eb281676a49d25247771f5db0120161446525f08c86b49f21d0325672d92f700d217b5d3b9ce5ebef53725fe3a8d4e14018d76d1082963999c17bda8e0b744f3198ccad863af12b274ad7ac9bbb23ac4b22a2b331422cb25b5e26f8585625cba9e82224a41164aa23fd7114ee38dd0180ca576f37d1028f97a47b318376c23bfa0d1bf5f5f0bc15ac450c3e46a15dc33ff6b5dee8b2cb063ab641c0211c006217dc22114516d62ea5831fd0eb390f9d027bf54a9f4f03a7697b64b0bbd165c684a981059de32629714deaca91880f7b258f51798c215c86f4c2f8bbb58348c2ab907ad065b17e7c0b7b192003fb2e7daad8f85c06401314ab0804c2b23438c42af21e0c482c81364d8a00c3756c8d170d7c4105512b290b1e5629a895b67b0662418297780b811101646096e3751588b23023995faf605f6b891a5d9e6b9f5da40f5e8e651cbd0a00175bd27da7a2d60d79e1293deb1f238d69f16cca12dfcd3c04b8c2d6b7053035b77809fe4201d8c2504ce929d87127ed90ff7827e0842de4b62fb1378512fb7af6f79da85c6e2f434c6f9a9f1f45f548a58a02f3c254e76b378403e4bc33ef413ac648826da32b81d3e103a832d4a6ae83cf92fe8d9ffbd0b9af4d6eff2d5bee857e31ed35da0d2b135df7d047de10f0f4e36073a6bce25873dff4769444d71c70cec34ba71c5b068171a74ded9d7293a86daeb68a13b02fec2f0c1fcb060dfc596417f3070606089da986402ca1a0366f36bb8daa8c3193775de74e73494182042ca7fb0ba88c0b02d9336d3417afdde7ab77d2faa17b0c3233cf0288fe560b9eee84f0d8c9c80483d08337a177dfcc81d8bc0168ce79c8d78c9bd9fa9d423ddd4179af5b7e79c4a89843d5dc1908294027076d64a2c126abc4a74d57480dcbcacfc69e70e897de2e6ac2ca9f8d10684f83b36568144ceaedbfe115da897f7a2a213e47a0d2baa9b641e6dccf4cf219494866ba150b8eb912eba57d99a0cf4c7656965b5af3bdde828957aef601491fe0e67e71aaae395805705172648bd9b1a9f57d26473d11412c91d1ca216cfbac845a8f344e855e77ef8120ef25ffd1729789672316dfc200391c3a901da726ce0a7412b1f5a10eac8bcd0284170930d077d2066e013f285e7c40b3949b02cae2364ce036dd5498f82551850357786f88e96cff79f7c7fb2ac226114b11adcc6443ad95ba665c336c450840923cf5dd35d1d96677d169516cbd4577f8118eaa0c82ab7b030f76e3035ba44eb87cf3fb99686031a42184fa46924a58b4e157ca6a24cfa4342a5381076b44fa77e6b5d57e7f07eab92316f51cff4699e2717f0bcf6e4c4963d8564e985ae1414939fcab4c66223ce4c6f065fe3bb19190d61160e2408101bb18de96100ff0c8e2c7dd68a82f97be844653cb84f9d47643369a0fe09b61e33ba211f7f010a9ddcb40686c7e46c3db4384435c2e6c2b34c207747d67bf82278eb62234cc0e33ea0b22f605508099eb9c1ac2c0d12613eb1ff9e74fd5d0344f1cca85d23c9334fde8e9fb88463834fe3d4168d8f6a429c78dba6ad60fa5f698e76a5cfc6a028bb065904536925c7bd090dd76dd536d8570d36568574e278487090b76bbdb3109fcb081c72b20b6f87c2738cda2e31133b44700b87ee376dfbb3c1d096dcc276e5a0b0dccaebb0bbf19f090939b992a6eb9e19f560b69ba8a94b17cc76d8fd63746a302191b689b84a98d3bbede2e6ed6a21bb8c06ef7db31d79d47fd08ea7f463a3d9f844817b4ef1b9578d8e37d44aea079c7edbc6a52480f606ec61a30a2e2f69759bacfc4dceb2721bb83df6097fbb45150742580b79389dd4cc4cecf25f50d77f85996e6bd47073ed3e95423b720eb332d688931ae713a7d2aa358160035c5e62d04004d418762fda67ef95361f4aac2658778dc9759bcbdb0c895b51347615672f72053861036152083efb3f67e0f5a8956c7a0e795882bced0dacf8c55f057aa1cc4892a2a8b58179237003227b12ef3a98577a1ed054c1048d2244bbd645a4a1b549d6e4c66e1910ea75c7e6816931f38ec6a15018cbb8eb20a963079ef039e297fb9563b9720ce29a6b191e079c47c9eeedcd48796d9ac1a3431f5a75632932f1e1bd6b4233cd0f53f5c94c9a5a4e29794b97dbeb5adb955bf25503b58b2366fec69ad704d3c9d2bdb5cbdcbfd7f949af984391f4dfeb0942881f8a430110e0be40755b81407b948115dbaeaf6a811d60e28efa6c5ec3cb946c20e2824ef956d20e4f8e241ba8a197f1753ae19d5f543e168d1a3ff2008e1aea2d8c9f36a7f994229e47569f46b12d202163519ce37ea71977b3197e0d7c2dd6131fcb07fd13e92dd4cf2a554ec6a5c215dd1d0a67d8a7de10b94da43d065f4820ca66748c3e490baf088959ae67644f8e2e898ca80cda137f0a324a38ecee1c2906a5373d8010b3381e3520501946d5d61e91a1204b916c71d76fe9807e024baacf2064563e677d96554e4bac17eba02f2384f07dfd36ea0264e4e94c293910ea241fde5962f99dc911f11a87a0b2d7106a0a750673a8e49edeec04e0b45cb02a4f23af95b6d3d83be123ebaae927d7f9f9903f720fd845dd3c21cc37f45e3d83846b4f4f3f8898935b5763cb42efb54f10c64cf60969cd19dd83e39e5edced6ffcd687714afe858c3fca5064086f40939146caa5bc3d77a0d180343d53597c4efdc2e97fb61125090309848c2cc53f5ce0de8274115f17b8e7eaeb3e2cb21e5d85fbc4a8e30054b5a3a36a5b8999991b60145a23dfc8b944bedb4827d2d5573448f32986c57a4e33066c1d09ab8ba4e8d9f75d728c1f2325ca717927a61edd9f911c211d3226b95b216d062d94bbe8a0e9ac5823d955090923a37e1db85720746fb9fc9fecfec4651e3af6a9f89d259db4cf697f72c3309687ed83baf655f3c76759950c990a36b78972233cbc1ebe31a1a285d65bcce1b5c995779932a81a86fd6a91c71ced640b15a787b138db505e43523c002fdc8c829e6172c9a1d29e31c8693aa547440e9466b5224085073d9297043c5bf70987caedea6a0b1ccfe5f42677d9d48ae82725ebc00072e2d031051f087e2f97d8ab4240d6fa0dad351bc3d313d0d7884bf0961eafbe1b20c0c193b8a1ca5d18a36f2c2ae53328220c10324ee88b5eaea949cd84e1fcc47880a2ad9118b8cb3979545d3db7cf9a0a3f740694e505ccdbf9b232b17b378b3b15849b1e235e13fbb32d60cfff1fac772a75ef8910d9e5d60c633f2e423f67aefc7accae54ad081575a3c3a4268f4a7744144c3bf237be207fdb8cc157e190f305f93d2891dce981c6993d040f9065c21fa67fd556281baa27f117414c0f64a715def9ba68c58bda919876273fe5534c45993ae674ee1922b480587c524778e6eca3b556cb4f2808f204636e43b7c64f0d3c1e3083cab55529cd3846046d1a16baf23eb153b78b84ba30b8816455f5ea5f51519a079d0fbf2f2efd58262ba456c4f77be309a210d7266dc3fb82688b4d9cb3dc01b5163e48b265af1bd84376b43837f2dac7a7bd5b40ee0273892bcf09003fac37ce0e3af398f24f28e1f6b0c678df8520f2d53951ba0353996cd502b1d5f024d304b903370232cf7bf66dee49c774052bcd234eb240195d317e31768db1745b86ebe72b11eda2d5e9e0475cd77434a46736bbfb380b8b0226c9745d310f302dc22b0d405885c6e64396bd36c39a06d1e280ae716eff6b40fa3e738ce657062ae505b59e3693ad59fe1b1f7de934c7385bd44d05e286d2cc4934fc816891d166603e46ca82c838f4c42800e5292723f6a5a3e3103762a160b99571ce32da073e5d3912f49c4990424d1b3437d67d7a094ab50665f7b8c9d507b8d33de549156c2fc154922822e5d023d8cbe9b07c8607cee4bf4ea06da7c6ce80b791a9ce7ed5948cd6df909c4766962600fb60afb04f41f988365b1f8425ae8b98e00121566823ad0d0714b9eb92626d152f555cef66158e2eef4f4dfd8710da25aea9440783574158276433382a83b3bf7cadcb8a9345de84ec1ab41d2e31f2dc7212b5ba8a514f7ac33007445f1f57f89a70a027605b04e8a2f1093dd441198ca497b96d9828e4e3ff982c9eb715484cd1d6633d5e3a2f3f74f0a97d2ab1db34cb758094df513a312a40a39599d7dc5bf9771cfc7cab41254ec20084b3b1e2286b57ac1c370dc901c0eee287ed78e56092a5e49223e9b99bf76eb26a7fc987f2211f2ea263925b488b4b416a0c788c3ded5493cde9982045ddccf3c8c72973c6fffcd9e5c50d87e4ef6f89f3eca383bc21080f325266ec19efba9c3202d52c2136c79ead51ef0c67685dfeb8185190ae0b46f17bb56d7aa27c25f499abe8d1cd424e2d30cbe59bb6125fcc2ab17161a50c9638401b4872b69c8ab772cd0e14c2446016c8a36363a9b41462c3b9d9303793b9b7dd34c4e9bbfaa50b2f556e3dad4525eca7957e9113af710c13e3873939dc2f3c53946979eda5bfb25624d4c845a7deb7cd49f7e1435acfaed5d07b2c4b7e8ce7d6cb9479a2d44a178e6a3a4f7d8af5e0c3edeb8ce7f745fb10fddcc81b0489f9fe214365ba0e3afab656ba423a121732fd8f69901961130c2fdba895c41ba1552a6f69ca7aa3b67c13b658d074d306f98f0c371b9c06741456d17a98c3cddc185665f0f0bcc187e5d3912f460cd99de2f2f96460a0fc084b024c0bd8167d0c181a306b46933902dd0148878a7dabcb8ab6d233c40d7a0005e92bcc4e842ed515392d5466a9bedb576000dfc48e668c907c88221878c0156ac8307992a2821baaa8c392ef47e80e12e5e1b16b3fa5325cb44e638b9e97a49125435717d8a9b6c4d08c118006f6057cc979a746936a64a6ea5bb8bcba4ff85c06d515f7f946d4b31d847a70a8384918f5a8b98117df71c41ee3ad099c6cf98a2492350010c441e1c9d77316a5f6edb7132115f234edeacb9e3aa68401089aacdd62e426550ca6d7da493b6f567a47a4de1ace0384f7ee889aef4901143d54bb4e91bbc5f34f7ae187d456876442b9cd42beaedf77fc47ea848e4a083364f1be40563faa8e142001167cd1b2451638dff9107521bd5d3dc325fea3bf52507e92322ba193aa1dfdf21287728e3aca8e6e15519984a9d8fdca7909e8d894a5e24ace2768c98c702ca775fd3d7440ea1d072c695c3fc0efe004ffdc8db2ad0f185b41d20c828696c9587267fd2e6676c7e32194b4f769816d2e943bd94960c8ecc84e1b7d61cd65a0f3c735a303f6b998f31cf8c129419346bf47602729ab0df1465feb82ac213372a7986c8a2223ea4bf067c50db88f96355b6b07dcebca551bb42c4ad1fb7df6fc15c9f79c53a716cefb73582ea36c6db0fa36d9cbc7a34d321324ede5880247edf1958e5a87b9f52ef37a13e38fb152b1220cc94785b0adc7d3da2b2d3441ece7a7d39bbee677f0684eaa0dbbdf7540362af598a519c5c5bf2832b2bfad4d05ffbf4da4bafd7c95e934a690a23d0524a57478a6a3eb0f040db30dda4e055a9ef6a8539e8d996ec5d0fc7824fcfbd54a1546e5db2454e5e5ddf0358d56f63c29212bc0a6b18448564c34a15ff1ea7a4ad1d2fdab765545e36ebbc31983bdec8412d13a62cd3fd924e1dcb40664fc3db63bdb3921b2bbc1bfdb136e45e1bc8143f2f4f7aceddffc08f5a13930fd363c15d7d71c13cb0298f542368e08c517cacf7a8383479f55b5aa7c5b744719e8d79551d212d7948b1cd5523fbd09fe4e15d31b113795d9ea8156d1beeccb9205c9c7ff4d22308a9d5fc8d88a868524d1d9a029c38580667c045a6b0b47baebf43ec8b5e9ea169215a0cedc90c1bd53ccbd3bbc09b1edb12cf0cc96514d1299f0e37e8c58088b9f05f78394c3003079d689d9b80e1c9189d9fd6e19df5891cd5243afa245722472b58987d0d0a4c756597732da90ce3f4c8f02d94d8a1a33b4d610b838f18b3c12c3adbb35c48ca93dfe19029ed70c536c50151365497e2fee2bc2d437f84f7bdf7ea3a35a596352aeb79de20cddd33379f1a51c77896cb61548f4697e5c32ddf733c48eed6d5c9357c481d824b74a293298435dbf329784c75fbc1546b8923275bcb8e5e5c9eee68720f4458d4ced0dbec83a0386fc442749e096ffc62b52de697f61ed578aa7a73a8d253a1a77b1a9e23ceeda268c237c23238a808b01c68af25779735fa8daa28557521f972c2658cc2e99f713f3ba78df61dac5eac5b51604c19b4ffa0da074eb0b556dd4ea224a0fb3606ba2e3900f515c5c8168f5a30c35d012f18f7bf323f1add22c55654518d79ad497061d80395173607e555bba76bb5dd1b908ca50eba1af90351e513e2cdce29334de6e03a75903706d30f09545148ddd367ece8eb63d75673da71ed502b88bbacf1b08a4e5eca2f387f1fc52e9e5b4fc1c2378c2e44014ad71f4d12ca479679b14fc8f7ef48e25f98a6ed2de679e636487e900077590e53f1acbd33258716d7fea296105d3fdb13f985853b4eab440feccc211be57b4f61d5bcb73ce5db40d7adacd93beb5d929bc1e2c723863b9fc6b445a351dcd792c4a39e4eff4ffafb63cdf88dc2fe9ede70af758272e4e9908b06c71314f1192ed3df66f85f8953a8943ada9ed5c5592d35afa51b46deb7ed105cc6875de6af4d6661f402bffeab531a2b4398e99411991a019dbc508dfd30e8025a9f6c980c9b34461b5a918f8d24daa3f0a897aabf0b576471bf7954eb5f4e2cae32741ab8f36ee545a1213bf3cf6ba00d8fae78531a863aa9d476272d7d449f5f8fb81427a42c06bf39730bc82f714899ee894b86e914b84f682e6ba230679b99dfcfa76d21d24f80238c247c535d0f8d9ed26b3e9fae229abdedae60ba8288e104061d0f1ce4ede0e14ee6aa65c99d4159568333218c1124dc272a51aca8147dcecc7cc5aedfeea893f5b57f67c228d0a5fec70b4f70f109eeef8f16bb546ccb543a50349ba5d03b53ce5fc8a1edb452f0b7fbd5c6893f029f22310e4cd5f64fb99f1c2e4834b9516e76b1407b9ad031774b4d2fba29db77c7f89e9db443708faaed82613fdd889d6a1d3e6db9762e5534103b682df9849ab128076e0cbcaa4456ec7967c3df1d0e849532dd25da87edf836e1b14a050ce8c16e5deb0ebcf3b9a9c05c79c8c5fd2ef938d49a1ab16eda4cb6b1884f3509cbf20e5c3eb7432164065a017b3273723f3fdc498111adb5fc9f657f138765f50d8d185cf71b55b266174f7ccfd8997b04aba0905a7bc456db6595099d54cb933ea173cfec4d1e40caf9a9d0c5f2b918f24f7247b9fdbe01a58fdca233b833717858f9546f56e056bfdaaf894f292d85a1c09b884ff1020a7dcbbffb6902784b1accb849bb653533384d19fc3d3950261fe0036780f379543022bea42a557840dab49546456731d2327b665a61bffc6e01987869d28ab26a230a9d94b75cbef380e8a4c096c6db20f378f953cc4a7927ebab6bab562b1277fe341036b9ece6ea755d68805e7f990e53b76a5d21a16ee706579a226a8204f4b6a91307a4f70700104a6e067ff69beb44c907a7e9bc2fd45c9febbf7e8e43b0cd160c1de1a6abdb9b2f4a9493214c3c0d119651380d1ec28ffd5b94d0b365a5d4abe6c43487bb230f4843439993c91a3702be3caea1cb06e4ae64fe1f0e98c8660991c45f4618650c397b3c4cae00bf51848d50becb8dea8033e69220d9039714a15caef1e4614b22c5b85a76da0efc09f8d24ecb02083639d9753071dc9b73153d0832c834b806eca9ef388b629a1eb456332dece91745388644c6546a7a6374640232d316ca06ac9543312e4e56805ad3b8cae33bdf7c337043bb41cc1d3445279d2a00fda3386540ef3c1b11ab668af8dd29364d9324a7d2c2978560f5a8f5f2107dfd29ab205499bc58fc76834f4de3d76023c755addcc9d4419b9a8599e86e01f78603075a8e29f7f0378b6de7f4b0dadda01bec1123ba7ec6467f5ab849009aed2b3631c4e50ad91d02b6d930e2c0f9a31632da281190ab8559adcecfec7a407e2cd97e338a093a455352944b0a94f4ad1da17b025523262a1a7c4c1b3188bc2ef453a2f0bac3b05a9b8fadc0bbfe466e64ee631f93b188d9c483e2db0ae440f0902a0477f64404c224381372c1902dd7ac8188114bf329763c5cc4fe663148ad2b8c9097ab06a5d7e0d4cbf5c2580858af5ccf262eab723706db7710bc18f4c37cb3787653fd6e235be2528579de7da9f2bb176d54db4ec1d11bd680d3ba5d229af895dabb46e6d102fa3cacea70f80f18fd21e4e52e9caa1b926f85f339c23b7d96bc7f6adaf9d94bacd0efbaba90648e6bf76f15531f865a5e15d9a64ebc6a19408b383a791be012065eb63f8fc1dae88ad5b1c0857adf859be964a108a1a0eacbef58c90dac1759f2c88b2782b9e265b8c528b269509a0b4b15983e0462e12e1278f0da0653c6e9842d0263aa2feab4d615a1a0bdc0be299488e3a5e004629e0980ac9268cfa3d1094775518a01fc2136c1e1bf5bbe740e65baad28b84a6aa8fc8889c76a2bd6b55a91da2f3738387d199b1860550d64bba188888524f47b50ab0fadb3eb94e771e4cef89e6668c4266b33ce04f22ef2370f5956998ca9b1bbb0b4e6e9887eb600a2857a11d5eccbd5abdfafa3214f27801fd9bc9ccdd6c47b02ee56eb834157bf4f648d7df45fa87e369a62a3b6f0c2ccb012d7732ddd427e110655d79a25f968acd887cd30b528012f32d24310ff9dd84e2d11d18d24f7ae5e846ed1dd26462381d103184c341220ecfffab8e73e55806c0fa83e75241a08b88d29f95fe5a681a6ba8c6ffcf672f2977ec1ebc415f48524dfac1e8b5d65bf8cf74e5a861345533c5e23c25307553a0526db1d22e2aa044103e805adf14f0b2e833a0ff9a352f36d6e03444e45468dbbdafe43a2280b9fb94288bdd7754decc0da69cf7d81878e152b326cbb70766d04269e87ac6e79962321b3de4a7c4e1ce6e27c98d1c8c16f8b236936c465d931500e74e3d1ea0c4c9677020e3e050de057284a5cce688aca5988563ba60750ddb1fa156b69d7e78c2b1638cbc724411753de3f9d66becb6e0a8b43e393db4a3f7130e2858d7352f4c807797661cbb331ca94a93d36a50377a9412c00eefe399ba045b3708d0a82f420c64233f53ad39e0c6687fcd40aa7bf29dca96055f7ffd9bbd003a789237cdd1429b336b432ab9fb4e6ae49ac6d0c53049809e9d98aa2c08c289e18f47d70ef35d0e8857649437c7b722c41a20d96215267d715e3a2251f601155f6e6a0438f7ab54ffcd510ccd24dcba8f7811d4afdd589c8851a6f345f7da416db697cf276f8f90303e6d6fc1c902bc40db06dca8c2809563d708b5bfd58f0d670b9f1ce439ad1e8b481e0de0839cd1a8b344b592f11122520bc2927112cd45798c81b89f1ca5960e1ec3ba512189dbd7221e52bb288711d052a87f26d0e3cac58b440a90b4c013c24c58f4cfb94bc8c11edad886773b10e68d1229892eb10ccf4c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
