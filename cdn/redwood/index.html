<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b13b7cc632846e2e1cc9a6f69b3c93819a9f0c234f73e8a33fea7f6962fb30f24444a5560065bc8104f6f04555224b112d2ca43d3b065ec5cbf0fc063c3ed74ad52691c5fbf8dbe73dec48271ca37d306e988abc4a5d2fabdcb9c2e020ee9312f87692ec888ec5cd82b7839534cf8e06cb60bc77b8445d63cf376464f8d529350f1ac5c99985f128b9a6651ba63fbccb91f00ae0261cd8b705c4759549bc3d346be7178f9740ec014135df60c4308734fa639bb88f37f5cca52f2052c304cd0461d67e64d873a7ef885a70253591dfed69e72f0178103ec79faa271a6034354bcfb96aa067804dd6edf5f6ae13e40316cc67abeecf78b46da8e14ef7fde90147fd624e72f399278128de3e34ba891c3a6953ca92425a876a1879bf829edec46389eb829cbfb02c981be67739ca30d1ec5198aeabe4f85f19e577d22608aea272ffed7435f1d79eef3be2790492c1e92030a450215170a2ab5c873b0c834f366bd2107212a4679e2d0bde8b2750264d05c7d3716ecae7e67e1ef59262eead1aa3d798ec7e3e8f977fb31333583cb3096016b8991fc03b6ae66f73b1dc4165472de8a063fb87d10b888c2a9a72846e2d6719832f23cdc0796e49d82e885134a0d9fd7915550855b28c991ae60ab93effbcb08ed34facdafcdc213d117f3b5d7a279eadac4998e3678cfd7a8292ee7a6cac41f0235cbaf4b7d48412a7f4ef468d15143d30c2285f0f81f4d555723707cbdea6bec741dd9d58d3858c7220bd654ef0d442e609c798fcb65ce1093dd58b126c949a409322d4864fa68826e05d4aebd9efa59a78ce6cc0c334fa90152d33000b2833de6bb14e5b97f1f3bd6964691dad15028412f728d9792849d3eb6adf656c9eb0c818275820d2ac64576938d6a45129e28389eb810429c9c024d4a289e02602b09bb2d227a029a974db54b249414308b179ee31f711bee7b3b387dafd57a986b07b567fbf1cd1e5a97a1d10b279440c70e391e07170c2ba4d3d767b5cf76e2404e7424b1b52f274077f258859b2f357f031f1ad31b37ca948ee14053999f4d08fbb3469eff48a3015da7e183df5d45b151b274415632b933f97258db2e143e81ac0dad2ad02bec79dcbedbaaae385e8330022108a8672b368c7bd8acdb83d4fffb08b451e5638f9e4d050d9a9ea828283f5c4c8c8575953136fafe17d15f615bef172516c1f85ca0cff5999f3e7e3c1c7bc5ecce9ed9669939b979f6fa53b65fb53e8df736701a00280712d308d36df79bd6f2f81294485b22492f7c8265d035c8fc165fefeb90ed99928fed3c39c32de6a6776d714e4d2e0287273f4db145e567d21f0e97cccd5e7b583269b09d642c0366ce44c32f2840a13fbbe24ec9d018824b7b0261b82db7948346777b982349c83d425c7d46d2bb508943ed216755e44d501de8d787eb0975bee498cd9201506055af07854584bf86270d54814d7a63e3110739e79fdc388f4cf3803f9cc36724e95af9da213f00138ac1414fe0deea30ad378c02db03dd4e7be71c4abf4218f30d6d681db2a24478d87326a44ef729e25ed07bfe6ce4a115f6996024c4eb71c86a91263258b953bd863f586c2c2e8b065e3df629c319aaede035debe2eea5d9e35e7b7f1823eaf14bec434741457b64c3531de4e22fc36850875c97e4b2c6eb01657d59077857176d4515b2f05e9c5c0fd1c394adc25ac8a9abc16a271db0bfe88413a506172159e257a5ec21c1d86d377784677b37b7459b37585daf948b8d8b34be89c72015953d7d27a0d4238d11f99f6efea74204078d0c241a89f402e1191631d9c1d5ef62708392dd2a51a147354d208a50987ad72e81b1dd7880da99ff7ffd6326d4bb0460bae976966a7ddf7231ebb3fda4b9dc8e4ff11d1837ddf09797b5222a257721eb87490f909b7525ce9053935a17eb84a7f44bfd7f3751965b050bebbfabec3afbd5f18e93b772a3834900a21109010aa911609fa28bd56159183235b10f48a5b3c34508ebedb8779df160903532609c8d87c5f247d0142e26c73a98b603648f4ce2bac6b77eb247f0161400874a60efe59a49669df4d48617f5ee0144f557b59da63dc3b59506defa53d6c757f31accf04fe13709ffdd67f914f2de173bd11bf954ea4983f5a2f5e1785981a737357225b1fb3e3eebe2bfd5a06a21d48fd9110ba99e6d639ce54ecb9715cd031cf20c2ced0c7b2edafd649c995c5910282516d9e545f56c002b6b00ed1de2b28e2845abaa2d1a0fb3ea44959ab1eb744eea95cf2b45af4df6641fc6d62b548f21f35944800ecbc30a1d2ba66bee8beb99e6161b15351e8a786fab175d4058808a08150bc6fa57ce6b071ceea145ddc10c76417f037ef3ba06d7c141552edf3150aa70bc9b32585fde16e7e36919a88427d2e4a8d6f64ae823d5539aab690389a0cd65932b54b4c644db09007affe202aaafcdf2bf18f2ea6c0fcff1f9e94799543c0a9e591782fb20043560c5c0e812713632c6e99171ec94256ee378f65c1b1d4855d7c0a925230028a5e18a32d5edf6c979d3937589a94692b9c267e26bc9c0d65a68e7f5b445c641a64d1511c09d1990d083669b8ee532b72b5d20bcb50c5856bfe7b4407f85b34988e36d1d5037b4815b29f0187878a47e234af3da971a90fb8ba135817b18214b17d724a479a5f86b73d5a3c552d7f17310ecab4e1fce8311896d0122de4e2da549fccb41aff55513ec41f0bb72b4542c89333e331f6f644d94516902de873d50096ccd92ef844741e8d0d3585bfb172f31a74a88a5bfe788e45458e8feef15287ff01ece6f79cfd10bcf68d02564d5ba9c4ffa40c138ffd1424bacd3c9912fc1f421a4387e0f5b8454d72123e92b5e01dbb1059bdd02b367e839883d2833ce72824abe2cc8afdea9a71b287d93cfa30c78a6fd4679de018bbbe3e29eaaa80e9b4f835fc008a0a66b07f2f1bf9c3563c95c0678a68dec20b63dea783c8abbcf33a3682fa840e2e238df2c7d0d7190bce41df9a49b3c15ff1e3668bc27515f1b18b075440237f1dd023bb59a96c5939d4f000b7af1491df65397edf0f5e3d50430c0d3bbdd1519f518cf6415e3a7629a29966e1332a6f8e514c1c1c16d461ac19fc3ee2fa55d984057c13d6c7f8a59b763b7ab3e2b8c5cbec6e0ece7ca97fd426cf6a5a5a409e03ebe3197c8d2f6351c598f14515c82dda22c02d520bdef87cbc6d22989b6866d441aa660f9416933413e73a165adba29cd21f09a93e055515bb536dead8d8dec5ea062d769bfd903a7735481346ae680ce6ef38b672f0f2eace7407b7e32853da17e42f4e9fb6d9707e537a03f7beefc8a473be102701a5d2697a980bc01b616278765ea98bc675f5f263d59efb7ee20bf10012371f6ae43ca32be33eaed369ed11c0efedc1101d0a23e32b77f79f647a488f90680c5b00cd87c0764d5e95a0c248a17228f1e69891226b4bd2c6f93b70f7ed5b496d1d8fe839d32122f519bcdc80aa1cc3b70ab8a61b215e7fe77c4066c7c79f8f88db05f225e6ce5a272268cf1d22d8842b5711f437fc3b398e297e9b047a1f74348ae6736f74ab39977eb6968d551856ecfe3235aab69b714b7213b80e7cba248b9d78a89f521f5d3d4564d3d4a9d217450fc72e1dd5b53d9dd7bcff174fb9d32199e74d56b748c6669eab1d4c062b95c36db90f7ca1b1581472a9ef9789f229ee9aac73472990dd8b5d5ab47d4cef01133f7f4b462a15417d986d7ca46c5e20176904e00c17915f172b3084d34c0c5b59228b080936ed61a3ccb66b2ed8835214a30a264d9d28f4970a3c9c4af9a32593591b0b5ac4362f60ce59e0c2c6e94881564778d644c4372285da5b9112fd390b6f2bcab8b7c1a9d43cf41e5d48c6efb95d7f23b792ebc88da367956049e04c600b2dcdfa43ee210000f986d740cc8bf157b6430f51563d300375505253879bdd0181b7a5f9d7ab3f841e8a882786fa363560cdbae8ab6efec98482a9725833010f9de4e71d26181aeda6d18cdb1f37089c61c1fd0a40ce8da8ebd0fa301af5489b597b6e7124ec63c47b0c983ebdfb5b4da24ab25d29f129c8d40e8aaf0011696b2e89c663760ebaba62d72f59b6ff61e57570bb2f262c188bc9064c6a9a78cf8ae2af3344b7a4036c4d16763ea5f51390f07b92a351c4404b8d1d99788a5b4dad54a49b6465927ca9e55889e1dc0a8b16c5f122218bc3ae64165e817d04846ac89b9d4209f00039ed3abdeb4a6f0edbb78096f9174d5adc854a24d90ebb482ef40b0c9d3b1ea3f639352c71f4cfc3767a22fdab18447a6e718b42ba9d850accb6c881f2e525ffbd12298824741279902872f95522a90008e522eaa331dff7a01a53832a8b1af5926631a24ae65564b5da0c4c79d49fcbdee15cfdf8821317a43666b4a6a3561fd19cc56027617b826599b381fb24b7fdc0e5a89830653be9e2f60962fafa7da77685768df3a1f5b468a3adb2c70a34694afe4c405ac8edce2582ec031a10027a82f4cd3230216ee5e5a927296529f75ffe9996422f9b9b673ffbfa8a19526eb62123835e222107ed4a9b442a6ed6d3f330da720f11e5b4c88c192aa441e25a3fbd6b4ca3291f623c2313e9faebcc8f52de60d611d6a04f8b7c901b407e531df1cc1161fe3053bef6981894fe61a2ac97b4cb711b5ec368700712f643702a6da16d365d1332b128657bd574f83ac653025523762806678364451c18af8174da87d7757682f09e12e663d94a652fc56e7fc03584d48b4615c53334008c379489f78eb1daa98d7d54fc765339466902ea66329a299c90f1a999d53b51e08e7a4830608ba67fb95b24cab8ce883b8c455c5b151ce813ee96dfbdb2529f99f610849ab4e976e1fa26489c1914b679b2948a4182898e41fb37c239392ead5d37850ea376f353bc0a2c6ab8bb526d21d314a130a82b51f9316d1d71bc24847df3b0dfb9b46f4cae354e5e7b532842d1f22c738aaa70a54dfda96cb1c23ea1328e195252d510fb3a38f317032b1b5c6944736fc059895de0b50aa17264a6d9e73f466a5ba4f7bb3b79d315f260bf951d30074b434b6f0b860f2ace88a6ed63aaaa9bf18578ae3704badfc1f25ae1aa5fe233c8e8dea210b726672486089426288c1156c7c4b3f6481d8239a8912d72b2412f67cfe2ba93e5db9bd4a7716fa0c04a8819922a4275eb5a27cd6f0afd3ec9769c2a39b679f3f75f5fe9482eaa0f930f36a788cde4de44ec58f672e45b9f583692a8c5a3a9cdbe6e12d40a50420ce9f7094404e740a18cdbd28e483dfcc608fcf4f8c330d094dba45fb15b057418248f79b8170a8de10af785d1d5f91606d863c192cbb41fe89f2e381aa3738faa63b67049887f34f1123621930722e2cd2c4066198afd68f351f49983401f9be6a27068e3a6687e91eb4101e874fdd8b9e038b2171f77255fefc74f7a1b54b5749cae8f6f333a7a96a7d7ba0394907617b4089eaa5238ebb7adcd0f368fb5e601ba5a616652fc18c6ae6f4c6d68002ad8d5ba68d6d76efaf3a1900883c78fb72b10f89ba4b6dec303d12b9ad499a4e54ed4b2c6236ba3f70df6930e6afa2d0fe9d3511401acc15a75409c91871ccd33a1fd7c3941fd237a50f4dbb08ad7589513130f6345f10175c22c1c253b95d9e8f04374015d2d4ac61af49fa6e35b8ccbd3c213701b29827c9f4f9671464f9e9f95e19ef92554cadcc6275da10e9e2a981a296f149a0e7f08d54b2f29c629655ddeaae89067ad14c2d295c789e74f1fbb480651c264bcd32bef65756834eb296359c09f1c81eab74d01ba0fd119a02011d96dd6bca6f097f9cb98473845c5fbdb8405fe59b470995904c034289b6d553a2a5ddb4da7b34c7fb71c3a2a92af9f98d356e50c004614ac7d1f6838727830d90fff98bb0407a8b7abf91260e29b9298809bfa29ec2cc1564485ec77ef4a9f8030c792e0a338020e4adb5351725866101cbdd1975b9edbb6a9c37f1a227b7d5e834a0a53b6468a7ac7932810148244e6f211fdb966c93ed256059ed543aad73926d51706c705703cab48e6ce3b07c7ea385c23b8b6d2ce544a5cc0a29f8f6d0923d9dd4c5fea5aa7a741e3e2d86e324b1a2d84e137bf408db510856d966b4094ae8d62cdb24f5492a0716c1d3e21ed96fcf2dbfa90ca50c11f3156b2dc8751bdfaada334843d495385ccc1dbbdcae7cbe0ddc1ad675636bd55aa9f12feb33cd01f9409eede7f5a72533dbafc654b7e18b11f2a9926896cbba8298732134a1c082adfd011eb7d207090ed4f4391dad68dd8ab6b755a89727c0cbe418d3f787acc514cb91309290b62f766787cfcd265d306757be98c60e76b4142abc0a851af72cfedaef4819b0a3adf188cae00c5d1d9e3605d366338ae889d7f1c67ea1a3455d9a80afd097c820be41299f197ef46d9011e4782ba78f43f86879635ab680844b686939afe807b7bf6ae18737c6523b4facd48ddbdfe379fb0757060524abb50dd849fcfe4bbcf9dae7e7b39fa8beecb15ba2cacedc27c8020fd4d8814ca9c905dcb11248c980c588c86f23011be470402a6f07af7d3b72f0052c0711bbf8f5c7421c3ae4a9b7fc445435bfbd8ba76c656a43ae288a0923242c17cc355a39ca9f39686d7a38bcb201d755dbf98caffbf89f18348b78fa38a1fec3ddddd0b2e2234b64c71f21f09e3b2953913e369e38b8ce09c265414fb65e09aa7a47b32e2a399380714f1c6649d825bea1554a7c861f1daeb2e81f1ed9357e96dcfd10af23570f66ca1c78b9152958e978d8f4dc189f7b18621a021818438263fd18ceac9f74e349918ad79096b47815f02d4011907f1c497e43e4dc863ad40968e665946d99c30817096cc49e30298b3f9802f6cc8e18a0e85a036cbe96a0e9b6efc9cb1d84e64cafdc17ea2947373d318d5edcd056be6d95b4324ceb7516a81ab584745729e5fae813922f8ba0b65ba4bb67d3bda1c17ca0e36e63de180f4b10a9cfc2f62737737a2ea7927bcc6ace0426be6d46f6ac5ad6085ed52859e3b9ecf5cc73372c1038ccea31d64063182134fc9aac390b14d50d08b0fcfe381df735428c4338cb807211f3117f2862bfb8223b60814791f1e1781f78e3459596120eb58b0667d3be825471754803467b25532902d040a4a612b06566a792d01acbe6136274096ad7b7c1c324cdc891e5caed06689633ad92b4b633ae02ed0b4344132cdc8b485c9417b509facc14730df05fde28f091301b3809c2297c8a60e28cfe938408845852c762f1805c31becc4eea58adfdeff3315a546cd97a630563172409a9f4e913025204840223371ec8033f07f5adba3127af79b2d0b6d280c01e1b85e469b82c90303f34a07beb77db1c78da3f8cc4ca231baafb3eaca06074aaa99bd4bcd8b4e7f9d14635d4ff129aabd0fd3ddc3b65b5e9a9b9d82909f31eedbc6567aaa80acaa2f2f18fcfc08b2c5eef8399768eba6a6b7ce259348c8e845581f5efea9dad3660cb28ab38e8cedafd2289b2640d896f5fdf31f0016f03376863a675d864beaf737d09a59419dc12bd835b683d9b62400c8a0ebbea72ee6abe26a943a3a1560418174262433840e46e866979c86d46d72b81850bd82bcf05ada5882ae57695a0ec3c50c5a8eea2301d80356bcc7e48324965b85fdcb6abfc3f3a3e0c985fd621cb823df5d18aa9ff1ba651e75caba0cec1a264a1920a450f90224fb45c494675c612f82a87f96bcfd64655b8f5e4af10d0cdb506c1ccfa73220388ff21fef13ac2429b2fff0a79fb5c7d62b90a0cf66f47813171d2da5f1dac8b6f5302f71c567b34d6d08ea8a5aca86120c74c63e4be947c49a8ccacb8a1112221d9916a296b893fdad15c23729e67e1dcb65f49d1814d28c2860c2b12bdad1ce1fbc066baf010c39271690efc2a072e48db8432a1f9b9ee0cdc3bbbd7eb8115bae2502eb92a4f17d9bf10938fe1d54388054a5a2c9a8cefd7003268395d8be6559cdf5dfa754ad1154f14f50ab4104bd39ad10d8da84600be347db2e28b7d565bf982b5f03c8d9bddef234e1c2cebb22f8ff47d0f2e4a4001fdbe9eafa229957b5d90bc93fba6f4eb2523f033c450c348cfc87cc937f271098e73729f1410f43f67a2d8b4fc3a0223351d9fa6b15b6e03f3aceca70ba12f613e2bfe8e3db6c5d4ef3dd5b2163f0c39f252046dc11bd8743a4b4b74ba1999b6c88be7354c58323be53e14ed7364de9f3e553462bf6a802f6c3e2b7b98220a90a10e186103b9f31c80cf09a6bd5b5c0ebc607ab5bf94a217fd441aa96521ae8e106ec63b09be5cc2c0059246bd3799cc8dc89e7c38f578c8aa81c3034785454543f382e3b416c99f78d5f8e0efe597babe8fae03b659b333ac91006712ea5dd1e63c74f9eaddd340800db5b680eca1c8a08b28635ce610a2630bfb860ff4beb2ffd81af9647106019ab12e3e03affa2ea054c924f6790c445b4280824198e18723a6bce78f6054b5b59276f31d6a43818612bd8bd1cedf44fbb9ff22d74dbbecc410f932d1561a765e6f0c2611a523026391542b754fb418bc5053c3bc09da5d548fc8f0c06509b276b8208be6ca1709e89cdf09b88cd977ecdcfef91d400423380e426b46c7e41ad43e6db14115d14078aea886dfb6395d570e82cdbf76878c114b789511c735056694430998d2e518a29f046d2220cf18e9d85faabeab63e018e2d48851fbbe0d782eca124fad451bbace41373b8615e4fa18909960d0a94987f687a65e2b873e7b252430bdf349e301229e46c2a784c8c9c883c673ecb71f037d54846bbcb79e5c20257364bcf20ee66fc72530021adf89d8fe3a6729b30e30c70e099c0d341171bdafe485ae0bf62e476abc6bc8be7bd52ae7e01bb5c69063cb5f79da71107c95da7d438839cff82471035bf53e4705a7619275054225a1a817d2dfa07a7194fa086b41218effd9f12bdb936e888862090e9621ee04abb473c0c8fc3e1fb04d9e8e1509249db673c734eda08062b23d5f9b4c8a8b583fc50c3e79dc4f5dc3c62b632223e4efa658462bffbbae192615b107cdd75156d89eead2f1c1fba6d10d117fba49fc85a3ce7cd7b3edd7ff02b0ce4e1e115967de5431626a4dffc66b8e766f475090fcbaf398309572520ab156e25a9fc376e2dd6f06c5d6bf2c6ed94ddbdc91128ef3049e8661c699965d5e655af2b2aef43acc6083c02f918205434552d0fa41a62ad427610f673abe52badbfc394a982344ec6e2ab02d6fdb5dd285e4773aa153181691aa246abbf172eb21a1aee07b88615be5d18affbd183ed0a403253fe216862c0334072beaebbf200afd4ec30bbc53d18a828b4b5f5a0f012da6adca2e5349e7d6eaa64b4c35ba2e2f2458c6d9a8ed9dab56dabb2265af3e6e3d48a3af02d655f69eea7fc3fee9d29fcbf660e8c686b2191ec08e3ad6915e993e8247cd7f184c3aba6e47c088ae1faa5d109d8983fe47b49c75d4be497d9d76ac43c3f548f63f2265b87d98a7d3472abaacfd96459974db8c314f585b28126a7f928f0f26424cd16f4b18f6ef408202281ab636bb0d2dcf7ef899fe61802cc6d69e78b10e1b3f52b024026cfe49f3408af1ec8c41d7165aec3c9f1e42819135f9b0dc22435afb3df99d3239da6cceda172ed89a4eef7b614e55c0dd7f131be88611277442b53ab2d39afdfd7d231441e708dc0ca2b1e518eee39e14b53297f03bb4bbdead74377eaa1aed7b11bbac1a0e32cd6533ec8442f535cf1123b0d537f97cf330a8d627c02cecda441f40ff5c3565e7ade8f2ee1584068c07392b1ee0d47c6ae9c488373bb628d662748f18fab4f997e517026c4e139ae87960cc12ec16d10ffbf34d3358c0b30b93d112337602bef704f634af4a270d6a76a49abb6896f2482b2a6285fcb56e3271d414589348fbd31ef9454cd6526cc6da1e5e52ba5163a017d2dea2a6c728a3999e587ca43626ccaa640e13e6be0717057e1b3e53392dee4ff3bc44b59bdb6ec07a9b120c86dcb21a174138edfd42dd4df15292d930a4dca75b26d7d4706a7554a088f6bf72b59cbd2a377712e76a920e21b3ff0ba172fe8b7de6b41f0e0c2ba4c228bf15e133e2d657fb0c036a1f91f173373d9d8ed9538ede0477a88c4b895c8eadd928e2c5909ac96c0ad7d3366c14199dac57f57d80cea3b0f97093e5abc430f83eb0051f5565f3925de1c1e9d7ca910a31a2f7fb814cf2d75190c0ccaf5f153fc06dc047df958f3d246b714fa7b309fa857c333d94564d352712bf5ebe034eef0b5e3b92ee2c949b1a3ac0077cf42f46483264bd2e1698a9e4744b9bb27701f9f15fbc83b4841e523c1e540e5ab2bbb1c4cc1c8461d36cf26dcdbab3184271f6857bb7296a79ae1e7f95dc24275651f9368723f06be50edd605527d45db39a640e45d2cbda27603946d3c3d1d5f7687787d5bc06b9e291f3c66b1f12fcfbbed8d26c5f0cd67138d70f14cb09190427010378cd07f0999b8773246a2c9922e2de2e71568d28d497cd4f291e291863f936b137f7662a0923f7eed5c6cf5bc9c40c5bcf60420e3c521eca06e2abf75f9601b56c37b48ac71e1bbfa5570ac0531c765db592a621657f3c3ee9c26dd0473bb142ba3bb5405ce236277598b437c6eea13e1249661de408d14787f1ae00adb9c682385732ad2acc6cc1fcfd3435ba677fb25bff46fccbe2ebfbf4c29f13a32325bad079cf0ddba008dcc792708f6150d690e68b176319e77b739e9019c97661f408fed0fb7d3ce2295fd77d83eb2f28bb39203278e8f4d82328a2658fb2bd5737950b797de0bb2148f76e61e3fd52b9a1cf6e86a1b964f603fda287e6340ca65f9ae1314aa7886acd1513cc75f3823c29338d3491f1c7fc60086db683cef337dcc3911ab247bfb086e598ec600470d06de7e044c4a04017c074b5ee2d0848d514c47d73e5d0543d02ebd0bfd3c2492900ee290b29a95ebfb20069376982e85b6585ceca1b402a4def015759c7d5743e63e282fa4de43347eb11a3048099460cb79719235c88d40a990cd17a149337ca9a074d14d2026d45da44cd1137a276143a5d0be39e041dd10b6df783b4779a90e6b5d5957342cdf55d30a358b1d11f7173a771aa2a8b8d5b7f1182bf90a00139e919de54631f48f878c2f692a3f11febdffc9edd9fedde0889aaca6667fd9ea271e6808da0fec584aeb761526d486a4b2595c1a4846ff86453f75bdcb44ab5bc4d83746a04819e7e18782f024d3385a34b11a8fbb1ecc4e4ae2c9ec3e4e7bc0e0a6332c4e5ef97ba2e96b6729c12fc5e6b2961558524fd98724a2bcf12e92705cf8c5c38a4eb3367b8c93522c1eaa2234b26a2f5e15e84d5a1938f995ae9b677c8f1e350fe6a62278d3c91a07a75ac25b83a55afb0d991ef4216047b6587007d26562394c214e36d8c3811a240b04b652efbaaaf73355eac548af222fe35c2ec46383554067a0fdbea1b3a488369f179ca29e47bcfdaf43ef92b98b3c9f4d058d84ae9f16920680751ca4c8f326c39138209f3dad325f2f36d2c43f523f67ddc897df389d593c1f8e0923d93159a09b051206a8806dfe537d1f93ad29fb5af16b06644e0008c52033483857dd789e9d1d077e1d8b2f8f45978aa133b8d05330e6e74b654d478f6a2aa24c6783f5a60188cbbc739412a4519050eab3cd6e6ac98c4b5c46103001ba444ce8500918ec5afd668b1a82b7c3b02145b2bc58d62718c21b92b08ab48b4f5dd0bcba69df03e0a268ad1089b9b17b4d0a2b5f29642065ad7b1a4d7de4505a901a636caa28811f87ebc18946f96d95a9476b4c283a5b5d38847047a47435d068dce576f159967bd9f1ce769f2cf34f76cbd788d6fb1d0030f618af1590aeb8b9191734e2bb4c2978f371e4bc2b8dd8f33b04dde30119727742e41bbd885db470ae37ac5b7e728cb9c90e50f00ae7706021d2e295fbb67b2cc89e17842f89f987492ea3fc426424ab8a7c27790bacaa9c8e40238052504b83a841d3d35df740cb1a3feb426da74fd8fd5788f3193c69a2d4cffb3d2e28918249b73e974149fb99b2018e44a1af5728d0b2217088b59ee37defe449819017896c56332c86af0f7a44713851d00c00c8e20c587df140e5b089fa2d3f43705f9213a53aa4d91cf0b17fb835cb7902f7894a7b24b06bc2b719a3b7908fb04f4a9c7e47c5f897103374489c1f4b68bdbe6a8d82a058192e6a09bd9a449a551417af9e976ef7839ba1dc7eef7ffde5bf36423768efcc6ab4f199231fe8cc2e5f7ac4a3f0862f889c2383743db42818e021febe154d7ed4feb7acb8945378f8a2beb5f960c439515d65d86e40943e33aed875d4c1b74ea485a08e54ba3154913cf7bfc5636cbcaab418437d14755c362b3b25a45fa13ace9a5efa7c1a7a889d3faba626e19249e6f0a784c3898d58e34b0a8a7c87fb20bbba467f7d2be2878f277d28dd312ffc5297312c743acfe01450540b82f41944552c7cac9ee0a55794e0ec48642e8673270fd3ff183b5ee8c8c9bde8cf797324b8ecbe66858ef097dd81b153c3931ffeea8925bbeb4a1553ce7fc9c93bdac2a687ef480149c30545b00bb5fc0af034b930ed7b50ff09c1392d5d58e963ab7500769a344148cf6322cfadb4f106af1c554536b906e8ba52b8ed85af945ccb5e16ea9acac1af616671f6fdc53959aebf8568ddf620cb468c67f4efd546b3a6d6808c032b99dfcb033b29892fb1f94df6b5251b2792a789f74abd552ec8f88d051bf40f9c0ea9dfaf9f92d3c49ecab53202c837835c35027cca333332380a0b5be78de1de0b03568a5664684e026026c2c84a57bc7ea90da03513f9af304db64262c3728829c7aa217c80612f8113f6283aa0d5940900de2f8242cd5fe071d99db7b20de037a8e58a01bfa148d55e0782e56ba8b634ef41c4ad91ed7baf1b24f8f1b038624d1d658afcdfc88a8d801f9bef652ac2afec05e6c4e9bc302050f0d2b32d92842e160cdbf861ba6c0faf4bb2bcdd7ff75c864b28bfd115355af476c2253f246ab806cbb927f63ebf7552e30c055e35817518666cae5764c4c41f93b409191a3b94adeab638dc444d1ec21b723621e64c08c34c767a034615959660f7432e8ff61b482cdcb24a1429df2cb8d6980893017f949cce1aafb2fa827c2cd9340044352cdf63f9fabd663981d42110968b0b82f843d1cd9e0156567f0eda087164de6506dcf164ae8b038873ad6a1dcd626e3a7fd8f8b888bf0ede6dcca6317f358552c0cb3e10129f01106761e18ae780fa1b26a7c89bbf1d4bfc31900c404b30a1c1c576eeda3252dc2c8484cc4ed299c1dbc22f467474bbf57b6f19f07379fdef3b6954feeb1cfe60c7a307c5c6bc421efd90d54e4be192f07da7374fd0890575c83508ef98e6fde42af45684bfea80ae52b93e117cad6e37dd932bf6410bb45f9bb973703cdee6cba226f9b89728280206243b811d6041078bba03b863ec209d475370be5d89ed461705a96341bc7519ec89c0f50219476607d9f42153b9bfebf697f40494de3bc897aeb6091594dba29e268052dd5f4c8a36de9e093a840530d0a6f1ca05757dabacfe8ee676ff948927e5ac70bf7d34528aa6a7cf044c73537530cc650b8d9479e4070cfa61b49c1e29171d43a7f36b559461fe837513951be5fb2c54814380417883f62f9c0306bbfd380eb530b3847637f3c76a5761d6c8a198302bf7a347192c626bd7cc6280d05ed65d26401c6feb0936d6ec6865d63504ce1dbed610c1f7f1b7362e0ae084e0cb49e2da9e275b4b787a31023d8e6089732bd37acbf928b51ed842ea489b4b1c47b6aa0b13de108dfb3ab2798645393fcd8b91cf7f200ca7a240090f94f1519b190229cf95e968fe852c6b1bd25ee01f7668868b1e577170b17657a8d2660610f654d331595df733ebc80bde88458f6fa2ced997623c0922256f2d3fa3456ec7c6b7db4afd95a51cc6afeabddc2bf1d5b57b7b40ac49a335e483305ceada6cb92bf5e812254fd4496087294d4d04cb51bdb30374196ec9de6069e6c6995c5c39d901765c33098d43fe04b2c22f619d4be8bc148a62b15ac8a7f5c078021af4397ae4a26bda90c7abc7a522089f8615c3a11721c877a9e11399f9e52edf470607b741a205f2ce7a22ceeded2ff6e2bbfca96a5fd203f65a80fc978806b3952f863579e32adb73f3bfa73f971f11725fffe895277a5c9ee06ad8453f9717a2e74630c130af5399b3f32c6fe88aeebcae63cc2a673df2383e452f7d2c0bca5c0666db31f772ad79ee38da97e638ad64946a4b1ff744bbfb0fab8d6d8d84f9a5c3250d4c3f8ee8b37900f5d4866f2310855d1daed8da8e1f868fa1fe449eeb22ecfc69565e0bbdded5422e06b8801af6d68801302be922cef568d61fb764f05ce81724c258f2704db0819ebd8cbc61ab3bbecb7e0c0570bc9a19e8fc6ea8bf769333638f116c5a86c461b581ca30a317a71cf4365b433b13cacf504a3c1830e2efd0f7543317c2c01f9fb8aafbb0a3cf6d141c4a46aa577a7514edf0c6e5207e59be8b1d7f637740a0598c47245febbb1b4134aa8da68d92614d626bd784168328e5cda50a966a30f6c09e3a524135496452e888a818e02c227dfcd926d406402909e939436ba891886a0114d7f9264fa2c7f583d24ebce9d87e702a255252d3bad93e4dad9b29a9110215a0fdb0b4084fc7894bf2c874009156a3b5e809b26f1b2dfd15c1f1cbfd55f46f7453dbcb278712d2f9c0064f2b882e9cbad9562266f9e6bcb81a9cb36b2b717a696802acbf43674cc1dd526cf133b50bb0cd91c12b74a11e24e4166c66feb1fd3f9ca941c98186de60462da8b100c3ac9af229f619780ae696ca25f722a4b913452ad4156d0b8cfb30a9a108669b1a8cc8831aa4f77d29f10f9c90be9267ca5ace38cdcd99d95f3d122a02ce4db39b9c90d80f43fe6d0353d93dfb0cef537ac96c8b0c670e0185331a382e0664c0e110acd7f279f8ba84ac938ade004d536dfb39deb1ba53ff425755bf18cd87362bd4a36ff809ebe4903054829d1dd4674695930e393af5069f9a76176885f580d5f6cfa17f74338e7a09a2fda5bc02da2d955bd099c7dcbc2f1375","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
