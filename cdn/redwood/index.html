<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c6852edfeb9d03aeff16673d3ca2ebf3009b8c4fd955db5b1d6de5771c9e0dd8407d9af24192ef4dbfca6bd7473b02060a357907a647621266059acead5cc90b99b35e299e943d92fc13965af1892fd938caaa0771ee2441c65cae15ad6dd86feb24014b8326d63848eaf4e7b828640a0e4e7214934b10a429c0cd43ed641b1a6844aca5d15e6e11f45ef8457086ca28a22e9f0b97860b80b7f8bfd03a3e5b23706f7850742bf5e98510154ad594ca28ef942c18da6e377a97b96ffbac73bec3a2b0dceb2429570e9a59816d4d85d3fb1b10b6ac1a9bf3d763cfbfc87d0f5057d4b1962e8398c4c3a65ca7fbf1798f9fe3a119392ae03b4f4f1949336c11058919cd79d1d4395053ce80266f59c53a9dbce916ba8cffa50353f9c125da81078887d0c4005fc5efa370cedbdcd3280d1d14f31d4771276cc33e292117c66d1e8f951310cb5ace8aa7ef46b3059235e9039352da571ee946de7462a7faa5984922faf2580b24c66cb3fe17e536acc02ff4e308882489f3da05165c9e87b30c88647bf7d42a90a09e91b720c124a1bd43928af46974b31e000b6017f290dbd4c16d33c350e750f0ccb8971880036dd871854379e955a53df77586319962b59c9d4b897959cfef0bd229713a6a7736c13c871f9d2d666fee1dcd01d0abbba222fb8b9158035973770faad92dbe6477f88ad96b6510fa3cefe88cb12d788cffb0bb3ac7e56af874aafc768df2674f531e208fddc68a70d598dc4e762a16f4f35b0a26be1317ca10ed5273cc382bccdfb73b475781fcf9d4ac38545c8412152b0ef0015e08ff32aed82e4754e63af21d3724792e7db48c196d88d9de58b96179a59fc932a182807adcafb036f2a5b5abab5b490bb1da1bc03d486b245ae8f1e427ed4f3ce27c62944593e9b4fb47eba2ffcabcf2a19b4f59b5bf670c2b3a2515e5e7e6ea6ea32af31753a7af46e8541390a62fca79c8c8ea916f70a00437b9e3175a05a14bf9bffc07ce4ef5ac9e176297a8c65bab156248bb996ef103ac769e1a1c73f374bc0247dd7d3246fbd0dd12518e82b4e4630517c86afc98ef78690fb293d3f17792f342e4df8be7da9d6d665e6f20095f424891ff578e5f09d83d0e39f7fa452179d7956625097bbdc95b46839d9181937a21c5977a94a6b069b0d51e1c61d1c52744d9687b903d5cc54c266d0268e7d69a7b7505961f8e81c3034d30b20a1e235e16bfa2a3236cc8c497fbc2357ed59f964915d0b57ab821ea6faebc0f93bb63a4f2925c5ce711a24a985cd5b323fdc15c012ffe42ac8bb76c9cda835e420b37f8e99ba50a09e452698a01d1a281f94b75b874b6a763fbe7fab93ada9f30253fab5365693c6d91b70c0f9f93fbeefc9daea9d5cf9022fe4853c18651af471a7585f12145766fa961ff10a0a500221b95828a9e061d1c68d75ea3725867de137500aa88c4e33812e92b27448fc008ccab31724ca375bc7bd207505ec198f6692db4510af7384073aae368069826e6bd6ad9f2ef3db5fd130d6834368ec47a77ea396c5b3f035b513ec80fff66f01d8f732c027d4dd26962289ad8edded7092a99320c611acf0201ce0e0d67ae2165c5bb7e72c3aef5e9988a166de564cdf3556071c81e61431182249e4f233f30f39ff7434c2e72444d2be49704d429ba9e8cbbaeae23af8d352253dae2dda65e21ac504dc940c26613e94e1555883554650e49bad4f8c7d07d3967d1e42c7589f7827c274b268ef19425670ec19b98964a10fbf8a7ffd0fd4da8cba071c6b0a66341dd3311b60294a40a04bddaec5387be6342aeb41aeb46277937b1af7c150ffcc084b2ea10d827a1b89e893ec8ced907cf7bd796bab0bfc880e6d331dd0c988cd545d51c1206b58cb9fbd37253f7f34f2ebafa91c9dba22f5ac08bc5c610c34605f341830218c6f69e68a37d2c41d16dcf05adc6a6e1353ea4a4007f95f27e43e0710f9c31cc53cfb389a2b39955aa3c73cf9ebd01fb167a632c2f165e8e3f5dc1191f0ae48c0d2c0d12f4b52a7b90ab978d149c09c08290099b661f0b2220428da656b9859e8131b86a9cb652ce94f2e13746b51873df0a6261a857ecfc372d67cef8b22d47582e1a80ad42f8a1f53ff32aa9e2f3390f2db1ab5d961e2cf52174989b5f483b5fda78b3f7a39586c6afbc3806e0408f8013332fb354f73e969a30f84a77fa8bca088458bec4e3c88ccbd644a086b6c9bb3ae565f71a014873cb0fca3145f8de9146662558fb87194859201fe345ec899b11f951ee30a274ff7cefadf4dea62f2864199405d1696ce9d2ef2acf09e50e044501738cc4124588f6e3e8964763035f939b9972ddc1c322e1504880a4c6297239aa0171bb03d59ce2ec9c0820ea6f509c71d3127f212c4214ad2005cd46f0d252dae5bff4edf2ee2d38e868165be0d5492c06a0b2dbde5a31bbf6c86e2f46e75c74f0fa50e84cac8a549c57721e3293751ac29427fc96839be88998e9c6bcc9536acb07592ea238b779d54e42ab3e8e078384632964be1966765f48476ef3a0f2c321bc60d726e86695ca8863273a7be35eeb11a475a2a1fd0fce33414242169a2f86f106440f6be38c9a1ecaea22a474fbe0599151fa4ba43f90653282ca89fdef9ead6a89bb966d012177e8d76c49877c5f93986704bbbe4945e6aa48207eb985cf121a708badd3e43ec232b8075affcd8c3ef470e6a5e41c5966388fb3ff5cc480e2c317226b474f6af71f8664687005985b2322555a3e4f5ed30ad4e7ef6e5a01cc8f19a7cd0247a6d6472e07ce63778a7af40c2a118a79e0b8d4a3c7a253a69612265bd894ac9b7b6bf7573b6e0dd54d7de5954bfa3e00d2423a2aa1ec7e03a16de369b1f691cd4cae5386712dc29427d21f9e0b5470077d7ccc3f3f8298230fc54e0be753bd518123c00b24c2304ebd33844aa1c3eb587950df257bdeed4417cc37bd5e965496e22d7a164a8ab202caab546d8132e9b245a7985adf0f7288ddc30c69bf4472710707835ded15b076b865f3e6ce862f8dbc3cd565a75cc49e6f900975c757ad30fe48fba9a83d9d26af7fa6da11c796b8f4f1b10e2472a7c54190e7fa740de7daf8cb82fe5028f4007923a14d2c74c7fdc39ee876fe9b892c566e8490fd69b3e64e36e1dbb018ceacccafd732c54ce25b47e0cba4caa1c03685f3e72afd550c69b2552fa80a4da8c1c468cd83a7bb62b2503aff7333564cdc15e5558376cad0bbaafe24f41110979b11045d7e343467f55d1b3044a1843172619d463dfd19d48e6256b6b4ed572aa7254fd86f242dd470ee5639a717964ade852dd1a757117624a179cc80fa64e9bacd4bf3dc6243c1624d54acd263331f023de3c024d98b00fd5b3c96ca00a7d6e788ca6734d71b694769edc3d3dfff4a14cc1ff9435e25c12a8aa25451ba9b9a4164609a694abb3927eb4deaa07f0a741628b3cf905aa838da75b9e9ae7417a90637bd08a34fadb07979ea2875a31fd8acddadea29669bf3d9a7738e65ae9251a5747151dd0ab099996b1a2623dbe04e345b2ead8534793a2b9f710776b56d2f253b2d6dd4e81e6bd6fe407a3a698265561c6c6bb7fba75129464f6be114951c1f924756196fb9ced95362e2c29041218dd927124473c704de8af92f4648ba6113ef26da29f2b6c554c0fb4fd4f384c0e862243041b5f52ec76d87f452f88a80fca2bdcd89711e137103019c23c851446ebe0f0841a7fd50707d37319382e56f2d7048cb955f5ca189aa9b35d457356952d75c855f61d6415ad59a30d9e530f093c37db485a94e4f198da7d2e9f607c17d1a2da924c3b3291cf4b53701fe3116c7f35a938c5c71710068e97efbe22431c340abeccc8f5bb3e23fff42d5b48027d5b67d43a81770b8b1a6e1d08640d0da6d3cd34f60c10b4da83d8c44d6f1332320889967af380d32563b961df474ca860c7a6de105dc22116a8a8a94d884fd2e719653c5407fd33fc2251a57b34c8afb81e874377885da08f423fdadbd1d0981ef770e76f773b639805887a509a087cee2386f79bd4996df0af5033051262b759ab632d29329f0a202a54e48b0994055f6865a16fe965162674d32fe70c1c73b9c9a17efe1040ad14bbba61bfa52fad1ae76c4895ddfbf82f51d89623c012f54f4d0a160d91a7fbb8d2fd44155830bfaf80a7348198c0df56b18704b57f1d32a4501c7c72dcb534d9a98fb29da71bd4a2537dd8272f01ac6c52edccb20961f599d692967979918669fdb7267ef17bbf7e84c50d032049b03af208998155fa50fb5617a1adede06a77acca96d6cd7aa7be367b50a545b22271fc40fbb1315b9fb9dfc59075b73f183c6ca0e7b28da19909505bb723add2abf8410be564b672236fe91da4fdda3ae15764c97d2232d70e617f96a055951679218444de598e1c4c2e9e361752f67d90b071f158ea7e38e2beb8de0a935d770dbe9396e3eba50c982120d12634dbbebdf6c430e51a38b06f2b147ffc199443d3f289e5a2501faf912af7e788642e7d1ae01a3ba8dff131bb80943f37c556501659ab0acb6cd1424613d5ddc6e1c177e5c4f29d64a5e718b57713e570fcb97ee801a760793f502e0e00a5e3ea3772a94d20e2b6b52e3cb9f1b591278faaceae9d0677cc794f265576121fecba12aef5d6e9723e92307c5745c80ef7741210197c79fbdfe14b827dc9d71669931379e61ad8abb2b45e0febd356eebbbad2753829b48cd5aa394242c3fb6d86edafbdfebefc41fda1031883cad4bdf7798a5ac76aba9bee691dd5123d4f4e379c3daf84091aa7e27382226a2ea8bce72038be406a95613758b72ec198bb7204b49569e74d9a7c129dde81a3d933ccac4b2168d4160865df9300cadb2009e21b131b26fdb3565a3be4b9c08a6d3745ee99eeefa0eb2d0b83f0f697c97fe9c7d3d21ca66edf59efe998c70ae66eb9e432518dd6f3b91df4eac917f024dca4cb3c26932eded9f12c73a1654b520a92ef53fc213220bccae02420d5f7b0e60d4f34b32025a787fc090b650d8325b41f747af537fa92b4ea34f7fdc45febdba828dfc527e3208a0425e53e437553c23f35e0dde50c159b4b08d74d117e6ee6d6f9b97ab54da1385559dd1ae207c1ff2b1972924de0bff0d71c0263d607d1c207edabd0f0c0b9bfe208c994ea5c819dec57d99d81a59297d44b0e01da6fab166739a59522b7e2ad32fc05b06a98e8070cc5739f28576588b638fb136d14df7ca5dee2c703299779aa82eefa30b744d109ad99f7e685cfdd1e6607626bb7edac91a3c190d4a04e41a0a88efe6b2d610c093f2474a45946fdb1613862289cb7c8b6a0d2c79de607fdd92874dcc51498f0ed435248135d551b83cbcaf91cacdd1967655e3de484a52eaead1f5b7a4c994a8443453b0d8f05b24f935897a0154ba1eb3573d5dc46a2428c1eadeca82cc88979fcf0610227c904719c58a950f27e764471305864c877a35b709d4da3df67d39e5cd8ea3c7749192d931cc16db58945b7369bd4f138b9b0aa6066680890271c7cfd8e4828505fecbb2086c3cbb2bfc08edb64945ca515b1523b381ac7e6bf2a404aaca07f6b60e38abea77874aab95ee5141aa78c33622052749fa97ed43e3f985606b87761c8409f374719cc911735eabb4e563d8955de8e611fe7c0be8e0375cc294cf318f8b021ff42e99b573e9534bc0a8b1860e48031dc589487840f636ed3b2bf55223fda5c3b5ceacd776874d2d9562f1c488720403ec1726996570fd1f387c2f489b9c94585030b6cbaa4eb115aa17c5375e565fa05ca69894940bb320f2faecb3de604ad6031b0613e65c04ed4a2246db50ef9c0ce178a574d9abade3b52a3a30e957e45295ed66b29d84415b780939e38c670b0be5e61360bc9bf2fec2d0cc971bf4dfe4b6d0875fb7c290a84bc589db7ebadf2b5e7a2780d65cb888510901a1e5930796f7ba9493ce3f1e59a3b50cf86b93a685c97febf86998e98bf5477b0d250026d8ee141a841eeb6e8ffb9404d939b2de8e33627948716eb2ff6232b84ad4083b9cbed74c0981b37ff326d057d083e5f3e7d478772916093aa4ec3932afc86c55fc349d37623546b1e5d9a8cbf361a3a77ab024f8e31de40570852287606e9e6089ed40f3c962925e9f9b2e8b87e3c890c559bd93bc6c45ae50561e942ce5949f8da9df150e31594f9976efddbbbaf7e9a4a94d772337830956cedd6640eb5a677eed6fecda3c22d0dcc861dbc50483806776e69fa17650324fa237b5fa299b59d31eb0f648bb7636a9e3e01cae43b75a4de285ad057a255a43b793b4ba539b0c26b4f02e759695334594704d7d8efdd683f0d5fae5d5fa9e514cf7431804c19ff82ab87c5403f9695c8dac88241df6b6d33532aa24dd6ea81ffd0839010a6d3b398121f72e5ac63cd9e94fcddd45d80c7449bdf0d70b3190ce51d1bbb5db77636e4139a85e8e97edcd3c80df6a0e93e70a37a9fab796e02cf927157efddea0babbbd7675d47a2b70a0af59cd1f057c366b722fd609fcbf1fd5d9fc4eb3e1b30f83d4afd56a4b71d06006470bbfa91c6e881e177aee632f77a69583a47ca7105186450dc083c94d4bf57c5d2d5534e405a71a4467e5df8c548a0bd3668bf2e7396e6123332feca47d6710d2e5dec97451d56d24a3c9bfaeded800a9f2ee019d9622569d5cc8e37bc3976d03e2febd911620e2a1ac77ac62db6a3755bd8758c6f0721f3ed67a11d716b2b7831613bed851817d868fccf6e08888d699366bae20ce1c88f15108a9cbdd9a25d2f64e0cfa9c80c182851153bf08f04a766f1d0c6dd06e1483cecb400c06983ef026ee9c74493e0fbe1ad9d79720e9d78f50295aac92d6338a55e72a047babd60202494711ffde731c016c97d8a7d71fbc65806cde1fa8b8e352bb53eef037deac67c5e44b32daaf75edad9ad9784f490b3423c6b6f620045b1d86971bd02b7a8994cbeb07a19f2427139a020db8bbfc5d5a8e49cb70ac066a615234afa2a1747853cb213b79a4c79df92fb1b66743e344e36a6c80d9ea33b251c68453622495e3a8183188d6b73d401a0a29e8fd3ba52116846b6e94000e33d48c5975e08c5652c976490c225809cf216a175320736252490f196e50f9b53c3e5fabfdb8fb5cf197501da95fd53fe5384e7f723698db03345b2225f7d5962de40a90310f5c042c2c64076bfd049b4423b71643e2dbb515b3912fa6ff62629bf0dcf58e899cd66d21a09e4edd84da120dd84ae608720fae961e0dde3ead0d04dbd725fe5f258ba6d5979eec00a9e16e7cb1f969d218ae02143cf0bfb28dbe03144b631e79ad100fddcaf6e41ec184da3641a4312a34f06e3adadb10b9323cf004e07fbbe8fc38e67dc021a65c7e980c20064287543c9c054ced4836ff15f519bd7af9f9c0f2dc9bc3bc24f3d7fd19bf2a52017eb2c4d0906e2d4f877d06202ccf67a54d4cf0ba9c621e11614e7cef0f5d457869cddebb72d8b11d14861c6498a2dcddb020fb3392f4ace87d2ff645814246fe27bdba14a1b88fc5bf6d045fca6c5a0c015e0a2a2d34a00eedc80abcc04aaf374060a73e04cd8506b377ceb0993912c4ac8221bee6621b81fb4c38cd66eb9e299959523f0be27153a9ef32ab8b434afa2e4a248c25cea6a70ad51b2eac82f9febbc77f7c78cb9dd9ac396baf5ba7ae8ec3675697aa9733ba604d9b383ddc4e169b9397bc5ebeb18d5fda39a3aa3bae3d3cf4f07a2c6ce0d0007dafc4530a6f0041a658ffd298d50bea8ff352fa8f0cee43ec3301e6fe49f1c872fccda85b4d4d7a82bf8976db20eeec8d359017a2eb4e0de38ab88f9f76f01373f2d3ec3559e593ccd0d699bd9669b6af87916651ea9f9f8425bc6f432fdb7e03c99ce0865ad62a8ef6f9f38adceb9bf04f3f6902f0b370a9ee06e6d2bd235ee0f32911b2c0392cd8fef51900fbf7899bb37fd464856e58c0bdd44fb2dc43001481ee1dc4c63de9fbce6a7063caa1d054aebeb2c4a1f49bcb0914ad709b05942dc8626c2aa2bbdeeb5374224878a39a6caa46f13f7c853fb4108cf0a1aa934976a9b69be09e8cbc316b8e48a27b1dd2d746e5f7b76dd05a4a1425debed5fd537a8fb6ac616ad5f5e4c00808826645f9ce1f0ab723abb94bfaf7949416621263087354d1096cc92de5d36c4415fe9450011446ad2942f7fb5cfc108a6bc8baa504a570a981b74c27d258f88caf7631db3b98d77dd3894543339c8af4f5bf9a744a133a5841d5d2b17f29198605b082abec7576bcb2c82ff6dcfef8d3e41515b62447d16eafc7986e6ff1ff7672ce8d9ed10c1b26bf93b25edb0175e85b214a68fc655825c3566fc19abca0e29122295234fef242a39d66fe32c37583d3163bde3ce93b2836ece680cf7d35c07c383d5de8c1837c2f4ba75f6dddcff00fb7c0513f2dd5f6164931372051132ee92aa351008c8627193af4d204fac550197f71dd64ddee23bcef95a536de96afcd4050fef1b2a35f05e15052d21ca24913485ff0469f9ab45671c5241f74924d8e8a66f53d68b14fa644b67a946c4dd92932695f75e5ba0a5764f136a9ba1c7b3c7ba08b7ac8e765f2c1a3951e0f1ad8ec4dc35822522ec49efc99ba1918686380f7fb59b23397cf6b5b7bc6868fcdfaa38880d94926a23f0fcbab68f30f7a6ad17886f3791584db6b57e71bde6d9acd191053fe06cfdbcc906d97734333847e2ae89d8ab23a8d3cd548e9d7287a312b5608afc9e77800bd0667f9e7bfc83427b284dd9a4da97d9cbe5232d9c635ff6db0581b5fbfd48bd5014770000d0e539bfb2edd35df634aabc8f7095fffb5ceb8ce2a76f4cad6e2f7f4b86b6cf84bd7da396db4f49448f8f8487c8f47980f95a07a91a06b380fb67c1bef4ca6f6ad11781a8c8b12d879480555c5b9ef97a1a4fab6f5b9c75d8a8ccf09ecfbc640c38a31a09399da4dc7d86f62afe434ab01e935badf11166b5b23a17e1d34786e31fcf3c5cd25fd2ecd69d372f5dde6798573239f15e78df1fd4ac0a7785456f386334203af04bb05bab3d62eb0c79ccce5fe9314579163d7c7e5c35a791302fcc54d7cfd075aa43e2bee76b0b79efaec2c6677af10bd6079d350aa386ab7288e1cfadfc56983be51e8b7aa72f3e8831d4eae0f486cf187d8f401073e621bcc03c0e58742b8dee8e37eedb05c1e3ec40e9ac502924966d0cacb67ed8732f147aaa1da5db0963b657327d8f394ad129a7e54e917bd60f8117b90e63ea8fc1c2ed16b1fce9f15b0a63bd2ecc51b4b8b877245a14039606203bea50b57a2845260588bd1ac52afc14815b4deec4ace5caf1f6a932f6cdc12ac372a3b213fc72616048d4dbbe782cc514a11285b58a1343f45c1071648814ed56952931cf723b741b7212597636a21683362c44ca4f4efd7dba0b1fba3cb570e7bd50f75d4a0448558a7e191c5281b18eaa253c5a41baef5dd97325bca553d86f327ae7dca897efe4de204c72c816fa008e6aa116d0b42bb3f7fc49bb967853703f5c22d5c59093177b5ccc0df9a387bc3b7e467fd70a81643c634afbc970f532a792bce6e6c37f35fbe64fa2d1ea4339d430269195bdb9930cde21ed665c3a58103570bb1a2da92ff94f94aaef77c5b07a99ba8dfa02ae271d0a0755b1d5102a906153873a36cf024b6eb751e6eed4eeea8a621facb8fcf953d9c6750024b974b43949d7932bea1a2cedcffdacfd48781aeeedd4ca39908125db92912ea6102acec82071c1a22bf3da657b038f4a06da302c9c0d7ce3d34ccfb6cccc763152e2e12cb140a48089e54beb5667f603dd36d9a615eba3c64480dcfdb81db4f309b0c6db3ab88fab4afbb40716f66bfaed82790ad022b1a695a7b13937f934a38866df2b8edef475bba7fb03a08100381a176c04b45ef4463485200fd084ac1c477f185a86ec87534f0f1d45cd7c54bbb34b43951b0a1962bc51c3e4eb65701bd58812ea783f4994c51f3783abf4c76cad928b0cd3d566d21dcb60479e38efe6ac8adfbcceddf6360a2ab84e23096d380aca59f7bca0d6aebc7f34275574e8e011ed5c7054c25cb1bc7e9d133a60dfdf49f5ff119f3544248c60006c51f647407b484aceb2dc474074cb74960f5d456f9da7dc95c1bdcbe7bf25de505b003f2eba7a27cd6b0c378d51300bc47743ae7409c684a275e814fcb2304b9f0e686d2e6a626b09c1ecbb88fd93b8f27bc19d2429089dedadcbc94c2aa8e4d4cf8cee0d3825fdaa6a1f4d359a3daa5e82b6282f065ddcb089a45950fe7ac29900942824235c57419be31774ef47923c538c68d9187dda76a1d4af942c353af4aa7af94ce6418ead22c3870a036f9b1f9d8a944c0263534f4b68c8a577e2ba18f725a369cc6d41ed9c8aff0bfde7f616bda517b41c8fd9ac2405128cd6dfc854a58ef7fcd6e1a39acfaa3260919364931bc240a3c12ffb8390e62a5f67f146e7b30be8eae5543c3425a6d96a1c0aa4638778b9f13dd57df98da1cd28a082921ea8dcf7cd37676b0afc5f0e405e1adcf716f762008a6ad41ea8dd079f702ee983fee2f142c8e0b0dc641c34aff80027a631b639396f0d8e3d10367848319b01c35a767bea10215e6edeee2564875b32b52ffbcc45499954bca54fef0940a747e25dcb6b1611b4f2df9a775d6f0ef69fe47d1ddb0d495c9386a64ffd4c6d141c4a3c567948076da5ef03141f9baba5b256c969bf222a961e11edd0aae4c07d28d0fb40f5d5f295d328e6952c3527a4897e2409863fe304a332e02e0324a4e6a3048185e72e7cd7f900f3fe8c62fde700483b1594772b8a1ec8cf12d4de2067092ad1eff019f5bffcdcfa260d593443cdc1ddf54f5320c1085466f5cb36ee9681a5d735d155683bc4a32ea9536c3ef69be92685f89ab18fb14c1fcb7fcc0a18655190fa39f1f90204e08b6a12d569114c6c6c112d98a5dbf06584f2b855581c4af1331e8cb6eac48d2a9f46ea62b027f855573b0a0253e1999b07eccae3e545c0aec7f021870473c169f084a5cd98ad851c3782bf9eb57180879fd709f8283853f98b3c65277da15af6da9a32e0f948a97e313395e51dfb565494bb7324f8fea022de3e8a93aeeb7394cceb1af793b1e316f84e9793ead94733d8a8ff41ad21b56b8778eb5e91f9730607d0884e1f23611554e6d685f75901f95b28229852bae352306fe6905413336dbf2ab72b81d3f67aac89a9febfd6f3d05603d16186a858d1cfe9abfae9f6c295d80c96fc7cd393e8d8344b26c5acd192536a9746a561547fe91e3f51b93f70a5ff666550c4245bf8ea06ebc7786fa6202e3bc28f5010621cf65b3df235db1708e1d7089dd7a86d7a6acc7950c722022851e4f105a2ecc6d807f87ccdcd944bf104a57696cd26a0fda489841b9465406d3c30baedf00582a44f12370d1f4ee524ac3a87d05e4edbd951906a97777263000bf1d6261fa25695b484ba77c2e43dc47010e15baade11933d58a95227ff17e727063af600f0ae981ab13edaf9d348ee2232dbb9891bbeb4f95c0333f8f2a0b1bbd415faa789c0ad8aeda3b26ce11f7187d04ef0e25eedbb8b4429d2699114559af17ace1586e81877a90651a1e89221d608d1c5c3f5799ba9b1f6315224efb7e194d8f5ab85b106515fd094763082e9fa0e769e346bac8cf4986f31efe31c0db44e06b34ff5ac723f0435e1f159d2fcd38fd0c8e87cf370d1a29dd8a558955f37389ae2215907bad5f1b657fae0677d8e75b86e5a5bd0f661ca990f22c1a13a7f219335f6c2359a960707c1f5004d9720cc7f464d82c7852a7ffd111ec540e35bc99e2dffd6c4ff94de5f225c58061dfd89a23ba6eb357334f37e405fa43eecc2e53e3441719f58334f1d8a78fbf87f45bedfbacb7a6f8068ccbb364fb503bbfdde0d2b9034712bbdb315c5af0afcc5f0fa68e580e0629881fd6604876374658c69cc1e4dc0d040f19692217d8963cab18de013639221cb7cc405c2dcccff1727f14c3ce5c0ab4d15dc73cdbd86f69310b265facc1a7343d26dacc5ae448708f184184559dadb113f66b12c5900c9caa27ddddd200e149a3275df02e84275088994981a12359c4ba2cb8c5d40f4fd34e018094a58218bedd2e6e7723bac00779814f2a97470b99c4b4ac7e313796ea63751bc28971f66a869314d9047166114cf89eb987b195ebce5752c4ebbbbc4bc039c605a8e1a07fbe2250b2904c0dabe8486636448ae3cbba2d509ca43356414a389f745f6519139468028c3bb5f588884e4f270e7e84b9fa858a54e62703c6693b5606fbf2390a9561fb99a13c2e436e9b5b17cfaa8d4f465ec36b9ad7fd03f917a27932ebba31e9f9c19f8efc95f2742ae809780d231c4359f8c0edd377ee8a858996efe54c83b2323c43cdd46fa4b6c62ee1b93536a9b7a3b84ce7321d2e7aa5dff6a37800c6687e4f32e5997d5c894ddb79c0a2f5cc0267066a74f608c517ac94efe99cf40b1af6a1a661864593041b577a16ef5ab3be9fe7c663147029468be50acfd1f053edbb02030d266a1aa0e381398ee8cdb1b35614ef7555f761db9ca94a79c4f32f7f932fa55b9dfb55d4d144cfd3e9e95474e5313d88962ec2810149ba4f3e10678f938edf1368360fb55b7a63d4eebac6ca5f443f968c48f86c3eb3d1eff03817f79edb524b44aa9d53b166b6ffb5ff29efe0501321b58554fb4bcafc16297057b9d7ba79e2d8c56ea501b065d1e70898669595101119dee0c228d2c8da8c6aa7170e3edba7842b254225d853665a2aaac86c8ed1ccfc8fbffed66c9d3d27d96b0dcb2276eb1b02f40e02afa0473a12ec062923ca1930e5ace5173407dfcafdfb09e7c673b9721dcc98226710f4f4723fe3bf3ac76766788f79d0abbe5ecba77bdb2a558471387ed4089ce0fbff6ffa763cfe1a65a25181d954f24a79c69f080523b244296c7bba6d7bc33687514da19f57e5602b45377c255d120dde9ec47dd11914626518fcba55d1a0051e1ceabd7e6155562c0551f0e189bb7980c460be360bb0acc314a85c899537ecc74c6ba8bb907d8273027eea2e6bbfd17fc530337160278abe3ead49d879f0329a14a70e743446f971b18ef8f6c2a109b5e88dff27d935d3228fe2a2f468c84f7275349a35dd41d27b40d55e56895a42842e12ce179354e77c8de2550d9b42bfdecc873171ea5afb77cd0bcae4e89b473dd27dc2edfd91825be6632d98e2d7d72a6051caaeb1c43e5287d0b31e5b832a7011299cbe0ad7f51a993747bc53a57c3ea9471687c3c410df455ec4f0e271a3f01cec61b96cc951b4bd988c621e26ec03fa70b9d81f2114b47fa360dcc90c469c9006ee994897a6dc475c0e2541bd4b063d904e1bb6ffbc29670153c22090ee536408b682d338385e7ce4c8256f804abe57c5dfbb23a433d66489b4523ab7cc0251b13a3f322828181107ebc3e51dec4f8108d3c7686ea1ccba416de7d84ae15212193f37c9d33407491d4cffffef4717df92aaa76a08e46407e602e1a39bac0f9b366ef12966ffae6823eb50da6c434d35f4ff6d7cfce3a5cdd9157349e86d988fa8123eb49a40bed55434e2a52fb1275b025204a261ace2ef5380517810d60f2f278b26bc701385fdca240d1e77f4cf2b5d12959b7f5ed0da5acd4b092bf0593326a6e163b40036adb653312d2f9c3916644d7ab25c00c719b619fd4e3769a5946539ff3a3b2fe4571562ecfdacc14c3e8dc798156b87ef22f9705968e330dc861314acef71dbc3f5e0bff9071209b19cea2e2c6def04e1201e2db4aeb57d65ebc7f70b005068355628ec8ad8d4d2595a2a876673fe2f4db1e2856275702dfe10e05e2fc9e1b56ab0ab7e94550e94cdbc32672ded5e06b18ac908073cd0cbebe0cdd636d31815c45b82765433bc9c1edee10d530a1a15809d1925633ddf65729417a6049424148e88d61a963c03306cb314a7417b6e2af885cf52cfaad9cdf334328503e6c15169ea02f8d9e45a7dc35ce624a675b8de247d11231b1ae0f4ee4468692daff3d870a48f9131c71bc54b9242b7fb8bc19bb7809378048ceb50db88debf5b0e31ac00f12335303f99ec5bc6f748ce8d19206349a56243b4dc6fb7a2f0055bc38ae9f4fa7e1c38ed3dcfdf77bbc854c1b57e11326a29c595ba542844c9eecaf16c457b4439e0c640089136c88c7916a9f09be6b53d8d87334b33bb962ea2dd0a8e8e03e907ffba4a82ce8c197a06fa9d5cdb1da560037ec7b4831364f35406ebc0323ac812acc9ffdf580534c7d3ac27fc06e009e7d24934178896260307dcf0ed7734c9b07ffe8dad527cc8ccb301b72a4818476f89a2877e971f52edc6cf9cbbded0a4b667daddbf1056e75f0bc2328485637198797dcdde691f81656ac80c05e3f6f193c77f953636742cdefa079aedddf3addd781d0ea9589bdc2e18219ef35ad4aa38a2bae43d8c519f49ed361e8b1688be347f4df9f4e8c14ba3d17a20fa89759099f769267e51c7f80d46d464c831a0e76899609980e93997ba4d04c448f468f5382254683901a9e875a9559fc9a2adaadf0fb9314e46228d91733c10185c4c37079f10da42d0d30a24723749823a942d95e95bb8ceb3765c310cbe122238ea8cf7ec28e8d2a032b2c7e1043bf488cece1192d0ce2351131180b954b8490b7574d863c5bf078b10a90051e42b1aad3c6f5b00939908c071b7e7c1d475f6f245a35c452b8a92030c8cb84b91b6d3cece47f01d3371170386ce54e6dd24f4b2ecc16db94e5015ad340fd444555ce699e38f7870668d58566c66d00e5edea07b845fc66c4ae07ab72de2e0e6316a0ca6cabe1216b512345719c710763c58dafb0b2b25d0f494c22c0cc21615d855795e4376945e969f04fbd7f224b937b294cb38d5f4c13111ca30becd4bf99d972959fcc1251420fc8a490d95f1a93759bbed169d6f90633e7146900f94f253a60a5557d49a9fcd23de52b205499b3aafd1ec4d17e366d3b56902449d1f22660d84ebcc57879a0afa13e5492c5bd75f983e768ef53cbd25f809b48c0ffeb50fa0088002139e8934e39e2d7b4b383b4b66ac1ca8f83900a1806f456c6f6dd258d4b4a506071d3a9a2a89819f53ca3c263c737b781665029fc66f265d4cc6cc3466c07bcec8e1e9e17a2a14e586fb7ef212f34698a4a5a3368a891a60df283bca0f97c3f27a371b7cacf9396111f04fd83d816c033479766acab9a9639bc3e9693e8b35a14bbd9d5c47a96016925835323a7a4352f766c27d875be675b0f677b3536bbcab4eb88a68b21d02a095d647d682bd72a8da6ec75d11732cbfa78a837226c8c0a85d3bea523a130c60b868cb4f8b3441d41c4622bb81fce47aadab7689a0efe5d68433c02a7381acc211792be9fe0fe3887afcba93b70d20deeacf4a98a0736aa067697faa74f8b543bcbe7db2532dd7343cfe2ec0ecca1e68cca3c181c1853eace99bc4ff4a349a92deb8d32ce283b8a2222c2564711046623490ba8220a21a4c7d86beade4e93d07e52158702a404220977d68cf6e96974d6d6fbd2ab5a92adda05c56026578c5741bb62637a4df308f40691e9ababd06046aee1f328dd12ebc1dfa64c85370866ba10056a13f81e6be244b2eaf414b610c8c10d267c2687a8ad67237a7c9828ed6b3b8306915689d2e1862ac59a39b05029c6aff4f253a99cf3e290f67925b52a3267b9e18ac0d296ce240e76e19decb759652a1a7955aac0735d299c4ace56e4322ed73eba9b552184b09f9620a6d8c88b00fa575b376f057878e749eb31317f5f30c17ce928ba681945b0bd74fe39b7db391867b64ce405414f370824aa23d27463f68a0ed940c3749e998ac44c9397a8d22226e22b18cce7503b14be6efbf2d66bd84c2e658470bfb565dbd35f8eb810ffdaf418407fb7007a3fdf5a54cd4f2b5dfe9fbbfddce10bf88548b6b6e2ec7ab60d4a3449ea54be8f8113057c6d77cbd208c4bcd84d2e1d86524d778eea8e43fd912ba2b3ce2bf2470d44b6bcb07d77fc8e4792976297bc075dffacdd7ba1a8a1009974d99fed034ead98f70bbe4e9f4d9a2dee75680bf49225abc7965bf5d72eaabb5fd48f99f05d8be06af375d731c87b46c21423509a83edd289abe432be8661878e57d8c1ab7c9565f6f7f0a19b256707fde1cc8c4389a55c6b1d5d56b7bde105ec54006ae5d313bc154797ab7a746fa3f7d5f7f1aa43af0069337e4df2cb8fc261c0a72b0eff567402eb5379721c3b83040808f584024d6076ac5c11619096f769180f9810c4aa9e6b349cc6769876d58a27033c91df77056b4a1cd19e116d1f0cf5877b464bc2996a3c788c085384444da47d982751d6488c56f37b76b7890cb59a10ae4da3dc743d48c0e396ae004b1664ba50b0634f68d34a7a6919980a05f980b8ceefd7cef89fb7728ba178c2e2851fef435a4b99c6ea25d1ccbc8f9f12c8bb38a49af751ef8a5be47b6f6655436990da79be7fa3c4eba956ae923761d57d2398748450bd6e4f9d563aa610f00d8ac43a6c9e8a72cbf98fc090607ea2db865e02496d5a22b56d12da50b1554c0fc4cb866c765ffa5bd214c159004c0bc10ac096ded7ba3260ac7f07eb1945773e15094f0a2b8326bcfdd961b693ad32f3dfed50a665ee8dc96cced76aa16fe6cde811f8206dc8b11eab37a2ce73edad504fb0715063b3e0214b76134d86dfb9b8d156e9f4fd41bfcb67bc555e073a3e8d4442c77be3fcb4e0384f89f6d5b2287997544940daff5394f5e81637c3e5bd492586ff5147bb688ef12e316b111d6b365d1866a310a33deb5b28000ee57447004f3c8919782472f73e1e5a23a7c04ccf6edc946d44e5b80cb3e91680350b4a45f6db4c7774139e2b89575d06498589f014ae9dbd71572694f69a16d4345175c0f6b1d45bf7d2dbe267680c474e599b5d0996b9830d33922a2033945c05cec6060c8cea69149e23f091dbec4f47a24f0ab6674c18bc6a65d2017e2ea33a4e2013bde3ec4a5b20650028aa7ab920eac75b2fb071da17d204a57770822f0c813ebfab508345db94e573adcefe699436aae8bf4b185fe865c53c55368a5fa4c7927d6e15e27802b92abc7ece75521ac70ff4731c172ae2149a0ef610c059086f07f2a8d0e21c31a434d6a27b94cf3c6bbebd203619dc7f57f17beee4f549c52ec734c6dbbe3530cce3766b5f1420d3d7185283267126374936ea0d1c14fc55194a6a73acac7c28bdf1ee70dd39e2c08b67adafa21472e9731790dbfb8866b9f51e2e848e85577765a61697c76f19cfed4f315bd3cfaa4ba3cffdc42db4ffd3a3b8c797f47e27f08471c6ccd05b96cc024d2b0b349247c02fb22c0cc08ddbfc895e36928a0415f8c1c88d721c6250a1b4c1c67cbfe751dcbe5483d5983bec439a9c60be790b57f104ee0e022dda8e59cccd5bb5f2a7532c1609bcd62b0033c58bfece8e75c4a1bb7800f67f860cc9cf0e518d36b6cdc457f5ef297911b31fe1f8855ed1dbc4a3073dbd80fffc46fc0120bb7bef203211589873c84d95c62574566893c31a9f0a5a53bfeb339e33b256a4424e1a988344fa425cb96d6f392e01a7f09e45ff1891937b9c9dd39e0c44bef1e62829137db4bbd40d1688eca6d5e597c10a46441627df1817e6125f696d93f651e3a1fc2bf0a7d6257f9e45830116fb253968ecf49d856202886228f25d158786ef58cfd5c457c09dd789d345120d60cce157e1cfd9b7ade2be494e509520b0822cdf8f676ca0495c82dfaa2ef81cb58a07fdee9bf39a751bfdd727b1f2346fa065d2576a8a6cf7de3e8b660b8cda531b6c4bd5f38fc0a0a70013a8b2f23fb1a42e4002620cff179c108eec65bc626b047429d6ffce3c392556b5392638ee4c57b1ed060efc0c5d82e68a2c35613a6c18a0cc6b9877c512af5e3699584bf0b379ea6d84cb230335d0bc32236d40a420931471e5a890f3c962ed43582fab5d18ab43c1c30f6dc01b393b1ca5fe78b6c02332f886154e7c82ebeff0912b326697d62879bd9b7a3f0b688c283ee42448e828bb6498242c484575","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
