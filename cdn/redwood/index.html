<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dce0ca8d01b633ffc8b7aa9f33253064e80b28f11d2c574220b081fd7b01dfd536a9ffeb220658cb8c679de08c4f0fad9de9e9b001032a63afce2306c14392c0c106d6cb011106b867892c41421e54b60cea936231470d4d0b490c883b074cf0c72a2eae038aed876bb9411c56347c0519e3ebd6fadb3d70d3bf13ae83fbd48700495aa2758ad44322c9175de366f686b7416d0092a594300b788e6dab7e4245d0971184e9cf220232f466cf4585dd5ba9b9622e549799c2b49053956961fadeb890f34c84ca32810c9a8ec0b35bb4fbdaf5086ea473ae2c842ccc2e9f25ac2064d2c054d7aefda8b5c22c14941085e0091500f32a253377612282d99828b76d5dfc1d8de3d9925ea5f1b2d79ebf93404eea119b4b1e09586e1af298fc7aca469a44daa3b4cc707605ef8fdc0424f88bc08d5ffb5a0033e6ad69bc4f75a6be36417793a1a97070944b47f0dc987a4b5fb9e68ba99959101ab0dd73b3d0ff4d91d87e3c54d439b9ad2964da7d54f673d9653a6f11c04e914bc0e5544cdd5b63b4f7e1a3f8af8acd39c194c8311d66f6557e3699fef5014b8b351ee1e552c9bbcbc1cce4e2f579ee1b637875803506f47a1faaea03305e408df773996cfdab848d271325aeb8e05a016d71b59f2fbdea7851e59d7a610906c60a07fa36e7e15886b23b5fe50dfcc16a63ecf2670b1b5e4e5ef6cd559bfd471aaa8f4ed8024ef79310ffcbb89fd85a34c8c08a6aa86c8e3168a3c2e596388f237f01e9258dbf389293baa331d711c05051d647938ddd5111e40d49fd34afd47f5a9a357a5e2b946201ecb7c62c70dfd9a451f1ccb6025f94bad2bb95b6b9d29ea8a346f0ceb40ee973f110d6e63a3a0969cdf6ebd577174117cf5cca65c0dbcb54c9d52b4b3a770346bbcac3f627e9b5ffea0f41f2252be2c184071a58ac2359f4182b54a389f9bbd25ec68c9fc426a3ce230fec3adf89f68d9020a719a66c440cf0b9158d5f486beb9b93629290e1e2e31c2c5f445b984db038c3dd926e6dbda4450d6ecc79cfe3f736e4b34710542a10754c2914fd5ec802b5d9910a59e4e90f60faa71554ee6f9b40cbed6cde179a716e8bb7f7c871c4f7a63f1560dd3fb6611cc4675fe90779348a1abcabc19dbb7bf03f6b1509f9032faa4676ab4555f316b40e44b7c066223ae9aab7b552694ab0ab6224dacc363b6e2649ba8ce2c2386c5219b591743cbb1f75492c37381628f426c803cd1e2f3dd101eb47d1535b0aa1ffedbbaf4264c9c1ec227dce75b4cec69a4340721a6b218dd08aea30cd1eeb01b09136052a83bb9d7c692feff3b01ab711aadcb3d1ac12748bafd2d64307b90e9333ef14dcf1bb686961e24a64bef56ccadc31bf2a55763378996c96ae758da834b25ba27b6d014e7c8b504eef459dfd40795469b444849f221797316b5114df0ff4d528971c430fc62e1d5f53f21f51098095507a99ae6bd64bd9b715760353b43e791cb8fb6c2d9be7c06d58ba59526bb46ac02d50cef669175a01385d4f2ac0dfadfd6867501e0c40dfee41d3935a57258063f82af7c84bbf46f3ac2f30dd08c4ceab0dfdb94bfc2b9b8d0f108909087ca7e58a4754c719a6ccd38aeaf9f072b38bd3866845517dc367839c084985fb32a924c8fa187fb590c543771b4c2605687956708b3297fb80db37be4bc54710363a84071e92501ea75ce3739954b85473a6415e53753f780a8ad15fcb82b114f54577c22fd7add7698f59c831d3c885ed3fe02983e6e0aed506bbbb513beb1f7b64bb3b3c06e1c463f07445523bc7deefd9b80ef06dae8845daf07865e4dde0734a8813ff647d5ab755625982ef68cfa5bd506cab29bffa50d8c6d8717182b424ce36b6e90f1f4eaf14620909bfb8c5ba6b3a337c2380ce326d44a2eb58dd5faf71cf424aa24c21f8e6798a11fc44277300ee446d8a6bd8f220a47fd2adfb17dc86d0c7cdcae95db773fc8cff45a54af15e570d3f0099edb2d50df1edeac273a8bdfb31fe04f09fd694b8efb6b8f686a4fbaff15ac55e0f67919da1ebf91dda9ae014be7b288519946fa76064e48eff11e7a0110f68d30c39a35cfffd1b3b96a00103e222814da58db32da94057ca350149007473c90b6750fe12f1a77e99cfd56e5bd61c41740a7b5562bf70103cfd0db6f1b9601bed62f5c9c4e37a407bc504d6913bad65d1cc2db90dbc1547041974b3ca629c11d44ade197f721490c60ae1d662b57a8ac10c569be96053c2fe780d3ceed95c1beeb525028c2ad5f5e8256b80ac8b91c752cb8ef57272dec6d554fb4cc1507756e29feaa84998cd0a150389f93d08627ad9053436dbaab5bb75c3850916cfcd2925bfff14e6ac4011c6d93b5bcf38abc8b614952140c83038b8cf5c28a5cbbeb837fc8e6dc95078f4ecef719dd9b5150fe520858218c54603bd533fd41ff2d47de96db286e1fb06f166ef8318fe984e461a5f5bb2066b7cd88124a3d5c8856dc14e364c6c13c4a0407e90d1a21ee2bc2d213238acc52f051dc3da008a316ff25b387310810a66b2b406aeb2c887f078ce85064d6d11d02079e8e86c20ec577dc022a94c7ffa2638570ad00cb8c7435c102329301b5f10ed426f6fedddf9a2b576585b75ae6a4883400f943d025edec509f4bf60c535ee8b8bf906f4ce03172df1d56e6eff810ddddc900a041c25dd9cfa69eb5371f415f1a5e13856cb86996e538784ce7ba364087cd84eaabaa9744623694236701be9045430d5fbfed1109d55eccd232a36b43f5128fffdc71b6b24f5c3c2a46b29dac11718e30c3b95f54913c093102e557a5538cc705b542bb24b8aa4ab52ae03878b68f30603b66e608287ee3a5edcd65eecdaeeacfd02fd09edbdb74bcdc8fb26a96723a79d23b591c784a7870b6df4fc5721b9bb6fe9ea362e3d24fffa2671c95998cc56409125f42a2a19c662ee1879ef058bbee3359265331b55c8e886a4dd2f1c7684ec3285f3a5193d57abd959a6b5a21b4c509466fc40913984d29e9419cc2b75c65dd4d5d98f076499327579edd6658aafa38d9bad34e90d88b73cb237f64b9b21828cbf9a41f473fdee75b08ca5e4f939540edf9796cd3ef18f904ea9f41f53d7c21a62e467920c72852da212f3c3139401545d3ad4587ae49e01b35eee0cc8805268119f6104c630dc9a272cb0636b61598df7735baf7cf5ff7b9567a9afb51df77c835a04f5a301d1d270a7f99dd6dabd0ee016d44fc48fd1f939858966052b1e749f07140ed363dd2d76ed4ea89099450b1b91dece5e7114a90617b47e3b2b986bcd40d9d25e6b1e73f061073cc1fe40bc144348a1a43afd16ebc214491c1daad8690d62a573e70c0dfa6b0db2cf8df92786a56cb7ef028f616b7bb076f4d4e01b924b3aebb2b6cc2685a801e2eb1c63f0ceb4a5ae0eb852ff6a4759f579f61a81d2a8f0305e757b6513c62515e370931c70e9e17704faf6e99db71da21f177ddec63ce206d195c7912ad8311407e7cb70e8f62e898b2b8259df69ccae7c31e84d7e7367c386956cbff0045cb28fe3aeb569a31da0b60570446442c38d89982a2744e5959db629775c038a86d0095eb86b46eb19f9d95414b8ac545c5b59b84fb632f955d34b878af954aea2738add8d74358e8de6dd5d114790ea668718f51dc49698889bec6553da0432824bd0675ced6fe1c890be968e66f1f1aae8920202706ca62514ecfbff91682bf997e52b8b48f04687a398076d83dd1944a0d401b07a366e618dcb3afce6cab4ff9a0ef01f16f8129317424fa0d204bb1e8e5ecd34cacc8c12aae92f4aeb5a2efeb8ad4f4412da0d04485deb0143f1a98fd541ac3490a1deb57fdf9b777cd7457bcbf20f2c8f7b0554f26642b1f73cbf9ac8958a2b3ec32a8a8010b4ffd18461527e262b05e1c5cbda02691d7ac80dd2fd1a5d36b80eea87a292490b11ca8cda74d7cecf0e78d8a38b9480e27557155e6f42713af320461350b5342b7698f84327ca08fd8a34dce985e8565b9eb933cb8b7241905276b37415d5a56b8659828df1358c7b0ee81c15968152f2953d8abb15b2736fa0cc61100e6355c7f7bd13a6dac034721d61f3586aea10823a9a25fd9d84333c90b6d76a235e6caee5f24d35987244fc1267051420fdfbc28756c5999f081a71efc1ad5470ad6b8d715dbd63ad00c3640817f22a6699595f81a5d602708ec5bf0f478abc539261a71535d94102d867eaf00e84d529439f25d1cce89f643ba0c25f0c15053828ed404666d30ddf154c98a3d254c55ba8bd5351122fb6819dad94fb5c9e9393ce2e457874aad78f30c7ff7dabf27d5cd0e7bb4188668c57e6580cb28bb65851d04fd7cb08f67be72ad953c2c5dcca14c5deab455b813a6411de0f9ecccc12f0285dd7f98109b7fa5028d8c8db354f33982ee645f1d84e2276e17f551f2b736b2764798e0b4be16bf5613cb8419dbfdf620418f8437f1321ab3a241a0192accaa829e4cb5feefa19db11e43e20e1c2fd956c416b1cf840a7201268752fa0e7abcd50aa98621e7f99787fd42d45587ce85e864c5ca26640f2d3618e9b7ae3368d51d24f6b79cc63aacaebd4b641f3f3f5cf035b9c6afd20db8c77ad0fb1de4457687e6bbdd3ef33427abb1d0df875c16a762fb36862b01cecf40ca3d363b99f463e067d6a1a62e07e09e80a344da4f67dbe74696bf399afe6cf0b30b92dadc6a58903b26ed2c8be009a5ce0677d307af0f59e31d0eb52fb8452acd9ea70834694d3cac331ae3886832a794b9d893fd93cf968780f5a98610580b3634ac6ad70fa4f1ec3d941a6da4992d3105c90aa3e6ae40331c1f0701ca05d957fb10aa09d89b4769624cf22b5d5d1532f816fcabc214bcd593f69a0a9d27db0b37d4e86587cb5cf14cbdbcb7931986117dec8daf95ed4ddc21e8183de2eaaab3f6a8df5d8be26aa697c22bb4f9c68e05f4e30db47725ab61a8f0ee797263a8841b55d5ea2e68c674e9b48e5ae67ffb3e581960f8b06141cdc70ff87e8b97f6934f5fdeedcd92929339e8f1d2741b0d58cef96b88cf1e0e698b38acaa6f5b93162d97afd28aa251df5bee97b35d6e1863ab45da44df3d56ed1358cad0e4187ebd83f54fbb7cf770660fafb7afa44df7d897e0f4dcd9e36ddf00158ee1d47277af3c5e4de52fde81d3cda0d9a765fd28fc4a89b2ea42ef3c68d654da5c27033fbaf39b50969ca2d0ca4dfce25130ab7651e023e5f2fd03c80e47c3ab23724a06abbdc0df405fbd95303e3ed5141f210572f7b89367de36d2d276b622cce8d106e405af4a8f1f07b21cd0a03fcc8b5034a7d4c31bffa6186d480f82a262a3590df4a4b3ce21ad9624d59f05dc6976781c678ce8f0aaa2b681f93c46af069dd92c49b1884f1126d7384cac4855ddb4afe9bb09664eaf64a200668aad65332615831cab0d2aa06b88e6edd8e7b5b0c3895130085f1a31260ba412a166b0960d37b8a22780f7185695663ff67e4712aa91d63af985588661a216f84d78e2888c6d9d945eff4bbd80f6bc9f9bd2893e067049d8705f3f1cfcf076a82ed301d7ffdc58200c4d9457f53506dbbb9bed38add76b87d03a12f79720b3f62225258abc9b174c3b1bc3ec926c9bd6bd0e9d5c7010340012ff6bc71fed3df886e023a666257efc1f553c509ac263adc9adec4c3d7b37924bbe709cfb0d0b1862fdd75aedb4c5d7437281a83f3c77eae8ab3d2dfd952da1dd219f09f3caffb4305b81dc76032c228951b501c6767d037e54e91f18abedcdb10951edcd4b494443ff37e428725428fe753be05a4277fc5f946db82b90ae0d21b923028064ad4190de8c6dbdc7c0fa4a0a41b872979a3aaef9d2ed260409e841bbef7af5a7675f6a5304faacabb58d3deb154f870157cd4b8d2d7c3def49594b8c60903009bf6a856e35c990935146912ac8c51d6953a498d660bff19712fd57df1c8c793b0f82af14c8b1a3abcabdb8e71cdf74861001172acb0ba93e4da69eec18e29ab84b82ae3eed1a4c9d8b89a117c0a7b35c2252391625ce67be93b47849ad546600f448dbb6f21f8a19b3b3eb4a1c45a87afa61df96f2605a1fd0123fa181e0f36e17b138d64bbf12ce50729f2a986a4590e0bc95d1f302a822d3badc5d8cb4b84780f960674219fbe7e4baa44c38a2f1956737cb3f77071dbc1b37d5b62dbeae2c238b0d327569e1a9219f929a01a4f3ce42669a1fbdca26f3c48f9cbfd55cd8234409fd1d25ec2ab475874ec8a4aa5a0c69addc4d06de4f2225b85c4a67db16616dd9cd152469f3523bb24a317ceafe1f841bc53bad60c8946206bd6c1c31886090d05d9c3ed2080ccc9f6734b02a361ba2fb91439fb07ed72cb3987652848a0f8626dd46cec3f70edf2ae50333ce1c51cb5d15fda4447188b8e2e367acb9435c4bd300ee9140b6ffa1d0ef5f0628bc70871139771bb31721d5c5fe6266bbc1db14ec7adc382d6e132b13148f2d9eea3531d0735885d79a74cd6259830dc336a6850e87853da3f92046ee1b6abdb7c3ddda1059f43703091e5cb38f8c22cca574ef695867be5f8c4cefd9e7f8e69dd0c0d0ecc0b9cb92c939bf84e371aee79a88559b7d154b4700c52a854b58de934e9441e562db243317784d67fd8866fabbf6c6b4f8f3bfb13cb63912f2122c4a91754724371bdeede6645af42107e2fc87993fc49e3eb604fe2234a62bbb418c5a15fdb0f1327d215b588057e6b4af84a8df7352f12e21bd0ee28721f5505cc406743e0b89abbebd7aaf5484f685951b8d8c1ed0894e78e6112dea25658cfdd23feae378c0c3dffbd35c58654232e1fe93e1442e27c526d24e03fb1c01e624a89bbff88d25e8197dd6822aa9d858603633806048325506944b06a2e4089cf88a72e75a5a5bc82206f41fd181a71887be3f562ed2679d81eba38efd3356d3a5159b4fea6fb29c6ccd5bc57fc8ba7029fdced12e064ffac8b103ae47d99d22a6e4ef35fc035faeaa2099fe50e1ee7d1d3edaec751f2d588eb7aa35acfc391616b5781162dba69829d1e17ead00698237be0338b1cf480e3de4393ef5556d31d7a14355af1b9ad4c50f44859a9e32c29580f75b79d52335a73e156c21b749913170ac105d1520f51e1e799102130279a4cd7596f63e5ab7c21b6fc0a97994a05200862dc639388e2996ce95ce6fd2212191ed095679fe9d2119543909f3bbb602a8dc8f11884761bcf5bf209792e6c2b434442fffc0c8dfbd751758e47718cbd58803995d3c0ce925d1f5a444c421502902e0a4908a707a4914e9cfd745f2b011509f7c9c983f360f5faf8a395993cbc0213435392e3439ca7e4233c3e1d6b2d8ee3b5de92565b1d9a39bd4e9c81a1480c8220e06d52dd94c3ff85314ca8fd3f87b84c461d37335b4837dee462bd1d6f43244f0d08dabc34fc43d965026c1959b54f8d6c460a452de284cc53fc2b4cc3f9ceec9e2c07b6e22fe1448f7f25556084c9b56e96fb27a979a70a7758996b8c8a1c44e9bbf4c6c89f8cdef5c2670671f1d6be82cdea1c31e489d3b17c3e281e85786c6fe32e5e3693a5166c1b7baa2746f37a51074a8e2ee1b8105035609d069da7fb1963d7d27b061b1e3450347df776611f72a1f3999aef0c737be518c3fa97403e543e0540a79a20bdb5b3cc7aae6071c0859cd640c5147c71e24fd949fc28c9a0f2f86cd8f1d9aa26651ee31e76367161bf3829d1f4cbf60a21a12c5ea0c5df71807204f1fa854b6227f7bc159ee3a642d00413dcbff6566987fcff2677b1e6ae196f0071f463d209dc07fc641ee3ff0d77709c1adc56cec5c163e3bcc8362e6866857374c818e3b5330756783fb81b1a11bcf94001556faf89f17c4608f45bad87cd8d11d3261f4df54e2b7512fd64911123a5f3e41e1e4ff76223b00549a80440ec82ba67007bb8e6da8b4bc0c6310e60a2457df8e4ce19a055a794665a5a37fc620128b4a5a2acaf41a1435605f1d4c9797d37f2096457513bdb44cc7a67b0035d28543aa6ad1dbfad813264822d32e6987ffd9d49a3efe6713852562a18b199b2cbdaafdc370c0b87191303cd202143d46c6aa5fac409ab62eaeb346a3d08e3841a76edc1743f7c6eef1fa04eef975a8589e0d0e5f79c9f7e595103e96122843c451f0177950807304bf9e91adfd7490f8bbe2a1c4708dd3b86d875648ba258411ffaaa6a2ff4d3342d766670abae7739537f558d7049b95b2d939d0b84a1ffdb38b5f3ea006361960f93ea1613d3e3319060f764a0beee4be7b794343ae486dd0f096df51ec5bc5f6af6003ded79889bd9f56898eaa3752a06b2b85bb19cccbc7917ab46119fbb7ea1200157ad01a742ed158714f9cec19e5cc5d105b8c6ef79702989fae4e42c20329d731b2ef6daa461b99c64548d5117212093d1c24cfb5a8a44623ad5f61c770eb6a4142de62bf031a7f7a97a9d50b3c3f056720b8fd4fe730227b82fc233ff35c315fde1b1f029d7140ec2dc427602a123f2f6eec274765d125983eb170111c57fe3661ae9e9040ce5fb79f0baa309eb204677b1f2a672238aac8d8169e5c03b9dd78bc8b82db0422d77c3c1ded268a5b1099e8788fff93f71051167e1ab8359cb515310909c5a89314b23cae32532811448235ebd46dc0c1531a1334bafb75f009e7c6eb81149f79005c9d0ff13d1e1b1631ad6049982f8b481a71983ac9a3609acec83cd94ec8cec0d9cde7b6684a2ffcf413760853e70649b7a345d2421b1cf60d3341848c5c4c9865b998769a9b5f22876618af2d05a11feac5a95d441f465fa4b8d49d85c923d2cf484a4c08432ecd66ec7ea681d40da5d92ce406be2b1ae8070b839effbdae3c34a7575792562c2889a64a09a5cf9dbebb12ce59b6a16c5d13179f73414d078fa39edbeb5f75ad4577ff619fff159f8a068f70331a8d1cdccaec664c6e718e8ddc78fcd15a89d42fdd8700f5d26f034ea47d0c183f67ba46b18f586e3ee88f9ace8031a49b2d82ecb5a4641926a8eb8119f15ea5ec0f643230a2e8de0e95d08a60bd1b183cf4f22c2f993e298b53347d2a065a77ec15836a9ec1b055d60687202a6c2dcf477263134a7429ae96554ca5662fef0c4874b1bf9cfff84fd8d6d8d120e0569418b42e50b9518c88e426be19477e598c2a3d64ea5cf21d93bbd97710c26eef0498976a09c6f813e24fa24ad1581d5f8ed39eb317b68f6c91c276c7b8157c9caa60438f389eeaae4ce6ac0e0d0c7d785f4dce1bb4f6861c0b0663dc54447bb17afa4c88d5970e79ee36c14e4b3d0c6bddfa4064a11c4805e52ef882d6b6a3bf2d7b276bc893927493b967ebf435dd704c2512c0c5a90f6a8c0756dd4d5261902a4f64521706e5231abbf7afbf312558d2c79ca5fe256af57c9e2f00b83f382c15ecf6a0c6494f5f272418cfb3f3fe80229a056b6024923e9a1e8a634ece939a53c2ed86614142d99316797d8bd68431209dc72e564cfaa585ab07a952121c2d6f6b502df7b017949a46b1b2f433cd328991689cbf8b37a4ba8ce7e37f83de496da62d23df498fc5fe6ac8b9809f4c441404cd5870580cd6f05c07eb6f130c5fdf74bc006db89f5eba0809ae80154d18fd1e24e627b9530fca3d46d7ba32e9703cf96f571379f2b8059601b37b17a9dbe2b0c53d29057568006d685f2aed6a766098921f855a73d85f4e835a3712d19d2b1190954434c3fb5772764e805d90cce59cf0a5b877d966387de32a59535ff391c4fcf81d109afe1d4465429c43a928c260bf21b5895b8d729d389fb4b703ec648f99cd1b59d702e8f5602bb132a12413d4b9185ef952247740442275ef4be98ac9be45aa518254bf788238587cae7e32e56ea355f4799468ad2befbe59396a6ba9e33acf6f1c281a5c25e7b2341fbe920c1dd80f43b133fed706419effd6fcba511fed90fa2724ff987171e3ac41360dde34eb9627dabcf14863af85b4cd6300ea464f2e6b1fe04eb9c393fe8d99b86daf09a1ab183bc6939e636609cf2fb76dfd9b615c41c68c4b3045551fdac6ca52c61aeb937949758f6dc4a1a3d2f3b0da931ae396dc61b81aefa6f118a85c258ba2afe15a0e62b233bf443123aac6bacbd2d8528aa48e68c79f4f8e0ff2eb92979876b2455a31bf7e436a66082682d9ddd21dd075c1411b70ceb1a5f3b34668c871d3e1f5669eeee03e251d31edbbaae335430c0ea40180263dbbfb5619231ea8e332ce8e931829984b5d52b2f17c3858bc3807c5909ce6c7805fbd66804d7807de0d15f54f831057344ac4fe13348ab337c39eb8be4a1f77f08900cd71f3b9dfc7f3e0e334d6aed19693236ed41d19c6437d5acc8c6d0531fcea1582c6a8eb7b2aece327617343769b6d12dc0d0b5c1965738168821398d781e4b613faca10a05c24ee3899848a5ecf6f96ce0e46596276d715f17ad2884dbfd1f21a0935ae05d32f7ae536ee166354999ffac793ac710073460035bcf6cad63256e4e5f6bc6b030ff48509f60db578d76645213ed75c885625ef584cf4251da1abec73a2862ea676ca116941a1c90f1c2f0553926a2689b20cb10f2ee8fcdc0c60a495ddaacb648fc76fb08aa25e8c43cd6ace1d35d800f92095b3c731a9311a61f2e7f8473fdd1e406835ed2800afcc5bdd454155f3a35696f8393a8c4bb0f8ca29a208b9030fc174f49c84bd577f5351e1063908d93a5837e618e86061d3a9e811431cbe02ce47026e8789f8288fa0e6b072a5127587a5f7d2b2ac787b385952b2905810b4f65d74a0e9b7f15724b1dd5f82e360525718dfda4b291cf6d228a14e004e4a317f4dda739a5136f4af2e86d18942de1e1ae21359cc3f9aad8fa93c19d5f6c00520473709e7b2771d4829c7ef79d3b02d5bab7a02494e62c155f8bae22ac123f4db4f37164ff92d997c7c11884f896494de7efbe1680c0d0e6065d331eb7d6e7ce14b7a7c25530f4444627956f2f343ae4c1d2f9c13c7ce6b403ceb2c60b5238a34219c4e7e023388155fa943e5e3ce49be161b1733e36af95272c3f2e6743751f948f963166e9600452c9e236b512febe502a1f788870aac8bbc32ff7aded86ffe720628ef6c69265fc738f1f4f4dd2358094fb9c9f83e24c5258c14ed20f5071616dcae8253a98847d9e56970a91097ae7105174ad713fe201cbfa3132805d1b55aad0fc0e63f5ec36e1cdf143b04ec43e45478bd3bb372740e325033a913e5f7808f7de2c71fbc9645fd427765d8bb6c34f8d3adfd42c5d6a57037d784f9e58d2a19361f308673c37e4f957cc02f691b0f52d6bb687c54fdc0c8423425860ac18bce002dca40ecb3d0b51ad50593f8c804a6057dda487a4b47057540be7068342c781c95aa89c2374ad0bfc43030d663d15823b7c48ea0c2e2d76dc76936968e5a39ff71da4fa76d7af93a1d3979a91d4923c388550f7d7b9bf11694a312ea40469851ce16e86c27a79c51f9daec447c3fab76958c9b2e7e3c11871144f810119e10b27b948944b302830c1ce8319b823ff9c57d03be9d5107eddfd319791b09bbdb9ca265785fb40c547f735e02ad11024f9e5fc50580a262070ef134777ad684d4096c5cf733d1cc4c23ff3c167c67bae603a3b86fd4576ff9e783a32c4c73f39d057487a2da38a05c2d56c88f9093c4d815887602c91a2a2fa10dcd3a3c0d6d4fda4814e49c02012ccdc817508c1cdb934dddad3d6e6fa003b9314ad18f60563f1e1a244e1983aa72262f74dfea9ba6f3339b2e7416412c263bedff447728255e5223ef95cc94a62eb4c327b61cbdaf5fda6efe723fe9145c8e62dbdef3dccadf63715af931cb7087fc92105c0d963667a897d3dd24d256785c64920f161b9bb49f7bbed3df7173e914199a527192bb787047d55d521850c2212074f7e5d1a24b340d0d3a679c7d3f6d72b916690a2c073710a706b0bc632b4c68fd0b32b9e1012ec08d424fa890a52554d4e0685ca95055a7dce91531404b32afc5058bcd79eaacbd12bc369feac43d009a6d1030a15846dbbbcd3cb3e980152b98a7a6fa64361fd7c285810d36d8b8cabf16d1f2336c6951da8be6a99461f54a74d324c262688ed8c5d9037f85951929dd8001599ee4fb1ceaa6baeb956a88c6727491d8acff2ec08e44b8c3f88b82b8bc1e20fde979951593f508602bf618776f8e92d6d6575023592792923d4fc026688e7e226b9959a8625c76ef8e31260420fd79d0d942d8ff43cc6b14396ccf229896add67a685ae0799f63951578482ced61202ee847fd600a84d1f3be6aef0a32f97864025339f75de09cd9536ef2db939b82b90e747cdde9f1d72f2f34003b1916d844ccf679704687fab2a5ca769575a938c66a178d7f21fd477fab46adb3d4b6e8ceaed89f4a96977ffc5e7ee59efcf0cff4ffa9d3317dfbe04ef10e7ba04131b3d50b4b15822d8489332932e041079047906c9e5bbb8d312e241e72f14b2ce23a594dc2615f1806df185411b9ed1645283a974e4cce86206f67d47b44869f9df56dab6b09ca18bf89aed2ebc8b99138f7e7fb64b6b122dad15abd8bbaf8b48bffe776452589fe8175fe7c0630fe5b41a52f0085ce9e560d878049710d59da0fb3bf7c20b1d2693eb478b17fc85c400bd997aa70e9cb477d5e6f97415ebf6f8fc76b54c697ad5cb25f8194ee70790721a45ea165d5d18054da782fda8abbe96e806e22e181cbca35a315675bdb48e4db2d999eb85ef0d23d91d0285e92266456034d6cae4359bd608f863421173446268a18e48cb56e821c89a840415c30fdac52ff197f1b85887e6421ffd68e02a9cf5aae10b1ef22e610ec66790269ef35b21acd988fc9e1485232da6c4d8f5946dead7efed3a0011d041d1fad7e428a5747dbf8a2dc3b0e57248b4c6b74bc63fc043a4a7d701b2cc785bfb59bf68d1212492effcca93bbebd8e3a5135d7996f90e2066e1f32435e611e8c04b39bf37e077ac81eab54c6110f3903e4886a1a0f701dd053a90d8ea1ac92e04032c691d60531f240725ef153fdfe232c6907ca8f8ebbc6d5db3fe7ea9ec5d3366dc6394c0cf54895fb156418d2cb43ea344dc03498bc5538d7608b913d3a94f8a1ec59ae2f4dc67d48cd1f22fedc72507c9d73e15c07a073e734133629cf85c7af8fb138e1b71737a24b03dbd73641eee0d197b0ba979b98515aae70bafeaae666eb82703224e3f8686a0a4c5597c150dc3651ab2b00eca58255d599b1a8a52083abb5f97d1a027da7865b1c4af79b078505a684784a5273e7176f614baccead0d87ea6f74fb65fe122d229fb5e908cbe9df1ba06abdb345c2e8e666da3334c1cb81d3de1ea4c69f3508a6d1c49a65d2ffa16a409cbde8238b5125ba53fff6c64ef999c96f44c9490e02bfcd19ee2c3175bec4826005e06d29959a417367226a858a2889350d547fa7882d5426100c4901f9d6024e0f733986a9194b8e9ced73b0f192d7ce23750ec7d724afb061e686147a829221504e3996c4fa5d753656803bbca8da90db9e6cbff4363f07c4e7213d958aed8bd856a9958dc880cc82fcb524178cb403d751b3e07c1497bc451cf33f77299609e13764e0442893e942bcc829434b488e83a81d88be66ec3110c6ea22209dd4c9c766bd7205f288013cc1c580453a986768d2a403504bbf3d1304edbf6d8ab1982f7ea382a4584af49a61dcd2d6f8f56df4d402c669a650960a0ed99810feb0e4019ee7b87a377ff207587bc8860a63a871dffa136faa76698ab281c0c6843f7b5aca94c89ad6eca6af539a62348b54c5971a565d358be5feb4f0d6d2b5cc500f2e46dfd8eac64e782184af9f496409dde199d14f689b283f03a93df8e2e82fea7c0244fb6d9c613dbc4cfab1f831c0f8858793d963db87fc17a8501dcefd58ff32e4ff6d2326d8ba299e6ab6004f988ee00dbe759236b45932faab86f709f57b361c0d347774e7278a8528c2e766e4a23d7b031dd34e770e2df8209402b624a450a746827ae352814eb7053452723bac67d3faef39aa0cbe64e300f432b3d33c6296b71677b4e50843229d5644faff4bc3d2a694c8e3b79de5df929d0aaa5d326dcbc28c1c60112d5a4e89afc22df1ea38a787f9dd49d26851157a7a37855aa0f592f1fd4648e4c047572a5f1bf9f8f500a3ded4806aae87a5842c8ac96ee4b2f2a2fa80affd6fd622977b1e947462d62610d38675e414256a2a92fcc2bf190d9d7f3771d4759e1eeb95d533514bb97c97c49f1e5365703a577780b8d4b1bf31adcfb5fbca4d4f3edb80440aa7a5227988dea150454d3f8c0183dd5cb7da3fcb709481b3f213ccc13fa6887764491efd3c576d57a630fc7ad2ddd3b249d54fc6d5613d227cc3c6d49699ded364107dc2ec9948429fdabf6b22b3b12cd3b30e0d9f5a75eef46274f7d4dee7c5407e8449fd954ecb8e15b7cceb39cc045f51b7c5d66488d33af1e0336ad2aa2366cfb7d92f5d31fbb3647a3ee749b976c83cecb59df8f0a52e015d75e6d90cc5a33e40b68a23d53a81da4b55be0f196cc55250e731e40143221ecfee56a182c9be25c05b3c675910b9c1c9c012f96f37d53d97bdc19ec93fbf59c0a34316f2842e7ede773486f4535ca5f4fe41b1dadd8383224027eaaae27d4dcf54615c58d17c770237ff8b9c4b2c3d7a8d1a985cf594df4f5db6b1640e5c42bc3e1154fcf53c31969eadd16a0f50077f28724b6c0bff3dae710e932fd1ea88fbf51750d6779458b13fdfd07cc0294c5f97b02c4dd529bea6f99b34499062ee649fafaebfabff93c6fbca048d4cd950ab0f2227a7dddb0bbdeeca9fbdad26208d57d9414756e38140a5048ce9604a147ee567766ec0b5958029552908be0df75aad0887c23c371e68cdf20000f3e8a91e87633999ab6583ba458680a02ec4687d12e3f521d32132172a5e858337a3386117e26c65046faef6e4d7fc1e8bf952a1f10c4d66056e44330df41bc0873e5976344e4654d8168cc4aa1111ce9e7c527f75fc5b54411381b50b127e71143f44d1543a265b241c6f692cf23fad09cecf9b2aa60d90efa3eaf600d7814f11991b2baaaad4bf285bb2f46fa6f26cc053e45fc93824e90ab4a04a82dc1ed4ebf1e0c28980343b2ff6b843ef98276d2a2cd4f5e7eae74c291014c13917ff74afe81c6304ea468fe6bc92bc1fc736b04e2ed4fe880c4a9fe6d35f2efb5ed0c9f287a8a2a099cac47c6bfaa48263760e62c51d1df2f2367ef4c17dbd0210cd8b338a045f9aa46f52c133626d97fd19f3624cfd8e9434627e48e2a916e8e57fc274e57a458dcc4691c23344548fc402be6c45ae716e98d8c29e2724c694b811916de70d3f9f82716b740b868327f1b1c18da8af8686733fcad943f6ac12450cfacf0f8a2c534c7921736e04f2976ece02042cd89985e58a2382ee29b8f6cbb48f6a19078fafce8014e4b93c6e13b32cefb9e65de1af26714cb2d30e8757eb60e4104cc33b56900e76211379c76157bc89da213cce302b47120bfe1058ae03aa67af90d506fc9653ed60098bbe8c95dbcfd836e7b12899b88d17ea6b351a46e41fcccdafb65e63c03cf45b7bd71637f7ebf9978054dbd63e8a52f13cd0dde5a74389e60f8897409dd248e7c920f54382ad0294666801c8e6ca4d8c5bbbf9c2b675a3643bedcf1e3578b5252fed63ef75ca46c8df2d0927d7b6df961b3948bd24b9933fbca0b93df76ae84b845d7f8c510981a56953b38e1c0d640aaea15d91938393cff600d31940ed19bd21b7e5bf0862502e156becfc04dc362d3be558fc3d08e1d9816aa18c5f44dffff22eb5bd76fb9eb817b0ad68c0d5e999de0f023ef1b4323a7e9b3be3a0648a59324ae0d303663ebf7cf5e8c7199ee2ae06d59c745e93b1a40bb60f964b0f853e5755f7e2d2476f795484f945fe9d979adee3f09401e0ab103a1d9fa4430eda7b7466cb76b2b817484ea77c36e435e72ba326f0d2b3d80e475f3e7fc40ac483eedd1872c5016e177089b2417cfb577f02d9101091eada9eaaee7008203528f3d2b997d20ac4cb791328b9e10cbe47e6c25810579fbac2b9bdad1403c36324e69d780defde82d4d7942d33d9ddb23100fe67565354a7b7ea4850191bbbe525e97150e6f05769748a063b47078f6e64e9030b98a57b353c74b73dc02033603af7833977bb3cac0092b14d2361a94ba963d715c7dbb0a7eb0053eb43f7bfc7aa8fedc9a1886ad8941d7c6dc678b12c91753583e0166786c66b8816c421c6785e471c20934f2693f6a1895e6794b3b186c13466dbeb0525f96b5d9210007d92ea027524bfa8c7e1cc7970640d5da2a1806485003ccf0836ece57f77f93242876e080e26a3a4858e4e5c1069347117b34ed9cbd8893f79b7e2c644d785b9a455308351ffe9abd2837e2177ec706714bf8131ebe902794831ae5ae5bc110ee86f04b3238c2b9210b6fa81bdaf384d6c0187bcd770525cbee07bf19a7e02543d30e16a89358fe719bd2724a59aa6297f96f3675062c3c8253b60eecf674f8599eef27c7e864167b64011524a0eef61470d7003c0abdf218ec3b10e4bd244ab6f2f070a81d07208379fbb3947c62148f7c6671d1504479bfa41d94ec296245a2d924e1d26e3c7a2c79a152929060a1fd15a0bfe03394d3dc2d83c898b5620352a4bafb33b767813d8767e8ea6931db52fd6da5ad96c55785caeac57574352d537085b750b671d92efb0d7753771a022cdd26cc526a5f2e174b987e83bff26dc8a5a38611f876d6ce4514af5c962ddd73c85b3125baf0f0ad1a98d130336d6c714cc62a7043c9163f1d891a2e07c9ace9a20adb80a2bf187e53c2aa228272185356f7f5ebf0283904f2b08fb1f1f84bb1186804cf1679b6b54f94f9a404f14cbb26132a2914be18651c4c6ae44ad64eb34c3eaf9d7be61b92bed48b02484c65ad242c412ed4816e81122c10cb3e0796640fedf6001d1db104cd83c9d489c9839599d404fae27dc60f6823d1d2aae6c6f64dd8dc631ac7094eedcc9fbd8c1e79e6311dd175d7b9a4bc53bead773d4c4cd272d8e8f879f67c82f6a9b6e96936886a2594bfbad078a9acf64412348f18685ea4c5259fcf2ff24d6daf53590e3adb5f28967914f922db783a7bec7542d39d001c4e273bade7545860aef73eaf348cc0528eb5fe64d3c99cc6939f8cda91f89c90001d57e6c5a9a8d0544fb01e7f22c30224a1fe3122bc179f600716ca45136afe888c58734a1be39da0be562b81217eb41075b0fdc29f3b78fb0746eb22e79d6db57d537c46f49d15c84fe379fe0ddc44a89f11c884d29ca8d5fd69c40f05489b06f3c20d098267a89f9d4856bc75198f3dfdcd8c6a309c822c51af03259fe7090be20c347d91394aad180f05fa15f03b1d3c71cb24e4d0c6a25c83113670c90a30ec5b0dca181d584a1891faeff41111f66865004c4e6c0e250aad5de6788312bf2ddc3694b121959b20037d9af999ea5975744897c7fefed9f34a972035fe90744639d5f267382460e889da57a0351f56ba83ec0e205bac3260f9c143bf11cedf76b083aa95665f9397dfa76d0ef7d76d444e64e71e69b8661911406304dc3f70f9c2a49cfcac8978ea123f5ce046e9cf22b7f83108c441300f55cb6dbaeab143f553bf7c4c101c2a4322eab287ffde589fbc2d954ed176f69fd27ac7c1365883aff9a522c20fbdc9d9bdbd58e0a72da4277387c536be1b892cd231b3e8894c65a699d5e8804a6f120c077f1610f0bee884a14001ecd5d70f4ce16aa254e0785fed44597305e439295d39d9a3b5fba901d1e2c92c117fba54f98a306ed8f0fabd14da8acaa368899ef2e29edd06ac084446e3427ccc2e567603cab5d1edfcac7a8083851fd26861c12e2526f6b214720e63f74b4db61d41cf13b55c1527c09ecd0bcd431c552f3735e638dc702dba968f9af0b65765a148abfb17c2d70b2a6b0dd2f8a47c1f0aa4ba6898ec7e48e36fa0a5ebc0eba38564a8bb091b9fe0b1ecac9d06ec9a0c2a42370a0b868028990e0bb11b687000317d81871a6fe035ceb0946f8203d4bebb99bb0aab0fd199404fb4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
