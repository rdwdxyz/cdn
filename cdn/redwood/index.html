<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d61c2765504c44fefd5a2d409e0c7fbb6ffd064ec555ef62d8546a6680b9d8d1dd48242f8d3d08cfa3afa96c56075dfcd5aa60fc6ec8ef1b4fd24848f5a141480aa2ca2f450e2ae39da89933e05c2bf0221309e0f3d960b99703f40daf33ee318f785d7e28ce8c85cfe209e30d51893754bb2528fbc44a3f98d5b1544d07695b4cfb3e2176dcadf6e72fc5e25e84e8745429500ea042918d4387771e759bb2c61d376f8c614b2cc9f656880b558537cc3dd82c8b9b66aa347f569e69c827825b5ae7c33dfb8b8d3d4d0bb1a17606eb4de8c3b4f1b12e84327a41e6cd85963b58aea727ebcb50a110f60a5d04cef5078a6cbe548eb693939c1d0982710588949807885e5ddbd55a9862d800cd2fc7233ef38c7c1fc8111f9c71d8a7a31d966c4ce127082879e69acecb7b5b44e6bf9bc9f9c368027ae1f6bdc1115519c62d40febe99f1e5fd4852b0331bbb22d65d20df444e9f4b4c7a1a3f01036c1ea74b37c76bbb899bd1c2175a672e68ad5bc31bfb3aaf0ca964f2b68b03a2fa38f63513f936636cb228fb6483655d5c66bb863afb6a0734c818eb1bb36144b67282cec31fbf6e0809400cc59378e09a9ed9188c87d8b929d37c0f9929038c7350294969df240c23c5b76cefa472e153542a350608dc8f90059e91e52feba077f6743afd690e526b7fddd54a67736112c70a3f3ecc0bebc137337a47688eaf487befb83de4e86aaa6686d646c3cca2f39d55878f67ffd19702eaa30711dcc71af6aa999f8b75618a5fcd307b63c91fba4be3476e1bf51244bdcfb683902c6a0091ca64f782fdb4f7e3bf656e83e73a3898158d64df81c4ad7046b31fd9fbc7f87a97e7d48ef069d1c0a84a0a2448db1424ba3686d7fee216b13669f874cf7245c67bcc7acae062b3594268f250e116c614641f9f763f4c0c2fc095090ac6c91eecef357300a2b8327207f58201e1b1148d59fe6a5a793dac4cf13feb4061105c9b421f6d02dae73318ed3e978eac76cc517da78ba39179f04c4c0ba147117a3034edd02714b066c422c8fc85eff00441f4721402b49599dd121c791689f5cbbdac7ca8da0cd20c211441b09e6274d9eb1a1dfecd10e8bb6ed4e84557e29e2b15d662c4b05505ddf2a568965dd5a5e184b1c9d040525e798fde27790eb6ed0d4e4c9abf0340ee211e71e23eaab2e2f8bbae36dc72cbefb53212ce6c95ff3bc268a0fcbc70bce0731d7b6fd42fc59e5eb57d8cd50efda93af694ca1575d4a3bc89b194b52bad2a80cafc128f25b9d624f11edb3c9a1391b859291ee497147856c5a94b802c8a41bb5d47c08174f7d8be6e231e3770b930c38476634113564a86645c74b8a6ad0cb9f8c20300a22f4a2bf4b74e53461fcc664c45f557954baec33944490d3b05709c1b94d74416a16cf42d63340113d007e7e0ac5c9c7ed91a7b52fd4bbbd59fe191ee3ec9b32fb38a375de17f921bb460c181aad2add0753858f77f5737ea8dd5f3a02f4be6ed01a3e98984f8f027b53f2c289459028ead2dbb53c8e6340c2eee43c5e3ddce94ef839a9ca97ca2f84f24e8cc5f82aaa85a6365c13faf0d49418b35b2cf98c1620f400f1cae866e5ff5c8fe36341fe044c3bc074cb344a04d0a6a5b130bfcd412dfc5612b2a9753ec9777806fe6ddc4bd153287f4144ec3c3cb0dd5e3e9f865063955f5a6683bd3e8c21cdc3bf866a661df707b08962aac0b9dcb0114ae4c8a6a52a367dd6f9fea6955a4aae7a531f5ddef5b1ebc2ad3bd3bb4314c93474eca9bf08168c6e9cdb377a141c5c57d92c948edbae8648a6fd72b6be3857d171fef081d45293977c9c68fdc269309ae7eaf9488663828d8c7fd40bbde5663cfee283df7a57ced1f9ead527b49c2446afccf5fe799fbb30e2b793b986f2940b03f2ae78a9c9c53ac1a091ae6225a605d38f1bcf30a4774c1a561e747880fe88a29b9228844d6fd99dad0cb40fbe83676cb1b44a34abd2356fcd6e95f4820a516bb222a073867814d91162bcd87d86c7a888250efabcbc2c4f82f40bf84fb903a945725f0987a064b120aa89acaa6dc30630bf0694e3bed28b38332b21d3f79b52315c453d3d944754d241180891cc1bab0e8c5da2b881acee332d8dafb9bc375235cdafb6f413bed18a4c823b2fb140b99c302ffabeccd33467e886d210817c9c5a3f35f57f898969eac2de45f8f949a6b461abae2eee0b20fe8f0fe5ad6e80e9d9cd5b20c221f720045521aad47b25d25a89483e02fa33b7cd35d1b9a8d375304a1393db6db72add6e07ef264ef75f836d0f036b160f4cd32c30d4b333123269b995008005a125cec7b963398c0b71384b63b38dab9ba5e95d09d62511b5da53eacfc77cb1e16fa6adf9805aa96c2d488ca41e68c58a630e6bc3db8aaf1605a14526f4a6d25918f65d322fafd895b8dc258bbf2a20a6b98e20fc52c5c7708471260c3dd46db5e93d107fead272258f745753cb5f6a996092fe8396e4e08beff868a8c68f946b6fa744760f74f295279e996936fe4abecaffa51a1f48222e25ea61f529417ec1f538137b0a7a569bf410fa07c7789b7b09b721dbdb4e70cf369a6b5c06149155186d9d6fad8e95094106174dbaf2d97a394e0d509be0f2db5651ffbf0bee802f3631fffd35bc37b151621d28ddc7f071a72a9411e33b06f20ddd5270f4f00e6744f285c35123dbdfa504d51418e0653a1b76b3de28686f67474b6a6cf562e659b4a64e80e16629852a47839ecd878733877577803e97ce07db127e2c4cde0c270dbc146565b83fd222af150fb438593d3eca8af25bd2045458305d2d5e59eaa281bd388487f28c58e94a301f3400f3ce8210c93101724144b2f9ecc2f7b034bba7f8d5f9b33ef61c020fbea957548d0f3e7c934cf053e2e92828df092d02905f9699d2ea6f7ec6907ba0f495e8a5301a7814226cbc7d3cdbc285e65a9f22bcb1cf6ce74ffb25f456f11e593422d71774e55717a7d35d1f9ccfbe08cd72b47fa139d02261f8c4f453ab1fea76189eaeb9b4a7ff92540f1f6354376af8089eff20e204bad04798c6136a4405891718be47a572d240d07b6afaf8d799fffc9d291abf567a8c246e357969de55a78bb633656fbd8a50c5e04237e5f2cb867805c7853fbcdec3305770258a3231fa043ffe514b44a0a8ff56dfbf6324f34abd88ccfaa977124bb2d3996a1d53ea909bf07ff470b4c63630fd8ae1be795ae223f961a42e48acb65c0dc5902234538cb12e4238c69ac91a6f597ab02324faa147e96bf20ed1f883d7e19497987f55df18ef2333de9bfbc26db145a1ad6b5809027c035558831dfca3089e95e8c4c088ce985b6a41cb0cf79a872949277bb3d92e0e17db40ef1a3197c11d5c7f79bc8faf5285b4a76c189a7dec4bcd4bbb72c77b83548894abf72c48f7b73591f16c84afaa712f759034759a625b296f36af706b6a92b478bc326193fdab914519997cfba16b437642d10c27235cbd09e61b721a4aaf7fff2ebda8705e2bcd8662548265c83dc7d73e19c7847490fd2906beddc9b35d590437a14e7efbac324f44393ed730470d4b4a9e1b8af4f022738cd77d9ccd06f08e3e9c76646ab25cc549f4c89dd5037e3be6b4e8977fc17bd42098b28e82d2eef596d94d054cdaf3ce1e418c8057795320414e03e8f474bfe7ea339506c690b36313dda847f207b3385bd3c4d8f7afd738805b123e3fb4088a09dc8cab61c448bf94ccaef076344f4ec62aa036709f28e0d080ab4f0502e3c2d0871edee723b76c0ddffbbcb9be7a7ae49745cb2322afbaf5634e5ec105445549ce7c4cf9a04c300cac2f562f7e48bb91685df6faf7eec0274c789ebbf1de13eac75f0b227b6eedf2f4eed02781e71a639c8288230110fdd7f6040d47264f65f8b9fe361e8b18afd48808c35769a926ce38f93e2ced3804f44c61a3a437a54b9ae30e3d901ce971b7e67762567e1558fde7ebed2ce5a92527e055de33040313162a77fe909a3d4a0660daaaea2e32bf04afdfc6a5703f4ecbbfebcfee8573710c84d514c3bde4ab6bb4518ea13606e441432e505bcf30f6d6adcb59e9e5dde38ba11db79aace9bf1667e6ec9f45295478293da35cd95af9e6922dbc93eab05abfa27efda067df1a989ecf271961bcb5967e17acf833b93a798e362ae338d536259a25940d211e0fee0f9dd8858b361e0857c49699f949c5d8e22571ae5b53c8ded74140dae35edf699a0a7ef49bb98eff8e83f6f96965e7b388f2503622e9df650c83b8a52d86242be93c411658449bcee3b8eafbe92fa8fb2aeb175a81c64dfeb6d25d7666787f816bb590e063144e6b7acfecdd80af932fa5d626c4620f446a06c626fd11b834b88f89fc733516ff07b0ec395f8acd2e8bd293ff902a61b3d817c06a835da67ea6fb215149450892dd1930c1fa2be5d4429cc38120dc1ec5ca42e237a065d8929ad2469ea029f07c9efa22c09cf0ee52c7184f89e2a989acec041fc913f00037a6b74807df9974203a91a77d3b05a548b8016b5c29f0dc3d0b2b9acdceae81a4fffb1e2db38c5b88b147fa92c7d953defcaef11f92cb74117814b6dab919381fc8cdf55095df38df9d68ebdaa84d6a42bb3ffe669e0ff1daa705923f6c069b2450d8a79af55893749232b8c34735652e3d29c3d83a49ea48da08a50d3eadd5e0a383f6cba278a6c67a5e6506ed520bd4a7847edb488143df1c5950cfc219d437b0a93e6f88e62d891b0ff0514869499b61fa1e91417e39be598e3c44695385cb2985d8cd526fad51eb55aa04e705742eea20250f7f2c8c4e0761ae92402a2e0869ad419ec90bb2aaf7f95d4c639d170c0dfd5d4173c3ee06fbf7e1fdc4d1140f790c28c1896e9c87abda9f1f3cf1b70cdae43803f1c3425bcbcf06e6b1d24adbd5dad5258ca66159e28c17d9cbeb2b4b4fee38643d8d6dec993b0e190993f41cb5f8bc396af3f0f113b58cc2de00f6b17f9b20fdb60007af72fa35f7df7500c9179f5c1ae3662df3963f4d34bd77f4dc4588060ffc9f1c5997a728733fa87acde339578ca558b2edd863390d63b29e73ca54ed9c3ad81ec68b186500c30334dfea01e66c1acc7b45af4089a0d65a5c68d74f3033b23cc959ce9df4ae13eeb81d4f74266b71754d31ef057ecfcfc6931a989c0aaff2b03ca65896e4747e19fff4b849d3ef46ffd0ff6ce822b7bbcd1dffebc49788ef69b3db4dd8c800cbced04fca19db4a379b3c713188b35d7ab912ec2bf3e3b470ed86e62ccb053a9ae0cafc05564c746a5a93c9636a76b55f400834983f256ad48008e81d4f9bdf94a4189ba84dee4c143b4183cb63747b32b826adaa7998eeb96fd4a4866a13023e12a1608265559c47d969881de849574652cef5f34d8a4cddd57fd7729070da5b5a2abe7635e143484ceba7fe3a90a791b2269d3694b6c46a41a14170891998cd29b78749f31a06c0f729de7be1ad2845c53b0418a9b0ec817d9bacbed39d76c03a2f3a1e5a91f79e19d69f0bc00c1ee107137857f54918a0972a5240ca547d82b9a2fc60cf2b1644d6e05fae9a2cc7ac1e47d3e29a36382ee30a635cbeb0854b8e8e72d3e9d492f3ded4aeb4acc91bbe07e7f49b2f9b9aa01cc6c2651be8d465b62e6a7f1a537c49ea70c04e07dbd3b6833e5ef45d4a6c7aad8e705f050102463cb5f2fce9376139038f6cf29a627c3b4894bf8b9b1773f1747afb1d41cddeef201dacf3f57cbf1dde29292a5b2dc472afcdd665389a7af50488ed2b74a126cd6b5db4cc2e2bd4b7a624b3f432dad9984acf108db28d883a138b9019c4467c06775c54ae5b2d2b4733d3c53b5266f15df8818c73324fe77b5ef7278868d29be89d4e517f12d814421c878f7ec6bfe898f54a7b3874bb81f925f4228eee43e378cfbde47da717bc25685489d7b2d5e19bcb5bbba011d7725f1326144a851d431939f43e8314fba0ecec7b097dc3bd1ac1ccf9458b9bf601991f64321bfbe8342f0867be036529126e28b1bf8424a7fee6d7c2d6845b7280a5b1c5c64c6d3fb2daaa986f5731c5fe27fb9deb7f54843cde859259fd70a6fcc085a14c5fbc9849c4c750f37b976a77a679e6802db411a84d32dba1508d22e81c33605d89d87eb3d9581d0e067f04dceef31d4913bc18880933f26516487a7fa7edce6bdee2b4a3aa539aabc9f3d9574020a3e8a1a708c6821c60b11fd69be9fdb3dd9a6a316c750bfc2c5069da7fe46aff1930a7dc8bea9c6ba1b0d6ae96fe0ba753837fc76987d0463f9cb2f80bb4c79f900a02563b1a195502b33c7ba04350a82d3b172e1f72819bfdb9ae8a92bf3f21564f655ab17a0256cb3ea9cd8da908d595f6b9bbf9e49c700d7c23606c147fae7c5bd572d02ec1c6b970f5ac20edc0b35e932bda4b58910964d5211613ae925af3760bf0dc016d09afbbb630e2183c0eabe01d42aa646bbd76446c7f36ae30aeb12585b1f1c2b57ec4ca28c9ee09450524f90af3b1aa76ee609f87ed1a2184245914d5332336119e625c40f7e49fcdf6bac2e279d0338501f544e45ee1ea3a5d86aa8bbca89722e0c4d460b988ed5ddc047fc007c468f9811df0c0fca08614d40ea9725e8f1c9b6a4418b4c8d61d44208ab66a59db9bf90ca28ee319674e590d11db056eaecec941ddab0456d901cee28ef1810b059e73bd297a15d4da25ddd099f88c5c2af626037200dcc35b0432718d03cd1f35505658b767bb66d765758a1232745b13b7e312b30c12978203da4be765f5606e972f61dd4814f311796e704b29c380a088095358d5258066fce8403cac985108795b189cbeae3f7fe016c7e94d0f6336bcd8d2e0dcb878f0f5400878937888b3f95d75e4d63f58204497e58f9413bcea100185a4d1f38e1adb09c13d7796266c04c8582c5655157bab4e8d09dfee8e7e6841c084ae68896dbffa209085b1faac2b3b88115462e9d814b5f175ed278cd93a94e273a0e1903f20b0eba4f4ccab9e93bef1b07aa3db52cbd092bc91febb7fa142aad960092230ebd9935e1747f5a6ae3e597939cb54dbbeb948f2fae1b52e9300f4deafb56db92238bcac9c2dc0b5514737ba7ca6b660add1817c2b5233cab855d4df6a4af8011039933186cff31bd6e363be75585d07810a51480166b450ca8912944fc49e1ea1b8efb1f1085d65ace7d727fe0ea70f52d7fff1cf9a756ccf7e722e8f0ff5e98743f779b88b9a26723967db3e5b760d2753299cd5cac9959dba3370ce713469565a44cbdcb468881c578b1326ac2cdfa62cb84677f2b0a8292c7bb5409b3022f318dee3df99e01752c325a7e561e66dcaf2abfb5317e76b7deced027f822a9a7523e6d38b501a6b63ca0ac2c5ff1fdbddef8fb2c0eaf9fdf43d8c1db5513f8d546ec8e64df1ac48934830c1568e26049419dc3f982d89f3b9772f8cfe0c8b85a504c373b627cd73546cfcc69fe6753fa7f69cf0968e5f4b091d5def0edc4ad21ca162d2cb58cde38b424d4e79f5fb7754548b47180a92d138076e0779ec9a58300f43e6c5e2327b6affef3b2f7dfc07cd354b09f05a01ce1a512ce8367b928da278d268838886e62817897242f042e5e28b2359b8613d9739d9dbee90f3282aeb2edc922f80441de54be48e3ed95eb1b956526963e5d3c77f532d4d80d0e142c65929243ebe4c89d8ec567e0741be18796dc858c2ade7a4c4ddb8b7e82d20546159afafcf26dda0db3a391b3262313ddf8f701fa3e3f9c0353075cce9635ba8e0cc85362c0d0e08ba84c0585df9835a69f0a9e5c379aa33878dc4c8c455e5acf6c1eed1e66e3f0e4301ee98f0ab9b8e6d5bc6474072c0d1e0ec283efef3cbd5c1d69618b4dc758a8fe4896fb98e734eafcfda0c501f316a2866c0e9b08440243dcef51554d1b3ed09f5856d2d81403605b05fae0f1d4112392e001e1bacae1dd9fa487aa242f92a0edb3d727d553eaa9f02d4701a1fffb179fd2c94fa3302906c861cf92f87e04cee88a43b9389616ee097c48d638beaaf7dfb39144337b075c00af24c030cfe5334f31ec7dd0c67e3509d9a528c86a5e185bc8fd95bd78883fb621d785e3ba6b115ff6a877cb4330e0a1b2a619a08a8aa1a35e7e6a0785c8f45b2d79e8c7c1738cce9455748dc942fb52b6f039f132e6062f81acfde27255f1821687006f964c7aa76a5055ed994aac792d6de2c0841e09e43722de41de5d943708f314e92c017c859bf83615d45e31ec6cf3f9366ad5a8c5d4e09b1c986ab641ef35d8555def63cafe7f899ce320123bc8e8579333d294164e8953f3dd54afbf0977d4cdb0a77b3d63ccf91225287cb8748590e42347d734c6f7209c477c5f21170ad32e91161a9f5177e1aa946c2e7e7d220599e191c62b710ff780e2ad7cea7b8adf035621e74b5944d3f4d3532fb7b5026c03d25a6e2a4d938ca3a43d4a41640358e982fc3e3e25cc07ec4ad0fad1edc1e2482b96bfc2436c306a01b7ce640cc4e4cb4bc98276c8e243da5700e3a0b07565981443cc1c4e002413c3766bd164e55549e387156cca3428da49a131ab49c0293a53cade051c60aafb9c4748a5b8c1a47c2ed0e25ac1a66cd94a8ee9bbec0447f4d347b60b1c8c602c09dd1a6e665a50f1974941c0e52eeaf95d5d8479b4cd2b2cc38ee2622fd47373d2b76d790abb8a1dfaf2a6919fb4991fc35b72103b86b8214c4fb6db6a8ff653b5a7a77b49c4f7d6a2a359fbb47ead60af7320e26ed2608c2fcbecc316eda8ae3c50d53bc5479bd08dc73bb67527437027661466bc34738b981facd2cebfe2d22043c3de5e0975be7c16d26f314ca3c8ba72ae75986ebe7bc3df2ed19b9614f5f1bd1ae5712d1a0a1ae57ddafa2d6ef35c105570f2cfcb755b25c2459b987c459caee895d27c52804af092dea2a08b9765a00a1f449d5f9056f773006bc8a766134cceac680e5618233ca9d8db1416b1be7a1de9d4a9275e8b41379572481cbe5f123bc6c79c2f5fc7d046891e25878966880b69e0be5640257a14ad9999c49ff645562bbd24648ec5f76b6f24643a25363b40f685e0900043a524b60a136d5684c6a6e3cc5da531a6254595ca6277ae49a1f02ceae49760b2f18ad69fed14549348296c201a4a2d6b3be55a6493cb2862132117f2dbf1fb5a10954179ac47d06173205a2b790da18adda4c8f16331095ab77447428d37d47a49f7fe06be73bc303b5c88105305adeed941d3b899b571cbece180de849b6816660ff9a7dd1ca0f577cef784ca0889e63179f96e052bf5d00afbe9a7e132321e052cc58275193f9557a470fc473949db4afd699e1a3e8977aaf9d5e37bb4fa2ef84600a4fa2c780fe73751db539159dbf6eb9b26a92e97b0fbc04930fcb805f73ab373686638173d9ad43f40aa9eb1a3a228317d526ed59a58be6a12775438afb76e40f4b152db9fee3cc9cae98009338c6ed99975817191311afd7409da8849d9ef8b36a36df5ac11ca4c7da35b4ab753640d03585950a867d87869fd5f0dcd7d18f8dfeb6bb175029c347c6ab73217567c7b5716bf0dbe758e0347443fcfc1d51f92c3b1871890d3d282ccda55d76d330320214d4de1e11470012e023e3149fe8d745a50fd3df6b3ea9e410d54e7c64c6a8f556a3e622cb7fd0fb1ef8607999a67b039c7ebdb73c7e072652ac595533862ffbcc645dcd9f8d8c6067eb83166a2d9d7b3ce38609dc9a03e75cf1a28b248d9ddb55e453df3fda84d6a71c2d101192c4207f7d20591aebe6a92bf3584eed7f743fb7d911604051d536a9d915632f4cc7eb0080c8a9ab0723abb3b3c3753d731ba6536a3240e1e860e0c66d7736510cb4aec1d7c9fb543e63e56d25c7a6a54f810491dc7b7e6ea46b7b0b41f833ad757095d906b616fa2488adb9ef1c63e014e1d2142a714777e5de5db5de6a91abb0f07e9d2c664bf401753c0838d24fa5091d07ece5df7e96433203993ef94d2e8b3b66c92099863d43a71046ea6b81601d8f95b69e98647694d573b521ba6a1193e4930503c2d1df7e25959047bd052cab3fa323aa02922136654031819aff1aa4defd4f41bf2eea688248306f6c6eaa85d4703558e1be613fbf576035b88e37fed84c146bc516b1033fa7b835cd5ef90fd10f292437a2141e27396160a5214fc5020073d4e9c6cc4d029d48db2ddb5fc62d953823d24a8b4d23cf26a504fa9f0515f10cb0a8539b52a9861e087e95c895e4e583dc55dd8c0575f5a029bccb3ddd4a27daeea8af4961d7d5a16117c9d4eccc1200a2af94416f011e855c5dd39881aabc241a11081ab1bbbae0684d4f5fbc397f684f976cc3645ae2d4f738494a13d2b7f6aa0951f62281c889e0bd368a6c3e1df00cbbeada5cd3abe8d1662bf4b62c027c275c033fee1c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
