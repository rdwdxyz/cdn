<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e69a103e4e27c172519a293ebc96ec81536acf2e422a2930b3dd5df23391b3e1b7d388dc87cdf2f773a1549227b0afc69936c384e94dbe129a8e3153181ada6e7171bd9c4720426b1b58ae19974c76b455e9e9d550a51952e1eebadf2989fb50261aa165fca866127b426b028f9b011de1af49f2f5819554f844bc3a9c400fce59bc6176858c25795833ee6ecc74761d57b5efab7625e8c408ac3a33acdbec9e43e94d5cc5a1d65c9f780d41bf1b8803e7462ff67bfcab5acca5bb9d77571fd204bd5383f1d12a386063c004a3cb61a3361f61698e1cb3314e8d05934301c60c79c4ee5b10e62b6d4d7718196b05d6333b5be5f094c3cd67ef50e71562cf3cea5a7492e0e0fb7328fe84b90ea1eb5eb660e6a6e12f9a4a15e071d0e029a149e83b483c693703b63e97928d5e517fb31f25453f1e65903ed077a749dec7e3018c415d258a9b2ca593df34706a080741af1426e0e5ec89d01ed98650a7bc544d9976a54ea464e4aa792a233df8ece77d27783abf21992ec14b2b6b1a32dd4c55a9679a37eef87deafd37edfe3514223b882aff988fd2662e750b3b3ca5f6e4ecc93a5bf95ef5cfeab1b49a4155b2c70bd8b1360ef7764ebf92185c603fa204c4e3099b3c8eeab2bbb81745b569677da15222791331a073ccf5171f199eb66a6193e4a61144bcc2cee05ac36c2f1d3bdc3ca235f1c1e1f4c27b504ffbf604c9a26482a2e9890773f7fd28d0760bbe90d27f73f00ce12dc523358dc78203331713993c947095e2ed88627bd61825eb0a67a1b9a6133f23df448f9c4b2fa5766b222c56781ba32970397ea16562cdd4a3da272072bdf7d8e0f2395dec4eb96b82b6863618ba734e2a5420b9d5afe551eb9581cd8d598187be93448b76edb88021ab9679126813cda5d8b68a737b1731d5a8dc33873da4b6329ee785f43d6bfeb3d3d1f28f0d2e82d675005fec0679ee5d1559cec237ddfb47286b79a4892dde7d32cfbf21ac1e65e086facc915038bbdde482c9ef8fb3523540d6b3a5c58c8618587f3a2fc38ea5df2395ccc59f3d09cf702e05a5d51f0220a4d17f6f6274fb0643ed7bcdcf4256dcb3b2446093ada0058dc55074da3ee24cad07c1a1915ffcf01376940975e4b0fbf8e84b864f4bddb8ae29ac1f721bb4cd13887b0d2c62a0964aa047131a0f861f28427bd0b68b20dafc68b2dfd5d6641c41a984e0396af1a24e6ebd70f2b9ee64fa361a19a9f416bbeb41bbaec6f4686c7ced5da54ec74c7afe59c966b188091f679c62624041454d8b89c53f927ed67a508e16d83b89672c90148d1b7d42f80fd16bbdb3c4de1255c1b394f2ec8875e0ea264dee413a4e6ccb3d5886c305bb39bc357aa513a068b64689a48e208c851d829f57a149dc46eaaeebfc008f07db5d2bdabb522c85bf5b2a910db4244a9e096f20f3fe782c4d18884892cc19b758dfc703460a8b20fff339ee1a83ced31c2bebb10bf04e027e451aede5a172482ae202c8fd0a653c412cfa3309e30b9d206ec73af311e191d4b55fb5171fba425f91f4a0984c62fb0fbdfab4b72739c0167dc69a94ec6e62e38ded247fb2c6bb6bc00b7c67c4e567977c0c25c9d7457e5f495dc4eab327b94ca7b2d77f02488877700e7e8e22904d7e02bd466586bbadfe27ca2b17b9898e3b711f3315ee97e54cfdf3c9855c63bd4758d594833de3ae275219051d12ba1152e9b9eff034bf2d5f499cab3ab77731a61462e6453474bc71b3adc54c38001ae1fe659b0f30e84ed51f699d38da18225d82c42414f4c09382b935daef6e182a6090786abf7b34142eb67e744119cd80b5ce9adcbd5020f1c9760677dc1aa97bf8398c9768bf48e425111436b60795456b5681b6169afc23a398caf8c0dbc82844e9530eead711953de8248b75e5d258f8ce9e89cc409cd4e8e3f3ff731bd5cbbae9a611a5d8cae0cd0ae2d2ff0d471a5376725454571e031f546d13a0b1fb03b9ca3a3d219c2db7168fd41c97f5d54fdcc122dc3bd03cf0efebf2d3d0a3cae298befc9363d6829adeb393db31965677fd8682433fdb61d051833d46dde2286916ff6db9c17522614bb7bd4261026059f47ac3842248c1edff459e74e91979f88ecb90701abceb940778c14824f0cebb77610472f3a411290de1e17370487b6d30b6b844cc96231acad8fbb132fb37a6f1ac03f3908256b4aadf838de2c8e40e2828074ef6ee910201bb733ec1b9ca678942d2a0ce257017cd6db1780885c329654cda1104840e6eaa25fcf5eaca3bfe19eb26f886681b5e5e94e66cd03d147dc15f048b0978321c27582b2814d9523d0d604c3d193da5e0873e90fef312727bbe19277e0d1033f2f2ae69630a767f48458845c6f06dd5f90a943a3f55e863877c3cbad008c32ad9f9f00f920375a79f753f7d455b60217ce8ba8328ed34e58419cab015c64896fda9d3d8635a8502bd642a27edbb48ff3470fb3406b3d0b01dff59e6b8c6b8278ee8fb6fb05448ba97e4f5a693b798117ce8066c663421cb8891596af3520e1f399b886294302a406363022eabe80ce1c1fca775d579cb473a24a67c3085af51342b8646a9ef02f573e1b1e0fdf1b96f8fcd494a150c1bf5e7f06ae2831d84a52c3fe4b4938f54cad3debdfef4f2e419fcc2a01d63fe3af9d701cb855a51499ba31bbaea12adea8f76b4fc4e9053d2dd1141c842c613f8517df1ce79eaa7d53e81056490f8997b14ee8429a9707f576a1047c9b3dad006da32353a69e1051514f7be1f6ec4b7f106bcbdcd75dc7084472ad362754a872038d7e07b51567a74d4062cb5ab3e1bb8c44a6a3891bb8b89c353a8a308e2c2d54b7fbede1b29795d89c79e66165861d61c60d222c9f756c8393f3c247a1118164e38a889d4601e52e39b2bd2a5154b5b678a5495775f6b5bef0e21779ba9189ecdfa2333a3a7c274bad84c900899a9fc5e996f458425d2859fb18903fd8052b20d7dc614e82fe0ef4ccf420a9142e43230f8c31f764e09de05c0c017d848e030197718ab392cb329dd9eb8493f860e8f9ee2c4dd7e05048e7e38dcf93bde9d9c9bcedc1fa23295aee5d1677956c9e89d02ddaeec5370b0d9e7d33f06bcefbd62c56ca6d9dc097b1abf0d3c7b03296a093e71498a5989766a187e52b7350bdb669d5764b0a727be5357284ca37b1d338e977a4fbf065500c3a289dd83bb1d90b88b90b477f29ba330eb1a1a794361deb9842c8d3aa6d8899318b0edcd491a3a7799ae0824379ffbded30881d91af5d105a378016cc38e023bc0c64413a9f9d94b9388144c546c48e8b285ce66ecf680051a4a4bf73a192595c221ca918b6fbd8b2cb2626c50558e58e309c8a8c969fd7fa78594d1ee7a365362accd4dc40ca3825224692d5608d808450dbd0df890e3a8714bd96a1d24ccf6472e377f66539763260af0e824ef70531c16cf3cd54eb9b603278590d2e23541c65cab7d773fc8e42267b8cf87e8e20f03f3aa79b4c4ab754418e72afa9f29688bf4241a39ee0c0bcf76c9aee6d85dca7e730f5a244fad7ca3081a4831a269e2537ff1117ddf0db558cc6787321bc5ff0ed8c5682be9b1911bd1bba6d3441789506125136c51e10454f57812de8e312d04779bfa2e0e4fee5cbd9b69148f4370431213a059149b4616944a991bbff2e26e1080359f3916f2a3f808b76433356573a3ca5405d651db17aa945bd75fd412de5549a8c8f51b04bc093596dba7960fd060e3295a94b60516ffc669de43511076c61d7d2afa45432ccb3ec948729a109977367a39d3707b8894d5443ec52242bb3f9fb02411917abefec2e18a9b772c3f8e051248b6fc4d358b6a09301acf7f1eb1280f3071d66ffcd5efc903a3a425f20ca432c7d4965874a686dbabaa2132bb330db8ebc493005b3292fbe90cb08f5b1f4548a67b0848eb5cda629740f404955b67f174ac559323da56e90ce163c4eeb4e25e91fffa161988a7115dbc78f81f31d0449bd9c578c926f3e56078650aedf5a51ff9f356122ce5050f88c1dd2ca49e3e5e27f2a1253a4c0a8ce7599710cb522632a40287509573a177886f58d140774879cbb7eee0fd906f4e4cb7e0674e1fbdbcb4c117c3826b5dccae60dc8077364a9f9a7ca2be054ef1ad91d6bf9a3cf2c0ddcd6d32cb10cb5e1ac6d22b554e3d92237ecbd0defa78e74802b8dc10260fe958a13bd8b999478b08ec05fdc5cad0337f05a63a0a8aa19d977c231fe014a4502a18852178e0a9e988c243e94ed035d561aa8ca80c1ef4daa93daa763823009971074476d81045b2d3b256e96e71b7abc184b64dcbe732b13309aa6ad42d83b85c6ec7e5d374fe13d4392cf0cf09b74f5e7b48a44748ed2d430a3dfc3440ba54a67a7e29f90c07adafc955b2ba55d605def1a77a61ad8367489eae3aa645f80eb7cb550588edcf60ede6b65afe83c5327d58957e31511834372a961e9c9a703586ea376c724da8ac171d887875d9fd9e8b10b54782948bf55965d679ddb365936d3a0ca4ac718387b3a2b7112a1f638e4277eb05568e223b0c9d48ee6f44614e70128053b9d2f4395ac3c52c0a583e165c9c0db8ebcc32d74bcee94df15a595672074c963d29b58c172bbc2ee3d1c6a889f2ffee0217e817ea21248e755fae7612bfcc429283aeeb7e889710912b1d4bfc47b939e384d32a1bdca5ed776a36abda2f8edae498572d1c2789cbfe08c89bfd122e5fccff2bfc0b93dec8e4ebdb0973ebf7e68853812d6852cb940d69c2c2920b3ec555432bab18fa29b5adb6e4c6a53a3420aad8e2a0fb6e5ebf148b0376d527850df935bbd8260be6338a3e2642afd9741b5102f6e434f0a3d95e6ee271d43f0404f753a78b3a6e872aa71c643b5ad5a9be178b615319d13c3bd3497f64408d53c9adcd99b45cc2fc96d3a5e9df30428eb824c3808bca4ff114e3c51ce94c9b8a2c587a841c05664bc2a97ae9ba4b1379b88f22dcb403fd3a0588a30dd549e1222dd193410754a824c15d50d3906af2721f4f4886fe55071fd8470a88bbc39b97524b7c3fd10ffdaac94fc9383bd8ffe9d1714a81ed085ed1ed545b9b1c858395534e0b82f006cfafed41bded173a06ec4e20cd6024577f262c6ae429a66d62884cb5aad8f60c27602b3c87d2081dd7385229babf0286af9447948a804707c00802b5e79a381e4cd87b686b9260972b3a7884b354c7ef33b3e0ac1e9086f573e5fd7d09ba4f51a391c05df9086569981fd291b0123c3a1303664e826e352c0804c11266e740b1719c989b679c455c49912de1dd0ad7501c08b4dec6057d5f7aa4799523ed35b9100e99a3cbcb8ae2c19c70be16b9b23c55a44cd4faa2fb5fc08344b22c1875ac6639ef27b47003881d14b92db028d6b5dca444497615e62173b1a55fd640e84753c2ac5e9b9cbb7ee91c87c8ebd179f920ae61be5cba230522dd81254cf30881b2f2200fa1d7164eb88f2b28aca56b2a9d621e0bf63cf7b03ce00d53b1667ecb3e5c8adbe48a57335cf8af8501acbe912a1fd9340123076e8f8460aa90783f49fba1af5e9a3bbc129ecfccb411319f72abab028ebe54c44399a8f7aec867aed552462d46206fc39d6352da754b5f7811671944699387718efb82a071939959272cab73c0865259e0cd3083893840cbec831a971e0f0ae4844a8c39b1cf78a2227f10268fa77be7a0cc571d1ce5150ab557f3a13fc9c38a49a3b3e9d7c91c8af342011f4be5206d7a454621bfbe7799481c298767e394eaae95fa4604b5deb6c89f997e77f2de673865371bec0cc41789643b1b51a9058d3020844158aba22660d6f64beb48d76d336c56e4264c104e191b7af586b83a65fe3d6578f5ff86e442191bf5096360b4cfa40b87b129f563874f759468e95f726e5424911edd8ebfac96e87c02033017ed28bc2b515b7adb4470b39127cb5d1c1ccad3cccc3ff109612c28310a948c8dded4691cc44dc8a8c819375a8d94a5b37e0be38ed8a14aad952305b06a3310bb7f891605ad8aa496be2333bcfdcb91517002b477a7ad0352a6102734455f9d180f1e9dfa68809fecf3d2629e52003e48f27b479a7489e2adf766b0580341093c1cc9cdfbcb9dbf372b592f257290dbd916946520da15649c39c4ab07cc4646964ebceb206e89f96697e4fc575f891e2786c00792f6ed55df912139ceb3c0d5c29a6bd6199ce2ce7632a10c2e27e4dcab7342711a0d0eae56c45e17d991278bed729ac6870b9263789a5d6e4a63867afd36c3fa60eea9480e9999a49d93315948c733075b90aa3d1218999fce44136b9bcdcf4895b6cb2f8ac216c244394bbaaeb3b5cd01804e80f5155d28b0fc2449b814c20f10b5fdbec719891c9b5a206b57eadc0cdd75936b12798850cf7f5268a3e1113b8be63a286c37688275c8f457ead9843d12e8b30072cb19df62cc29df6ad2ccef615ea700df5cf17d97b3ff2f9e42a2a40a7da9054109a6b8f3d15fe1a5515cc5bb0cf1750cebb44c1de0f59ed81238377d14d9f0957f0ecea8491adfbbefe5e59d7782c54ec4b54ea8c2f72c7af28b95b5ec89112ac0337e108bac2c9bfb1e1f4ad7a32d65f91799ec1f4ef35ff962dee561a5a153506c357c93c3a2a72e581db01d01e3b814a068b121f8aa3b8aaa123873ce2993c331552d09956b2cc61d7adb82c3474567cdf95397a05c211df29d4eed02e68589d11366bd4d8f978ba17559c7daeba238740d8c9eb62f1e404cf10a08a771534722d38760e70a6751d1025295b1c2fe593b6ddbbd32d21af2b3202aa57c1f1424f1138099d48d8553e69b68ea27ea84492f36e7c5d6502299d1880429b70080d7a7892ba41c709f8aa8c52dd9803bea310b0e11b92b85dea08d1df936e4a97a7e626a9c0c6dc19085f464efd0ed21bbbed7ef0a9a1302648b917e45a77c316d3ee281271ecd14354df76cd30025457166e203d3749ca192d1052ff5b20f647b7e5d18dd1f0a801a4fb8dc8f878bfebc3711fc8cf4e839a7a68e6c672ebe09cf8dde937073451300b1a93d7eca864f937abced3c1762a26441d688b2126ecb9cbd6303e1b21206c933a4715720f99a79abcb13933888b7eabccb9644ffd2d4b4c32f5e9219ea2c458d76146d59e00744788fecff844d8dd6e762fb5253d2db214beece2943066ee0dd4c690568603882c1a8d021f9111f37fa36d94b09b346ee706eb0ba3dd21d1092047fc047195cb7021b4049bc5924d7fa5eee8471cb7468009e54075d92688de26e7a856dd7c0884cab4b6ab3f77d27f83cd3bf5f09cf5a3ed85bafcf65f11a8c8bb8d79bb239f86dce76908858de811b3cc0b360f74afaee7f8b6c27c4e14820f3e15bee7c58d6e5f76b8ca4cd84830d20ae29c6e29b64fcc44907d1692f2e882ef3af79427eab22cdd3020429c0d7c597f07e6f589bf3eb199e5c91caf443df8d85d1abcf995f0d10e5eb71b7126cf28f3280dd087fb8dfb973dfce90aec79ba10a7fa6ecad2e3e39d5ceb974704911d35cb709622685a172152491fc62f520ca64e6f6fcc9a921577665aaa2dfb8df5bdbd33a46985d84c2eab10b126ebd2a7631177aaaafb448145cf8cf96270433f00ac92303ee6a5ef46a4c74a00894553b6450d028e5bd4c2c7bf9a881696986d39893bbf0dc1c3147170862a4d31532b8099034564f9282ac031db39fee8d7d31594d0fe81f0273106c6d91ffdcf6fff121929d7d2ecfa7944602b39fda67af7c6832829edfe4094ed8fbd7c080825e0ecbd9831427767e022bdcac56ef17de78d592e1ddba317cba3a5a3d773f4c07e51c1b64bdefb921eecd475878b6788679f776266ccaaad0dfb2a1d5cd303f0493baaaafc95e5fbf6c1a03c1c61a7e56b824c816ecd6c8d3183e609f19ad6c266330b97a53beac78491e712db2081254587ce33934cd931c20c20e7b3830fef996021390473f6ede740689389b0b7bc21da211eb0b414000538ab92407fd03f207a6ebfd050ad683a9f4d0ca6ae3d7d5ba67861348c6bc3e91eb1075f557cd69a7bc7e7c04dd0d43af75b66518e4fa0b5df7f35817ba227449ce0532f2a248db4d68c6302b0bf713db26360a81d4b442d09da28b0867e610d1ae245c120e0cfd802fa9dbcb8a98a092589f51ecab1d36b1fedf5ee84690ce39814253f2c04109a0e6b0d8f67655b14960213911b276b183cb84f0afde502dd743f1b2c991dc41660bdf8666b5a8dcb63f7c857a7d233dfbb5915730fcb3ef393ad305c32a69dc6b47db52a90be35367b2a3804b258f84e1e812e1d1414b55c170fe09d04a3464549f99908ab1bc6a330cb02ae44a78ea32f2c24c74ab8ea70aff30819fc91aa399dcb91cde7d77fcd9130ad390aebd73d793b6b4bb24dfead4a5bdb2ae713c3324d43d1c2790a8c213ec5b2bc397ef636aab522eba0cf8e566eeb33ec212727b5085c6148aed40ea4c198f013f9a8d32776906b87ec88fc3c51f38974d061ebaeb3025fdaab912e8958fe701637176b31a4f6395138bdc0258acbe735b3e3d229125ca1235f57517b4e6a7e9335202b38b3b0560b8aba2e086c636eba6a705ce81a7215c02157e316c9c15d4bc76ea8dec4b2db5d6329191587b03b4b023779b0272c52ca9c464d322c3354ae91463ad0c77bfd9297bba2285c2f29ec8dcde3e0b7c056fc1d6a69135d5066ed491f42edb1809f8c8d6048dadcd324bd8605c3b34412709c08b3bdfdeedb4a774ee47503331f54ad164f71778c60b4f8a6b8de3263dac40795368ae833da94314d64aadca3a992517439ec881c8ed08afdb90cb4b24e420a75fba583a9b57fd15714f24eb8f38910928ea48447836abfa4f6ff996ab67c6ad22021a3b324791a23b24962222710ebd593cb4d6ecfdeab1ced0c0e2ca9960c7a71ac9ba160f7f421fe3f429192e117dec4f99663c1aea93bb83ab906c690aaa82da236ab80ea63d2d50d6eb5c145baf51ac4bd5ca22d02cb8329d67619a8281e2492213c130cb7ad8162f1d88bca7969cac41f5031cf72fca50c9d0ee3e618ffa37ff01de104e39c11f79d57371fb94499b1693e0d35b3d3098c8fd04833759507e8d730fb018c9846f75154c139f102ff101898909a5fa2c59cae2abee3ba1847b1989767978046ae07ce3852812b0f55e3d5921a519c10eeab59253605341d97a88b567b1ab50069d5cdc858c3d5bdf7763afb50ba2d6d7d202e32f4bfe32aa3d215d293015fcefc7b387c4124e30565f0818ed4c9c1b2fc8e6e1fee55d9c5a8e0d521f172c6f1b15ebaececcc2908b054fcd2fd8acf9fb0c421684c211f8743d6aba2745c248737a2ed71ac9b1d48df0780620b70f8bc7e0ca478c4675298e013a4cd6ed5cbf0284fcc8eb37b22faebdcd947bbd6d5a8623602063c3070f06fc52f58dcf8bb945f0bfdd11bb715cb9c17535d410b9770c9b7c222348d9c4f7a815d918a18111990a8f87a94caf30a30a29a3f6f6702f4358cfaa7a17138ad8729952028ae3527f9378b67f3a942c31ce5e09f4dd9e373561e9a681dc07039d09cdf4d78a1d0f70735d2447084896677b21e47ac70bf8d86478e9cf11c7557678c648c09697a41f28025ee47461e02d89956aeadd1474413e944f819e88f636d9acb35616c4a10ef428d79ecf3aeb8eb0129fc80979f162d438a6cbcb741172393c1d8d2496e411065a69850fee78284fd4b783c5c2fa3f837b55c45f5974daf125c68be25b3e55dd10e75bf19a95a48a3e4a4f007d765b2a627ce49ea7379ca05a39f3beca80083acaff4cf2bb578a4043efd581a8782696ce461c32b0b2ad357d40004f319d73e82666925e19be67dc60a71e75ac64e53f9bd162164bd9513f3a7f8e53c3e051f0fa4936e56a7115193d6ff0cb66b09ff16c6f0ccae3391ff8bcb31e99acb65ccbb1ac5f3a0e28b07d7d6b8625f8037b6594c6413aa70ad53f5749cf39b982df01af0e20bf7446b03f095d3d3e835c8afc09e92cee6e09a1c3281a440e29880dd88fe8ba18e1b3bca200e8bc24b0030c08cd0bc239fe8e5a4d804661687f5101c1f1f3a642e2c19e1bc9c54ddccd81e011e3c19fc9fe010e6ba1639b8e229e29ed84879ab836468b74af4c9c56cbdf83bcece79112ee526673a33afbbbf529834531b815a6ee45079fd7bd879c716f847b9fc7e9ac940fdb073bc156faf97f11425f16bdf993ef1d3156b26e2e2011d9ed29b082db6a904cc0ce5414e50cc32089e78597829255919975181fbd5c627c840c5ccc0e428e30d352b83aca6da1259a300bdc867c611c0b423215969e011a3af8712e3d8d70a64d496025ec480eeb651853c72e247232e031d922f16a71527d3a63af23226c95f36a4f51f2146cf1e9e8893a8a16e48ed1a8d2bcae4038115e9c35bb85a217abdbf180cc9445ae2f9c029c9108e96665629c3df110fbdf4f3862f9636ba23bd6dd0875383b8f99d37457c7c28c3dfc1038e0650a96322cb1ceca7fed9dfccf6cda7d38bfdd17ea8f8db0eaec8d87566241adc5810cba3f8471ea8dbf61461385f1b4ef24101955c3e3090781d6ecda479f535b59885915c4f1a3cff0dbacb92d98f5307ae989e4f156b128bf84ca847f48ac9813d1b0fae470f346f2260c414ab7c630bbdefdf5a74eceec60aa7a36d8246641433d956c2e417b361b75911d90000c8bb7d6bc838159bece05c8e87aefdf17c699c2c9743d5e489972e84e166b4d5ecfa9f23143eed5669455b88f2251970690adfce8c4979709ef6dd5f25c6aeccfdc7c0a418ea24e64503c32c083942eea2178e3df4a84b459f7540d543e3a65a3f31febd14a518fac917d90f58396e48c1e4fa6eecab58217ac074426f29d0a4869525764a96f1dbd2ae4308c1669f08986344e1703b772ae86b1bd884c1a55cca480e73ec464bf64943193782130c2ec6657264a7ecfac63048beb2f3250160e20eb1a7c7be57f61543e69b2ab4401d98299020fced2d9a098f7db117b7fddf5773be5e68c0ba8f3be4a0febc105a3e6e72f6d6cab9bfcc90f47d3246cc00adf355eeb451a21cfe9143f5123b37da5a309e184b46baa413874c647514bc09266a7c90978baadb8893f12bb851df8a1b38e09cdac27f302cfcdbba33cbf8030943d6113510822d869b3f85b45df8d0e682a5bdeea6383187009e38c863f1c8c369e30d07c7a13a0f48a463b1802046466c8a01b128b55817b70ac2178c9da3ae267cecc9aa72bb29f06aa7f7fc6beba2236029657d95bddae00bf26f999262840f20ae042d39700a0456908255c92b6d30bfccf7a3846a8231a78862aa6403a463c88660a3ddb99edc73112633964e3f19c3e7cadadc0127368a23a1ff0c0f533eea336f3450c4e30e1737cee768433902d1544bc480a1961171367b6f17fe076801d72438032054c296ce91571445d92f72c694059b0f251c984e008849f208e0abf235574c3384f44d062497670120f9c94a13f34dc16403a3632e8787c6e2a701204b0bbb441561e57d3b61bd1aae0fc4c8f245711a4d70ddecf16101ef9163a4f59c6495b5e4f77c6e7f193ab5a15404d789e2a20bb145e9d4fc49fa74738f691d1b576ea4bdf9d6a4e4b83a7e8dfcc2114437800b65a8d0de8f9132ad1028842084811d7d70362c51e412000b85cdd9113f60785b5bc8afdb423b7dc3105432aaf98024c142b78efcf5ecfdd6d0818ae7a7e9ea4c4eb97f715c2bfe92f3d406e04c412b35be5547068215c4b0061d9f875f115fb1da0d5b1be9c8d085ea0f6cc20bb23b46f7f98464abd6dd050963222ca90abf7668b75081994fbd8a773ed4f5bbed4d90c03609e4b455c16be9e84437bff987775fe2a11d3a32ef763e354bd2354c80d34a9ed189779df597f067a743c9cc6a2ce43c3fd236d8340073033d073961aed231f5471606a137de4b070bf1579a239b9c3afc8d9b69d8ff8e2045c41d4f1cd6bfa59b9510fd7ddd7732b808118c84ff2dbdef44f8db2783e9cfd71191ac94b01732a6181057b4b5f31d20fbdd0097692a78b256d1dd98678f8045f61e5c824628eca3a09c60dc51229069dd7cdda5ecfaa735e2e7d7bdce84ca696af4419ca6c5da095122ce4e28a113a571d2242e708bed98f28628b6c51a6a2b6ec4758811285524f15c30600d657067359569ea4cd52390d727d6c009f85bdd81e972d5e25a53654194e7bbcd8d3d7ac80651f37e8c9b5d6b93aa95eccda48fd2e6d3132c05daa2bb7f326d147b369429a01a8a4092c59ab727ac825c90027558ad72f987c714145eabed7aaa647d957a988771a9735c707c3a805366a7f3eb0d00a0a7550ae398e8ef716f6b2b8b2f89aa7c7bbe118feb1a802e3cd33b7fece8feb9e715a2428f9c13155abda9576938a23f19664260e00c7a8d9de3ce1be54bf44a9d4ed450cf7297dcc6a8a235c29cecdd8ad21c637f0c4187e665ab7a080ba57abdb90f5cdf970e7adfc12faffa24c3fec7818c52930d81a02290133437ca5af018d21c8111e378183dae8f0a00790301d63ec45685d7b45c372f1b971f1bc7ce53053b0824e068fe1f9abfb831d181934a29120d6ea5501ad0995ed63ee385686ac8ff46bf50f3918b37c9a842042a59ac730466ac3f58f9c07f8070033ec02ca8eaff873cb2561429f352f585a6bd76de6d4bb9892cbf2d2b30d6187ad18a9ffe6601376a02717b7658d0e08ad9bba993e5d21b87982d7c85b339efeb50d934d57695aa230bd6cb51d3b26fc094fb68422dd4225d804f5679909074621a3c3a28c38402fca06314c702aeab93e2df57b067ef293863a183af34f1ed6c235b963e28515c0364fdabd0853b8c642c0d5f5134a19810931545fa6c6aeee5bae1c022debfee7a8aa245bf2bedbc800a4e43d4f64658b7c11b085800826b3f5f9cb10ab111a5d16ca379a97f935f33baca9f1bd12cc7a03c1cf87016af0186f3be26f62c3977106be2b7f3c1144a2c091c85ca2ba6ffb23dd1b08c8bf224b67bd4c7d47cb68ad6574d9a3fdca47c7330dc97d60e608f74a5b910858c0df24961159c678fb7c4b1a88e3508eefe0585db10e7b09767bee48d388268d41a818548c3ce9d1641b2f5f6244e649aafe47fe026969abf13a0a449db49bf3f59ecb27c899bd62e48e090044b5953a9c64be8dfb9c02795a3f828a9c2837abdd3e4f5943745fcb11f31136cb318a747ab1dab38f8e89a837fcbc96a95c08fb9086f07f8e7417145d0a6d904a494faa50951844ddcde197d3e6d5696f490bbabe620933721644484eaca473bb933387478aa59fb267d119a7adee3ac52674aafee75da66091c514b3f2648bdea9cc5611436412d95fa81f9ac68cc2d94549e90d72c1120dc72acf948b52c1a9831f084f8acfe09d340ffb09868cb02ea31b0ce4941b87da9518c8be13e832ef7de11be088552070b64d3a08307e760eabc1377ce08772a357d143b95863d9a736c7f47de56eccddb1d8a4021cadc5c81f4c251ff385c1a468996b99edb22d6d516e66b7e1ca11672d656bfffa5c5c22bf7ef75cb5d9fb49847f805756f946613a9a9ffea709ab0be312e20d8ff624d755b469a7a324e493846031e270cc51029b1acb892f89d4119170c8c85a3721d75ef47a06cce207274597ed36d68cf7cb9dd29ad5de2be864d89eca14d2634a5e0a71c513e2fa811bf827c855a8f2f5e96ff7e1b56b78b4993d39fa7004faf3f1a1e3b0d25c495d5ff055cd7582cbab547bce3eb7b0f653979c0eeedf8ee116f05caaf675255655e88a2017fc2d567b51975d38efb14dd3fc28301b7d328e4899c2ea6c77f10558a607b4ba0a0e06a58a22a029d0aabd3123bd9004837489c666fd5195e533a65ef651cb7a832c6f7bd38fc05367b9dd892b08bff3f189afd86db81658683548041abb173253451f1ee507dc84058fa54913ddc0efdce48d2a3a23e62f7e41bd3fc21f0f1ce6db2745a925880c36065efa72aec91b822769b2ff1763869bc8188dcfbb25be856d6cc1ea3aed2c82466b7bd466500b1077c24905135a254632a440ea2374d85ff291777dede38760376b3c8dfba4d1462e27efbb173d6427f668d8e0c034533b795da71cc6df98191c5eee1e250ddf34548812cfbba55df06b700cb2c8beca499c557177af52bfc35c683fd294113b6e3257e8d1e29142f84ab691b7a423f19a1b5e1bb209f0af8945b23ad08ed70b1c89b23ed389fcbb04ffaa2dd8ade0fd05eeb9578d047a4eedf1432bdf89fd2a36603a4d16b084458e71b7ff1c92d266b08ca77e5a69a139942cc47c4806a0a95e4171056a46a01f52330130e8127bea3a5d9d90fa2de084940bc048df2256b655c376bc06350c3234ceb9659c680247b2614231c70582a71db22c0fa6f8d3ef01091caeb1bf19440c72e7105d3445a3c64fd554375ce0bd9113ed32b50e970542624be743369e0b841b48804835f7955a6dc2fdc7aa832db27312f6aba1a6d3bced39108746a4a9bd6eb6ccc9087e78eaffff41a093dd7c742e7feb61b955abdd5a7025c3a7532ce7349ff8792e925a75873ce35e0a5679d4073ef6bc2dab2304c770185698a094443286653baa805745d27b2e7df96f22b2b2fe603abce3de7f27045ab1d9099c7e19b62ca16fccb99bcc12383932df359984e658ad03fffb305567dc616c58dfa54d014167df433231ec0a16aaa8958f8c3ee6fe5840403f3d04c789be78de6e0fa7b890899ec76c72fee98790382da6d0de8e7580c0e89483eb8eeb760d04d0822893e2113409769dea3b0922afd515dab2ef54e9880938347b91600a7d89a3daa7d43f2cf68b56233d7d83924e7be98cf19b8c977614227c7391b7c0ba2fe506e5ce6bba4bff05bb53d3a3febc4964d1ebdc9c648b11f5441b3d2d3f7515c8b7f1134abd27ea2ff6cbd5eadaafd0f7760628252b9f8f24cd3c9a45d3d8384ed0ec062bc4cbedefe4f5f63915b28cd226580198c556a5cca45f26ac59748bb92d24ab26a75955ada3c11aefc8cdd5fb17bcdde4786a9f02d7b28b962f5372dabcde867bfabd8aa18b20e871e94c6e73acf0c7e5fb825624caa6edfdbe8e51844e0cab372c4f58415a375e37316815319404964cc2665aca03f26cd249bc507d08ffc6ef316931a5b3cb1954b06334aee62448fd8ca31866d4f2f1249b212121a99175ca3e239fbbc3e076cd5da85641e2e21785bad29263db75804fd8a8530f916bf5d3fd9aa579a22d3455826b8cf22f12b32e9bb2c8a40300a93be4eb5602614a59ab0d0c26413d00f991b53eff0ec76168f5293851f06a86717ce67e6191d02ca93a2d94fb16f02c528301f0fc6811efa72189bb3066d723a24b437e6b17266dad55091842a290215bebccc865b0e63c2dbed0985cc807ec069b485321d73a95d0589b89324aabca291fd10f89cd9e2d15286f720a1e1d3de63d8d5cb2679bc5b5aefbb1e627bf1e1141fabc07eba403d536ff6593b55a100413f2c3cf21d2075dbf03929cb7d0c1fbbafa6c3219af093472fcfc949b3a968e97e1e63643939c05a8562b2600a3aa8000f22c7b1d7f82130114fdedc09bb2608c962dabfb8c7240b82a6be98e9b9abb67a21287b3ee4e9c7b1919f238e7e11272cbd0ba797b794a49a3f679d5de82fe4e46ae48cc0dbc810e14ba654669fedb9ac1a1c4bf3f3d144b1f15f1a183e7c3dfabaa4743727f434e48724cceb8c2f18691894b8a19742dd40496121816eb591a305b426df76f26caec5277dbaecbf470776e5f47713a87f8d531b60e1a0c2fc7b40d719aae32d2e449e301f15cb0df5210d90f7c32e7382dedeec2e5704e13aac6ba6597bbc7b2063a6050b76b1f22c86ee3048eb64a27bbf98d31821b3c0290dd817d323b1fb984ad4d5ca245a3b383c2640c8227232fbeee6d367434917d151353605f516c6888fdf2f7c01d9521b319cad133bf2e931929167d1a32dd51b18897b3636c0cdc4d87672a8c2490e29a86606d57f4fb90b31af409892e4b6fab998ba116eb41614cc40e30cba37755d18cadcfd06cce74ee89a070a6ae4cc1b58be3226b94a782ce70a915bbab52ad3e5dab9a6f20b41d526cde45aef2f06d75e0febc4ed8d5b0e19bcf43217f429e61d71895924751786485dfaca779a8b733bd19e802ed74e1402c656fc7af874342895718f2ac3a7bf6b55a2249137196339e305685dec30ec361044b68038df1a89ac644adb0b59d570793cf4945df810464528883e52f063669529021edad0fdb3b07d0371f7c4e3d0231ebdf3552b390b1c875bfabbdc7d2f282a7a3c6215c66de9cfcadd7a80a1a0ff34cbe308abfd985a90642b2c669408e5f5573b59f6aaf1f738b4060f282245b3c98a0eb8a7d6a6a3c84d7f6e8c38a357e2e7f8960cd1e0bdb499d0c9067bcdac8532001b17e3aaea9827af76a7b3d45a8e58817075df277e6b7571d0eb8b56401ba1a5b20d04665a6a609f4ea27eb2977a3699dfabef330d668f1c3ee54f63e808cfe0f89b055399bbe998dbddc4f49f06b94bdebdac474ceb81b8c4d38d0f751c998345439daa6b2ac91b998ef7508f1ca80016e6dc3b930af9d4b988b2b8d09ad8d95374b10406b437d0f181efb2b273c6a5edfe27944cfa38d653c93a2f5e1bedfd97b80b4146a5d1051c2c7ba85a1ce05a5561a34b599dc9adcf2ad4e39a034bc5c5239fb4ec17ec7c2decb040e5e63c848fd2099a21dced8414fbe9df7e493f35b97d5ab3dd8390aa5308047307af8c1f455a9de4461bfe70ba8978f8c5061f33b1a7e17ad9dd521909757b87e9099d6c00d999bac909553fcd522c5920816661c4e0760565e3b6e40982c15452e7c604b394b6e35361f9eabccf60db63343a7b429a4f4d1b62e8d7d1b498ce9603916d66190bb678c21e4b7a9c5bde546399113bc2d152c5bfa9e949d83fd90dfe79c7f3b283929903c6bb81707d60c075c6aa8fea7d55f151fb5f584d6acc914237f443ab190880e894a7c0a12614a0677e4a1206ca5b0fe17b6950cd7aa21d29359b401351dd9dc604ae8d4af8bfc12be949fbf2a17908792e17a16f4fe9bab541f6fe9156a9f3f02e93a1c29802331a3dffa6ae80afe25f55e6193ac034c961376f4d17d803ad0a4eec44b5117513a98c869f25ac5a45db6b2a6c30b6719e7a166c1d8516e130e7a7a97bd8e52c57e83612990ef0d46fbce62fa66734bfcb333e10e03a7f3d3d9661361237890a579c96250cad302948f213e962a6780b690fed60deaee2d63cbe9ee3dd567ca53fb7a176a443cb79c346dea6eb45708aa5efd95240d1adc6559d92e580b530b55583b5520c3a701ca8466497dc77cdc23f148ce7d7a82dbf9266e4c67ba3e8687f55d1e000980ed679d9c89e0830eb673146c9e9750b783fff91f6224b7b6aef144acc00416949fff87f785940b0b28af1990b8e5205f470dcc27e15651b0e98a2faaa0479ea6c697d9b3599ab9fd25174bba1455a2c78a8eb1749d17c020fff3989058966a9a949b849c9bf01a686719584a0c18e349bdd46337f2aba33d37dbca7ff0e3cd6bc6e980cafc6870821b1179fadeb1da260342eb0cd3faef6b6f5862d308775fe7d4965f3a269e6d95bdedcbdb3d7928366c7f44735d0f7047b143584a2b2917439db7ab2aa348b0aee66ea58dc42b7d8ac66bb39c2d5dc72a5dfab626284146579e6299acdac098061e87b404fd1c5d7cd16dd5e7089352603de176893fa86215b1ff8def2299ec1d01f27d26f98d63e68f472d780908d04a8616732278ec6dc1a4e47d1f19fcecb0d4ad07df047fc00f81de4f8709c06ce5156b4280c2602f5dc73c77653d01c8673d272b14f0b452d1b677c11a96e860f3ac2de6f5114336f466ce10f3fb86537f30f8252796e62002257e6abd44e9040c291249b6d217143f778d26fa0a1cece0d8e95369a3a0a20ec28d5830451af16a057cf8988c1a050b9d41df861ed4be0f1631163b70eb5b6d0c87665e15fe62c81059d636570d4f9e44c956d529442666a7eb9dde1c3d334f96f6e79bff26a49f7d5dfae3228fb5eafa84773966fb008c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
