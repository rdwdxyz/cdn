<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64689bbdaaafc36a0907604dc72b0c59de23b39695fb35228bc4e8691dbd2bd9cfd99ed286cbaf9471d74ed16f00555f6233a6e93d228d25a65f8e6087ead951c7f864198857011b785bd8efed94a8227fe980bc0fed7aa425883fdbd0958940fc4232bf2248c4b4f447c5ba505bf38374f4369fe408c4c9cfc381fecfc5a832f6accfa2cc831a50556d7a441e1b82545304365e62c9ae3cdc29821321ef5bc7b6be8ff7ce6e72fd0a88655a06541d73a630cbfe7203fb03bb2f20dd5327197ea8c8f294c7b29a19e0f3e363ebdfe9b49cede1f02d45de30cd939e20a60ea1f8846eac9319d2e4039baee08abd478064ff5a56ca944c35cb805d2d7c9df14a1aa92a036cdd3291b627405c27c35fe31b2e9a2fd0131ce7cf0b2911db32cbf5a2f8958a46364619c3949b7c31e3f2aa4b023558a83a3801e133f42ea0a647c3b11f0152f544d53b47f3096dbbe772e73b738ad97bace2fbc753f63671be33696ed08a3e773cc2e74263e397dfeb6a4aaf4203aac5403d6d42289a7ed7a84bd37aa6364fd2e782c101f6278d0460a6e03e8ad5ca2a7a5408c583e68a62d6c96645490d8c3ff1ac452978c2de866a6d6ce84709cfc5225eddf8a9577427d0babcf62dfcb47efad48a6edaa66e715dc7d466a380da8a7813e2fecddae136eed3d8c76983128b7b0f98930c330cd7c5b0fbc2957f17ad79dadc60482273279fffe6eba71bf465a082e03d8c9c8d9bfbaaa3c68522cf8adb36865d55b86dce78e1dd6bfa4f16e6d673ff70162711c49069be4812cd20344771f9bffc308bed4c9e5bfbf67ac011c1cb06365610c79c51fe8439fac447173d004b6991e3d817eb7d931a84e1bdff371adbd09f980a0d936c3e8e02cd95145e6717402c5ac4f6c66d92af92d789cd043069b2145e2533184b1a171a21f9c03f7d74887eea838cc7493d0943ffc14084cebf413ac42041ff14e105b07d15bf033191b45e8ae6a14d546cdf0b018355b312279265d921afc2f9cc5d4fa3cc981c25b4f8954de4115aedd62938bde156f9b14c841000e7ac0ef8765caa4d0d3db67c4da0312771f3dfe01f11d66488a86a66d84a48bbb723dd39a5441db0931767a03ae06ecb1cf4776eb8683f02df9cb392fd62e9167b0947b750f0bd41275c69d767e41fcc39f55ddda1717313bc2dade24a44f4d35255d7a3f9f9120b0b670e9358cefc886830dc0619ccb8bf645c4eb76e41460bca9d8ffd2d83face1bb709be49b04797899e41c1f00cd539044c001db0d4dbba6eb1527001c283fdb45f6dfc547fc7e5f0ba8e0f793a9ce4b8441471f035e7eb12f1429502262ce29251d32224cbfb534b6b1de6b0fd9ce878c1a6eb884957e97fd4bc59dfee0ab1f1a01cfb82f735da47479fd73e674e217dc88e1e8ade50ebfc0c66d5b9216e22235c18cfda75faeb68e74e4e007e4106f44ac3fc36524eb5834da29754bbda3cff815d0bb82037f6330c9fc60e171812bc8b74084171c7a6a197041766e27956d8abb8894d94d4d30a786660c302efe0490e632ca99193da8818a2ac4cd2bbd00420024a56f9f64f8bb18f43d7d5d6e25e9da9146b1b33def89e9f61976a9aac8d4aae60939ce5d33c2c729f5c86ce7e6b001ca106c0d1d69661e4270c3d135ec01cfa6fa42e9f2cbe6783c917ec85b1fc76e10619bd8140f82a153f7869f001343dcc04204206d1f7d10f1a28f6c88f5afb6bf564d18124597e70f9fa1f61cbf2ebf39f902a9705e868612dfa1a9b6646f83ca1416e29b558ed4e06f0fbecc74c8a26d9b50134f68f82824cf2df7d8ec815a018530ac1cfd59c225eae8e6e27e9bf6aeb27e808200ca1185fff4be7dfd6b47639a0ab4624b561b2b45b43aabe69a26fa42c83aadeb2423b51cbc013d1ed9f9e8d491acbdb7ccac74ca79ddbd28b8a338d66cc20be96b31874595ae14210b6cf9f9ee69058db1dc67b4cffea15ac53a5b38a11530fb075e30fb2f5a8f53852bd772e732ffc593d0c782d8f2ee61f17f19909c5851f850655863f0441f58120ad3ca0952ffda55b317190db23fc13dff02f47799ec5a51b007a9f622b1f4faf07e28ec9761c2e79685008b83bdb07452dd8f9bcf0e283723df0e1bec4839e21bc917279dfd5f181b63d08aff47b44d4fde90fb33c46f357183e593b35ef01ed4ad3538ed4f46487edbc0328b14a6a5f846b57488c973d28280da6c15ee90557b92c94294b2042423e6454d182e63fee96c056bca42e4dde16756754920629a8e91c18802529dcb237f4523fb4ff7e00fafb559dfa7ce2c874795e6b794bb5b80d4e152ba8f104502efed610b97ca51a88b1a56e67fe0ae4c0f14e4cb86ae7d003f0cec2829e90d380e81ed17549ebcf7d0a0a32fcd7e373aec379704b925e33369f6b4951ed833448007b90d7213204c71f5976f774808315faa4870328e975ce3e47d4dd8d134e67bda284d6664f005bf5bf6d0f419bf127d6e74c0ba9669f1d10a7f18a043bedb7cbec92adabd123aa326f17caae33bdcc2be6896704f3bfaa131a11d1ea62ca1810239c2aeb5b472fdfdf11c4e920546e0d82405e4406b4e017757553c463eb2d211cddd3c8437f08d8a85a6be6fc0a2ebdd01dc5ff1df148520d20cb058e5c258e2ce94c718afce43f94c86f10f58d604c5b6b1a697888a1b8cc6ce664d409ec00a26fe667ed80b781ae5eb205c6f6f493bd949045f3b6e876e4303dad138babf2b07626358021815213673593b3615b53d68d0d2390730535532d993a2f163ed33bdea776919e539d29097e08f9d632bc165d40ee3cb8a90d71fd024991899f2182144e5cc0a75625f688723d054fa98479600678f7cef58aab19df55f2f4629703833e4b9a7d222dd73d9ecdb6e0d970565680c51366176f53709eca63c1402b04b59be26ed28cdbc267e823b320cf265cb229aebd83ea125cfb7b98249059553cad7862899f8aec870971596e91e4f0387f8fed0a1a3e9c4220c8946a4454c55398b7ed8e994731eb8d8a6cd94b1f5d360fd5d3699684cdd2de4cd276de0c6358386fe5978e06faad1c69de2540abddd76865b41d5e886115d5ea08ec9e6931b9326330a150836f2177e582c978f9741b1836a85889818dfe689e2547f3258e8a73a9ad134a675c6cc864eef3bb43b7a72864eebb8295bd8ab1df973d3c0739aa4c859f28d40d67953192a571506f2111fdcbf91b43856bc23a95a1a9fc20053db1975d7559e11b6c426a5eff97eedc816c70b95b4bdeb0bb2eeeb43ae9c52561074385ac1002e001a568e0f5da76e9f99bdc18b0cd86f8bbec028eca09ada2b76230a04b4f9c5e8fc33a23fd5e60765e2b6447f3f0354f5c6bbcae9b784edd6b87df2fbf14745ac64c0ad3dfa25d7edfcfee7dd4f778cbe579a59e028474b56990890e637206b196b445afc90b51c2c05b3ca7dfa5126371442d1df3a1b084480da8d2426d92f4bfaab7520315a6a626209724913d9f8d53b124143ece1c1fa4efb0fa3e6c8f33b4422c259e97b56c35913e4b2d12ab60905b0e79acbac081eb0cf3250a2aaf6a43f445de835c7d99304ed53f98fb7ad872a5012848012a6b8c93988eaf91b38ddefbda36d9080ee1895bdb323e4b07c3f5abe672e5e5d5c13aa200fea61d99c24f628900c3192c5ff4c5a001616fa9700442e3899d909b4dd745e419ced8a130bc3ee14bd00dc173b5c109b3d9b584b67690b3a29d8325d238bda724ea2060e6f90f116492f63bc8a71200964d0984311f38cada8dd7718c923024999c9f45758d8342c884bf5e14dc06214af9fb745c4f0d8d35d2f55cdbc9a03f5835f8433b6d1821bc92431cfdf8ce0afbed605494fefb44915b8b036334f25363099f5d16f867cf64011bc0a712809648753560ac9dd4d678708b19089b4d2b7c4fb2f41cf688b35a58539b06cd32d46a53e0db8013460cecd0f79a618446b5ddc352acad6517f8186a67ea9c95ac4448a3be29557c286b7f910871f851704e2e117f93031242f8b84618b0e9acd63e4ce96abc03f67fe202f7a10e08893b27ec6d26999c27f33d986aac838414c4e5b26711a1899e7eaf109ca9db0f4570cf540368d9abfea2f3a1bcf732481e9448ae8a6f4c4a3cb00f270469784e53afc3585dff465b4a0b1dc4c3a1c18639dd14d6b244dbc7190e1008f2e128b7e913569b55ab7c6865ddade30f5deb4ee5ab9f2ffa29ab2ae7453b2b20e2b03250648b4743cab28495ce6b1fda76d4a116acabf31fd848258eee46bbbf0a639f3b19fe31e75e789c6f8ef162e78c714607e4ab5a0a20fb58e071cca761942cbab8eb2baad32daa7e7fa2787d24d38faf312a742fe3918c903acd236026adcc882c996119fc77884a116beddfc4554ead00f5f2109bee391d3ce967b05e5f5356c40f11dadde6c0eda0032331dcebb695cf4f09c41926ff4b108f496e03494f284f726ade40b5f783cbfdb6e76ee83fac8b1b72e30c6ecb825fb6afe68d1f7e7b6400bcc268f1238be999267bbb52a389a16cf753bc9282d062f31b37ef9b4730b37eba31870a61e400a7688ba4ae0a8bdc2aadb1d651231f9669fa557792392e95af6e04e098194aef5757a574def6ec1bda42edbf6c006e5862e2d64473f9e0454a209052e05bd206bf6f7ba62caf5e6d70559748cdbcfeed99432dd9c8278e472b669fb18bb57f37658df766f2642e96a63b33dcd9ac999153652b28ee4b55d4ba4fbc3c8a05d72d3ef262919297cfa553f92bc735c2ff3894ddfa4fdeca47824292b957225ea9132a79fe832a77e382c2cde0911b628e3fffcd7974f8409dd4565b16e84f184b471bee6b64f2ee16679cf50c4bf17942cd46d2f30030f8676b02f5bcf357490cb43bf9dc6a7cb0e1456fcbc090d4199060a87171bf12c5f5ad2c084a75dda4144b0b514034b9afbc8356392a246a180051282613e9d8bbfc3eef800b887ace72886e063919955285b07a9cf812465dafba9f9b6b8a6b192928bce1599655bb9379c335581b4bdf0f395b8cc5ee55e84292bcac1db15998460072e4a4e7d96c683014b55746114efbb4ddd46dd20a2e1bf7f4cbfd86fc782fe96feedf5e514b7b583690abfa65287db9ec80aec7fd1ee03bfba529f405fff9298de7907a51bc5986c7802a70a8a65c40f59b39cacd0775256c8171c4869f8b29e34430048fdb63d3ae1996ddfb9c9f7617a56558d6583aa36624ecd17bddccf19755d980c7a6fef716ac45c1cba4d4d42268cd86d037397b3d2690b3d6875ec07ef555e212f6962a464d867401433a841b6e467c589de6155e3fadc24c738a05147b06abd18f39c73cbc0c5f5ff71f72e74ae9bdb2069be4a479d6af7decfb037eede05a128cc389f7f721c813893a3da78320e38faa6fd8e27206cf5debd07ff3ab59a7673bd5134970c2dc70bce4bbf728534611b3d2927b30f8747d1a93744b17c84c84f6a8b7a85c3b8a805de291e9ddc01d02b1a0d712de979b1a302ceb278bdbc9ea7d1cf9c6332578be6d98510f544f05caf14bf1f20a8a7c36d627bc3a02a0ed3d62d6dfeae2e79d6681c6805cf20474ba2f972c5fc1acc00158b6cbf46b69ea68626ade7960e0f73aef03bf6e7ebaa00d72376b64f31cf04aecd8f38ad50b57a99ec76ad6d33f4291e342a98c2f9d50ae4378a33331d08ac5c648df44925cf1888a6ccbc63e47920546b5616e9a82205edb74b6b475ea6717ae9ec96a9368e0f02908b23ea971f0febff25247cb3736115cb9c64ea3fd61c5f96caffbe9a9f62c3a6e2cefb7956db52c3fb272179d5c1decd8b8b3f89f40f5abbd9ed18f81a9c11972f8c9080f5f68fdfc0186c27d20183ca63297218762cb9b40b92eda0e239c66fda3273ed565a107cf6da04a5d338b73a2bb94516405c1ab3d33ffe6596313292ba990172c50b1919d98f6fe5fa534e57e7fc86fe0a6676409977202cbd26c88f385ae6f8b08935f2dc2f666f9ef64bc8bdaa7836e4ae55ae0dde5cbd165077e76cf212305989d33e9192a72af12f082018c37f6ee3204621f3ace09efc10881efb2370c883a8734c71ec2a69e154a3d9b51aca56262ec0aa46ce2598931efcb6fdd03973ea33ddc074cad83d341fa0937f085f85be814e3d3c6d7c473f28410f183c8133785250d4ba445c33cc9d192f70f558b1892330b9ced3971b4317676406815f5ffe8a4ed6e37e3ae08390c58600e45bbaaf01520c4715f83882ee1ff095e1a44da7fe3a615f6f2b69f63a444de22cfd55309fac3003b3a39659be9ba4b537bac9e38357b97f63ffb3882149134e62e909c2bd787344316c75a1769a0c4f9797b4be2b3e19201047834e16beb2fc647bcc36d2715a45d288b54fd2947a0135f899400a50bc014f4975de401591f71f5cd15b65d8844a196b5fd010c2f91c94c686aa28dca2c9a939f26948464853686c59b0d0ac2bfde0451e1b68cf605bba6ad74d9ec8723289b5d80b5126584598f5e96b1bb83d11f4ca877429118406fb63d50bcabe9ba23a6b710f4b019f3a34acc068e4d285e48f0d2a48ee4413f92dab0983a6a99d4f393848d31f74de5301e1a430bd45ab359c94bfc185c88b7d18c46dc36d2a0d99ae387f0bccb34f0de7eb91cbefbb9220a159033b51ec54378b8858ff76999ba1468e9ef2ebc0c0192ca19aa0642711073be127c5385336ccfdf6380d2014a3361c4e09321c8b34b272900862777ead4464aeba756ca7fb863bc8478fb6302c7c021a08b426c7a49f9e530ec326b0e8c020b78b61f5ca0bb3875ee6ab39ad46378c5b53001bcf20aa39d653eeb9f0ab73497df8663af9fc64406604c5af1c22ac1ea0ea8517a2a7f2149a18059ab0a9a81f963a042a88d3f95d4a23d56481ba8f793a2f0198e5afa7f06269cf1b29c7ff1303e423ea065aba1941654566899ceb5526f93817183d57e66c8a8ed1acdfac940118011332ec168794cdfa6287cb229998c6f451eb338ea8bbaba778ae6df023283a7ec3add53629f8c065dce0b4e5fe3a2c3f5c863d404e42ab2853fc188b773b0bfaa584b1897ca48d6b45d1327673d84ec9b9724aa4068cb89859dcbc6355f2460ce3a45d8ac5e9a4da4557b3a1939a908e9219e09f46683f9625fa86aaac5f64354aeb217a8423bb46430e20b0d4e568b3c4daf09a7d27687cdc600545dda46e2903a544ed45a01248e32a7ef2cb46a1a9126ff4d78b5fdc1436e949b12976f3bd35d8d5d8a7c9d4b625f96995e8b904dbecb68083c60b836041282968e1f31684a8f74b128b6bceb8a9a555d695725ed3e6bf42ace75d1a07ad8887df878962e166345151826c79a7a5f53635eec22123f873db7e230333613c5d1ce8389e043961ab089444fe850fe08768b09290e001cf2169080d077ae3a14c7d11bf86cbe402e621051833ea0427c78fc1e12ba2fce31316060fc640fc59b58ce7195f107899c31e088eacb0b3e87f7f2a738903449a95def2fbf9a5ac6f20ef5420ece66fea3b62151aaf0c0221fb53b8f744388970e9a47652b3bf70d37bc43e44d9023c75dc67c1e37652dc488a6602237c25b32670aad71c043f435dfffd913438dc26d592fd9785df73d400b93e739d6740003ba1f429fe6623df38565f7d2aecf91234f01b5843530af9b13fecbe8c1bca2f3644a9ac1c969acd4391841637f202434b562498558bc8ea5a07873fbad3c87dab43f9bcaa769ddcd4d4ae69292a05095323ed611a3204af09509c00ddb6dd785c81fd20cd575eba1f6285f80716f7b4c8ed430153ecc26920fc33ce55dc46515b3c7a526fa59e8b90759b1915bb9b454ab1b9fde77d2ef4a030b1b7c9aec627c0196b0ba49f557fba3df2b06735ec68069f7181c6fcbe0116074576e70103b878cc16ecae52122edf55231d418b98afb51443b87860cd6961e0cd9ec6aba5ea33e8bcc3c15afa60624c752537b14a370c8f4207f91e6757cb385799c19d0ceb8e425a357159ce60c8bd1b6e6ae0804d5db804d195592e07a8f4eb2f7254fc4740941254d59061cacc4e7af3747c17e85a3a12f178b255ecc59c490962383b45a11681ed1abb2d6d203c304f134342f9b7ec7422f6c877deb06bef9de62b9495c11115973ce6b944ca4ffb8e1584ae5617f1e2d2fb92a208aecabc587582394fd9fa8fd5375169a3ef755c94c6d087ce9fc80436c8e922631ee88122671125cd835e2b0b7605f0d12ee1546fe417103ef3fff8081a381418324d1f3f1db60ba637424a29c3b9824fe04beee7537f76ef6bad859b02877a465743b7c2b712e56dbfcf744077db5d82e2a418258867a8736adc35d4ee96974209a0ecd32d65b2afe750d04c5388da73a512eba50112ae25cfa7cd5120fe3fdc2510b3bc99f27f2dae1e124c526876f4860d6924026a9c807704154633ed3f7166dba401035ad552cc8417923acb4011defa58dd595c65e0e7ceac88ec7877369c2682df89ff113c0b89afd80d30dcbd982d8c269ffc1a62a1b0d2e21c338fe5b62abb95c1236659902b2465f07c429b2ddb7ea3f29d5a34afbc6fe6f3957ed6a8845753d4c4b649c9f49817c14dcd0d947adafc26e72f8c8997dba5335dd664cfcc64b6ebb97d0d579c4e0e1fd6acace7de6236260e3c7ef11ac80aa6c93909c818faee4c39d7a011810e33867bf0436171fb5394db3cf38fde0247ccd769535a51eac14225525d097a9dea70c389f96e6740503e1d04ea8998dd3cc21a855f200a3ccff8c167345dedae19ffcc49c7e396efda709cd78e9df312534bcdc76c5c87d16b343975544a4ebbdb5b7cd6786c78a1a84dd5fe29326ecb5089d15e5094099466214857a7586308c1453abcd4a90d39433abe90b0d02093b8f2679e962bc2715000b5e4dbb45690fff77eb56c637f332eb32f77e074ad2882258c09a5f002320f56d1fd4a6e0bc9c0b45bf261813ed47eb2413d6ace54cd0d3a6db91f4976562a1a54a2e23473f0a786ccb65a0992085e789e13bf6bfe08621399180f8223868ae81db0a6f74d9c34f58c7a280f5e8771db6cb8c2da8c187a0ed0510281632ac60c77d1d460e437cc5227ad3aa51439d3711ab5a1e29383f261ea497c970fe72ce24bbe3ef640cf69028410fcb24968b52c6fd14b73a1490714ebf2166765367c4d7131d27e3775aaad2ebe6bd45b825c3e76882b8684dfa3ee21d04b30753c851703c901b7aa082165ee4d8651ae1395762a7b78b06045a4eb753979d928eacb6f27067daa117026f17eafacf69538678cb2c627356e2f56800a9dafdcf1de18c67ead558283ed3a1af08f54bd238323195e15765aa19904f41fc62e8be0cb7dc2dc336a544878c4f8ba8af6ee4c6c80ec0cb1633f554fecad1480709f841b6eeca786e04c987d1c3b93a21e9782d5d2adb56e26874bdf7df659ba929fc066ce5f50d54f58f434296ccf57e631386ec69eb2c77b97d5f390aba67414d4c0eba26292f82c777fc21389ca260e4ab02529be189cd5eadbade2b15719d442106df5fb815065abef94e70baf9267a9d79df0e9efe131b505a82f416a8bb47547a1f90c4f44c99ded95b26a26597f251dca0aa13abe6b92651c971ae7517fc63da426938b8979a1192d7b0b83f017b1141db18da5fff240254e1af0a2c750edfd285b8276e1866b1314984dba60a21da5a1e7f8bbe23ca33d9bf29fc73d572aac5683ecc2a52541bd3cc281d67710a581828a4fb5a248545f3919aab0e5b1af5ea2789cf1b36d2b56bfe00dd97ebadbd2592b9848ce6901a27f9a47b11b7f3759e3af8d74fb630dd9d35bcca30648699a6d061c2fbe62e84965865f5ea5a9f8beedca47740628454c4545c127ca8525960f3adafa29ed221de09e49ea807533c2cffd3869365649b7eca73579613e46cb788756429bc6a79fce6b58306f32d6d48503ebdc2261a4a579c39567ec6b99b91ea4ee203de7e89ed8047d17783b9d701737a9e35d89915b61a0c411b4186fa1338416126d6fc70eff03f21094485d4c75dcb479eff6efa180aa83503ec82454c4fee85a8d4ab740d8bd22ca9d80f727850d2ae06187ea5327b3342aab9e665c8c82ba8cf18dab3bad330b6ca9931b394bbb42451fa688378078b2e849ba567d2527da88b8b1db93064a738ddadeab7c5b7fa7bd01458426d717bbe2b695f87e3e2e990ed73936fb40d84914e5afd19e864301143df1e5d469ae0e50b05587702d139887567603bf719f67b6ac81954cfcc289cb65dda0f4dd5d3ab92efd404bb9bfb25ec09c6a00abe972343e9df842edfbac10dad301000bd1ab88f4fe7491109e2db85c99dd4a32cfad83e7f5bf4005018d2e1a0a60b6bc91c8d2faa626e5147bce243015a5a18e7247d74f7e643e4ccb867a44adc71c5b9468bdf597944cfd852a7ab8425c3dd0253d3014e026aecfe9b151aaff2c14da88ae39710cc18a79d3af4586eaa889d61d42e20264411e036d9bd49d4da547247df717f8bef74fdec12c175b301ec50b6dc9d175d3bc815bc4d792271bfa78424189bde7d843547f2487b6b18fa66b4409b8a40114ac28305e218b08e171f695c2575c04a246fbe26496f26c1f31d6500187e533132b6eab51353312e041d58d0d4914953341dc7c8c44e37c8517cdc251d0a98a732682a13a24d492e01f3d4c34e294327e77b563c4221f4cef64fd7a152395018f180f1bc15200b4ea36ddfe76b560c1085c09502b04c918be8f0f4a5e9a10815f3ef71300208d882b2cd39f8cb45e4cd334c1e81c524b69e5d6dfd1758620f69ce4226cc075acc00d932b1136bdf3aeb1511c2ebb177501ea0453f2e21465d76f8c4eec47bd061571c259df51c9715cdda650c6a45ae8f36cb5cde483960c07af86da5b40e8b6cc212d9567dfe96a17a5210b124f25b324f8929021b97f2f454fab3b1f05b69f20c664d627682c32d2393e59e7279c1e7ce51baf5a5cdb9c2b3f778f071d1128208a8e01f275ab1e5141ab2eb6e12ebcc0195b1a58ccaa3e62fecaacb593b2c64b4c7dd0b5598a1fbf958eac15eaa2b25ebb13f2c4031b31690f49f53ddaab13456942e16165587dcde6ff8375271dc5dfa22e6c53ecc9c0610bb3ada06769e38c9c362e68854ec895938a2a8c70bc4ee8ca6a760f18edcbe635cff5ea312af7394bbf3ada6cb2d1d815eea7b2d1b3a336c15c3e75ef866e174f45e78fa1530948e3fe4bcc42ace4d60cd3ceafdd4115b981fac883bcd888e142c17ee96953522d9c28d6f8b18fd3808ce4b474e0522613addde929c01ca6cfe6032d84c2f3e652b21ef9bc36ef0a8d85481188814b3a3ecb0cb642c8af1e6e229013c3aa544193c23717bfadb278dac03636a9cce251c625e88fd016ceb1dd866b3436b0b908531db3aad21208402790ffb99494431ce755f53bfb11d2dd4ac7c5a0b548d8bc6c345b975f7b4bc80aff60fd1f6ecd1fcbe0ebdc3678c5132357f5f1a63e78a721ff0b8734a56f3e4ffc0fd793a837c099efa3a6bfc3277773d6ed7872252bf3015a04a66b6855f1f76b36fe5733de2ad945930ffc936ee100b7aea2f9e8befd116c9ce5195c7ee981749a2131db2c75863a8d337ebb354ea5767b162c0669547d5db00e62584abdce2b8e965d7e5670ff361f2068f788f9c7b201b5764ebae85ce66cfbef832c9ae12ee7cc12c514cb0ed44a318eb956f87fe13fbf47c02a9dfd0e3a4830eeee31933f1fd33aad731e6e30b0c057bb0eb6783874eab54784b92505103a22cb583a6ed11f60b7a8f06ad7d65476d7769836260f6f65a6520adae5da8a3c3b5f047b9c53c80710f2cac7925289be8927b4af93361317c3ff97a9f3339f00454416921e9bece7b60b42e2969a5408ba45b43cd634bf8cd206ff38eab02818868abd1244c30e036176b6569c0a96a0fc0855eba711c44c9ec29c8149d6d551ac1aa5432ae6152cbaa8265a20fcde8bb6170ba53667204ec0be6e977b2d5970f124bab22c270b82333a8bf59e88e3d48fc853874a0f45888c12bd1a10989b836cb485a6824ea759e36159791c9ecd00106a9541ec6884384d95d07353a8db2c71c84667d98313b90f3563fabe98c4b2f3e6b248a334c2aca98004c2abed8d68df6b7743c8aafb95178631080cbf92053c8d02d45ecd8dab9c207e09557c584495b444cf734b4221a46722ba1577906caec82ad74ffd8f2afec93bf726bdf0f11e165ef991b1df227729fadd17ba6b78d37afba1aaedc4ca9878e2c939278df23d2fdd254376f7d5d48daa1fc49eb6a9379e4b02ccfb7044e28fce1b9a72e4f88d94937abf934d0fc22b9e562bb92347a62ee4e734fe9a1e77e323ee1e02afd6d9a55f33784d3b4963c91cc15e31bb3cad2d093dc6e9ce887912305de22ade09c55d6757f2defa76cc1025915647e22768fa9900a815930888d0965ad1c02b4f7480fe4056fdbc8041616683a0021c3a8ad4509a1be4f9872d006f8c28d3f6f608746746522c74b0feba2f01174aed2b35bb77946f3290c128610516218a8cc55cff684e7c16b010e3d6065a42cd66df3d1d6c3ece27d19b56e2aa8ebe81bbfed7d09c41e83fdc51dd4b595efde75b34eaa9d339ba8efd697cd14f79b572256050081f82dd4451123d5081e774a1b205949fbf4985f43767e40b0e9e9782db9bc1138fc5867bc7005d78040026608bd8fcc38ca5a53444ac4d956f90e74e48a0e0a573f2fef7a63a70aa73303efa8b95b6b41e2d0157d26eefa40f0498e1aafe1636e99da76ffe46fee581020bf0926aabbeed1cd093f4e73d700b88b0c9b9445802baab9d20bcb00071b6e7a5de63eb3b72b010f5b005bb6d613d2882edff6ed9395ed1a83e2c47b67a444648dda3b293d5a789888c9e13a70a35295e2cdfd9604cab81acbc9be630b632424a5c0b5727f0631afd20e8e193379b1057388acde8ca99f3178fb4ab6b4c7e55c971536957a0dba926bb8dc9e44d33674a760830391da082c970862fabea15a18833e6478486ce8bd7df707a076337e795bef101b1f869af4ed175d6d44f2c6ec3e4e4cbdaac4eb646723feb8128fd519bd2050b6a599acd40ebc42c5be02dc064325ab4a0fe7e24ae519cee75299ac3c983d660995f0f30fe9e1e19da153e8a2c10519f7641204e167693abe7dee613b1bc707af72f0ecd9fc69b7edc31a3e6c4a8ef73781efacdbbb09ae6c54a1115fffe182d46c562fcd14b10833a570354609a405509c3dd21261242ddd251e785425cf38261ce479c59e465e312c2905cfbdb2bd1be032f87a4df591ffa0f734cf28980fd7347280f7dda11e922b4e3af980c98111dff59e185fc6e31e04010655cf9dd7b41725aa5d61c3606f898eff64aa576ae102d41eaacc33c6bbe05f7d1062a0674bd7f0de5c6fed2051e4f226ddfd4fa82456fdef24bb179c38ad468bb35b006a0a23dbbf73abf3f3843bad48bde947d7a72ad97170729da87f17650905ab6a5b1bb6ee33fe754dbd2dece21c0562c950ee33d0c9e97983d3d67116ab2a515af78bf53e9ca587eeb02452c03ec2076b72a3ba26815deddb4d635a3c1442ab53f3bfef5e2026fe0709884d81a560a53995b8384073bf8586e468c15ee4069ee0f9fff11a98dd0c710f230935a3aa41978dd158f3264fcdd5a4dc72787738b070a193cf0a581356e5951c8b28f0e066441d1cb54cd2f484b944366597c653d2866fba2b27b9bf1d1a548b9db6ad808b003d528fb603ff7eb9608e5c71111a796c2e4069b74e6d6ff9496318bd26f788da76896040ae5db1a08ce4e2909fcf987ea2751a178dbe2fc042d46d8d5a09b22aef5bdf36034eb3fc78f67d05632353741de96901d5420db8b6a9c827168cf623408a7d1d94608ebc00c6c1bbdc249901febde83d221f0366c0fe6f76b6544e27b5d7612cb9eddea7104b56047109fef7e4ab46e800975ec1f2a198e7f5bcdbbc64b0130a083f2e2cc88a4537070deabcbfdf32b2545f09820aaed2afc1eff55b874d3a933dd57911320cb3aa622187af52340cae4352a1e3b387f550c2ec71e2058440d1279fc7e11e43b0fea8131dfda9be275f2a1830d5b0b5a337e17da5f3ae93a5374078f96d58f2d75ff0a4b431db05e00330c93dd23dfdb3ddd1b5cc7b5c9e4b0d7c2b724fe086237c9052fb4de0fa72aef3e7dd3e7a7b2681ea61329b4cad7d04bad1e28ddbbe61088760b901b087dfbc31c281521c5f08056ac65be115aa0942e81fb8ebc16d7df21df01e1f7f88f4cb45ff6793814e2cb86b44ab02de888f6f0b6d28e9441eec4b6dc7d0f7bcda0d466e31b12c9d3247655fb7d379db4dc097342e239e9e77aefa76122f60d820365de0eb6d8dc0af435fa8fb3b731b3d5f28c6b4fbb48d38eb937d9d7ae9371787c321613c41bd2fd85b1b9a3767df35de17cb5118758e839d9a7e373201374bd034bdb950faa4e84ad02244525ddfe3ae863d7d9646f7df67826314197d8f61e2211c07e5212b9558401a32d08b5a01d745bb533f3ab46d7c398cf4e325a2b3eb151c214480d228cb8bfae5f1913fbd03c9e1c57462fd4672cce639871b2c54c71bbcd36c7909242157aa1cf92fcdb94fa6a90f85eeb20bd062be5ce35230d37ea0bd66af04ad24e7583663318b16d352390619b7cdd34da42aa53639b811982a6be783a014139a2e63b7afc6d7678b9c778847a59770031f828b1714229710b318c507fd7f82599b7839ba76e8102c23799a70dbe51d0e492e9167964878aea63a3639d860cf616c5842364124efdb06b4e7036a75111c0eea7d1ea5332c0d33a1b35dfb56d94f85ba6f1438333f37c1fc5ac9ae1e7d0848641a63bbce5814770fe88d54ea48040e0b9e802f508948934cfff9933f81a3118ec70a77bfeaa5b998e3e28d880134a690d8c3318dd96203fd914f4047b5dff8941ee0e1acaf3e0e0ed3ebe7c39c7e0faded08e73736406ff656c13d424775c68455f3acb0d3aa7f34bdbf8168c7b433aff40ada3efa92c3f097cc95952c7c33ebb49e35e01db1d26279ee47fecb76ec7052b5e1e550020301b23c6334fe6738f5fce0de1a7e4a4592db22237f275e4217868374927ad7c5b4053faf05b22182d382ccde3f8a56070fe5e93fa629a36356e94e81cc79f41ce80587c4b63adc05931b73c1a03cadb703be9917afb7c56da4ad4a6773b05be8129aef30939339bb12499fc156667d6b4be2353601b10fcc4e4074334b143b96872d84a1c69a0409a63afd9034303b548520b7fd25bd470b878b636559b4c23920ed7cc0cac549bff47efafd7cec96bc49160b3d5e37044ec2e0e5b6a3d6481a835e2bc012ce82433509ec1450f6914f75886af658d3e58c0db67c771f663305e7121ae95cd6415ab579a4fefd92fdfc69f7595966e672d306c8a02aaaee06bc09722e57fb25e619667175feaaf8a04b99ef928c7982f4819fdf23a893e9fa8afb7c5b8f10c8efba7e6e76b80e43b8ecd49050fb8396edd741e3c1c0fc08bca528988314c20e30095d136a7ac0fc6992872393ff7e4e489407724253e6c75ae0a9e5323de4d5781dc742f0d1608d0139a9e9488070588b256d589ea83f13e71fc80b9be031953540a6a06c85f6cf1bdd87c9449105c2b7d865071e33b8382a297963d59e72357a818b50b1fd0078e4edfa6471495dbfbcf7d6a63ef11024aa202585d01f38d6d2fa81d79000e7081df7ad5bb3bb0f5d2d30e9d31bbe5a8d15e4c9d87509477de1713a4ff4fb8a4a2891946fa92289024d793a19b4830d3182fad80342771bb4d77fe36246a91a2d5b7278400aa0dab414339d3244a3355ad4c05f8a680ad049290cea8521efc4aaed1d1ef2af19925307f9ef04c0530eb293589d46baf5fa8c21c7c9498077769db7c133ea38b8062ff8d07aa612586d93f8c4aa61fa781950c4b97b35d47d0061ed780907f28c791b25ec33d47a79bfc1db9a28b14f8e8afc32cd2d315057e2f1a65eb9638e0e47f58303379334c0f27c9261734a490dc6f3b00dcb90104835990bbd78977020bcc001dd53611b1a2d64f9a1530cdf548b2afcfcec00a15e1d56561a1ff10f7f9c6f3ef443b105bbab159443eb226b2859390ad5c692c48105de39b28d0fa9df7e71e9c942918f0605cd2cbb9a7c5184f607e5b2612fd5ced9385be16ac76d5d0d4de4a3de4cf5996d678e9e183d0aa2d3477beaa12b31cb114aded0274a2c8fab372dcd09260b20ef449dd1ab40261234d988c59a985871d84f595399cc792a3e8d7ac1663bdba948a333bb494ffb46dd0487898e18a2e3f1386f896b96f208c561c53da3b9ad46d67819927f190621c6d0cd858aa20942db988bc9b5fa5b0b4b8e95ab051215356b5e73fe7d557597a9285d5fd95515f0a1a7923df2e04549f8772fe6429215cc8c1251d9739c75a6837cccefdb55f241b989731af9280642662402882a29cb7f4595afc1e2126e5712ebf5f5d22414ddc15abdbcf7fbe3059e5b4f2e8cb96a9b68ec7c713bdd1e5e67168daa8d91d25201aa371bfed8beb05bbdf5e6319a8665a92807926e677656459b293ddcefc29308bcfbe7db3db1c6623733b68e09645f4a9f1937f96c5868cc419b64aadcd6112a8d300edc0ed10f7a06ba7bd7aaef6cc48f31ba999a5e1bd9d8f9698d2ef8bb440b1bfe2e3db1983ae1b5c09ac92309ab2b11ca45caf3004985ce3f2dd07aa6327145ec2934eeebc3fc675681acf6bf346386b7a1c143e5e4f5ae44dd0e783df394dd1ad1dc422dcf3d335088fb255e4e72e156699b207900e2ab2e218128835ea7d2ad43691477bc307f984d5bfbd2494be6361c8b9500c698b3ca6a424f88960a5d2e4cbeadfb18ccae2c8d098d6b71eac04980c870dd076e685fa4fff8b5236b3e7dabc784356e538bf8c3dd11d3f66a096717a833ec0f3405d330a80885e612d5912cacbfed1af8d16317441f9aff46d89487aafb90efd0913272be5571c64756554d06bf2f6482583a5941f8d454c6d990881c2562d0a708a80bd1df7b5c0f22e15f7835a76f727920172c9c1859945fac2825d26a8bb68380be1750a874a67d8f315d8294088b4c646c9336de01a9ce80edb95520fe53bfd940953e3f3bdc1020571a98ba71485a6a2366604102050945116477c1ec4635027e38f03256a217b4235eecae55d2b1ffe6638f7c7a81466ebe2541e26526d8a40947cd2fddb23df6a5f197e7777c50924819e0b01eb1d9e4abf4378ef6719a505d184f7154f27c382a9a841ed629aa23596b8711d85da44b0bd86c099df6845782c41a11b94cec5e43fec6c096b1404a60b3151e6149338fbe0f673e620d465fe94436506713e97d425ed3b62ae014f2c2b75950f24bffcf4290b7fa133c2aac887c875db38bd5a77315c42cbb67aa3325bd7da05f97b693cc95bffe198088f47763332cbde5ee3e8b8f5f67ebe7be840b3045471bece65ab675d5d1277ef19b8705cfa014ee1b2e5289d71b00bcc620f65763f660f9a9b08fe6a9e5d8f052aba88ba3fb980cfb8b0438707653b655ebb3f0934095b21d5fdc241dad3248beeedca4f80141f784fd34c7066e62df368435115ec8ab1ab97dddf8aa34efd8f7640255c878c7090ee0486b6b3f5c77f92d2d40b2a88f615e94e9d48076efb7a1f3b4d6ef35d550e8109ecfb739b195898f455412ef421cf7176ca767bacd1e0f4947b5100fea74a128f1fadd816da24032c7d1330af64b2b3bf8228b6243b0ac67a2db44e6facc855385bc3cafd9109f8a7ff92b19895efccf2446700b997bc1dfaee0fb56e1de8ea20b48768cda8991a62e34f19c5c28ab79040f3dacd531c296b9ab7a5c001de84c962d03be78e5d4333c006517028fc96c791e29666d50993ef3c1cf63cc795f7ff5875cf437ba496a41abfa4545c63ba2347e4786db3207cfc27058efebf67e1c1c7a274a87512dd14f9b32be94c794332b27a8f455b0de543a9fb0a760c21ae9566a35b0fe610985e1a8f65ebe88c6a8ace82cba486ce37903b65e182558d2c228aa1d52c509903b81d56b42ab532291e952b90c882ccc163fc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
