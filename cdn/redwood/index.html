<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"035507cb0f4445878318a77c4d2dcc865634d9f993381d949475f488b7373db88e9a1313ef7fe9ed59b5d18286eea3e48334ff4646a75dd2018b7203f67b0ff0c91b6f7ecebd1c61cf1a70689fa605c2a9c7f3f1685e54c3e678600ba3a4a406e46e68551beed26017ba07ab33db0ddad7bfca9e0e0acafec95f344d15db9c1c015f185c259585f3cd7ec0314e5f9f1d04c6a18e3fabe06d297a3bcfb751bb4bd528970abcd9f07451f9e929a433ebe4a4b3c5748adc46e50d4c44d9d6ccb3419a60c8137b7758c6d165302ffc90a15c95be4b336a41cc71c55e0e2e09b60ff02320f3e700279b0df2a203ef0aa61f5d608565f0569f2889d8eeca09e95c53871b28cdfd613399fa5db48575f56bb0aaba60e611bf101fdb378ba1c0dc2edfb4aa93f665c55a116d6f43145d0b5fce6eaf6ca08407f54aa48231dc9dd4964f2ca77bed8e1a80a1e3ae3c8c53a9a18752d4639b48049995eb1f1dc6013949b0cd82e55589146eb67c9d96113924fac83a171ab9336f747b3e00f752baa9444cf4437b162b3c994b3abc03034333f257bbadc3beac5af1223d4643cf5d324c1882957d38fce3f32af17b2b2c931b0d29419c70342595a69879855680599500529808a255dd28e7cd34ce2b64f7c365b0f7295dec8d15fa95fddc33290b65f56dfd3a314b72d75b2998ef39a9ed3383b2d535fb4e1f19c7dfd33724eab72b5831616245bce859331ad894883f0b2a5197c8a155b1e282a4352c68ed6fbe92400d5aaefa4f2eed972a2f31791393182325d375658b66149a34bf6534ebaba17e4afb28809071b6b350b42b1f89d25cc9ea8949d346b39c47ee32626743d17627c517d123f4b67c28ef4ab6778ed77291e2e4b626ea6e79718ef29cf579047a92dfcd98a306eddde7e62b2e149858f27b3e1410ee693c41a231ecb839ef0394c2832225f367361a340dde253f7c14ee6aca5d41b554de3c5f5e35079441323396a6f5bab5b6cf1c76db5e1ccbbf2c6e4de30093a30a4366eecfe5d39020435a7e727b72a5d24f0ebec1d46bb50abf4eda70a328221d6a66e591873010fecfc16e0335bebd48dfa57ce0aad3888236ce76a225019fcd02ffbb8a5d39db87207ec1804430a2b83226deb02bfdb69b138b2d53a3028e99ce81f144f7809f129b4d8fd454494f289d4bb8167d0fb078e63aaaa4ef802a3a066e0dad21b438293489f41d9da0563cd28c48b03eb99e8152dbbfb8d42a17d5c38ed8ae59dbfe772b4cd7d90749dc9305f6612281128ac2687dd51086a6744142e3a6dee98c04f10e18fa79ed963cc113a732d0b50153eca8647291b429c1ad05c7b13c41426e5290e6732786db28bf01d5ad05ee0edc3971945c5af3807515a0c6f60e7a4b6fda61c4ed9721be56a6e51e255cc4263220ec72a788c2606bf3c6a50d907a28cd4a7ca5cec5123bbad008e4c314cc26b41ce7fff832f9211bacbf5eaf9efd5559a15afb3578dae2839901b9f200b08d4bc05cc9c9810011b2cc8ca94a26e8f0117b46f3d7ea64ec63b39a56231426357d6f5415d463c0403deb58e8e8deedc83080aa23afcbe628a11ceb06c243380be73e550642af5a62202dded14c689e43692ee87d3501e4376374289cdd6d4c8498051f419f788b84cdb28d14b1b5389d44c2854cb19540aded32fcd3b47095bf79ee806f702b5f4a6d23b299f53c17f8011b70f8e03a920be21568d9db1486f0783b15cfb72e7fdf1f19c4d5d867f36f5f09a65a515fe177b4d162fb6e230d5ce4177ec2ca0b81286ec528e114f71a8139846479b6be92bf271147e74abe6760e0ed485ef40eed64acc0a9f3054c70f6583d081bd6cfd39d65fc3f1221d4c61179877c38087ee7ed05693f866198d4e8b799224bad46e86aecb4afcc598bad81610b954642fa1dedba497613fa17f15f4b6becd787586e024eb159e52e6600b2abf1c2be9d73285f625c67b9a0a820a1ecc36675e108a1237758de772d7ebe2b6dcfcd91b9fdba14792052b39b2198a8f12bb5660144f3d31f6d9c71831c168b2f4eaf96dbf307a56381755b1a11371acdad74dcf6195dc891538a00c782fe5eb451bee1c380a708faa7217a476115bd463031326b8ba32bbb300906407d4af83b2a82f9043682e41151fe8315c5421a84e654aee3357fa603ed38c5ec81209da78a2ecd9f04ddc6907697f11670b9f356a0516674319ff35aeb9ade2b4907c3904cf1ce7826bfc06f266847b712b109bc9f587115ee6eb65eceaf7b729fb8cf7efff5d5b37065327e5a79a218a47f738f9050edb09069f9df8d58e4bf1181b3306536c088f42dcf48711d50a323dcd17b6a4543236f22f4449071a80ccde310fdd0551edb6622770d87b401190f8114461821602567eb8bf7efa00def4957b65174c382a6d8f15aab0af8648932b40c94c812aec3ebc150b174023e165f39955502819f560dcb2edf0cf669a9ebcb0651bfedd4606a4ee7d5d053c732f71e5adbe12c89a0c58be02fd6308491c0b34579deea8b107772ce7a82fd929f0d3e7770c67e92129b8f6f0883e2b0c0dd41895a8b4093b0948af026611d41428bc37b91ce121a9bb7a4850358a40e950fe5c76020ab6f051065f434975560a8fcc5804e42d5a31664ba3d3b3e7f4e44a1ccc4c1d37da0bb3e6132efe97cd16b9aedf172dc3f6d33b0188133bc0aaebfcacd180339e56eccbe91d893ab7fe22e22c7cac46d38365c26da91ac232ee1242b01de9413c89e4ce5730dc8a26113563878468950d73ed504608ffd51c35abce028a452138644b00a54db6694b94193364234ed02733f62599325cd37de40518155d08b758750235b2dfa4aba11c78a8be72c6b610b7edd1eeb912989d32702c4dbda9ed28dd916f8c812efaa88a1879333d75906d3a15b63af4dad855998790f31a83d06edd12964cb7329e3f922e9b0f66d1df2255dec10fba46d83f75914f73fc1c4c8645da6f83d5b4fae3487e8dd18eaef8eab1b65cde989d445ff157283ac91a693a6d8f329936768c5adc0b08bf0111df66f8fea518fa00507038fd89f2cac7239e5b9f31514149b62647348c8f91ad0dc87960501e09041758006837c5c71cf588e19e8fba1901212e1425f0ae687cff408ab84c02a3b1ceff3b7f7f7a986d64f42627f9e13836fb1b375bdad712749da0b4afbb5ab43cea6151452a54be5e982dcaf143b5c18e6cf6e188942ab9c42a4481685ce3840986fd9c42a24dd43f28bc2ef88c8678e717cbc4831781d9f8224fce3afb327cb7033b267f8288c0e019a4c504bae4b61a2ab900570befcc40976f63dec693dd0fff809e72b37a0ad7be068f34695481f100b1f4bd02baf80fa5b980674adf2e924c8328e47e6c9dcb95cddbef8d241031a0ab832d56a20bd65e15f9482ceee2a5645e160453a3ab449f608cc1daaf444eb5394e24ee5024a762121b05402d7572805dc2fbc5949bb4d4b0735a331e62b186a7fbf8481a4c85b98174aefd426ba1dd89caaffa266098685bb9529932507665df82cba6064d349639f62dadb90f0223c04952d37de4bc256ae5652389f9c1350a280a43f435a0d96fe5a050c0c6f126acc0057180f0c6a3babea8196180a2a4d157fd8ecc10515c15a73b3276f3b0848992d96392ef78b815eb1c930cfe216aa2f2164dc5ad77fa2f5ca4f9a78637ea47f4461682a729a763198992eeb335d0b75485c6010d0667a4f020f08fdfec8b49d83f4e22ac47fb292098b5cd4d410c55ea57231a396efd07bada04c44b306d412e239cd0e868fff24f551afacf89cc187c2bd0b66157fddc9c8e4f14e35be9ebe55401bbace29e2d26f85360bb5d5ab444577fe72833e489e88a541d3c11fa87b5e0503340658ced873b47c5fa346020f0a6af77d560b2e2d90d7b61ce42476ae9188c23f7ce50f90f6190398f8f867b84950f57cfb4f242c7ee091bb475b08b6ef0ca2232b4833af8d66567ad0ce5128be150564c56d9c34ea6416e61510f8dc2523eaa985ef5271d1459c5f0f0eafccf50943f7cd1255b71b1976a3f0b4f96d78b6a37a598c36e480a2c89dfc061c59afd811061967e72a7a6b7aa161c891a27c59c540f5e74f9d33a0f3e995a3feb8d65fe08f072891d159c4951ed86c328ef4b7803597d9e4243391e5cdb927fc12990a37b4a16d922a335f7f9851a9b408028e94b402b8ad532d8e6b92e24e3dd88fed8d3c15e4e6ccfa067fc322a2ee7c905eaac4cdbd246f7ba174975a7cc988cfa01d60afb125b9fca97655753ba5a14e91f2b2e1e421add8946f7dbe75b78710b034680860f246d08811ac7f1d7c399bbd305c2887e8a2f7eff7859eeed1c601cb6127e06b65436dd22e5a62dfffde813e15e76bab192ed8020fd80933b5f7e4cbacff2975b0515cf7dfc70f4c7a4d6942686d0deaa69163fe4b271e73e564fe6253e5e9b77fa7c4672f4a8c89337c8b283c7582505919da1cf1ebda8c7f6c0e5325dfa6bf9e9514358000e529219e54f8c46a03ea9525184cb04980eab8dbd687b9d624d3496c313d67ff2f01ab91b59c46ac6f347d8e08aa1886db5bb38df08f7dcbff25a9d37a02dd59c996db928fb86909ddfe53eb02036c9e960560c4e29a21356db1a7fdf66a315291b5766fc36a40feef9a5c3fda15286711f0013bbcf2481a7207839705ae3a5bbd5296b3102f98793934bda779ed523d02b4715d7911721d9e9e7f54dfb75451424f62f8534088182da170413eef440c9e9c39823591c185690aecfda2c843c85ecf63db83edbd4491a10a9289dcfa1223274252ae70a183771a3c0be5b1545d038700a653a48fa41e2e536b54361ba1ca0cf8a68498be59b061baf75b03ca383556e127f3cca1cde2dc9f485814ba71b96c683cc7be90c6cdb7d366b167abc3faaa57f42ee7e4eb0dd7f1d5c3c2c7d5bd23d27ee1572408f6b136a6ea4d68b91f42ba4949f84212eb03c6822a74c2e891c7a276a9da65ce9a0a469df1d8467d0486150bd056960bb3e78766168a92d54c55ac6490d7911b5fbba925963fecf53b97701eb2822bca8a0503c8028b95b5c028429a0daa63931bc57482479f550c33b0c2a1b7b45cee9360b474f172cc93af16803194d74867fc224e573b7082cce8b794bc632e56999892202a3f993a3195e12f77eca47694acede71d9869961eba31c33693e505c6a02e533437b276f6a61c99cc62ccefa3241035a5289b67c95c47f894a0b3dd670a4843d6f5125f690e30551f20dfa309c80ce1e67abc5ecef608c8a02a1052578329b6c903ec0792957379692b817bb2e958ff239dbcc9b8b46df769de7ced0b12c4f7b2f93c42b94ad8e759ad4995c29fd5ea18c223c7d1f1ff7f98cc43febc413a87499ba5e946fd738b75da9ff75d3d0cd79f96490c3b39d9e067a6d7df9565e1bb7bc463ece211db7829d881f32a025681b24c81a3dcfb56701a28029b84b56a91c007e0af2564b2b143d6465bc6b918d581c71ffc90b11230dba8745793494c5d34389effc2fb251e15c8af58b89e945cb099527764e5f60017ea0075bb3a44195b676473160e18ab99d3eb22ec4b6ec9184ff832de170c360aed59ef2e5576e6818b5fd8dcc63e7943d548db51d5c15fef01f020bade63eafacaa215038c6248aa5f6f7bffd3f622f734bc27ee09002edcaba5fc4a626691b5566edd72b74a89791ba938d2d189780e7900d666fcaf6b56327925c05d503758bab180ae28033fc6c3ca21bd76f0ee44ff3df82a38a2d125f558f7ca0c52126bb1de08bf843194162d965826c539a7421abe493b5725f12fa95a1c83d333729955fbaeaa96c4ec0cf222711bfcfbfd1d8e7a57e6e3cd4d1dbb06d193ac56acb0160c84b977b4297a2425df2ce11ab45482913b9fc4c7fe2cb1ca29791e049b8fd94571f1addb3d6662277b374ec9b1a24a6ee862b52eadc31e6d3090e70d12cf98b569485470beb8231756a3fa5b310f7837a3957df3cea3af082e2f4468a2fccf37c623aba2dbf7ae22ee1f7ab170201f4d0a9cde12e58247654e2520f0cda262f1032638fb7946e3070f0f8f6b2aad9fd8ed2e30be123adb8f8ed7cde46abae592524d5deb9186b2e44467eee164583999b5745e0c9e4f482239ee80dbd5f4eba414cc9d03e0830051caadf73b88f41ab50f975163ee2ae093268b902c991058cb5f0f7b7b558fc8df5584f303c3fcec7aed7361c1359ef19d9e8d898f1467d32c574a2db1fd765da591f9e5109ae77b59df330908bdac93ba0f6198e7ea2245d8d10e29d6c83b00ec321d796f094676c50bb0c3ff25ad0c14d7198ca141cd48aa4f8a455f6b7a8ba16081f70e3e566c1c0417e13bcec9d42a5dfebee727c78f85dfc697535cf0fbbd37382cea692df3aa780c6c6310076c8186bb05f3829b21fdc1166fcb03eec93e6b301401d1ea2f49598d88c67f1caf2469325aadfe1e333e9b8c008871f2e35a7d0becdd81a1cfea8c2476691da5660aff4faed72a7feed43511c466d6bffd6f93435c6ba78aad1606b0373ef61c4ab1fac2fc4eb2cf0b400530cd339880e73106d58bb4aa84840cdda485c350bf10ae41ab7b9951b1c3700cb2093adbd42384d44820577efcd049ffa9638741e692b242ffbb717bc598b60ba57736df806ea328121d6f12f31d353db95a52f710314a931fb40c39b35c3e5a0449fba11ec7d5b70a0f619faf434e7b6038e961447b9a419e280a1043b6fb8d93998d69cad3bac79629263fc2a1219d8a857e80a7b2c8aaaa2a90778a5d316861c8e4f56737c43da085b54bcfd047d8d0f74d2244124ea8f5cde4009812b1cfca9a1879dcf7c9173f0afc8db62f98d54f2fe6f4cefdc1ec69207a0cd42f5249f19e1812b51d7034adcf9dc553b10c82b4fa54949c64c7b928a3fa45a3b9204013e4e29439773d6607fdbcbc3e9238577e06cd4c0b0a8da8e2be1eab1b3a93467321b9efe7db4a223dd6b27f63f94594c388faa5fb73c00c8d77d12ad1f27db4a52e9cb94257d7b41983f46c7c9a3d45fc686bddaf04ae396e3548a4543ac92a0f22936900e4e679fe807bcbb6e71bf15f079eb19db7b615d1d0cc3dd94b6916e135cbe6a752d115d1760cc1109aae34f7ab71a2cdb6c712eaa6bc4cc1cb110a23f16debcfdfb037bedfc94859ddb76b8b7685176f84e155cfe153df2a822441fbce95a6e7c67fd5d982ceb72fae027ef5c1deb890744e4dd637a4f407e7e69b0a6501d4c3d954430dd49498b62f4c719d25da0559f0eab38da0b81a8418ad672cfea173d28de85b4f49501e5016f100895e51097d7f604a47282f17be882c07b0151531d301e79adb3d985c077f11b45736587db6286c7113bf57706c1119b903e6c226783c8f29265b398a21632bf2ee2fe65cc86a7fc8e5a77cb9a4b45caf51dda9ffe1d07af436bddbc81bec82d05f967bdf421b0f88ecbcc92a73493f8dd8213c6e31b015322fa0798b80453e070084d95759b6664002399711e82c1373184d2993b818a94655de408bde7ca8d45b93ceb04dad9400505dc3996ed30848fdf009fb0539aa83783c728dd3ed66d8bf0d8a661a1d198d75826417d88d2f47848e899fcfd11e586917e39dc0f529d54656818a69320fa81dc0096fc23797032563ed9d837dbceca75c2132e2952fb5ecc084c6d925784cf0f17db9de322390289b0813b287f1392f1f03ff392c7a31edbd26d8a5004b1e8c46e235bd79432a34b7709afd6fe644ec17a3f03750dbccbe751dd68f3482ce851a02e4fae2bf9bf120620ea35aaae6a3b94fc0aeb50fa586b26a4fb0c16ad54d0d12fc6872b061ccd1df2af4f157fb81e3c84c50f0a2d1de5dcd781531120a67c7b18f101c2be593bff43970122b31e08ca6424f87c666e6376be9b8928514bb2fa231f1cd9c7d672466b6f28354b5563f0e214e621af3d6f011cdd46be400f77ebca1420c85f6bc87a7f224b5f66c32f32151d913fcb8cab5b3c8410b1aad960b0c611915a48fbe8b1c960665d874c5eaed8f741c74f624b533247254d9ccd7d738856a426de48831e0c9ce18aabbe3b3354eb83ce158fe703e2c7640886e7826ad38af251bb6795014429500f7891b2b387bd03460d35d6de1655623dbd1a701165aef22323ad2a49069ce632084066100e56d7b7e50d9344f541b12c62d4e0d75a4e164ce7a5827cfe4a20c767fedefc52b610f71ad4b70d4dd71bc8548d33cdaad1abcf14b4d206a3d82ece6f76dd2bff1bdbc06426b350f36172345e6c5cf9cbd1d0cfbfffa8d59c882243f42e25ff7cad5a3646488694717b9c974b8d144a2ed18d12d74ae382308a8351282d24a6e4031c9f9138f550dded4c66a950a8eed9bf967f12d6791e4a52bc49a72dfb938cf40fb715ac796f4c7f39f95dd3f15e7a4e1b6947962387c4f2eb4b9b993573d4f56af77c96d500d770017036c8697ca6c0dcf9d99ab058bb7703da4ecf49b8dc7e427a3428815c9aa08c8846b50492f7f545936e568a09591e54b572d3b11ae8b723638b9a0b5664bfee260724324727cd875190da29a9cba02dff58734e175bd571f6b17ebe9f3a3fd9c2311f9b0f807857cbbd04c5c26730295c8b74e4dcbd58610059bd2fd060d99c24ae4daef65d04e0bd5f510915eab508b7fb484762db8d3570ea3dd62b0933d1bbb852acd50c03832742ac91a288b024be86aca87c8febf116ba33e5d4494fc6506e923b31928118933a8aa50ce74e8958fbffd5a860cc2b9f28abb8339b970575c5bde0821cb637e30b25901785bac619d50fa36c0fa86685d2bb509669112cf5ef5bea5fc162cfdcea36bec647493700750835b29cb251f075bd0366c32e50d83231ca9fa1cdf0c3e28cf3ae8ad769a7ef6825525603e94409cacda08c262cee7a617783524dac966a14c5280d4d8644ccf894d9b29d7edee8641be0f7848d4dc0347d580dc5c7fc377bd64f8d56ff1daf2a363f40d680862dee500877331512c86922ba0ab1a0aa05329e3bdf172f0986646612e036044a3a2a22ecea7cc74d6ddc0e95f9889569d0ae18103e8a5ebdc9baebdde80702026c5a2f989626484f3a3c4088523fe90316a32415568fea4484bfa4a68092de62bd25686b411030f54062411ea1a1b50597392d91091935b8b1865fd8be588a3cb2a6c65b605628ed6e8410c1e0de3be9425fe4ce114638693f780575b0330bd45b6aaf9ee78f934a608b653e743d651c8383bdea42bf6708fa63c97da113dcbd5ea58c263df287f2b0068a24a36e498a6322ad1704a4b8051410d325962ffd40d1a51a1e40429cc039b0c39d9c9e4927f895ce7a1d702c887fbb67460fe93f7fd286c2fb09e83fa77cb6458bb4597bf898c162549b2cb5eb1bdef38093025210d921f803c9520e0b3e72c689ce11a0822e935b8528a2b193c732933375390c6ade1543031cc5f05cfbbf9e42e8ecb98f5a6c03d891c304a35f757cdc9702faf45d0e071119357143cb268b2d0ea06bf8bd4359f293e62a85b488dc41bffdb67af9c3c68d1bddd45ff43ee8e46e0fc813e336574357ed6f70f0870766a2b414583208249af0ea4ac1b4be18a81e1273037f907a6a12b2d79d2aa58b861cc323b234d56868d738eac17be4cdde23b4770e8da56a10e8899fea22d9fe01115d4109d50cdda5327cc65b7fc133324c422302589ff9a600553865c62e63b10f2d6522079793db9f5a57e6e339ba5ee5753dc0fd1d0c4cab336cc915d9132470e9654478e3932904407689ff76bb132dab4ab211b1ebf9b6d7d25c50efb2745fba4b33a0e70392f7c3f1ea1df202675dd54145e4b3afa1604abca49cfcd45bbfa02dc8329914ebf49cbff9ef7fd44f7dfbb880f87af343145610873372e3bf31adfe80b76ddbe109fb88228fbdf0592c45fa7a8f961e464c15fafd278aecee9f1d6d7d49d9eceb7b0a62161355963bcf9447f0840e65be604c84c7694cd6e942f8a77e3f5d6ab823cce5e0f10bcfaa707c87f19b937bb86931c3a7b48de66a89f6bcb46f4b2ca8b5fd9224b713c3690727c7051c69467f585c1723c5acff3732683562be2f481e08e8326abf09446cf540c68e5bd053fc88ecf29d630bd541883d751a73b02d03a79f5b62f0f4e364d20582a5bb04b5c1ff36f54875575fd08baecb92ce3f38ad820c22a60dc5288a37b4314021bc1c7088ac848cf5e6997955bb83778d758a2b8cffda1f8977d6551fbf1b2b58198255ace1292115abeea858dc13e239fe738153e5fe7e91ef25dc20e1acb4d9a4fac15f868f123d5de620f2f610bbaf9cfc35a78ad3c966a5b563da832819c94d7bdecdd33456319073bad2f96f29897e7642e7c9f240d64d98c28fa9ce981f9e939f0686b2a904dc9c9e9d00182d8a2bc58e9b0aaf1b5c0116ec8cfca1fb10613c1de9e96da413ea35e767283ec55b8bd23e5426bac5f4b788554c215b2d5520f40a4d2af9eb74e19b8cb7b2442d204f2d9300d1e4fb5aebb50a492fc7d7b58e6a078fa5e59d983f0add326846bcf0b86074ffd9830863edc924b71be102ccb750a8537d1de360e877a433241a26b90c09556d25a833a38d88dcf475f7384c93c12eb80c97978b212e6e659e80b82526651d6c33b9acaf58cd458b49be2f279867e63e70656fe069af75dc3649283444fb57375b4c3552ddeb1c8b6b53154b9cc037bc87afbef64e816822eb620e42021061f458d5630742789234c9c1b646d950f902f2db8cd5014913e79934252f15f7251efdd10a111e88c33f4685d4c6551cbe31b0957a874f83756b5e031c799c65305bb4442c22ba3947a23af822b5a02f3002ff2c92a3663d3b56c87abad66271b79ffbd4829b76fe6d125223703015d63f6bcace538ade0aea9f4db9c624cd65ef26301bf47df053dd0571352ac147d410982532824dad08cb1829df797be4d817fd0220430a282f2a528d54446f213205b78f487b8a3089b57a9f3d5e4442d8e669219719e6c7ac2b20da62a0f121e52052a87f580d32b6e0c1ba82ffe0f6204cbd85e1cf7ef24196698480a7e42a5b0a813f9440c15e0a6d1ba99cc06f439d72f1d54064c3292c423f6a204348065c83ac3fb650c8a2a9a3060ba9fa3ba1915de184613396cae502285034d6bcd7ffe9a17f98a50696c0b63e77ee73a89ba5c962cc5a0020365eeb0dde3e247582b4e8c8db664530e97a28c87b1c46f276407d009d45701e08b2058bbad2fa343f01f153962dabb09ee14d6f5d159513112602644e1e866a623ecfc694de0d8466a3a2efdbb590a163d356664857933f893b17b0e8f67ceac88383c865e4eb76e044d336b0dedd315b64c0f0801aa8655527c39df815edf26258f60a491097c12e37cd42ad9664f42ad16e5d5194bd4910d14fcabc8975c1e97c6a5f22902261168b3edd896ec46a85d473b38f5031274f3c95e85aeff71e01129dc6a9502d7bb718cdc4e06ebc958ba7cc6fc8827208efca79d5841419bae7a70b9b086a2a48a602b6903f1888e107c7856e3aaaf7d17acf04373240744e3da8ddd72f550529f7b72b58fdf7e58aa7132a2128edd5a8b909db735300283eac3ed908e3082a8299c0fdb234d04d2ce92820231d9178464009c01bc54f2c2ab842debeaed53346f58ab0d78702d8a9347b7494ed727cc46bb6a63baca8ca3d3741a853e1c30010ef9e550aea87c67527d760daa7fab1b8bde27c19d96886ebe6ec3b464f0e7d7772bf2b721d7ab3ec7b0c8a5ced72b081b47edc24625142d019d57b1f8aba126ab4f382b9ebcbf4b1304448800f4e3c1e26563a30d77f3b801166780a92371aff4579a511360ea0fa808ccdc9cd81a69123a637d0b44c66acb750683e5a43f8f1e324f90363415d2c5b23b97e9d985916a18c97bd074cf460e8693517e83291f3d9ce6912d33f5c2501980fb2bcc6ed758c6638760c0fe73c77297288d080fbddd035d3f664c790781f8328c22ff57e03c564b58cca3e2386026863f694f52e79b00797c63a18a571dd50a4236cca5618c3bfdb1ad5958886899204b9ace6a74d1e5a3a4c997f379bc2dab6ddba4c07a47de71ee93f955eb8d26f8a5a3a91b11bb43f658db77deb7e8c71a867314844706897ca0c83656cc068d50cfb035f0ecf4a412b6655c00e5f0507a59e96b6d0e3af3770abeabc4c50e84601e256c582c1fa8b4e2807c1e055121347137f0716b2d811354faf916b94cab5daa8f6fe6f6c3420016087af18a252a7089442bc471e67617c1c41843b69e19659a819b3fe42db53e133207fd447e2314e4b190d32d57ddad92c6d69fdfea722834dc2b24a239b106155d2e2aeb1f3792256a1b81c26821da336726340a038bc2f682f3442ebd5e8f0d347e6ea072fe194085c8f3ab36a9f2d47013de85af495de6e6d63cbdad6279b334a674d3bc1c3b8763c3d72e51e26c164f996c436e584796502a7fc29535e2405a7499dd680ab2b8118260bfa091248ddeaa103d98aa5459103156fedcc538cee9ba453fa30f367bc1916c3ba33aab069ba0c07d4ab540688b0eaa5fbd5e9c57b986947b11d227470d914229fd35e1722df8ce4694c67d3539e92808ee82bd9d81b7dc24d3c845ed3c4309f2f07095794797798a6a6c0d7feb77480e7e23fde69764f114456aab9fd4a521de958ad837c78f5ee73b7603d86457caa99ae1213ab57ebfa840fcad9289ab564e50aabba07054a7a9c1e432ec70886905693b3cd058ba21e50706b0c615e25c3ed961984356cf536fd71ed441c634c29d5d767291acf69d480dde5735681ea63f0b297107afa9213ff795141be1c4da44210b650987701a70e4da648a410822befd281be89d49eb67b2a55f02f2738a057e40c7c1a913377cda0ebf420892af8e94790dd9fe72707ae9b002aa67e4e01e9d2bd07182577daf5429f3053289cb44c9b64f0132f656ccb5733c7bd16c4851ab729a74991d485e5bd17c09db1cf2e240e96e628c50723210457c895e92d81598f7e5beae2d96e0291c9de4db23c4967aaea33cc2439379f21d5cbeaf6d22b2ffa9c5e8c55a87ebc593f8d89e0e6d8957cdf36019d3bd79f8c6453e9f8d23269eb5e01cd9c4b65dd51719454a1a47824675b8058261ca62ad2250770f8e8789236e8b2330f94efbe159345cf976177a02a627759634308453237a72f61bac9ede831d18635c5fc8ef12b6a0bd15a5af8dd19d1eb1c6e4a3c7ad2c4285954ca87f964bec5ae7b2584a1879b08aa7ac41af03f4d03c9553a20c02a764c82ae857bbe1e73c9ae69387d261c865a9df30c318d6f82ddeaee7fde6cfa5d0b8a3ac29bf437e6719f9ac880f1f287246061ae149feb021659c7ebf118d91bddc7e5fc17b046a43fc3f3d7502f589ea2f02721a3b23beee615327b454e73f5f1cc95e8bbfa506a8f3ab66c6855dd3a44c714fefb85c276c596bdfa3d60ea8fd9ef117203359c03996d042b894f02a5bb5cd0de05b31ef6c1a83f4563487078d1fdfe3139632762c6c093010c134e31655a50ab4e4ae8ce7314dd52924b7e401798fa17ee5332a7dc7c20c741b76f7d20a9bc9df13e61fc28ec69cfe1b2e73e0d941861813acaf64d1e349e23c5696780216710f4ce333562eb06f87ff1d89975289dc7fa01837562c135c895dd00d3d88d458c76bad825ac8b994fdcc7c45734712021f1dde55813ac699b10444407be3aa624801cf8924945a052fe06ec43d952c90bf1e76a8753ebeae34dc526c8204201372404306ea8bd69118e4375bb0afdf97cf1d5ce51ad773e48e781c99193e713dd168d53779e565847dbd8b46e9388c4b76b6202b1dd9c6c99bccdf482e4003f36aeb3b3bcad577f4b4feaa79bd16fa61c14ebdccc09a7fddf0b0840b58412601949e08267d2892cd641373819f228ee46d058118ef9a9e6674b0bc251ad8f6922d2483bf8a1f0c09b3291b1bd47759706dae954ea2a1e04d42c60073554797592ada6be38d4d0324ac3a59f53f9f671fbd0988b2d5b078e7b4b700d2fedc9053b17b7edbe153c274258e3e34ae7901e9c3b9f8b97cc1a76326194bff538d0dcceb61d8e2a14cdf68eeabb3a14cd5984f7f8b2e6290c82012de852dd20dfea2019cd195f3ad0e5044e7ffc7634170262ca140d80070daa549c9b8280aeb8578f7b939afcae3ab156e9bcc48fb422fcf3bc4510ae98e89974c87c31b7369c5955c4603bd5521a05fd8ad9708f2c9340e135e5f90ccfed0ac08cbd42a3bc2444335a3187a2404d9989db14bd500c7d7858d861efd64ccc35cd69f9c10a0b8b929d53dceccf6020699cac64a1543c893913a5555afcdfb5fed7ac2e6a2751a83f529c60bcc7e3aab7687eb47b5cb6c463183bcb1d03b1f73043e49404fd3839d54d5b1cb3ef374828508147b67e77c310308929c1d3297a912b1824e6cb4bedb1766d0618c9faf252ed01560a60543445d6fae42d5b46ee766be7a76eaf3bb564208545f39a45efb505274221d312ebd6382f5b6a374989c7697b4f22d74780c6a62c16108936b4e1f96107ca5e107895d1d399baf590bf76724e00568883078af5bc422fdd84a74de1bc04635975f12a2206278b0843c50ebcd653d4c11557e02dd4ca60164bd3b06be55f35e953569d296605cacbf16b09a334c64e4a830cde5446e6e98f4a027d3e5e1b0ffa5c2d842b6b2c2c7a20818ec8108608e397d2847fe223d4a20921e6536bc757f8406de346814639e8c231be907705cfc3ded188b87f781c495fd2c9fd4b8c41ec63c8bab0feef138cc76e4413be2c70e36a0b3670689ec9b933cac4fc59e7fff6ca6b49950dac0f6d1448785d6490206feb376df6611cc0b38d9310409546f132a8b331edb0c8379b2e75cae1b3dbb0873c6bc213fee24e64e9db981e187c7cf33c8fffd09617f874a237817b6943cbb87f5fdffcab7e8be1bf949b051d6313b43411cad297468c153793e78b47b0c6fa8f3f332fd387043ca096e2d26efd43d5fbac790cdf0c71031d3d361a77c3f169870e4a2e64da9a5a6f4693ade378be55706eeeae9e112078f9bc496ebd5b7120e334b620c1bc7aa0497e0b1f405b10a7fc3c1f7aeba1674b8facb9a80dcf58176fcd70568d6db6d50540b9746a1b9a48ac9c65cdc02a9ff84731ff7ef9250b665d9d0385a0e97bb008f4c37541de3c7f86eb2b0ae887c90f978153bb3e26f70160b7bf62aece0f43d20a127c4107fe770f01e35c190711706eba5a10aae3b176763236cbc6ca81d0e9108cd57b3f85cf4b5b921429858cd39f2686e3d2bc31aa4b35d2e172d5ae66fb2860c47f0565fd3a48ab3126b0076484e6565245ca835795e7438abca3df5d06dca32592534a92c69828b57b0b5a344ae2b2467d3b9905611a65e91ff65c14f64a6cb5ceec88726bc999b7f6e4e87eb8e020a63aa81f51f732a4091d72bb6fa770c292a38b71885e15551f7749baf6ee8d13aeebd264c63b6b4bed653f86b1b9cc26ff8127b25cfdf521db233e6b6e343f438b2ca525d4cebbb9ce56ac73112441f271944792377c26cc8429750d4516ce00dab7622f112c184bd464407a454dd9ad82e60e1ecc6fa72e06dd0646bf990ca1268b117884bbc36e3f7115dd7ba91af4808cf7ef3d818289ed1869893d919b3c95b3cd7ffebcd51f3f848101ae21d9af852986209dcb888eaf2c14d7277289be37485ed3d25919262fd7bfe13940bcb2b6351498023dc77ce43fef25a2d684330a75a9f5044117f9dc878de153c63b263cad7a820ca5387f04ebd9d4f6ee9de3be51cca746bc3c856549f0dfd0419e1a2e70d613560feb86cd25b6d1f4461a6ae1fc11b235b08697b34925c3dfeda66d4361041a274547aaaa5f9484cea46b7a21e17f27574658fbfec3d9305a0b925fb738776c7f2c4340f7bd244b2d54d2d38a81d98d9bb3e8d06ffc8faf31dc0e4306470907746d8d4f429fca72eb26708c346596454ea0c68e98dcbe585c1eaf3960f8ce0708df4ebf8be5a850efe41403efaed2b7cde59122efff66f9ccef5a69dedbc55872606926ef2dd93bc8ba4104d8f277c67d6b46eba91f311589be7fced7607f7c13736fa6b7f079d81428ed8ed5616bbf42b1690fd21d12a9e2119d60f6171dd99fde9701e5fabf40961ce5ea838b06ebb01426c95e2e2b80d2dcdc8542b51335282db326803dc54282058d02632760ffe8a5a49ace1f0b812233ed59b0db23ad409185de8681bd0eb95a6348a4e9363ef0c745f0c903b4dc7b643bf16ec46f9ba9eb018b1c871cedb59b38de85056bc3d79cdf6bb67f0ce3fc5585347a0bb9559ce434b0d810d18bbb1e1cab7b67f00d1a1971987188d3d371bba7c79582c90548daa45a4bfd2d3e3d1ecb7d48f40980964c2df540e5c2550f39e1538987758889ece63e325c34525f154c56017988e61af6b7236a8c0563f16f79e7913b14d1f899aab01ebbc5dc5908993093f6412fc17a00df653f2d3a102dbb24a76321450e1f5a9bae92c6bdb6cb321ab12ea47e8cfb9480c8d55314e624e8a90ac993ceb9c944f67252b132bcf6ca5050ad0e676f07ecee540d9204834a52f9f8036982bc6c64128b9e07a7750866d0251e3cdc675c1242b3115c80a1cf57b7e156e96586548dabc47ab2cbf2a57f76f133f0fdd0be8143e03bd431f56309c26fdc959cfb5240585946e0b2dea23ed0f3a6b639eea4eee658ddac03a6a391eaffb6c2643ca7e03d80862c56aaafdecf9442770bb4dd1ba63e346bac2f70a38928e44880c435acb26e035047a669d2d3e43b33694874aa29477757439c15c7746b7997db214f201b8b69ca95e934a36bf3982421fedd40fa1300c75aeb4faf372fa7deef16d4efb80a4a7227a0851ed7e39eeee22e9557505963304dc312e0a4efdddb65d72a00146ea6d8350cb978563ab7bf449a89294c561fb8d886d80134fc8b0b6405c0dab94e4f1efe10223bde7a19fe5b287a1f6dc40abce55bb09e5529b3f36f2187565a7512a240a520dd96a27469fcf3b2f7781bdf97f3b45a94d4bc3157db63e96120ab35493cd99d8775b17935f55e4fbdafe029b45bd75e6d7a7e05ba0d218f73cf15ad5a11603067d5d377e1b04aeacb6b6351f4711aa81b9a4246311b6a63553b2a6acfbd1bb83a81e1479a1131fd078cba584f6e89558b7ce8fc9e33aebced37b27a58276c1a7800a7c35a5fd1c5fad83bb50d6d88e6040f1cb9438c5858c0882ce478adf222c00366c9238aa5889fb34e1151df11653cae91bd0549f40a8fc355b6c04b55b01b552b050bbbe15c7e7e75748e84df2b51f15c2231c41bf1d9112254a1ddca0f876d802a089764a649ca9fd6e240882b7fc3f432d9bece323731384f448bea0c544fc1ce25721bdcc7125f41f15e386b3398649c592c44d8cd3e1d3511aa8b17af24ff2e80524d4d71ba06e187a6707351bcce0a46bc97597f9d6585dcf7b9f94aefed0281f9ef64b4ac3bd2ac17343d418b8c1bc693814172ef11773dfce82f0a0636a39a5632f772679019350a5313731b870c368a3cc9b586faa8c5e73c40aaaff97a4171a1eef3f5af40b4413ad0f1428d851a6e77da5ebd6fab7fc95b451617dc1a3ae641dddf57e8f3c73338aea155942c3edd8e1c1ba5af2ae56c6563c0a2ad410b92bf8fb08a90c4bd20b95039bce43290788f56ad144755443d6e28c71f46af5e8ee347e2c4b562ac3343e8b3e32dc5f3466ced2b543fc9af9560680a53abd49b731147b729f973c3f8d5db8b72e25086fe2d168ea6cfb5b3903081994ba31fb7cc7c34513fe769e529dcec2ff974f378448149346f068689a02e10f7d55b28110e811d8b37540e96ab9a0f88515a531fd2ac1973c132e5f546736f62eb99a4ddf428f817fdebcc946873d24be0cfc6847e59a510a7b2f8696f0cc83202ac8394bb5ca1488b301ec93c2825e6ea08e50b0061fd5f88db0f28b413fb5939a2d23cfc4672738c81da5495a0bceb9e10f5bd2de0d67f193848589d2c9af2aec6ecb0ea5ae8faf376499518e1a4287941bab3ed204e4f11a78250d9ec36e2b6d75882266","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
