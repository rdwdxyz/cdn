<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7191813706fb400227599f29e92455a06aedb9ea8fffebeb340235bf383f4eb473121ba7025a6bcc08c8f3d594182e669b860a2b623a9a93825f444e22b51aa842ea52f387cf63be36311d8067b8ab01573118d017114c7bc3cfd911f4ef6a28ead0bcee08a2d9ae0a1896319bfe0101bb1242013af72b305758a3b32ad67c70befba635800a98477f123b667865b881ddf10c104a13d0dabf4b227f0024dd0ff0f2cbb0c2fae051ef5239b731d96d2fb1a574f0bacbf95390c15a263dac64af8da9e9a5f4a43b3b328765e6d22905c0fe8098e3546db0180b77a3a52e3c83ae75ea2c18447c1e04d4652d74f658d92eed578e561f4b46a595c78a1cdeb62fb70699df47eb2cb70dcabb98318b0051276b481f8d77c9e9884e1a9ef11eaea2adac764bd7b4e3feb97807ef194b0de12c666167f9a5013ef7fdfb4bab7293502c86d74d43476be133aa2cb0a0a5d64b15e26b70bf082e58757b3afd9c1e24b48836054f410ece8fccb74ada4c05f200da120bbeaf4015b0e3444587983a83487d5c759c118558705302c0ebe8ab0b9c0fccf7aad33183e6fbc6efb8d7f8bab7a3f7a436c39aa443a7291efc1f43c8623c9fb56bdc81b50eaf9fef852ff4cb3d9ce88e8085727c0225c7249ec82383eefe143c09d244ec07b6bcff3a3b2cea4cbc08447fe96c98c9145096456846348d59b61db508a728a1ad685c7e5e051639ac6575c5d3048e82e699270201178382634b83c8f6731c8f915c8ad811599d3a91301106eeae77381604150cf840e54e437ea82c62aeb5410778f1152dadad7e13ca4934be3a86ad81413409190d82e8cbf6704399821c982095615936a193fcf8452360bed56fca8697a3b5b22d0bb12214e88d54980201162dec76c726a225de9bb89415e55494c54a6beb880e02feb5a06ff400dae263b8338f140f4b3dff20b913d2f1440ecb7867dcf2a701993e6347f7db014c2a29a6b7b8c09d1b6f281ab2ab68ca39388d5922e1b6ccb4e0d291d76126394036877efc8627adbbece33eaa8304e2b4b2766acc0ff79d27c154da1fc3281bef22d660e575ce77b9df9f6904ec37f41c51f8eaeec776079d59edd5f2d1f731420f0a03e0dbcb7ccef94ea9c683a94e199608604661d1d628259c3e47be637ef32a5c2fc9b0317cf0ddf13d6636ecf3d48b3c7d340e5b074e60ab1e19948658372e5e797c4f29d482603082846edfd94a358d15875a008348b3fb3677ed33f3268018878422c7f3d1af7776e78931000ace04117a1950be29dc25872a9cdb11216e28365c6a41ad290351bf220b6c970f5aada3d7aa87d17d4cfb6df94daad292578cde2fcad9fcc3885bf66768f0aa6fa9835f4b46f04870caf47942472750dec010ab924684d62e023a65bdd4f58528c80eb1bcd70a3d98cf0479942c15d1af164661f37778f3560e17a7232a165cb8478fe5abef1b213b6715ba4834c444526a46fa940d557ac09a158de4638d22016cd8a76dde2285907b5a0d70176b4d05a9011d3adc972a4a4b0c8a29311d2e240cc3fbe43f8c0d012bb99317afa412af58f07c3c6f4b3bb89218fd26d870da2a45b724641f3b32a9922370f0ab4abe29e92c482083a5e0a03776ce42658d9f2a048daf2bb5d710d2b2a77a80e45aa34ca1bc2e949b7330d83faa1e2eb3e168add8976a5dd2f678583dde1ab0e1ca7891d3ad419d2e189412e14a49b9dbaf9c214df67d91b407eb48146c3cbe113190d18879301e72e7850b7518db7c1bb4401d91b092c51a11ec11e83b15fa711d3c3ccfdc40ed59285cb6f991dc38111320e0fb1ee693cf7cd3c7eada019f89e92879f85717ce449682f7efa1c88faf15ccda6c94e515326439e1b1977c93e63bff8b2add94530155029c7ead822dedb15c2668ce348fc371afb72179037ed8a94a599501952e62a66855c6f23f8482813ec3a0911b5bd770049b78bbe9970c86403c00fc98d48e7ee35b850da83d3474478cbeb856a961b520cd4fcf8f106f3f4520b21f774f8807808f7c9757bf0fdd16ee38bd5c55739c6eacb2c7b8a740151d5ba5294c947958b226b2a1111519b231d552a0a755e3e4be6717b58e04c301ef0ab27d6ae89ce40e511d8554605549144782345e64dd6283dfc7d422e301daf07b26832af4233c22b0f825dce08dbaf769fd6beffcb7bdc8b19104e977e2c32647bc2387904e74162f2fbd1757aafc9995e626f42af309b0635d729f61631eb46927f5026be62ebb52dba4d3c5416105fadf75a44e5f490cba0d2ac2e9c94aac7c56eb6f1dc02ded6d5a99342e82a79dbc129ae6fa542897dd3b6d7fcfdc2460aa2b6d0b1f53504aab8e4732e8b916b80b4c8795bdf724453d036cfefce07713b9e5be84236bc6358040ff58a35aed7b1e77e3aaa853caa84e267ac4e5a725e927ca9e13ce2572fe01887636e7802bd0908ffe5d3e73382dec000a194abff3bbb1e9b98fc491c4d4a5359fd51d1d7ca26722f653fa0881798f078dd52e548e04a47cd3e19f0e6a2934cfb6c50ef1af766e843a91f3392063f625249c07e34265902197b2fe24ec5c821cf2e94783c03c3ed91e812376636bc25d347fefb482b3dfc52a1605668f444fc67d43149b93fc57e5aa34ca326b10eeaf73a50ce13fb1085b9ff43b473a2ce3024885a27d391ed277e60a66053544ad8f624b5b0e0623063cd22037578fb54f2aa3b5ea4fd32bb5f773f8048cedaea8708df371a111afb5cb937d58e220bb28400905788d7254c2a487561c25f197f98d2b474efd1dd1a5fdc2ad36945d1d3ac01ee4c33c0e31774b7bd491da9aef18a3bc218eeb0263bf9b3d1c79c73d40db805a598dd41c9e5a3d1730b406aa7c02047e40f49deb56df87615514dd3ddaab66be5264ad2fed634b28abc1f6886b45ca0405f01cb0824406e6de8e88615fcef92e93eb4b26f839cd8972be6f28626fc84319c455db3424adc218651dacc1c10213cc5f69ad0b76304194ed9b070e31552b24bccfa0f83eb7196413aa75f09b11488cea2382e7b6c61b5fd84c668c14bea2f09596504123a89c7f6eb9e0c0e3862602e50c441fbe9459fd0a3392f88059d3bc83dac0bc437acc767d00f185d97bd4cd842d0c3360f85b63585a9e59f312ddcba31b75962550470f4cc769505de8b4ce055630617eb771995b4442da2fa805d770a22d48c24e09f52c717f9a776ba30e33dcb14de6edb4f8e41bbf2923c7e1bd19320c96105c065c28fd6da62b9e4dc53fb096e9ca67198d0196c45437efc69733b6b6b05527eecacd50d5acc70456553bb2113aa9be4df4fc68803e6b5b7860a89b055fafddf359f8a45127cfe643fd09d57d70d439245c77f1845080e5038e0c042a8daf2754ef403a382b3cf52170e68ff03c495c2e0ab6f5ac8aef86bcad1b9992ee723ad2a18735da155a7cd33749bee58cf1f68bd27b3f31fe76adf10dac29a69adddb008c3d5806dad2dd9e150d98962fbfb28e1a1edc13f158cbb00b505471ce67ee0f36160d1bb7004cfc55cbe6013a382fd4e002109ce5c018f439a0801cd0062b1f9e158130b89a2932b477dffa7a12ec10cff001b691d924a8f34c6ccfff003eae98383286279ecf9a068aa5a1f12fbedea0b34ebc6d3e4b2f70a6842899103ead96ceeae2586ba6f74dd9cdd5d7330d5d3ed1f639fd5fa544bd165b69919d0e664d7b23c60bdffaf4d1efdab4d681ca3736662529785fabdb6f5668757172de07397e17de86c053ba7aa274df0904b87e41f2f709f29889f9f18ebd26b7ed1f9128afe40394d848a0b645c58b7f132373b9febc9f9b094044cd8a30c83d1f1498513aff56410331abd5864cb37e08820dad30be3cbfeeaa6ab3fe99926ef6617e93316deba3255b7fec91300984c46e0e476b8192214b83b94e23e182c383e8c07f87ebb240dce580af2410aa17221f7c54a5f2f41d961f75feabb32ed9a323b3df24afcb19de9736232b85e91700696cc0e57367dd6f7e096403882a95c7a1e41177f7ac011401f367260839b316684737497cb9da54114e55e2894289332a1abf9ccae7f7ca725a15169d4f74925acf89c21b4c3afda953d53dedd41d982d934b269ab54279af47d959b6b842e39f393c46895c9923044c2848bd231e1efe8b00cb6324a44a6ff9d294e6cd8a5e05d1a566bb59ab494848bb27c67f76713b028ac7e8a5e3f9b669f0fb68e387dbdb1b2ff0c072912ed5fd94a378d9c3b8df785454741646b8fd8abff9fbfcf5b5d1bc6b337fc9727eb310bd2ec938d7425e1daeae7796ee35bec98df74eb1e4f7e9ed61ad1ad4405caf17032a064f0a961b832156a76c436e51a3950817b594c2db781518abbcce46ee0bddbf0d93c84afd2105e9b60e7777b8b723f2ea4123e0217ab1e890bd8ea83e9366cea2e70448c62509e7028d76dca9752d94a4e650f8af4a1d027c7ce0b5a3deea563daba4667a91301a1f44598ffc8071adbbe4e7efc4d512487918e2e19cca0cf3e7d24c371abeb2346bbbcfb1e85e6bf6046b722587c0ea1e029150ec5487b60ad29cf20990c9f6b192606d107cfba850f8261d51be3a22bf3c1aaf5796b21402a4669d0dd23847195f132ae0cd250fb46c2f5126302161a7172368e60ea4a5621fc2530a2cf532f39669df41758c7fafafd4f1224e5e4c5eb21304abf468a2c0af4d379ddb6f08e72ff1761c065b68f082900d85903006bb0426a7705dacbdb2dbf0ccd8c8202bb74c59eef18c078c948f3b31e054436a21e1f584c22e5c1954283abb5b91c81ce7cff09bcc6af2167baf21f07c6133010e73320a44e6b17eabd374382f39d5d8a89431225a620ce0cf8298f282e6db68577c32328323e667100e94032d9449eb3bf78f8f0adeabfb3b83b9082c049756ebe918453ddf37a9e5b14d7437a4fbb054e5d16a93fdd7c631985f1c6c5807f37478bf4c0fdb50edf955dfcb79d5e42e42e503feaea5c780133ccb106356d977fbc57cd0496ad3773b74a56473633632574c5cabb9f93caa141b498e51d952d3316eddf11bbf46e1f89f974fb489baab86723014495b87fb7b66ca9ca0bd66fb30707e44ac4eff2cda2563b8541b636590b3aa69c03150499cd5d00647c0ce24ac69c51b9be5a5b848c68f64ad4e33fc94a6c0bbd4587de0b6d6978fb8b40f754aec2e6deec48820d0c67184274cc338d80d63ed876921f7da5826fec6fcfebeace93fe1e589f8a2a55f677cb2f7de56a77233f3cc081965bfbc6e49e127c26ab774fdc798bd459730d8e0132e59f30bf24f1823c032f2564ffcb4f84d2d19823c7108307df923e7d1a2d46510e351a1db6e34e70510747e52c79e709cfb1e648ab12933bbadadb96880f48e05f89ab4b5564956438f96f88d014b8ee0d7877a9b6269551641b34d2a8c38a05b205ae3d9512a052d7af1532ff989896f5610bb8246a2bf45d944553385e39a2619f9fce22d78334dd2e3fad45dbe6494cefc20e6909095e7aff2465b2207b98b01bd087d4d8a2389d6c829e4c96eb5d2c1ddf402af4ab374ea65a05b67d8828fdf56555ffa0495e65392123bf4f05ea724c25dfe322464cf40ec7dccdd9fd39980a3f9555c37c3e7e815d36d7f39fc7343ecb2c684b740c3e5ee53840aa26089c6e6b2345b0fb1568bcee3daae6b55176f2ecb98d0ff5c56da3f00f6555e5ef3fa63630585f9285c152cd5cbc0c41960887d8773085ae647c95a8f338f32a35f038d48a39ad4bbdeb7e12946f4ef50b8e77d6070d9ad3026f3cc4b0f718a5f672b4c93690886d5d0a7c75f1753a6688776557a791a555d1f8662848f197a620fe8fab3c8f42d7e7351317218db2da64c4d63152c721f36bea25f774735359868b3b564db237427a715bd0e12ee5ceefa838b7afcef899f92a4b509928ac7d659d8fea54fc1778bcac9d061c7a93d630b649607bd752906a321b2d260659d065e557ed30ebd423a50a533b14dbe002cbc5a107c0647de69a264f7fe427a4a6a614d7e7e73c84bd8f89d6407779493ce9e6f230973c05265cfae1d3c9ade6ccdfaef818e7f28d88e74f2f01232d16e671a3a37a1b0e3cd9667b8befa85e6e06f93805864e344cc7de2916dfd32c407e9ffc256d2e7add317556bae776f219a6dda3be4cb276fa831e6949fb93f441d84e2a198d4725ad8d2c9b7bbdea1d030e20585cbb6a92097214cc26ed1969285b3d406ee7a1a959012ef610fc5f76ce5805fce90ef9ef319ff9343147a1954b1a0aca07397974bbf6e2b68bb5b30e0e7d02bacd6cd14d527e33d874fd160ca9f05ba56f33ce601de3db7d4137504f2d79a6242a7fdad9ab7ea79bf669e744923637ce0699ee32af515e8daeac886dbc6819c726972d6c39a174978e126cfa2821b1a3c5a75a2e1a2f7c332cee119cf5bdfea647d978dada79bd81ccf4250100426a4f78360ad2babd0d8835672c308949623addc92873cc94b3bacd765a6b471ebb90b638dc6561cd55b28b28e99fb66bb92d783dcf43c8b73d9e6fda617f92d91dde7fc2b011002d10bd69f5ef220b9a91a01a6355f36557b786d6c11a88845a8eb865609a2e3a9f2b3070a1d85f6fa9ac304312d9887c02fc279c559aa1a4efb0ca1d8e4b5e183737983f1ecfe6784f794b8ba5a42b5547d31af8b37f1fcd39287779af4db87e34f695efa0a0f84cffc5a6367bf0bc85ddd554e575439c4d2ad51dc36c826ee6fbeb3d7083ce6a616e05733e2626ec5ee48be59b973c3a1ae791bb5d84d36eea278320b87244328a4c0a317b8dcede3fc1a83e33478f48ebbefcac38236a7018884eb41a5fded6896deef92e9243b2603b232122442a38badb729e175e25ac9f5c45980c18e26531a1c4210d08c08c2334f773d903c8adeb6de9fb1580c565fb5146520bedf67edf2817c64a2e2928b96a4f6ba3f7b9b43a4eec090ba7d2d3b64a6535d2342380ea1ffb7ccf35d649a54f2d710891daca3ab4cd34189fda5a9a3ab6431c3d0a3ff1c438c49ee267c75996cb5890a2ab76419b858bf8efb9e3ea918b4435267e34af3642eaa9d51370cc3acae9d4c50ea000ab5c0f70b59a5f7885aaf827df76c69f0ab8a760e2dc36dcc900e3f6697f963e526d4b9168f78d377f3314ac677bbac59d7ae1b99016d2e88aeeac7fd0ca546de2edeb688014c9149b8eb9ca454c4b7185ac6999071a91b3c5b647a85805fff3223d938002929c6d843cd20437aee85a19af7d76168a3bb4ccc73d429650bc174e9305a572b88a6639a66a5c985b7ec4a178642f4c7d552f596822ccc2a459d766de9f19ffb128d9df887998dc7525512bfa70cab82873f4cacb0cae7eded5b64de0fa869af0c2b59ce4e3394af49d3a3728fa86f3bb71db1bd7354e67964d6d9d34b10309e99dd5f535f7f906d7acc327a6fe287b29897333f48358eb4beb9f20d780bf11b209e168c8f082bb9929bf4d45a5d1d2b14b9e583ff1cc801c2de6c25334e518c008252d26dfed5f866f7f4f9a118017a87e47d36aa680001c84113d13b358cc85382f178fd009c3c4c33eff063b98d52d5a6cfec19f2fccc6341bb0c7d2c64e269a9e08e55c24dbebc5624b9a1d4bd07c2612c08b60dd4e6e76186f4b21487cbc6c853bfc80a91fd50ee1ad324395beccfbfc1c64a7d69c77b74716151d1cf22abedf79b0ed959987ee3e792242b69e821b7f091832091a597e80073196c031b470f0a7a3c2740b47b130f6958a43dcb5ac7cce22fa11857bf797e0df6e5340767977dabf27f502448d29520439ae0f9691cf807186fe3cdf897fbfca2b913cfc67cfd6857d34ac3e59f88e4e949840053e92b6a36053a599dec28e54ba3cf04b2d72db10520b2de0831e4207fce39b4c885e47dcbf74059f2d2cc87cb16c76d511a3414ad361b89d89fccb495a6be8ea4b947f2fa59e84510c2ff7536c5bb07bda7f54268e621426d40cb2bc286daf7d45348e17004aff9a3621e34086b470d0b3aee44c2713b7470edfabdc4cb4906bd9c265c7d0d455119ec505b3f95b88523d7063301b58426c0b51c6c3ab4c97631193802d0ce0dc9f1b52946b5f10fc910cee88ad275d5c2bd99d5f264efd9d104a9f6109e9baf87aaa3cc34f251e07fc890789c15f9800c6bf830ef68e5ba7174c9e38d68608c841c70542bcee80c7a5832748f9e8a3da8ff8c58c7c086406986662545ef5e535bf7213b86fbf0c7511fda134bb88aa690040b3e0e5da97867e0350698b92f9cf57d5a31aed041f38ccfe8f68dd3f3608b2df5ddf09960d89ddab4ca8343d90548b5c89bd64a632d27bd4878d827d81e46a90dc294957d58d8bb277acf8e1ccb8931493820ea8c08542054be59b96ade883eb87ae3ce3888effc13b8c0b8bebb29030b0b5ca5377767c596d67fa079d19a0f4d1a6d2b03578326e91f3765ca4c9aeb353b69b404279d6249bda46d0fb83b60889ce23eb6e8cbbee9a64e55cfcb6ef5c0feed55b7dbf0eccbfd61808a59bbcbd47e6c2127f72d8e635b7d1c3e46d2fab012a7ae90c87726624c66e9c47308c1dfa790929de3cc29be543b2ddb6cf6c406e3dd04205436014dad58b9628bf68ad94cdcd85db0843df6306bc1c0c46c0bae5b24fa90945ef0ac1a0bca5c929814d1a32a9f0cca72a4c1f620107ebceaf9e1fec26e21c7d510298430341d2e64ded0003ede9fdcb4732b771b70c8082f681a1b27ff8f3c87f52975e668c4372a896a4d1ad1b2f6b0ba9da308131ebbb2d59b4dd8b6ee4d18b31464eed1b699d514c9b56343c0ca5753226cf0597b21e39fa43067512b697004e50e1a0d174c5ae9e1bcd9603d29562a081b60a88e7e668bdc0b7cd0568d415e532c98ef7c58a1bc8c050c9e0f4afa2c0b51cbaf3d48fae5379b05a8d881ed996e7d078aceb5f7ce3e622c9a437893dace9ba0516439244cf44229f6e7d113187d550cc458d7b22d491ee5908c168bba0cc0e50d9aa9b69c792fd5933dfc1946521691a1ae79b3248bf791ca9278e7855cff1b3aa560b658f0206eba73da5e78b7cddb9365db3748dd5a35ec15226fd4af2fb7dceea4ffe578bf00688b39638f21cde1c752f182134a162172d2e3fe0a9af96ddb52a1ae619b65bcc873ebd3248e07f97f481c3a511a5d24136054fca04531df59cde326eb20e894ba25ff7aac7826ed059a59ac123258727155cdf128634de700abdf6924dad9c366e7f78fe4fbd7d9ead7f1c5ca96669b19541194e9aca1ce9b14f1e216b4d6b9d7a22cd2e506583261cd86990cbc9bb38cbcfd4c8f773629040dd92596be563c4d05a361fb851a22ee94d28ac74be6192f8d7cdbfd9196473cc2b93002839beefcd3942414f85040c1ae7a62ed96336d23dc17131c530cb53c1cf95a34202dbf1044b4f9f5dab4b1d2745f454bf54ad9e8305ae3056d50a1f1f8b91d39e6e5742646a1cfd155a3a1aa315bbae50940ebfd192416bfa4a01b48f4dd76cc43af651679f247a57bc9af877c873cc2bdb040c4de56b0eee4665c3616b2422a8b201c3a9abddfe9cfef4cf754e9790c823876e6888d0099cc133362c6926966573b315bcf4af3abb44fa16aac8f159aeb6fdba47d02dd2ce9f3623898846f6ffba2cb3ba94e71143c4e4fb684cd5c302612f8af3a5ff52aa124690f5e09ff48723562710dbe90a5d374413e03585bfad9f07c2f18e480a4e7420375ce54e921b2aab78368e0fdea261bc02ce23a58feb062702f37447e599f8103421efceb41ff41c864a12ce7dba326b584e81adb76d30ed58b9c760639342f34ef47d976342841311c7998da45ad3a24c01717118d1b715bda8ca5ade8716ddcb84c960147f3c83f645f49f5d564e6bb20db9067dfd9e49fe05394757e65dc60edbe0cd1eacf00d7f19819d41229a18b27f54cf188f61500dfdba93c61b7abeff2670e127e6bfa06b5091bc154e03ccc247e5c44e37149579d2168df8737b695577dbaaf48c2fce47cb1d714d0b3d101544d535195cb93edadd6b9f515a1e8cf0202547da43c9080b38c6b021b803b27324ced7b5762a8cc8089efcb680f440850275116f4cdf22ca4a6a7090d4fd7ded49757efad00bffdb96bff49a84f4a2c5e9efeee5f1626ab275894032502f7e3d5bd63d2bf0abbdcc11503b244a58fa767c13d8754a0be7cc3cf1789a548c68302567ff628a4f49329e06f5064ff35e3ea22883a768a7a98d53e7e19b347fc491c86eb47477b3923fbd0cd8a4d7bf9174998b2eec86fb4fcb1231d3dc5f1be81c3b9321c05d2ce1a100d8437a6e0395926974e804dd8bebb27de79f01c19e2b3b5aac879a2b81fe03751aa1d187cf62702593ade0e465a98f913575a1a05a2512cba4b057d6e334b344cd47e4e4f4dec43174c9e1017aebcf1ada1cbb2ca26c9ac091ea8fb753885d3593e916b5581936b8487da3615d93fa3f24fa5ddb4683193ae881b2cd85a968afd99d67a63cf0e6d3121d81a12842799171effe6fd10d9f1efaea014a18b3b3f720c08278426b97048534835f4bb8dbdc35d576d4e5c695822cbda34e87a2d8ed07ae56ed9b0aa4c8d23f1f3b62c0aa48c2db90e3283e455c03e0f6f2e33695882d799b8b4bf35941c0bd2706ef04b53c201bedd02263ffc357c90e42c49964779ec6bc43363e9ad405ff24087b8cf5b932e0a307ba643ac2251ae8876d51ebfc81f76629c31225f513226b06cb3a914610209a05ee090b6e69dd950232999da060610902d4fb3bdbbaccf9c535a7ed40dd8f462a17d537e43d138abb4bfa87faa0d641e54d88a05adced02046b86db1f2d7ddaae06a49c4b36c61fc39523f5e640cadb46f9bfd73910691bbb3943f07f8848c5e6aae4d291a225201d841c3e8f959edb72fe45e4d4ee98f437948c648389c8640190606606460bf823c1eaa923b7bb7ce2698f34fe3a397e27e10c764e031401fbaaf6bad6549fa61283b2eec06f993d43e3d8fb9f9ca619a147cc9667c4557e322ffacf8bffbc9e77dd413603816745942032c4317a974756aa5fa098b90969c9da0103bb6d11ffcc640db086717bae8b4893fb408f958b11256359274fa8429169c8fab7e1be4126e2b01c7b7e99591c0fa7ea33a1ce162b32e808207a0a2d4c2b04bf44515af54ff3b9c9dfdb526e25f6542a3aad5c105f12dbae97636c87856fff1b448153c8c1ee7fb844ecdfcb090bb4844bfffaa3c78416c293993becbd3345ce0bdcaaa9d956fcbf40b9165e8bddd06fda01131d2b0c33cb9d5b8267b577650e49682bbec331ae197c09cba04e13221ea07309a8af085e7b9686f9b3a3e187c68d735018386f01331ea633efc4550c2dc524367bc65cd1df08e3a1c682ede5a8299f25e6219d5167400eb2bc14556a988531e805cbb374a8e349dc8fbba4527912174e8ab0f0b6ab1aa51247e46ef91391bd70cb1ba989cb836e40c62dce9423cfba52c24f8e9e61015341ae8db10a551c284094c5d7c66a200ba5cc3ffc87909b506f171afe76ace049385b2f72e070afb26d72e6b93fa8b9e091fd4c26f9df4efe4642f79c4c9fe3379309c22d61da1e578dc770fa3973b82dbaf03f7c085e5e8094845be915f21ff790196f89fa2fec8212ebfbf9c331be864887ef9bb11d66b814a384d2950cf4474c402b7fda43e9d43f80a536ac823e9014a6b6a1c1fc0b9e5cc775af8515702c9bdc6672a7f58475e9b5e30fc59098395bdf96d3643faeede6edd2988a33240a5acb024189d14c7d98153583b114eb1f1f271d250b33f7b2ce0c250d383b46b8ab6ddbba481dc2298a59b530b4c960f6143c4b5f986f008b524695b08a08ee1a15a4bd7c62566ab05baa057cb85a7e4cae507a423b19a78c9a1dcb462d4a948549221d0a8ad256482e4b48b40345963bb45415c2bf396d0a3e2853e95324f6426b1f7326f56900081495bff1b9d971d86e7727fb4c20e77ca4436e71bf2442ae121c8ec26b050d93e27e133c633d995663031d5ad1f549416aa855c65e8536dec03458b1ddf6ee23403956a176ca08a95a4b5089c2ce725b5b187a4dde16dfff941cb3d6191700f56586c410a2a6a5726e5cffacc47cf866797d482ba5d71fdf6bf7ea1a4dba15c1ac46b61a83017ee7fce4fb4aa33d85bd1120ee1e1f0c906ae58990ccab12ceabf7f298adbbc6c19ee90b41683eed6d7ce48fbac19cbd4b196f738822602ceea3a96bd3f9515834982a6f9fd731b91a606b4c786005afe91ef3983ba5a8e26de32acd95c145b8c71ec0059f887474b0f50a689df5252ec558d5b08c584f53a91d8442c083c6b753bf28ef846eb1794114496169581378bc7020ead743c7494a6b6b3beb6cee180df9a0dae71e04b65ac7c66d8b47a5b809067e2e423fca3b5aafb2583e3a89af9cfadfd628468d3eae243f376161d7cac53c843178e0201da590431ad722c4190f6c1fa643e04827d3e3284753e993f9a1ff7fb3100415d8a0a1cec3747e65150ce66277ad88f727301e9f55036138b740bcfe14ada9b048f6bf84236ab89efb17d84be7193ee82bac22fedf5a49f4c9cbfe8e1583125c78a8f18dcb47c82953991858b6c8e958e44b35659439b985601eaf1068a4945e42b5ee34eb617f2708c0c64b153ecbf4f8b1b0e583a627b05f9a0194cf2e17978ff9c3938f268aa7043a4f87a59a68ba471aceabd67c81033f124dfb9b4a59462d801e692499719a92ca6553b2634551807a91697145f004f8358c929f42e6a3f411ecd25ae7131afd7dc628f1bad6af8f5abd9ed68560e6c6f72bc3af06ca8d1521ceeba3bcb29308d9ca681eb62c10253751f06076e0534b138496d321811f2711416b782c14620ac12449dcef828f8cea11affd300899ec11d16faa430f7db07d859e16b710e1d98caaac1bb394ea61ddb2d54c76243dc363b127682447a4b3209d3ac4e9cfb4fc33411e66f737a6c8c08fe4368335b14362d17ad3969e9a6090d0dfa20f0eade9a920d559c415828fd290cdbc6bdb5310dc3a8288d3408480468bb8b426d4c3ecfdf1859090b852079024638b7e7c30e90d0b79f22ce1a490db5ae8df392b9c4c744886747a02433f3e3976bb7a295074c48c6957b126c0c10f97b49465ec6644f7cab08f81c1a5d15c301870dfe00818174ecc2a3e2edcc4e6c48f9ad2cf042bda88291f5c7af9af3b04c2b3717961474ae5cc760ac4d850ce44ddd5079e348f6d557ab9ad66250794f76f1b15e940261c749fa3cd1dd8968e7340352610dd4f036cc0602155cc08ff2a4716e64fa5417bb4307d56c0a1bcdef40ab145f9f9d083256155b7456d7ada5e683da9a7f329709ece4b43e4690acc837316afdce01ad361713aaaeb1e200619b977cbb4b9e7669b0457ccaf9d91b76f845077bb1f17cc9c670d68e5f1f97088a33c65a4f766639a576fc03239c178c26b97871f69cc6ec8962a9ae14f9396576d01226b4c3a738091eea3963dfd3bbc8cc09cb5db071462f3770a0cdb2c11eee6898956fd920976f3c4437f0b0803c9d6d3b6915f96b60974b361eca0671abfbe9a4e98ddd7f1034bee87b8ba33045c73f951652adeafe294d72fac1e164b4a6c9a7c97a61605e9048085560481192f6bf107c13317442ab8e8ba31916f2dda2252d247ba3e8c50ae17a7b11d7230ec83c13cb08e2e2d2ac7f3a95f2b7cbb8602accd946a0f0211b4ff5a6f71e451ecd0784aaee5e50fc5fcdeca96cff36018e841a5ffc1232a43d0caf1d2653b67a71a5da72d3c6d2c01d37022c3a322550c370ecf8c16a3db7f9b225988cdb5d7f120f011378623d94762a2be7a82560e43968a6ed906facbbd640cb7422b34b7531fb3ee9b78734065001512686a328ac84f80fd657411a9ac9b6be61ac18a8ba4d7cbe0202554314534ffa62566eb37b5406874143395ded50ee9fd3446e8ea2f8728dcc294ed0308b03bfe0739fe9ef0b0c785691a1b1c9d3e7c59ddf1c671656a05e2de9f98dc4a50ab20d4f39b7cb05f4e462171406612b9f24bcc6cbaf918d8e928d94a7b802b218cc06388faee699dc456186272dc17a4c00738c627d95dd504ee36164beb920b554f2761302856f0147243ff617983083afc7e8d6021fa0928bb655d63f3f1f46496b42192b8580da2f02a99fa214c53f307d1362a1e90c30f7bee5f6b0cf0cf39c16e03ec0804867d07919870f453096b565e2ea280172273e3f22e52da5b1cb1b4a553c558cc887f811d5454f02305886caf0fd4ab26a4ea850454225c596ac786a83367f5894c8426c85fd9a6b792a4330a59a977df5186c40164ea6d42f84a646256da1bbd91134b07e2f2941a27cd73374d626cfbfdf9321367bf9fd188b6a35833d0ec872dc0ae7f22288e7717276256be67f2a271ac81b6db85b48a5fe9ee782ed9c04f0e67638b9df755d5b863eef9721b8ceeafb064727a8d42beca68e6a3c0f47f74dff29a8af83a47a1bc65a0500cec0de7eb68f56c11a0aaf02b6de302302eb75f92fb6ed7b9c9f69b8d75ac9ecd8e90c1e4ca34228d7477ae0cc0dad971ed5635a98ec671b04dfb052f61887a2f8802d31290828316d0c46fa943ab5608b3b02b71b41435b012baee50ece4b0fdd9cc630a802d74ae84191c67768a629d1bd1399574b77db6074342b409d4abff5b81ed39848e691d8d8d94b0a5392f3713211d009b9561d5cda46b9ef9a570f6f1e1ae034072e0d028e6fbc874852ce7c9f1d827e6d623d82e764866d868a2745bb47c89ec3483ffa499443ac43261c56a2ea8e56c5864faae94cd5f68585215ca58f6dbd4a82986cc1403169b3abc3c6b08b437794f02debdc851b538793389d431b7abb622072fb7f322c34ddccf7c01511bc7cb93e75c79d4b5c4c743e5adb424de31176f9c86ea421138039c5e448f465bbd1777466f14eae6727cc4517c20a5a691b4eb98b3eaedd666399e9554e7b99a3bfae31f185b225529b4bbdafa7d665afb7047618c2db7cf39d046af0b763dfed1d3aaaf5c593e4593f46cb6774c9cb81b4bbe1b3d88e2429208c9319a05c78068e6740960703880b22a0799f367c71e136274a0056f8217300b9842830b722096fce70a03a90c2bc19783f71eb99e190b6b0f474fd6a5dac8ce23b4c73bde3f3f000c494658803a17d1e50e1e3f574fd633c4d279b34c029a80aaf71ba5db089b53345bbb9f401fa6f8b4cb4e651122b351f9c0d1274dbc1db8e58f33760fbb6073f9564b354dfa8bdba941e56277593d1603834b5f6fadc0e6cb88be92e74f55e2eee0b4da428b444b1c3a84a9b9ef75cb672099675b40c643764502420aadd784a6ea0b16ef79e57253c27541c5848988c4bfd782ae4a00ba97b77b1710180b724b3a03f61922e018b76ea6d2f18f4b2cccfeac46b5162bcfcd35a6426e8272ecb382e002de2f05a54a8fdd8f880cfb9b6b0f4027eca9226874ade478b121235d9d41258bd91ded179602b52c5105399d725297c96ae08c4119f0cad81e18478d3a03485aafd33ee15e9f90e2d7a5dead9797e39b1534e209c078e299dea8522c18d662cee8079eaae37019149b42a53afb03fa917bce4b2cf25ec3d92ffd21a893db4d141390c89bcda686f8c6fa6a71bc37e9d8cba7d75c824679a39406eea38bffe42d9eafd4077e46afc2cc472dc72e186e1d28ff86ec121a0a10255a66a3394de528f8e3c20cbc17259be806be69eb562054a48a872d968a2e5a2033ab67f7caa797412909a6bba97466f7742019af9e668480c32e385fbc6a82928efc8153019255cc4e563a6a13706995da96e9e1dd3f17026a87d032080a7606f49fa9a6016c3a7aa4d7a0c9049ccd8dfb03f5279bf666d832ac3cca2e618634a4589a2ed5f4db7fabd5ba358ea05afdde20b93a399239785abba97ac5cad56a76a298d4c36a6fe068f2d84d672c5b52e45cf75dd2f53045ab22fe9df227abdcffc38bd304288bf4c1387df4af028a5c58992763cc1c9d43eedf2bf6271c3d8251b044c41cbb339cc513e0ce86828de5cbea35d4407e52e9ec0ff5ab573d07b668a52e219c1f4069ef5ea3d507cb8e6b2a91556b92fd340f29720eaefc2b24c76099ccd7a1602417b8db8a6d2fa6079e0a3f02d74274e83d9e9d87f86d99159ac1b99947799c17c17b495a5c62d56cb810cabfccccf8fad7a96538525b7d5f077fe628a6aea9e5690838e1174f70d6b88faf51dcdf902dad69f0839e062e295f18fd11ff7b902a91f72b9bbd8cf76ceaf4a6c0963a3d42a94d5dac1c6aac796ed12045cd2ad5c63cf1b9790f8cd14914bb30fce3669d082fada55711de220039f0e8f624a7d6fe97cfd445fcbdedd1d2e1f34333da747cfb1ec599ca3070f3486b54d32481bbeb2ea41e8db96af128fb0fd94d7b2c71d73bda600079b801ac72a4db96d1aed090d7ae6501a070c6585a39769f00f43f82d67862f1c8c706e0e9e92fa16a5441ab82ae76c92d0c28b04883108e4785b0e92862ce4b16a4ee82e35a11cc652a1104dcb1e954b1b9a8ea793adbad3df565bdc46bd59c3c6afb63497eabe60cb9d8823015a25ace489278c6ae73f6b1c3049afb3fba60634fd0c57e99a5b28ae60ebc30a9ee244592d33d1197d7210e2462f4672283eb8a968d2a4f3df213b685d664c52523a677517f3a0c9698bc405f568800bf839f532731dc9805ed291254422e3be879e8f51740ab022c76da199e6c1fac09283b815393b914eabc2534671e4c18cfdba74d47e4ae1ab4c5eb36c23cc478111f1ab630ad163686c2af5bf3eaf8bdff52ca2f4a3b00d5693911e50e39c97524a6f8dfa011353c9642ccdd8e6f2c9bdab2138942421a021a2bc4ca782c9a46af4baee1226f0b606a3984c3f62ab1467a4c132559855f7c5b6a6c2387b6fa823adac4a5411d0e42eaaf234f9c9fe267ab1de661d5ef577cd0868ca5f9032d1d4af5fd4e1e75f7e827d324a2c565c830441a45c08c464739e89d678e5cb645d522b57ba6238b7272af1734e31cc58c829eac811ea1aaa4f889f3163708039710d06182cd2720f91875398089a421e564dfd5777f6969d42916582104af4872d27162fae2978862c9ddac09871e4fcbefa4939f6191cd1942d04bed67cd112748ad079d86c5680f550da01f8105451293b85fb02fb124349b4c6d1902e1b2f3e8ea548c1100cdef519cae2011995d52c460a2bb616bec494050ac500040417d67b0e8ad9c60d65df0e7aa6127bff41c9248644fe93b487e68c1fe47b81dff1c75529e88dd3572e209ba794129d6a7d0fce0f9c03a5aef3f862218c89b82304875dd460e4c73ddcbbb708602b34cb68bfd2d540ebda2d346ac0da2d03745b8a304ca35813c5239c1ffae88febc33ab982e754b9bfda9b0bfb09fb479dafeb4392df1dd3e996cc104f0d1e253c2c54f63f33d1faec9f1647dafa01b7ae995568b0860576037dd46e773759d4abd71056a0d48a09dac2f7a3a8daf0b87bb9d40f6f42401c350f51877ad3d8e6e4740e1994a440f597516d06407d65280f4db73b38ba92fd4418e8ab48cc442d06fbdcf0993e07b0909f7c5b8c43adbefebea4e802121aa21557de52fb94d5f66ed9d1378b9b8e65c0e86b990fb5621d06655fe65e58750b402b89c3571f1233b64254c14553fea137dff0eac3d1eedaefb034ba9aedd81044429722a39a01206c53983426503ccc3f2a0324cfe6a9f6d86987c0b49fe9332268bc1cf53fab4b8807cb90bf913e0e23149222bd7c77f71e8f0897d800801fb17f2441ba1886f448c6f1321b3c966d29b6e54fb10afc771cbc9b2b4e9990bc8a55c2b0663f0fa47212bbd6dd2c3e6eec6a5939ed0ed8e7d15c3f7140f358872531d729b7844a74e59d103267fbdb6a4e8745f388ae7a5efd9a1f82bfb5be100151f87d75306d188e8344b8933aa73f6c1b192c881ad139df402f229bc9883f9e11a4c67ed3b1fab443f13fa05bd410ef0dfd04022587481022eac00b7c4906c3225886f70a497c2d7b3658171f7614892a4f9cfe353ccd4595a7daba4a0e9913006ba582e18a7bb8610a70a21f31b8da1fb7bf1f73aec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
