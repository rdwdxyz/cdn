<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1aa45957da609def2152b0a73e29a9e9dfbe87425732d6109a8f26bd5164415b7b19f03929d41aa40ff64be9e88326fa08a753efa5a5e79735423d460b62d951657449126cf3c7a1d9e750ddc088ff77decb2c16e198ec8f5258e1b111c2be06d1e6ebbe04f5220f417358c83cc91e450d89fc238e446bed92ca1112ada9d419dec1cee2d7496e9e7f651b69b2906ab6b90c4c3cca6547ee1ff023552e7cddeec131720768c26ec2875f986b53cd5de84bec19db592521dc79a43b3e3cf7270105ae3327b56c3b9b3492c91276afbe9c5b06938c461995257e447ffba419cb0756436fb92c2cc3b7c5a32f8f67e0431ce59449e1b88a4383c541d9b9c46ad39ff51f9c0e30cb7ae3c824037744a2d5c7be94b5f05a9dd1dc8351089e6d9231a6524aff481a7a3a630f78a0464199d45ed401a0bd07bf567b79c61beb52848ef8267c8aeb62e59e62c8d8ebd00ccbbc6468f402deb719fded03efbadb16ea287c10f8041955cb7332b34be431ab7906e0741a192187fcb02dc738d99685e3805c41d48842a89a832465075285a1d3ca95f0d87f2c7eb8f52c3a57b94933a5908f34da95ef6e4679b44ccdaf2a969e77f7a11d90562822d7025a6247a94b90182b8d8ac9b781a2c34fe94be11c2ec72c64fc50da677373f82a675e68183f26b0e08d63cda258cd2f2db156764be4133400e3ce41d9b0abf13ff6fcb0ed28ce74ab3e70e5e689c944f6d2aa1d9e5c72582d14f0734d2f96759a66c669b2fd7107f3473c57dfb859cec5a7c0693157036a2832913e54088d4f33863dd1c86041004c3982aa2df1ed9479d384729559f5fa5ffd8a9b567d694a5dcb53df2ae9787a18af67a0ea32696ac4485fb6a171c56116cd4e77f809a79818e66e3d6814c58603881341be0573d6f3e1d054808e1151582d3b68eef584bf026175285f474eadd0fe8a426dd71eaf012bec086e510c2e6bcd8e98258dd0804e090ecbcc8a63567020c21db2044ccc11400de042c09dba0f968a347c0f12f85f3b107b4a394f17ecb3df6feab41b826851a7a44f6910032cb5835765fd2b3fba59d2e824625c304cb5858f0a65b7fa1e3a5297427ed74d7e0c0628bef606809992dcaa93f5cf9842452f564a60ae0c87478b0e074ae60b2545e0b77f32104e5cf37038cf3a05286e9599dfdee973d82f3758a5fd7ad1631ea758a43f69f8772fd9ce3bc729f49631cda32403403fb302d02cbc5424b4927554266a0335860e5ddf34815d95bb908f8c640cc97eabd174f9bf11c68caa89b0e6c0262a3766e3efb7b5184bb8a616b1bb2ecf06aa38f72b2667a6e8f4ad8882fbf0878cf5d50d127451e8a27b47796aa53a5b915ce8b2801f07b3e10526a109a868fb8961f4c9e19145a1100095145b65bffd3f09ee43c27ae2a46e56e6ee85ef2cf5bfa164580057b625c2f83ecf800135ccb78b3c363f5709c9f9a98a53d55a239025fbefc2486233468c2e4d92d0e42d671cba6e9f8a22860300dd9122583e8ad4810750cfb04a1f45412feb446848f457b8b80220fd4be0c77cd4549b73589ed4391facda82b27694df6b700b8f5fdfdbea2ceac249866685864b7a22a6f95172b4da6b49eb935cc17d30a2a440a5f9ac7888c01156e8e1fd0614d701584ef0528a791b6d0a7fb62c78745d743194726b9f4bb89ba86846e7166f83b84eaedfe5a43418118a5475da82d30f508f443cce2622700b6b02cefe86a071e3b45a2659fc75b189df9545729ddc08b8076051e3dc2b0fed6971c9a3883ee13bb8387b9ddcb65301a3633cacd405933e190835950d79b8df1e7bf76fbf23f1ce107dba8a96687d14eba1dced9895148e43545db3e7284ccd41edbddcd42d07fc2305181b7f7967956d6784a1464d0215795c5ae2cd2815c02377dbd1cf1d593484c7ea8dbaa3dca697d54fbffc750b3122a112ae7c3b492929e2f63b5733548fbacdff958840b27a45c2f30d82a75179bfc4189053a5048640cb7e847a0c83bd4d019cb1f1bae5449983c7ee4dea52cc1f4e9fe085bdb99a76da5e83b21c097308b31c23dc06596a491fb5d4d858b05fc594cbe43bf3c7df24265a55817fb84a04859e1747c48bbcc3413b797875a9d8342f7695f751052611e026485d154c9e29582d80f26fea8138913ffd86c9aee785aa253a6ef1de7bb49dde3a1c53172df92bb59962b19120e78c26b45a2cbea018814161c83ee4bb011106d9c868f63d7a6469ac44a8684a54f4f127b99d21f9683a3a957f735534c3f8cf79e239c5ba39cdef0ad6e2962cb371000f2d044bb7efcfde26d619029f64c19bdd17d08f4fcad4a4bfe0c3258a79028cdbf92e3248016a93d9351797889bd6138766ea684abcaaceb55d78be38e221371b7ae419914c668a25b0d6a131c0219df1efddf6c91603752332f5c797e552667e24b260544bc23e32771846b1b810d8b6dce85998052d604692315487c722597cd067319e01007aaabc8627db9243399c978525b863269ad7b0f3108450cbce04fa4d7209cd5c3d8f2230fc1c6b6ad9d5ad9c17e60b1901b31b5a2b24492bec330f1bdf660186fb802eae3f3e20b81d6a886e92ef6e130b1f027bd9a5b406ea6657e45edbc4d7f627d892ae4556585581a6815da6257c0745074f48dff155299adb0629ac8cf8b248a91c68b3737e3d4ad5a0c155a7f6cf516c99c0a6c9f23c43e38b974b9a1ebaaf1ab93832937d389fd4804dcaa01c254b555b915d9fc456a45611ec301c215a04544a90de22a9d37c62f8172b53fef6e75b6bce04e244d1f06a4a25b9cf0516f46804718d87e71d02b8266d09cb31806aa8a48f86a1416ac6f081488e9eb79afcb16d050592f4589c16871515a1f9065b61ba3d06601ab1bf39f3f7c2610bd51244f0db798a11bf96488cf7829b88bdb500d952e8395c13135b8d753ca19ef652551cc3449b9bd0e2cbe6067a90d2ee0e0de2232d97babdfe850642b4c37fb9367600f9930e4fc407dba3b0d963a286232045d70fe5003c764f9d50dfc3c6f51d1f55ade678f6b90a7ed5a6462f23fa81db5fc8cb85f7b2b2570a9a982217aafcada39e11a159a9fc63459038e70e0ece81a0ef246a95ce2fbd07dfdefcfcd316ad79ecffafbd16af1efa073df16384e97d01a1cf6a379c98f3138b165b5d435d360c4ed737e67c8d951b322ba8c2dbea3e0bae678f9fbc9f57270bc3dadf317a363aa5b794210a3ed253d1d5245c2f6331c4089311597852ddb1ee8c25f4550fd50084435ea7b32554dfca32cd53f89548bfdf326b525d375d61734c7f38debe6d3a08db9d45e97598e111ef21ba2c3f3179f6b6b380551e7517c83356bf166de8f86d8f2a398baa0b7bef865370815c0da4023c00ba372d38c8cfe9160c8cd30d26ed2c230d561e5a67e0afd31ebebf5a9379c722425c80900472afa65dd4c4fec03342b4b55c5f7ed46c15103fb4454fc646f7f885dc78281117956eb13066a2d49b3feeca4ea7231997d844a38e14cdf3f725b9b36e2724f1e1d3e4e854f569cba8c4af18d0efdb002028a911bbf098914bb85c837dd3304cd032815854f97f964f9d854caf75b71a85f43360c8c3cfc72cb8334686c554872f5fb969f43961b6c44d2b364684322b7c6b5c257d14ca0ff7f7c941133208c5bff0905ea6aa77271051b815e74b0ee45db306501e809aaad9393164b50d1b556d0a5d286079060ed1fc781c4b60f7bf8563d293455611ab8f78b6721a3a222949aba635abc6d93b85e60f8f4f60d02592d547d3928c4c3c919b6733deb617bee967b273ea4fe9e618e20902122ced630a2f3230037493306ba3cdc0dcbca41a89e9bea71a5c9f0f55ec4872290538b10055cd5454c54cb7639ab9539e07b37a171433599ef60f5cdfab4dc36f55c51355880126a8eb994b8831526dcf8e24cfbdc67dcf172398717aa2ddedceded6d8e042aae6a1e20c76ab8a8e4ddd6418cf5d5bc4aa10f2bd5985d67a69ad1048b435faf621312c06d1d2a4219c0ffc4d0cca53ec6dc3848047b7407e7eec9efb6bfb97a6a24a730d0c10e560318cbe9ab471d7281084d678a6ac5f2e6706229f7d357ab0ce8b5daa02221d9d9acb7906133e6a1e54fe30d9099e9e9a08594291403f28648cae06db6729b2305bfae95b8e9f24e7e7925e28c3c8ad6ba49e49361d13bb756a110b990cb215c69f91e425ea1a13dfc9a91748cb75f70d3fc4bab24307b72dc3c21230bba2ead8a6d38f0bd2a2d1c924e13782733278fb0228dfb9782c9903dbdf22b87e8d421453e605e8cebed4f943e907e4e35624bfd5242d1de436318e5bae81a05c1df2152bb6aa87a4ecf4fcf31cbdbe6d2c29c9035e94eb077227c1c4172bae2173fcbf4c9b9d073ab799435479c3eef8f24c332629d4d3ed66b6197ce822148475a7fa51072fd87cbb51664444dd533d17c5cfa049c501a21aa0590d16b5a78d70da03b8f347f529936d5e0a7a7fcf7863aa18453ab029d1f262070f8efe3d6821d3194a45163b26ee5494a9dd2a2ed758f1b4de7c3ed5c3496a16a5c082711d5c73989c2cef780193bf726cef00adb0cf46a9ff8b9416fd0f4f88cf2187f80e9a2149a2185c2a3c90df6f40c4f138e3d56ea7cf1609eb3561a24a90a884a549763f0c589f9bb5bed39da6e768734fae3136a1fcb548a71f6c32d6946528fdf44189eb05d3e14acfd2ff8556b4bf0beef00ea5ee02f07ffe5c7cb71781192fab6aa55c16b2764d68cd1940eabde57166f6c5ae410724771d17ce71c71128c5e0f854bbae66500b62b25e53f517506b4f2f7472a82fbf6eaf360fbcfcc7d94d6845f1a111f5bbfebcf7bf3c45b32aa32a2f30ed05d7be68cd610bccc5f63f51465f9c987461a61881be7bc288b25f10658252678cd44759066f04e4a8fcdd15750e735f9dbb09e3ac887aab2ad25c5cf5d24e94302cde59222223a278989f15176c66495ac1f351d54119fa4a3bfcad7e0632f498f33fa925b28787871956c4bed11a8d833cbf0c552ce1ddd04d9ae7cf4b07c559a43600b7c5570339a9115e00ca9b6a335bfaa5da5cff22783ea56fac47e4ecd761a5009bb13953b2e1caaf13e0078afdb9681db37f72869279d565cda53a67f26af37cde46868d1905bf248790568e756112cb26bbec6204691e75630efa89db1f49a5f333ec1d686e24fdab62c52ccca6d5b4db99dbd85786fd019c47935c663bc778c5be407a8c5ad5bb8c173bdc9c9c6123462ed978726db4dbad6d8c556a1bff94396b4295651017ec3df6a10baa9ff5b92d2a795886f11c0a0eff4504012d1fd70a92b6cb35f3b48051f13e09f431d6ad67a3aefe4a40f7a1c2ea91f07c2131372940f5e479d8b1aad3601dad0ad3344e16544686f54757d24b4121b0455cfa3d4b7eaf30c755d56d228f02be2dc0930bebf696242a8c8350458d10004e15c93870fba5ba89e227b51be7e907c596a266e40b1000553f28a480cd3561e14c036448285d64602376e9704bd61afa9fc2a11f32ac0fa0ba6c793e06e45d8a31c53112435884a72c0dc5a1ae23c501f668a184465b5f41338ec77f8cb158e8b99709c18977b43b3b8dab185547c4ba5f0db445d35b759629c02a0f4259c2d3db6f01bfdc6300b2fb67cd0323092d52898a2a72a52a176e4b78362c639403e37790d9a7f27ec7bf6ae3f52ba7e0d577b42ef4fb6c74d1fba2f0fce39d5c1acec41f8ae3d986b907a63ad63b204daeb5d131a79640d5f65cada010bb9d6d9bd3250f544b6127bbb14d6577c818420edd5b112ab00b756010e0647ee0c414962314b91ba2250acf30cb3f996cb86763b9bb415c6317fc7a9fbc1c89e53930eeb17614747d9e5455080f29c7ef9bca9a15fa4fef2109a42ce809d5906f94ecbd7e83b9b44c90a1a27308046cd104d06bf403c400c5e252d038779f7761823ae0a96223a5d87bbb570d869343020cc3313a7adbfd4a8ea5a0b8475fa7e85069f1a44ecb08cebb10054833abcc463d569d85d1ef43057795c826b052096446888a8b9e504b4aaa94498b261af757d5e9e9957a2da55594ab225e5a52d64d193a43d1d553d9a446e14f21f5910b7dbc38ffa68a1858d5a52383031337d82ddeae24a5af486c6ad1c725970e466a231685851994c8b973cc3bf62874752037a50263fe3d8b2417da146f7e223b2067d1cafd56700f9c85bb16e359ed2d860a10538f4576a05c9a5ab02a88d158af61576e034c6d5d20391ace48d726b259d3fd7a8ed99ce12cff2c42ac25939eb43fef056cec760beb3faacf2de33cf6d06a297884a47788fb5b22949c84ab8344ed1d039c7ba5d5b602602ff163b9072fa7e2deb8bdbad8158d765d85b8ddf1a31a5686009839d576d00b65b7d4840faa8c929394034a5393be05f94edf629cdeb5fc86523b1274074b4902acf6a1deff9001fb406831cc7d71912d27c232d324474dd288c7b34c0c5f7381034a53994fb61574929e4f077ca11423bc37ba18dea0d53c94d526e9f373d111bb5bb2717af4aaf3012182fd4d90f0bb594c1d0fcd1da8d5ae915da6a9c16b44e39bfd74acc0206f993cca58a4c29cadd2388ccdbcff6e6818289e676bd509b2c645c9d4bb7236d3c58520195219caaf71eb3871659f90a450ea9bfedf27da88aa64d418b3b64056a4568ed6638430c552f4f845fc438ce05613567f0e4c5522d515b983542ade2b6b446fad28dafb8d700718f93bd3076ea627e43426280b69938de469e9613f8a58f5e783395e0fa2950c2d89c8a6f6bfe5820528809d2dc762d8b6f14b046023561ed7b289161e6fbd07af8af25a714707ac771fd265c97eed56fe2ca257ad3a4df6beedff249b8f2c0528de670382b495c41820720b24f77c99b13376fef2cadceba9d1e6c31afdad8a853198e39d0dff5609d5705f26e6229d3ed4b50674e89c59d6e5b16afee1e89642f9a8354022b3879dbfbbf21356826d2557514fe1e2dd783194ed45cc29fc2143226671c97514ca62f2b90ccad7d3f88d27fdfa31e65ca13fea1ddba74249cb17d5064b9b6e4b0bc979a7663cf71c689fb1169bc7d977ddae2195f8f2e6abc5a5998b97febffcd82f6c03b8807b2d74b86a49b256408a045e26b4602f1fc8320fd9c49138d9240667c757c3c419ea0f9cc0714e0c316e835daa76e0dc94aa51d7d83d4536d8b9cf90acace89c559756ee9c08d0cb33ace760a93a38ea1e10b2d20a7e91a5b8ac871ff8c46aadc6f54d0b4b5c7c66e25fd208c67eaf33fb0ae97c1256a870e6a4473f04dd1d532b8bbe34727800cb797fbfda5f6c34ee31a1a6d68030abd5e4ed084d213c0c8df0cdabe8c7d7c71d76631272d5583c5a1d0e1488e393992b5400cb8b4b1df1bb6603c74c7e63eb1fc09c69c0c997bfccc207d58e63d85cdd91e63f4ba441b2bf6ae46c1064fb428bffb98a98bc73b9c655274dac58b294db57acf7d859fba7641fe135c9f86968177f877753d1c76356786f5a40ed0ab1246ea76afa0b46d1a3d55004e705bbd2d1c8c3fc726fdb823609f4202c356ff5f8617e90ec1d982de7a6b777d3aee1cef8aa0921684e85b4694b8e6a7329863d2955f16385d93167239c74d4609b23dfc8a6248f4e28d7736ecee2fafa9232f7cb9dc34927a97ebc4dc1f86378939767042398de73428241fe5b13fa72447c82fca613df0c4d1e68ace67a46731dda3b9fbfd2da608695f72f18d48521272ff1d13117296c2246bdad621a1754d49887d9aff6ec2383c9b32e09fc66cdff1d9acfbec0d8ed415dbdb2ec2a9a3ca530a9fbb17ad37d670f426964c0b85aed0eb35d4d93d3a19213694360cbe764e9e671ebe7b9e1d0be10444b6f51e950279a86b178e40641b164e7e1ebba08921b82c048e11bed19c0e71cd1548c9d263634b4169ec1b6e2ea2dc91c18de96bf05392884e486390f23544fe2f28a0f7bda9d96073f69cae0aa5ffbc9cf6b76879b45d7f7e82cf0bdd912a35eb17f212636bad45fa75ef69942602e44ac49649c4858b8e9f7135b83a13dd7548b1ab057fba0b08759ebcde412422813a90fb634a5c2e727dce1f0649a39b87aa176559d56a3e7fcf28aa494bc96a7ff7d701dbe3b04d2b7eb1ed3a0c613094a755506290d1a188761ec52166c6e75e7f95306cf573156d0dc896f5e32b24641809ef19bf3095090ec0cce5455edfcbe232f63ddfec291610f95650ff52659783ebf89fceada18c27b2fbe58014f786f17e03c3aff366c1646d4c5e70e57a1c5dc835720184ec14b51599cc9c7c418591818ca374758b9be8258ec4b3846f4011890956a10c01f1e485759feda4f0fe4eaaa82f9c2106f6a067230ab1abc7fce066b24815062bc4470b18409d9d3c7f92d0ca8ea5bb7d05197a961765888ee433a970d4352e4b7820ef27b54c13da886288329669d68645004ca0e739418660b7d8a637bb66d72ee5ea3359b56091905a4dd3e8180bfdebae44d754de94f917a41f9662dd55926f464a74784ef99ea02d4bc28b86be38824ebc7ee793a363d7686c2d3e19f622c28b3d28188424edca5cdc19bb8611972393c2211764f90b32e69516382895d280517bcee084f8b228b61c654b5ea5a7cdbfef70acecfa4abd8d7c90122ad70cf983e0c59c7d52e71e982e1e493b1b7737ea3ff534beb68cbb95577a34b085b0abb58b419277e017a341febae3eedd417fb04f07fd086a3b283d5373c71adfb6e5a2978512405e0a502073f27b597af941dea7db526905ba4f6fc22641116bec898ec2fa5414e9d0698146fe880a7541be8433e0e0a83c45661032ed7c1da5b851d93e8bc4a6793ef269eef95760e362da9ad80cb7d0c81091f89869cf374de26d95ce94cfe60cc54c4d029a80b41757fb7d4a46384dae6d80f99778b662b114b27218c2e0811b739eb668b8c547f000bba28352f7214f10cef50248cff153adc7dd2216a5190a27ad17f4c4f784ef0ff5873d79f573467ed66b0ee3dc6bf621ad7f50b1b3806169043b4766782e7862f4480c369e3faacd06bc10f7e86e0977d290c128665e85add14f796224ee14c17e3765aac029d2838964f520f43cc05c3793becb3928fc343e8ae974416c451aebcfc86541eb7a1d40bcbddb489556ffce1406fad69d3ad4474203b24fb6d57a74e134fc8a8d8435befecca76119ed0ba66c04e9fc32a514bc2ea4f3a22e70b29cda7efd73d9a32c505ec4df99f759fb03ba0438698e740aef631a668e28b564c0a94984aee735f00973f8a03a60a5ffd0be563e43dabd8c263f74c908d999ec08c5a60fd86eca816570eaffcd920e34f5486ffaec8a84babb38076619ca3ca552f52e42b150ef9da4d0beda5422c722ce6e76c80c2c44c2ada0b9eeb875a51fcfeb7c92138892e0f59ad4956db4a1d9357393c8aadd9b69a6205c44f4ec184fd451bc7497bb25ebf65592f8947dc8a9db979c8c4dbedcd22b9b370fba4301865e094774a3360b7c6499477ff1c5e40a2e9fe36519976b7772c43225cb600feb028ac4909813fba21807e7981fff20dea9a8ec6cb3b910e09f03fe7f315c94634938a882cdc6fa8104f5a7da9a054852612ddd7c4ae028abb4e08e16740fa10a194658e5ffa2fbccdd45f8f7294e73712748e9ca9ea20e2d62f598ce176c2806e939192e0a6195b77e145ca94df95a8da4800a53cf6ef493a90389f62251d303bbd4b3d04caa027f3b69ff5f770d90c170106d909264830eb951f18684617e5e13cfaf60bcc67c85fd064ac59e699dbd25b1a37cc8a08ebb6375720a31f21f3fb0b48f339bda78553b61030af18dbecd57b972358c56a066a4f266ea220d702b0acfc2b375da8d27025c74d422b6e1a819c5e5406b8a6c4284cb540a6fa8b2212d6cfad1259adabe00339fe313045cb777fe1417ffe9d8f86f4a48bf0ab04a8c6c9be65c15460b4db8b9c8e24f3542544913bb26763777a2dd727f4abe73d847d443ac6b4aec4672c1cb69431c7aa08aff37cace2e47d36a4d3e513c4d1b219e045f89af6ce8984123450e28e8d79d9cbe3e238e0775eb39c030966bc654f0f21e893e22a3b7c43586197286d86b3c6a307b4afba9dab6d3303e4533f77ec7af57cc02155ff1cf00a592a522089e67a8bf6e685740e2d65d738f16e868b0d983d8f7afc8b3a06726e0986737918f6ffd717bfec956c9c1094ea72f834515d21f7f4fefc7c2b6383024fc87734ae4d56bb8ecdd6417788ea893ab89e400ac32495cb131b3763d5278bd6c8067eee6e17edfc5233e2c6443f89b0d28f2afe21065fd273030e0bfa327c51875ceb4108a9e6a1e7722c1d79d989ecafe3e760ed21311fb1f58f32f863493637265989fea0c1ee6484c34491f9c9ae45de23c963d4082fabb2880693f680da0de680abaf1d3c607391fc047ea660be8e894b9d4482d822686f33cf43a7cdb240c682964f50be311c04607cfe628ee7556c5cda86511f810d2d44af5e558f145c4c868ce9ab321b5e35e74afbf965a11f9495706a9120b4879cd336c28dd81485aaf1a740ea344e02731f2fcab83417859d5e1c01e9413d8fa94bb7ce5abe3628c40dbeca4d934c28b2d07475856abfd6f987ac4f540337371cf4cfe0455ef8b9f6ca34d96c271b94a51f19727a4e490f06f1c58c7cce7f81af25ec143ddf94592d46c795ca5045fdf8a7796aba7fae3dd63b49e16fb984a9c78fc3394ddc2af0b01fc6ac0df306de2e777e8aee97833337818ef31c1e2c880278072438bfecf14597e3a9760f60a9850b32682520d7c6d02813929ae13102d913e2c854f44d5cfc3ad10923a77a8c00eebd84df9a37820fb57015b75f2c65a2bd495332ed18fa95790556c3d878a1f2f31de483bf3cab4cdd156b498612e907419ba83bff80d55143381dd714ea8a1c3555c3ad6a5a0fa69dbf1ccad6bbea44b8cb1d81683422006ddbc672d9caae0143217db653d0f602214d2d917b0c59c2a2480939dca12dab653f2fec061b02a3d2816f6c05caa9eda1551aea6bf3a79b3c2255ccfe59b3eaedc47f8af029e54783e3538270f962164435cfaa50af05cbc944fecb1b6270a5ae212fb213101842e748329278a8b58271f49aee094335cc49d223a8c175ce8b2339e96cc809606fa62c68ac980508474f1c3dc1f5612e69d4c192e47bad021091e96a63e580436f20d08c8d4f233f44b52448c269af1855be70d9b21d56521a412832861cbf1ae8e3656bef4f471308105bd42af9db94211ec904a1d10a47d22f1cd4bd96305bdc5404204eed1e5b4dc081e168d55802f7b755723072c1430d66f6e70c05f6bcf3f00d7f6df3962c3d31e14fd8217f813dca950430ede12fc034605c21a80d238be7bb102362f05b87c9f00c21feeb7b60445d2cebd8d76a5fe3bc9d7ed7e04cd8091e1dcbcaa779cf4b1558b4e24473cdbf1607c5218360d894c9a1fcc18bfb1ba117c89fa0024aaf8ff1e5b2b654e1fcba974c8b9cb49823c2bd0251bb063a41529262d4ae949e3300452957d79eeb24070a9d319c5a7ee177706208e5198dbf1a6b12a8594c40cc3d3632bf401aa6c2bc2a7f980f761206296abe4be291cfd7ab89fc2407743f1087a18e81f8b8d632f29bd2864391d934f4584aea9ff3383a4a4eae34c222e64082b383215c791511e26495b3ee5b8fc7e4f5f50e071518f95c4401ebd22ded11dd09dd819301bbc7651653cb9aa553e50f51b6a35fbcf859277daca0ff7b42f8af79c042f87b9b1d6131d3a1ae4e143ecdaf61a25d3a37d56d870d8f12a3b03a54222d2057099accfcba0ccbc10644c971e5c97e1eeb53ac2f18d2ce050e0c0e019b612c75986a0459b7a6b6a99e57b852fd5e0021f3533fbd03f6a872419658e612588b5399a3fad73134af602bc357113861a42c908433b8b495e6579f92300450dce23261486fbd67d5dc2ab32fa12eb3db60e16116717223cd75114de22edd4dfe52f1db0679e9f697ba2ecf687b1c956d8c7a8c8d9a1c683fd505622f9c64be1e6fb9bd09ae6d71d442552252d7775053a0949b7befa43005a04edee9aaa0224cb28ea056f89e90a4d792088c39062b0f9cccbd2456decc11d03f6709b634fce2332fcb7d0c99036a992b2a47cb4d664227b595e0e3938b439ad4b833d5ffd1dd428ad11f2236128d78a600f444c1fd6c07918f71fd4c7b10176e8a1c25f7da038fc6f3c14850bf73bbf7d1b765eb20155890c229680bde1c77ec038ffe775a599fc4ae361f5a47317e2ddeca1e743a42acc2193dfe9f42bb3abb6299f24a0b151f09f9ac063b8305cafed8c402df43b6c1ef9ae26ebbb2c2bfacae39a691166262edb3ce47c494427a71216b9b4db094ff2bc2a5a5c16e738c7e8593249d5c55fe55831a74eef5dd89d6194d7d6e369b167e8f2086a98343eb755c7ad0370025c2351df63cc214aefb92bda35df71437fd5ce80a90f8e642e362e4b039a6d3d1f1b6ededa40dcb629dffe3090d04cb05b66332012902e9b67baafdd3d6266adf7df327e297ad6fe4983030abc0bc7841375833a3f0db96f74140d53efaa936dd999f5fe14ee868721121ca81684990214c474afee74192b28edcf397dfef85b4f9be97f8a37011b5e1ed541f1b214ede5866aa04c1ff7e8c26d9b56ae1bb2c2c2f1662b51671efa5cb202f773b869982ccb1eec7cc164faec3532867618bb7efbd2576bb21a751656346b4f5d6c908c59d818312ca06bcdcb9771204e1a3014e754740af2fbdda2b85d8a96ce08db092e7d3b275f47e5b639f1b2057bfde1ff7b950fb9b01fcd3d433da343cd6a52f8427d24f202dbe99f35e6cbc37194902ab551d7d4667a0cac1d198d5a0f9fb872a3204dc31587702c05c5384314db20d4570ec6a6a5036b8682410ec98536562435717c94b4dba87fd65b3245c1a341a4d49b4a7d2d0f239892395de3a28ab7eb05f45cf3686429a9726569dbe1d468e418d9145bb3213c4d483547b68e034374d6627c951f6851ab84e683115fe75c01d89bcd3c423f4cab098aaf1ea3cb8b9b74bc8e0ad1c1cc57616b4308ad69c1c03cffb9479c48e562c2c39f884ec05c22abd57ad564b933b9ba610b86f524a7cb9592d20053080b1c22e18a5fee748857d3a827f3a11a73852c32662e6379981b938ee9deba188d1a86dd0f49613cb7a49a07af2da1c792a947e658e86d2d1b28c4faf223adf23abe6d50d1c79d5707d83d7672546a7a2a8ba7163b3997a6f446f6db5fcc2e4751cb06ee47e85dd02d582ffaf9718df4c40c55a4833e34802ea4b33c6e11ca760da2b98da2ee3ce5a7cc3b2c7d765db214345be20fd0288fc1210c158c2d75b17bb6344c6fcbf0e240660ce4a40988151447b2010ca5abe0d486f0e7a73efab65dcdb888af2b737025f8e68535d5755ff1810a3e11a18dae9d6d6cc4464bb2c6d033a8d134ae47a412c8f708a160e075c1ef1fb4413f8d75632fcc3b1c8bc358203d759db1a827584d60cb151c0dff07a7ae8f8bdebac1ac1d13a5bc5dd828a116c929d9dd098deae137bb51a0f2fafe9b5a6896abede5944b08a9c8d077651179e4244025346bf71c4bb6073dc69593aa776cc5409df8f5053d07b909f385ce5d60b9c260e7e02e6b4e0d423fd885b72837230d5f15c350a7085520b39ea1ab0492cd0775ecdf233dcac45713c974840b6fc938f07101658e180411dcc75541d0b20c7979ce31e6b16330097b8cec0bc54b9bb483e297123b49f4755d2e8ba85efa017bed491b18e5ec21883c0c84afa869ccf4e1ce65f2e3ed6daf741bdedb505a6b306d60c3aea59db707e1a673ab792125b4a44a50286f16cc833c193c37596e4374a3889d37d5156eda1886100ac79daaf6ce223d46527936b95f4f6fe90705db516523bb126909559aadfbe0242aca9ba70f1a255afc67312c669ec60366a4c45c2632bf422aa82953b3d2b8028849e06eae7fb113724018bc849ad564d8faae72920a99389fe245df88c9057434133e5c621ccf8e9d3cbf577baefea00b7fd1f49aa2d702890c547db793ec0621d8145acd18fe36b9e8fc1c0ebeebe425054b47de87d67f7a56f1162e2e6d7587e8b490c3e27a1b6b39dbc28291f5bb16320f703c48b954398b56366d0df606c2cc33110c12ed3fbf31e842eae56e6f59d8b7ca512779d4ff9fcc357f65d736479e5edd97e41ed8bf826acf4069e95a383e428b7ff6c7496a7d00fa444f3d0e2098c2c453ef41a602ee3917d5f63a25c9386be9ee1c223e98905e2dff79cb0a248f83223104f2225d8dd0d7ee4a93c91158324fb81aeeda8769a47e3f58c1d5dfa6650d23dfa38e2a5adfd6d8457fdfd5051177cc15e2ac12c0fbef921b539cac808513939e8f29c23e37cb7dfe5b9f9f315da14c2381a50dd4765ded969982b4653d48b69aaf3948304918ccb4918faf7a6d61398075aaaf38cc863f56ec1605ea8ad2850497b96a7c9615b6b6a5c7e32e19cfa5fd49ac1af07a64d14942ad2bcde02437cf78d241aac3bc8100cd16c61f2b6a71dadc970e72c7787f87320c7f1f68edfbc5d16cdaacabd6acf4eeb57138abb1725a1f2f48d63af19cc5eabfe837581661e2e8df59655b10154390537fcc7790c53d855afdd6faa4f5b336f61108919d7984c068594dfad91f738a2a800d8a1198f0a6c648f2ca050a6c1733396275a0969b313d78d5ec2e62d73689bb3d65e48347a498faca148c7e529411e9b16b9c2171fc4284510c0bc6bcc96d94109c1264a3721de82834950133427abcc7f2989efb99302c4eb84576407ef74be656ac9550ae9dab83fe473e4270830c234bff3ee760f61641c42488abb6683f54eaaf8f544071740d660f4b78cb64d8b14cce9481d40d5b40d0402a4d6b165d323207b37d2f5f94badea33275d9a317fe9ba82a15a9034467668ccd8c33af03bac8455d5b7b83a6af33b22a8b7d537eab590bfa98dbc1784941be115ac870c8e5414d277f3fb1a005647d86d16f60aab3e5585c94ea5b6a125bdadabea57e3fecc8ca30d51515ffc32eb99943dc5951038c04e74c30896a193377247cc637488e33a46e0e42ae84833e003028228c6f1724aaebe223f0d8fb2a1d78f350965c9ab5ab519f46b50cf7d1a617eaf07aea0aadbed4d39cff39a16a076ee628217c9c11c46a5e7714714b3f734b86c80ada7ce49dff4cab3937438aa0aa08f01f99f997762fb8261ccdc8967b013e8c3851589842592f1733fb671d8c7c0b20c040d782c14bad6c867c51fe33174125d58a278a1fb4e00bb5b66c2e7b036975dc6a1d730adfb4e33e4ce3461445d5427faa4ca186d77deba3b6116e92df14f1fcde8d8d6328948900ca973bd47524a5089f23570bd2acaccb71277dbf53a80b6bc8178214ff0de90c78e3b767cb15e777195eac8bdda72beab4c218158bacd54b56905ea1ff91bd9e183ee619f1fdb2f19b60cc684c9795b9b1b0d62975dd5435e164cac19c28080dc072276ec5255fa297e10cbddfa10d4c62f50d822ea5eba3ae404c39e40f61ff7badb967dc3fa90d2bbd285e170d7c4cd4bab7fe2e5f0618313428cb7dbefb8cc68111a113e34bf30940ba572f94b5cfcdf43609447b50241b7747caa12bb10ff3e4f142580a56ddd4f77c96465c908b1fd43a8e40bc0d76f7ac4e2c45ecde979fce2d66489bf99f7fbca0421893468c65031d51cf4dd9ad9e62f4bad448889b6dd73739935c0895f97af605e21567cd30d5f5a36fce8337c4e11674c16328ea67aa7f39798d1c4b1e8081fd14baba670b113c22b7d0fa1e60a325a3e2ae8f2639360cbb572810b664427e1f0f8a02e887d9d68e0906d52484e408bc48db422e68b20a5b9aa6c2d5a1a54cc6518de058cbabc43c74a4af1ce8f213c09a1bfc1da46909cf527e557bde7e0f1752421c07f2905439f356a37d8642661cb11ea9d6e290f8d04443435050c4910ff8862d24af5260f8480481d5dfc4d2223b2764e696cff82605212bd2cbe06209e9ab0ba92960a416f81507233935fddfcb93f6a45a87dcfb28fc1f1e828eb47e3d947b6ec7f107979536f3403c8b11fcdc07329dd344076719ecc66523391f45108d896705f6ad84f7ab33b5b8fd76e78811c0715ed4d72a399cb6c5dd7b473519b7419e43f49ba2eee32d915ef08cca71bd9520d548605bb36b4950b03238a1a86e47a458081b8293b34669c3ceaf7d6f2d81414468c7f040df520942e48f371b8d0c1452e2c6bc8acc7141454351089287bb28b50cc2fc6b30641c5f0365944d1d3702ab1ec77991138798a9882f324ee6c840dd8934546f013bde7a663ef461124e81d90d0c88c2ca4ceb2934a7bf298f44df776c97e277f724d85b4a1b700666372dfcc0fb1b54f4d4cb4a80e3bbd331a170b0a76a7d6f73e41e990da988862de49264a09d5750a9c281a70a2d5bf3da98cfbfd17007bed03fe35b821bebaf7d49f810a63cd098c3aa72f908ec70ba84acc882aad21460b833d904e0cea872466f9428f540a701858727b40b30fc55ac4605368bf1f6e6f99aa82fd8ec51b8858f6ada8e56a473671d5ddf4a4f482ec3437140c8e9f303740868e6736fe9c4d06be77409c9ab9d559ed8ef697d1603bc8b414ad4462f1b02a4e9d8f0f3b2de5b40ba017b8cf35d96c227b6232f9bdf8e532033d4490c0b1bb12950950970b813c2de67de9ddfe39dea45e089e8b3a2787ba8b81206802cf19d1b34b3c6f50b4cd059c2367898447427a9da232930f1806f49f6de7bde670971792ee9884193b84a1475d836339a15c0a5de7c10e4feea50d23db1b50eb79c883d42b1ba1d65e5450f04e70be5a6d4ffbbc1e32bffedb42fbacc693b0704f97383c6359aeb2d2113e2d6455b47ed10d292622d25a6452f4ff4f26601a9dd94af52c1937af26f137a01acb75d3a0413d6593ab509c12f08824485f2a75be0978a7a013ac895f0ccfbac9bfffdda214317c971f291ede10ba023bf078c332250fea5698302471f07cc674dc7e6d25d0c5b8931b26409a123e0251e85f962376c45346c08f7f77d130884294821025dac50830b2784b27393dedae3ac6cef1e893ffdd328950d56f20320343eabe45889dbdacabe926c2e76c3ad9fe8a2cffc12e0a0e70cbd78c6242baaab8a4a7812a99855c84784209111b26aed1ccd319e8789760b154ab5b04839c6fa30763def2eb72e0ffc9131b4af70d22a09cb3d52765b1c68b32827dd1152500fafa0f588cef31921512f4ca5a3d2d5469c5d7981628067e53ce83335fc7c9db2811a198e1a1f8ff311d432cb0fac8267dafbefbf04a943a32ed816dc1fadd09e2b71ffc29e7d1c9e4096135d4ef28f49b0b566b876924e747fbd16f4b36bdbdcd0e42139d0204dea5afe31e3a6c4e4d98794e467466ddc1799afb6c1c87ac827cf739f2ff78b15307b9402a7a78dcdf9abbe9344f3f1d98081bbbdcea0315d0cc4479f187b1c2c093d0f55b9bdcca32641fda4e3de0f4aa67db12a9e6b89ee41f666e09392945fb36e926997a3a957511532263ae804b67960a08129652c9bb667ac1d21bb43c3dc44d82951366e06a94e2099f0a3c9ce48c68e3956887230144a72822b45d0a87f3b5161343720a1029083844efda4bb3fd9f0cc2158ebf685b312dcc1ac80935667fae3c2bd57140fb0d5a62994d3cbf246134bb9e5821e4274056fd785ce9f73344cc6b1731b9da1b6944fc1da3f2f9c6558b84bd0050c36bbfcbe5704bb9f456f69be37669abd139878a2914f1d4d2c810e500df351499ae3e9e5e35226ac0e333b7a5eeeea3fc9b05db3a1c15f8b48a3725b71868cb2b477be6d0f9a91af639fe4d3268e2660022d761400eaa319b610f1e6e4fc885df5ffec03e8581c3787d30a976a3c6a92da97ee36a8e610eef5a982e50186fd6c400a9bdcc790160318bb99679cae15ac71b41081e1b030730d371c2dc1e43edb369af927ee9955399c9d1cc88b1ecc72803b8cfafc446365dfbc0b1908d38f0c11df28c4afadc1772c805c5d1b21976cdca31e8d833d175e3afaa498340f4b4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
