<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"592c32fa2a1e708dcc9d4091b7b2ab49e147de07e43c1ed39c0f0d7293c59ae10bbcd5678872e332143624c5c14876529f1648a6633899fcea9338b9aa54f5a833dddd101a4f16c6e03e34a0773bd0c57fd758d4eb7284243cba0ec3323d096589fe50b9a89035268cf35ddcbc4316e97f6f575e26ffe23715c86113b3bba98b72f919063e73ebad341f010c68f5cd7f5f5c4065a0b567edc16463eb4406e8022d773fae52eecb8ba55ddddfb7275aa5a755e2c8945290d317e9b20650764dd6b58abd613eb781b53c16bfe6db17fbd897b2c2a0a822a56c500275ac05125cb35cea8dd1058e0d4f0f65db27d51e00dbc2e34d2758007ec6e3359bf0ee951bab75ac6f528415d14dc12436bf84c8b54146e660eb4c8396e44d6b295a2fb4addd0458c68b507572f96e40c49a1504f4f33fac84bae332dae871a00254c96a5f25983d262d42e0d27d3cb56b6abc159e332dcdc59f6008ee1d147050e1faef4cde0be1d7abbc5f627920ecbdd1f903ebafcff6cf0e8699c1223b4b3d644eec689104f73ea02c35a342e2f38379b53105cde02d99515ac61a3892e8d02cf7381f5a25051883ed1c52d86f8da95ef2dd4bee21bf54e1eb116025bfab9b18d13d3e7e965b9d70074b957d6d1356b806a8979048bbe551e409ae9de53d78fe35b9fe379b4aab1cf67ee832e6ef61342e47ddbd07abfdcc5981a61af50757d98dff3f15aa648da7ef7c1facbcef8d3f9815ffb70c94488fa88f28cdb7ad4f93f3107b006d9c6de3df33a3d504ed1952ba19d335d333d7196ee9f09283affd2f16250ab6184ccfb88030a3e120cebe4cac4a8cd4d8da743b9c128cdbb92c43475745c16ad4e9ab22db87f4cb59f11c3ff9f4d5444907e8d88a6cf3fb08c6b6e3cec2931b3d2e670a054452f69c6dd83e5932e4ed1a92c5e4af3c3bd807b19beedbe6f48586330c24d511d750d79225a09571d2224cbe267879fe9f6d589c6c535fb52154f0c85655634113c00db25336ff316d08c01b0157174f9ef38c838443154f3a287200e6c6b34a46898ce2d1cdcb32d0a429382f57891c132f16019dc244f7b30c89f9a8015d8164d6e3a808c6ead351917e721dc1eb434cb3fe8adb2571b19cb3989ed4ce97bd1ea2152db2f2ca73c47f5dfa6b1fb20ac8dae2f8dcfd86356259c69b58258b0b043bdaa5ea530212664b3a777bf1f0b72c79038bdf08bcd188bee551db5fa713f8d95ed0a2830dc8d1d2fae7e7f1ee4ae1c293260fcb8bf5f1d2093bc9b31668af04e5a99e5f6985b2caf7e593cc4922ec6f84588da7885b25f67c8bba003b12c1fba6199ef9cc48253041777e05b8b797273baca82c1f5365ae8310e8cf6e284903036e19f8a9b81ecdf25b4b8bdf7bb78133f740c4ca6700a8f7f7de489d42aab17e7fd650abf79396987fe73c9b04706dcf864fb8123a07abb2cb1a12b584086ee249c18093d47d066f032084f5adbb67e40a5adfb49211053ca1d0869895aa16d4fb218ced3ee1e996431c433577e29c242c8ed04af51c244a63826ad3b0d55367fe1830e9e6c3c7578a80bb16e0772664b8ba0e4b3159838477b1e0aba362e8326030a864887d7c5c0ff1bf2edacb03f8d9a6adc8a29b78d50d1765d7aa61d4a54f87e1fdc1a1509d11b1bb7c115590954bd736b672a6f532c00b6080e20f16f8601a9003c2e6e0bf5145ffe8ed01f32e1d484467bcf18fc66fe07252e95d7ca0dfedc14c91ca459c155c8bb9e584b127b9df9fce9a425ea841546924a8d581f97dcacc55aaef51590344974eb63f24a75c74bb9ea4c3a33c02e9441a87bbdbd81a99aca824462ac98ccc2bba83516f9f1ae40377f31d2e4b140703936cf288d05508a0b8c8169d093cc1cf8df3332919939630c15cee7aaa72298cbd329e7d8952611bbf16abee2c73867f3ebc03df208957826e86dcd88baa0954dabec94b0aa5946714d5720a23c596e00f06d3bbb82ac41d8fe83c696cd1cbb533fb00cc1dac70e0c11a4479823a44654cfc605f6d515da570db11b5a31c718692c4a646a59dc4d7013a50f9dd519b870e567d5c542cfaee4102ad5203082f51c0cf4f51f056c609b99b8164f2c691596a5462b63da4e490a4b0fed70c3c6c883343230903e7d04cca41b2867b26a23883bc0d61890b71b7ce278df96137b84bbb5f5a53efba8cb6c42aa26c0cd06472c847185e73d85c5a7919e8f2a6f7893e3100985d092d9c8f7b9cb25780ff51d1c7acd44163aeaf7ad9c964571319201dea0ee4b682bd37d5a426b0dd28af280c002a8563d2ee247af95001aaf56e817dc4413d09eb20f1d3ae08b600c90e1b1b98e60c49cb9ce12c0ba7bbaef3e603799edead2adc0afd093bce879f22b2af1d0a7055eb659d8df890b75a8f950b27a47ac7ec100786f1230942f7c9bf4509e11e6ce911a59bb01215d98b1931d01e70e40cb7dcd8ebd582e386c5aee5440dae4a090f0012dbfa15de28478ee1301290599a4a092eb060276ee01b151877d5551e1453818d9a29c2744679ab509c50506a0ea7f13fd7f4751d05769da5f093af695f413b5636c89b91cb1bc72dc931f69b6bad9f9be2da9858b03faf29fef40d014f70fa9b7438c08c0f2e808f3586b3c5a891fbeb68b336acb5f375ed0b4bfb0284f0f009d0a1ecde2ce2df54a1b3bac593b356c90f16279ec3a53a053697a8a8154db80df38ab535ec432c69f99ab521073b522b389ed08e61e4d56e26f752048f4416e3337405efbe6148bec20b4693d90207ab138578b2da984e062dd85700b9e5e172c62ed84dba0d153823673669015ed85942e7b96dfa35bb1806f5124b7d846fd0db1dc27ae9a2983b32324ded4762b25de1e9dab0eb4d721c721ea5156d3ccfe9ef5d1f60026796b40238a7996db270e7b9bdff08cb24345ae51a58e50db732d6c9290fb4084726fb5c1a560660791995bc91a55071ec63b90100f26fbfce2750b706db559f36402c6c844d42fe3a253b0fe08b195f4a49dd4c415f0cf2e580d84f68acf4835f6982b2a4270f89281192e6cea8fa4b7de9eda14f78f8069ba63719fb2ce37e2af0e5beb5c43956821af839bf25f32cdeb8d440f3f4c56687de1508535928459bd33412daea3e019e4a4f0e5fe1a782e20620564fe640c045fc23687f1fa65709259a1b85f159f2ea3f9d3c525af269dd7f751f5ccdbdca40189ca9bfa4065c9e7f62dd5da2b4f555a22bdc9059ddc8ea6dabd311ae25ccb8acba07eb424c5a7b96eb6babcfb8fabcbd95b9e20e0d5423822237b697d631ebeaf705817992522ba10b800a9c0cbe7e0f98a57b334bd15d919bf4f615e91cc7ab48896fa923a07509c521d51bb9dfdf4fdc1e424e7f0a647d9b2d8998814773f6bf2e2467d04309be910b215ab1a42bd72e9c5617d9adcdb1659588dddb6b532a6842623d0d7c00f7c8e628edc5742efca9e4345eb825f628da91bd8651ddfb27f7dbb4265b19a951fdb163b5024d53e7407dc57200c0fc332f2000d7bdc19bfed2aa95a58e0f13ddd46b585d8ebc58e16329f154e47aa31c1995bf20e7e3317981c67f4a1c00e8bdf05a8742d027668328de59ac60e53266fce423efd29ff4fc170e0e041fce6da25fbd082389690056761e03438163e91ba9c53c546c1b6230cdb2b692190c2857e3bb5b3459c2e0b698883fd864551d5722223729b60fb1232cec8de26a1612dd99d4f445a07fb057684a4612e9a8d4832859c8f65625be4cc5dbf398bb8ef636460175a8b987645f5d36e19b2c28b5ce5bf26a90daa7609d03e6a75c49a0b6a46d4adc16080a13e069f3e674ea4de675f17ef819e0c71aca62f7e38464c4be45c1daff4dfe8a9b28a4d44e89e0e31fb6a8227f188f36e6b200cd19448df00947975feab86efdc9a7afdb0e860c725738d905b41a9078c93531f12a4015afabc15df9a445cf1a2bbd108b885ddf6750ab4ec41285c7fe13e0fa0203ba75c5298c8d52bcb2e03f814baf6370ed6a37fcfe28394033f7efd191857b2620bf6bfb701ba904310a727bb00a45e10636187ed0d90e16b3da8c2cd69a1e47819749c490d52e48882508e711570e33a538c3a460d3a347c740b1433427ca5f39ed25fb9bef820a22ea1c16034af5427bf8ea1f5092e41b72eb7548e6113c44c9bc5d2796598d2e2a1762b3e919bfff89fad35d65744b5b939a1b487c1500b03cb079676e90eea2defc0da7b2f9b9901864658e1cb3aa68cfd83241faf845c1a07db4c497661d06d55cc8611760929f31a0f6fe7121798912d2d860689c1858ca867d61f004ce81db5ae31a60fd7c7b5db096e45e63f2e9b3ea0d12e0e40709b8887a77da33bae83e22854e95665a1244acba38bc9cc50ca63e7bc6418adab50e6ccd158ee65d9cc69d8103ac58d5a5af4d3a946cf98f0dad389a7acdfbbd9fef2dbcc761dffb3e5ab2b1a82640a100e62961175f492213f1791f69e5831e7b6eb960c2b57263eea4820d38a673b61c4020a3ea04011d43dd83f8db28acaf9291a3fe1cc7f272279e1b6eca391defbb642e9783054abc92498700484d1532ec85f65ece02fff60d1e00dbaf107fb114320fe886e8690f5c55da2302896f9556a07f069967eb85bb9635f9c8ab75d0770c8f16d3ad0bdc923ad10d8f0e53693d04f70c84ae5ee88de5751d53e3f500bc64c9e900fde2963c8f6cd39be1f7c94a2677c104898739edb3910ae8b6ae658879b79067466757be100273c0a1624c7e5cadc16aa72abe8bf9f1023d27668e445206f2d0240c8aef2f104c0024bb029276a6f1eb85d20b7f1392903831e461e39a8e232266914e2409d714feaae118b2f767e88fbaba5b2f50ebeaedcf911ce4435261f3378d6cf506b1de6ea4be05afd3a974796f854de5fdd676b12052982cba3b154b7585ffc35bdf81d04e2fa912732ffbb23497f5b0ec1009712a6663839421c6c53371eb584ee7e34c578e45551a65c3dd5d1ee4fbfdc724c644a8824fc0f85f7845b28f87a643e212f3ea8994dd5df6aaa675e7d4b117620c11659974be8c24efd39e056e495221315a2df44b7a8c5ffa3d226ac861359c39a0545dde7122d8bc159e9096c7d48897c3034531369dabfeb0b3e837a5cfaa9e8f99b287dc325910631ae1e0393ca1151c5bd23e501d0b4b56b2f77537f92328e161c5eedd1fbf1dfd001f93e4c7c1fa25375a25255b34c5e3e5db9314e2ddf52ba78a1241636b81ca0d9c28230d18346b85bdae9a8591e991b1c7c5068329775c237a8cb486b0c05c6d90c91de57d3a81e4952071c5fdd3e1c6e1080346562f3c17cbd5b67dbe857108b35ec30518fc7f7512e4bc74caaa8f656c25b7ed5865fb811eba82192ca741fe17d71c86c86c2142cebfec48b389137b91eea0ab33a836285b184e168277b5180f61daa608b73cdf3752239b9fd8791164bb80444209e0e45272d3055aaf15d989d43fa5d72b3c6ba4a223234f8116715875b7905f2d8f755fed15dc9ce0192c754f9516d4aae8227b23948d1a42fef170d609e39fb63a78b7971d0eb66ba4153a5cc5ec5b27b73f28581a99d0134850886b597429693c1ad8258021f071cd880a262909ae14a094bf0823b4465429c9995cd27d9f2cd8e3f0f59b842631ca79e8d2a216e925f315d7a924d8d3637519bf66b6e2b81c0c70b387134f65f5fde45fba05d83ae35bd9e03ac9bcf294639b38709928a1ba315dd431bba204b80d1bb4ca15dc9b22327f212775bf4cf0cb15adacf071b34961e34f136339b24ac92c0b770852beafb87e76b2673c17cbd6ff92c227bf40eb9825d8fa5ad71f0925d20d9cb6e3df2f072ad2964283665e10f6cf4acbd15f9f6cb5ac6ff541cf092283c088968bdb5efd02bec1e5fca017c98e54ca67ab21e232a69d9fda614c24e4c567da70e4976581ad863654c728070b9fceec5e501a452a1d6769be718a46529e7e057a1ff3d99af87ca70f6c143755085ef7af34c70895d1d7627810e2a71f50f986ba8427a575c839274d42ec2b9d976d9966c6e3c7252c96f51e382c8a0009e5587521fc32ae97c70531781afb4a0b2e5bbd90b42bf34889be9c8e43253c3a24f03c28fff5832478a98bb084709ba673e2f68a218c3ea2f600c05826e990ccaa5fbc03853a60604c3f52fcf4a2cffadde504845c6b734a54046445e0068ecc054da8434d5569f095ee83f943f0449b432397f0d5bdce1d5d98e7f448cd777ab3c8c93dee2a5b77dba729e30c174ee410a8c51070bc1e180874feaab06cc6eec80f6a227eef249487fd05f160abf47007eb5d1e953bb545bb673d3fe41a96518b9f8b39f08109cc77287da90784369f2c68dcdc5a7f235b3d291860675184518c4eeca32d1d0f22110760e85531d89df6d03b9a5f4fe616bd824f2dd80ab4d35f7c470fae664fff25df955ccb75ce22926e8558663cdecd9a2203dd3af854b1fc512596e51ad28323597eeb250162a72e96febbd8f5ca74db04e830063517003e4ed323f5aa8ec331978649c9ff965fe1d6deadc6055f8dad5af8504fc5ad6570f8d95ea8b2861f658232aaa3d2e28809de79350e18f5ac586aeb120e9ccf5c65e0fd30637afa7c64dfe76b705a7d01e51f58e7999712bf0c91d6664f8d30f3958bfed1e72627745874380c58a1038b54f11ab72e0fd1f558f9ada8a64daa5b0dc68fe574266bd78c7bf827e877a2b3aaee9bcea03ec79d3b43434fbbc1fef7174c92d641120ad05cbaa1b1fbae1f1693bee8f3465ce9ec7cdf89c79256ed9be63893c0cea40aaa1e598669f53a8d236a646263fe183381876842e25f251ce6608393e7e94af281d9efe867193c429b01baf866db54776f511fc64d5d049c8b543a334c428e461b307423d8b7d7bb9d9cf0ce8bc1af956ca7e0c496d03aa0552f25f1f4aa1fb98987c0260ad19e68877991c416a9694eba0aa3217dee1e0f9fd6102680079470e8e2d856a0e16006d5abe3c92980fc54e73e3d2bed39d8e9e01a5f30490cc8b3290a07bf37f230611a72650fc178b7d7fa671c6d75fe342692424ca47d7a5ec2bb454c369882afd3ece179f72b9e223c3894dcdc52e9c98ffc18eea6effc434a1c32147a66ff56c34ff8d9d1a7ee38b9df6f5e4f73e7ee5d3c8b7b94ac4370d5559ac2a4526ba899d794eaf24ad1039c5f4ecdd4e97d9f723791ab2b274214ec7d3cab2d49d3c1b3a5da044c0a60830b85292042d290bce5076cbd7c3a275073600a16a0ebe5db511eebd35b2b1bc1e45342b206c970a1fe6d80b6a7b06670029aadf333ecc985d1ba7287c5c416ef36454fcf81c2b9e69a26e1b4eef0c51d58b5d5fa2790751200441b3a2a1b5e76d980ab50c25515bae3cd003e90a36f805a0b7474f9c357b640216d38a1a222f377b4d361df545fddd25672f9f11f74971d5d82cb48c7ecf22c26d3a544a94079db6ed23b7c9afd6c5a1e1a7046fe3fd3430420844a8bf4b7294f48b6d77629a0cd9be781b85c5d66dae047a7c48a870eb1778acfb46174bddb6d5cee8f708054e006042b610147fed60051e7ae292edf69754485b0ea53b13346528209636d3bee2e8eb1151c0676828657dc770d7acd6a9ef18e846e5964b99dc8938921427d260a6221988e993d155ad2db72bfaa203932f71a0cec0d38343273e9e83c241004233d159d1e30a3f73ca8ec2dbb0a96c8d27371a718b43a20c39ec47aa6e5a0d4eef6aa6f5abc099191957ed81fdb1fefd71509fb415ced6beaf30a45a8c2810c2ebb86b6d4ead0054e3e18ec8e3631259ee829fbd55b5e5d61a2e00961da7c487747153427ed00ed317e36b85273176c90e5d9591a6cb8a18a91defb22f2cd17d70450941ebe996bea4f80076538c6ce3c729f46c9eb7a9e513c83b0c56735af8343abd7bb173fe7490d3efd7f037a5ace91bcbf424db20141642f43db5ec9c883c52250f380480499dec96229e0ef2dbb1e5552536256685c3ae158b91d878ae9df207f3529f53d6b6b77614fa67806fcb01e9fccda1502fbff05cf9a82ac7d997518622da66149abe8387be9c83853c9fa1c7d99d9558e3c6e6780dd7d8287cd908dd517162168ab5a62e5c6fda58fc2994e2758f55db358b42aa2cf8a052061b9274ba915709504fd9010f257023fcc52d43410a7796293d82aa74bf3bf920babf4c3f5130eb1d8939e810b220c770bcb7da96d7828851f7923717014070887e7776b46adf8a8fba12299538ca9e3748aac9e350d1471b30cf80734f6be8cf3d5c8a3c878e0b08d5a22790b8d4312ea9f3aafc713faa19d225314068f68c072de9332cd68a5565b76574f3400ab1742ce6a5f9e4695861d0b5108523d2acc0faf42c07d0eb719d36ac6e5992d6fdf02708600e781c11f82f586150ff64e569f352d9ccf0abfad314fb4299e17c7e32dd7224589729eb445bf9b52e3eb51543582512aaf50802298c510f69216ac5be173167e2ce6f08ab68a99cef2670329e5e3be7a5314ce55c338caf4eb1b3a508938b2ce21f274cd25c213b1f38e3b5cf6e594d4526305df3ebb4a56cda4d3804f7d059ea113427ff5d78da42385102500138dda58399dabf6255176263a0aa846cb89e14b105e1b6fc94099786c2f45b80a8789da1a2e740c50de6a848693ec51e02956e71007ee95b5d315904f0883148db93e2e89b38978c24576a8208a3ca4cb81c7b744c5dcb78544517248097c431b185973f23eca16c9ad7758d9960ac37d21fe8a0e46e697aadc1f1c3cfe8064b0577480863ab5446ab2c117489933c73767f8857f300919ce93a310f4ced00726c0e2a7d9de05bed928ec481de2c10edad0dd567ef812b1b430b7eab0f96710d04b60c267ea2eb8818fcf628bbdfca081bc58f7d7da9c461de7d9648ebb2a0bf32dca6959adac993b4fb361dbf1b984dc1a6dc86e10694c4fcc6fb918bb3775a467ea36487949fb652ca5839bb5153a81cdd38c1b3813fda506ad8f497f84c0ef8a26416fce3d6b20ebc83a90a44a674d1e9237ef0165bcc77c489ab0a6442030a409c2a833dfdabcab950e8be651dbd8a3de648039a3af9278337487c303af539339bb63bac782a36e051e3f3829b94cc2cb730e544c248da25cd5f5416b3682994029e0e5fb66d3bf2670066eeb27d50b01b611b70ec1d9fa6207bbff658e58636289c10203742d40a45f9e068edf1090228d39e30f639ba28f04b80876cf815fa4a8bdda7aefb363d62551ca2b403a74ac2d1916307d0c131da96224abb1653c59a483c812419ca9b93cd181a516f1ebc3e8f2f59952dc5f74a51b58e220304726ca4313fab08e3508def2f47913b4f7d7e702474fe140e6156149102932f4773b86f2bc28ae2af14a65ac88395de76b20ff090a410ba89bd65007417b5796a421faf772c34fab9a066c0a38f64c208fd2d6501ccee8bbb44b14620af39404cc11208a0cb78ae75d87a9a459c889aba84a041e74890eb44fada084497bcf1dc6ecc97134dcc670a335d675ef6e3e9c7ab78d5013fa6c462e7992a9b620c3f2e1f01d3fcec607326ea4d4145f2c92cfc21539645a2c700c951d02866166176c7962b46a1f650f7cd4ad643cc4ef6287f464cdb4a75621c63343c26648b42afabed445b2055dfa87bd1c637b1ef21843d2b3f05c266a0d20b0fb379ec3ca4292fed8c80197034394ef5857f6b6ef2a887041a07330e319e89084d03baf511efbbaf23ada80ea47daa253f88c78336be2917766e6b0b9e11a63c403e96ff307590317c0f482a905aa8ddcf35142f366e2184776d52ead13b4ff7a9bf9f574429dc2bce4cb902d451556e9be0265350dc10bae3104564638f814ebe2b514bc1e79a7224c3d95a14726bb0187afc74cbfd3824a8c65973651334727420d22ac703e76712495ea09ece9ef63553cda407e7812c5c9404cbe86304ceefdd1d64b2edfa147d6344b88f47d79ae1aa1891c9978b553a7e62e839d46b97f2463cc9bc94a6e01110c83f9dd255c12ab449ef2c124f7e541abd0ffbf17b9e0d8167a41ab94d25719da81ddf6a31cde110210b59de0dedc2140fb72ea927e2c486fec85099d62d60dfe5646e758688f9273b2b7c91fe5ecd2f2c2096facfce0de3fb9828fe4092cae33a605eb592a1c1f126aac92196979e941889a5714aa0f66d4e508f140a2e19672671a214aa76c496b1573c3d080baf23d0bbdca639a583388ebb843dbf04abfe360988510beffedd952aab016f37effd0c6655caddbd51ba74a2dbe2223d0d09c9d9b39465a71e0f96da8afb7a8c0b9a58fe51e5c61af269e143c2cdc880f81fd42b2e481759b4724afa047d7fcaa66d4f4c02a3032c940dfa9d379731ec3012734b61cc6ec900a2e6ccd86e38e4e493836f85defa4754f8e52358b51207cc1e2d1e2b19542a483c015826d752332a624ebef22199fc9091f6eb922880afaa828860f64da97f40d3bb48b6260bee09a38bb76f0c32ca7117548dd80fa3e96a0958409c4c84bd54db97334efa682b48d96df08f19d60e816e2f07445c953b7c08b0f5dc48ea2dc567bc5808ef42622de09b9d19754eee6238473943af75837bcada05466b3b72a15a28240d6fde7407c55ad03ee84b265f1edf174434fb39c7527fe204f65d9b2a8c417a18a8501e25d4a3de79a100ee067adc44b1e1697566b093a968ac99dcd6a1c4df26cc7c4809eb1ebaffb9802e1628598ef7c1b2688be77af0a59000cce2ea71bc0d065f3aa6689b47fbf37b978f83dcfd931101cafca42463cdfde0483fbcdac88d446d9b6b943e6d92abcbf2d7836d30b51b5469540be948c9217e3ead3119f325e20ea94a4ee74412bc629b48eb380bde2659bba2c1bf754a5479920eae7e76ef04053460f5c3f8fd5ed48e579ea7fb132c4b4c098625c9d465779d2bce4d7e93562f666ab856a691260c9b78804c0111b8f21d2dfdf1e30814c6ff0702d2d75fd9e26cfd9ff60b165bd99694f8a4d3f096ca150f3a370b4d09094735bbd0e65483a8357593fd5be7925ca5c95a8e3317ef7b915b6d0a08c1b3e0ea834dd78bac9a56298fdfb61d6745d1786632a949f45d91b970b1caa0717eb6c754e34bd134d909f38ef2284e7d722cc2c7137b73f93efa91e640bff309af146af77f5063be688e5c0cd0e67fc3dda26ae2a2450d712e28ef6c91acff08ab8e6f0f9cd2e4f75979041e70798ebe304b36ee121e20f03bf56b217a16e46074399ee022c847a1f8b3ec80452dcbc92253c3adf68117c1849091d96da7803de7c97a66cd07ac46ce9d9e1ab0087b3437876a93d60e345eb18a48aa3b84ce450b4636c70b411651cf645b891bc79514a268c85f05358fe0cd696b35ab0e053eef5c8faed8a0cdfbf1ea4979f25cc5a9ee5a415be735a8df055decff4a6be52e0f0f9ae4c72d0385a5cdf0d71a3b42600569ef3850123a3683eca75d44f1f9e97039315422e49a4bc39c31e9f2b8015988c1f01f12f2d90572b8a6d6a925e23cd170bcb91da8bcea0743a4416ff0a1ee61c78460e65073fa532179ff96a37ed6583c5771b0be02a5abd31699e81dd3145492abe8a50ba8e21f780940148d015addb75e6865236b25c438ca2652e60831da1af1a712f205d2032df765462e4bd504cc578fe3793ab929f4866f7fc546f51faa501a4b199e6138a47c5ce12f7b8f85418a035a06e251401b6941ec912f89e4414fcc98e540f704f6b8f5f621a409942101d97aee4e30b15c16b6adc14381bd8e0e83303b0a78769c04dd9d1ebfce1991fdf3eab3ab8c8c64797ceb2e82b72ce2158f29f803614f5df7a1342de8e13fb71e57ac566b74e0380c7795ed722109ea0f7c41b12b18458a59b6a4b7a9fa2e1ff45b3653c2b52b4b2f26b04cf75904c98fc275074f822229414b4e617aaa623eeb1ddd12b2b6c58a31c6f20736aff65525ed2780f48d9c7943b051f7c6a51fedc1d6589b632bf169879b176687963574b5b79a72605bb65149859b029d42284006ef56fdf486a1fe75616a18b4999e1e9b2658345019db1d31e4d9df33ed5261f3851da2db69f2cdc830855536f639d6fad41983b710536159d5e4484f400186fc8e95b50519389ec0cb7feabd11a9e238b56c9e799208f66851d56e7cc97505f09c0d06c007ac9a958fc362c01960be722a6e0234eec725bc3eaeed3fe5a5f8550d9fa10a2c9c9541b82c38354462ebb749c9e3c608c2f59f259add2de2c3f5fc3ff9fc46678d9e326d4b914538194509530d7d31c96b41f6e7787d34c2d19bf08fda5a027af258084171b9bb05638dd694cd0a514d696b142160c6917b149349f5a814e7b619fa1e6c9546ceda60401266482cf1c9f05c425653a55f0690da1792e1291d7ea94432bb2d2f9ac321d5d21b7fd5a2c696bd09c5a8a6e2999d8f3048af870fc25e70ebb0fc5b7555dc6a9b37d9b0012cb3de60e68acb3265bb6c6e4a361be1888d7598f265284814870e6ea53536fd0fa29bf8a5d5e0252617a755533ff21489a4812e1116e8af103797c122ed60a3a0201b8486918f543e2a3f563b6cc0f76403a0457631cf80bf38443480964c60c8b4b63c6d42da0c42fbeb1987b9d59f8ff11e9e7acec97bf104febb026becbc5ab5628c988b9bfe92756be8e0d7f8368a8efe722821224e177d2330bc9df0361e7302db4a1e42e34924cd639bf2cb1b4cfec598297c0dafe2f71fe8df5e77f96243b6e0893e5219762d8b48f3b0ed21400cbfcc700fe100b410ed7d94f29ea2f4d80e629a9ece5e3ce67d32d227f540bc6327b8ebadd64ebea1b6b4972b33a3b908a25ee9f75e7de6fa73414de43a35cc8002f763a98187526114d593e57e8c9d65a28775a965dfb37c6a2564624a37bb8ca7ab64f9d765b7a17457f2855834847a7ead3fa93cd66a168f9cb1d9ac87a37180ca3beb057041238b05cbe9e1d81b979ce132bc2af06466609b5aa2a9e21dbda5ce7bf329ab7b4fb2c38deec3607152fc10399f2cafb9d5d4c65c1fcc688111fb8061ac56b7ccdb0220beb4349261f9edf11b01456d8c5b8840f43f8f668e481a47ffe82b1c4905ec201368e96e4659ea8e33c410eed393f397160d5c4b934513488b7afd26f5661a07a52cf9af97f7320d509d7ef64aff21efbebb0bc253a13654cd6634820d230c7c4ac1dd4ddf785e94fa593e2c9516b0d3ccfd99b64cbb4e9e80853b9b2f7de681cde13fc2c8ab36ad546ce3dc96d109d96ef43c15258a328047c354477acef0ba6341517928faad327dd684b896cbb8a0f281e1f2a742231bc46012c3e4fa7c14e39d3efedd80e15266186af025bf300f62a5517aa5bd4605797d4fc6b130c84ec6f7344e0eb6ccdcb1c1e685a89623fa25a248ee638329072400ecdb76be366084938552b7636e9433abb8065ff07799d4c7ac4dce4c0da1f78896d20370a2985b9de037a4020379d20b217b0964323ad5126e1d51763b82fcea70f5e5651b2ab2e7f05f7d8174aae5152b93c58a63d62fc3dfc6ee5aec4658bbd3915e2fadf0f1b90874cf189e205aa28708e4fdb79d98f69651edcfaff67ca76227f7ed56e7778c50e5fdcbababe0e865f8d100738e4574cffc731653e8356c59e51905ed1b541f0edab70b8d86ef18e1171f3c996959fe60d9556405ab211d59c76ce87f4b6969c3f71f6e6c08ecba6bfa7c490302ca1d505b6c11ba410c70665a81c48ad84b8c8c419d7021fa7da7448a9671760ca83d53187d170233607f8966789c784d7882d1ebe1ef7c16f1591a75b2081e6d2f7c070d3830ca6998a7f725d3bdcc81889e46c1bf4cb2ae8d6609be4f15ee611766ed6aef3f0cba89b3043414fd4ee1a6f0d599f8e6a79e0775247f1db510ef1fa1ab309b70dbb64d4ba8159bc025c7703d4299671f038b5fd2a1e4e346e94f2cd70043838336a47e513b3557871d5b31f256d2dd663d6989499742422bb7bf512f41747e60fd577b167bd414c4ef90283ab4cfe94da8dd51c9c5d787cdd60abcf88555a59980e3ca5dbd3cb5eda4f24e77ec68424b2172a44a34a6578171a850b4de4c36e3d5fe11224ca712799424d5dda53a6638586d34e7d491f2fe86d957b84cb269a7c177ccdbac744a9059bf16e6b112e5782493727a583b79a088c5f9253a01104365d340533899bfcefc1dd7f15aef9bbe2162a5ecd8b4d9b689d87c7907da3bf60ddc09df3eeeaeb5a8e5e27b9dda6d8c779e4b6bfe09cb689eb2682226a90d83a04c24ca574028a4e97ae34349e547234ffcf148ef5f73045fd416249e8f5349fe03b998fcbfb6334a9b414201c85d4fda795ce207be66bb4c275cf2ce1ddcd31e919337108d7af6c6e1c3f6ef45e2c9043c7641b28da920838c4d6098d89dcd294131b9ff564ad85703cd006e6012e288acb1e19e29566a27f488e59f0e9ddeb11cc5cd81ff09a74d732e8ef32669aacc4dfb4cc5afd4cfd4ea0bd9812700c89eaed012f3b747230d96f2f6883a69115413f7fcdae4059daf7d0cdfcb57ed6efd11f0b5c57f4494074f35b16e34a41c960616dfebe962c1007a4d7486b9f6c32f3f13944bdb3353f49e6d82c7175e035e2d7a456212cd5d372f20de1d99c4eedacbe4fb47ae4447f56a5274f63cf910d4dad80749b9cddbb449e9e24c9a229a8c579708a073f5c72b44ca43d5f83d0aba675d8d2cf9d3f08faf5d21c2799b6f47ffbd2025d092f213fce300d204567015929357c6116a46dd689cceeca4a745227cbaa2f7365389afb4061952e1dfc546891a1c6146b0c6f1edce3524b3a80f8aa43e5c11f4d44a4168c4b7e46f9f70fc69ae0a531f1bfde3e8198f40c83b89e61aae05b8abb3b41d256e3f6221aa08bb97872ce03851d39603cbdc308e2ee0294f81f519f2b9c933c8690e2288e1445f067e046df10251ccc2685a1cc1e173facfe2ce8b4ae0e1dff7267d9a1c984668eb7b77b7873939f2933873c53aeeb5508fa91d3c7c0545b42d3fe1b166d4094918f82690bff3c37681ae042eda1f1353616413438c5606fc80fbc90640c0e97506cc515177766da248a06376dbc3b46dbd0d2c76d03e8319c24cbc7e55c759210eab1bb249fd894de7b23b36680e6ac52a5ba0b81eb696071558484fc6750f15a664fef7140943e3a67edef154f704ba11f3d50aabb1fd4a7bbef1d765bfc7f6596351cbc807fd7eda9acddf1aff805d5e8cd3d4ac0f7b4d962148317902dd24c01d6a6bf269e8f71db184b06b6e214451c1946eccd2d75407e1fc7b961961e4ced3e74cf1a31ad4ba31cd960be4930455aa7c908c7289b27b4a69248e832ad7505b64bb269957d25d85de369e266f929bb78a486bb1098ebda4d7ef5aa1db5e927863f3a4d09d83c1e9d1fa5aff9c5079a68733e845035b1d1fc72ced6019c489589cea642060442a609dd9c5bc5662347998a39e113cd3fb10d488311945c40ffa5f25900e50aa8b264831be12b6595e99749f9df832c5ccb9b5a729841afd6af851051475bda7232113023beaee82bb11060ee61290d948679fbef949773fe0ba34b626c67d680454ee2ed566efc4ed1208cc7c6940c6b508423d987156e19bae4bdb88e021eff55b836a44267d08a282c276341353493f0d8829be23818d9896bfdab514a7e2ee4dcd3267100e3678f8e54fadb52625ab92ba015b3edbe8831912f38186345ae62b50c7ea61d1d9a23d4d3d8541cd4afeb66b67e92e0466f4aa3f35eda20b7e6fc887ffcee64e840ae4798541b20079d66e04505445f9033932d882302c0ba173cf7abdc7de73af4d0a0d39455b4c993d27be8c58dda8f4799672e14d54b708bcd94c734f68037d0149f7e93f79b4f5517e3fb04724791cd06730697b925a1b84d5e333f40a4bd66b78ac9174466063f38364686ef993b0c95e6dfc72ff793caec1a3d8883ac3e0e5e62d1e0b0170a321f75be96b73bdd008246265ba09ec9b9d9a2cdb253d656c6e422a3c909e1c071c1e8cc2c5e73d85c38e15f42e272087203eef0f4c6ac88dc71e895c8cd552d1c3e714e7ffca432ce150b5c431c05e75d829f7e39409a08a35b17e7ca665d3b52e3c5b8052b1ffbcfb1d771fb4aa2e0d008f730a7fc2bd06364904464a829c75739f82849f26571169b05b8a5add523ac8d0198b705786c2ad117c6418eb598de6a9e81b981bc55c3d84588ef9aeda3c761b1813771450ccc7f3996ae1717880d0bf6fdd5a2d49cb0eea1071cc001a8d865789421fe8b6b63f8e5e11b069c0e6cffc421974ee0c970d8862a2758535ccf844adb091ef77392f985e820b4dd88286f1abcd0b034e08b1aaf4c2509739ce03be9b263e07a527ad6327b6fca3cbe82b77dbb4b0024436b6df39e2cae3c8baa55a05fc099aeef3f06c5da506f9f986b0a53890af330404268130f8810297caa9862ce11c19495593641a5f49e2c94f70677496c38260e3745661d7e3f477e55e42a6c32d778835dd70aff4a9bcffa9cfaedadc96e41d930fbbfec412e5b1d01b0111fa8e724c7711babdb1fd898d26ecd940240ee5cba30f740cdacf744e78c4cad09122e131f7ff54a2646991ae3757629ae450835ddb21ce5d194ce87a4398dcc7b66f7d1be650c396bb81a509ff4c6992599d9302e8515eee8c37b047bd36299ff31cc1b88ef21b4c5dd13db2d95b0a05c314f0162f9c6f216e7a3fe26c67da7051dd68fa0477e490a4af8e834a30f81c1d03727adee8f73d89fe0a551ffeb4a8e0fb65d44ae32505b2dcb5002ed8a06ac2b02c7cfcc0f0ccf63daeed3c40faec1e715a57c0c3475f37266298faf06841db75dfbd67b0ab94e8c5d4f70130741933a1732776099ee35b2a146e044c70c1a18f67c77c2a03c3073587ee6605dab5e3cbf119baf1c16fc50aa63e1244c4b727139c3b087ecd83a00a4e2f1ba88dfa691cedbdf5ef9518c914c49fe88823a91ccbfea9a755503ac2e19fbf1c8a51b58f317147b2903fb8da2c374ce9b0108d64b5678fbe4895aa0a48a74aaaf8abbaa6aaee6cb49a9d133d6c4aac15dcefbe6e49c0bb013adc38c4d182234b952e0626f9137dfd4c4d4118889e5af5931bce104548c43a69f2eb02291a842f958bcdaecee78ef4ee99d365eca34cff10815e995e29d907c782ae97d59b5e283288c76e201c6d45e47a5b51a40ca034b4664ea3cda9dc48bb8aeecfe2cbf4bdba04904cc2aea8211c2d067c1402200bbb0c985966049aa32fa2e646772ae623e9730b4d522916428242404e0417f9ca8be747c8b30a330eca6a475bc85ade2904796f699675c9a44ce6666656f8b2f53cb0d7ce45aaf0f49df6d6bbaaff000f0abef8a4ade1d10b6f6b1052c14132752a9396c085b8fa4217c51e029deb6693e3728be07fd2c60a219329c60cc84823395fb302bb96f4d1b91b9546a09de7b6c93e773fd4efacf520bb3ccedbd522b4c6658430dd0932fa5cd959d1672a2398919591e45bc8006a0408e4b1fefbb7aad0d7012817c7cab726f0a0d70b09512f89499c40548daebde98a9f4b0148ed24f424e62e891ad7076270266c87498c6a8a63baa09b56e6dd24b68593a9c6c07fd5d404ff97adc76efafc5ebf821803a961d5584e196e9d2ef7eef2f2e881544678896c279f7dd4b3905c48d6f90bec3502376a298b6b6e917d010e40246ae136453d900ca75ed1993c0147fc4591f6a0a5d125617d228219049ab313db9b31ac2dc64c6e07f66b01ad419d3bcb7e4c1c2545cb42339404b7426c7fdd42ec22c17eb886a9d21b899d1b6ff1a6767dd3a7520c94e44d04027fa35806c716f3fdd9d3dd3f5cba4353bc7243c6223caedc41c825bc95875cfa7339d4beca1d60edd7a3d0e0948edadf19b9eeb799780d18d7321720bfc5599c0bdc6450db58f18c99795b2e06474b9d9ad8cd9428572f4b59d52e3f3d42620a6d98aa854a3f830d9621670c3a32a5b1b54a1c68ad25670adb07a6ae0e290dd78d35e161b33612283ae1f74b08461b77f1d464166de87cedea15e5cef85e98c34efc53e017a3c22c5a5ce4233c5267901e9de2e39ad55137e7975313b3ea5966424caecc6428d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
