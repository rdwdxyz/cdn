<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a30652605376ea92f9dbffdaa6885af03aa492a3abc534f25a5a0db7d58cfd50b23d92bcbe8f2dad6c3dbfdd75b39a7574bec312f62befc9b5c96efa84168b45c646afa812936ad9de25931b0f36b4b41da449a04bd2c207dfd7704f5414cc17f00c61eedff7a4f6791e4e42ae9d69d73b2be2f47a9b231bdd9f408d8018504242cb73e04596a063ac429eb3c7d5934afef6410c2650b87ba79a99e5ebaa2442678b87cc5fd6e76df52697d3a0f641a574ec7a65125c41ed67f8f09fe1a8386a681631e3262a88bdd0bfb483b7e1d8935f0a65f7a3c66143688474e6a9248c7b53db6336cdcf4cd535c3ee328955284f0f8ed8d439c2b1c04e1d6887001b7a708aa8f9c727e4bb6815420d8f7e08adec8ecf0641004412e8df3598e1062f84e665f2772850ec5e1a9df2842282d23b3bd78f56de79a6d16e8679df4b8636d14b5a1ab086428225e80227c9d4f3de88abd6026e517da8fb5c9f5d61e1aea41a535d8a0927321af1d197817c7bdde8e7070052e2340a01ebcb54e6c4dfa0ee382cb3f96a99dccc1cf960c79f3d61c00a7ac51971eb2de9d053d0e743be0c07589806784efb233ba18b37079bb718270d296680981582af6a65e325059c961852ad39fb284d0acea818e7dbfcd4d089e7d5c3aee3477e9dba5d33632f37b0079e3bbb9f4e837ecf9e40d90ee302c140874167f352759ccde8d868f91862797530c2000564ead0302583d0bf16067f0bbec82d6c6f1f7631582424cbadc5eb483b9ae586092552782883e1fba62e4c65ca7aa03ea9d87de774ce1ad3e6a725a98f4c23f457c1d83a141869323287101b0006002ce056b2f215f1187b29529ec4637ac96d38d4797b1ed5debc513f29d022641c10428b453cd5b3ded9685d94ccc1c07822f8197a58bf756541ffc56923ccab5ca4be43d321d335befb40759509b49a2d443dbce66fc19cf11cf90763e3e0852e3a11190d45168088870885403561653cc28982ade6542ec464227395a036a554b331867f0d497de16b2eb8e7b36afab73e1a39e0aa2df1714933d46bfbf3248d2ee1d41f0069cae0206db3a97ac6b4c3f36483ed57c9245b951b62e47f3c664ff71670c46a987d4ff776c35030d1beccef4cf838e96e42f00f380ef9fdfa639a4760f376a25a66488ebe7cc611706c37f798642c6bf2a81fb051c25619bd2b73057229ce8e458a79a7004c7685a138e0b3cbe6be61c52a12d2acb89e64a2d671cb652fd706ef9b0cb0dc384a62268e5b39f7ed6312f0becfa87831d70fd734e9ff3895a2c0ce17754893f4671c42a306998bcdd1c81dd8b89f80a7bccf7493630b91b1d6d72715d72c65e57f1e4c9dd63bad59278b8e0b93dc0aed341f7aa87ad850293e4225b67962f6d5c6e842fc9563a340a9557dcd87b32ac96bd6fba88fc1f3f98b3f33f28670104597dbcc5f177f49e7a5a1e4bf3425cfb220f7c97deb3d1a7ecadfb446430bbc9a9dc049444d6c41dc96292577f078bcb4bd4fdd8cf39a2037ae42f665dbe71e2ccb4020b4ced3fcdd3ad46297227192713fa47e01323cfa1f1d99f8b0b7cc12677b56ddfa68067f00f4dc4122d14b187a0e0af24e7c257a23e4964cdc19437c9e66bfc6954e3a55a477148b2fe0b6cbbdf0f6a22d62c69c295ab215d1058333eb5f7fd35b8affd6f57b7b2b44b6bf53b45dd775796c068e417de98ee5467909da49abf2ae46cd79e70f1c995a672db9bed9f96cbf491688157e5db991bd632a31fb966ef91c37397a27ab40fe444874eb079dc21097d20bbceb2f6e162ee8b8d7d290231ff71868f41ffcb3c8ab0162a0c813064559d665d5967921ab8e39e6127fb9dea86ce1a0bf56c5c64f32ca6eb6e7e8b767e27e915f4498df89c80c4e98a3b66bdaeeb8134d98493f180e116502c9b12eb16ea00c08f7c312cce4d04357f6044b76ac88ba87c72346b4c73d50e1b289158a2150e0e498a98dde951fbd876215c819fc9697a4078a6ec6696ea57797b892c4ba191bce3e177cad73b3a48ae516d4de04865e8126a319f6d17aa3eac7396dd16f439689c93d091402b780d16b8a78d9ee5097cd9c8428eaad0ddf8f87d6a2976c495b54020ab85b43d07c8e0517968700b425e35b470da03d1fa09022880c28e33a4b4b499ed62ad231a054c4628b007c58fdfb02788e9dd86ae2d7215d5af9c9d9ce7aa9e0ed49a69a129b0745f56855f78b2b91902cfb5f51af03f9847e9ed15acb2632c0499b4edb0b920967cd6c2e880871227049ff3456fef1cfb30b839a3384fa71ab30b4f586de5c6dd65e2a19fe2b7dff5c2f7e2b0b65402040632e0c8c8a1795ad0479e2be08a3d04cc716bd001e1f0966c5a5b0e234bde47e19ca5beee9891207e7fa02d4b194c52cb11a08995b3386355a50df2c9fbd78391dc86b37f75d6a5d9e19e0b841fb384a3c9670bbbc22bd7e1b1c6bb1e24aad73978848f4d48d3be71042de4223339009328ed8dee64d72141c553a4cf1dab09b6c4ec1b3c86ae8de20813134843b43b8c7e4f14fe86536ba9ba65d5b1b484ec1bef324e2c17b416fe0f5357658eb604dc2a976e4dcf95f0e290b38267e37e01a14d870244b45a69b12f2b05b1067260120610f18360b01cb2f696a29d6cc4d3f783772de2dbe8bd3875bfe8d94bcdabfb09399975fd55a543ab4230d8097778ef8abd5afb1a2c60079ed612d76466ef77aeb8dad93d4efc52d6f88e2beba97a51ea51cddf56cdb43982fadd0347287399332b7ac851e54482614feabbf5bdbf13ccae946ac26ffb024bf634f5daf32928cf377b48814512922fc036694deee8e2381cafd4f3dbbc87c18cd9ea0f3b7a05bbd1b65d2cb50f3b73c9d10505714bb0b97cae110f3331d5a2cbecc27b75fa764d892d664cdd84be80b872aebd2ea8edeb45b8f2e905300c66c314f34e5f969b26ee8119157cf225f3e02f455acd8326fc8f98190d935798cc81b4b4ad9e2b38491de516ee3261cd56c3bffa070bddeae6de442688dcd0a096ec7e156e4aec2fafac5f15c5b9df37153d9d1cd7af9ecfa207a79097acde1e01956e440dcd3c5e87fe416bfae5ebb50d86eb47b2935434e15a33f4cf766559d14e8013cc842e7597b2f4c400efead49d06c3a4025b76ac92d1c3c2069b44b59bb2eb774308bde565f09fd0151942237ad9596d26f4c8da7487b653646141b51b56cca854389b02a9bf550f163f10c96c2a12fad7fddeb924e21e760130f0cd4a58f379503826180e483583f52262d7f38e1513e16d44558f3d14e9e2e591982f9b50225cd335cfbcd20193926d71073fd5396d7e39d45a16a6b30a89c47516c9e04b570e6b32dc9b68dc6a4830bc7924d7f57836df28a036f811b492d0aac48898ae3e5f9406cdcb53bf313732d0f6b92770cf8df73d9cabf2280a4b017a1c3c94ac678217414a8f52599c981d946a6f88985120b352e4e391736c18d7de4cc4dddf23d125d1317a9f73315fea5f9b7fde19e43e7e95cec5f7c6cc35ed708485e9f0ffcd3132334a2c75886077ae71291e3125978794f78698977330dd51bc45c22226b4c8a86b7729a618bbb6bbec3db2377a41030a8dd08da21672cc5c2b688c0bcd126084fd6759504a1e8cba1495a18e6c9d81821cb1f3fa8364c260cb44dcc4d3d571a4db8bf5d5e2342414d6f30f13b9c97e9d7a042dee503a6f33577573060a582d9ad99174ec25eafc629a3e59f3575d1e789be70f982c4a292c253fe8e6040701d849fa5b579519a6fa8ed119f92083095dd70efc2b22b139147a1aad0614593ef01eb4c7d03c0a5dd9e260a229eb47ba749e51029be712cfd91704c8a5f91b6c5403a9b8c379f5daf7781fd2fd2ffd40f5aac83523ae0d9cd4d00525277784794effb620ad5919be0e43fde9297fd8c981bc4cf938c053098686f206b84816145fe6214702a3323cb2d24fb739945fc895ca70af95da0f53509bbbd9d39987b2625c046d459b6e53ef85c5d7f1d6c18a84830589a0c903b7bfde55e31621fef52a973ad08a2df50212956b03170fe2e28d61168284d49153d59114bbecf88e4dbceaf9ded0630d1f06c1e289e4ea85f4ea7402031cdb3883b4b107c5c17a07a8753b15249959b33d3607cfa86486fea6edca8013226d3dbf0dba2e9bb9ff5c0bfbf58a55b14f75c3f117526910bd57f20d88490cc495698a7e8e790e387900b968ccf34a93963651e2bb5423e4990248ec21f8537fc0599ac2ed5f3c295fedc9f67d9c7e25e98ada06cf28bd0deae2b17313dfba5c13e0b1f3e7c1f21c4e5c1fab68aa0f39be993f28b6e8e4e7c24b26e3f1ca66ca157b2350b2da263cdab5be149a2a836dd9d04f54b44335fdf537ad11d2173f8df441b24b923b4cc74833955d2b35e5e0fa4e79f820baa5fa0cd517e028b2728bd1e681a170c97e721c0337e53e16c4d8505712b81037f4bd6e9d1ca2b4514d33afef3bec2c5bae7d1b39b38f9fb2bb9a6880dca4308a9610e91750ea57a31a05109e848102780dc5f939e36baf346237ce3fbc78c0bc12e8d397c749c8a1d89addbebfa0d333fdf1f51ec072e1a05476d474c2da25e550ce434961d6db9023ead28b9d14ebf33fb7f2e703a0a478ca7da1796a02e00a5fd001774637b98ca20d166052e7c1108b628a46094ceab857d5e16ae9a80bcc2a3021517b1eaa2742ae25956a917ce113f426f465146f3c20d9905cb0a3deb5fb02052b8b3d095b4c2d1491662c2f6a6e2325f770db55ae72f7e3c34b910f5fe9adfd05bcdb9dbf78ebdbc7b65a6a464e50a13e070530fa6d641d2aa5131ebb03a9042f2f1edf0e1be808249e11023ed4617ccda21c828090931154ae7d1a899cb257cea63564995fa957ce720ffa2286fd3c30b4b3997dc43c90d7fea0be932593dd4fa354c514863278c843c1a1bca6f0dafe6c5a5f9dfb8d5f06937b686073a1672dc4eb79ff0b0cfe651051050c28cf2a08d7c50003baf0f852ada549f5806fc242c359dc2a89dd865a9bc43b67354eca54347724f4258349976a19af315fb1476ccf1c8fba7664df08edf93d47de0e3dd53c9176beb7eb916e8a203b33697ba29b2e3b816d92a07aeee00077adce16f032117a6db9bb04f8b673008332993cd87d4ac00937f519913ffe76323acb483f53f6bbacd2a1e988b9627786ed382dccd07e7b29c6131bdce9f86ae004dd268347645766aad849d2bc55e53225ee2882101420bff13ef2825782f860f5bdcf9baa45f19af2375add04e11a35fca3b59d1c24fcc133a41757cf3ae6c86d08b711077917f79547f211f8942c131925fc81d0e57a38b0b5eb0f55d93b6b3a5b0d785a81c84122547393537c7f0af36f5c3c988973460d5f287e32da4bcc3df88f96f848ced6f2154a4e2ba896e525357b232165be614cd4332f6e7c301f8bb74cc740e2ea8d247432f4dc21061c7f574fc354728717acb90af63892458bca1f0c7f77e557654a4064b1792a3e68d49717c804424b8449ff71956aa37f0d8c50dcb009a64abcaace3a76547c310eda9b0df625018d2636f7228dd7585ceff52b9d38b2f43c829842a8b308ded1b6b673ea565ab2ac570e5f4f311e559b7d5305b43b9cdcf08a19f64a37c06d53357844b1c26ef2bcbf763d9c9b0154a8e3e2fa4a838bb99efe6d20eff99c87797dd11f1bb0624535def2a7c5e6c9826f62449ba7f9cddecd449e496a64049778cd5a682cbfc30da4d812cce453e18bd99d25739b013b9ed0dacaabb3c5c305c794d7d1908b115a733f115bd1c8b54b6c9d45fd210c12b195663e93a87423f90657c88aedff188add18e00b5ea23737b71783f621d9757acd5d382c3c24a31f8807b53dad170d4983b992facae9e3ed3f413e37311c4db5dce5d98748e8121e2a12ab14e6c434ad31e3ea0fcc18d3ad137c31534b1664c32b316f80a2c91ff944f00d5a59ff687c2801a9b5cf9209ee0e4cb30f44eb5d58824848117b8589317c276ab79e72bc901afd8790af00a94156458137763275df73949fd7912c0d7acd9798d3cb656935388a2a5a3a2a351888373dadace9ef619feb21cfe2d8ddb7165d04e0e256a2e852f1c1dbdc8a9ab1ae9ddb7a756e4ce9bade79202a2176a62e9a0a22962c9de828ad58ea5356d7a9b5e5378a969371d4d61088a1009dc34567a76a1ddee5be5910ecd49caca00fd83b2063acd5dbad423a4e341790db2350efc1d06dbdcd970c68ff7d984a5105ec055fe1c3e929d07e66c11e3560cd1de767259874f59a3dbecac26f1b0dd25747c44a5b0f6a14dc6e50128ac37f53e836460e14962eb0ae28d6bb7af2f1ed0f9e1948ec3a9bd01afb4e09cadbc972031ea7a79e7c0bc965ab288465f77277985df9024c918b388d7d9d22e01653c52cc98969363526f7a9c21c0c05e8f56c9ef24b0de9be96ffb1095846d2e350a6cd5a02edd094fb3ea2392c4bdd6c2d60cf2eea8010421ec00545220339cf58dff9c8027e633b36b317f1e8ef220f4dc80db3d079b23f76cd58832982c47feae338c77ee05695dd24fb4ad45dcede1ff2aa96b0520b374679070e9b3c27b0e349529d51cbc84af60245e5da5d5519985feabd09aeb3dd7e08a5689888d259b1eaf6163779456ce2c45ce2128e7535ef3c0e57bc4f35c8303644e90f5fd55146b7a1cbfc1a978eeb0032d40e7924b12555a61afa8900042c40888381a1480b979aa207e25947a9474fbe998c641910aba05e9c61edd727ee3386098e7bd1a87d54dbfc75f3e96d8edb3b629abf2e7e7d738d4b7f37d43f0311d94ea9f854967c8152e0d1d253fb4c06aa00541b5101169105008549f9e57322a522f236b6e3999ce056f89990595f54d26565502aca1b4ed6fa25b808e8661d51ffed2d8da752351429b53655c9f5f89098914037bab68f9b73a0704e9d702f9785143b21965094da8b4377ee5bde3862aaeac334e055faca9d036263182ba80fa7953e6814c818ea9764d498c2cc81c59abfff986de02dfba80ba5f51ccf83dedf712d2ee605d418c30683955271a419ad862d6614b026bfa5234d8ecaf44a0d3f02b026d766f3c07be0ec6a0cdae7e3db6ed3e1929ce04f7719fa37cbf796e8f2c00029949b91441c8a132699eba7e3c579ff2eb3e9093c4c51ae30e75a37ef7543a43a87d01193780a74ec732708d994c75ce1306259f1f75a7f1a4493cbab44b41f10f5338a242b97c77be190826d2aef063ff4b6e9b881ac7bd4a0749da68dd86829b8276e91e850a59056af038c835eb4a583f67f0463d57c5b14be842a6a2c48325a2f131b36df0588eeb5d9c7ba82292714b8744258d20823b934d34f4e8cb3e26edca610f0970f92470751c5733b9a93eb20a01db15a472161ae5fc0f362aa7263835ad49ce3da7e20257db165269d08d004ca43a16be175896bafa54e78d2062c255fbb2545499395f016509cd1018abcbf9624aad314fe58d9ad204eb77b29560a67982fb0d7de29db6723bf2172ed925469e9f1a062a098a0bcad1c9a909768a11d8e6f25f93c73e7182e2f92b05fc42212ca1d6948bff17408b0b384e50a8f9e561a079e5b80e534e4f767b264af6286e91c4343506ffc9cf7527f256107dfc73402c5c03444eaa297732ee5366c13034e79a80678aaa6aae090ee4ff43fe60ac7abdb8daa659b696f3ae7746dcb0333b76416f7da391bf3aa1f2011e113b7c84452ee7f9b850ddb4b20dcf4922f5d17e27fde65596fbd0821242a42209c3fe3325c47b371115c82ae3d74086ae0deb080b50d8efbcb4b06c7d35097047bec0122a877d397d1adef833050a8cbb6c93cadd88dbaecfa3d3b224e54e9b389b071084205acfbeb84770c09f975146c3fbdde19e185020e81bb4411104744ebfa2f2989420b188c270d854deecda8d1f4bcdadc0fed2225aabbbee8e415d0d865257afb53ebe9eb145e20152026d676c8ef7166f4a9d336186a43031ac6f403d0fa92554367e253600409826933f66700d8641e12a8fa58095ce62672ca179d80d0a57b1cd3ccf8d146eb9eb1c75eed3e3691060b336a69d6603e69ab0a4ae577cc68334c31483abdf927dd9bd82cebdec928870efa86a099e24ba570a85885b0b2545db5d12982f35dcd4d91ceef582e253c9fb4a3ad78d22061e5ceb7d9d8dba116abab06081484d47f99b2194d38fd23622b64a5daa088da0c2eea6f9b6b07e3445833eb0acb82acc7416c2e40f6a178660eb3362633c8ab6e6c322b55fb77ed5a0b983769813610cfb341ddb9cd4c32cfe3ecd9cc4304cd50aca6bc3bd813823eaa02061b12022c11bcf7b0ec49135829f29e629b8dab8fccf2c4b5edec66047cf184f9bc7b97952bbed432523ef477a7e4f770c2402e661cc6394fdf4d37b2d1ebfec251425a2d41a7dcf13ca61ebfb810f9cc4eb0941c233861b9aa586908b27ef631b0294a397109c67af44b898022ad191cb0bd6b9f0c4785ba487abd13dc5053a975dedf1e1e927b17990dcac3aeefaf460c593769440f24cf4d8b78d6c9239d3d1d1b228c2612c639b05d56bd8b1a45ce63addfd111775126ff17708ed790025833288c8c098b5f6ca7476bead6ffa4403302fcaeba0f5be59e4423a37fad86b930128220a4f03a4cc258b63dfc884827df307fed24394fa4b359dcff40fef22f518f7b16f209a87df815740c40b24e39a26cf2d765ee574bc097cc581ca865f752806dc52c21389017d2ff9c269bf067288c1dbd71dc1b2ee4a871fea57b0a904778795856a4927263a0457f0ae3ab8ce6ba9263976605029c08459ed38a025a2c3445340cdd060e02e996b4f2a9f95b5b4778219460cfe5945eb782e749fb7c5b0a48286a0a595da54b71539a7a65a2c42ed757ca3f4af7ac70a0ee5cd1156ef15d199be5186eda9908edceae1d4f98e2540e04655e66a525395fdfe5257426440e982cb87828759568706ef872e86edb03c8d537b3d5a9bdff29cf366d1aace1f431f26d6277054c527ca69e88168a081b245469fb7f2b1ca40df7ba28778bd91411caa46f99e604ba3f1fe6ee539c5798238cbe308e18e6f0784cc027c52b5c15171f6836793501a0615319109cb58b9295ec1a2538fb9937c05adbab2807161a1171da3648ee435633b42e57d2e2695de99324d8f6612229915ca69d0e405b580ea6affc3315f09f0bfba94c8d515738ca7af3a5bcbd8d0d36d5457324338860d1945a3836ea3f303a3deccbd03ae9366d3598b8baa8ab971125472c899d91249880fc0a12044e29cc042880735a5fa33abcc3e876072b13e543744ede7410ad0f54fca156f4695ed5456fd4ce7b58777a35dd32e455c37930d0b9b70ec2f4fb942440c380a4fabed558256b7f1631624325689f8296201561325027e436e0477b99232fb5e12f64cd2d74a873018b08a138c75ec0f486fcacb26eeca45b275b0121c8031f9e0a4bc5a5d9af76b1dcc6a252d9aada56a1e4a353cf04ee553916c696181d5770cd493f0f23fed49cb83a9b6b1d7e939d8d22f4a6dc88abfc7d72db953677b89628574171f7a0fb3743c16655bf61607a7e158bc6853904e27c47ddbe0e6626ca5c2afdf839e8edd72b4bed50c2e9455cbf14d1f6b7ac8b25f82a72016d13ffbe4d1d3ce1a521c31a1ac492bf86ed3c885303bed9ce76f03d61ab421052810209c13e05195d169c8060c5ec5e625f40fd8665ccc4f0d38b458aedbd9d3a6075d935b45977a072306450d5292c7adf536f7ec03b2d58e30f9f115794106edf79e482bf1816941a1b2aca5fa7a07e4339237a28549448251f3cc728ba0928da1c459d3c6dff5454f48870f0e476780f4aa8b401e01be2184d6e2ed8aaf194e0288f5a6418bdb767ad9554a06a969b0984ed750f69d33aefc717b442c07703c4a432f3d2a5d26ff4a4e4d20406c02122e5c18be88fde1476084cd48d7f28291af4693a71da8e362b401b8bc8e9d5fc432f0bf751f7d31b8936f5468faf11472be65ed8651b1b3c9b61cdf74da931cfbb32e3224775aa792900e31a3dd5af2ddd07acdd83ba32271a2f7fbd4ec2db68edba673f8a2cd917f21c0636d733e5ae78787a5f10fc6bf4bdbd36fc042f59dc9445db3fcda24e1586fa6e574211177824087b3447acb5c7e42dab5a55dbbcbf0a91bab319e5934ae962567600e687f69158c928c96264b8b8e17351501794e878fef4e98a540061d16e6d2f7c6ed54a66f2127c41e1a1600cddb0d2a265c52964d32ec64ffdf203965739018a37f45f3e482372e6dbc6bfe0d27e9a51d81ceaa2c9674f9dfc1782be6624b831513650de24a5a4620a8e11a9c783998812c6bd4b2cd742ed57dc2810c7895855d80505e1524417c8478401b3d1fa9c2e7cf558db7300a218703dfb0b6ef6c36c68199f5a364d44a16a8c4f52fc95c10f58025e611fb138999ef1fbe6cc389fb3044a5d4b5a30c82aaacb3b7a6dcb71e9318a33b4fc8cfde92cfb369359ff56106523bfd55805c1b3b80c4f9b88047efdd0333806ea340c18a10b526838872eb6d2a03d8c03a5270e7eb27cd2b5db3c1784c5fb8de6ceea1e096058fa42a343cc7ada93b0be75862d197047627e26ee334dd4b7f52a47b901d96a792856e21bfc0093870a162dfded0b1f5474ec6e99408db5ecd12c728ddfd7c3b44274be7ff69439ee1d8a7d2a7e2c44b8e18f05e558a752068a074fb5349ba00753673c708e7343ea47d83de5297bc4a6bb4e90364f977d91f5dc382f46fa04f0fad89ae951898ebc6127ff857e421058090fb1d148406e1f7644955a743037baf3615026525cfb5109e3e4bb73afb72564c0efb8b5322dac85e59a75030f859534ab2e28a64abc64d52d84feec36b7f5661c8fafc8e3740ef71e1954a393705dd1b22793b60bd412af80d16605a56f7c5fb925e3b26bb942d8c9970cf7e01c454d65fdb1f9ead2d5aea89f71a18d59c1c8073a0d05d1d235527d15fdd734006c7d00d4df1fc36d26ef906d025dc5026a5b80895aa28c313f2c7f1ee552fb9573a91f9f8c41277fe04a3759d71e7415a3d1754265f55805985c345dc5376e1ae835f26ae7ac374ed451402619d79d6bf5270460e1f4060cfcc386ac89584c7cf12d490b49076685a01617a14621e4cbca2daeb980dacf7a1e92b0eb3e666a18d9d4e988e8119f7551c890a519b6614b5b33d48700d08d7ded7117028daa816c7590338864e62e1e39c87b0d44e06c0611209ebc07d8e08a06f2a765ec3479cfc2d8932be76ae00cbc47c499754dbc4c90cb7ca36c39f7c433ebed050db47af1d8c267591362ebb577bf3cb972d513538d3e6d2d505bc91f1973ea1290ba00b4462e94faa970cb46208c3de1a498a84dced6e689c048ca436babf6357d6e51ac964c7516acbdddb281ba03629e6743baac0467de2413f19adfc68535dd2ac28a33ce7698bfa86008d0cae4fbafc51208b8458bbe3104a580ff7f7d1c3520efde93087f5d8cec08acb502f736ad7032aa87b2b4964dd63157e96316af08d20f7ff5b2c90322519a7e63831a574a6876915b8f76943ea9291a1dc095ff1bd6f248fa59ccd48f543d90f2aa4405c6a9cb93ebe30c6c289476bc60279d592b9df5dfb6376e10bcddafda5832ce3c4fa132c1c19311b7a8a5c858350836827d1397f68c0eb7470387d5ed4163e7123737453e4319a6c22a5834c2592f63d25037fd4c955df4469d7fd8ea7887cae527608e000c803e7309688aab3529ebe3d106a203562e55a5b127c469f46b4ebf762e9567245c493675a72a68c09ad2e7e8f69a94db73038a0d4b37a6940041e7024324b58fa06335db2eb54f05756299678de979f348fca5ab90c305fa26307b730e85ddf193b5f90a1408dfb11a1f194a51ed7b9c7352cb56b7c5c70769090e3fdd55d0eb01a1282b99786fcb44df24a5e6e39d016b86f9b894e46d529bbc86271e8761c1dd5cb94db0289e27958ee4e9646c7feaa8714713b6929cc0648f8f9984c36823b7f99503f6e8687fa1866f1e729699363d68b2ea2e51f66ec640ad0b48da5d5f620cf4724a016a52cd6bd745b1d03bfba55ffb9989094c4eba9851a22c7690bc3180080db998bb50bcc76c941b4a6f99bd6e253d97630bed6dfa4d3790c8a40d76941a5d8f9b1cd8cbecaf3e35fcb757c623c091f6f9b2679430098ffe69ef89b6e1589fccb8d7181689290f6966ab4f530c66b2eec6e68bfb222cb6e62bc2fffd18d271a5ab15bee02ee67731281889bf2bed14b10aabdf81308267ef4620e78fa2bd24577b0f1cfe106d07c0734342864eba1396f3b4658ca619846bd14f42c3a7b037a3cd640512794da7056c933b76f63f8cdc5a24d48e8013c5973d7c5756d598860ccfd805e2e7baf10d8d33ca89293a320da2ba3c333c817c0c9cfe4355d1618f04e9a05e622853297e9f1b5131bcb68a6083b77088197a78aa2b6dab48a8feadf2c53de3e1dce0ef95f38b1a0a91ab88a68241f26e175f7d918cc6c6342af2b537c7364fc950747c7b98918ac9329ed56e66e5f38a37d049235d9caf1593f1c65a2290f72a4eadb7be4b0474dbcc0adbd006344fde3b5b96661f0d5dfbcc6bdc399f193ec9575e407b4855385936586ef64372dd079af0f8197d14965976ac51bc32f0798c0e80cc57a1e395ade8475a7bbccde0197ba637fa0e218ac1b3dc59d417834ca45848d4536ae26f4f80fd4a723502c94435cad380af396f254ff7d16aa8441a596c12a6c174afa4d1409b169c8497199cdb74741585f971b972db3b035475489e8be478d57b8d3a7266350b71ab7205a7463146ada62ce1f6a4d0a4bf2afebf502d85b7ebc336d5ce1d10b56b900d09b2a3a922f24fb8009a5681803851a6ed0b5cc97e757cbe73837c18e4dd8d90e59748eb699d3af47e7808eebb9d4af605d7a297ae4c6c9521fbc7289c371b02a49447c6a0a7d20063663f2a5f1ed4efc2b31b8c4d6e531094d26d7a55ad9ea858a7a3c209b15b72ffb601cc986cee83e8bf84eec1872b2e1d336d72148af6aa242d19c38261bb0d5ed4ba4ca11fa7ae9b3b65247d999e894e6d8eae52b3b381e2bdf448e0f6353e12aba78c65ba6035193656fe9f73c15d997f4c691dba7edfc14d37bfa621fc3e7d354f43de572ff65def527a3ba90779802556319c6680dc4436bb918d77867a381f0569e2fc4bcee35496098d907d8a7e1ad6a21f598fda8dbf58c1b91db6a9110da1dc9d03985d2c83e4f0c9007c34bbf5f55ce5864d2d7800d5230c005178435f770ce713a46db43d085f3ff1dfec201d0ec4a84d26df0c13f36088f2753368ea5fec36f91d45e534fae449f2c0e369d1132223f40846400288d5ad21e76b434d4d4300aba0c41772d58e484b4decdbb5344e28e38f789b70e2f6665504e0d808feb1edb19b6b0fdef28bd07a7a922becc7ab6ac3fa5f38fe884058f510a4deac17e79a17faa287f141a40bad05be76276306cc67b3f45203238fee08405c9f76a2a14590c1864dc20e13aa1270859c434bb669902d3301243357e587e7a31f8caafe90164443fe9290c92b5694607a90b72c16281bb40c9b8944f0bfa8dd871f33a4a331f844e899b15a064ad194ed266cbde8bd8fda6916fc772bb3b02b48e8f04cd405d047ce5767bfb1f24fe1560dd25335c07463770336faab2169b5a0bb1b30be3dad5bff47cad33018a03b185ae1035851687eb3ef01535283829bb24e171570e3733344736dcab8e192816ff2b546d922800ec60f2acd5cdae9b295e4e678183b79b8d0c2fdb4baf36aa247dcc8cb0b0a2f1623895bab7934e03085fd05090bb3fe0df34c5dbd3f0c43bf3d7cd69170f93c3b51675f76ebe8ccf3e5f6aae392bbd5fd072e78a630202f2ec89c016e268e263c753adb7c50d19c19c90fca61def8e307c2f605b4bdc98978756b7e8a5d7d7b20c4bec5f968ac234ac591793e46813e3a834aa30bcdadf88c0a3598a3b1ae06fa66ae83e92759df2c8d600fa80c07de9deb0d93a51b29f8c9c3058554962feb95f22d911fdafce8f49106b946b70fda13171837deedb539afa35950d6c87f2276274c114781b3356d5db29ce692ab38b8cf2b95fde2fbb9fa28431d202ba507a0441316af5cce79be3da333493069aab0f8af83cdf0f850dd5e05b7f199d3aff58c3101bd48edacbde02af83ccb90e026bd23413cc100e4153a898e39f2f725859d44d9458048f67bca60677d58fdc13068bc745a3c843493755d9b1f9a0234f126f690143f244d1d7a436dac4ce46c62cf29d52342ca7048bd16b440077a69ce546141ff7db021656338fe2967cb304196666a18d3a4791baf221cfd2f8fd9c0e085d6297c8235c42e058923039f2961a228b8ac50881bf2e36a4e2562dbb12bd08f01eba40a00c94bd6c70c038e740585c8a542702c1c65cb5152d1049c8f59cd1b490c8533da28d0e3fae68d89c281fbf1e3097d4a0c77acd553939b3cc77101772685806a391834968e0eea967997cd97937ec9947bffda42ade9e22b6fc059767fe35dd44a5d8d6fe31f9951583edf9c0d0eb88dab8771482150ba73f124f4dcc00af19a364d2f06670ecf9f0778e2ec9dd5f1cb31cd188e0ddc593ef38d451d09b047abef9e2878d1aae6f106dcc4974480b3e15d6391d2ba1033a34546a93c97074350a506ce769a975f0d74e5644cbef3a1ea4eb7926ec17fdace81d10cb41cd647d15b29f2a4dffafae3bd8d92c920cfb0cfba2c2f062a8e493fce7ad2992cd940cb68a2d1ab0ebb4be563f505a53ec14164bf69ff65ebace5bdd96fce5d490de9dea2472d01a68f0bd08d8a104857bae209ea13751b836307d20cebdbbf1897bf7d02d6f487f68f82bfd2228e651436665ceafd8b7c3eb336518f1f660554591bc2391a0e677e8922da39731bfdae5893cbdae67e24ef3247178585ae76f1138a8b654231cf948d00b1d2cc5fd18c97b286a9e91616489099cc005326623a662d9c93aa7121d8fd59026ccd7aa20b41d6896560cbd88175ccd6f5c783493fd1f4ccb15771a0a6720ab38ca36b386ad4dcfd6abd34bbdd86f960aef8083b68d88679c8c5b64dc2ea6b0a7080836c87cc42910e9f88933692a9dc31048b9153b72f43328cc2ae606873ade87f4efd468bbebe9d5d7add79c19f56591b2dfa4f7b1f7c9d21c4967020d7aaf41a3dac476de3cec5d45c2a76ed53edfd68842ed8f4801133c362bfa647c54492ddbcb4c00f6a0ebd332583b9547f215ee63d5e7dc03697c7e215c347d3cf7d349879987b2d68820aaa911d6f21dbb7d6f80116fa44f3861dc041ce803ee966d45d9923e8d96f84c7871c53956d8f39fe477d461a675dacd310711bba98f8bcd8360027e727b3df3d5997705e26917999356c3f947338852fb9560893a88a6590d05395c74d844bbc99a2e21a76281aca111a640abbf5135c5f8e3c450affc1ae0c4e91a68e747861ef94f8b5ed4e3ac7692a375f37994a4de5aabcc746bc39b8c82606a203e6f6765772472705b07617fb7f9d45b5d96410c6ce1d742bd59d754e602412656da3d0ce75b0371072421a3897975adfd9d527386352226465b4a3d6ff40cc65934063591e508b67d7d2792c9bcdc02146a66ecf107939ef49ba8294fb2536a42a340fb3557a853d856bf0a5a86b8f6fd9112112ba29eb0a533c35091a971957a25abfcc02b604bae46c5a587fb11e71fb5953e3bd009490a488e1870bcf9d3151e4299022dac89f23e7c63cd45c8e8fa8314980e00d313ae1a2ff9e322ef7067ebea7f98608a4371e289dae40af1ad7facd55e6927b81aa17ace9a97a1c59a6310969e79fae7c2d9f964013ad1fa03e5bb563aede3f62d27ff4021144f6ce0f4d1d4b179b12305043628af41949203f6327f46bcdf9215fa6b179749dcd2a801915eef4200701f349fb71d46cb412adcfc16c5c60a4fd397b67d77015e506791bf680109c948b54794aa143a3b158c61ee4d2e0032b597216001e828f3bdf732ed07b69f59f30e8541788bad62195bfa5cd05d24a712c420d9471aaaea29ca01e6895f96fcff6c21e13bc26ef00c0e52d6c34c8c788811929b529d639056000b4737f92585bea1133b04b8c3e3c412031a0d4affd2338eba7cdd1204f5fc6091b4555744d832b920469664bed1aa8116d835c08df23fea4b313b0e67e456ee1b545cd685e09b2468a758a9f19aba5b1c3399bb34da3ef5c01c3504c542c1fff2243b8083dc3e341c3cb0510810180ad00a5ab07fa771fc6ae3340221b388e3d71cf68fd229ae9d5efce46d0833e12fcc88a6d828d14ba4d0982a45c8d9dc915f74efbcc0f698307a0ee99d38eab66ad8d9da64137d7284ab4c897700ec0efa3a782594e4a354a9699a7091f236a12d0b508d7be4438e9ace7cd580f4a68126884c949924ca8da9c19c7c945a9db527463e51f6a50590f55ad26fe25e94886a4430c3a36d999b93b83e2439830c42d95c5669daace96b1d56bce156acd8572bfa7084a910f9f0c743fb9b2064e72041c085245885ddeb48f28e0717b9d4f0397a80127e31a4b1fa9a9210f1f1a47dfe5d123c43493947e3192bff8ac526f0676d6e5c635983c737284480c8b0fd230038bb43a9e42b48a2db9ecafde8c8f9ad9d24b15a4c05577959404ecb5fd46241eecce06a7f1a7ae140a8e459e7246e2fc87a09a644c2c4fa1c5f386004d673f5918c6e6d872e039a583e55fb548dd783dc9e413679d616627b4f4b8ac01cd11cb526ca81bfd3451f89d5dddf34c8529b6524e944dd46910c6973a62731c12ba4f88e58afee3a58dd06b92bdad2b72c25cf5ab9b8f2ee2e070779db556189f88fe44db4160c45b1a5563b2ec6af446b5846f75d91a5652fbe84e51e4c962967a605ec6dda0b21a27ae92ea8856cf36240db5f1f4404159a40ed718f360d0708a8f5a1b4b50215c74ae52d19c67e475d8e0a914ae6891ee3d7e6c5c8696265a388a2a9875719a0402f43cd8ca3e5de223070f391f498af1394a5d36d3a6838b8f369183c6bf159a8b451a12ddf6794fa153d1893419a1b209d15cd30fc36188f9f6cbbc2bc44ea9814eff30e249ba02d23b90004ab3f2f80582cbe1f10063535324f3e06df8db0b67e40e139abd0dbae18f9c24e7d73e77f053d678d3f7f63a83a1930b5eede30a2c8ebb88b49011e7f886f5f4807537170cee5d9b843594ca232f1c68c2fcf0d669e8b3cb54c0e97a23e4869f46cf9b1019b34b984be0396b647ca180537bc3da796f44f533ef8c9ac9a11fdc326d32923148977767d880cd92407eb42a4588969e7588e2d4cd78fee325da5ff166dd9072efdfe5aebe58e61a283c0f885bf2a145d24014bb1dd76b500f15817626268eb19ddc960772f784c09b84e0c4494c6d7381aebbf50687524a68511cb20c1daf098c70cc0add4566de863d20977a11bfc9f5609fe00986943440fc50093a712042e2bd651631a8c159c10680c16f8bcdeeca63bce3ec62aacf2bdd7769500420bd084fed47af35ba5525f848afc3798d1a0720ccb1a3502cfd411d2d7ff9bfb3b709f49bd9537c57abd1dcb9c437f52ca242a8d1ca089bc6c2ae70e8813a43ab45fa6509a5e7b586ca80c7cb39e7c3324cbc0ac104b65a9d4b043dd05caf96dd252dd5619b3b7b392adc4e5c942a5a5a76d8fc9b8b7bc97dab3bfed5f065dd28a5c787588912ace179070064abf6e438ea4248dca4e5fb0120bc4998a3a2bcdc98f9be63cfc23f90e5edaed763ee9b4daaa53d2238587c51f08109bbb794727d8acdd29197472716644cba14a8c9a3a6e6d707b8e058ae98d30f2206fc01fe56cb32524f1b102a37274f05d344aaec5d53c9a7e49f3bbe66b8cd6dacdb7e11be0691f2036c584def03605731bd0e0d6e13227c12139bb8729b8c4c932bbc9d141470271c323a9540a0cce3036a54a9bfa8f7410e0fdea43489602d4e017b8b0ec2d826d24771a1a47245ef5ee19f4d21a061c87e0e73a24de3c3cc341d5777afce36194e9c0f3d94a2f68d4286d34f9dde7597747078247fc5d3427f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
