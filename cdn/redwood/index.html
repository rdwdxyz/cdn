<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4b8d49808950b55e129404cf92bbe4eeab75a3f5e5cc3de929aa917d547e3807b0945f8f70f169cd7b17e4642fb28a0306f4c633251a84e9272ca0ca206dff46704ad3247ff4b659960aaadfeaf1b59928045924840e5017090813ff43cf8f428f01b1f619166b946d1b965988235ca6a719dd8f1dd4ea1ce67c044b417b309e09bb23e7b7afb859cd1a226e8c4cb41ee145b8a898d2579ae7ed4665dc1b7d9a56522c6ed083cab41d539fd9d12cc5def9d3aae36b63711b8e1522bcc135861292d6f804441b5db255e7d7efbf20380fd22e598ba0be63a313b455854b2499d3e69898ee46b9ecd943625d476b528235f559b80508ea5c4d95130d7ba1589b5b4d5cae564d23d80577c5a955590102d030557529a2adfac2ae35167d3adf2e14cc41867b9c142c052ad75b1d7fd76e189fa769411a107f2cbf820acb9389cdbd5dceef0c6194f497e4617a81a9e9f74d7bd2427156495053a4c5edaeba7fbec02ea8344a5d3dad847c1b64600ea9051654940246356139c839a4dcb2d42af433a75153adb27ea60dfe683c39f9179004d53a166d2ec08aed6abdfda4362b8d05f3a93d1f775952428c38d550fc4585fe77b8641cee7c53f30e53f9b354234efa6319e69e51c73ab07118b7977f897f714cb6538c2b24fb96725c805aa0f947db870a82e4322b91039f56f6b5664992749348d4885e91334b81e90f87eb85bc2b47ffcd8d9e7a596cf86f560f43c7b615078c3aaaf47e1079fcaf2cd5b152d3943890dafcec885d91ffe891dc905f064850a8922eb2c8e1eab8d87c965ecc6a55c6076b5390b1b2288ae3dd6527b0854940790d11295ce4c638bba84451cd383985a6857546ed295c212fd19dcd67eb0d8d6279c735f1ac1ac189ea202f3ec1a11db183d05a91961a8da5e493584b205415c2425f0de5db8e3a58d8579632c3de4335c2739f4a557fa7cac84ad29c8c511ae31d68e02ad289228a9eb500cf3d2d99db3b642376c5283660409b38873cd7348b3e75483749e4537fcc456bdb155417f2e246b284b08b9e37e4c7493a1d2be0876e7af4e43a068a4a7382a04ae44e1401dbb39ce501b91137cba9697099437e9e9305cbaa0a065e66c5484f257ecbf6c4de5d05d51e978b9691b36e7fe24daf5250631468b9a09bd9f3bc2a849e63d2d48b1d164deb060afb3788c16648b5047912c9b43189e7624d9237db88c2ec8bb856d7888b383fe65e0aefeea8c056db4789f0656325ccf4f3e3378582064707368e8d000bf2204f32bdb406bab0d318e8667de4239d3b02f51b2e4ea5559a6d0bf1e106d809778e8babb4444ae274cdbb0fb3c044f0b711435bcd4cc8a33d08bbb47c5917771e3ff1415d6dffd244734657a2d4ca72f7712e20d487ea77bbce02d6685a3794464ee2297b320a53e94dfc30eeca7cc3cdd54292dc9333f8a57bb7b64055bcdaed1fb9df14fc4376219a28fde31d152114cecf3ff99fdf3d35464299aea3778bac9e97ac8d4b81ddaf56d0a4eda3c1d1e4448b5ecf70a1a62b84c0723d20ba2ff2719947621dce4d5cd879e4c6e5e6e79b40475497aefa801f0b41c5538ce33e40f263b15c70be6970dc503f0aa4cab5defd1e12995ea92f2bef8a4e460248e0eef0fd3de47a844414dedfbc7c8a4a92f9e0c02dd4da4c2521333f66e1c5f7ca6de69a4805fdebc09365792402b0be974e28094a5fd8e16c638039d79048a8d47a00143f189fdb1badaf7c6b0fcd8c563147aecafacffebc42b0f7db533e0c8923856a5267da88fcb3fd3e97aa88948e005e975dc0dfeab42f5ad29f6ddbf15d2d9114d3e1d923e950539bbf22566d35c435fc0f311366812eded128fe101fbbbf5110c28bfaeec5ffbdd1606d2888c5c366f25fedbcae0480c8d2228dbf3a1166489c4586927b81b456c951146c69e6d0e4e6f04fb5cbedddd24503fe26697cac17bf529c92fc77d3f2fe6e6338dc59ab0ec073327ef35854172e8844b0b7d8c98c7e17badebfad3b999535f42c87aad50721646c784a76a844226979935686d9d86a971db4d468212877671e780a7121eabb05b7638cf2b93df1b927d3a48c537ec4ef73abea80e06e2ee9e63e84ee399c96063a103fadc7474b7713faa4988ff0d4f767f9aad739ece17112766ded91021fbb97282e94f9e9dc0efe7fc7fb45f9087459d38dcd2aafc520f09a4edc39cb6e0be315f1af90984e725f87b487e388a123008016f278e2fe256875343a04b94a48c9a863cebdb0cfdeefdd33502eb63aa4593d187deb26006a5ac681dbdbbf3e5b6496a75873974fc3abe72bfc16b6c658171e1f31a805ac83016ca99f125c101887931c7bd11e9e94dcb14fd07bb0fc0c770b96b04f1a2ae4ed42cd0d9db5c7cddddde4122d279b59f7ed0d29d9c29b5dcbf867354134ca47db5f815bb727129fabf979d7801c5ba2fadaab43895372b263df1a22a9f06f3289410fa96b82809945ffc16711b2378d34a82bcaa9362645bb6caf0ebe30a50574b01b2f82bd12a8ae52caaff800ee2eb4089cf5de3b47065527a3af390a8ad20b8215056e4b7d00e9ca651600a173a5ba1a9d08340064236f03348da802e4d8f8a0543aa4d66c9947401e7c1375632d4eac7b2af937fd8652d1432bb4442361fff3397d736c0c90aea89a2ea596e30497e67fb6dc5348a0f3bcdfd6b963859daadc9b839e264c9c33c538feff5f4a246dc1f673a477a8d9e76662086e84c69c7533cb5ca2f169cb26a4abe62320d53e028cdc999dfd0d38fb66282f20e4e159a64fe6a542dd2757ee5ff5e2cf43989fbb9fa500faef34bebc0b76fdfae21121a7f2689c32ec06fc353d1f5fe5956a86abfafc2f529e790af9693d312c4dfd1ddacab809dbd29e9e40877d29920cbd1b0bbed08675da9663ec2798da871cf7d5d9fc8a1a4749947bcd96bd7ccee57b2985e549b71329f3ed9351195e3d4f56286a6d3ec23ce5ab5a4eea4c2b4dc8f5539d78ed9735b2459d050732ea869cc8e7066b391c273c3ad4d2720b3388182f072ddc541b3e80e2f2047e8e1504b6f5e9a2b971869180c3ea784015776b39bd4d7f93efbe3689be10e84091807cdaa0bbc359896624cdc6f0f21243f184b2a7cbc642324be63754c6edda7b642705f2ff89cb7096f53c1decb8dda0473a09ba46c6506377bb635a2f289ab407032f2aa6e0fe7d6974e099725d2d5edf8f0c39d39f7a70e66482307398582a73bc2b61fdce99d0b70e323ad811111052a9cddbb0866610f88ab8247006a67b734cad355da339870f3a4a8922a2eb9f15e18b16b1d79275f9a08263a2b54fd9b4633d75cf937d415f2d8a4440d3339a9c3a26292e02e19b8590da4eb5fe69b104a042024e04bee7ed797df93406031a171379526347c5791c845e74d50cd0f0089f92184e969a084f58861b13c354100df2aa9c45658dbe5990e92ff0affe572ff6290ce3688057849ca4f5ed96c7d54e34def9bb2db2f7d15e8a1285fd6f6e662ddeadc5677e82202dcc3c58f2a089a8a4a5dff198259fae4171b9d0cc65674c40629c7e8e18a64b8dad39ac7e0e03d0421eacc7beae01c6c93129937778b52b38b3b2a7a6137afa00853cb42ec6ca4ab3b8ed2cf75c86a0ca457da1ad465bab788566c8a8c5aadf9f52587348e23b480d6c561d991e9c1c2fffc37bb18966ec36537f84da8f024b3d6c31f19580e8b5359d7e1070e5bc7417838dcb70f14f3a2bf86ad4753d54bb48bb01288aecd380a80c226590e76050d35c196b00c3343cc6391bfa09a8e9de0260f7d95471f7bc988be44338a4f03b1fb7cc8d9dfea8548e11815300d7d3fd5d5febe791258bec05c8acd0c45455b8cd1714c7465164c62c61bc8b5d2fa5af1e4d2c314921e8717c52b6978e4028d9f4b8161c6176ede4942ae2a1058325b90520a8a3aa1a1ba0be2cd77a98afd2e2de96e323aaddff0379411e8ef1b9fb077a7fef4e163de261b4df33978f4993caf4c500a392538415799c47da9dbca62436719339f9ace50bb270deb34bbbf78263f5010bd0db40f9fc8b5732f9c11825781917ace34abd1672009ec16357a4e856f1e085ba560e8d086bb8bc59f2d4ca0dda87626aecf2f91482ee75f2e94fe1ac8fa163ab7a55d99c1b5fafdb4f4c0ce7e452d4276d916f011e3a15094c5cf3a84ea6835c9b79ff1bccb1363914125fed4d2aee88d973ad473faf0530ee441c31bf4486aae04157b25f4500ec0d36024e8f091f9aa50f1172cb3be841b733c0fc10af2911d309ed62b0459fac0249e65e1a0f9311a2746fad6021c02443c2c44a5aa094877c1889af509cdb5c40f8c80907d15dd8a3d1b6ed92630cb2c67133062b1befd96809365a7a0ba7b5f7a3c79094f500f5a7228dd9055858af7eeb3bfac506627855118ad9c00ed9f60e839896b93b8978f8f7e1acacb5271138ba9f8c60f0e616bd4ffabab0a37f1d6aa9e2f3a26af63e6e15d671c88898dbf9ec33bb16f0521eb29d1f469b43eac5eb8cc54d78968852569363bf6ca53d96e8d08f987881db08727a451cc5b2141406b02f39bf9623a535fbcf7eec40c336ffa315a61cbc312b453fa246c37ae957a0e9d7c40c662f3e5d28632812ef0c4a193225a3889c523074fdd8bfb39588dcd77c40ead8bd5573cad1f01434de7b27b8e193d191842831fa6da90c7e9e6143f617bfb0fa7c9d32bf8247d4acc0c7a79b5a97609a8a934f9b1588f064a7b89320f801e57e43c7cf39149a318cd9b28a562b2b24bc269bfec87e0bc850e266bb1234b2492fb737f7afd22c878d1c45e493135229655fec630ef7214cc6f2a6de89ddfc7c38beaa19ee8799459b36c9c6915fe0dc2c4b9f586bd7e580408735cdf37484e72db64128367bc807d15be0a92e0872cdd1be50bd80b6448ae628592398db1bd0c368c546e34e9ff37bf7fdde1afd3c58ac877bf999e47ab74f82afe6259d239cb286af539729124d5e1180275a6ac55dd3dd23ebba173e5b243cdbcfa962c92c553ccb8bd08eef598c5d36acf66672537a220f208bed4608038c4679ef0e15d6403a2a9275832a99db617a2f69ac398d8b2f95f3a3e47d475ae713ba0e6c2c8c4f235f5d7efb991b0ffab85202803cd4f3c2ffe3e2d734d3a2bec07379cdeb9873e55ba63a2331cb3f7b0bb48e04be01c262e9d9c0595f13fb06274c268d8b266fb904a69399b7b964e57d2a780cdabcdbb8ee54e3ed8c6ca053ba1bd2dbea667424659b3d1693cc6cecae0c4b4050a1e7473e21916cd3ba669f2c474b9f09df1f7cc4b36601d4e50e19c26317312456d7896f94784ef183fb7c073ef199d128d7bfc6c31628d4df8627121b3140736a3a07cb2d10f04a43a3ad0f3beab143400072288a51e0a7e1a725617825f9011f3c499c4aa1fc4976e46f6df469146a75455a3d9dbde0a19b550a0b42064c335477815293461870d69866bad68349d42e0e8ea23c973cdeb659956004250a5ac5b664f2126adc5e3f09aebfa0734ceacbea8c9cb14adbe7eca234b7865e281f820a299f2fc830215594b6aeabaa5e9f50b1433a1ba4bae03961bf70049dbe6cf7257f53264d1764cdd9224e861a469b6c3bf1b9a8382945e35c4e3ef5d9a85ad2d4b9f87b3cfdf763f060503bfe384b5ca37aa79425e68121f2dec7191af95af7916d47598926be8c946fb3664beb131cc18dbc2891527f636ec31fbba021354b9cfe783c5e57bdf8ef917e162d0efb7b1fc52e2d085eabbec5e9d06b0fc13f593dbebcc4a70366f8a41552a0b3273c19c4774f75262363f1fca3c4088d4395825a446c11965f1e104a68824d23e389bdb62e3d0c7acff996dd1b4405170824318c1fa5445d9d30224d7341aab6f86653318575873994f292dcbff1de65068ad1dc02a5615e40c3db31669a47b524292f877b28f1c6a53fd06cb384e7da7450ce190b7c3bc21af79ce0866c1e228e0d5292e287c045821eed7c135febcd4f9d4b581ef9ff7776156773bc7d58ed496bc6724bfd557021be27d9d3c5a62fa34168e8bb36080aabf8694ec5a7c24e0384603ed13d9ef48ba8a0da9e2cd772715f388b92fc670b0d7e79e827e9714f5c444e8d876815d2b95659a92a13c9026e1925a3c650d261ca414bc91109893ea87074918a0ceeddef0a3816e8ae109ba124bb54690ab3c4fe58b274f4396327ecc0005e9751b53ba355eb6f28c72987730cc0f0c2d1a4209b911a4db54ea75f2a61e12e4e549f8b5d8308451bed751a334b49e3533505b031e9e53756299cd7dfbd69a458bfa6f64870b4ce26fc1c5606d41925ddf8da1f5d6ffad8fa004b27a9a3420308ca2bf4e3f6735c7e636230e212e4f7d080e76b469d468b79ec6d095b3ef6cf620a9078209216d25e0488534803830bd858afb8042dc810fc57609a0379e626870d12b6b93f740ad4b1175c2676d8cdcd2fbbd77af54a9d85868ef7bfced4e0642403ebbe5a906b914b1e44ff6c1291eb262a9467e0593b912b325114ac7a31c668775de6b8282cc9e7d8b7cac4263800d4e16bdbb255aad89591bf40389f163c9fd8bcdef0a65958ff458fce0abe3746cf25d9170f32465456f8483bd83bcfd85e5ba30a71bd73ea13cc99ca7a441cdf356129126390390e00614be4d96015c7f5aa693e8a030a7b630b93d4c8e9dfc9016b3ae22e8d37ed578e484db966e7238e9a36dd3f9915d39d95f1586d1ef944c7ee4bfdbd78d6efe6a32ca8614bc811325209edc1818389fe5bca008bb55a6a03f872ab00971ce2d2eaa61dc5e6212f3d708f8be9c0b95131aa7995cfade31a25e6367c1fec6bcbb9081e30162d7b637daa899c944037fb80a6b7e7379b319f56d045b91f11eb93cacc1414e3df5f3953ab354cb82bf7b3b5f4024efaf64624ec1fff070d65fd9852763254ae9e1dc75f6959878d3de4377c3b2b7d660001e831bf6f12d381211a9ef717ffc00e4b3482aee5b1312af05b1fc9dbde8f44c8b768d6b1d3d262686082fc2c376199ff65009d198d0af9d70f0d960ff7541088e2982e9ed891888d6ad6b3117fca38258246dd39504a86f3016b1e5b9e50e505480d36a24515768a0e8a8f1730ab8b0ca594ef98644008f163df2820c842c49b8e88b795764c7161e5394c1e64e289cf31281a8a5be07c6f6d9531a68a09368b4a9784a37174120acfebab4fdaa79c5f48b2d6e8d3c80639bcd01e8024f35af9cda207e851fefa3aabedb5ee902df02ecaa5dd2884320b0a08c3c97ef9a87d0646a5115cc144a6a392a7c0b73f1f356230e755aa976e16ddfd59c04d554c1ca40039ebc21816582747daccab7dfcc7eaf0418cf83684b6fba2dd9ab5c28a00870f83cc7053fd6c7b4664cd38c570bec59c66bca9a6b0e17c2e2b406c66b217028f2e7c0485fe8b5fe70321738d14e3571472191d2d61c28e488e1bfa5b52e6cfafc265f9acffbff6af6831840330184130ff70fbcc5be9d1a69af44f05aad11bd48e99f91bf6e3c61341eecaf42505ea8a0ce5cb1d998c1be1c8014b07b22e08f69736766e3ef2441b923da2be6fcb2aaa72dd2a60ed722a4dcfecc5e1f430b81ccab5ccf8566471cba274adb60cab0e56ec66ade4c6cab91fea3694ef8e9a3f79a58e3818c4872e355618dd47f7a6af9f792bd8106e8149af7c1eb7763a23e614fabbe2ba88c9c070fe94433ea15a3daf7fec5b8e6382fa4e22d376513ab9062d56022f67300be61277fb18bf3e963dace83b3ed23e1abea2639a3016c6c20ba8c1b59890bd85daa467183c57b644d67ebc98b97df245dd0ad787613958a61aa3e6bb6ce175cd866de073943952aae91776e47cb4dfbca5aea193e5a2733ce659658484ab181eb6fed325162099c66aedeb9b501ff4557940be52c461d5973e1dbb2ca594ed6fcde36f92e43ce5385401aa47f682d97ac46671f0a29ac17088be38677e669ed0b69f8a4a5f7a18d09621817028ed94fb2d952528c372a54a89cd5b4d7b01cda790ca6362b129f581c5753218b490835db1dc46b6a9a0343a66e89dd13433fb0fa9453acf86fda5dc30b469e82178db9e68231a3664aae8564305d726f3b9d869fc3dcef8ced58230cbba13f8835994e3d474b65cb26740423d905b19397012436c569b5b26c8db318045b322c76737be030b59181a9c7d73b07f0c51154f963acd436616e63d831030b30795d51239d5348b0d6452e070749f7985b52587a221b4b278e71ce730039fd6a0f3fea0c4f9977d1fd28196f0a77e6d2f9af1b22a2d5d00fd4208b189a72d990741a74c56893bfb757b45b8f8fa867ccf5dabac0f6958117a4e1c1d92185dfbdcb6e3168aa90f113db377f0ca4827ac9ee6ed4052391f66557d1e4ec3c6ea32907fda2b77f0025601b1eb720bac6203d74e4757bbc77f94b43f00dace18b5ac72e7dd61a7b8ff7346cc28c01645ea15225f90505b2ab4ec272b54624ba8c754aedb1f6f254d4f06a404a2ff26e4a9859e57400b86daa4bd9777f6692eef8b1c08111e2eea35cecfa8bf35519273206899f4a7206b168a47060f71814da15d43b2e78adc6403848762dad6c313ad9c8665ce24a5e30ec689f4ce9f01b99e669040aeb4109f34967d503ab9bee103a22c2d235787d2f9e09e48128203847ba659692c520163b87defaf0d97d69c68e47c336f5c9243a3e547c30b882cedd2f3ffcaa2f13959a24f92525f0f5ed0de3af99c6b2ecc35260fb4fe56f2035b7c16ac604eb251e4d369c652eb5b83f3e1edf42057e18066a6b15806e24d7fc95efdb233a6e292d97e54191c1b4d323e44d5303e2c1bdcf71f5b21be7fc583258422226ccc4eb921aed3a3b425abb868ef6b0543e88f6b43cea88751ff541f0c3bbc046648130f3e068221e7673652e2da79385ab2c2bb488a1214f60b0acb393cdca8fe44cf7c4282bfb3697daa444f373afd41708d3af30bd33782b47d6aba77c8848f344d44e73d1d6c1b7226259d6ab0cf63b6f9e2d5a702cc9ae9924818b2458cf4e6afb953c64e55b2a0ac28ede05770ba00251b21265815520bf208fd4e84848374cae42263d64ad57be039807a0fbdbb4586c9f74427a12196949c7e9a3138769a75ad54e44a2e104a995ccf08ce716eac9d42392a585f16c8463da9dd256eb1130d0d2f25dcd5a25f70f95298cbc3a4d483b9e8d22935be57206cab75ac18276202c33d1d938620948d1317187ba25cf106e295eec0e4b984bcec26614fe7a3a7f969b6e108e1df547aaa0220fa5ddf7e6c9f4f457692ebd42d032d25b0bca4e28a3003dae245252d86ed7a0f8da7774ea0d7e3a76c24639d382afa844dedfa8d45c47c4d854deb02e87223d1313ebd5cac85fa7fbbc7e7cd6ec5000ae61f71525dbef6cb330431a7bbb14fcbda0d109b900707c4a6a550ea82476670d9304435ca71a7de0c4509bc66a7552d084123e4a5763e3190988bb58fee457be69a7933459fde804724f6facb9917cc3c6b3593aeb9ebcbb82e997dd069da310eb00dcb3590ecfdbead5812e9cdf2c6f5d3f8ddac6aef03320769320aa54224a0e198904c95c7eb4ce4d933efcfe95562f780646505ae600f3a9606636ea798dd4d16ebba1800523f8231d64fcd134bcf4de825dc96824267cb9d88629c85512a800b1c775eddfafc35bc5854dfe079e045907e3f8ca15763182d79377f028bfc264f5212d0dcd846274fb2c4f915bc356c303dc1819ed73d3d01f899386fc11c92b5f1709a1d7d1ab90d1f14cd9398c6e44e631f745a886034643305099516c97a96cf861d217dc03fb7b00504ae517174c96dde4e9384e602d31dfb23a5943a886ba15a99b047a2587b81fa287026670160c360b44ef2552fed00e3bd6073361ed934f08a75b235d662dceedbd8f9ad48093d9efbbe4a3b36bc1d0f27bf48fe2ec7b26ef0b5ba6470d1a6cab57ead5fe3e10ab8a0fba477f2526e106b728787fdd173ace89117b872f418ec38d958fff64640703cbc8bae2c222bcca1b3f2ea52a288310baf770fa036b2572d8e203e4f3f92135698cde276fb36257881ea4137112f37f4649238dca3f22b37ea35eca02170a5ca603d89c8d04803b16761e01e8650fed71b3e98ae4302cbeed05e4ab36fd947b7ab8baa0fbbb32823d51fd8e948e91b961cdeb3f5a213a9333fef5bfff06fe825b33470b504af316170ec5159795222f33029ce9b45075f86dbfba8fa19d26ad0eb0da278fa59db4d49879c99e17db4c66a79eaa648af2cc290b36fe905c158f03c81d59771f314c5597016be6a52c6d3e9e873de6c674ab0182ad2315d871f5f75725e3de241987387c0f05bcb5ec2569a6258b747a1e5bfc73faa952142392e4333c063b5e3e5a4a735a893663af1f5d7fb7f49cdb6768b166ea768032de1e6f2490eefb4f79bc7399eb286f02f2d405d166de5b1165c38b3445099f8bd2245d35713251600198a3f058dc02b2167880750c977b5b2cebb07b83687de7c8e88d82c3f0477f1252783b6c533b5544975be2a9a9b53b3126a8a9d1dec06c479f627da60ecb9b9c7adc6b84fba1963a59fce9e0936a506395f047ff77075f8222cd3641cf0b3ce44ca7605da0c973b47b110c8e94979fcb3422f7fe42131539febcf5a144ef5bafc8c1bdf83500df4c824ba63f7441cbe1928e5004e08e6cb495633422f04d4744edbc849df686d3ab4cdb0efd6773ea885d8666256c59ab7dda6e37f24ca623cffede148521082d2e3cc4ff1172bd9bc0cc2c7e939e3971f782d6e483bad3e1f2bbe6bbec1a84a869f2d9c2e2c37231d67b0b7fa35e796111a449c748cde0496d107266b4c023efa22b1b6aa43c9f98edde0f2fef2e9f043ba0c083ecfed671e76b28a479ab1c39366e8df99b6fb664836432ac8b4e3039bac1968d71fbfd60af7d0712db484e2bf2e7716faf479d71fe769da6ad28ce8c2bc2a37bb1a26ac63bb3540594c0802c0dd2d47a2e865d7cdac8b1da3a4f1ea4a9eff2a8668db705875dd90e389b870ce6bd483e82ba428fb799b2de8a45ddd5eb72febf8773f792d2e00f4b09b0b05f32697c31cedf29ab078a51dbc1ab6acc06d7868e4c14c904abea062df5c0bd38fc7ea2692570691caf37c95cb8b39088abf7e3f5c62d2ac0ccb1149dd98f02264f4c7bbbabb99c648b403dbc20629aee3122551c6b0235e6c8721be93733a474ab691c845480279e2218f31b5d0ad977594659937661a9345e8ca104cec62d1227e5f14ea648232ed820bb8f905399c5ef2f8f5aaf6ab3ee5e95c994bb8ca26773395deb42b71cf7c4b09464ce22e43b24a941225753559f5bf5740a1195e0dac68e7be5714eaacd77170b757f266ffb0102eeb2fdba01ebeeabf50d56265c0a8225641eb10afd99961016094bec7f18e801fc3fc38aeb782909b88402bae96caf6aa70cbf0b3e7130f16b69c1f79fb44e19e993df356614b7bb18a36b89f5e7c1965521dc114d5d1a94625497209a743423c5798664c1034321cd0b3fd3c2a750e71a9806a3163b84c67e4d50c4ef92cecb1276c99659465818e76c595859fd5d568bb2e89febca04ed7bad7a3540e178c48929fa64c3c9f72838e3b246394245023288a5473153f5f68c0e3c9fa2ccda8cf2d54c54518e07f95edf1aaa6e0660d55991f9053497c0141035d172fd4d39e81d6ae1f8ce8e7e702fd6691c12219053a78d6bb2524e70e2c187c023761fb89941d3b7ef3f3d32b26c54cad035a2c898e64672fa6a77895c68c7272b35c9df6431e4c67b446a26d87e1f739d9925ecd11c38a69c3d62f55f176b51a51f8ce4a2b4fca4030975a752ec086ac2dd814cdbc7d3029cda818ff8d5ddcca2974d28c073ba5fe63349b0aee423b9090c8e7cc89826c70d5fc783853d7554cd742f3ce1d905574c3677abcb9b03618565adc12e13072245dd62784b793f330750d7b5b0c9bbefdae93cec753a0f22292fed61151c01d80497a16ccc4338ee3b9f13d3b13d7120e57bea8c8d676cebc80ee80f35879ef1c73fa0b4c3015d807d32908a18c153ab3f9324d90f2dd68a668ce0657cccfa656c220e405d7ba4c130af4a802b404704aa4f5f998d2e9ff27e7ba5e1178003f6d231bfc134c4e063a65810ed4d72c2a793b1b1429bf2e7a5493852c593e88878e1411bc63c3d9bbc31b40d65cb4f8ee322c0f403f247c794354d30ad884d804aa615bd4227919302bd4a7475f7958f5f9ce00b1d63476f7606db62af926d7d3a339af8978bca2114b5d40243836884f26349aa0523a822093d6916ec550f5b0ed3a5c79e3655db7e0027271152735761684fa96a97decf9a78db821fea4bd7d9cfa92ab25211272712e150d68e16f726792fac275e6f36cbf9375846fb04172b15c18a5fa359f261098a15971a4bc7f046a8529b8d8a2d645bbbe186c42b69bd066be8066a6870685790387ac9b25a4893b87b0099aa8ee393dbcdb9bb48fa04f92c34a4248f5906d3236015b1049a628fb16b634f1615d856157febcf6a066e30d8689130529b366e8f88334de5b3bc52e08e778d8b1ec8b5027e0b740cc469433adcdd13c3119dc516a8617c42d402482268a3239907fc89b91a9ebf67c0303eef66fd01c1353ebb0e57e0527c25f790dea99c209284870365bebf36ea941b95c1793daf9a337762fd4ff3833aeee0ad8bdd50ee2570826ea541ba53d940f52dca20d23c4ea3c330fb25a707f842f79105366f2e3ce136c1d5eb4df9b0c04afc6afeace44209c427cece15997140b846456f256f92f59d51867b716aab43a26ad08fa6fea590c6c606dbd6b1095bea46d9350e958fd55d85a2c50c2ff2924b8a0c0bf50788f375c3093b677324be5920ee6bcec3321d4d584db45418c3f04a34641c91ffc5a0974c8fae1547b6cce085e442d95487a6c721a6d4dfe9e525dec3d12eed9205a79001cac8b207b6a0489ec7ee025c43f9e98375253b09e94bd499e73352624ff871e1e60834ada11dc0118c8f8d4d175b4b76056ffbd118ca42bfa0f7d4468e6d41afb83956658c62ffe86e00cbf3f4014be47cb6891cf507641ce16c24755e42285af2b8df3dadb0230040665af6863c29a89ad16a088cacdeebae73b8be30925bd56339da3038ebcc4fbc283b68ea8d76905f334808fa843a1d8b12713249af845329c959f97e8e736991e7cbd39ea5d1924652221a8749ddb809638afa5c44d928cc3693b409971569b952667fa9f57f114a4e778a33c99d785d1d718bb5a9e9ca29a461d70c21e7cd2da7256e43f99c965f6945000c39515386f3ee51bc5cae47b30ad2103d1fbe1b96a096d6b275b2df8c2d980b1774869d0f6b81e87199aea2595b6cc6f1ca93458f1a008d1c80ef19ca1e4ac5f0f3e21f38186fdaf653027c201b68f31be6ddb5aa81123ec300a85a39906d2a09ed0c71436669138a6ab008aa67c2c5619c24d0d72bdf43e5550b36298f0ef7bb48480ccf4c29b86052ea3bf8f682ccb3ef5ee97a9ce2eb0d73f16b55bd3862460975771036b849e71f8e3601f1b9df7c02f42d822540630a8a99dcc96e3cb26b3f36f37d1c80ebb189e1d5bfc340cdd5f3c6cf3c4b98e88b7ccbf2fde4e3ab2ae0da428f7b29d59f0dada5fa2a18366c47dc89f8d947ef83c11141e72474e47f72a2e175b3a9ba51e742e4f6fd19899afc53b3e2fdc9b95b96f6ce61f0326478e5bb9319050242d7e22c9f93a049905db48bec56c970ff48e2190a82631b152ff2960c8f3fe3a51ce05cd99335c59b918b398ed69e02084eaf99f17061e89b5676499810f6616a13790deeabb2b0e8b2fb2d86e145b2b02a232426d423915bfcfab6f174ff66e6c059e96211841c59bf3e8779f62a83067cf8c45f4e09ed45172e47568c4a17d62a880e94df61afa38381b03582843d02b4cf23d1b298543f5ec95024ae577f2a6a72c0b3a0c47db51f90ac2531a3ded8765e77642a55af5cafbd01050102e1b385ba47f677898c78940758bb4b631bdaa536ae41bf24d9c35e44c08ca5830410223c19e3b387eb69d68d277bd93cd71b1ab236e43dd3a091ac5a3e2de43443a2add75f0ae5e7a1dcae9349c1e594aab9933a40f3b52782773665b287797fe1bd47e5a6fd757a0454c1b1dca8b61c310f400d682a26e5c2888e45e7a556048c08e77a254a20b5f60547db6a7debd1718f7433672310314fb0592af26e80abefeac84f05bf71a4607b19aacf16af5e29bd24bf3076bc27db4cd3c0e6c8119d8c354d8639bc3175e57c7295a140945572b329857a1b92fd309f4097bb9f37904d90c63be109e4031259433e7128c551c612fed14eea81d1628b2ab3851aa11fe7b4045476ecf4e16fd45f82713305e43e46a216386a050ddb7d4272f500ebf1d07311700877fd820e0502ae91177e3ccfbcbca77121a4aed4308708e28bce85afdbe92acd57e5cb3e599aa88cd0eac6b53df5a7cc89a678f6886d975c5b4f378d1492fa451e513040ce3324c256b9546b2902ede0851d0143de9fa15a4abeb4bba2b332afb56e03d96e667f73a533223dd0b6ea9c50798ecfedd92f7ebf673db0be5e9c64189a574323763ee442f880eec4fac5f0b8cb4c2b44395b14130883c518d65ecf6f6093886685cb379919fbc38d68476402929cc409101b3b2531bacec6f6f9e99ec8a17473ecf51ed4e52401d2761d8bb8736866c02197fe17608d5f1deb19151149cc5b20cbb7568464d9de9e560cd2231ee590f550e41f5681e3f4625f106c7d38739345227ab8b713ed3eb11039c09edc44ba28be27c918f7ce39a459cbbe45f4ad5f9c4d62c9ef4cfd42cc746c06bd151f9958d38508763a60cb268b819863786c5a41368fa9205beb1472e254935e1717df2dd1b23eab2a4a9c7eb8cf25d52e68f6586d6f672415bc0f62591d6b4f25c08bcdab405272878ff7a75f5a31ef9d993e0fd818ac8c741bb8b065020e3a0c558dee4aede53400a5404e559b459c95c2e5a521a69910e09494809af4df8242173d7747d9674f66a0ccbe1e1379e1cefa0eadf8f38a6a3db1920dc95fb6cd8a1c4ef25ca034ff21a6743d7748ef040b0ff8668d410b83d74b25b893b1649ecdda05102b88fd4c7304a3d7a6eb662cbd3a0bf5aa0ff22a07919e71a06c1b6b3f0e21bda5ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
