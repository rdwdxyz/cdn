<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a83b438435460a46d6676c46ab71f02e816a6d952eb56986f15974b4f6f7d078f33b3077b3f9685918b3b9757eef1d61672a91abe3fb34d40c72ef398be24e4262635d10c8f9bef93c39cdac40d9455c69a0363a78adef9475ebecacd541061193956cf544fdb2a769e9ffcb63ad3a28cb8059849d93c5a1904cb70da8bbb63bb7c3b4e5268d55b07090c0a28c5a8932cefd416cca024119bb46f4c03a9d63572570a9ccc4d61bc7ff85ba05308695f0199ce3b293c44851321673b12cecee6aebc26dcb003f38451717f507a26c97dcb933478d422501c19a0acb3c6cf6ed3c330239b29d7b5343404bb33c817508a11b83422412e13c704b5017346f3f968a2b0887b24d0a1ce0ec9c46668f7887465c3af6f7de9d8cc9e4cef92fe819b75168ced476ce57f062b5df1c8f60a61c4beaab3ca482aa8fe120e8bb09e8880cf3bd016c45840d3338f1f8e906d999cdd4e650dc4926858c78c9444a9db1de9c3aad39e406b5545bfb9d007d975468812fe586c56d3b3d6929c14758282551a2bd4cf88426827ccb4b35c44574445301075efcbb852d74b70f0080815358c66f3fdca7786d1747646e73e24c09c4f91896eebd65a19d12b2601edb4f6c66ffcf81018b33f524a0d4af606469780e011f66441422d5db415d3ba4bd5e2067e2ce21427770da6f94135ee5cde37baab289c366badab5279c9b0280d441e31b1c7b93586fe52bdae1f1f288da20b6335facb0a824bc4039b79e0df3f4300e4634b8deee8f9ec39b099f9d06a91085cb7c9f7725f40ce142d098c4544c4dda6e4a5b8bd0e26f5a3b065aa9728cf702dc098c661ba0627631ea9069a7f8ebcc007d19ea1b5720d833195291c1980221d09d21b5044b242a4c3d76ebd5e80d7900e40b93196fbff36479d1602ecfec92f3aa251f70c9fbf2121e30f38b3f00a2d6bd5504bd3e8e8dfe79391819f7ab9b8d5a1836e13c38ca5fe66fe002d2aa97e43616308e221aebf84fb1805cfbc9274842a8b1ef17e9525d0f1c4bc47823b954f3c6990470e5ce894c4b1059312c5b3e0eb7de0edfd615001ca04ef2e977fe2648f27b6f53af791e20d7bcac63471b1901837b80d0c70348eab992078619851d67a17ebcf71eced25805bfd81e6f7fd4c20555669b2ec88a6130bbd839b795e577a47c489de486419ffc19e569e26d8f4879f9b243be1655052d23c3483af25bb05c573156fe1160760a63494cb3e419ba61da57afe968f38fad1dbd35cb649ddd1f696c6184faf1fbcedf21df1a8b0adeac57cfaf81fb6bc472dda08d67439b204e02233159c9602af21fc5acdd6baf4d24a1fc9829c782764c0f236021818dd86685999c163968b3ad66cbab572042284695cdb2beb33f0938825c0b25bce7d684af6111f3f3bbc599faca93badc49ed2885a6b00d003c7f9e8326d044645cb17f5d30e6d09014e2130c1b3140ec0d36861264412b4fe27398c1e3698f1f164168990993db4c99e7679b46d76cc659e765a9ccf80fa942c9ebb65278f81591a92c55543d45a680f99f485cc57fb0366d901ee1dba62db4993d60d558692fa3ef28bd87fc548b95a96f6fca39fe91ed76c0ecf9d2d02494432805f1072781c37e623162a0243702857a6ee6ec69bf2127101878862d7cd8c800734b4c24b08b2b65934998edf026ca4dd124a093259cc8b74779065eb90ce3e9cf048a129ae57a1199a888c91e57c5d66e9c4bf8df3b7516fae5c06726db6187277de38596dfdaf47c305c4a8b969037b130153365ff78bf451a86ecc730352e65ed7aba0308c0b5ba62d8939e9ed224403f1b5351a00f7d4a923ecdafd7168bc4ae2cb6c03ba0cae89b529fe2e1d31c3b43ee28561e95c9faaffd425b79ec19acca6d88d8decb1ebc22ed29b85e8f57c7b7da0ed9fcd67dd6d86df2360aaa76f053f860398efe7b7d9b17a52119bc95dc61675c8d7f2d808e6a9d6fd3da2bc3b42d1e8dc83d723609f8311191e7e1be5222c047f6ed1fefa1eaf52d65c1ef7818325c800976d141e31850862c0ff43480251c947e770b3d2e46d2c17d684bd8b2c1ad6a5fea36fc63fe5ce6287da3e95f1afb21ae4a167f90cbfb0859cc7205600b9e538597ab8ee43432a52623d80afcedd5fc2a9189dd654a42dd01080384ef965cad271e0a4d039a38cd19f1edcd04a0d2a8f920765eb4ba030c3e90a4c1cac67f256a8e300f0120eda6fd9eba5f746590fc770bd7be17d1d2cebe8b4fc6317610f2a8ec069744b924c1194c6a5a18ab69e73b1b90b369ff90ef7b7259f0dc944b5df888f0170ba8ee97c6b6a7d03a40fe0a4248031a767239ae9d7e38a040104477ae6987cd713ddd30409a7b02fcafb6cb7b01f98bc4a0a6ce0cc068f9d5f6c79cb0aa8aee2f74de9307d7f1ce658b50f538a9fdf982804acafad6a4dafb786d0061e69e5cf1357c6506f12a0cbbcbac60141519fe379396f02d405ac88d8a7d0e0597cdc048f7760719ecc043bc2077a98580c50f8e5e151291edfc83d6217cc96f9684d8f6b7cc85ca4086057a2611163208a6e7c8b722570aef7d7c4fc5082979c66173ee970998db6e8d4d2abf9b68c143b97d3840eb8a6f535481551531429ebe4bfb57a2a82c43c88a2a6dff2e827727181af328837c2b79ea4b4789eb27e123015c19a24c7da7d102f95487f128feda08116374193ecf588ed2673b8371df3d83f0bf63569d52125bf1ec32700c29be0631dc92eaa8bf6e4b4c27cd8f430f18abc5264735082a33db47d3f5caf2e5331fd5ba67485cfc36eb1c40610c011c0187fbbf048ea1ad50a57134eee7d4247f8fb19c33fbc36a2be869c7ce2dd158765f75f49662e47f35298ff0ed8958971455827ededf2c1ff4607663920dc2dbff51f34ee87ded13fed57e13a28dcda4cf1e1b4f97784dde4d02886d41f057ca4b2c2b24193e119f51b067a15ca241f4bbdb9c4f57a06aac197534fefc58bcf24273f561949ef236dd2c37ee288dc15f5e75d2b43ee70efcc6036864cb9fd80180218c8abb0dd58e4cef0420d4d8c527d6b322ef74bcd30d759387b56ecf6ab4220b5e6c8d8022d75a8fa331424870ff08c3b330a2d7a4f65b43ea7e5cc27d437213ef6cdf83e1c8e8bb966e39ded9f94095ddcfc07faea5d5f810cf3630ee407f2605d1e54b3d8acbeb48d892186fe097ad8141c73aa4128e1ff32cbac836783bbc87e8657ed0f874341b8818ee4df8edf8d86bb3dfcca4adb4c27ba2e4ce55d0de2aad9a9b1c533b09a41e392af1229daa5d33d2ccb34d0038cef565fdc65640da8943b14880070b70785b4f83b1d069121102babc91758265191a2d62ac6a4792e1e178fa19d0d74bb34e81f19f3865af9006b4af8b37ed74a94ac9661a2cf87273271818460bf772cba70623c53da2936a78ccf86f23b1f676357be2fea9be7af4e0887c6f4f6ea1e352a522933fc7b5048b9c07f5d8c57a6da63fadc4eea6a555787b441da27f3ee15b0655888718891890ccd7b3378b8605815c5dd1fb2a7f5d77f76f7646bd773f4c107760bb6b14f29464128fea325cb65662ebdab1d902ba343b49479982ef42a2e55e14d9c50900d584300cf5f514106be66e6ec761a0a456c0172a59927bee3bc83eeec24a047eae60be3ebcfaf554df27868634dff416b4c6947e0bf5b0740f3f0356cd29f5516584eca6ccae2c14541c2dd1b1cc19658066bbd828b20f7de792eb4f1b125bc5d3704961284226046c60a581bdef284aaccb5ced2945ffa9fabd7f9feb3049694e6551d724b8f2d473a6001c544820c9f3a5775efc281a02b6b3e0ef35fe5f06e3fb228d4770b253c656477ee0a7ca77730c9de1c51dfef479532d82532e94f93beaf613ed78d5070b07fd6a3223890ce3376c1bc7256352aef98ff35883aa3937db3814cf430855575aeaecb5d215ab4bf9856316fd953932dad8c9c7b53dc0dfa76f5a07de641f78a20858a752a71a1f6d2598e887cd50e547e6c85b0eece3c8c811fbdab96fad5d0e66aa553fe2027c5102e225a7b0d8e8937b6cc4abd9e674fac945687835ece4f9dd2c51e9747ce3173562d5f915f1422015f3f60e814102364927a4b62b951d07af2a4414631500eccfc15accb3f4ef3c7956f26dfdf52627b334271085b5fb9ec3c2683be72eb042f0187390945340eb5142e0cf299ce59d43f3c8d3cd9986ef251d6bde78dcb6409ee3cb7b77ebef28863e5ffd1d2bc19016cdeecf48a81633e42c103a29f755d7f3120e4af3eaad749a763bd9b7556655b5e8007eab8e8d546e8df92f1c7ecb439d74b9b0090f6b497a263f1e34f59cc614d179dd727ffa480ae5e215b94833efa900fb4efb9652f1347f7b6d51504fcb18523f15a95c089e11ab4cba94c90f96e967461b1b2d9bebda129c4438c16f82a905f0118fe7721c377ee85a8de3430d68308003649d643be3d9b7bef40347586429002b4b5dd9253c8c10a46db0455df76d1f4a3193cd05757b4c2aa1dafa0e5d91e28678e67332459565d6a3e25436afe6171cf35806cfc692e221fd5333466ed4369eddb9ce6215c8b79723a91bd3aa6728db5f9bec73a44951e95232b62977042851172f8db8a803d456707f7f0981abd9f42c2177258b5ad94a602a818b2813807f3078f2ef55b9444f513948250b228ce76eff9bc01cee8b1d9ae6a5c69529c4084ec49f96364cc118ce551aa70f4f86639b4f299e6854bdbe3e155d598d401ec4ecb49cd75ad1c100951ef8403991482690cbac71f8c87f733fdf04d26eacb5798ea4b409e79adfd24fbd075f6bd2798cd1fed46852388e684afcab6a9b8f381e6bdc979ff15abf59b14a17565ca02fe1d4f7a4f56d4c51fcf8fe00acca902c2325f5bdb41b6912da981b40911204b52e4b933cdb2ea50eab744269d57acaaf9f6953dfd83dfbd1cbd8dcb48e6b1724e1a07bcbc0c3c702d882d87fcd54a08fb9770cc7118ff5837957cadc80e095959887770fff477c012a51b055dda984c8818771795bd97c5ffa402f08e7b7106d04bcedc5046afe29acdbcb54f56661b1d0fa732bd67816e090d4424ad8f24643a6b7c6c0ab2caeaba0385ad8df20f0dfe327a75f46db7b119b05d805aedf09f582e43428845fe885751f39b8a881aca9b2a4e21e42e1ba4e4798f81c0716c82a040267948e087a23a0d4ed9cc43de6e423a605fe871d8ad5fcb73f85f5b5b9ac54a0f104dd6289f65a5940c2dad1d1dfb951b9ad911ac3ad501dce62d7a169092d8333832a845eda943c3d3073eb4ff9d5b86ef3f17bc16c8ffe263e38d9b8261a8c90b2ae9b9dcdaa2de13e33df21b32ea23d9696b7d95724d9d5b9631ddbcf55ccccef47e1930b6caeaaf46b5a0b79a55692edfc663036e6ece39ab1957cfd9fa946dfc6bea42734af27f06f76c2daf4c797230bbc89dfe4f2eac5ac0445c1d08eb5664c1b5785ce39190e4050e86ac82698db2b8496ca69846080a52d46fccd5674952f3a29ad4e1571e0dea85763c53cd172513ed49e768256cec3b90bb70e0bc93b2835c2bf52562d9bce11956f142f97f99ec478bb805a62bba9122b8e9b713c89e57b2cc03c90f17daf980090ebd6111a6c4fbfe9d41e72fc3fdaf5c0e0ed3c88a118c9fae71c22759c847a8fdba7b84854b59719d4daf36bb2d56ed8b95cf3a7b449dc0a11f59a13873c3429f5dd291aecf96cabc9e9be1b467c85c7d7b51ae2cf3856b2b7ff58521a484e85b45947938fea707bb78e305190dcf8be4f592ad3c79d6c8373497543d9cb6b73a85df732ecea99efad56311f788d1fbfccc9f26eb034f08b5e1c008fa553948b8461d20794da23e4e9948640c53ebe57092b23806b14b62d2f3d4b72d17d91eb90a3fe128d329c139cd9c71fed31593410355cbb8505695e81991d39f616dca5e5f1c9f14c821347b9c4da43935fc4d605f5e53d5246443476aa3a78ea01296a81d6d108525ea64f370eb933091958d1a0bfb2d3d097085d2e24fe23164de996de4f9a167e7a7e5459d78254a1e62a35bc725ccfe2f110d0d0c7c50b40dd50fb91bc36965a36e9c1eea5d688ff31ffede4916cbed33c7794f7c646c59944c51a99bcfc575f7764bb8067a5f2e3062dec674f59fb05f813df3520d96ad110a405651236e8fd89623730e2fd10d002887a595c6d35ac4938843378d324b38d0d195fe472332c1bb2a721dd0de852e70d9b317a8cb9f62cc447c0df3a76c540a6cb7982765c6dfdd4a36187725ea34ebe0297092067ddf3fe780c78006f56b6cd58d3febcfc4b9b7f1eb7dfafa05858e9c7b451f6b6be6f93244be19d9cbdb7cacff70cbdd124886f644328e73f19d1ba5169b077e0b61bb6bec53bb0548d5af16eb427f79aeaf8342516987e609bc72c22d568f366193e18024f1cadea3dfb007e1af837acaa5789fc6e4b453a55dbc6859f7552c95814d81a4a82caff2ce5c7a230bd0291dfab653c96557c648d294d215906e7de96c1de22ee4f1bbcdcabb30273c21f4f15e747b8fe11faa744d869d5ae76c7a20ca8a80a4742f269d65dee97aaf979ebfe7e0e884f17a6a164fa25bc7fb05f58aa8514f625d5f18d00d9beb61b3709c922155205c35d7366aa18a79827f51baae01c0a81dda301d00227479af147c982241f80d37b42e280a4826fa0cae1774286f79844059fbc06e39eb2b2175f2975a5b1726454091f2d4db6565da4763c3f5a3db1cd8a941b3db949d48c2cf10d75d905d34ac821f059bb196ddfcb85850193f099831eb799efc078541a73cf010d0db0129c3ebfff832e86ce2d8286093f10402cc13c17f32fd620b60e846569021f10b9b9ef32a745a8c335c214c8d075560cfd3290ccffffaddfb4c077638186582922eefecf246329ae0d9f516a3223404dee861262527fcb22ccc57a7b4ddf6fce728ce31f4fdf6a398627db408a1bb84d273b3d9738e721400170234f963a5fd48f1028902af1b769e689e373aecbdba99898f67eff1b80f1deb7552b949ad97cdbb243e1dffd1b5370fd1c60074e04eda81e1b535d6d0a16fd7af1d812dd56c7554d666caae10454e1a52fcf60617789abb105500dceeaf0156469d54a81bdd1a9b45f12bc7aaf3b1b4f2ff5cffa82e815566caaef018b1b3cfbe1d299838245cdb0299093805c07349112f0aad94e7614b2a88137a6804204e56a5d419aa448c6af7a1e1322358c338dd4437be976cb47dd497f280c3380e94b96e54957683362760abaaff3b2e44f847d95d64ad6ba240fb47a8971a709a99a6bbc433b874a9c3de70ddc7c0d38ea1c6975ccb965caa3f18d01602a8738b313a259979c909acde0c8d1feeaa716b1de53987b7f7d5bd288777c3f95d6055243e49c45f977c372a01c2f142ad3061ff892e68dacbf489bf5bf7a02b4f791fba08f443759b007470b1f5fdf7fdcd9e70a0593c9401142b936953180ef8d45c48d17312ad36e5389cfd9a214bb9c05dae85cdb58d04adc4084bca76e3340f6da225c8ffc76a3acfc5b93d6be36c7d063049ff2c17261a1ce8c52fb4d9786f169a6177f93405f279e94b814f559bd30f20daeb4b77d1672709f7360f81a203bf1825454edb228aabfd246175cc584b4054d8882c816840d72426edec6befec8c3a0babe6a43a3ee5c87f1314b7f4d4554b605c2c50e46adedaebabcafa1c4fb8a64d7147a7b4c5f0947efdb4a082a66c34df0dd7868eca9a9e4084dcc0dc7f88a745a90e7c01f69d99769843bcd174fe1ae5c19f980ed965c62396e4bb6be10b06a30469f0c6c79b32ac8d6ff456e4ca4beec41d4542cbae0b339e308087b96cd2bd7e15fa389ea699c1132375c94bd5ccb20eab7c3f804974b67b0f05c026a164be56d4999d8a7bc021fb777a4a0ad98b4fb31088fb099280ce5a2b26402dc519f82e33042caf49280395b96821afb1ede22f18439033daaa0cc01048c3301755e7fe3ca94adc603670aad4947705816aaae6eaa18211716a4c45e9eedb6dcbc3376cb5409c6b58e799c0d46cb07d484e9c5c6a9d96bf22505ce6c7647eedbde152be76f7c4c9008619ebe35bb3487e8a11ddf5896f670101dc46f128fd17527f90fd4293971e2201e72276a5e92baad4c9ad0664a832c73936b32a9bc0551040aff2ea0feac07281e72885a60ffc70b28e7883f76fd44fde1103275b76809177f1e1a151920f564973101f24930cbbd13508fd5c3fbb401594b3aa1e3a5625aacfb399e4f88c94a7fabb2a6387bc0625e0393f621d6ff9a620fe3e8b7d5761df9a0c2471c406d55db620346a88595018938c16a1807d4d7fa7535f1bcf580a8e2cd14e94441256357ffa19d813a1ae19c1e5fa70777c0259c9d7df9bbd49b2b80ec3b1298df8c49993ae15f912fb657e6c6fa2a5a6425beb0ca8d547f574bd8ab3515f17f0999f8b905366dcaa36d7053dd94082edfbb1fea345536f4d82bb63e98da321a50b4bbb912ff0121ca75afe614b9b534040150d26a34efa1f673c72bbb39ce84e331fa0cc10c2367ef43b95e8edb877ee2ef7e0a1a769f709f1d719c85fb9a64a9f4f97fd2123f950323e6e859d170f44f8bd2bdf44e37516021eae16a8b8830411eac1b80a2b65fca903460e22efca3faf5f81fdfce637b69ca3396f27be5289642280ae5f613130fe2739a46ba510fc776207450037448e049472649efe1b063c056dd8c2b0cdbad27fa4e756a0c30b3f5a9fab0d066e603af6c2a0a1e016bba03cd886f51ce0d80c2f5c45f5d248fe7ea72073233fd1e9353e9ea02185470c3ba369c2ec58953282d4e4fd87f62a3258e507ac2fe45eab887e1ced2d539908bd789759c7b44f1cc012af87e41c5ca354f50aac3dbf0e4f63da035bf4bf1326efa5a2183e1fdd703f200a3c5864fa8889c330b9a10d3630e0178ce6e36d88c54acf1738e533a220c1ffbbe1ac82186f3a69bf907d6b61128f9be98d83d4de9725d62456ba8f39206882bf42fc96e326ec35cb5ca54fef6ca77e93cab008664f511ae01641271a048fc2586f07ff57602cfe81db14913aa2ba031521b6c109164f068be69312b639a840a34f490b94e850b345cb8ef00df34e582d0bb3739221d81b3082bff27957be3a2e612b7a423d0ddbb1a5d0ed1de03640504beff3322ac51c4d42ec61dc8d80237dd4b715bc885cd10a14be82921754063faede655dd75389f7ba351e7b6d9c651b0416f877b438656c9fb76c394ed53cf8c3a2dc0f43c02d71ce54d53c08a469f6e6bd629ad54976d7f0759042d4e1b79db28e7cb1f73393f405469c44a2ae9d252b5306a6e942d048505d58781008cd62e44021ab30811a85fb2058bc358430a1ad5c740201f1123489a0ad6cef591aa6db7e80a55084863515fcd31c4956b98a637367459a3598702d4953f71c9f7ec5fec40d7a68c713018a6c090c67a2b235ef446a404f77ca2c532db1f4fb06efc3b3567e9f85fa73611288a4b00289f9599218c9da102380e1200590fa5621af4bb9448278de81c8356b3682430cb3cff42cbbb4b8ad24c87b3fc970f96ddca2bc840f4601c23ce011c8ba4a1c9f3817f7ffbc4201c0467daaef089623735fdb01a037517a9513641faea55d24013d7d4725a3b25f8977c20adf6cf8e161bec71c35b26a52f7dd26240f939c348d8401c44986cbc9adcc045fb71383ec360b8aa7e0fe6255981a6786189964753631b4e1cd8133badc0259608fdf8a85f5cf923f8bd6b26e27d68deb6270bc130b280416c6acfc70850f7824f47a591b3ccda1bfd94c0792bc5e5e37586c7f3937abc1810b27f0b01244d71a08ab9bb8fa4aa08c2770ea445a66b84d41cca13ed2bf772a506c9dc655f7764ce010018c3ac52469323f1450fd206ca1fb69fe96120f5efb5a6c88b2c3c5d5a234970a7832ae153e7ae606248a84332dce359398fd954462e3809fa7f5c80f230cd495b0cd78d2661388a40504b03c10d74f13c67b43d7d34a00f16b7081f684ffdf225ba0fd859e4379a24373cb145bc1c733a58210bb71723953c01cfc94f91ca73dedf3989c7519bfc7ca32fab7e72225fedae8fc67af985a39fcf45743b63e2f1dcc454bad613579e6677dbe83d6b162c1bd6cf77e9371f78d12548b61838b0168b033930279c3be846efa217eec016abb2d67cf56e2a9196057330897102c5e6b4f5a075babfbfe8bbbfa107bc4881815d01bdd967df79aa64066aa2a89f1bd4dfc2324f8affcd617c9543eff625e4a1c6b1737e974d2283507c322e364367a660bf8451af9cb99f3a7798f34c39a647b08380ffe8a6b0245c37a861796998a9742539ccfe78be9eaefb920324f1313b6be9423a31e10a5e8f135a72a13948d1f87e1935f73e999afec73e443c548f62610f10d464982d6252e39597f4d373442912adf105b0bc212cfd5a8730e7888f0b74b39f9aa4dee59b9f4befa3b35123c123fa562b3f1cecffe09bcc697a2a8742d005b6616d7350f0a7a8a0f922d5360aeb646ec6f6335506d5ec7acdde54b7bb8266aeb698905eebc9f37061814891e13f3dc6e5c7299652a75879af2f30eb4fccdf6910a84e2f7c9559caafe77aab2f975fc9627b55c473387ba128ec3c2d9f88bd5c3c2ed1ca2b2fbbe2914826d192af2655d299ff2d6473dcc01d44b455e31010302819462e5b16ebd2663712105ea6cbbec38fb5424daa7b6f5d81f7c19a96a48d191c90f700c7ca61d860fe09e54a01179ef310e2d460aa8a42f8f6ebfcb49800ecb178363ad30c687b322c850582b3e74603d022dddada801857f98b16f2f78f6676be1184d1124c0e4c519d55374e5dd9e73b2099ae2f703f24212b9995a1341be89fd0ec903abbbd09520954b0f81285be77ff042a2adfa7cc5667b35bce8e5166edf45651b81a28fed51b3656851c6a6f3e5b65ac1dbe4a42b7f03bf6b43402ac0fa4a719301bc50ff137b64a4acd4ba4e050df2e11612b47bd327293510f44902fa8bafb317d000bac80a6d64eec66baa69ad1e4fdb1937b20620a8ef3bc19da91d788a507873747f6a8d197ee9a1ec48f3845e40d390c3642746f4f7d21042e1f6b495c60f4ad3d5072ffac82b36bd314889dfc413f8f5ac5c28349919224d3a08f1f57ff916e2a3928f580ce10dc7f825ba2ce70eb5afd6fed4804eb13eb203a834e8093d23d71e66d7a11f9ed4f3dee4eb3ff5573822553acb3bf221fd119d23c59c195fc49d725a08a2b7232b352ff4c8fc651d6acc71a9fd36b62e0e29963d2937fac21f6e103692e2ba27bdfa23482ef1b1951c747be1869457d3825a04e51d23643baebed20a054e34990076e866fd4a9b052d8d9ffd34fcbe807d9b3f1a3f61fda72512ec29eb489532d79b71ba2984852df83db85b7a7a396ff1e3c442eda061673d6536c7e6ce87a8427451e7c847c34474e359eedf133b71f74c63c64321d205cb29768c4dacb27560c06bc52b5c6303f809dd8b80f2a14d7e0d411a97f84bb7d818a0916d2f78060ac6d872d6b1e5b152624286914a7ab42d572f60a07b1c6c01c0cd86edc2fb2f862e327b44d3251bc93af2ee642b3b49c6cb3d41cac6c044c27d8ce5967e88fe7a25904372b39c260cdf7d35861eb4ad95f2bc257e381fd5865c6752b39d786ada2ecb273509e3402d65e46a0805eb2bc3cd61d7b6af24832dc26ca2aa54c2a901243aa8b8f54a35dc2b866f2f5c72dde9bba70fd64ce69c759792408f929024b98a6e8ba5f3c2dd1c6d0c4881a063f256b6df57c3d518b811eafad587f262a06027205f793f2ab33572d322bddc89696a9707ffaac9367db4a18f498c064565805d96ecfd24b3adad588fc24d1b64520c61786b28535d98e9836f99da10c92761db1aba5e0ccda1564860075f1105567f5fb8f408e4bf73bb3db38648084d20b543282217c532cd47a40f39eee3d7cc5bb818a28fba72879664d0d2096216e1d89ec65f75e081bd0b489d515a4aff4a96a35ed81b2c8256c1cb11d0f1c565fcc575118021c3ff93bddc863ae6e7cdf8e5ce0dc2ad80af3fa2b22cfdc4024c78f93a7b9025c01042198c48d10021b4b12de19c316423b0316b3d053f114598ff1adc93dbda78078cad67e4542871f87d43327cd929f51ca4589145d2da5acedccf37f6892110710f7cc7eb3e3055c7f62d9907ab697ccbca61b831792b4e305dd09f9c6fab2c5e270bd27677cdb5077192705a3d0feb01a36d000c7ed54ec55f4f97e4e51111cf7ff6bacc9d285510bad10508d0d3139c02d6d39cfd33f7de66ef93dfa86c44c045a333b245776b8e14b2e50fda4a8b7949a938aa81888d26443a72e941206c612fe5e2134e9bd9896644578870a4fa2d8d93280328edd93b1ddae328f370766d43e84f8aaa2429585be7d2d09559a5c529932402b94cad4489dfb79a2e20a226f2ed33630a65786e7e71503bd8cd830508076e4e6c66e91d0bb78cb54164e230f480d71da50bc2cd066018997f7e1d2f47850e2c3dc7b0d2a74541fb6d53e8799e748576154a5891d14c081e98960ed4285dc8fdb2d92fb3e908334a98a4f50ae03eaa4e4f73c67a79335daae338f9b4fb92de37e311443fdcfd6d4e69b8b1208e2044fab4fecd8e3988fabf0a352ed88dba33c0efdb96c699b14cddeb85b32f16cc3a20a594faa5b69bcb20896d7cda22501d7a5b4b137a407c6938e741c4e8a54733ddcd546ab9cb0d1b11b1be7512c2476d73d03de9d40c43e304c00b3f775ef0e4c16370ad20324f976038ebea3434819522b9c13d00c2d4794f6b11c976a255b432991055703cd0dbb8a14354f938dd4d73de9f11d3cd9731274496b76e9e2f969fa10c3164c280ed5fe541b43bccee8fd3fb0e421129a7ec11787ae6113a9d92aed86835e7537c19b8d7c2ca635ce8744ac928534fca9aac5b66a93016282de5fcf86e13b17eeb1007f4561a24a318727be9ba61a77b8b0e60ff92286a45293ed272f70fb8a2bdd8049c177418185d710b41aec4a66226702dfe8d9d88bc1ca0927a34a407091903d14c6607586ceeacd4100346c9dbcd41c3ee0c48ad6ed4ff6597135ae160f771fcfc9accbc23ea82a561ac5a041a2febf023204de8af5ea33fa80f665b754d7c4070dadfddd26a64f3e5a964ccf08859bec5148128b35743c60cb4ef10553b03b39bbf664538e8f363e0a7779e7d047c4f4f9de87056bce4dc21f40342658e5f1b643d15f7a85cca7e98a85e769b7c0712ee4a3e1608da7397f9b4b11648379ac4a04c5e1f88ea65ca8930e916dafe0343650ebedd9197a4cb23a9123e4c2c9d0bb537e03bc0cdc411a037e624d90adc17b969d8c9e0204c478eed7c99141bc35d00cf5569d515d78badc56668d24a9766df15644759ebd37a61a77de533ede76153fc16642b1fef6b9cb2d5c3161e01683c3762156dbb9ade95a5aea3297849c40c2caefa80938f8de08dc6475ad21dd1c238247a802bc46ea67f102a96c296c7ff55168569b548a4cfe0790351880d64e213ef2aa7deb1c805df0a44ba41ed8df19d643cec478f0658d55aeadd3d13d02dcd130628cf1b493770a65cbba696f5d4f101dade4c7c2710d7697de3f7b073c93741aa1da86bb366c8b2eafc2eca4e00cc3f2ec97903396751b312c971a459d63bc447b27a2d2d082af17520b172e3b0184350e94a9bec953c1697b5b6e1298293aabd834126b8fa8e224faa9cbb59ac22598b4f505ea5b56a8a8095250803f53f62912a72f75d94302b759f4fbc4806a05ffc797dcc8e80240427a53faf672f0bed3a88dd6e8922a4e0f826871eb88e2a18aa41a134ee0dbb4c069d4711dfeb1036fd8d6d9798e4bc80c4fade94cd9ba1e20cc6a206476b3d3d607633b4846504f8f62addec7f08d233e7b04481efed6981cd9baf2d491559b215b5196481ed7c9c3d5ac6423014ac197759ba63ebe72ba8bc1dcca54b91db73b48fa3eb017e504e555b401f3237a2191cf041d02aa068ce08fe16610572fa1a94e4f4477c71cccce5c42d9c6f4c3c7f1faf4cf189f46ebd35d9465ee59c2560a1658829935c38cf85522b2c27e4ad430cc1bb8c68c262cbf36ea271cf25321473fa3f783b17f0c1844b3ad4e3850c9f4c8de09b4d429a27ce0b024ea1c3626bae212af7d133d4fa3f3adee13101aa6bd4020b27603264441fe990faaff9b2a1db3ea076c84a6abd2c594170258e3dfd31e1ddff44d0e0f1d4db4b697b50b4f7581c38f9784adc5dbc7dbe8f6eb5ef39afc9a87d15da39d5c1b7d2c4a68fa4acc9429aeea523ae8acc4eeef9c62a2d1ebebb0ba267b90e1f6368e2c5f87f63f7665da966b0d337ba47512a61e3d39500ce6ac799815619e5e2ee0c79e1885f9d97378f17af63dbca54974b7930bd0e50154eda063edffd948559311b2e56529422b5b450e9fa8416d10ef6f104ca07e28e8f0b1eccd72e3c3048c73a7c6575bc7a694e682fb8743d57cb9010595be622a12133270a7e0453cde88517931a58ceb34534a56cfc86bcd3679b19c695e2803a5ac21b7d452700a17cafe0a4c2ec76e62225e81a031b35bf7962fd57df19776cc12e48cca8e97534917e121f03dd104c4f8a93449bae437d930389187aa45f3044e383d2d5d64ec37fdd5486620b66aeaaf31842bf1d2eb8abf9d693f9a18d2c2456cdf7a3c8b0f1f84993e931dce0956a57e38d8250f02b7bd3ffd7ee2ff1e5db22fb937dd5ed62aa8fdebc0f8f95859905ef5807e420f9bb1164198713e82fadeee7ca8d5f6519a998d572a6f5c13670a4b025666bb00d8877e227ce9b59a4b5ba37a9f96b1acb9b8c44c574664674afd9ca4f8df3f591c5563df5d55ff7330dd67814e7b0770588ded9aa89fa3b27afd47a26f2d03606b3e16b5ab68a25fa6aee68e0d90f22a86f7dd42278c47323a789141517a3af078c7e3b60dc208d047e647fd042a56c69d1f3c6d92aa9e7f082d5ff646a9912e5883394addc7c526227e9240f468f0c0fe305af2cc3e1635477b36f4d7d128a488547d660ee8c96f4ef00992d5132c5876eebaf8111129269a7aff82c1a260308c4584155c11582b8951c3248a61aa08aa2efcc8843469d339b1c4085726d29f884252d33eb8f8bbf5bf1024e27aa2ecbcfb1be93fd4f0728999b220e04d8749562fa755d9952f31209e23d260bc952a1bb77bf6ef54e105c67a92b1170a9e09ca864b40a119c5354842c0c970c29ab1ed5b1cd7f7047d6d87a4fcb673acce7e5955b94c05d82a462d74babd5e4180a97c2cafc2227c8df6163c2148b7cd9a556da1fdfe6e92a24548632726310ffcb8d80f4f1ed109bfc5b4bfef0612a042dc4657ec005ab73130354791cf855a413b3e1e67419dfd9199e4080912b8974943578b5df986cb0fe62dd4cfe94a6eacfba6cb64e395e20996949d8bb12f53032794e5470c097a5e07d16e4fed68e9910e39cefd7b02796d70464f46bb450babb6b75dcc97f296fb5b38367555288e3d6508918acfccc7c38e52aafa345bbece33078ba63b61cb1d8850dda1f92a45fb89be31500dbdce98e0dd4cc78c672005bccd3b8170e89b88e09c2b1cb64bbac2501ee1320cf121e59ef7949083585cbf9d1a85cd992c309142fbece7585cc555c5fa15f62985b28433f18c52fbe39fbcfd17d0d7fc0b594360523184a6e1bb5908248e54df32361ec516bd6a9cdedde13a0b84d4b2bab3a38997f6b838cd2d0959e860899f0ae0df67f60d50e1f6a125372864357aaa477d54a14c277643a02ef3171b5354f16b9fe9bf0d75e37b4c8de354860d8540e10e59a7ef840e39d65f2fad18baf7f072ff60f7cdb8c50f1b591b14b43bb9f3e7cb0676a1634ffe0dbfee3d5f2d4a8773561842af7a2648cdc0d14db6ef4c939d14a3b2a31840c0878c0b9e5aa10686d17fe3802db23a5dbe2cea777357fc738598f2e19fa70134400c7f45b8a2ee65d10aaad7e33bcdd5807702a0f46f163513313ee06341261027cbeb4ab09475d8466e4e2dd72134150a3f483443ca236ccbd3f58f83f4fe00c4e5b01362a2cd71e204cc7785776715593e3b837c55fbe0ca22bea8c61611368939a01cd5c0689e5d5807e37eb829f08ed7bd3ce1fa15530882e09356d8ece8f5c917cb05dc549f2a1f3cb3b2ca89294a755ed58c17a2b000945903f682c720e259e083e9c17a9ae10cb448ff533a14682c239e70b7ed489d6565c4d3b7a0608a65c0311f58f59e1f073d5a55a1ba3af63935e4bc60f7b8427c12f1724e413fabf2d7be80ed9a9c9dca97dcd30aeea58a6baf06704a7f56206a332cd95377ccfb61701f01b29c5d8ab8e3f952f283ec0abe872f2803041dc1416eb22f973337d64e5c4019e28c296559b0fe8641f31d65ae82b493a1df6c0db31d07b876051bd39ae87c2fe9bcaea856b3a1cd80eb423384b60550b285ca03a3d880536bb971e500612a3ebfd8c537cbd0f4df315deda48de9effa35f29c51db91e89131f5c85421849bea00ec41c5615321eb03b1f3004412eda54bdc8d00a7f9e5fc6de75b26d323eb1baba46d2f856195a5974dca054dc36e0443b424fae7b7429ca2d13a2fd92de9968f505b9df6921441d9b9b262507701b39780ea388ec3b750ae9d3661979d639077acb00844cdcfa053ff4d2c2429254ab94e9c760fb358afd0e8f9b1a3db85571a91dab079b6ac19c4fb09d453cf1cf7f3c39e39bc0e658101894685bdffdc036ed7d69cea05df57cc96e710b98a7a199358a25efab8dcbcb570e4ad5322aa9a707c1067dd904987cbffdbfb51f1774238fe93e565b6ca7b0b32db839f321e2d86bc645b4f760ff0d235b9a99085ea8a76f53c820deee34d8125b5e793ada81e96ef9c2d14b93176a7aa0b108132e1c02adfcb3132660919dcbeab5bed2fbe54f2f87c08ac4809a8dce1fa1c86a2e7ab3090387ccf0cef98a2ffd62fabae54400bd460eee0a36b153d638150126a03f15819b061548abe69e7999b3745b368e8988badec167f5c485cd822b23dc705e57ac79f7980d2ff28acfaeb1765fe3c138f2efe41e789a42d19ea1bf390ee27103d1e8b0d6c2ea71988f823b242b7b4d10e84ed57a7133ddc41cebfcb68c0605792525306970bc9bfd80778398008521bbfdb15af37288f6a7ba46855504d060ffa7ac5794473e2535b5088a29921d40d77ea49c9bff9960d1fae5a776b87260fd808f31405a879d80ae119e0956f49df5e87e230938b480a6e9a3f72cca2b8bd7460cb6864abc1e3db7e428d8016c6687be6363bbd848e29f6052aedd574a08842f23f5b3ca3e5acf8b2975242e6f972d31bd2745cc08306de85b745a8db62cd22ba752e541c27c54662648f38d4ac9ffdf6261d9fb6272a1d55f34d11306a20576ac0515a51178915a8b30395a93c7c93384c96740dec4dc645e590a9ef643069e0d0f18a61564e6cfac4fc048879a5d2793ee4f48ffcb6b8604ffffeba9bdbfd6e88df9ea878e1e800f903dafc0c23900f17f95fee03edf5970f13380d0b6322852c6868cc851d813cff7be3a89961c67c96549c3e62633b8a01feb33cf85cf4218683ca9baa271d2c27b938d9e89a1d391f7b946675fd4b0644de609ee8f610c9147fea55b4ca689c4ac69a3b4c6a6b99c1800dc7caf160a6a7c856ee6319094c5bc16bcfd50e8d034fa46abfb87f7e47ea67771d2b4246cc5f23ecfa78815b8ac58418317e07f157624c3c554a1a9d3a95767f3ee88524d5f4e2ad349ab9a9d6f8280d0e50a032766b8ac5801789e7f0ca4446e60ab636b7ef762921d38bdcf9ac0ae0cdf70c88c693e575cec5beba02ef7a8ae38be675a3cfd33b5921a89f49196afc7921752d710e3115e2c30708d7e1c56d9decc4e0cc4f3a330572355d8433f5aaf5c6736d996bf6fcdcdf64b8e647f0cb813c849d24ffdd8b2fbcebce91282211a3b4c3011ff89bf35552cbf2cd10cc6c49e4a6f5b43b7debcacf75a2fa6f12f8c0425a3aa79df31bf398a9dcd4d575dc9b9be7f50847479c2eb59d18ba12af14b3309765c1e07ac5ee69e6ebec4022b31476361bbeeaea91917c3045da6b120ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
