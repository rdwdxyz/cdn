<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f72f7d7c5780c374af9f01cbeefe1a4f76d7af6081fd9c5c8005f8c9b3dc95cbc69a2a8e809d7bb098b7d9aeac36cdacce6c04e3e730952d86b7dbd695b24eb8c181152efb6519be818b0e51c80ace755a3ee78f11a09f7aee1082dc8d032ecdc21e62f522bd255399d1d54c435574a66f8e59c53d0a8bd456ac9fbc134a9fe868d0917fc1cdac8407dc17badb00cb690b2e195e5de5fc90787e0d65ea80ac122cb90b22b4736574c5f9eeb9e4647e4412539abbd56e5efe317c882964682cfb2d48dca6b5e308a006cbaedf01e8adec8d20a9512dd3dfc66c7d16c97e71cedb8e60bc86989d7a9cf2b91437a3b1d933113bf7e920cdb6c57cc9366d2f25249a2587d988299f7928c6e082d2c4aeb787165f8dda4a4fd8e81a7aea50fdeee08ad1f6a7d76d04f4562577c9771d056bcdc416980a96349be1fa291cd664e301be7738d427bd83bbce0a3cc2d3d5b845c3028897b4ceddd46d1a80becbb237999e378a49ccfc9cbb849da1168b19aca2815390595e4ec4bc0a0d447a987695952034e8c5f80b5033c26a07beece41ec399d804355590a34e2b6d982ecd96565455ef0e8df1a225a4db5e8f29bd594a26d727810512a9b47a64ae7b66b967a1da9271aa6567e1c1e58534eb6b079521b39062903fbaa8b16e7d67f9f35fe2910d612ffef46529ae2f178ed5a5827fc9eca6cfef642952cc1bc740f41ff18bc9fe3ea37d16406ad5bc9570fb5691573b73c8c5a6aab7d284b720a7a7ce25b6a58753807a41b0919703dd0879ba4057d5c5d9b02dfc655040a188cddbb0b45b4e50e0d38f547f654fd9baf65172bb710b5a43944bf171e1e0e0afcd36430e88b20a51fd2bae56951c5492a9643a0a1274f9b7934edfa665ecff0d7180f0f78f8f419c8ed7a08c1a8975b68e3b7b4305537a6e9fb770f6a7d0bc37f61e01192dd894525913383563aef2ae30a52bafc61c8fddc8419a7f7e933b08df19e9d02ef4a152fc92a6c3a45a29d7c9937f464691867b484e70cc6d955900e89596646c09650763075527d408b25807b290130343d11c56fe7e7b0810dff7b05b547e354e87d044853f98ee75ee110a6e50e3bec54d59f6e58ae960d6d9d79e760b82b22552185673ec0769d0fe559611f3424ebd6af088e725737a745fb77a44c79e8146f5fe5a874af4a238cb8b070a951dbb8011f3b5294ca918ad1c047fe52c85e4b1147b0e32a0d99f28eec15c952477e01998b5f8aefe1129e9bdadfceeaa1cc2f7c30c207dfd2c5867b1c2008941defe895bfc17b2448d5db5d833f5b7bc17d7f4905a0101ca8c0c2f6d0c6b7e50f5c67cb47927e7d9616cd5cfb82a201fc5f05f2664bcd1f51407e2433cf372650e9eb3ab0eac39a48bf349f475054137c815355a7ef15a4fc8084f0b43d04ae54c15868eeb5d34a7cf254ed1f6332db4166aa51e8e10c1fdb81cc87489ed776d3aee88eedc72cba39dd6ed06ea07d2aeeb61765e3fd1b79407b69a701e790178c8ed28b915a2084dceb8f5ce96f5e23ebda0620b049e2edb6f53ce1e169c81eb5990896a0c2719a4b550f7c3302971e0ab09de083cc9e80f482c13c79d6ea82989c099be0afba4c79f5397b0d692c3f71da64db7be0678fa405514714fd6a7926e5f5844a1d1ac7a07ba77156143050b31fb75640a377e9ca2bcb54b38ce0d885946855ff3cf19aeb57f723d3e70b6b1b60b8d0e43d6a716aee056f8798b320f6fcf699293b42cce2b9ce9a4a0e74a020bf1aef508326b71489ed67028ebc6f87c1b2f8b8866f8c4c1f6315fb404bb41cd0c9b129a14648af4cccffae28d3495d10e05b1b4bc632eb45584244426d21b5968999076b5638a94638678c6a560671ccf35207fab8defcc4ea84edaace79385c2e5a5833da7353dc240f03d20dec1401dd9cee5ab6b9133b7227e1afeffa9cf129a93f0482f07dcde610050066e767e00d94da290e91c9d67b4d2ec966400deab6d2cfa904ddc492d5427d2b104b4ddd1b32c3b0e7dda28e9c79bac79cdfca3382b5ca262c2238dd26b6b180a37b2fc0d67e97d53046aadec4f9e9d6f00c833e8704d5f5b31dd653d18c196d2fddf0432031c28fad1d49faf69ad572cf92b56806ce3b7c124549e2292b1b0b6bdd01add72d3689ff43a8324e6520cc3efe5a19ec8e6c5473c57c1495d2baa0f41b05f7b7fcafdef474c0abb465168cd32c8b895912f07c97c55f326f9228b9cb61c67257a43c54c93391dee413c97773b558e0f3d20b743a736a4718b6fbcd47103776b6a4aa926962dda3b914ba4a5859520d7c0a8f53e1dd5c675136d5e4afd3d44130076a355476f3e5974520153d201625ba9031902a2301f0198ec17f7188062a5c0098e3ee5d0dbe22dd3710ec99c938969617927891575a014f9b7a760c5ee265fbcae800865ecfb66e599c178330c6d3819cca1127e3b6c61f770d4c3af09f2f0d7d313b8f96327079071faeacdf3a4cb5016df924eb0a110c4b21a6657fcf471551e5c27ea2d414d1d41edefc8c7cb39a0564f9a88d55d26a2fa0984d14bafb2f649560bcc0592ae4ac971973dce308e3afc5b01e7820e99ebe7530ce4ef7584c4ab93e59a3328be661c9335cb2d82b586f17e1fd68d65ab47c710c880017f00323c0d80fd37317c101b56694aa5d4226755022fc425c2fd509e74caa48d604a46950df9584fb0fe0cad7b73342751bebfec8e49ffb1fd56fede86247bda3a0222f988c8d30e3c7418bdf2c584d9d876c1f3fd2fe6ab32da0303116fa7222b1c295ad0ea5a0d28ca3eba56001489ccab7a6a0313269d32045e0f3fef2565649cc44efdbe5f6d407dc45aca5e998df7f3bd31880a52ec088245f16bf046e8edcac67671fae5b91e1bfdadc30d7d6a264103a6fcf85379c65e7510210ff8906322a48efcf70ea270f6e47dac15f390cd2cbd6d60654457657bcf2f046fa8ba84d44d1eebe1ae4a3e86ba8ec0b2dcbec5181eae11cc8845fae5d66ea23df5a979f7071161bb58605b5f196b167b3d05a235f7446062a539d7f0c8b614ea372f02e6fa5d49eb4210ffe3cddd4398ffdd873009f652df91b422cc798f3c471897c94c474d5f50421881ad8bfe4e191758bc5598b3a4699740085c96c1cbde898cddeac8bcbac3840792c04c6d03da39447f8e0896f9241c1a11ebed63b8d475ce49c345c6769f666e16a8363a0c7e6beb7a64cd2351ef7e49bd4502ecd89e85b727c4713f80c23ef10423e9ab29c385d772475ee05f52c6ca263783d753143d3f5b7e7e03c229526703af0c3487409ab27d64654d61818afeaf4b30dd07d4e8ade587e117d00f459fde797ca2b523363a09cc25ea9478628164c79bae2d43368d0723b97cbef3c809459ce7ec3de539e118f42410a39bc6d3ab0c0ada5532128e97cf34d0c4514554665f2e180a8d4c7dcdad2ebb2c47b7d4f69c96c1eeb466f98b96946b8c056c050e3c103df8b41ef8cabeb4d13fe5597e2071b46843141a786824470144ac981480634a4f9fbe10aebe4cefd010d113e060fa6aad7a71f6fc1c58122173db90f03c31511d88deab2e2b7ce295d36d598fa8ce17d1609108ffefe5e2a46b4aa47d0e5e387949ba44c750d42a9b349747a3c12ce6bdbbe7915555c257d6ae8e3a4bfd7d6128f8aab51a3cd7bbdcc5319193f1b399381db2d7413d946ed4b6ffb43dd78f1e591faa9ae501fe8b9700539118b3688b597febb2997f5eb17a193072c1ebe3ad445db2d0c9e23c744175a2675f9160331eaa4b0e876f76ed00aa86d9dc177628434d7c4982091f21794e3ded90c7853757568c79a6bc96e269a7234120620b4f05a1302175effb8613393bee6baff07d649f9a03843b7207b135b3fddbd42c5d8dbe299577e04692dcc5e85f266ddc817d72e2c9822533fc017127ff9093dda9ee2af51d2dbb4c2abd6e9e328a304f32b5edf8a4a6206bf979aec6f32bbe077797b3c3f940a70c98f924a734fbf42e4c8038c495b580b53956b58ec38c82e28a92c8375b76446c587a0420f00b75084af280a0f46895acaa373965132d251c8ad28db6bdb11b2e3845c7a05381f47e3707ae96ec63e0f0735ac4d53b494486d11c0f595b541d6d3840fcfc525e1e652ad1ab1c8a49695e0d12fe85ef37c66c5f4fcb7d576dda7f421d2a900078558a4c3fe1beca17556aeab0a2f2c5758f6ce342a0790a968ce59c77113bfca9853c2ad6203903c84cf3d3009ab34c58b7d2f1c2a5c30a80677afec897d0eef5e679cdf19b314f2af4bec4645d7b47fbfa36981dc28c0aea2fdf3296a2441467d8f32e647a9c117e8539b4446643b12ee849a9dca3ac307be5ba35adfebea13e009cf108fe6d49344137cd3d3a827de32073910adeeae64ac297959544eca16b47615f328b1c24a5f33052dc2668139383520632af6b1671e077a4ad95e0416b05b79d8496eb4548b244852073358bcea583b6c80aef0f1e113ae44c4bb73bc0c20efb5aa3a896303e5e77e169c1b5f4e5cd19f6746d89e1c037683326f11aea5bf298a6a7a0fe1df3eb3fd648ee3195a0197f75be34cabf556e1d656f1b4c9988d35364fb04ed891e3609ab827013dfd0e3410201eac1b6a6676d1d9c523350196177b6b48d364cb2b6f028668d00cf6feb0e66354647a746035cfd087a0f0da18c514850803730829b6028ef3e543749caaab02d065e20d9dcaa05aec91175aec4c3a5d1a715c3338107c900cc26ad317080f64b97d9fdfe811ccee6bfb50c7e6125be6534405599b3c9d42a4fca5541c5dbd0f6071da3ebdbd4a1da159d6c07d42ac5fb6b795dfe7c619651ec7dc80a750abd968a965543dfffdde6546a40f9050edfa704ac213ee3f10cc41d342ec42103817aa121c407d9a35144d48f2c07a8bfa80e947840bd101d9f35e33395322c9690bf293125ddb89a1345ac2233b54f500ddf52f1c0e3c81c095d2185631c5892eddd1b7edb18ba75e10de85019157a22b0205dc062684c941c53513345aa1018716423d011a36832ca0f5469a0561e9c1df8c3d0c901a02d58b5a0e7646406866d6dab41566d8d2035d54dd64c85a36376f33003dc45a3d2bb4d11b1b59104c41416d1742df511e8190db1a82a66ad0ab69164424721fff72e9846f8aa5401330d94555041ead11d653fc748d73d051ed7538134ab2b78aee14f60b930343c08beb842ee8efd56277605a4e0448e6119c35b3dfa14c926105b6f85a73a424a7e72b783d588e306bf1d4730e219bbf56432fcf87edf57c7aff5a9f8065012f5e4148ea40a48a3dce0d3c0e6360a2d6b7b0d8d4d40c4a7033db649a5fbf68802d21153065ff8eee6f7db8b041a07403fde44614fe884922f9d1e13008f11d06e4779fd489fd0ce242f1c93db1a53f5832b6b11a93d0ce17ba46dac0884630b61004fd13c4ecff4c2d070ccad8bc27b7b47d3537b77623ba4d28d7cbc6d4f3a01ddb0d8e80380f168a11a4809e199cf125abb9e87e0f93dec4b76d6c4e1ffd49c1abd6ebe4af2d284b3505ec3fe028ed207500c5d9ab47f21ae6e63fd32d5e71965edc7e10a8571851ecf42e03d0a09744383f3d458d2dc4869f65448db63d431ac4611489f4d2b18ff46b36db80f52fff3ea4f6181623eaabcfee156f1d96a06fcbcbe7acf8f8863ffc16fe37a4a70aea187049ab3f40fad8a41c6265a7ae7ba7bfa9eab1b7f987b90fc1e01e49f7103c62895d5e709f803356c0bfac293999f56eedad3e5aa894b51e11314f47d47e244e201fba79e54b7bc4258f52850bc040033e07b0e5717500b64ba7fe91d7901049d11733e318515fb5e34e0d943074719a53c4828d1daea8425d5724d44c7f0013859f0e4054e509d4df40b410272281188b7c984cef88269161b21202a311f2fa441a748c6891a51c7422bc3a8f66c5135f89f8b6036f43d6ff69880d8731c9d0b102ece9b673500961099e25cb911fa012bbea83d2f8d5e2b17aed0ced74a466deb59475dfaedd2947ce4f587ec91926c30c595b878b5ecabd9c25dc06ffa358e85ab36ee01b4b322c8cfd5008115546a1baeceab73e06b3c2006da67fd0637c395647e8d523d7b0d426a129e2653f6570d42d276f271ac1e120ff4bddf67b5cd86fa3b846ce90b5a8a938fb3173fd30e8697eaad5a118eb62238b714678e3b20ae7a44a5be8ac69abcdac7a622e96e8a24f5532da01943b6c70791d5ef65de6c831fef3b87eec502eededd557a5e74246e4ec7f68884829f1a87fa598172aa614fdbaf83097ef12c4fdfffb88510850ea15d9327cf6706944331b1759b7cb9af3361ba6647ba7183bb9be28f7edc9f949881f8c7453966e069e2e872f85f4749c7d3ba77e3ad8fffca9497aeb9a7067d0a638598c862e6f43fcf240acc8c21f76e89c07efb3fdd28c6fe6c26149d5d4da61b93590330aa565946c07aad664379c30ae9768d62b798e278908b70238d51ffb929a73950f07d7f1e0a22c0eb6308e5f457e676efec98c1eca67826978141c7be09bca9ed5ae62164d2231935cdeca49893f7a84f74e7dbee557984827352c88fea0e7b159b0085a67c399e4bedee9f8d324935e81c26751589e711d49d94d56fba86d30d27da61755412894e20bfcc0c9656c166cea31623d044d6826562e48d16440b9977e0701a4642425e0baf66c571fad7520802d00ff3b5ba12f4b35c140666646ed10be19c9778f03dbbcdd43b3f09f6b9d0948a9d81444a95d3afb1d869adfa0080e8a0205ef2d8e3fce148b6e0813af8c08f85bc3296fac1b89e6d423745a90b2e116811ba238e011e87c16412d1bca22aa741f451119262a25f8fcb65965b8c2b0eb495132d6e5eb74e9b87995aebeb7f65633a9f8abdab89ec919a8b9aa0f07de861497c1051b63374d55a21e17582d1321c37c52705a8d17d0d836d91fab4706d2de50c8150b463e0c6d3161d2324aa630dd5a3d22c694eacd9edbc6ebe845e894f55a1ae3fe85490f0ed430e6a20076b20dca380d9324235341687329997ce235584da589d78b3f8c345619886ef8c47f08c7159c1520668fc5a6cae98b9d8212878c2208ad9a7a8ccbc11003c79ccbbe26a8297ffc12fd89cbdefc37f0ae069fdd6149dc0f14eb092949348e9f1389470b8ffa058d87516579f9c51147cb6a94ae81e364f14ddacbb3d9d7a6a37d714eb1a13e89a439ae1698a84fafd3374e6a1691ad3fb2bebbf6faeebb6bc48054b5179d118adbad39de5328b8fa5bebef5bd0bb68d9f78fac21a887b57c9be69b995f1e9d2e4d9032a3b4127f84184e587c8dfafb670d9941c820298dca9b3e5c7fdb6e62c6f29f413845c5e3220704669e98a8c70fc9aad249f89de8b990c519599513b7d97ba7a163b0cdb6a44b9bfc0b521ba73cfdff5e273d2f221d294ccc5d00131462b967902f7bb3c8ac3fd50aa123aadc1d14930fd4ff311a9cdd042584585ee6c90ccbf49833879edd4af0f8029b4411a7737d37079029a19a10fcaa4c5d15a3c48c4324db7889a0210e78f4d0d2f084556aed928b9afaedaff9dfa609c0cfbc451a5b904a77ede938b1c90973ec2cab6abe2d0144b62d69ded94b4a777ed685a1f612ae1411604ae15ceb33cebe9f0037610922cc42024d36ede2dc8edc10431951f66f6739c5ab903df58b7b957d9e5d80f49e5257a977a7c90d67b398671fac4ccc5d96aed1f0b30058c2eca402c9342e36c7d86bbf46f7c0254044644441de6b87bab08dacd1dbc00291fd53fbeaac32fb1b27a0ec3f21aed50ab7420ee2c503545cabb210dd0a6d73cee5dd5a37296556e5e315a491fe84c76a0d11fec67415959e7d875c08bb8e1460559d95d07ba62eaffeba33edc0f9410bf8b1693be2177689e554aefe3f0d354cf800feba694bc5cfdafd27393830bac0e4b643a88c16721017def395901147e78b7d54f893179f86847919231978634d0caf60550db21809d4c69a4d8febaa01b7dc096e5c00e465957054f1ebf9c053382976186a4dd0ae83aef728c805ffe6613ed22d84fc45e5b28bcafb58180c71537bf06f0cdbfa4261c044a234badc9e7be74c34412956661d969d0b952dca4a657e7d82bc95c52c8adebbca975dcc59803f7566860d765a2bb7e9bc4243e8bf883a5fd3df0e7ae6d52204cd515b6b5c8e900f430c98961c27e50d10d5a84cf90ddfbae460f7c591ded9404e2876b3176295b9b20ce45f3ccd6ac61a41b8afcf9900c01d0524822249b3dc430368f360c087a16c029b0bc26d766770cfcdc42e35af58b4b1070be81ccfd7ef432353f1753dd749779e603bc02e70d0397eb8aeab1566179c1eb0dbfe5de6b44e8705e09a529500535d09aa63726af83dfac184100b54e6db5c2afcfa896a6e5f4fa6359c6b4837b98bbf5c3cb335ed72d0c23a0625592018c7a049000a079430564b6a50167c091bad4957d83645f525359d03ade8f27b73a9d2f353cc5b6f17e882160bd2ae67aeddb052d6b9746fce431051564236ec2d9613507bcacddf5f836b79e4890ae590e8216769bde7fc7e87f8d8e80c97d182b90da42f158f2d7524a5761c855f095d5b6c8c03bdda14181ffcacda3e8d14009ad2f48212460d79002bf84d10b9a1aa59cc2791b739d4e7aa3ca344a3369f5ab3ac22cf6e18fd11b53cac41e866f51ef1da9761d105ee46686bcaee948ca012b7fedd8e05ae6271c7aa603d9ece313d5d208b24f9ec8ba35db775b023ae1c0e30a3034640064dcc1421a61ef66e1591d0a8205b03d86c3594224c02765b6596dfe2598c13cbb1e18aab4cd26e7a0beceb91e14236ee53a4bd6bc451d2ecc918dcdfe64b32de0f872e9a769b423cf9fea5a93376078e254efec428eae45d53168d9a39d841ae2192787d7658d22f210208509e90b021fa1500cf54c03424836bdb64af712b893c6112199a7b51d65f18ae48766e6382266462b137be5a784671430668188b844ea7cbd323a39485b10e79d8e25966cabc0dd1e7df1f3f3023cbad0b2b800a20457800ba1e88d7ac4cbbdaedc6b2d287d92b747c41646283879ee223d9eead33b081253d429c1b7f5f631e2243bc0311994bba57e3f45012f2d08c2889a13197d83d9aef89537b4bf37a334f62ee2c3eabb53d9654b2ad4aba25fbf87c96db5bfe3eddbb06dbf9ad8a107b0b7780263d239d84c8c6da0ac84bb4abbbccbcfb571447904dcc9e7ebeb6713e77c351d5e1103f3916928d2bbf2b033090a7da95e90acf48593178ac99369b158d199b75060b848e1156dce3fb83c48d655aed383b726c19e7e9c94a2e1a2127ed13651b9788881ffe15e661d6498ec37c6142a09c1848e71fae06acf0eb188d403d9500f6e2e58d75fa75c7074b172472dc78b75cc6b250d2eaa5860ab322b436deee83eafd4462f7155d70dbfafae8ee1e6862b62e27bc3429697d2fda3321df87f54f4046e099419352223cd58cdc35a9bee5ef7872fde56f241bdbe9b3d367070e1e492228195bc0aefc4ab841c14f10c625ba02e632d5cba4dd6ccb12980c2cdd3717371f96587abf9fedaf869e7abe367f83ece28a1a8c9d7868b99409cfdf9640fb411fe56441ec46e78ea4b237ab08066a7685d1731b137f3cbbd70bc7126cb4d65274b490a1b437d46e008cbda4186c9bc541c63af867f9b06db20d22b020cf0a6e8fb07ea0dc76699f1798ae6246ccc29c616db0706202656a68a0bb944f7c61a687569923fea74cd5d110dedee2fc6defddd0dbf5d9a3ea2fbe4e9405f78ef035e0d02f87a277c0eddbd081bd84f58b8b9c57c245d203b6de30395aa8e7121cd4682924d5d91cf91f9900f38bac3347571b953cb04cbaafca75eb8299054d3a536983fe73fae13a8798c9128dfceb74b52d8af02b9ed3c6c5a48b06385e74ed3d1b54767e931e43b05b2ef2166baba384e699936993307e1426290a55e172c113944bcb564da00563d09c3051185f7f40d48253ed32c175b6148e6aa60e8cb90ff20e02a5bbff672bcb089a4376840364c260db45376652c86da6e8744c270cc5e32c148c888ce2b3d28cdbeb5588925b8673d8f06a832dd50f203cbfbfcd7fb96e206047dc4239e349786055213489e406cc3e6e2ba831de8ce27cdf1b7d12771bd3a69802809efaf92ef7526194d7c4b07576b64ad9c4ef6be56f6aa115997670b0293458b12a902ca887c47c3ba4bc10dcf6c3c86c66f24c07234e9353ab63eb71047e2501f01c3e9c9e858610012f3ec5ef75e6ea91a513176449530ff3011ad067592a7cbaa6e5c8ca868238a307a8aabea6affbf58fc8f9ff903f76d1d25b6576ab4355cd16faa9914cda389aa8e88f3a91f4047fb5db57d060a7892cd7f045a127feda5ae37a11033412ed6cf778c5e00469c8c04c40faab89496e8b5caace18581b6a510396a8e41fd51a5f535ba96f8bde38a71757f75eb3fcfd7211da858b7001ee0c95a475b6d4bd01ac946c8729bcae749549c0142dd307de38ace4300718ac3aa2ffc46910e272b46ea171951d10fd4dd5a4312040828103022e4703d9cb0f068eecb33a2e92f9b05ceaf6600b4d4865288ea37047003754b2da3a12f444e52a48890bf6ff61338c17e3d4fdaa509d9a97ef7ca16385691b88d6031909c00b3b61fe2a0b4354c9a4d137beb63b533bc4aa750fb0e08fc6ea37a1120d571809f6ed93f594689e9a43a8236c15fbd6cc504bed9b2f2c8c1a5b6f99f21725fa56f416a0b25c1fa6190f2d4c282c77da883a49d74834f7f2900b0d75ba46db85210b348f796081d1b38cc404f77a19831763c7b612db7a0370aac60525e69dfe19a336a6242688fedadd5879a802ba054efe394a7d305c56a8a285703d4b409610dd856f93f4ac2ef93e139ae07057ac8de366df58731db7653bc4d692c9b48986c4556c2e45620ba304993a05e1853b65d4e661624ec680862cf1bf4f1c744f7d1d0487e5209f441bb272d0da8882c76131c3dc0082ffd9428d7ee5c0e1def4a19dfd5f77b0882f13255163079393d0838860bbdcc1615f64aba3e98388d97969e1e35ffbbadeac759ed54d56a860eee15b91e276d490b9ae0185dafc8b790fd342feda0a3777f75926d0d63eedf386a31f28f66ed1542b319970df39058aa3e597b8080f2a7e0c6c4a1b3a4a0bfc0789084cfd909873459dfd6b2e45ff0d77c7ddefddf5faa1e7429b0c54ae4ad74f97b33e297dd3aab808979d2745879ae7b4aa08649d6be1290f2ac836ef5b0c7155f5b7c0655ce65bf55227d6589d5353771ce1b53323ca1b06df2ae8a6cbbf6cc316d9704ecef29bd65b70b5f6f7702a1fb29eed81c18f0efe79f47ef7cf7fa788951ec86e9ee92a03165e812044f021fde4e706fdd7306e73f94cb6b133f558c812ae7d3336341e6b4030d69a2721b92ce85db1b4c33b394099556fa46c1da5ed48042e67cc54cf2942a4bd2af0b63a5928b715fd9a2bce6712edcb37a5b410eb7383cb7440bc771f5ffb40daef7240389695462f722aee052203bdc87f7695e12b0df08a456a2b3f9706574be7fe4420940df91d5498d11e41de729a3e50a5cf592af1862cca88c2dcafd5dbf416acc081ea81add730e3939901669cc0fc2d10d7867e45503d6a75ad4752c2c2f7836c3e93adc9c10a48a939791a398b43a80d67a3b0d8a149d97fce2e927c134e7a783703f1a625f006acdc871c8b4adca6945927819cec9a238f96e3b25e6f0051c1c32ea54c7dbf3f75197f37beeca751de7c47ce66210ac2a952f62f6c3c389568792ce49afeb7ae2acbaeaac11bb7eaa01fee26be613254b2c08c8bfcdb04d6856caab0027adf7599829f541dc496a3397eb165f25eb4f2319d4fb5957547f647235fc01c166523de684353f5e344d8505a6d7a104d569c809a7fca097b10e7a6088374b5432d0d0eb576b8d843e2d6a227da4355bef7383d1f045d2bdd6480a7daa679b7109c0d6901d5a07960235e12d08b389bdad8b89836c31a0b2ed98abec88503133e22a675867b2b6ea6df1639e7c13e6b6eab07dd7d988f8774478c058f4d53a84f0a270d86fee462a6de161961ea99ab6aa43a15a945f33bd12db893e4b0bfc6118ddd4f5aab39881992501114652a1ac1b046d390d783b0260e30cd563a202878aa2960cd6756dd7e6c50c9b96e4c6df380218636a3145fe0eaabecc6c2cb355bbda4b317d9234be8918de5bf9ebd00f19fa57815a8fe640d8e6f4a6c9e662be826e9deea2de8de00669ab36469b0982ef1ee63c5cf8cb46bde9e2e39b092a0c4b2771052bf63311df53f73ea0ce9993178454d67f9ba87de86361ead3f670cfa15e9368d23425125eec6b8d552bf8301e6acd1620e3948604d71545180b729966e2d2f1d2758032c3cbec47337a3e18ae77ba7e371c5b60604042fd15f1f04d709c6babb6cd50aad10e0e533d2e5b052e509aef30cefa644a54c887be8f775f6b497c56dfd690291aff0f21708b9c916c891d9dffc56b6e73c68a67c341b525e53c4350dd9424f43f8848f1c54584cfa61647175444fcc57dff1c24a7ab4e04629a7b5c1907dff0b6558444b0e44290850b699df1599478b5951cbcfb0a14b5c1fb5a30df680907197da9d5ec32ac6bb5e931ce2155be0c9ce77a531e393a79da3cac1b69605f7ba8c512d0a826d793e222dafd4e69e8e3bf16bc2c1a51167e0ff5cc803ac5c0f7bb32664d2f1a66ebae75e7b9f6a69bf7f90dd19b2959ad02c3a3496381a3448d502ec7112feaaba2460b0c53ecc969b527d46dd84a20640c4626985836ffdb296cd41b08172c3721bac0d17cd37b0eb5a2740863cc7fdc90b671579e73eb12835d966e6ab2be7f7299d712ea493952fe5b4201dabd3a534f6535692285c31081d8d4727f90ae11458101cea63bfbb758e7dc3ffba91f207c50fe695edd52e511aa3096cc52fad591abe5b396c81980f6bc5305c7c33317fd0e5c4c6e2138636f2bad3eb95a8395f7b671180b91b7ff0aa3715df179e5d4319125c9047a4a736cfff01acbc7773389a35c03f365d48e257af55343b505f3256c3c5fd508ef6509d1338069beafd914caf215cd88766626af20aef41821b834fd3aed2118722725e5ae67d986ab67f8004efe3c05f094d92d4564b120bcee77099b75abc2c265d9f738fbaf937b8f37a3b15a26ddb86d9bb405501242b4f1940341ee3c105dd16599b86e53d4daaad05a2e552a34e18d23f9c0f3a3c76596a32d624b8813fa483402c3223d3818e3e340e46d30058c7aff92fc4f68a6f57cef78786086902627ec72dad612bfd46f43056a23fede47f42d6120d388aca3c2f798b3069213c1a6588bcc2f79f5a79c34b8e560841785e0cc59e50e3268c1ba4043f873e5f28271d5f132c3f282e399c3a11467140f4eaee86858d3ca7f438707af6dbdfbe2631ffead5bf59c97c272fae8417950fe646eb64a0639fe022ee6ccc44d4f62acaf3c75bd2ca366a827dbef6a1b25aa9363485497a5033d0fa3eef76b051b09ab570020a0d4fff1c201eadf6f7464abc92e6e0da2272c89998ab2e3f8dabcabdf88783568d3d8d556bb08e204156a44bd236a32a70b9cb737b025625d07938016dfbea93667b45f44f5964fd5563e62b9a642f7ac29b8cd4125eb9f1f5737baadee8a543d85c43b0d693516da3e82318972cdef60b66b87cc548a697ae2d3c0acdc187aa1f9a2aad54cf6f1611a0ddf9f330eb33a0ead94826fbdea16dea6bcda583912f0a26cbceb8dea886f0ad1d71731c1a4c34993540cb8c318a7c944588006d1dd22b5de26191fedcbd65853d3116e2a048d2960ab9fb5d67b0b33e36ee0b9370f3a1460332436568b06e42e3c51a6d7765b1fb44bf5286f996b1c86837e1ef6ab224762cab55181391e0c8ad0c2dc17e14b0655d94e8402466cbdb7da79a29fd0dfeb0bc928ed2dc6bce5f5dda200ce137e632e9ffacee78385c3ded5b97711a90898be8968503b65d467d6b1e01404e03d6e35c968a990a32f40a7ceb65363382fce99805640fea70ef5562b8f6d1cdb6e69f64d416c7e4cdf2376e62f452928ec87ada7fd1df88cca9a4bea75548646ffde163ee721689c4948bc7fdce29d379c8f5430f76995907245fef994a8be732c9c0b9ec9ac58e48fb4c6ddc013fa76cab27fcb4131d1ff334d167976634d1ede36078b1f32a5b69223799c7879026643485494d797757f3d684ba1311fa68f1852a6ea8e7be2a525a57a672d5c72cf6185a4b716ffa4e04f596a8f3d0a3164df4a8024c95524fb8a3b224b54beb1b3c6238920ea88003315dcf04d0e46490046957dac9d435c9c920eb8a058d90464c474bcf2d1566b16444956e9b16f21ee5a2e9e54a081b3b63f8ec9c5b73d205df51538dbce0d8ab9616e5c7e5e33179eacd763244f2c3b0d78090d1e662fea29f111394749f5c0a149d1a6c420249502df2fb1f7954d92eb0ee1e5d7d0af954d35d9d125cfafc9a2f9f58168055b5c1266c4368de1fc93331f01bcb20d3888eafe82da05b877bd26f5c9bf33084e86f1d289707655cda895d170d31137be0082512d4f55c82f7191ada442ebc080a29e4b108325fd8a2ee84644a55143ecc5fe42e0a676d4b49798e4edb712a709eec68a7ff21b5e90d039170174dd9f2be656205287d4f69b7046e63044ce6281e5416711d951a194a0d79d41067e4fcb29d427eb510fbd6b69c27646fe9028085e797e4a9cf6e299bd18519ce3242e5d8cd7b2e7bfc699575fc67dcef72344bd1374dbaed76b98a6ea9175299254dbdd2eb6112d0b9d43921c58f175633c6dc969370fbba28c64188c91585fb060b31d2ce2084531a8e0b541db8aef4d1d19f1fe5babdf46fa9791d6ef9fc5d2e9b68378270ba97fd12f02590ac4cd7bc6340d8465807a538d23ef8901d6e15e0fd96c0d942d61ae601defbe23e41cf0ba2184694879b64d3d87b092c70f24ce1258f8c9a08fa1f80a745508e5af1798bff5a1507586ac0eb43bcc3d189425de3e571e70ef5ec0ce4cbf6ff31f736c7de343449c5699ed9be1274a0247a789ccc842c9bddf32b9441cf5ceb04a7e1465e5886d80ffdf1218392fc792a3de951e2eb08eaeba6d067de4d82234dae1594c9156a4d0974f1cff728d7a92e1d7ad561c481bf82a275426e9709040dda74c61a9372687a53dd37c302923f8280053d0f3ab1c7a3f5c7ce1bae80d600fc8e2233bf8e6c04ac7d47069642dd1f95c9407398a3db714f91c4e937616c44845c07d083e961e872978c2bd419cca2f507733fcd6ced68f9b36547165b8fab813499b7b5b33d193ab9bd4d11639d807d0755d5a0eab7293b334031802130d4f1ade251a59475c186fa9cfad29295256e6f23cc153b529702232d3a5335aff87ed3df0858370b0a877c4d4bd954a01792ed59b9fad23f73c2eb9e664f9327d4ae38f9fd87a86b21210333677e3865ee0843da28904ec64eb0aa83b15b2307215cbd40c84a653f2e3d23377b27f7a6e0785e84fc235df8a3ed98e5ca3d24fa356737dbd92964824c818cb13234f79d97734ccf1f96a7b7f68c4e4afc5e576946650e16910024dd7c24dc6e67911b0de39607d1a00163875baf890d42ab67b853aad625fca98e2dbb574340190fc62d37a8bc64549cf437a5ea1dca1771f368a919053c8de3df821dd10284bd56e0c2a22eebbcafc6e983d4d1522c6d566f39866b21284bc152e71802ec933814318e7d148e41d9b89434415a40f1e47d9ee4b5cd6ac1c81d2e7b8d3fc200f06a2cc9e34a534ae0ec6dba3b92aa66fee6106993821da433ca86af0fd404147d2219bee2ae904e0b71012f691731d9dc3614ab7965474d33b14e9c678ef3052989ed40f8a83a30a3983a42ad16a9f3133c730534e0f34bee266ea3285b0b90eae64ac9e9a6c3c55df1cad482270f1a05a7c5a7a585d5de987ae369bf1a50c7a7c6afe2483fbf2a4299a1fb5aa6dd38f9c67b642e80977e03504497eb4e813758610cce7599d91dfecc81263a77b668c456b8f414f1778b80c47b5635cde0197d9bf74c12f065c25808d188d1788ab6ea81266a54be6936ab5ac309036bacf00aa438325d3f0a1ce721ddf99ac0c1ce3c3e0ca312e2e40f35c75081d14730a64f4b471647dd8f9490579f648e6dfae158ad4fe67686a3487a55ee2c0363af17c6773b2751edfe8158610c3ce7d278f615bf5c23ead8ae65f3df48f1dfea9be760b8b6018e1ca63f56a65a1dd7798f7bd549a0a2e5330138b9bdd42f0c3c10941682c6714c55410f325f9f0da8b66a1a82f75dd62e987416687ff96e74ecdcca3de157ec0d43ea89df5978779819f759a4910733953ef0d4983843c390131c4caf6fe13e2dd25de425d3c034719f09b086638bba4ab7a5312773af00183546f71dc060e28bdef8442f5e16affcd2f7f8bd32ee9ce04e4c0b2ed405a7f33b70ca93db79e66980e062d7a91561aa36cb874d680e844e958566da7a3338a465daa8abf31482051c90a58dd3421af6745222a284a99555950d36382bcd3d9dfb4d7daeeed0d9cebf0301bc6d0b892c6a328af89af14e698345f58939df319022a6e3c5a757b1ec79d8bbb89b1ac648d2d37601ede5b568b46ae32b544bb20c44c81eae2a4c7948face705fa2a3c81982d31e28c4a3e80fc68316ba2b22e6637404300ecb9de6b570170749676755bb2b037b36c00bf2ff087f9af338f77dec04c625b0d243792ad9f139f73458463c7a3480d35bb815e448cdccaa500c926cb9b7eb2a77f3827cd5b2b0d0a61527d40636850f598a98eb3af8dd27da075255c594e6e23981b62c2add5a89019bd002f4f9c0b4aae7397ff660ffa3ed9447f615e66f816ef177bedad2fabed56005a5e5cd04fb287fbd04ff36d9fc4463e651f20b9641fc3733d32c18067b6429078181f1681b43b38436947835db03c4f362f1710bc9a887f84a02b8331a932e87e46b38993caa0b36c5fecec4c69e9a197599a7eb7d73421bfcbc54bea97244d3a91abc7164fb76f4c31f133c3af3006a059dc08708228e9ded2d0dcd6dad084abf3d57b50cfdfbc412782ac56792e20f1f6e02851318cc975e236f22565a37c5dc0dc16aed62dde51433daf400e30b03317b3a587fb3d3dc7e5ad704bbd7708f6cf1cc1fe59844ec6471e7635ac13c423cee762dea8f56c31a3768e362465218b83ebed56a2b76dc7cb0ca3897f67296e7d1db643c3cc19e16df2f3e573a289ee3459c4ada6a5bc8c0fc5e93357ac42763661a455832133759d74dac8d31849095fdb48e3314e94afa0833e84c3feeeb46608f81d84ab0336f87d146c118ffc818928b35b14517e25f2ab56e6002df3a892f42a2f39515580184a85dec559263bf30000ea4b9ef412de57c9655ce2517b42a34f20753fda0f557cb73f1c8f2cacbf025e3b46baaaaf4ae2ae68c5a65a5ce3f2d4342ff6c8ea87b1c1089dedce92c510405b345338a37289c061d5e5c1c821e77655651ac47172d03f81d800915077d9e8ce6f0a18f7756eaa4432706f9d90b65306414b89ff651338b7f6345309f6adc55efe10a60d788ac55934c18ab63aaf5bcf7e27544a27c6d87a08421e209427b4d17d8b3e2de464c00e226227d9e0833550511dff768940d8c85652ec72dd8493fba3c9fec8ff7d66b8f1e15754c66c8c9effed97c4d25cca6fa5e50acbd5befcf4f39afe9ae43aeefb569812b4ea194e52f175e6ddddfeb41b2eff9a49d61b0cdaccfe67a0238dc03b10507ec68c06061573f3406bc5d9212bbe59a5c1908d49736b49fb96df08b0ad5a9e6be4d03ebd08da785801cc316f79da79d3d9cdc5406265707c392869b709c70d6be9d1f6dc376332038ddc988b5d9ac4cb08248e6d19d473f2ce65c8d1df519bb0921079886b0ceccbe7e351a296cb95d5285201effbe39bafed12ca5c5fec11cfbc143b36a25b599613d416c6e223220eae71dd694a05927f0de1bac4c85a40fb8b063e57c8e5f824c90196106df77343f8d9084335db82e9106defd7c53cb7bd09b4bf3555c92b021a1bb23760eb4f0edf864f136","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
