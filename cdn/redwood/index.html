<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6808e7593a1fbf1ce57fa20fdda9ac799df19e0e1c16984cb66c6b3fda69c296b2227bf5ced1536f407914bfbddd74cba1d471476fad3e960a3a2ee20d7c72e44dc16b08151014327e62e8b365b82b5d6d300d8f54efa9b0bdaeeec5d4d6321f4de9fc71c191e7bb8b61e17f71075bd55395ddb9e9ca2730a9ac10fd481bb4bbf192a5e1fe16dc177eeededf2300219cf04d44ac74500ee12b3996a15ab836a7df428e24aaeab1b83727aca5803dc24d13bbca9a7173a9c8906e4fba72e19a651bc394e1697d402ad6cd77ba9804994e5d33374fffcbdf318d2598bdbbc774659ca7544d29a3413bc2e11ee0d791b99138cb9cc0bf5aafee2ec7c5f7e5e3904cf377f03c45a03c94b4650658ce28cc145711c8c85e8d7ed0870e7a21e299092819c7c44f08080fed63a24bf09043ce60aa67956e756d7cf1e7f42326326656dd7cadf1b2e9432a3e83303c929d74859e4f5b62b43da98b9e01230824befaf3318b32e74fb109234df16dde5b51982b114b1ebf20530a6af8b8178756e6931c04129211677819dd5551da1279c1ec3a81c7eb209910ca99f1ef3f97e1575c57a5294680485f6384601500e11351b652f2f5c1d305f7387033a254abdffb28d3573051d0bd8553fa26f9f708ec7df1c623a033dd0b141d590fa5cabe6568c288a880b9428f8b92528f55c0b42badadffaa25a7a8013b9299a7bcf170acadb944fab34829e10210c48e83d61c31d2823766194f4c801ba060e901a7195758f6a266433ee2e50274d730047197a208effea9c8725f0178027bb4c6a4af03d08b4ebee3c94f944065f4a1eea139cefe1131879125532156a097883ffa52eaa7fbf42daa3644c5701eac250cad1badbcd02cd76cbf30e692bf97fdc0e82cdeb57bc74121c5777089fd06f21bd5363d90e5f8847c5ddba21b03a3689f61c157df649f91bc35a2259fdc44ca66813441209c043d45655b6d52067f7de6ac8a1fb166ef0f55ea4f83499d4812e30f95d21e3e6c46e5793d4948e7eb439e72c5efb905c5f9b7695c531fe97b9a294ac6d5b6ea59328270a41e891804e69b22f4c5ed4e0e8b9c17a3e81c1340c1c015ee0ea4dd29c322aeb9fc93ba6a2c6bed8f385300582de394604030a4f5232d9c7286e52760224aa61e04c2e8fd3e5dba63bdd620b3022257bc464e28c335adc7173f22807f4b6a0e1274201474c2d70375eb41369661ae22981c3ee0152488c5b2c7a01c5f83d2b03a976adc0bf030eccad65cdf25d55f20cc179e6ce374851cadf0208595717c76b5e3959b94039b82d79eb55ca8245bf64e6b99da134e9791a26c1b741a19c1d4a0fdb63c422266bfdd815fdd3a86eec46ff7a16d786fd841ec62f1e613b9bf66b3a5aba5bda5b9456ff3c7ac28221fe25be03d0cfc71e9bfa99808d8f366463b03d7272754e5ddd555750cbfc4350892ac950ea010670b5866cf291cd15f2e6864f8a9ebef35ee3c592b2e6135f99a8503a48e93939560a1034372145f6fb770c913641e04b1403e69e13ff68845279adb5af9132216a9c77a3f3b6f64c39c9de15468422a0c8efff3f0946eefcf611123b8c2c55902fe7455adbca118b87e633e26e33677464dcaf59da5a0133d744a261d3452ba7c03f78a4d9c21c25e358bb70275490868363042315ca22e6e773b9981384a23facf239b8d7c94b09a0054c19f9205e9deb48f9b915d3f1b79f53219dec87c0fa356e8a0eef5662fdd112da1068c09e9a601f4e527271ace7507abb7d316efaa20417da8637fc61e76725e72940dab1db33e5d37d3f44c26e8140eb128f523cb970efa04b4d6a70a568d33b280e84e8624292c6ac6968658f403471b038025a376e2ce0ba6d96878a322098d944174d8e4222857bfaef95a952af0201842ae041b87140f7434fa926651351dd5d2db139813b4ca70847675aee420bcb6f56fd3eab6382f30957a06b1fddf990b8e62f377468902c02d3e1228c54dcf45fee7a1b1d0d9a9bebf24eaca10a00d99cf9d1bde8c6dd4f5700700391041ae8ff9f7b1a3ad16d50225cbc4dfa3659a25b22b06d2b9d5eae9eb8deab8c70f6a45e38dcfdbc3f5f162e02a9ebd0d1bfc70162a42a67b77285bbec0a5447b72a713ff8fb24dd1ab40c4d253734d3a42f62d61c68dd9b8c51360134f59bff14e339a5312792bd2d809646523494e9e19a6148d0842a2d70b74bff928532d51798969a5d2c70c7f05b823c39e31f8d414c63f8e8bff4a834a40b21eeebd112052680812dab80ad30acc0038ebd1217337096c8f22b1d2b7f6c6497f25d415988d3b96565ab4d3ad942238f38e80c4c24f6f3c916d19c7c254e37529ca980d3b85c2c9e5e4156fd6d06070ed8f80aa1cff8b80c2809bd55d0fab1818c0e2cf62ee4417dc16ae9b8cab1f62764711f7b20f987d6cec9bb7ce4bf3210cdac94cece3080fef74922300fafae69b679cac51ee6571c108af9fa8c0381338c796a5fde84ea7b1f283ee4e62c5b07132f0819de5a4816b88dc29f8f275e198f1f40803613add4fd82dcb8593dc706931204ed000b2e3b322f06ebbfa7816b61dd6078f6881b2a22090f84b5beb180b335d207bd08473f4df665b99836dfe3f23b970d274f4a78d46469c6b782966d1f8bf322bd81eae1e446a8afc519a8c89596dbbfcecab205a37fef9f949e09553345c8c993585f108c180d989fe531f9ec5062aec87411c9360c334b734194eaa880c37c05d12efaa131a46fff8fe0fc709a00cfef5097c2ce0c7ff751570ec89d0eca39ca237b90b428847af3098337c82460c475a3262b2690eb923610d75a86b734c49451d6356c5da474afa759799de47a1f785bc837ec2ccc7c5b3d2e08cd038b5ef28b4d4e827bf922589dd25cbf845e1e18ccf636cb653a7808cd39102a65f92767cb1cb5163eeceb00c1282172f1e0cb3ba5fb5f0d0b0226cb7ba69b0141286c227d36f4577bde9a871cfadec83177f1679b2bc9d25003ca69b5f0df2a5f4f79aa9f20da93125cde1d47767ba0c298da558d6fa9b3e938f36a28443b9e301a17823066a40a8125a51334da31fb46a0904344951d0cf5c6e7b01cc00eacc482f096404fdd8b77a2493b0bd6c218dae9a8455da2e78208faf10336f9694bf03d0f13b81d19c30f2c009e2ea6fde68415cdc09b5c418ade807f2f5e5415ba2f0c5c1143a97b028a227e5062a1d3ad0219d64171b2b95f12c329d55498a3a45bec465235b43ec8d1346212d297555ebfe14a47ac976ec0b4b2e6341be5869fe91c6d32710eed83cacf1af44e8e942a0bc5a5d83c60b9b4305411a4f8599acb7edde65ae44fa4c5f98971cf409bef0a88f45618efcb610ded7ea054d0212efec33e4f418b0694eb03ae2f4ebbcc024b5ddee4cfacbb05c34780566c5c3e9138cb8a9458b272945ad0f29add8657327534360b81e5aa16a9043a35d994970e87b4bd4201d8ba91576fa9c27ef2ab2fcd84fc74c21255a1cf21f6ffb1911db8d6382d039c7336256277bf960f290059093343c499d2e551644a1f9a2003b148b1654b75daf72834f86bc0c4e81530b6a7ee9759449045a0886a15982b202cf6426bb466362e9c35cfee32e342dfa574e00206304441b170272ccbd367f85464f4510c89e03eed070fb42ee6f7bc9b01646741434faa7792e6cca51d8c4b8aa43e26103692005020069f19b427de4ca045cfb535195ab578bd755a7f8f142defa860f600fe9fe0116f86764ed99a0c79d4ed0233e0e9261bce8a8fed09bf545e262c8d0b9d084a67f531d31c6c401bfc8e24efe92e2b7dc6cf99cef60c5e4aa6cbbf41dda030136fa66ebf623d68eb0b206fa50d128f4180206879642e439c340eff6daa625cca450bf7627e6e51d0bf7ed7a4f6fb55ee690c91931f2462581d2c5c79a0e30948f92585470314a4fc697219e99bd66c9783fe6f144d9c28691402447bad0653f13058bd2591ec69274b36f64a29239a00ec842fe1ea473503fea1ec24e5a01869f81ed808e0fbc3f24b62b04ffe90605028708c1e2eb7ac0f6986537de1357198c1d1c77516fdfb376f233ecbe4e85d1378f4c23440850615f125292c95bb1e1da8c96b2ce63a45275a885e2bb8a4187617bbc469f1c66b64b897a5bee34f5ea2ec59fa09b7377da51d01e1b76e892561f50fe49e16ee780d1612303b5da4161ebc252576f9a880cd36987635b381cfa1a26cb91850f1a9835cc7603299ade7f66b11090c728c79f07c48ee3b22e3e7c79acf9893acf7d83651e3fb9ee1189279ea52bd8bd71da993cc7213bf033d9c632b9573ea7581fbcc5fb86b73e3fa55df097baf8dcbe8157f0b69eb25d09d4a558349fc80c8b1ddc62829f43fdffd3d829ca81f88d4a7daa45643121da25664bad84175d03cc0635ba1ce36a2a461741a3a7018da482f59c195a55e6df731282e1aebd60dabbcd1e5e4a6672e954d46deeb2e162bb310bf36abbea2f17ce25e67d8b22230c186237a797a61e50f2b3dab9be3784bb33e197a0e33ee1658ab270499f4ff2cf969bde6bfed30cd94fe86a6cffb928d4845b49bbc2bb56778a7790f2ffe4dfcf4d9d263dcd134695b73601202baa59cddc49b1cd9bb49d48f167a369f6933e4cb4dcc44fc917ab9dc9ae6b9873b349628ab82aafa06f616b8639f77e29a57eb472eabc37df3ae2c11344b5eb10973aeb450191f6b1f86949bdca071e522787a016d190c758c6ad5da71d6ce3d2457a1dd358fe84696ee65037e93089298e9bd85b3020d900aa645cc80671bc5db0375dc89200d1cb22e1a56e1e9897c73bf74f34a705bbea2a27a2128ba224cd418046a6a88e1cc6b5d40571400e456db43fdaa944a33a2fd5198040f997352bb398ba9ed8449aad7790b52607c93307e58bcc29925bc62b357f1c2f8fcc032c16b443a44f7bf492148e8ab96092b3dfa06344d9c57a32de846c2412bf614c9aa1f0234aec7239d11c70b73832647032c3245f5e6447af4eb12b6e3040e26f967b24310d771124d5cb78004f67cc2cf2bbbea58e897c97d457f2b04e6eda492fd0ff13f174e0927f33030c2e538bd7901d591892f518a631f74f4627675aaa06b504b5ac780252aa4d207cca9bf4d43e8cc910bf1832b2972c268a4643ad32bf642bb057b6df8bb4c44dbfd0c600534b524bd6b637989eb35ab8f1e714878d8b52b48fa4fac9d0bedbce113f2d4b2c55d3b07e18f88847aa7661b6777616c8e27d10f61ce7e3ad4af24d3707a94ae9551bbe4e71105f2c101d1ea8f31167bbba54d5479bdf9d52151f44a4e89bdec18b0d44a1da7e5de8d7a6c23d7b67ad969cde23b692ce419f5df7f4150fac66be46c78b8ec37e1423dc06c626e586b7317bb3735eb1f936ee526e570b4b66ed9ec08a9a69b65f664af7d4f6e04f90c93d7cf407d497ba8d13e5f79aa837f422ebe4339c9019615ec9c4726d618f59aafb998d6046e2345e29744559b5ce0c5c0de0b371489d01fad934342b5a24e19213154c9042907e5052205e49a3424b248e3f06401397493927a0a9e8caa894328ad3934ac5bbf2e5ee53b07ccb81ce692656d0b0cea190cc0de3df3133667357ad08ea5fa3bc26d7c6cf9210ee015c8369a0b046b6ce5629fe9382fb08acd458e0e500eadf13ceb73f2e0786d5db3325e0652ec9c925b3ad1404fe0e1a125d9b236f520fa98104e2db9fd96be3621bac7762d6230a373cf69ef35a66af275dc696761e7e1de4c6c753958e0be92306d9ded107c751dbffb10da71d7852ce808148d4dcb501e22a5fb68c2ad16b0194cef908ec39a64dc47bb0c6c35a42bdb7c8f5251c3fa20bb4107bcec5a9ded81d7574e0c6d82baa6079cd6a12cec0979f4e5f2bac24be56718d50f892ab9b15c2cbd47fc097f714f5579b21138bba9e9bd90aa7fa2015436a328b357ededa2b53079f0f05d8a2848c2976b7f260dd1d234a19c7924932e6ef8b5555c3c4da11cb9e0baedbc00212673fdba8ad40d19500ca3407bb2b1e69ad464e40b545ea813b34dc6a104c3278664df3f61e9c631678415a41a69325aef20a2d8ffba4d2c8f0f1f8e9e9e412aa6960b9ace4264cf624bc07ab827bf4bacd804c863b3eedd004a45a59d15d6eed984aa4b48b693b4c1977bd65337cc1464dd892198fdfb78a0c0a6e8706bcb8ca0d5dadc025e472ccd8dfb1b1b5827af024cf8006d71df8cad70af997b0d691e99127fc2f8bd9ebbdcb13da1673ece1aa917ec84a7e377f61df6d73e2fd9ff6f3db149c765f43fed85481c031790afafb8194ef095cfe5d68cb569099d6c2a6450c83d6670569f873b9713df03630589fb214411476b909e4f6c2ce445ce854b1944433bc855d1e27c9ba4a664af7ec0ff4d7be83dd2e115173e930ca637b4e20efbb7a3512afb322598fb7f9b1ecbe5c071c7c6f0473d4d9dc8a5c8e8954fc981cdb3927d2fb211291343004f9139222c20af1f527e2db2748f87d54c43ae8a8db15d06ecb03b571e941f124fe8031e4e484767f09d7f384fb646228ed42d15749f6471eb8591f7dc3fc97054a11d63c8e8e2a598592db79ebb07510fdbd0f2bb4d0d1a62c48bcce8bde2f6efc99891342382fd5a766e2784b845ac5cc8eeb2d9fe3ae8d3efae05cb56e6aeba5605f914646bab5cfd27f9401f228392b9b124a14e99719ac2c63c66c9de0c6f6adaeb85372fa869e9d37b1398650cf6a8fae9edb218d1f8100698dd313f89cd65d80a01a999c34e7aa538f01d1c6e92f732a2ada35fe4e4cc37bd65f544cc7ef3a592089647a127e355c62000ad37593cea2e8ae1a005b831dea1c282e9184e0d9df22dc7370e169c891a2baaa2bf28a2999a25c77c47a0d10b164718e436f79b7afb7a1338d97f468929f00254188b263f551b20181cf87e529599ac4cc96c7951af5bdf1a7fd3703789207547434d94a3ae4615f540f8a66a687342c686ec005a2b2f0cc23006239d15fd0a880eacc93f9b09619e4b37e80171b9debe66753c0c8860b5b63e6e4cef1cdaede54c70c5f5ed24c72d314f2b6969bf144774cc667afe7cf35b5a7e4babfb5fa8f941d56d49fc3d581b573b75aa2639e4b15627cd59de6f47740eacb3e4f692160546fddb3d504ddc62a05c3504cbebbc4c9ed9f11bce03099dd1691149831497fc9e108cc4ce0584056f3b750cc583e51a3b70d6709e1e2d025587d07d091aa608569ae107ccd52c6f1da0ba5f60ce39256cc9f0e51deae7b2f43cc9d94b1abca8b0c9af342607c395c052b1ec3192415f167eb0b442f4218666fea3a8c79bca4d01c9ea1eaebab79e4165a4cf0cb53d6572b063c3ee929df1d8a3894f01b1dfe2cff86d048e5b18cc7d08f92c8eead2e0fd134c431af4b8a0c88aa25ff366ecdb07851bb80a9e8c94d1b14f02285219543c4ca58703d10f6d1b3144eb229908d3ae3d5031223a653d0cea208a2095b7bc757994a231dedc5e62b7cf6f39c146eece6059850019ea1fc997140a26b242d874c3f745b461fe852567cdc97d82784639fa91130a5f2f42d701362cee5cb5b7d2ad0df1ad8c19476d91d337f2a16345abce03da67aaf761413a6a27f3ca3c88bbb499b49f6357eac8b2b506b11ed55833a986d1a0f0a566acc1438f277268787abbc6c987bcce9b47ea81b68ff5ea960fc74427ba39fb1c0d0adcd44e772e8d53cbb6dcef80e4d44f9b5f2691f10b4b8d9a860a57491c6e4a130018cfc51507c0f312a0d56cfedb7f8c5378918708c252b665e18e555853b4b250d146922983042341b5bb6e8fe716e881fc41a392fbaa62c15750f30cc676926f27b085cc019b00faad91f7ff540d0e757274c05805efdc6d6bf4bc681f6e9effdd0b337f29674c244d362eba2e1ac2c3b1b97411438c1ad9158052317402ba662ced1a698ebaaf90bc3091f62e91c6c6f3ae3d97448592de70c1496a2bfb5c9de780740e5cc2dc809307a03e8a7692d04cba0cec54e150af33c1826e08a6674d7a9988b11a769643139e17c80b4b44c276688ddc590a6d87226362b5c08ea40e6a32c624a9ccbc8890ecaa0593b284447299b6c890ff4024f0337149a565bcfc1e48ee895b4ac21f3873c318e7e34440711ccfe18e4457b5055553b15192de1c54725e2c55c7bf530ba0519512be33cc432d11aa79f9cbb66f64dced69e613937829d078d810a6b1f7667f8f610a7d20609a2903a9b05a67057bb747a19af87876b72aa08f036d39edc368927f88998ad769b30078e8ac94a1a4d2ac27b4856a5b1bde0604653e9f220ac433c1380d6289fe983f5d8a647d885f49ea47d068c89b509a648774e5eff9cb742b2e2ede3b804f67f9025141b05553a95b9d9fb464d5f1866321613e89dbd9be90ecbcf6ab451e4d9c09a3712deceb4acbc5589f32ac7c8a3ab76175ce8cbe26456d3b1d003a095d5bb1a165366c571e037ecf82ec767a1576b2cb85ab0df73e8b235bc088a6a71045c6d026533ac900cdb1eabfcfa0aa175562c4c9ac950efcb8d197fa1ef5b5a3903532b1cdf11d97a4cfcac6ec851022ba058b9ce8f01023f4132b19dc32e5af65132d28ab21ed4d8533c731175b3b3e873c6502251b26887d03a8e74b81b4819339f4842c51232cfe751c0f12ceba1616537909de81a1a7fa79226ed421f106b407fef082e68a8bf757246dd2fd482608abdb0e8a8f2264993463a593bd6f7b1b299b42bf8cf7fe0ebf121c2ce736c4953d60b074e9acea62ee076e6dd9c7d555027721f5d0860a97e38961aefa28c49fcb3e82bb5154f035e0f8ce1275ffdd4c6a13c1573799bc541e843efad80e96c66ea20c6e05a543e16367a2e33b7ea5df2d3c630181d3c813745a663da8b3137a8361f36948cf00a91d25af32cc9562f1900fc97d0afe674b5d845c4d2858b0681f05d5790232444155b2d16aeed4ffa7a101873a0db3746c2f60068e42f9b5344e0c1942ed58fafe0a38f630b239eee001d470fa5307a76d55bed18b4aeb28368c3aca45c5606336b7052c416530d22f741bc2fdd910ece2f4be134848f4991b0320aa5fcbaafb5864327b939c11f45fcb76e77e4e1ab2cb4d2ec26f8195afb303ec4058707d856f35532c51fc84d39925a310d87133984da327b1e1ab3ee2564a4be7af1fc7223a7ce3af71f2fec9f8abb554e6e3147b0a7a36706864da4caf8d638dbcaa63af713acbc7530e1401b01eeb4b136427a49ee79a1602501534ab90ee951c2b87f9811f62ecd2d97b95a52625fe5007cfc18a1b6846bce8dd44b452a7d8425f39146b4a1b9379f4bd65e7fe128687d54492e0479772439302f2fa66e06ab9434034ef2eabf49ae96e20e6b75ab9103d6069adde9c9ca81fc1c48b08a9868cc8f08cc06e7a6f99b78c78c78b519ec0c95291fb2ee07668bea23687ef7a4525160ef05bcf8b772f0e551c93a41e62ee5faab6e004f6a24b9900c4f7aafe01f8e1cae7cd77a9bb0eb891a84501049d820ebcf368a949ecb98db6266afda03e87edb7593f0c5d48ef8ae042b7dc892d1cd153e6aed22bdd1f452f73ec8f67fcdd8fe98489ac59c2dba4195edb5607bc68339aea88d7354afddb19f64148c0ef605e1bff20482498e918fff458872b17c20a15bff8cdd82acd98ad9188c56553f49f9dc56c25ec8ddc970dd63ecd0e0aa33a1596651d4e08e1bceccd9e185f297e41362ce62fbb91eae554b511bf5d572abcb94699d1da95b126385756602ae4bf02dd27a1b861fb5d9089296145ec7a14ccd95bd750580feca7c0ea8060d95b31682a169932744f3ecefdd5d63207729ace105654dac939aef34c699f266c17b24fed1b3537df9afafef6cdad44b4cf42f77e1aa4dbb13e7ffb83be3d39e5ce7713f32e064549be0041a6407275a4ee32cea5a8700936be5b0ea09aaaadcff6450f34c133a015bd0761238aca6dac645617cda8597a1463ff9365df624bade43ab368f25fef52934a87dadad5ab5afd1959990391272b29c4a8e17d5fb09a8c3531be169418be98f99201930633142563bbef859767f2d64dab3ad4a4ef8dcd427f1dba3446c2d79f8f615513b36e69cddb8d4d5d0d22d2b7d9a764d4232665af028b99500318bfb4c047ea7cfca7d8b32daa626fc777bd978ebae4e42de4856918ed224d5900b3390b7d559970369ac01c70721a57e26114d0a65e723af60384e4faf8499db37143cd191c524e387f35ec42ec0299ebac918475a197051a97e1858eddf7b8f4fa0c88ae34a785ad4726c8d0c3e193b85ef9d03b467464a5e675456567ab6630be51f5457222bb705ac372bbe5fa813b902fcc7838db2ec88aa570016753333215b73e943a63c167330461c07128d5e3f141498b9449bfb82ac9a68b27065f5577313829f799f1f8f8ec70521a23ba52f0eda061b274f32a90cb8dca924aaace36fb7f5de1259072de264a73bd146175c4269e6fff035b7a60897a4b99a2388baf965468b0e13b9870c17a417057ef61336db36d7b982b22374bf4ba8aa1f872fcd54e87a5619591fea757504be922c084dd33aac37cd5c8cde735ce633e1ea102419117cb07f5b783c4d7c71ef7e321159418933625df62e05bb5a07b29b04353a1bc81477d3a51edc289f7c9bdee449078c6c20439e934f1fc9fa95dbdd020a020047253fa85de759c14212b7810934f3472a44a0e8c506e6055bf1f403b8abe756a78226f860a83a756a238c05cd2a17e2f98794c21fce14bf8b882ee52ab24610b2997a35e775f8f2bc5c6b261b02c94e04e1e6ada98fb4c88c5bfc9d84dd346480514a8350c3b2b47e70d74501c62329cf19027a5712de81126e6918b0defc09d851582b56f54d030f53423b0f069469b0faf974d24bbc19db1aa18b18cfd1f8b9eea40c9ebe6f9d2936a203f6ba87bf9ac079de90d558d8f3b7f77d89cc4b9ee214036494bf0e68a0b01922935191ac6f581727e8a36aa58511e7a7e3baf45cb5c122829cfa742dc422908aab3107f6e12a39119df610f270c65ccda67ffc01b3ce7fe7e6290383716aa5f542d6634158542ffb0e8236814af605535d481d561d3cfcc1b9d58ed28bf7bc92db3a9a9a437166a52de06cc6a4836bb6c5f9322d4ebe7dbec6cda3bd0f70d7b2d474d1d23c462bc9ea621fc9a2a000d120ca3e2484cd9f2c7404020778f795166f9a6ad3f76fe1575c4f5964747393e51908844110d137062772bc3c7ad7b86ccbeb357f1ce5a24567420e9b26e923fbffe9ae94eaa7ab7036b8d1d06f4e50266294395c9eb1832a6498f2c3df2e2736d5a64b0e440667d067cf7ab5d5df8b15b3db78a9f833e42caa83c83c688036aeada544a55261d094b2ef73368cf9b031350e778d387e166d307bb7bef2855b757c77a04ec1b585b3ede93dc626543337d4500e3a898dbfc56eb2efac829654a9976fa0b442612e7aeb6fcf4cea4463d5b9b954f80a12443c3395897b9be616acff6e1d997da191cf58a7770f9c85d3da74ebe0f080939ae93e5bb0c78050def4621ccbb041cee339e67b8a3783d5bbcab8847ab0bb09724031f01f46f0f82237abd9f8da340dfa3a5183de5d158a7a31b5724ba773ce4840d9cbba84ab09abc5358fc1160a07b4c97a1928ea2584440cde9c754dd6657b196856a5191dea39b74a25db03e051ee34079e358d60de2bbae56e250a0e63b1133044cd42b17c57e1a2207ea3abf54e30a0f6259ae0cfbd2298e390a45b1164576f28fa7b31fcd769fb4ab7b4b5b582074bcdf5082cad1dd7f5bdf3a51240aca64cfee6f7c06cc2c61c66dd01aca6a3f196941f2bcde282d6a446e5a59b6c86b21737d37a26566ccf00a5741509c197386f08141c97d67b0b4176246cf76eb544258116987cecff53ccfabe71a0ad23febaa22539145ed4b98d3d3296a8fb35264e4003875d5e70fad3e1b0ed05252729af966907f01496c663ed9d494788bc262959f41f919e8e732cf7a5a1644ffbf8e5f2cf03177f149b74f6a4594afe2dd1ca2a77544c54775cb92da350476a2877ddbbd0ba210d89227bc8f3af565e938a8be05af1d428988720db63de5d529e204914186075a39e508cbbd48103fb56ffcb4ceee25c6f1ae53cc9b60d46a76ff9909b9bceb938f1f7b41e01dbe0e9906c41a6ef4596b584ce2943fb0f28f3c41cb768a059934104d05bb5e28306e9186a147625d3209c0a3279b368b93d1c9e8fa673c19ddf345ff6adeb81abfa5165b39fccb2c655b656ec93f1c7ef06a31913b898284ffd9ead0bf285a5bdc5fe061a786fc7353abc2a8064a0d5863dbdc11570ceccc363f9d95129d95a8f26507df1c46c83a40d500327c0e028a87f0507266985c25c4fb8bae91e0868f1f7b39e2bf78ab5097c3c1c7c1a23a2e5cb04013f0cae0e62a72cb8d87246967d3f6b58b27cefe3c4d47b53df24411bb975fc5f88077e5383aad298170a6d64c0128283a6ffb55c22a1117861f68a52159350b59e4c87637a02234b76b025a1e75456a464743807b78037636514cbaf59383d4a812cba20d061f0cdad95444be4b6807da92f9c8e88f5961e6c1c06a05ea8e6f208cb6de14c49b9bad9c7c47a10311d941c81e4a8a70e403263e8e647c55c5ccdd244752fa58e1e62f9841aa75f4192c808bf17ec6a53dc68c062283bc9c8a4f1e2d7ec3d04442683c808aa382e239a61baa0a45350cf70fbe41c7bc40b6865bbba44893828b5aeaa30a1e2b50e18426f5dc5e48286305d9ce455a591ba65a76b69861317adb0eb6c91970070d941ba13c8d5afd39aeeb7b36920bea28b1c9d119eed177e3a9f0985f5fdfe4a2158ff3dfbb84a87d4eef5373f9334513bfb4f8bbe015a0db04a2d44fd66cf5ffc0f51b18a25b08e5dfd75e85ade9503f43e67f1656f300e4fd88ccdfa6dace19028ed87b6d775638121b106745b3de0426b999a0b22bd68b1a49e0bcf78dc01cbe7c5e163e1b2afc072bb266857c9192614661936e92adad5a57c1e4a6a23c3945bddefcd49e52a2a13655e7176533e0121ed563a6dbf4f14311bfaa313eade8e0b2501b76b243a26f5e0715899ca650b52a7ca1dc3167c907a63a354f081136c33846001ea105392e1e4170a293592092f403423540ef6787e899e2bee9d5e44d322157d5f381566de1ada049429e8ecd6c91c298ba221745df565abe6d7693de01dbfecc8acd04cd1ea6a878463a3877a5fdde32dfbf14da9e369a5ebcc5ccce2cd8cd0f418c3f6b51e42a3b30ddcd52f3c48132efbecb31ab02ada613bcb1bc17337166f419de26555c5710a5dbb66da93c250bf3cefe9a705c022a02b88bd06422fdd228b99d7f191ffbf0acd46e6ad268a7e64c23c45befbfc9f5435680f331a7bf8a69f0b24bf63dfdc9ea1fe374350e7b53334f72e53777798f045d3e19a1b7d38a4cc4d20625014b66afd4a8fe9bafdc1999739203015b61258bc9f5a8f4dc3d4f61944449093f2f4c9aea776e62b2edc62b55c2808753ce0f0a3e9d6f79fb865e0e5e47364cad5c4f3ba52e4bbb4a2ae7275361ced92f529dcdc19c2ee415891b059fbb4e04fa641473c9408832486ee23ac69a3084e3cbf68f840498f61a55a81a6bbef394389c737f797c11d6d41d4a6936459e69a24bc7f4b7eb19d82b073dab18fad32d1bf48ff93445997fab56f4c9abe2061d32aa9629534efedde06ecae7801dd72f0fccbfcf0c0a20582b20e45155b8bfb2699736ac64edf49b0c6bd858ba33587ef1d1cf84b1b3b490f6710178df7af75f067ae523dad7bca62eb394def8dfc8722a2d996b9e989493f10b19a244cb1fbf0ed8c8025780f8bf4442af833a7222eb1f143f18e2c8c34a377e1a35b2782714f9690a35457914ce26fa3acb7692b63f5bca6cbb126dc81d209faa98025385a55d824a28aa57c3191edb932358fb5fd0d44b3222aec60b07c048c56ea45ee9cb070f84bf01cbd92d9f13e8f39e2f1e90f2dabb4929a4edbba96f9773625ca737607c0983e69dfd08381f94ef0ccb961224134a64ac623793c1ece15a8e961d8dac80d048fa09ddf6170f212e75e7f91360c6efdfb453705334662ba5dc2a6d2117635b20269d1468df1f395d2d6bb0b38ab07b4fac31c34ebb94cc1414d355d935e06880694e56518d73b79b3a2b825ceb63ed63f6b73b102eb9333e55371645497812f9c3f66fd5fbcd946efcaa0c3a42bfaf89b274f40ad684350629860631a30d9063dca89550ae387eff45f1ab5b7e750837e5afe8b3c32649d15586f6fd4924e2310a40cad8323b2ee9211949d44fc4225d0aa758a339791f397af40f0d3b0b7cda6bd8cd7b31664d455d2df922d786fe9584ae46bf0551e345a734921b6e64a024609622728fdfde48c01db3b8fa3cfbd768dd38be2430624f12a754acc4daf7b1b16493a64cfc52803a61102611f5b1808161191d7d5b76a3081a45f64a3bc2ecd54ea7440bffc88652bc3e17dd05b309a12636a27c28c0be323d532a59fea5ac9190780f5d2706d0cfa467b5592255b698a2954cbb4b938c4586c9a4df49c9066144291fc6540e967b266b19c233e9422ffe1749ec99d146d0f78a41cc53bbdc9fefd29b3d4e3a05dc641594c5f8e675dd898e30254d1e2ed09f71ee18a5043670244ce50edda5371f7fae572191d9cf78c578ca2b0c8d6ff93729663b68d7f0a023e39b6c1b0978f74428984b6f5e855d76d0ab3a8cbdeda83a31b73532b28e5902920b9744c1accd7bc30899cf0f6b643179aad24bf1935ddbe1ff03e748246bfcac79bf2b45239cd8594f9717fac0010d43f4a86517909e3fce3fe2761c8df9362685edb5cb15fbd041b3d9d295e7556dc8b0b3cf411020810041566c188c4e0df3f3289273528c76f8aea28f9ac1089fcbdc6ac28c99d93b332b20e51a5feb0725b51ecf16752531b6b9384e252e9c50b6e22712e051b87e64b3f03ea41eb9c15c849783d7f036c9de43eb70dae281eea6451f6eb3688b53d1a2da69790fbe347a6728b000bd3afeca758a9da53b67d963ad7faeabb35bd135eccda1194cce9d38663d90767144d6a090b6d75e4a6969b3bbe43b2302ea0768a0a9cecfe50c9849bbdba027f6ff704c15b94ecad7413342ad76e1e78a97568a210e5ed8d8a40feae42417c757f23b8bb1a2ba7a9f31c4e803aa7658b35ed300c99a412a284414034136c082dcb81ee6d8c58f7f5df6d6dd59bf7101047b8e5fedf60312711da35c0c6d4fc177a1b87e2aeee2182141fd5d4bd02164cc4d14569170401bf3684a712f85d90347669d205cca7e6b3b5ba0617d7be48fc757d14e9b59d53aa23c6cd44952cad1c92d974fb501f0563a58c45df1a643f67b7d403fc30285fbe1d18740c1a7b362ccc637290d2314bcb20d9c95f7e5ed4886991b27331bda7a48069bda82aec976ff11f066a16d1060f9e0cbcfedb2aee83eb9ade568b9f53edd2181af4d564578b2fca965a30d6b8146f6fbe45cf66a735ec282235e311c0822e549ca09d9b59c0bd1ee43e2f920122dc30b6b77c6d7b7d8c9196f5f5d9fd4173726565623f6b101b5a879be9b083c768bbe8d9403e1c3fea4f6aa877ee8c30f21ad0efff7ddb251809c16c2a99346fbe13c9328198de14f973a7585fdc60b93a48da16e87a4d9e952b550949942cee03413f29254afa2e9b8781ee65be99e34e9faae22d89fcb73852dbb50696af06cdb80c1306c42b0a182b374fe7189b78a57ac707d27c5c503f988e28c2e4293e1e11155d3b2644311243ecdbf38ada376e40773e65bea712a5ddc7a9f46a635e4f5fe64025a7b31d9fde22afdfe7c001a3dfa52fbd37acefbc488da142000abe25291e4f04d499c4d32427c3ccff1fad5afa53d39f36d6e6f75fa4bd28e6a71993caff6e232043c01b02b41963dbdcc4efb673fa702a4f7b216ea660ae8c940a119eae22b655bc84f0f54a39d0a40714417f5d4e7a3dbe91c46094f1c962cfdc14e6b114a642a0356b537ce401f892f5184cdad57f83db190d3b847e5c20445baf7331d0d5ce6677a77f805d918cf6ff85480f99840dc7a774c8f6ddb499bab9711f5076eac97d26f1f97c13260bfa558d4aa14afb456d9f8ae456a8b09034ff33e8d28b575b75ce6017ad475a67cea17384bc3ccd1a1e3117ac1c6ed57720ed75ea0484430e955408a6be80fff31ccab42e27a2191f142421917a80a2d6309b56149d2af7cd53d13a6d7514cf783b4d7314b10822734c06bea23973712a13703052847ced1f9b26d134b1a8dc3b90a6699220800335464a8be5f846aa52348e1d5355ff1a27422f93aa7655addfae4fb54f4e222d0c02951cfceede8ac420217c45ab76fd82be77c1c4c544eb3d294e31ea1245552023b54499ac9a67c9cb3350df1f12e4f1cbeac4ace1161444efbd590348ab96773eab7af6961861938dade71a58b0a133f68a24d4a74504c7d93cc033b67e1ab7474b51b59c6c821aa74f287844d72c46ba43f3c4e3a0ffcdc83d436e4217f24b5e7bb200447ae67697325cc229fde4a684902dc1f9c3c68378a96395cd55b6510d04d3487e8983131b6edadaa8bdc2c24fddb31949c69f38c19b766c7ac5c40af0cb7aa9811eb3e72e9e41c93831f0aec6ea89b9ab6ac01d84d4316f8c966b1059754236da1f91142977313acf4fe87e730fc2212d473f6e42f64224acd3b58950709f10862aae4cb0392c871b8245b66efe5eb9ac0125ecf9179948484d7854e88a4edeb39bf1085b52a9ffa1f752e7d18024668b820cf9df16f8b55136ca56281afc584d8852616e34e613c630848e63e1f38f747f46f9dfafcf362a87ada66bf60442605a2e50b6e930e23c774d31cf61cfb37bdaae27ca98e0ae916faffa1636c0cf174ba01879f866ce74b871564386697859df81f28073ca7b16004cc824167cbadf94c43e5a6c87a43d4c996d58a5b20f94d78a15a9b3fedb5261a2babb04b938ddb0215848494c9d2f1c401df3e1e09cfa8868f55abd4965716268a80a5fa023bf03d49915eabe8fc07d01582b2862e23f022955692c760cc4e5f4a3a13babbb69e02e024669bec2a7f9d8008435fd01c9a2bb28936fd86da3438fcd058b71be851387b1f8c768ec2fb4fbae0c6b7393d195a125a0ddb15475e4d89c2bcc23a5077bc7add7ba856a5d5c16c8d42d99230c71a77a4f31a446108cf35115bdbcac1d1abd9d50cf25f2b61916d1f5d2395d1c44583cd5946834ce276582790b1f2d91dcd0023782c384b60c01c7395e3ac7dc23803a5b7cbab84975691e13e52ee304201cc1779d06ffa568754509014cd4d4df0f4a916578b88ea9ca9ca1515e48934aef166f46aff551acfc58e56d0c03431818d581dc0b211de552715c91ab045949ce096c4d6bf1d1a87fcca6767c1bb2337d0f182eef9708b4932e204210373cc812c5f522cd120e668680c501d53576cb88f3d63f9e735924510f5f6d673856312509b64763cd1e2e07c78a4acd416f5e9932499998b6ef696807244e32e279824f411ef8c80fdbc79c1ea06a10e3e73ea0372806ae6ea36f5e7798d562c9e99756d02c60c0510e5af03f2745f0431480393de73bfd851cb61842f641c6b989304cf14dfe263dc6084aa2229794e8f7d2b566c43cf96a55309e800b73a884a6adfb3f2c2d6dee5f364f85be345ec3d51659f7fc19dfede7792b4677cfd724e44e51b2ee1a51a6d8eaa1333726e359c989d248856f63fe96c4673e53983148fdc8cc44d2429b9dd9c8fcd71a47cb610ab423a52896ebaa63c9fa3ac3c00aedd67b84615dcda7c91bbd7c1d34e668f0bd04e96559775176f48a8d6dee85adb8282f5063b9e7db97b8bf2caa7c83fb82ddbe628510bf64e28480b421960b7f47a06a4a4575c5bb3d92184daf388452ab938e0dd1358266f3d3c83d030d050ac646cd1562c4641b29fbbc3439280e8f46e0a08a7ee60d866f6a496d71dac5fe2ab464df14cb1f4530b957d7f83c68581f6bd5edcfa0dea3927378e3b448e6307ae36424d7a0ed0cba825e984f282860fee139392de38518d93f84cb9baf81c84a918cc88df99e97ee5c44","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
