<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9563e089b7495e153102973b7f79f2e8688cdff0c7ecde4c7b0372ca7706a285101f3116b527aefcc4b7c4e5ad77f402b8ca533331408c08e78eae3a43cb7d4e6bf61b7361341af8b797459522e49ba74b6a49b3d770532041a55945787668acb301b8d658dd6cf962e27e35f9ec662f5de171b0b4655ccf3f2a64c1b263959e994869b8b5968082ff9792ee72ae8fcdef19291fae4944a687f27711c85c8b624f2b80cedbc7b9c62f366e5e002d9c5d77d90ed2001964622db2d9c58befa8405378e4fa5c2b3700180e02f883dc1be2c546600cf9188fb841ca65a823fd4a5b8a9841e4d55493a670983880446ce6ad88e165ece8353cdcf0e6badf310a9ee67373d8622a7172cc917ea89d3550b7cb23ec57a190a68accb4629fceb5d01b082735953743cacf6955e2bb56db49c7b03dbf9ec5564f4274bb92463b7e6266bcd8290f47e81e3ea928d0da472eeb57c704d81c352d309cf9d01892dab74752c1e30abe3cb8963e50250dd49b646d16d05ec50888be06b54f7bafdc14a5f7189603f536d3bf5d2fe9eebc3c7528a1948cb6bb74df8c1b2c255ede6912fac651d29cf7add0e45c41c0dac9a1d55dc96b2b0b2af5efa934ad798ceda7bded017c4cad72aa767659639cc35ba6e38935a228db2bf18da1818c54b4f2b0f548dc49873e17a081bbcb63e4bcc86f5c364b2791242c7fe10fd3d408bb628a8dad169c74304a2b8450dc972da5fd8d55d71e31b6b0a0ecaa3643c7ff509bfe0952cf2e4b5c448770026b6f3c8b44c2e9b7ee69caa254fee758bcca8d79a0243789ce43f7d4004819c8549cd1c3595ac61122e29b5bbf1f18771e482415ed51762e094ef506b49228d7dfe56371e23784796be3a79c2c951179418304bbf34166f2049c74b7df8a986dcb00a380b849311c0a235aff9bd7bbddb4a492213939d87fdd5d24b986fba9a48372aebf2109798f67c5af0bc2a94b2083671342afd53046ce04092162b9d4c1cf9b5cf0995a48d926893796a7f155cd4166d2df46b2690ab942e11e7d4c742a5279e8257c7e8f378b884ab635617e139f8cd6709dd08aa9755351a8c3512bbf6a9a4568d9bccda505afc06ecc56bce118584a6336c571910949697cf2b9ddc965c90547ce6ee3d935206f8b7b1e6d3a56b78506cb640c6852f53ae8dac6d3ddc35dfa12869afc25725536d037d8037da6bb99ac5b66d6a1715baa34037b8638d32c3b3bb574518f079e28061fb149584292d2cd95ce6e0d9f67bf6d70548438c70937e207673b7cda111dd0f81ae10adde917c4cbb03e058a80da9e7febe1587d2c572577ec4a606e05446baf85b7f96cf15426e7eb1e27eb38528c0e7dac0b5bf78dd153cd8303404932a894f083967aebf81cfc8ea369c4143fef968b9b36e182ee94d19d3d54db30ae683a73173ddff0a33188094ce2b0782cd393255da181f7b3ba4fb7fb592346df62bdd60609c53512739496a1d041dde757f988a6048a9d5449f8a8edf8d9ff73213dcc8de5d338c8d4cf3d606345e4a2020af39ae86f32efcd66f7f1eabf94b0d4ae21b64d057422ae9e810256381b74dab25f344231864d12fe65c4765f891e2a4e42809f574bd4c40bb49417fd8fd85b7e0724fb4d35754147ff3544e0386024ac5d54e02c51c12103e097b77bb449d4417522c8e07383d1f31a5919acbb6b137e2796a62d601b72b589390e6f4c4e1049aa2352b403830480d941c1ce12f9ed39e6fb8cf64d55b9cef5959ef98982c3ab16e471d898ca8e3490aa4c207ba795c9415058f9bdd165197b730160d38af2f5b55606ac3d09057f1965057974d7a41615597c373bb4294dde72ab1838457378bbc87692f4b96475e7087c0e86b74ac4f143771afd03fdec444fe16470cf35212b1a3479da08c3a9f72c98b5a07ff0663b7a64257c67593ade53c1863af2fc868379ffc33fbff2334533d7dd1eecc82face21f467237a3f287250aac62aa260347da48819b0f4f0dd12fdfd0fded80442b5b654f3c48f0d38ad0b950519c9d7453a77e5077a04c96a473a5e7a1e6031a56cfff1de5be8d470e1d621b2e1b1550542c3d4eb1e94a0059d8b748f3049142dd50515676e77ac41fba0ed3af8089d52259aa442dfb91cd528fd8ea6aed3fd332b18c0bcb17fd9d5ccfb28db708affccbcaa645b23152a6ca39ea9730cf3214386c7ca8eab507b9f3772f590a7ed41f91507ec648a4b704c658c3ef5ec98e81b334955f1687f6e9f08d118e549dbe85d447734472522d17e5d649f0489cc77e78804d3ee2202d3c9f501668001bd8f0302d0039ced19a49d7c7815cda2be7e9544185c40eaaa24730eeeafd031eb2a40f50665382a2edb1fd603637f2a38b0af6e9874c18f635d0b3e6d8189cf529d3721759860ec9694799edf5109edf45066a0aca6313f4532eae5c5360e5b40d2533e780640da58a3dbf8eab8b7265dd3ff9ee9213a4e1b2538825254e48bdf3a079c0b5857d4884acf1693fa57ea9f120073224ed4e037c3c38bc4cf0c0f846d9573c2212d5a5c6de2ade1a96ecc4373c3feada2d7f84b928f7928e152ed8bdcdab0bb383158d72a318ee2c72668e9567272a7bc97b0e98cef8cf4d57f9525e729a8b79791802d75db0558232a98823cf56c91a2a52d9432691556fceeb5b9dbd246d27f9449e3c25d1201c11d453714158749f15771df8295ea6944abfbde9621e970a2e90f6a13b30e7287dd15ef35e1ec834c053f45225e686af9d5fe982c6886a1e011930a794b462025456f3e80275f65afae466004a30939a355deef329bd8af526e7abff4fab5857fb9a3c97694503ac664706790ed29ea2cfabdfd34cbd54fb12426caf27b1f055b879f49650bd9927bd20bd6dbb93b692f0e396c7c9e234b92b3f19f2913ccbee5cc688fcd2846dcf44a9ef5f407903432109effaaf05b3a8dc23c91edd5720ab294698b99d3f173f30dae6c21ead84a25e709c40131bb993b5e84f46dc308363f97ae05275622af0fc13190ebe1e0432286c69ec8a91c9675427be514b8ead1b75792698fe7606df0c6bb3868e61728e7b0eee17cee7af8cf96b2b76e057850b4dfa3d0f72c931baef8f071a96064ce818b1edbe0ea4a7f99711b68a8282f1edaefd112dddee585800953086592afa6b306bca2e7369554680d43a51e2b521f9e9417b8cec3588ed41cc800dd22526d504a7f05df92a5f9ed2083376a438f1d574adea89153dd880864c71599f6da5bf394f596906ed46dd1ea946f16b9ce3b2042fcacbd105bda9175a05f15c0f09c7c98de67a85d4449b1d93687ccecdd2ade067d132603861d19337ddb0ed1079a2d24df60c55250682481d17d8f46fb117aef06a2e309a4239d5e1bd4b8812abdc4cb12c8bf92f55ea0e3bf6570a3e981ebf28187ee35070c720a026fcc3d768d294052fc7cc2d6330b69f96de9e1c10a5ab4e88f145c566dabacbddc06f13a12aa692971b4377c39d0771e7e4578d788e106912f37ef6027894f3564c28f848558724e6951a1e25819724512a7e65f0d117ac3c1e657f5ad3b98de1f398a99e70b0b284a242b53d630ea7fb48ac36b800db38a1ff3395ec7949178ee6da39368b71d23456ad3c39f8d5f040b5b8c27df096c506793a86457b150702def81d611ed300c1d9e378256a9c3ae0a20351f40e99d23dcb7fcecc17a3668544390959a53513b79c52481b3c10983b4cbb87b082a4bdefd978a8113b327e2358a9c9333dcd96044e030eb2019e9ecaac6a3621b2e2e92d173266c39265a3a04a0bee9a3f7f6b69d1adffb9b91593d901a17889e92c715e7c16599f926daa8410f2612476d101b63a305aed9039b90721752d0ccb6dc7d3c42e7b3acdfc3ca132b12ef058bdafe5b64d3000a4d3d1048bffa058088cfbaba64cd19824cc06e00e7af772f4a080505950fc045fec8398d3c02db688c77327bcb48c19e16e2ca258ecdd194d916f0db6b7e5b4e48a4a550519499c30b53d146ae0890290c934acebcec4546196179bbb66c7e954cb66cbf5050655da739bb961db5700bf9d0596be3b91a505c6c897494ae338657e4c93638b3392e51de3f2e5bc5eedf3d307833b83ed50ac722ff49f79d7aaa2717bf923a0251fdffcc1ba5016896688137e3215104fa192d406b4598b1fdae443578974c193f176d21d63b10c5d4ffde1bfc4d484c5da163849903bc8fb8860bb9bc5c9c86cd6cbdd622d473c608735d41a973b76c68c3de4fd59d8344403b15c4c5858ca75e163e46608c14ebb3f7af74c4a094ec59a0f562b1592ae7a35ca8fa5bf5ec9ae195f5054eb50e469dc5a834d96abaf3d5fb1c5c203722389e5ec6a46f27cb207f32f0b08c3b57912c1f842bbc09494276bd0dfa0b93f3bb63e4611ff8405ba5eb1bbf63c4edc263323e741850170786d9c1569971ee45e1355aa1bbd63d9e42d09826baf3707076c00e52ba1c0b643a2757fccd83ae46ff3b5b40656bd7df085adc87fd4db2262f1b7cbb2f513cb68e10a9e6d1f5bf7d1135fc99c2d803ef7ad50796cc859ac87c0c5ba9ec8d5676465ce4ba6f5f15f55f6366e3193c18554f0655d72ca4ab4bfbf84d3e619caa4b9fb6f2c1a67711e2d46672d827a5249f4bf6d8fd93e79a9348bb54cc8cd5631c0fc1429a0b8de16ac96b8fdf00d65dd0f9d423fcbfcf97b6218878bdb218eb3dd56921ba0bc0e6b22fc32a5479436c4e45e955f38c372f69b9d7c37239789ae2d59681f85a2c9d05d3b91bf9f216cebb569deb4d586074295bbe08c0a574d243826ef8c63a9c6fdf1fb27ce68a2f27cb333e04166f851e5eea7adcd470af63c96658fd2754e067d1325b082129f3d7ca70494710e0c6b8861979639839fdb34f2355e4a37e8cc1264a472bbc663367190dabe19a2bd7d299fc723af2c433eb2a47a60bb5e6308ef07f9c8f0efad47cd7bd4265018eefbb977d12ef5385312460686d294a2219cde93f792ba1ff97909fc0b2706bb72af19783c78252ae587496f80552569a8d2eef41408cc4370cc3ccff9e0622009ff686eb997de523af981a3d51032bce05e164040ca0adc1629f5853d051ee2f5252fbcc7b9f7b7b3231356b868ef8b09e857adc8dca6ab924bf67708d3e0a77493eb1f8162009172cf9f7a8eb1b956a2e0c8e75def5fcabcb9b585f6a857cc72aa8ce67da0b746747b347f6c03b6c89462d8745bce9107ff9bb0c104e6543cf24493744c1a37734a0e8a0835b3ea770b61504ac28fdd64e4657d94006f3537715414c888991f041a6e7c50db1ddd4700c0c0a42dd44f5f872e40a1a9f5630912daaad217e2f5059476e328e75718a48eebda258bf9886943d35203727022ae9c2a346dce7b5712fc1acf67a91d18b7bcc0be49fa9ea42be9bd7125d5eec4937e08f697ed72d62cebcf255a4a604ab27880744b98f31f8f4a66827baedbdaa1592e0bada73edfe3466e2a67bcd5187fe69daee2b4b37291d634862026ebf9c9cd7fd5184d17d909c7bbc0585197ca01d8d0fc7eadae1593c956be5e4c6c7ef16143b730b97774c61c2367dcdc35084ca928fc51386cee60a0122bf1c6b4e134f0d45bc3c5c4da822b6d4c032eb542e5647f473d670f368bf35fb6c331310896281bde254d875c0950f0bee6539da976970f552d79ab3af6e4c5f0889b5e7a43bd5378310814901895c4a390b700b47708d327b82657b88c695dd4d23cab1f759a0c9e6d943d1bda9d191d07525eb31a0542ae53bfdac17bc6190f5fc0b3deff87497c2cd080caccfa506faaa9d20dafe3c9551aa172733015a7f24c622748ad9e8d8960742b0b7ed4f14fd9f8340a561432820238e6a8330d75baa0c7263ced4e9b45dbb13cf47d4d856403765425fb60ab38860652ac84586b2dfad38d60735b5be61dd146c39a778fff5b379a8da6724f24ed9716d36eeefc6e5ba9c2d4b95779b190b867123dfbf17ac28f01a4a187b451069b97b362cdf7790dff1ee4e5ebbe1a8c2f350c293d552c835288156c994957901ceb3364194121a019fddf3c94a244e3b472d337d0054729a3bf9be26f348b93cd975104cf7fb2f369010708f74ab3158561fc2e7c3495e4e62030babdb3f55624aa2545481ad131e07529b9e0ec8c689ff1e8faa67cd45412d1837d6990cc603c1ad4085d091105bb04dfeaea231d090f44848eb0acf815a79507d833e03991b3b3508c0272479a33d9123f2129c57e160a9dd917cd653f119ff6d7c77f71ea4ace46eae1ae817802ba82d4abd4bf248e8d06e11c0b0438245bc7273799a17047e393b54d7363aea933bbed77f8a807f4ea31fd485c67cf6fb7aef54c7a14e2b43c565f9686d56f3bb4f575314bac53cdc7cb0c87d5cb033dd20c5631db752027ebc0c9ffbfd592518b8ad14a4aa1b52b516cb3a773ee063b9bd9a02fc3cb0f95253e0faf25be61e80c5cab4440a086d6a702ddb935ed5081128f5bbb29a1b57259c70f44b0af368067f89cb8421583187772923bf6b470d6d309d4dd092ce382473e4c83ae0328131385f5133897130daba5ddf99d0fc2b58aaf73164bfc9398fdaef36cdb94c1d6d0c225d320f35d457712322e168a19fb68779766882c6acf02d606c5d7c1d2567a062617a2fd32c04d7a84bfe7c60fd79f944a366c77a4623ee788efb614396d1d091a7638a1cbeb377d91dfc0578c0f690d505656290cbe2cbbe2f16bcfd4ee5a57724c99160cb5ede2a8c82673082b2c0fbf8e7cd3d00305e4decefbdcce85360f59c84b4b6718203b592b36cb7609f825ec867c82dd41b50c4b4ac37784818b02d5f78e4569709a8a66ee3b5350f6e22893355c9bd3270463c6e66a4b7ef81ae64e838c669f4d431981911f0a78f97ca40c89bc9d8505e7aa8dcc4e1a0aa0101c98f8719e1ad8f3c8078994accaa20804408e8ebf25414e6a94398144c05a59fa3d434b7f6e17ea5d80139d28842714dd1aa7e158fa82b103ee1d472739c81a0660002f287d18a759545e3e9c801b8a3f4c147d095d08fc36c6f46a7648175abd7eefe506b651b97a4f9cea4fdfe976fea11e3f3f4ade4099bda62c55f5cbf3bd556bb9d2da523d316c3e1fd7e69b60b2c3984fa3b48aa94408eae6f60ca8d4da6d787832ee90baa1bed479fa42448d33311b7377da4c47b1523bc4d25997419319c85d8a5608a142256305ead0084eb73f12bf47227493b7aed477c99752d384e1b2dffac25fe42d063a1b561d6460d690a90d2982d0de518702cde99cf5788c816ad5c41dd5a61075ff4820e1d31f00642c5831952133b61a5cf8b4d408779770d4b01031dd10fd13bfca5d3000ccd56fa3c6546ac418e687026c5818ccb74b80da2cc3e8e5a6c3533929e2f12fe6d4e94e265a4e109ced24a8d28bd8478e115df655289ec09f7bca4d57787874902d7d05b0c689605c93efc63e9ce12fc2e7ad1c096b480ee532236a2eaeaa99a128b05fff76eafeb51c84873cc978cf34d555e6db11f47f45a37a9e254847900dfde7a30e51a1c3c01c4fb72a43429fb02ab1ddea8df4e0c936d1f21b85170574076a7e3ed80bacbb7c6222ca435b68358ec6c89f97fa59ad1c93b131ce21265377cfaf678dd030b25800b43918cb4c3803fff62be59a3611b471b49cfac3da3ecb1f9f09ba1b95d3bce74da6fc960c579c306d58cdf8aba533d63e8eb91f8862e70fe7765ad59443f678a1c31af450df5e083426d2a8e65408526644a70d90bbc3f887fea2b9026042e3d786315c238ca196ed8949208bb376585fc4b265120ab75ee939ef0cb17d15de9f26de1f660404ed034f7422abdae9752b3421b76a479cf81fc8c23f6b4206063e6bf6320d0f7278df96691179d25ff98b448abc187208d6eb2f85d6d4202452680c6a7d3e7434501b348c3cd41c1a6a38c54a2fa4972d5ee959f3b2dda5b23bbd440849ed9f4154dcd079f93ace05fa1ce504e018416957caadf63a7585bf065ff65f8839349d6f80b310d9c90762c203bf796a7a381feffdd305e384b77dab77e67199ab8b7dc8dbb85cc5ab31e95485ff362c68a5f20d89e3e2a2109825b2bb37212ed5173fc656581d872b176951386aab3deaf34128d5fe24f4044919cebfa54c9838b489c6e54927581b28d068a3ecc0d02851c770fc9cf2c94bf948c94befa3a5a87173f979a7ef7fcc39a3eb37992c88b6ef3cf2f15a86f861868295b960ec5437e7800d0110331e7c1bfc80ac57d17cfe8d2630d3074898dadd88a68de150e0b9578dd42c3e2ffdf1bf08eb40f3d6eb529a628a68ae50e34899d84e623d30bf3408469ba805c8c89d4c759be031cd08c511348b0f6a9271e3ae952861becfc16df2a35ed6ffb660847b9b333a6eae6d6cae4c0beffeb5d37b80e2bec01ab8fd056a22cd928fb2f4c1bdc147624d1619435279764430528a8c457a39403cabb04f255903e090a8127fc8f55b42f9225174f38ba546827b9c4653983656e5c755f1ef946180f60418081d9f2a8a1a2825d99f31c041f18cc517bb888f2bc122620ff5bab55fc6ff4e66c87c71145451f8d8ed664808e5a54ab771cda9b982626b67685c09f99349b85702b2c65cd977295078fcfd46db06fab8b469a0a74ea6556eb01a63c05d0b30beb8109e364c37282f7cc2b9078dde326c2f22becfa564294f1cef67c61a95cbe988e491c0750eadf8cc778c288be3f8fb651f779af5bb556cc33ba77d20d278f03c7a9ec8047d00156a48b5e5b7b8b2455feb56c33fe16364ee72bccf61287444d3e262611a1068f3eb09c8058280093fcde641ca34327835926f192e939982a11ed3f8586bf5e50d774e5049216efecc08f6faed142aa9be7efa3f7401640c62f0d2ed61ba89503c7234cfcd66e758fd8060430048d3ac0ee3a8780bb541f6125dd89103f84129920dc3ebef90c58d2e2b5eedc5bcde31ffa83d1cfc36c0c00ec8030dbea1b13c1435727450289fe5aa3d6d2725e377b00215b6b39b06312d4c12a6c4022d4633603e3554101503453ac9fa8cf3b9d4719b6ca5f881bfd36ffe8757f9f0902ff201ac9be273445aabebfe37e43fd1e97c5d390ff34c365894ae9e3cd84aa46f027490d213f1cdbb65f0905a0d632b6814666e00883e47a5608aaad1065cc5e884c9a2806e7cd39f6581f2d4e63b0736b5d3dd5e2eeda02f7f6dbbbd3d044d109c62671ad9709dba53b1870c3e0086bd634d18bf122d478d11a77e8be3f48744d45feec22974859dc3e9defe9ca0654504279490dfee8ddb80fa2d70815055f897f4d49b06e5c91b809eab1c28552cd274dfddaba4c5b92ffb607764fe5132454420b98f03ff1da5832e690dd5ee94be2ef34efffea2beaa474e111c670646ed6e5b7d83bec61af722b2e799245e95c10bdc186b96a7065bdd20f70e49de888d813506f2b8d078ba6d27bbbdfb43f77dc27f2a3aa06db32cd8e6d46d374d91a1d621429f9284b94b72d0fea06e997de36e183b88007bed6da7e5e1d99c42d48bf75d3e5c859ed3411641bfc5a5f15d39a18f135a745d8bda45e04b3dfd6c5c0b3d2948fd5e49687e419f7f10df650a7aa2367e8069344a153f0ee0853ec0f1b7b67f79081a3741677b56ca95b80ccae0ea37efdcc09979a4aba7b6c4c8f28b5ca60b65f2b55f96e3f7439790060c5eb4c2c4082ba40001cc0221e287ea1bc1e3450d994613b0dbbaac718a679e5a4261fa59c9d10910408463e407c74a4e8a76f188d71278cd4b41c824128e68fb40a4bc6b267c07c2cb8098072485cc2ad4377ba48de26b86dfd24c846133a9ca9bc69a39cdb61a36ec4d480ebe2d24a2bd92b9792a67930ac452abaa64974805ffb18af8bbb29c7615187d844f74de5c59f394e03bb6f8e57dde757a970c46fe3e17e9098b0d338d0c844e81055c84ca167fab327a10d868996b42a8dcaab6f3d3b6065ec7372ac594a6dfa079bfb89886dd389113d9f5fecdd435dd15603070b8705565100e2abb42475a5dc135d77b8bf4a555c220b9261e003cb0eb2887cb3306cd1e96d16d55e2e2f77ddacaa1402a6ba40a2648dd51e0bad3300d890fe061c163148c1cdee6e1b91f4d077b0e54ccce8cb3e79316ddcc0108260c804f19930c23c9ba9aa82ebad0e2459cb25b9cc16c17e18e1e547795a43d2e354f73127a2b322809f5114c434d3cbffbd990ed0fba2ef3d2813836fc0f57398f9a712a11cc4390bebf211462b1b7aaf14006578313563786ade7f8811480508e7a67d80f97ab87eab5ee396bb331404fbd223d69c6cdb800ba2cf663cef1a68b734b28340e544576522c2c8e0aad68cb3a8822d3973291cb49dca3620fa4c77172c160a1ca611c8e896e544921b884938a4b7349751f49b0e930423468f156aa836b6f2103ed610f84628354549f7073b34033b88195161ccd20b676d5b00cb7ac2b896556551df98af3e967170beef650f5a44e1f666996058cd98fa3dc6b524d1a9306b4288279cc7ac798e688e521474d7831c945aaca2b4a4a229672ce9bcc85e68ec16e59a1197ed57861853e8ba9174b0f52a6e79e17e3b9bc092d3e19c8d383c569ab8dd72c5da7003e377005a45dddbc5f14921b853b5bc60df23ed4a08f975bb5ed2a2a943a94c951731ae5a352d228ada92475442894a4b928fd9325090eb4b6bce7b703d37ff6f8c53b17f803501f707968658e52a036ecddcc6d4344aeb2c44105db8ead5e16dd348ff99a9edbf19a4218bf7f7706fa277b812d172513c670dd21e2c0baff21e6220fc22423d211d53e57b1d84224bfa110364c9fe36b07ce4a60d3d1cd14f93d23078fddba7ce819c13617f4188268b66a947fd2372160966377b459bd047d47b1704f54be9c4a49c78dd23655ccaa283deb0d3cc50f9289db08675e979bb24e2867d66d032550daeebc2dc3d51dbad4ce1100be0f7f3c885840d351008d0657622444e6b71535f3482490668cece94a6a81923b4974455f947d7b3863cd2fa065dd397ebabb2441d57f20147cb34710223177c4128782c62acfb032046709426467bfa9f2f1001b2faa056e26b88a8bddafca8cfbb32a5ec8116fba083cbe6c35ae092de05456b2d2c109220b4a7cb18fb490480f3b7a622aa93568de281720dabf6929853712cab7dacf994e63e53f82c1ef4fc0b394e1f0c95e9e5bc9a49d5e4f617260d4388414383a8537e0065fe69c73f1404f51567d3dad31d7248cb5e421fb3e581d4ab4219cdd1895e16326cdc67c35ba8d246822b0c9a3eb49d18af6d816746bb879bc922a1eccb81683299d1702308edeaedfbc3c62a7e27f565fc3c6de1ecbe02cd55a39ce08aa6969bf2101278c5baef8661aedd06771a54fdc2e387b693f7f5cbea5e20d48485aa1d78bf6e0891f5599e803327eee7f5456dca97a34af0c3a60a466a27ed0f77aa5958c67043d03c28442c1ddea19beb4043e1056b6e4f4a5b9abf7af6dfb7a1ef8c4cb4ee2ecc3af7d6ee3cb85c2c6af062f032c1cdb838781a8038640a338dfa8f8a01d1eb84a2a4905b822e7c756c50ddf8209fb85bd59142c7cab229ecd7e9ef67f67b934a438ba491b43ceeac5319653105e40bc931e9f14f63f680296c94c566a9aff4cbe6e91134e35e622ab555ed8a7c0624f9c4a7c7b9725ebdeae8ac3d1d6853403bdcf244a0ce8c4f2081c772b0b8e3a1a56c35f9a53343ad78ed9612ce6c84548b66f7479de3808383c3ae3906c9aaf40139bf840ec99d2e3e23e9875679f52732a0d1d97c70242fda19686e22425660816c1d927bf08c2479c5e262c77e5eb3a89aa4dc8c09693d99f7f90b842a4574716286994df9c0fafe1c4b6d96c9017ead3e4015ce2698924aa11fbd7a902f933bd431a64a7635473641bbc3b278e8140447eafe55c1f35676b8947a8aa9828e15ab2d3ca745f9385ed23f3bc793539e7b14c608fc5657ce7b4314764b7d498526eaaa427af5b274fa4d8b74d20fa1e3f55d47cf436bb940864b04efcfa7d9520f2e234b24d772f269f9a7adec26ee36ee35138f5e61565d6d2e9a58e3f5d10ef6266fdecc179b26a63f5153c5fd1cad8a7e028554b79c839bc60690f89448939242ee3551e8f1dc5d2e0d10acf9c446dc1207494183da2a91bc6aaa526f866638fcbbe27f2ee7bd1fab1dbc3dfd39fe749f6e7ce2dc53903d2e60e1677fa1075bff5c1a3f39eaf79c63085ed0abb8f5b82503aea673cac5a4645309cb85704ff81c393207116cf2aa8c019a0d25dd3b0641b089733040d5239dd8c714a07bb7b0ec388be4c121c8a59100244ebc7bc44259055f0512da309626b40fa66f7fb6f73b4e436bf140007f06a06828d2606a2bf9fd3e6cc88fb2049783b2ee732429f5e4db56afacd7b1b93a0e4a43d3e83f677da7528c18589c31850cdeeb2982150259232a0bccf55741a71fa40fc4f0f18cc009639d08b25bdec34d2b5a837482e4ee37204e4f3b301e02056c23607cbc90b8602ebf5dd8d35e6bf04ce41921aa7cf3a3f0a28b8c34bbc5b4268c91cd2a951b0e38fbab825a8298480d102f650f31434d3a818822ac2f96e9e299dd15e5095639e4c7f0b02949df9b9a8d2dfc1d2e5c57e2225365e5e6b1305b48036dadfe1333fab0032c439b13ecdba5d2a2322b81e2991e917d72e3a68f1dec05b2e3e1a56a2b7027470796bb63e9b28e948a5a71d2aa73f1ba1c98eef7bc36204a36b126f86186b50d2d1ac59b9526c0d700814b208da2072ffabd0cb06e72132942518cfdc9a3bddacd3f8cbeefccbac04ab2384002e4aa5ef5a282d46f8ab6c01aacd5fce869b0f9dd8cd206200091bf35122bf83a36f7d97165ea7ac5e3e05508db3dc52807d3d01e63e08be369e42fd00c66db3bc81e3d1b07d3ff5813d12652d7d47859087b137439b523bccf3e371bc0c65e5bd3275867dda0a6b5e37975aa27f815e2628026e2af8a5369af408e4862ebf24443a3289c10644caf1a5ebd9aa4a294fea805b923e9c9abcdfc5981873de7d681acc3ce439c87b994de6b4dd76d766257b20bb8434c9ea71555ff29f1a7fd6da1618f7818b6ddc025321cd92d9a2a34c6ee0e5980c1f8f3edbc6464bb5076cbd2c5375f1263faeac99063ced503966b4d1feb7e8c1c3dc0b7cc27733c51bf566d40b24a67d8b7149e69d7e6a9bb523b421f6c3c3664abe6bce6d95b7d80e55217eeb776c9148b0f54617cf481f108b84b2bbe7569e329d874f10dc0d5b2bc297838ce65987d5f278d2d6a308d6a2ca7cd4fea15c8608c6a4f6ac86209af94f9924926d59b0a9ffd3049c367453363644a827a63ab8ed75d2cf32864b1f0cc70143fb145c41daddc2c281394c1111bcd6bce9cc3fda69d328ec82472ecc28f70ab9d592d5f7ddc020cf19039b85c5a2d1f78a19f47fe84dc95ec6dcc1e331ad3a93d33c37c650963cb8a60f8b85a3d812a964f2ad4e992819abd5ff0c0cc36603e66f356bfc80c1b2eaf1c01409d12e3226133a91a491dc3732574dbf4ee656a9b41d1e055ea619436953d38b6199b972efe4217ab52513c7fd6057fabef83538e5738a1d2f47ed0c6603a8aa0ad7b6ae4c97f1803f106f7eb4e657dbb62fecc63ea6196d93530458bd89dd97465cc50e600831eba5843d79255cd724154d6626cc4b20545e5d9778958714ca056f0670e3bb55fc2648cea0e40699627d62a4d1c20dd474d24ffd4335fa6c3fa1273049007f7f3c9d86f6247ffff42e57a17d5ad7157a413fa68dd30b573b4729ef8fce990dc6da841bd26c86c023d0eafdbea135856ba2587184f8319f90f9d828b6a5d48f8dd8dc5f1b70f5b0addf57e3474ea6b73c97e4172c3a3168a7cda503ec4b96ee6e04e414ddfb85a83a7200298a4d78844c381d8c8f92027f1fa4ad658e61601f9e04567c125d9c646cf4a7b97b8702d4267a61da5e98fa68afecae166b30fd5835ee5536a4482608721e995696bcbc19d96fd83ecb2567af29ce65657916bbd84476e5fc16380cfccd3f6b02ee4919acb69c9f44274f5be6cf41484cdd7d868f56d734e8346feb05e08481c99e427bb2db70f74fc82cdfcdfd9582ac7452f5c2c95f89f8fd34044e28814d9097a93a861254807d0330fa3cd3fd761fe4c9d3c7c8e22001da463656d8cabf397243091190b32397d2d59dfe269a95e5d11f895c6a9c966f74e2b5509454212951376ac60a3555a89933c6b76de9ea2bf63017149034d4c1148e8824907fc2f118bdca9df3558efe40812c1fb737b48cf64696a1f55adbf00acfa2218648e60d1c239d7c1d9a6ac92d6c8cdbc31f912515a646bf6d3a54667ec6961ced0473749b4aa207e62555eef9717a370e3649b3e96a88ad0a27ea68c29f0febe10c0e5ba2f7db154af1b97d53f042d8f587e7f48d7feb468a8849b8bf6f979e1a6fcebb3549e4ad15c3025ce4abbcbb638945e8d671a5b65843e6562ae178fcef06f20164276d6dbab35455dd7b932bab5da9c7f33884070612d0b13e391174c33ad5afb6106f37dafd6e71accb1c1af716c6523a76acd142db2a642d72364c8987dcc2f19474a024ff803894f443988184cf8be871af094b46aaf01f407460791cedbe42b42f2107bcea2150ad8bcfbfbdf8e74fb089afe09041b576a637625c514d17b974479e1ae879b24549df0ecd67fe1eebbacf836ce08ab31d1bc1f36a019e06dc31d1c69fbd8db12154cffec31b4e6c3f1efe84cdabb0e648bab010fed587cf0d200bd583bb2dee20561e0e5e411ab1138f8ac09762afe187a0fa92700c462cfee9932c1b9111bca679aa6b27f83692a7259655744dc28e0f64d9440ceb142c753804b7d26136331c7ab4c14a31f66a2c930ee5059e1cf3cff6e07a514902e19c47c0535314ba1efec77ed623b593a6cf1e41bab55a2268bf7fae5701f7a06d83fa1e45fba1b047e684b6c0d62dd983bff06547edee3e9692f37ee8a4fc44735c1571dbe93f3a34e7cd5d0ffa3259e47897f3351925b71aca22a38636ae0303787afe390d579680a174d3bf59ae0e7e4e1dc89c7312c63196b9cf2dec40afe277484d78b8fbef8db6d6a02f1ede511c74f2a53c97706b3b7fe6331aa04308f8d6128b09ac1aa01c968008b5cb54ff0de088905e5f2023b9e9ff02ed22eb2552b0353a56dd5d1df4cc3223e9a6e6b9aa6612ec67f4e81b93b13efceb55f94a8731b6be2b72fc900bfb73d47e947e689c9c6767b36f2e8431448829aca28679ee6616716c0f3ee8475d37ea6b7f58ae5ca6e6515a86be09b9070f4d3e3fd4ca45b8c7dcdec26a41672152c8a9961674a7a783ffa0fc2b77c263494da5b807253b0b9a951069dc6cf56b78e1ba09d95df8aa6eac3dea3f469a5798b4f36865aca746dd32f0dc357d025735d6fc256e4ddd15f72ede7e8cc0130c8be275c1f0d38a21f4113702de5e0196c3aa83d7e00455605f6a7265a71eff108c8bf0d7c646dcb1804c2ccaa267bd6c95606b0ff18e4732fcfd25341530cca19e14b3887fa8c1413faf0a3f428ae23aecbaf597b3058b697c33134d2f76ae7041912d37e152f9a890f0a8a642282a0efc538986190ecd8ecc4058cd9a5c3f96992ff76db3bed96d515d15f3fbda096427794b7ebe08a140bec21fbf86d30a9d211fb2b1ea3c8daa751ede3204e94867a7fa3ebc0fac64ae831b470877f8b6fd3c5a5a26361bdb9fc0b2e2e03eba11e52d50b75281786d4411b1209c483bec9abf16f019ea75501acfa8aa1bebb0d9bfbda8e3af66032c8d8a077bc3730ed881ac5470cf6535d283af0c04bd584ddf4fb1bdb53404e5a3282ff7cdce0c4bea0d67ccde5441909b1a64d1c4820b029daaea8b8079a0df9203a1c71598521d84c9e6de1b9c8df2a2267d6fdfa122519b8de2cf5c75083bfefa93ce31224f2b340089fe715743b5747fda516516539ee7217910343e2ba227c08ba1062531f5b3f2086d18bbbf16e0b16cb0a4c55330e733d7a5611f7c836ce3678874996a92d9736ec0d645fb548494e83c28bd46e2cf8246b4c5585439661bdfdb792cb012eb17dc4897e9fec18a403036f6761b1e1c6c9dae3c4df6c1afdc493fab40f5f84ff5a7e0264101f2f73e9eeb07fa6fb8da40e003f5d433e7da439280a65313d9552414ea5cb81daae17e3ca5a56c7f7baa2e26e2ccfc21cab00be787e3c3290f481ee63e4824d25ec93859b83484bba9d1642edf0fb0c0669dd0bc467ad7baced02f7b78a0a0b91648a5175bb4047dd52c945da21f7a5e45d460ab440acdab4503f3decd0d2db4a8b83f9bacdd8732b154b7d029c586653d7f1aff9a76db160e4ea947b7f0323604d9d5f503156162868856c2ab4d014cd52627487c865f8536dd3f94c3cf2e3c2f4759ac5e4f7f861d002f8f8ed4d0b8a56f277526307fcb298b4e96a2f85449dc3857173d018bcb6241f15d00331ffe6fd6ffc1b7dbd4f62fd41e0f93913d59679176abd7cda16fb38021d5ffda37f9b6981cc6a1f85d56640fb602cdbc1bff02a227a2cefa57e4fb8766eef45c8c4c7f37569f6cb732a685d53daffa138e257fe086959cf14f06c212d379d659649044b39e8db81ddccb4d1456b8d587605a913c8b80c42da9f6d1ade982a6633aafd1df0b4562c9367bfd1abb7ae93475c6aa9df2bf5715bca890ba9a1fa82a9e6f970578167737e34e5da5b9d350ba2c4e7ee643fde381e0ba0a94d836516a8c3b7e1bb440da82726092f0bd59cb06078dd83545851a4f67aeea69e384dff8a6905abd1fe513bbeb8db99c17163020d3fa6618683fee981d06de15dfea9054a414040b633b70d831d6c2afa28de73d76aa6daff4ebd72904dd926ff2b051294a608ebaeec035ab5b1f3ecef9374ff93a0d5baf9cf53b32c251f7eb1137295a461925a7066a563bcd0ac13ca673c58a3311e0aa788bb8eb49c1775818d9ec90eda6edee02ab33ea7cb037d1b10f19075de5a7c5299b49d0aff57b61deec8681874c7096ebf16f95041fdf28e23411781d22191332ed269f97a88fc4f97fab3f89be095fb2a8e74711a6e54b86a1d2c9ad4a3b4dd90b1c04584eaf42df08322ec8082fed329469998378b80e1667cb8b044b544a98fc61e56b8d6e6948ae190c216272db9d92b88e03cc759291a40a97eac89532a64f2ca3180451c6b6fdf3b0c49aa53d7a7304644f939b8b05b784eee52f47ac19582289e6252b3e456f3b0b3ef83429e44fb07ba844d91e7a29209d3b1a038540033835820aa6402f29fc680e949d9ad787816d1e8ffe9d998e4141c7f1dd09aa6bfd1f570bb3f184231528e6cf5ddc5216607a5acc9862ba42ef3021f18de32c9a6703a8ca442dc2443532ed7f3be8222b793fd4931cba5cb813a74291b7c567c9d01e8a1760fa9d6259c119eaccd600c5ca32d59d99866336807989da1426950ce9b6ef2ed5cc6c2472493766ba6e488eaf9bce6c68c92b065c438f3f6367d08f0f5d5914d60f4be6bd755cf4671675fe2820b04b867f6d48cc17f224cb88ed685981a6337f42ae9b5e414a79d990cebee4ac64825c0a5bd56777267ae02476ebd2e3e75b325baf00c0e88a167c2e41dbcf7fd45e7353ce811a33a3f0b818af1f0fc0a6d4f125ce009ad70f81eda1e4ff08051b1dab222b2022ef3bbc18c94c97ba9cf2e41e490f6c465159064bac6b40985c816dc3e7503b357af70647bf19885ad7eb72a0e9bb2ed0f3678976dfb72becd3081b14ac4fd03605b00f9c7354d4d2d42322c36afe24a6d751a668dbb80532eb04cbb740514aaa993843008a398dc42757b102cf59314f85d771666e1a3351b6c460d26d01231424a3fbfc890dedea4fd2c05fed5902e9b796216a68dae33fb0270d0e59f43134c9355b39ed2ea00797dfa8e0ccd9557cc3edc8f3f0e46bbf071bff0b2ced57de71868fe166b8fd56b223481092c650140656f4916cfc873e089ffe360c7a08972d8da1b5a71691ca115af7a9f38236310c5497909c92f0d9fb4397335d820741ad044d4842b93a38739090efc17692f2c5d40691abe59d1685c793610b3e6212dbf7ed928f20bcf43a643617e3d52f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
