<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1afd64db7f80c18356244242dfeda5637c155e45248c95b72c71e96bb9f34894f471b81c2916d201577c3cc00d319204b9b2a3d720acab62bf763b32e0de613b31a81d9c6639b6ab018430144ac20b116208ffaa17689054ddc135feb683f6040183ad4705530ccee6ba7da79c8b6b0c7c44d13162250ff86a1857d95e8963d31faf47de07711fee57dcd8145401090c80b590f2282f1ca6a84637c4b742d03e2a4e750eb445d888e59cdd3625c6351154bf282b5848e7eaa3494d9cc112e360302dc55f23d03d6ec795c707922f76e8031972379bb415fc1cb4a4f315cb88ce0ab48d4207182e438dd78ac4e8802117664ae07d46d639bdfa2ca5bc6bd231ececbf76aebf1f5fc8f9051727d58f371031c9bb933e127e3604ef06e3ebf8dc9c8395f11e2e9bbba96d40f09d029c57c0288b0c5be857a370705dd241bfc9f9fd2a6df19268ed0aa3f529b941b70a95209c6165191221326bb5ac742613e1637b8df721b76363e8728a2f13657e7d3a0cc39b68ceae3b67deda68b331361a4a8c5f9315b84a5f4ba888e1db42874137a60b992753189e8bfc1fe31741e37a28c87063a31e8c9faa5f0caf73a2a206e56181b16609afb4231351382d5c776c4ebdce50c5de8d67d0a45167b04029d93499cb7bdc7b8630f9bb9a0a5b4312471cb3f86d9887741a6cfe4ef0e09ff3d23e89b5c21f8baf8d217bb15fab6bdfb26e5fdde78622be25663f3bea6c18684ffc3191be00f8d86f18d372832eb0a028da92ff1092e2dfe8777c2d0d175d0db6e6e0f74083422f696572fea6e01bd93138b3a5ae5bd1d209a8fac6e3c0f0d25cc7162628028d3f487ca6e9b1cdd1a7e637fabe3534a3ff475427b0821163d4ff21408fa4ea1289523a0a6d09d017d6ae0b5c5278bcd298204d4fd501b59b41c251af07172f01bad4985dbe8286dc83deb8cdc7883e4f30b33ebd15610017d1dcfb80e0d2d6b0a57851bc28cbd455d88d51ca2d79f771a2df6f68026f69bc06be1d5b51f95ea5308dfae5f7b13b5c4ca4f90791654f0aea7587623f8a9dcf6d327c476afa245dfd66be16e79fc8f7de357233af50d712d3e0e9ad656ad5703e41799fe8cbc7a3d00520cbb5212bdeae43b86962c7cb2e3f34480b56d1e141df731ca91df5cb41ecfb82215ba851dcca36242b349b22ed67b84ecdabbbb21172d8fd7a9224f24f01242c376771428397ae919ab3fe964bdefb7504125021a3c4164861361cb1e8d0485f2f5307c30f240a4444fdcfb97886f9d486d7d7f17707d7f65f47136e2f41627dc4c2a6e56816c396e1eda9662d9c5b0d2279c344a334e18a2d9b76cba9f4209bc5aea8214c5553dcdc6b578643330fed11ac6f5b9421ae08c0e99b617f923e08878c92137deff2836a07c199f12922b2899dba189fabeab3044c55cf54d642e9fa027dce26f4f4f7297e76ec376cc6662403290a2b74c1c8cfaf0fee74f7d0842660bd06f36b37a64c605047d0c5170af2c2f14140fe5e66b34e747b97d4e9fcd3a8f9a4cf606947357e3959f885e904379615937bbc99dc52088aced7f3d0e6755498ab82227461afd37fc98bca356dd9ccdc5a271e67aac00e0da67c93c55fa44cf7398f48b7acb73eda59df0e959d6c2dd7453d3b66782477cda1b1935ad8389075f304bb073f871f57dda3a1c80132c70cb0b9431146b7e0b340522c51f5fb9afd06ce9c523f2abe55fef6d24db43dfbc903f115498858ae037a14f07c35068c9dc111a32b8db48702b52e106c045c234004d17cedd214e7c6e5d3b3a0656a48f431d10e807ba8e29b4dbb780a0e58cd2ece5954178ba578fef3a92305551021f1f33b25e1041b20a5703602c9e9215395485e6486b67160cb8970cfcf502acf0cd88d2653b36dd588e027a9093b5ba0f6115a32819892b65602bd349ed951b49a7f921c221d72708803c44d426dde8622a31c82942d9c04e7088dcd8b51ebae948304b3370d5fba5e464917795c78e11fa86aef9a7dfb13d583aee102c11bcb391767810f7828348e051c256270b634517065f21d6e22cdd46c3c982fd28e6da75981745d70cab3d6331b6b7df9e9944e21a0e65d5bac1a47bba931ed2d8fcc2599be081fb01c63c745d54360bf92ce377fd56328766c41ffacb49a4e4f72d53909fa0b6b1ddbbf1326ca10ccf24947b8a0e268f65959ce7e7e94ca530c93a759183b4732af6a4bd84e09cd3f0d470c0aff97d4b7115bc527c0e1036d1ff09502efe90cab1764f5a6b4d23b5bad72e2d158da0041a8ed663ae91edc12bbcdae1844144f0b519d5f316f96ea62ba785131cadb70af1e8fabd776f70838232c4bd3c3ae99367e955ab5627a0701638c4795e75c187a9116d6186ff72d622ba74bce0a133af632194e1487554d0aa8fb5e4062823b1b1ae62b8ab59f479a1068822ae5482ae90c43d2349c0403a313f9ce52d70a17d27554604fc79495a1f262a7a0a020034526066b2a5e442e3875967d499df72d5098a12385ae5cd64104a8cf3143ce31b976d74ed34bd05f89338c8e2d755d3ceb52522b2f7cbe06623727115a25b3071042ad58ad1cc211eee5f4b15536eac81c9bafdeeceda0a24197c4edb4e465e340d9cfb9921b579c27d18e1854023355760ff56c02ec2853345f198d324330373e6cf94f986330c91f201a48588ac6c8afcd59aeb6a9c18c1e4cf8cde906eb2337b864776eec498784100cb169eb3aeb582f1ce3b917a60b255baaf5c773d9a9a0987dca3724cd78770585ce6b7bd8135ed42806ed15e2de8c04dab5464337f3f111d2a8d7ec00892d521d72efa38bf4a32fdb84c63ba18850556cd76b3d13b5040713be12ac616df49b9ccdd976358f00b1ed3dc9131762f6a9e295aecbf0b34fc1f0eb05f7b6327428473352152adafb7a444cc7a700b8b4412d5e7f010fc541216dff3c121c8743ddbcfa00bb5f31168a00dd7e023cfefa2bfebe679a25fd62832b0509f888ee6f1087af1979c6dcd226a1e21e8c8ed0ead6ac064da9d89e0bc7971d45f91f7e7b480f9fda4e2d4baf1b0afbd0a39a38942eaf4edd1f0f42456ec421adeeaecbd5107e214341a996986af1258903646fd2500dec304bdd0e3f038752c84fe283a9026922bd1841a9f8a071bdde884b44759a83dec1d8f6a3e99c9081fa1a00c857f71d7bf22c13149bc4fc6458a09bbb9c1bb553ed915dc841485ae5b5d22378a444780d3becef2b1cdd5feff3d3a935a100cf717d2cf0a9176a737db8980adf83e4084716eebb1b4db6f879b58c3a033f758140ea30c3764be67286f9d536a8eb84e034887baabdbcda6005989c608d02cf3800df28b4410d490824f69a387455b60cb91ffe233448e00b49ca15ae13a6afd31dbedb66c111830d4afcc78fddf0ee5e8021dc09b9e422c72eccd204b4303b7ef489287d6753979d6417a35d4cdb88afc36fdce2cd2003f1b42f18cebfc44714563921c62c47657013f6a25aba53be489cc527973e394eb198235d9c6e27b85dd573f293a386336467b6ffe5811b0f1dc483728f6d26d7c4bf77bdbffef1d057268b8a3f8f5f4012ea9b57533efa4bda2094e67622ca15d04db9231f82924d32b5edd74eb6c5ee17c76ea6bf398eefb1c2d1d3f63bab088faa6a82bada47b92623a02edcab6de5b3d407ec3283e043b609f8f6d21fb72dd9d328097e3a6619d4faef3df06fe9010063dc4aa46f98f7568ed0e79d702d3d4c4bb83bbc62c14b38af2501ba8b7ed37e28d8af09c9b0d867be00cdea2ac6e1bb4ecfa87272d54de5d85478c5c6ccf54f697ae3be3d3fe19a67bdc52f019ff6c1055201d6fa6856cc7876962b96e4ac03ab09521fda99d9344623b1e02f8973be45df6a9d82038b712692d0ec4f4e926c7e400458c25a1f919fd97fd3224cd3390c3b0cbb220957232cc6c8d488d52cb07a6c34b455250650e5866db02304663c75fb1e96d785c08326a7141291b8d58caf11c05583bfad069aff03536d249408e8989a29b130a53a7db5d21abd3e3d2c0aa51e36f9a14c0bd3c9a6912d8b66c6c8c1a74dd5891b07d4c036dd4ce680fe94584b14759d9029874b37cc7e6f8d827e1c92fbbce6a11d2bdb00c326ced0bb6cd0cae899648c0adf90264263b74dc3f205830d342ac1773217c43a460f392809432516c87d69a5ec215b9a0f3f8b7f1e47af388f783166e86246b89180756d16704568a5ad3e503e0a899c04792b60ba53ff0c915d927d9a21de8849a06df9eee319ad556ef61228f21e95a5f9b938d16d926b7f5c7d6137a1307e4c2257a2f7f699371e9bfd9de01dd16a92399529ddee9f30d17dcd62b4493388bcca3d6aade9ce16172deafe7a90d6365ace756213f452d641c783f28fdf96b28c9da2529043f2a6f460459882de922d978ef1684367b6264b98e4be851fa8298988285d58876fe6afa17e8321574c38ed8f2f2b49d154039e90a28b37524f9dbb73159a1be0ca11d3c8677afd473c4d45856b93061c57b29ebee4fec97f1fefc8f915cd948e470bbf6d9e5d66a9f7ab35cd53931a30f1eb48dfa3a1bf9aade7202a591cee62f64c036837dfd08a77aff768bfec6e6ad7a6aa744301112221514a05b4bfe91a9aa6846fdaed298d0a0a59868a169e383b72e4313c850a02569b8c30f16053c19670a9e62555468f7984e94b3ee3441b5f4d1388b8bdc300f9378af6b79422268d3f61412e4af7aec9dde75b1f0375b663abcda4a29fd888dc436e9d85d53f1a580a8e402cf7c8ce4a6f5dcddfb03acd0bcda1821abad0f1163d7cbaea3ac3b0bfed28643acb6dc018d23f70617d349ae835adbd4d626c41e1422157da74965f74578227960a82833d1a19a5b4f96105d00d52fffa15892ffab9dda74a56b0dc09664dc81466beb4848c3283169fa258382752bd30595bb9c031c235c46d6247b470203cb9f189065b09e72805291c7840f3feec2e417b44d72c473e3a787c705971c99108bf80c768ea122eb9acf7292e9684bd8e002aba7fbe0bfe60a5378561eb9407548e0b90e39f5b86d495359bea6fdf477bcbb9a52fa3b2dbaf2bfe3ad2a6c336d690c41e511e478589bb2b6a9c9ff9bdb516851d6149d8298fcbd5a830b9d1da24ce715875a8358bf07f42128941e04eb0c06e062cd783cb8c3a73d90f0bad2dd2ebf5304993990d72b089a5cb85390b746e53d28e39f4ca0b19b93a9b23bde3e8bc4e6b8fe4f12aba6c80ef676cd31337b943b5862c2dbc068cfe9e966e6b698ff12ca226b0dbcb087029cf0917943eceaafdc41a0b91012c501c12bccda1011ea1df67a147cae0e48f427ce21db928e730387a290385bc82f1337faf9b752517caf8fdd3b2ea35d42a868d1a3498de58e8a6bba01e8585348463eef90599d35e948bd78446272ee2f2d37265fbc6743e895ecf76281d258b28b9bfa316e12783f03c9ed60ac6b03c65d50be652158d5e35ee4d86b6ca29e276330d656edf8a40fe34c5403297dc68452df035a31cdb9b4eaac30610d36a40baafa7916ba1f45de3c375ccb9606693b1a6254950b656ffd7700456b8735519d9f1143db898a8aa7bfd51f7f0e55a40d5ba172f94ba4ce0088361650c95cc6aabac10ce61198dd4a054c84f07acdd93825e14e964294c76a23574db64fe4f4d3907006ef5ee96bba808dc211c8a020d8eaa7c81b07e69ebdac8fb6709c06e36648836baebea80600c78ba8014aa199a553a4fc343e52aa3939034adfa296e460cbef92c70de8c6f2f808a69d951ea7d4136ff067fd25c442e0a9da6bb8b1e2bd8d63c41036cb411eb94474a7c0ded8856f4d8121ed888116a3989f28a4c502bc544ede6b297bce7b0578fd6a74d0d27b112975525b9254c4638edd3122b9a8a524399dd5b9e588de9ad247ee41defecf669cff40c099c346b2436fa707850d2993d50e2b37017d70b580048c8ed06b94fffce66611e51f9a9e2195e859a0a307ebc255c4213802a7329991e66b515e4179ae829264ab52196d6e2487be291aef666477d0f79be0af237896a19daf5624e7962fd81525fc24538a05f8fd50408ad30c4621cf7542657cfca3a6159a670ecef14bc1e5199979480435eae520968bd102d8a0352eb0e1b938bf9bc1800e1777ac91740ffc1242bd72a1b51c2683c3f09c0c256ce43ce545dc8ece949adaef747569c829d22747a792978b13982e7d0bf939f5f3920e63df0b01a8f023a5976100f0485c1d278039454ee15c3565717febf44de52fd15b13e4ef19c60dc09de2c479d5e816f9b1fee1af63a212e90792b3a61c07438712c3bba7cf1b81805919a9eec08391e2f14615acfe6b6529e78f3b35af5c24e9e4dea71a916efbe54e4ddaeb9b5e3a281ac2588b50353385d2c2c43a57db3c68ef1c22036738c0154108377e862800a4ec8ed44735ceb7a83bd2f3407ade195036141fbe46eea652b7c2311facd5382eb365eec1155547352a46c226c1e82f111b405e8eedc95cfece78358c2cd9e142fc80f8652a7528fbf39e86a22ac297dc68340ddffa9e614f15558d27f073359a5bb650f40f3866aa873a9f1a1eb07f5b42a9240bc59be70e55e1639138abb01bcf6a404256293df7229d0747e1132b0117dd2ea2aefdbdc4d8414922c67ac3479c1cd748d6e928ac33b27561ff12133431913c561811d2542f8b3deed3fd4f3e27ade9151d5fc8d9a0fe32455be683fc4dfed9e1e00bec3b84ebd743b2a5d976a2d8bff22e50c5339830e9a34deada675699fb74fc17db3190d82556a3e599621fb98b0be89b00af0992db39b12a01145400c8ec1d4eb84074c1c14c6e7e083480f91eba7e0df5cd467c318404dcc1db1809c4ed612c01922bffc53add84a928f978fbe345a3a852cd3a5709822a86ff6b0c1c1ecf62cd37ecf620a2a74c16d0eee85ab4b5f70025a97a89d1a45a13fad39505bff13f678e77d9a8fa050d97a4069b25cf19388a424a697e135e0f6675d669f7b0e6fdd15eabde4b8948f21069e1f4ba6bd05bee5962eee003116317c500b0e16885e594430e85f8a17ea7f665cf9e75424ceeae2f8087c8fc17c1f2ce6eef38545dbebe7b814c99487a6075852bd4cd05faa912b06c88ff81f9c40537c130ef82fe1677c705d1c71f7fd3840485fce241b46cdd548fd22a63d1e1ab28df8db22735af73581d65a69f088a07b44ce17a762f809b8c013dac8e2b167883c60b01b89ae4174643f70dce5104ec44188a958109351ea0fbb4d92b071351c7ae9f3d0341c4c1b74458c3c86975a4987589b1a48e26e87c6d187970efe42039d9c8edd4bd51ca66b081fd1ca79229b04cfdbe381fdfc77c28a03f1aa31c1da465cd3c0ae9656919a6dad4aa2e0df009f1a8be5b1470a57bdbca93632c09c77e0f685ae5d4657d7dff7d72c8be98d37d05bb0837ea0449ff0b94e827438435d55db0285540708740da198c5eb00dd021c93ec2b8d5080fa87faf846d1f0b2158ac362b34e151f8e126d0c3ffc0fc02decc683d117788f554dbc5c1ecf78edc979c91acd589f0fb0c4e06680976e8b8ecb3f32ab5d9b2e5e932cd6f0bc759af05f47461922680b7f03249d5477372561b0040c5871370a1e4f8fadb142e3c507d25cc033597382acc68d8401a016bcef7a973a787171aef93cc5d63db9049771a789630fe1f3a2ed6f12b05c2d08cb360b0fcdf58b7345b0939615874bcff65c9ab98a028d6bab195b8aeb757cf8c9a94d41af9caf95d92603d356614d8b7300a08a37ba8424f40cabf7059a5a91568666f5e8abd6b114be404beb080efebe7e958aba6a565aa83db1429542eb1aa21c54ae69ffdffe3b117aafe8722548adb8dac0b152887e6bcfded67a1aecd7895d4d4820852722c220d729c97d67647e30517b0a95c3fdff38a8605f8042c6ae78031d2a9af0a9cdffea1f7e6454fbc8b594074132a5cc72e981866475f3f5d7711989369db57b994cf790a6bb5b395390716c4d62076e7b3197f906ac87e6c97b318656b8fdceb1b7cca0ae193d7287ecf4bbe2b1397cf32fcc0d39e50f45dd8b7a95e98bb718aa9cb01b2fe78f640f23e63b7d0b777e1749477277559b9059bdac453534fb920606c0084ec950f63da387b4d0fd1f4b2d08d502ce5ec833a7ae3dc0d55d2f4cca801d306a43082b185b1b5a33287acde661f692f1230ea8e7992a06cd4f84ceec053165ab78ecd5cc7e08e5740942bf0768f234a9914330b515b8c2f97550a630d527fd958daef0b8afc7c66354d695a28e04e6e893746388f3b89574db677edc6d338d5a690899c9baef37dcd2780ad046708eccd82130e9a611f345d3812f3c5342103bcd1377ccd8ac59018bcd5d1b8b93c7fd08dd8dec74a140f25f457630fab84b8a8376970ca9f8e04ce70dc08ba77cf66a590e41aadf73b27d5b95cc5492060131708490fb02b1165f9f49cceb7c509962c1dd6aadd24c717ff710923452dbfcb625fe3e59ae593c78c69cc3d5e125e937c20cdde62787107a637273f5a8f4d54798557170fccd7af2af234dc9fd7255369bf88b3453b61a3760d29f55948810e22da5884f805e18dc70f8154fa51c2dabdee7dc5b63caf5467416257b5ad98c0fd3f388bdcecaa9d62d247ad20a57b46144054e00537b378a52ce9610dd2561734075d28c24f31c620882af34408ef9a1b574e09881a96e945a2d3ce0c0a8161bfee7f0ec7b4a5e516e6755dcff66f783358eb6a50c902ee543eb99e23afa568fa83a62889ae39ec349da45862b6a6b01894c0fe1af9f355642524b1a7e0f11d4aac5706b556ff4e53dea4d520c09a7042098e3b63289f1ee6f9e69f284f7b1f3f691a50219141dd54bcb0d3114613669ff0420e37b25439ba0f0ed3783f06792ba6f479db158b7c8c7ad2007322023d63aed3de2ec691896f70633fda5e168148bdd2161d46ea9efcfd596bd47e9215d842948986dbb26524cd27a7d0645fec71593fcbe373d81da74dbfb55ac49ef26d4799b368f20d1da470de19b8ba6a3d794c6e15218cf0fc3a467297b046888cf00c4b63b1be176d07573ed0b9b0d36096504c36f0887d0be9ff2b5b2267e443d1e41ea40c43d5a7ea13590db4259d50e52dbb5bc755d85de044ba62897315e3e0ea3edd18a92a42bd17d4cdc8b76faf9e0f1d24a76ef5c6d666d5db777a45cd34b8885aeca10ffafebc60f1cecd49a49e81c249cb8762cb5ef733d8b1c0d7f45bd9db4cdf430fbd2aca916dbba5a6e5600236d1b02ee871bc06675eba9388944d15a1712dcae874736d933541fa2d7c81223ddfc148243f448113bbd9ccf3475bc786bf63d3d77aade3b9bc5550d83963390a80bf5020f8032328acd073af9736f70eead07ee570d0a785599828151c5830f76bdc998c8f318126752a9fe34272050ac6b52b56832f5c5e92282bea2eb868a97efabb08a03ed7d6d15709ec8dc91868d884a56c1a29fe9850a78f801c6e7463670aa85851f26b4663efb7281289ec6b1fd42cc44d8e6588f69d5f7372848ebc5950cc6b82d3b372ff2a749a8f8e06110ec125bddadb5b7136d0a55d8c1dca397722ec49153e7c364238a8c1ee87e21c27e79f74983150d16b3d37b142cef0ed224d8cd30fc6c56bdae179785fc03729c43eb9240ba32a9cd1389c5711825fa9b6fa5daa91eb6f4f4298c5c88a88ff67650484832cc47c3105935573bf8fd5fc441060fb6516f01829160aff58ed959c540fa7bf56bd5e7489cb6ac2558656099384664b6066ba5726c4f439212790eff6e919821df72387dfab8172daba856540d0fb3e9ffd84e12f2f83a31abfc1baf174c2b2ef13bed9370ae390ca87bd707eaa58bcc319fc32f52d7014089ddfc11ca950a9b179e0334fb2de05f05233b630844b5fa06254c2903af028adb2019f7f2fc12c9741efa80ed71c08da296cdf9186b785bcc823477b09a080ff3ef384eb8b6e87e723e881d6dc2eacca0bada0b478ee1966913cd1047b6fa0d978228ff4ad1db1bb3f81068e93c45c627b986e0da302c1d07ab0dba544321703a327042d3499d0e0e24ebfeb8f930117c60e9cf67e42295d11a327d99d3be5e1757fe94e3d57700c40e28468f43c93019dccced3876340c9a8a0ee3da2c359e1c251e80b5167f4df29caf460169b63160fda72b024bf55367bc505bb562b08e7520346830211a9fe4cbf83a3aca837380565df3853fb655dc8030d7cbe656ee5a5b5fcafaa6a0abd7de9e287ccd906ef5c9aa36bc91c2041a37d31b4f0ec65ea031fc47da4d4aec41c649d790f495b121adb8505676af8f8cc393d563df5155548259025ff15311b83a0d0a038a1f45100882dcb3a47e5ff1608ea6426dc4eaabc55a41b803500494f222872ff5cdbf973d42cdd2afe4a5a4f104cc890e6d85b2164e594bf5ca988fd4aaf28eb43aae6215309230af3ee30eb1a812cff4d0bd84327022b71769e4baa25e85be66b1ab42bd1dad16b2500c4ec64bfc9f60e2201675ee0291a22892abf8d6681e0aac91397ddedb463855820425d626db82dfe59db66d85fccfed13ed1f7ba3a2f259b6cb7f14bf077c436ae5f16e9506ec1fbf4b7e342e0b88374f69212ed1d6a1f6a7f4178c496fe48eb2ca63f0f9139b09a27b334fe8e19f3b0429ce1ea10ba4bdbed15cbfae81ee44e17705bb49160960fdd823c8261071c0e80de36cc51dd26a0f1e3018921590187feccce344c36d2f35c4383d323eec77e3f9a8ec0d23a272a0afb06bef50d0eb394b279c8cace93cb6f4bcaa66161fb34edbda15e6a57ff757b6ea0c313d52e64f2cd78e0d3b728b8775422cc570a3ed51c87592de0251d47919dba2bdf800c3c2f3ad7dcd67a32c73b3a1242b6aea809513df19c64d69b647458b8218a7ab14da972a7172b3fea3b0242360ec2ebc5ccd7d51c407298c0212fa5cad216944968cf96d2c36da7b6f4a21dd248023f11ad39f2cf0088d201d2b810879d3d245c9c742a7d75cd7c80bc4be4a6ad6aa060b2228a36700ef85ad24b15bf2c0983141776f280a4168b130e2ee648b4ed4fd4aec0cea09f398b5b0a8188f07c7fcec96f856a83ea2c9a6be69541597c55fdc957ae7473cdcc0e3b00b481da5b927b967ac395a490a91dc6f669ea60633f679b326c04fb4f88050057ce927916e61a14a4bee7defd578a70a2c3803730c4ec57339a1dfe518160c42f75502bd37f46269c578b19bac1f82f2ef5dcac5b2a8499fb17eccac4e35f13d1c1c49899037f3ecc54d952962afb7d8eecddace8c93cead81d010bd8554b009f4a72b4f688690b23373d2c566d08e0ae85e7ad2809a3047f99b73d9817726b1686dd313008c9085a3253127521e7219a1e86d8843f15dce89f3502049def719048f2183abce8e9738484cef54f01dd17d02910eb865055fd46428aa35d0cd615d974a4f5ce814e6e6ac6f55ed36cdc53b5d25cf9a85119660f412b49af29875a9d7fdc9c52a32cd53c253ade5f1d82cfea61a8f6e4e2db551b985f5f3041bd85939cddeee83b1a03ce3c63f51e5958d6b0ae38408dc39daeda31675efc6e901fc8d6367d190cbf2d4578905579e9b696288cfd71bf9a924edd1467f10a759c0e3db89d4f4db3941e75b9a1c1e5be034ffb3421a4af581c668b17b4ee78058c0c76fdd6f41544d6df2959b38b20f7f7643e5cd25add8f74592ab93b654c2c02e8dd4bd6d5cb829de26510522d351b599741510b1ea29bf85326249ecbe0ab8ff29aa92c86dd630181cc610a0cb14a006b4c993159fb30f81916fb6d3e883f017acc1cea68329dc29e936bf158e141c1b60a4f4b79de21f0b46e77125838a9e7cc66a73a0669f6e3d00b34fd9502201b25548991766421632e48dcc51a3299e68cd172731d7fbe5bfdab38b4e5d43b074591ce3ec6783e5113cbcbd4af096452d6db22becb8b051ff95a26a110edbb8d376ad15676839c988f67c03280d993dbe14b418b4aec968236e7546541f8f3ffa03ccbaacd454f709b44484cb129da505ed8fb9be51f58ff8fc470f92e1ebd115926dae697c1289d9d39e79efee69bd4474d179c8cb853469be8a638534690954b455b9931d8092dabf2d4c1bb44bfe633e91e4d21766c94f75f9962954e34d5efe654a0f903796a86acf8c08adf7c43a7caaead200cb56c66900e3b8c92adfcaa17301e9783a10d30cdaf412c9c608ef6843a1208550189f1bd47ecc4b7edaaf539cf3db0864bf8adbd8afa7a470b7eb5b920a5cc1c67e778f2c33faf9031fd125e3a7a24b9ec006a423d8fcbfe59e20fdf981c8035a382b5d2789991b1e042cde5dd83f49b6dc83f3c9a004757b8e836c3d4fa59970d2c4821148e63d178c04124e12597455a085cdf8833a36897543943937db7e8e3607d85f97a8fec40d16583daa2d38efcfabcf92fb038119c45474ff6eefebad9363b1885ea776d6e31e129ff9147c316d2bba905c95a898936e242eb5edb8a1d353686e19dd0294701aa4ca0e1d0b0edc08f28ea628a642330c71547f37dd79a0d6e4afe7a969218d12cc64aa25f0e1d8377eb6fe5427bb947f7a125ff263f853048b9c492de18e881f40e24d1e49ab32357230be6c2889c20f19b834b15647dd687ff178302d3603a4f9bfaab0865175171d1e25f912298815322481f25f217e5537608e737a1a712ccaaed57e1fa57b8fbfda74caacb175a050d89cd5d8bb3ce7d0bc2eca5e47c23d71c077cae36e614c7378121e4ab73a87d11a91d16922c1032fc3bef66e398bc901b1d24589705726628b40872126e8a57cf44137f2d0ea56542a8e78dcee2cd383e5feb6db2d2557b6f6c0e9473a8622959c1613d0e88e731b795faf36de6e9d09aceae7d9c38066439956a51f0518efe8845d962cd1285a9e815e0c838e6572f718fcf9504599af9e34bb699fedb339374b2aec4440d49da6429e2f5b57e9535d41d7f931b3fd4e71671765760f8a860e130c366a39bf741bb82e864ed166bfd3e94bbbe3fc06f29e1f727aa289940df9ea39bc3cd1d2a19932c649fc8295be161cf76d6db9e113cc23907b0923085d36d782f25641dfd30921bd911e7485bc90a6320cfdd26b8cd46d1fed05f2ae7166feb3b7d0607bdc7ccf32b98025af54b4b3695a4ab882c00b3782c6cd6d4e012559d01613e689e46e87ad291e395ad82de3411fd32f170bff680e4feaec41be135727e44ee40a107d2844e7eb8b496aa28e2bd396a33269d735610a55c7103d6c7a179b85e42669d8888a60925e968f96d6bf10d8d1f15be3cecd41121228cd2fcb1070153a641e41b4748b8535fe041be56dfb848e67b44cfc8449d321ffe185e26f8901a1bbf74bb1089015439241b6de78aa93f4badf04028ea7b99b7de0c0f0c2105329a4763fd5974b608c6e745327efc0fcf25f47f99d26c603785a7c674e198432d0559c11815fb4602187fe4f5c873a54a5a1d7eac154735f37baa373402cdb50b58dc19188fe5a28d2a7851602ed0b9e0987d31add61f310a977604a4b30ae06653f214b650af5211d9a5458d3b68a198b651f24582e0c1ac7d4d2134989c2c45bb7de74bac63884f4ea79fdf6420d13d3bfb475b5e30d9e3e0b40c7a1822eb448ac1e7d012e3295e56443ac4ae3e1b434da285fc682a5b23382bda0b204be97944a49efba376b2f8ae979989e737849ddda366643491bb8e7ad0d05c15d6084aecb644661f374b47b1abda5a75720f80c10b7b09aae9e3abc21570938c0ba0453a37336582f749951ad118a9c9855dee3ab838059583fc361dbfc6fe23243290269f5d68125096cb714544c80089f6c7192cf70a4516d49cbd812e129f53c545092801e885123659f6714ceffc5213f0fedb1d390c21ab637147622156d2ad07753eb6848d11ba457ee0e7b4148a648cee10c3f01cc2ab53fc6aafb01ed4003875092b8905fc38740b25e1973ab4e94460a821ec33e4ca5c0ce19b48a7f9ad2edb40b5f4ea0fb7194074657add867265179a4b279192ffb858b3b35e834ce5a8f845a16b6ebc920e70ff01bb294943221f305ea9ba605ba92a9a53eea73db2d0d72879995bdd0fb8174054062e81c144db182d4ab94434a60dd6e8e597a0424b0aa900b5b4c8bb0dd17dd430521f17cc8ce2d250043ae08c84b6264976ed0c778bb524979fe423fa310b060f2f168d0f0dc5dc64ec99c3670c39195f4ee4508b7220044102b5fb1b7ffcf480b0393a15ba648780e1250d0393b5c75b43e44aef2f0970b1d9b8d33871612b8570f9e9142acec99dfaff5c04ed67c709125c2370cb310a82e2a48693ccf534c31507bd5d53d2f7e750ffa0340b280882e080397c02b2e16d73ff241ca914d6d3f2058e01c33230db3fd9031adf13b5b61453596a707e924c19004b63164ee3b68b2e5d62ada6292d7c756fbf99343079ad05a3bf1709b738c196763976d1fc21c4e2c4470ecd970128dd4c7e8f591aa47d8de7442c3bd2a8eed525ee8a67243621520f0b8a5e297fb4521d75fc0aee93be5b524fbd6833642be2134a7d4814756930c160980661ff75972c6dffc9ee7a33f1e880a8040dd11313bf3900f99cb22270a8acca46461711cad54101e21e6bc6946827f21cc296a8eb4cbc6ed6043158ef4ed84c982bc6b01753c6f5103553fe1ee5cbbd6925d39ddaf05e7a4602bde193664ed714100ec514b1d26fe47494de2b94dbeaea6e91cda26da9b1bde4dae9d582935fcf4b7bc27d2e3e8c603540c2d712746f5ddf5314acd1b131ffacc4058adb7d7decd9248f272a5854a0f00d386003f0ceee72e097f6a9fbecc7789bc2d93623ff4fdd7d1efc45d898acc93c17633c648c65d675f67e2dbbd79447b12db0947bc1a2f4762ce819044f9e39b0da0249c6864e73e041bdb67d306fc8f0b7c2909e7b335d005aaf47aea7242372a7f959173362a4b4dd36f1943a0f773c5b435758bf4814bd142de151cd995f39cc5f824d91e3eea974393ad5cb9faea8d9231ef0bf236d4c00b164a22ddd540b09adce627de51913171920a3c7cc7e99d52c80e607e6668d36d81f457256cdc95906e3fda07fb879789e7fbdae0eba651259dd8c80abe1ed426cb1328068e8d9e57f0affb0e20082ad0b709d1b3257c25cfa7b6633cabb6bfcdbb018bb94abf0e4f6ba62be91b4d05d68cd42ea0f0a98423a6b6e393b246834cbe53a23e5151fce6e96583de3d64b30e512324da9b1f7048b6b35ebe87da699b93ff3954c2c4fa080ba0b9f725999b0002f65c6f49a1e4b26c9b207952f9eb8b3c417bfb775b4981d22cd7d6f7918867ad789969ebcb6d220e70e79f85cf144be0082f5a7681ba5c2cc190c3f9eb961e9c33f17d4b60641fb59deedcdb0e38a9a5d133455ab89ece07cc6648365ba58d479b16de1d93fc8dd7a4bb44fa7528c755c0c2227b6f113ffdcacda7037a3d2d3476a63a72e6ec4ff144670e200e071b4da44665987c36f137b3436811d76a146b35e16b82c649929572b4747a7fc2babd08e2c7b8b24c69c027dcdbad38007f5aa0bf78875e3d1b0b1bddc5a7b22f1b70a81d7c71bbc1b2d19fb60b6d058039e256d09d30de5b426b94e969042bc618ba77d3e5f30bb64544a8a3ac8e90ac7fccf3a1f440cccd0ee75d7adc8bce0987cf83f1993ac27d6b7cce11b5188200385fc66f0bfd263a75899dfbe7ebc32dc117ca250e40e1e3d0f3044497cab13584a51d5d0427cbd79927f2ab29a8ac2ae18cb839a2ffe2d50069896234a06faeac72c3ae006666660fb5eaf70203ff4b250140cb50ec2fa2a654a4d4a4a55a9082fbf0b966233cbc54a17e80b73d44e0a1fa68cc8253659005b90fb9be05234b4b025dd29aa6ebcb90bf893507cb8bc25441a198c62d292d1dc40fbddb3236302cf3bef37e00a840f2afa548a97375b0a9b20c237860729613ddbb44b77cee29d1fe4167b2fe87badde7e86088d2d81962276fc766ee3ecb9de9ab58335611aa933e48e03e8f03022be954eb3e31b245464e18e9057f6812bb6ab7134bd80ab5b2ddf092ca18aab4e77155c790c36750b7a34c0341590806ef688c5b1e3ba8c568988937547cbba6f6481a616548dba38f2b9083db0b99aee91cf3648c1ef96be01c49670bbfcdf18edc7eee6f2a045f826e31f01e6acd5b175a668b82424293526a852970321df49bc22e08ba0c8306c7327d06a48334b272ec1781b9bbc64c0450826d23beef4cebf4d00d7b9a574aca88f502938b859d62b1ed9f47b966291597f9d90b663ec8c8ba190235e364251a6fc591bb52ef1620b47daf58318caf101d2aee81c762bcfb6b9d41f2524211c7699cf0275e36c15f2662f35e2c3720f7cb5bcf153a4d4c6a9249231b33dab2b2f522b514fe2cf779f742466c23056659f4bcc9fef4abdfb61a38f5c012654ecce4a3f30a0161d84ae4a895c74565c1ef830b10724f26027a0fdd416d7d914df5da9cd5cc4cf2d2f09fc1c185a278a3e91d389c3b753ddb1ea0f82eee88387df95a754cd35dd6cc0ce065078853d95640f904198b210be589f091afbb80c63a4a1e60b07bf3216cf109de4699629be7967e963242147b8094bc115d51053c326efbb2086734e1ce5a07e7c1096a82c50c1e02ae37b189f32594847e01195dbcb2571f555f1962f5e7fbb434321828d6f2926176cb1855c1d04def8c1e655377a067f56d5a30c4d3fe0fc9acf161adf21dcb96c60dddbb5898e2b45fd7624393d0db480282d7fde910dc1619f2a9b04f77fb5417ef2f919356455bc2116f2e49c8d4630f9d5366ff400ec18217a409202bf17d22e26eba1da4180789c296f11266b334bd3c8534158e4a9e7b311eb415f99c0e9381a6eeee1241c5c25f45581cdf61979b52983aba23fb8cb3e1bd0d1dd92e210d1f42d192f7d5994439fdd9b01e62764309f127ea7b1f0457105c72e605136db88f518a60cec8ac60179386d718724664e11889e303922ba35f309dc4d193352a5b1a3ce21af915d1040fa4d344e004abc94319063ce76e1a872aaee7c6417aa125066adb0a908e6f2b4acc689e98512af8bd77a87c7da62861015f5418dd16b7ef3743fd9e83f47da2997ef5aff8ba432d79eab82768cae47c38fb286182c2b91d9ae0cf090297405c617c0dc1268277868ece9935b8b7fc84d39c057485bc231cd46ac5963977393e66af0b34da58968ae2eedcd5dd816b15ea556d309e8c5a88d23bc150619147012665182eb4195da2280c1c22800d12301d1bbf6953328aa6c204423f5699189808568381c3645cc8cfa4f792e1741fab9d8de3a08fd84a8578a636571ffaa3238ba1e2e566f01a002098ca5360c953ae09da2d6ef051ab24e58d3ba987c184ef4a206e8c6aded057c0c8461a6f3ccbc5de3ef90354d7d76813798babf8f85635294ac62492eaec326c1b20efa37859d171a418b6d6dcbc7a9d1ab55726ed2d79de472488aadad3a8d0b4f573d342a32956e95eea5a271df801ba50d6426cd13e02354667ba37a209882d5b37e4c014f5d59a8cc56ad669af15f2902da043e12cbdb890179636e7c7d493514fa5d2e1a6fcea52a4d62cc2c0be8e7762f0d7fe1feb946d9635eb544bd33bc90e96717923e01d1cc79e46fb064a07fe477000bc9f7fbb7c608b3959b3708432a8a9fbfb8de2f8a2e94321be6ab2b7df7921e68786fa525d6324e3984ef6c245810ca22cf0540da5676cdd7a7012b1a473d77d57e637891d8ec29d0c359f5dc32b3eba0aff61f59a8dac678c1eadf9697031f00550e7f7df5b59abe7f0b549d742a62b566f6b8e1357682876ec8a9ebf85181cca06f611aa7b4b1929f4c3c29c6d6d3cde7c573376fe18d57a9e8b397e57c33bf7a16f2c7f346da0634be7274b27d777690337f171e8a9b89b351b5685644fb6d5c8fadd04ee0a07b74ee864d4fa5e086944ebd46d154b16c836bdc73f2f8b3d6942877bbcafe40500d9dc3cb2c245569254f61d3493bbfedbe0c7b9d69cf7a826d9f0bb8a512c6277fc1791845d4dfdbc971b77e9b34d44dfeeaf2b395e5dbbf46152eed3d037baa8ea9cc0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
