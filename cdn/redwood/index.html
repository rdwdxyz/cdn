<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6eef7a9073fcbaab2806f997cdc0f4cc8d6bda451184863e1f3abe8b88d0059775330938fda347253678c2b4956905af053997523fc34abe9268bd754f54e313bfddd94a291dbae572a514ac75251c91781dd8494d00984f2e1add0a060d0aff37490aff3f47e2287f433e35a6e9b5bf6d90a2176e24f8e619af8667b98cdbf786ef6a8102a129c0ee34402fa65fcdcb16bdfabc22e92d35f160e31d124b1ae7af5107b1c8570a2eea706045aec64df383f8d2d9a1a5079975c72ea6f9f744ca267ec6af16d07882b15e370e1d89876ddd6059bd77d7716a90a31a9924667a4bec16ef8e1fea4f030f3f76a41df5cd6368be38a88e8ce439038f36857d08af90ea98dfb71eb35b555213007da4ffa8b49921615d66a950076f1391ee68e9442c28017ab1f3e6ba70f6952598f3d5dc428ccc7eaa5a5762c9f27dbbfa13ba88cc6e2ef505d3ee924c19d6bf3288768a89d2676f83b4f1dfdea845e38404e7dbedb21439dfb628803c8c40617a2e1919537983536bf683d4995538ad0e4ae82e1956e9231549b21c4b4bfb7350796b792f2323da4f2ca48da2cd3ad241aaf51b5ed28e4a7cbd5618c07fb0d728658c7251aea76599f7c7639234c1990b9aff6397565879b87eaaa02d47eaddcb9189725edac49fe9be1d2fe37a6b582e6d2510de337f586da7e4db54b06c25ea4e1e8608d0b331ecf70828db2ce8726b6f9181e312723973de9210833df2fa0b1de6e8747231d9ee56f29dc9dd201dac6f44284cb4210bd0908f2c7da34bb4a03d3e3e9d45160f9e67931680cd5d08bae884b339ae711a96df906e920243b30b6f1df6e28d8d480ffde898dd9b0c7289aa0376915993ba688a57a6275f59d59441089f65690d45fa422de4ee8fd21ee1e181a8929a1b31e6a3f8447c73ee318bb606ddba0d2177fe35f5c1a06d8cb2f0fe9dbb65847124aad97fa8ae95bed81dc14a8eb3d23834cb0bd686b7221541c76521687178d51c423e1912e6fc91346957fd28d98b06e441a65499304b10bd7b25927fcf90aae520924e56ce2fafd5115fd5cb8367b0d3581a71f2ce5a422578596bf8b02a91f80f9d29c32c617a7c8d81b544d2b9d81710c230ee1e5b41125ed896f34f54598f77a235e30e087bc242e321e2df0d374934f77d26c6c1cf919c730f35b82a47d1a66bffc82a173ca11284bffa40cdda7789e82362d6e5571eacc205f6b4a7321f8c9d59ce94eaaf4d0bed9186a429bb5d0d3c15d536bd74544b5163b9e75631f67fc0b19b9fe66b9e236f27c8cf9f908c277f34dd3b48fa27ea4996b5689626248f7d052f0a7b9980b748f42f10c0e5d36aef9765f7da41f15cdbd9d38c37b0aa8463b567f60b33313ad624a8c9b586cf601a8b9ad80e46ef52b1b91a18791cf05dc98c8aeae9694b27b961f092c3c9eea53ee49c81bd9f4f19f5eda617fa8da888fe46d6a370f1a3a61271fae450ce088bccd2a5f3fb2dbc0dadb974b03f41fa7b9df2c3c125d0634c6bf982e15a07de2d6c28c885be29ef953799612bc232eb4a080f81dc4cf246408d17de6913cace6d0cdfa440e7b0533860a2a1a6e3a8ec19fd95a2fb9b8ce24f4ffffb276cef614bb90c779ec573fd375720538465188376a98fc08edfc17308ea0f4a3dc98a91582ac598ccca634031e88dc05e71773a8f071e982b753a764f5729920814fc8f3b208e2ed47a67dfa7254c35782d45161cb00da12fa4c64f21993b75b49e337bcabbbdaf716e1ec2b543fa19f54d752be43edfd304f98ea4c028a73931c059c9b0c855a75b2a7c6af3a7b2e2cfe446863e6788356f6a1b1a7cf49d871cc9162af785576249e2712e54c57b9ea748304ea10a5209e272ca361d727e7c6e97a7198b2ef3993d80c96bc17bdbf811696329d3c6061aaabcea1a5948f637d56da78a6ff16cdbdac5a0777f60c9c1929b0378e8a645e9f96206780fda1142b3d537a4fad70d522e1309fd8283bba0f35d09dda43d1bd0a79a9287b88097ec385fef6821c6fb928560c51f7101ed7fb92664d51cbc61dd71dcf7f8ea07b9976619ab82f6d6ceca1a365c40e2d6d6c2fa5c954e505f992a13b4705807becbba97d0b4d09bab0f84b48adc3b5e73b89c07cec3314e4e7ef4863ce082ee6db3af81b8331888f7d396d1fafbf33a9e89c173d7dcd9cde1690b8add821666c923c0f10ee2a986e6dc54bd5b3a191aa1372ece7051fbd6cad67d4b288d5bf0c157da0b01a63e000792fcfd3e213f4e42ba24ea52bdf5209b3a22d4a91a6b339d0843daf1c4efdd0266845e940094d30bc168e0eb32e0098e6af5b7ce6b2711532749b8665f213e42bb8862ad956bacc1732b317e5b7fdfffa01f3fb985db6dc3cfe1fdc339e2d0ea7b101e46ccfc9c2d5c6c3ed458f7125c3c82a6bc12617e2c7242063ed37f26b99542ac4f5785e1a93eeb41c24c9a2490b7d17fe9747cbbc2e3096b9cfa3260fafe8cc3d48f46960bc4d037311590fdba6d4bc305ffc56639e815d9f05d4d7f7310ce43992b8fff1ead064432bfdef6a83494c52926c44c660bb298d68e78f00a2a497386b561cfe0da86f15ab09f5ff6ee065db38e68dc7a71a223285b13ac97b99eae5fa7101e0a9b1d0b071dd0bdc1c595c4e1dce6ffd158292707af419ad0c05d5dc3bc53df062380d8efa63cc3f85a13e0e935f8f4d2fb8c58955d9d7f1fa0a7d7789de66efc5aeb52c512924f5b4154e353c45b057338cb5b312c63ac0688c7b15e621e30701dc0554e1eb559c62d406fee07b89415b71a70b2e9ad08d7e7175bfd54b06fba51c8247af95fa234520a655e1775a1e4365249cf769903f1aaee7a7befde57df06519dcfde783785df855052b0d8ff860e9dd35bfd9f68f299c47db7c6d7c73fa9a1f64be9b3563d2d732542a58658397e746098dd27b97d114bc4e2737d5f1176944b09517324df944feac1833cfecb53f44df8e06f739c59d50efb2e5cf9a826cb56201bc4f3123ba095e547672d54916d7690aa1f266c2aee05abf42636cb1253a3be087ab73b871b25a9843d60cb5660b1ff5be2f55e6a47a6f1e6ff90115b39594c8a020820a9c2a93f61aaaf7dea013efe3e0e006797384f65512e17dce41a49d8a60ff60a191c96ff39e82c7872f86808733fedeed8f0fadec76911d59bba191cb7bc1f9f5e967d923a02cfcdefd745d2cbd312e87141ff86670d72427ef2a0574c9c97df57c50da6543222a4584bcf3801d5e1731266ff4f286cfa9094db278db7e6f44b20d8b8ffffb62be6006cbdb535da8971dc1a76536af3ff1349f610dd89869fd15f8dad84fe95614db0cc4a80ff7fe6da41778f301fddf49fc50472251b6c3bab312d6e457d5cfe8d081bfdef0d1e99e1864e8c92c93908daf54509ed1bd6f56da2a2e83f2be4449ec1b03679a5381293ca6238113d23807dc0cd9d3208b2faffcd16a4032af1a19990b3ea770d7f4bd62b077b55ddbfea8ada1404cc9581bba1012aa5b50025a90ff383de55e052b40a981f6e277a27e4d4bb55d76fdf6184b6772d862763e86513c58042406e6e03fc2eecbbc8cfa12993e7d4c5e932dca55f694dab5893b2c3a6eb0970fa66f4050ad95a49ea8cf0654e08706760e29c90a6a8da4f6d9146b5a68e202f19cad15bc1764c618765e7f8fe51f9e26e9197fac73702bf44ee6068f330391152f2defabc0ddc2e573828827bb50c2cda11cd1a331835f0bddfe33fd748480a569c80197efc4a649c3c05286560e6390f624efe9bba9a03d4f609d0d75737ca65be7b0fa10a392877cc2ecf6dfd29af7d19fae47ef667bd67c2a184713d957b2d41aca18931febeb269cf629d63ad682d4cdaa8d4aea9a0643a3595dab53dcefaa737b1a0259202b7c6019385e3305a4de26cba9bf87085dd594ab5cba2850e0ec1108aac4b2325a4bc45371cb173fe6f4af2e649aadf450bef9f7771e068ee176bff6f6acefc98eb6425a6267f2b586fa5329e2be72a2474cdc7acc354d63e399f4e819f925478a0029265a71cecbe13c86426ba89d3519b7cd64eb94df00075bb8e57f27117d62ee25737eeb79289c22e5ea1fbad0310fbad4d947befe1d80342636baaf41b10f0a8d84f368c44da827c5fa5805f8232a385317affbb114e9c64039cd35396c8b316d60bd61b9a7a6df07be102b5100f06d641b41d53bd09a7599a3c7f7e9cf6225c555725cb18c74c28125712745226ab2e8f76ab4a6063d81671c8a6db8dd2a8c80254c79c1963b9066b7af5a05fb802515f4a9c19d47682b0487d5619efb00fdf4fb7bbf46bd6149a50747b3ead3f46fa33b99992571ea9295d5eb12af0be862fded6cdb94a44cb4fe16e28b81ec75c4bc465012bc54ecfad16633159bc0bb5310808515dd6f808b16954f76ed3bde83b9fbafe3a64265e4616e9598f087cb9d279f613695e27a4451990de3f168a41c064b3f0f17e6f4d5cfcef5febf447ab08192baf7604aeb9b7473a7586383cdeb16221fe52af4f91aa4eea1542164c0520de40f937b0f770324a00f5571b0e4f0988e8817067ad9e7e8bf3ad87ba6906de30924ce742a1b577a08ceb8c0cb01ce3ec46620b8d9c28fb14a5a19aa1c352ec0c7647347c9d3990e295ded7a5ff5d3b53fc9b20bc75d4bc27fe91a9ec5cb21115308bbd160358c0f91ec83d288138bf0c2bb4a03e36a0cd87450816ac026bc6eba7ee286cfcbcb59e94e49b70bb1f66d7351a89984a352ad814bf6583bffbfb84e93f5a0beba3efd85d3f315dfeb451b27695a56919f7c3406544da34fda2d7a1c65ed3e9c8d4157d835de29845c9ea1ab6cc6940a697c5de4037739143b11d9f5a9081a06880dc84a52b2dff1f5b5fb908e969cd8a2bab874bc2a26360766bdc3362dbfdab92682bf7975beecbf393c43093b6102678fdad3a84054b8a342d8c60c52b3d06c9c14026d02e229e575663ed4df38106fc4ec50ef4f69d9d1e0ff032648609a0f9b09fd2a21214ca1df2fb930aa27c96703344ed125a574834636abfd030a9f9f53a225a825e9624514400204442bdcdc5e35b57d612aa9bee024745f2f7df83a82a7c0e91ca86dacadcd5de4f941c022e0b1d8e73fed5efbbb27e680cc26b14599e249ec865078d302c8c29fbbcd0bede7c861687a6e143960ba3e43b685d4c62e4910d4477cd5c6c583195471f5b1c6df709d70b04f1c3da0a7f5898b30e1658c193c26806a76cb8ba8e648d17930757c1ee8d6c3014e5e9ce9e33a06c8a9bc4d0c636ff7c80f638d91ec00634839c37d1758a71239848a4aed184720d646fab7b2790c533067eada83e1d16b2ab5a9cbbac57c381381b51f514814683443ee8cef581b8149ca4d275566dd6e3e5fa02010c90a13a7dab89ee9f777ea69c2ba6e2e131e7b74930fec6802d5f0ea23c1801f23aa4580c3a514ec84dfaa2ed2ac945abc80f223186db7b0b08dd6969167814f97da28b373df4be8e2d24a91e0e1c993346d0b9c67cd909826b23bb2d6afed42a78f437fd00f867053323dd1438af453dc6e1e139266b65bf0f6af5184b7b9e82b67554811a0b353b6046dc2bcfb0712ffbf94f8effe981ec8f3f391cca12406da99ce8290aa5b1c4a8fe43516be4225873ce05912ae3f141d4cf88ee9c61499c5f07cf64a9e1532c08491139b28674dafa1f710532c80438930efeb8f91f771df49ab2add4193dbeef1fbe18566ec759b097c2bce2df0782085b81fa2760e052de745eb6cd8a494dcdf12d2a0baa33519d778471fd404bf92ebd8f9dc989de9ca5aad4cdb28cfebb4ec1e75c883b3de690882b4c8b033c26f2c9dcc6bf4dfbfcfab5d0e05c040c4085c8ed4e6f02c5ddecd9dd8f2d21b449f7ad31b763beec0db846f5b3a3e77f0b5b037ad015ccfbd4b465986426aa403985c8e9f8ad792d5cb1f024ee29e4fc286d13ddbd93de3c66c168ff2f8e5d36cd70dc1c95ea58bda8306f55d11805d6e5aad920622f208618cb04fbfd86607d2fea999791e2cb073099fe6b00e61112e7a94da5d094d01b7ce315d8fa1a8b920289ac9b7870313297c7a94238cf6cf6ea013d0367bbc64dacf797669f27947e6aae8aec5e02cb2e700adb08d61094b972806d9d30a087bd3a2f055b604017c06612d533b4c7d5203280e0a7d600eb98b6bf5aaec3078703032471f67b8853f20ce79327812244e91c96462e7dcb158083daf43aed377c9b8a53395469edfe54d11deb33bc4868ee3055bbfae7f08a35f8a120fa7e35bd2ff5a43e4b8678dbde8c16b2e99d3b2d3a8a20d6b0a8e3f3f7a8c9429822955167d20161e3c9d902aea94d5744b81ef77f15e21eda473445ad6ac2cab8a7f1e160b9a2c799bbe9ac44636d0a14d6a9a730197e8ca43f078a07ef58b37272207b5410538fe78e563a594eba6d37376647f18cb5539d1ad2ff5e1c6fa4bd112e5c0f0a77ea649d961149f46a0c20c6398249216db78caf90d90bc9631d06c5d511bfe3b03d5048b68ce177e4271fa227dfcff5aa68d5a0a51023b69f8a835f9f14142f9261990584497baa2dff40fc1e96256e27aefa79fb3692e36aafd7a21dc3c6646963e2c2c8a6df59bc6fc611622c4c82bea1bfb238b1159e29358f943d95795f9c08cd84751d17e0abe5a0faa4122999ed355dbc01cfa3d8ee3e9e0595fc224cc45877d1ff34e595e5842443502c49dc68967ee7dc1ae77c488ca48d5efeacfcaaaecc91c268e85f5a40c7a4699b7c07cc47195e84e552ad2a3d3a8badcf7effc55642f9862e7147584a863ca55917463467cc9e6c8e25cb8d4ae23a64c7af7cd0821c3c08ca50f4647a9bddfb57e333ae8682945338a65102d19dab8c65ac95f315e5bf2835ed17b11241d74fae0d91227cf20af15fddba048a8d89b64771ed4a8222de65ab331aa2c8d3dfdff43939ee3a44be05a38418a974b90c7512a81d21b17d37a1ce932492e0811f3d0d74904535f0224b322c242bc0841ff7278f5d9151447cf2ac2b2e6598dad308d1df5df4c95f91454c527a0deb746a7dadbc04a00bb7f2602abf19fac8dc6c6c8ae0630f6826bec91e29048a2099a95f1731e33fa31efb433ff1bc79e06ae940f3af6ae25ce2ee8fd1cd41cce15b60a89b2a404b7183ee9c7f853ebed75c518dfe032728831019e2850c70484bc4bebce23e00f79ce56218cb85c1f78f4daa328c202c5f8277318edf76a0a407bc732e78074be72a1ae535902d55f582edf3c7397f381ca59a3b084d8b5ebad00d6cd647eb57e671dace7405e770444902af12f5fe1294f290303cd4200b2cf0fada317dfe9073296d182e7baeecec496ea7297ff2934b23445ce8e9dd20f95c0842deee3fe650ebd065b400b01222f449070d3af7cfa7869507c25a69e438f2924ec6185a1a2da394b97389989c0946a0c55a9bde6d784d2fddba022685def6b5733e5c8d3ee2d70bbb73a92374d1d7c099a71c3b0dd014b056c94f2a42cc59fcf4fa1a2ba91ba5660f2808f87c7e17ecffdcd3b422f93a5c4a50a862b75fbfaace879cf47ba5b1862181f326b23f88a0396081b6ba8ac346186e8fc8a12f47b5ee5b00b1029fad9377fe627f9090914da45465a10df6ce071b5c2549412be22ee2bf3845464cd8a830699955c7161451e506452be95830b1cf21cd6d73c652d0f3f6fb58b5346a13efd02dce43f9ebab2d0389c1435743b87ea239e1dc35dcde1e3be860753c4e81e77b848c813beb94fa3810b6bdcb7e636ab10dbdc5c02b3d53fc5135e12e003274327705ff62aa9e076bda3f9c15f403bb3b0dedb06a08112005c763a787adeac8b64a104f39bc535b87697acd8d953f054427c08bef7b923e8e8c5db8ea9675d2b68f57ef33f38db19224822f0280dd0aca2c1727adf4b8345a9f6af23cb02f4f8d2e3bcc9b2f74d107b67a1292f472cf9f56c2fd6560c302e154df7e51a9ef4f43287dd825c4d7431c4360ea7289b69098bcefce1cb5b1f79c984d0c947b3c9f2aa0cd6f867a6c034969497da549e903a1b49171f5f74035ab5cbe6aebed1452f34ecb53439c5fc5cb7e58c87f66777abac42f6366b146b320dba34bb33bea16769fe55705c8bc422c1e4b3d4b0daa75924561cba8ed9c9cba2d6a8c7ff266c92e70037ad4cccfd71814d6fe6e0333df4962b9f31582fd0b148ba1dfc6dcfb0e7bebadaad9d3f90937e8756245ded4602f833b6be85d44717644ce7eabf7c5b3a6d116b3602a2306164c6a07c70aaa166f1eaa4e80b5fa8a208980f25314c6197aa889b1d10255fa0be2802ecc5e345cbf3a30eb069cfacf1477662ad9ddbb7589834f5d82bcfbf6cbe0e85ce80236dd578d83b49c60401354fff3b4bbc8835858163abc11d99437c47e0551314e545a0843326023f5d4de7b3ecd4643886b0145676b548c4a6b2724f00e0323c93cefb46eb519e01eb731120af3fb2e1f5d0a6124b0d5f1ab2305364f69c2f5d6552232d60ea9bca8f82adbe7f1e3b999c5828f19da67b5eb496950ce3dbcba3122d04a61a75c648ab56bd393d99337126bbf91a304cad56eb59de8df89692f06b7042af8ea617c5bfc8ab0bc235ff5cd9d602cfd3b6665b6ae30ba26e68008420af818d555e2c6eb04aed0101cd2d89b51e8bd8e04c3fdd1d4a5b49667fd664196f918de484579d33dfecf0bd60a39e2e13dc3a469ab69367c57912bd310db18fef451c8497e8343f77aa843a6a24c8942d0c360ca2901877e0826dc31d768d9b4ed882209f70ecd282b6cc03e78a0435bd5038d6e30ab8d6893bd07a937400433e3eba6f343915da22d8fb0d2c45518757bb8da1d96f5509ede90731e80760d1fd62890359c81e5ad31120db95043cab0cfbc07d4987be0ec8aac77445886a6f3bb6e318f7e6685221d592a74aaf0f531f20e7a0df4aad9e16ad54b639aeecdb528ef771450eeb206263557249fbd80c50b84a3fef71fadb91decbfbd3030c86ddd2f7f4ef11dc238f148ef6e88434f200f7da59f76a40d3765dced79a9fba6fa7a5d162a58f0e049328e618e324b822907feb12b920b3f693d53fc3c18c29110246527d75dddf823f7fcfefd2cc8481a2223067a8c93cd52d3e753231c255d63fa71f9cc607f265a6da9cb81cd3e005b118b57dd400c713c0ef5e268f4f955269feb69693154fef556ae83a5767d1453fc462f6c0e0d230a9503a9aaf3eec199c6c9393b2dc02e7afb603f9235dc381a2451c37b741d4287e4c07e5be0d33c73ecedaa935640fa14c8f10699962d42abcc894693ebd41c9892d49c1689aabe6fb63aa50ba7aca6eac771d3dda07274b0bfe10a5cb312afdf26d7fbcf39404dec8409fcb7bd242a0e45ef9f32558e826bb6cb6f84812573b40438689e4b32c5a88463228e982040e03b4081d7383f15f0899430f978520158f90b0ee1a805ed95bccc6d21b532a851b6717a17999f07b6d05a5f65b31a2384458ade325280a98c9f4650a8cfc4e0fd2168ee2a32ec836d2c4e20da2ff91f6de21418c191225c06f6ffbe0537eb10271d3998d778c82cd7565f8be9e841417d6414f5fb9985919f80659c0109c48091ec9ccd5133d3ece05e8af716de3bee7b6d3482a9a681ac1df94d52f051271b96cdb48a1b1ca8b98cfd98a50c399cf6533860775d08e92d329d0c01353a6d46f55564a5461048aa2bdc3501196529cdec349448266615c554d392201b804adbc9cffb2fdd74b340674b195450404f787d0889a0da3129761cfb3b97c7b012bbf29b61d8a65290c6e11d9a0259abd6d3d461b9b362ceed5967e7f50b549d139081e010a89a13073256f4f923bce926cc90ac63bd0455878d25e32b417a62f57ab0ad9c2de8c2525744305feca0e981a58bc44540c9f64b3b49d996e6ca5347ee12f90a88e4420e405f4a27c2c6087a358071eed2c096695e5b0e7a8a9c6216b6ca773c8159a94f5d9d9d2ed0ad97df48eae12a372ecc18c8334e2d31d0ee6937878b1d0fd4f17c90c335982fc1505e42c867bbd384b1e69035d7eedf012fde8652be37c09052405d3b4d4d73ae48efb78ee06216831f799e6df98ba0a06ff124afb6acb517c0fec1ada1cb49a387e58c58fbfa3e52be5794a2f2d057ed675b26154e3cb4888650fc7f4118570f179e1f842be5c5e663ae3949cc63de83b18203694c480ec41253677716aa741c30c933fa977e5ccacff86dc62987f5445cf12705860ec402c72d81586cb6b8f02f5cd65fbe643721676842900d58416c410ccb53ee092b55a83da2954c035540ed776cb9ac9aec4c5b495a31f7f1e2466f8e699fb8cec7e0ac585129cd5c1aa6d8b0997d84b4de9b03d701353facf2b36aad8de52bb14feef2e4807f3fc9ff66ac852dd7ec9ca31adf2af9c6593e04bc6e2c282d84bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
