<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d41442d36be6f7a4d84055d4ff29a3aa5e95c15c500c1cdb9bd2666686fd22d7564d916f14854fdeb3455e7114bf48c21ff2f2e9163f614e5e2415c2927eb84f4f73f5c3c4fd5975bb8ddfc13b49eb5b9b9a4b26382b5cd121c717df4e3d4acf01994a4f98c5f4eba257fe788e32470ae3d8b28f6292476acea282d3dfecfec6d75128551a4799c9ffb320a72b29deb96af6c76f0e8355df4345ac8f1e3ff51b5ffb5cfe8cf3c0d353c02bd0044c6d26713834a1a2c04482decee415bed506bc0d523091b34cf42de7ae7866daeb4b8d90554b833b0a443968e6e15e5dd3f76ae390d7c883708e210271a3a5a00def67caf2de3ee38bb19334dfbc01cc1f569776ceb5db634fbe6f35d2d939ad59b00804787d7bac3bc620dde74d9ed6cb5a7fc7255735dc0b69a4c9771525ba705d095d75bee6106fe91a77b23fad0ed5913bc043c95c5a9f761514cbc4c78673ddfccaf5fa8c3f32c4722f837a0d61c1b9da5718fa1bbfdc4e56e8cf76f9e0e58d41bb909d5ad0a5bf54a07734dc373b12a9fac1a3e7226a2300e2d23fa570e61cde3e59b139bf29291e87d903ed91c4e9217e5dddadc6bc9b1d4b84be48a94c17675405724216beeb279f8d8f61389b6d29cd835b19a5c098b93d99f83ca474fec0df71a3d514f31309ec3cb32c566c58cd164100023d4ac60732eefad6eb25309db36bed4b0d98b4a831e4f1b35d3aeda1aa1e229220b632b46f8553beabf23c22ad6fd98de3aaa665f6ab730cb81c7802530ebcbb96e31196ff45e755f987ac4caf41e533f866a2472d214cf95349308f00dd9cdc724cf09ce50e020befff20f525676e9606db5b9b13db7c37c457721737699e91ed0e7c1673b19ff9fba3b8fc1a23195de973cc4df8ffd0e0783f7411e60d4d6b85053ac887b3c71f86eb89780fa0f7eaba7b607c16c67a85e9439738d51557e2a325dedf9d98a432eb8d2e8da74842676062f2a32754cc10ca3ce9dc51519cbd3eed96d24826efa83b8e74e85a18d40f6d95c52c0afef2c14d48ed29298a6a4d6b5e56d5f8b40e0abf27319e7c133caa6d7d3add704759b3d5d7ef988d24f5349a42ba731993d07cd4643c64701bf9bc70d5554c244972c121964d7f691a6d1f39bfea575da371ca72f6cdb3121499f44f29fbadf36f92a63a06c10e6f3fcf866e9fa3d567d5c1c23fa96da087bdb0c9fabc645a00f989d629ad3f3283fba8907da1711a0ca608df4f5bacb1818a8b38778bf3fc0862669d2c719e159d442174f69bfd56f4a0649f384b2f3137c92f7bf8e6a3654274b0cfd813309a5b447ad9f176a7d5552f99b2d5a084bd093a81084bfe212ec310d61ec8af7c8c4a9bc74be40cf024986a0abd5d43ac36ba59b7136b6795240b992015afc60f21b5cc1f9f862923bb3e32a01bbc26ff87b548f4b00a50f01de6e763e0d19e9d9c91b4dae6437d9b6b3a4d15e6f3b796a4089b893485250900f36c1a88dffe080b3d89e4ae611fc62dbb8cf6ff9f16bd5b346dee145b9d232c4a1f12c95b2c901bb9bc80c756e3f7cfbbf2aa296eb43d0e192bdbce16e31639f6a42548d6312a43449328b8c10beda5f35db9137b248a441dbcb2b953cd4d52b873c8d17243cbb44e866e7a5405ac4568298394b5531f55725d4a65640c031bc126ddbff5ac9bb1d4ffa8ecdf3f4c590ca45545abf6939b6b389fc1e7a7a4aea4366e82cf4129277788a5b6e7f163de15d0b0104eb1dfe0a5da9fc738a8a612ce820501f6fb427a6164c5e68c4fe071ea13400875a78a71bcc5ddcdf9b42f674f5173f5239327f4c29e3df1e697a0e9fbc35f941fe30a4d29df0b246f1b6eb63ebc96cd440dbdf035ee977a18b7a243883a8f450c19d0bfcd7578027c1f9189e48796fdacaf07b0b188a4d8fd550855b2a55218531c89d885e117e3ad25ddb0b077170af755fcafd4e04a790f01aa2ce6c78e0e93c0fcc1c48224a94aedf4f709ef6011e6ece278b1f0eaeeeb3433fd68199f306ede2f0265549a5510c007193ffa941c2becd21fc8f20e78a4cf0a90e5584e20bd980fabc210ee2c7c8a9176c5c5a67e8cc22e43c9edc19f25f15173ebe1970cfd1ec47e106321cfb6b6de141f006b32fd271d8281653575824fc0fea7785678f3b6386027ef3d2fa518953d3b1a826509016fb104f9783b48e63effce8df0131cf76fc70e00ba1afc30bf6f24def54b28d26f51518dbf6ecfe39482061b51bb3f9977c7d5d7cc1938f7afa0c53306645cc8f04cea5b168042a0d9b9389bae0f646cc9f1e2ede411ee1701862f795ec301ba651a1cf551545366d62e42c48fcdf9b1fb69c404b34d66cf933dde6ef69b46fab6329e347205a20d82e3b6a69a876e1cd6ba9e3982e0b00ad06522b4e3a34d3380bc98fefa89586f18befc27957e633745798053f397b3a68ca522e4269c15817334aa6e64a6ce7d5857e93c0e241a8cc47950643f0c76ec7b9e2f396966c35b6d9bccb3f3dde76bf3f27415e2049d5b75ef340a099f110528bff6c77f42c85cb218544abd257cd005388c6b473922dead365331534bcab2e1efb4e21bf486d9d484db6cec80446eb75e12c7c636dabe5eb9ed40052fadc5df1f230bfc7076218bf7eeaa7bfb5993312bfdd39e063c5707646ff653c4dbc8b590a55a1ce349c5c965e54209f0f836577fa4507a358d715fd75ab0b38552f8267bf7992b9663c3bed931c4ecdf51bbbcffbd20e3ceda8dda1d95727227ce1c50df58a2be4f74e1d78a467b6d37a5329666bc0cae3692c7dba59377e7b3437d8f7bfc54402ebf41e7a3a77bc34224d64f79b72db926c0f4cf99c3145c6537f2fedd663193b5a237effa6e1746518bbc8369be0d590da5122a0143c39b8f28bf606e9ba2ec99b2c8cafb828d5668097f006c6075bf9a85bf46b2954e6147362a7ab26d21064a4b4047a5d4e7f43b49a85c5e6a5f69c11d05011a9057a49cd789dfaef3e57c79602792650ecb7be7632df18cedb263baa5723111eba10a24be281ec1699b2b27e03020d3b59e3ce27ccb04faedd02a7e8288b6e38d071387d3365d140d839d8892db45341e448e4279b1c0ab6939eff7b035fcd6f83890de77421e791956643fc96094fd2d884b1eeca2d5d6dc714984082589f6e41586078783da3440f34d1aff066e55bb6e71b7c7af8c49d7491709fcf0c618fafff35aae797d0122607c484b8053f124fac1079dd8d80cfc2a9be70a1ea7db3b113abb70ff67816d98ccf76646313ffc23559da4a8517d0f90287f23ba7c1622fa7f3855067ed2177554be78ab83df9df98d14b4cdf3d99be1398557c930c957444a7c714e2440514388ea0d243958348b82b96b1928554abb2f78631fa48677b6ee93b6063ffb7657a38635d5677e0223301c99ec8714e0060fc3606941b214af35d25dc2940333e9132f01a71db6fd814b08ab5898feea04565869db24b62b125cabf3e28cd7036eb9bcc6a9e66c20a985f9925bdae094ec4986510b43f83b58d99a52087550439ad2c885798d8eff1f5c107e3235fa0b59ee63fd201a6391b81c8b4068f2744165a2d1621911a96456e2d30c441e4d92069a7fe054073e5e909ae5efda70c237db3def0a34f64983b8b1d1a12e572aff73ee6645e39fbaeb1b977ab1f4324818fb28ba6ce1451b9affa6f42cfc9d198533b947300f9c0fb547b5606b895448caf5dc502d5fbec185c0b0c0908c7e3f103d747077507c8531b417ed6aac037c05b39f4c92015b223eebe9e6d18ea4126b52aca24197c0d07f65b7e98e58215039ebc41e48b874b21a77fb5b6fe5393527f77d218d2b12a84448d768268c0dbebf2d527cd7f49b6c06f5533136dad18ee4e6d8e5e10b7c908eac2b67a6dc59a315f496c200e60afdd242be04d8486279bb2e58d592a5c33d2301a0523845b30024962b5d3c8602412a2146b2126d5a9f6d9396c4c3fc3dd2813f78c612d13e46c5266acc583ebf199b42d5eab9658b15a7dbc3f9103aaca2e41aadd989386eb8450feb3ea72196e6d2791f5cb9f7f505849d8153c381497589f09bff2a2dbe86a99c17ffc4efae50c1cf0d60bf368299ae180b721b70e6753f221cb48ab346236a89b63fc7bfcb407e0791a4519f9321c86d4614df0f1bfd51900b71e846850cba79cc83de824517f9972710f674856b0e5f14f53d8a878cad24162ba0b8197add620d954990a277e63841f42745273fc21eff6c790a871089b56d8009122e6cd7d0695c636a890f3422debf4c5a5541253fce1b1fafb85b128e0ea11e6b8c5efc89ed01bce91b667d37c731e6d74d21198c3e34edc5b80ce319363663e21f57cca4e32bc3e20f9f3bd5d5e58e1da660bc98b7423b7e048dbf65afe0db63f7e11a36b584e61593b6d631b252b4827512043a8cf44a482078da2c4f23b567e6dda22ea3e107f94e037f887f4df1302983e68f5f7c1f0fbca20248599d3ea656b02e5cd195eda3c03c27ae614c074d7e0644463f59864e74541316e41e727fc89e307e8c0772a59875f95b724df694dcecdcc6038462d3725d88847d0eaf0a58cbf9250b4a17285763fe9609fc25200bb4ad072c5a3645fbb2f977aeeaaaec46bddb7db37510be595cb8cadc01c2575236052fa302e08da8efa16454ba9d046632ccde45aa22ea8591ff57bc037d82be2554b72a8b10aa3f7b4c21fdeb014116a43916ef191f4676ec74f8096f23cbfe04538444f8b68e32f00b76a433039f63a57d07aa66744978907882ad7ce06a602d5f194111be7b007ed2076ae08cd53e63bf82011514b8b054a496313949172928e059eeee6a6347c5c605a59f36a94022fc998930357c21621d907b4efa005159a646b1309ba39fb598c1ce5f35edf426ea4907f7785517e0f78d50d5b49cb2ffe232384fbde34ca95e6fc2236911fc0f3664e2ec2339511cb14a365220b9b3b77d9929addd51a059bcd99049571f75db2e8fd1528719aad81e5ef532645bc7cc2ea50992d75c3dbb83e7b65bbd74bbea74e925319a22ba5a97814d8cd1c401a02ea2400d8c9bada48c40f120b27563363b3443813353d0420cd65286899c0c74a962690d99e1a21edf4ebec56ed419aaf15a38288a3e53bc9ed2973176bf9672613a5782eae2ade0dc921875051bf87d53c09f692a4873b5aa1db1a7c403fb278d5c1f4da1ef9ff36c5f2c6a83668a337d93eb6a07356d0a8e504cad0a02e29fe84d036245279a8b8624c065d7ff629da7f3b51369ad70e44de4e6da2728d5b25cd693c6bce0c5e68492474d72c35d678d6928c0bbb205c3caae2b30e25ca062c045d57a1487d10e212290e99678e0b4fa2ba256aa1f1796cbe5693cfb99cb73bc9e0a252feb5cc58e38f4a823d8bdc3978fc2261846bf412308f87aa533edfbe1600b6f443f292006a8543b2f8b385a10d31eb1551ec7541faf994a41e309c8822bd98dff78445b3b6e90b656514a06f9398f127324c4c29b08449487bbe20f3b76d92e615cbcff1bac6f54b66ceb665552c571e8218dc49adf255c57394f6504a28f2e39d57f0eba1e1331927de26b7dd1934a25e643784f2a7554beacd9a9a9d9271602a77e9f491292885d95a335392696a7066695a838d333c4790457e368995ece0c519364edaec68cf83f2468ff1e454e16131e832eb5dfe55f8635c32d00b67eed7be8d0c1560a454e40355a16d55ebeb16e7387201d0823c09419dbe07f364bf43e342401cbaf5c4885a9cb0f8660bc502457bb811fc147b12032fb4a670e581f3560f483648919113c700059377de8069424258d54f5fef70f85cc59babdcacdda7b3a1e85859b05fa3371306d04906a8005967c4e8ad0d9a429d9a36f343e94733f4479185aa077ccad43f9e7a401bd9216768ee4b6460a35867c8bc2c1a9cf9d3c63223af4c3eb04a48dcffbd114e8f6df0e6d01a5d477ad63bb2c9241440036c5d9de444424a8e016c19579697326b00a7be40d46016118a1ddb9747b0a7584ba1d0ed0867667dd9b75cf694838fb2979c3b682c60929659c28f60ada649ea8419fc1f6fc2f932e14398b27873741d973beada8c21324321f5a8d0ab684f231d844beb8e4e1aca7765e32754bd909614a2af1eda456f6cb9788f915efca38008591952a5146463a6ff73bc9f0576db14e2f936edcc9ec56d6903c4b15b1dcde3320b5feb9aae39ebf8e8c85603d65c2ccf85392d0861c2a0da1d501ef30337b701726f3a5af12a277e4108ff87de1c12c69126c1920ae987a338121067aea9857033e35b0ffa6e111791c23292e83f97271a06a1d5959776a6775523ca7fd3628cb0f72235410a6311ae67e6d237daeede046adc085bea40e735ffd4c6c79be132afeaaca7f9688f9c55082ed4b3f73bcbe49b83ddc9f14dfae8962da0f81969636af0fa4aa2afcbe19824790e6f45b138b37b70ad898ff001e94489753946e997c969e51ce8e4e217af27162aacd2ef8d5f430aa4542bf4f0cdc3cce8a2f891a916f1f592591b229d54aff90c2dfc2ee61348c45a1702f018f227cbd952702a789f476d106c3f91f24d1a7d8eb3ef6e161d8800bf160fd71e0ee5f13545db23a9b2e88c95fd1a4772fe40d5fe9d5aae956a8d1b02d54c4be0f37bb6dcaf436b6d7376f5c724aca87d1c8b73bd874cf127cc59d8cfe547172c9b9a5947cbeb19d63845b3ac3fb3f1e1e03c76f74227039e47bb61383d11710bd16c2bae2ede32552fbd0d60e0bb2221ae4b96abc7598c30a51385b57a68dc35e8eb8b31bf2ed5ba52d2fa3eee0f3addccc45d07d16514515c14774479299cf98b16c73d3a8a84873e7108ab84f8e709d43fa1ab3688cd561ae3936f3e03aa236db0fbba750966820a0218ba257b6968db05d87e34432f0e0bc46f9cd488a18055dd015004918a5760f6a63335afa51b2544af2ae412b3aa270a7b0d00d0fda841c29ba897ad488f3e6faf717c827aa82b29fc30fb21043061ee7ce8808c6c5f876a6fe4493e04bcf80ef55b1369fcd0a2e2606c36d91d51c0367383feb48cbd579234aece76cbaefd39e011f07384f196cee4334fd4bf1daa3cc19a5f4bca98625f90d9ddac96f52c447e8e25fff16bfca79f6178f903977b35d026d01b363e86ba6d5da5ef0b7922d0e6b0e9720e66cb9acabc87a25c48043869bcc4e8a293de063c114dde81c82025ccef9711de9d437e967e6a450d1d1355120322e67fcfdda10d568822df107e169c2e8b3f955e891afda54a4c997fb118edc0951a46e3d1e49e6a907df1ba0014241d9b07de1b91ef07248190b46b734c61c544649614e0a31d6cab97993102c7203b5f958bc61c258baa021f3b0252652c7493cd9f6d4cbca1247fc92c7f9968debb6ce142239ef8e822a575d3a674143811f4a4dd3aed6289805baf9cb68490a49341b03d9d08bbf3a151a53f1ca19d15ff4b6db6fcd5f3afc59ad2c731ee61c257cfa6d9b3dda2fa8955b12f208124f06e11c019edace96975d21d86a26dc33053c3724e488bd3f07d858cc9222ee7ed2edaa98e4e0972543224d41906eacb91b4cc0c5c91da5078781f1540f9fa727a376d6a7a0ce035299a01d130aa35909af24a03e07dcf7956501ba84e25ad062f8b68f2ed71a141173223fe93d91ac67781c589f6d36a0b4dbd38f5d978a8a7f2a2535f72d8d1414abe760a32109cf97726d537d668360cca032cc159fe974032ce2724efdf026859e587ab2ebb5cb957a53b5ece657f49c5755f9a7bb0c42fea06b021aec32eae0b345082df30605965160a5f1c1fe3c79c3f3b8f876b4ef13533c8d8eefc43874a476650e1f39f601936e38e0d2c5e013fe152212ae1b97e45d0f1a1ab25b189be674407626200f9c30491a7402c255d5b864bdc4419f44b6a7dcb922e33ee66dd8c0a3a2b8b532210eaf37850a03e8bb2b9bf5caf229bb8b96400728a944dd25bfd220df8f4014f99e25a721936637e9362c57902b87425659abe89a4b77ae2f3370938c9d739597f52037e7134d8a6451952a7dafb94384198a0488b96811df21dec7fc6dbe6d73500165e7e9af56b5dd2a239f7d7fc17d81f0474599017a2785076eda4ba271b1fda67eca9026d589896af6651a44d465f657a37fb56e423a8ccbf8cb2f74f281a139d17b00b3f70a47907be166059004a2ab87d5faf082c0ae17222d53191683b7dd7d594c67c1bf6ca1ddb9058ddc872118eb0b94b13ac59a5192c8856e8d23fd5b26fe7e4a7744890283adffe5224f407390cb0e5eeb3fe05dbfccdfb8997f17102515728e629833155fe2dca7ffbec1e7a816f8158407e778ccc0587f113f9c84808abadb8244feb339f0bc8b81f68a7852611c3192392295c9bc6596a46c8f9629e54fab1f30f72a683d50eeee6200e10a2e8b79d701bbd40dc57b5403835c73a2962c7dc57dbac6daa6efe5ce6efd59208c54a2038fd274b2c71ea67a06d5adae2ba0a456d3640ea7ecd4107b938c1fd401117e730c7284b58b22578a888df24a98ed6ece61b2428ff24e891b758766b6f1635981a76263bf2e78a48e2ead3c376ca5e73d8a81c0084869ff739cff8b252ce4764a60e2c1c4b71ecafb2205de75dedec46bfe42fe53cf2a41cc4c515b11c7f4e2ca8d8d8d38fb4886c5261a7449fe7122af16586617fb32d9c12aaca9dbece107de03cb9d100c884ecab8243957d69d7fe69b29867fb67d8f65844e98ca2ed1b34e261b692716dc63734d7d96f38e21ad89658111d90ce955e0d07a42049bbae24474e02ed0b037812939cb38c8452a1e0d86f653e37f69f4c4ae050118e04cfdf173cf79ec0cab41052df7af49b8fcec67f2784564464dd909d42b64800da986fcdc83c77b715757e1cd275171edd9938df49a8398c0e40f64ca44b9223ce18998a46550c28e544c0ca9f615b1d302d38f1e1bc4b140d642f4fb6cd8bc9d017a41f4cd6eeeeae42401ecc26c1d48937aa07c16f7365098e405cdc0e6fd277cf60cfe07f64b42379331e6a582cf843d313813716f2cf8d4b318afc0e37b88e8853fdb9022f353f6121677950d27bd17cc2a7aeb7b1bdc85674b2d3328039a00e076d86d336795be20b0d2defcf33d98d61875a39d57951a33a5feefa62b4677eb8d3a547283e827c01feff5aec98cfe2e0439fde6a534d5d198e50dbd80b6172c89c91abdff217a9b00598bce4f59709dfb7b12f93e8c0f95451763361b5112f968f5fba25e6498f7e6a021302e9dafccee47cf50c0e54cbd67fb65be4014ecc3e583f8f8c2006c0b0849bf8c30bc28cc93353fa5b675f198b0473931d7b0710e33fd898a4612b6f767d3d3bb6a04ee4d2ccb5968cede439325856c348402be7b907250dd56aef740b5ebdb60a4c42559cc4a9bf0a679dd3b91e6d29b67c41eaacfce4e4c755186459d7a1f7bee1cf32ff5e6f42af1b2fd64ea92a8517d5726ec4a5c33369712742fe5b0ddcf1955408e4f1e22ea5d2de351187b153fb3ea90bd198ef57c11b82096b07cefacd37970ae83475de7e24611dfd77b7c1f9db9a223a7eb9c0838d15f07e67a6aacadaf40a5ae1a963dcaa8527fc102acad4cd500f6f63d2886dcaa0aa236cd2a90680af07301b61c31e986348d7918a54a5ed9cb79f96475f2223d7ece40d0ce7bf5ae47291d325b49a090bcba26613fd7a1c6397af8ba162da0edd8281e383e540af794101f1e6cca317f5b5fb683ba482397e1d293b562d3a871149a8822d53441d2df92a581e21b4b0364ffda78baac39b6953375851f542fd6df383c53e35d2ff64d4c66c3b53a2ebd8520a9cf2a006253e5c259d906d5f6476493775d1c292a2c759027e1be6c72ab2d63c186f1a4c9674834866ab18e4c23b8624caa9eb0aea2c6b6ad9b07e89a80a8dbfc5790b4d7194e5e1632cf4059b09ea1a068bd822de6ef93928013d54e3cb70e394229b86c02e85f172599f9294dbe0e5e54b8debe06306e6b38451a07bf0e91524a2c740a4986b161a125731c7f34e1145fe7a57d0a2ace20a1942074d6c0da458c3395bc7b7635177b44e5e914fbfd9638890e636582c414f205d1e2484cf53b2299a12683a13e55e6f4bb5d809ce6dcb62e9cb416471231ba8a1d02866a78f8c0088434773dca974ab14f9dc34c57420121f5ae67a3ba9cab07c29741928ca41b40a0ea7e7d1991c0af993e74b60c5d891fc4e8e0d86de7791af44c1ac58251c8b8c5d2103a21e9f2a3e63bbed44aca971bceaa14217dd81c45443883afb625acf83047c1d41710421ccfa167e6064ad641d63a962bf62c3402853e7262e8b286f3c4c08debeaecdc7cdd84c53e1fa82cf365aa74a21b5a230df079b8c58d04d91ea63c2707f58165e4256cb7cd7eb1b30f6e426083560b001cb3424112d780178ed5ad60754e9ae87157f2be87f1c348620dbfd85c08cd28652741476dca76cf9875ded864fd62b51272b9b24c7b83ebba2a147334a245f3432bfdffa4f701ad96c1c10ac12d36be4688d0ade7b27ef297352f641a776b1a293040aec6291fa14e8f20116e393a6771313409e8f51f0fd26c3347afbfe8029563e4a31a08b97f9cd79e712af8fbce4d22007409a7ca8dbb51a1e3f5c30c38562a2b498d3ad08aec861ccc6401bc172683c5ff2b60f41f9fac0a246c0090165f5f295d4bb047aa9643ada0cc16c1b684d82cac1f44d2cd24700c732e4206392c55333335152d98d843dfcd1d74648976e5ca6c21839027749ac0a42214b23a98b3ace0cf43194308485668da3d96dee24fbcf3e62dd9687a9fdd8fa31fb5a7d2a7491eec8102224a927b6f9d4f68383c68170c8edc01007c513452e826ab087607606fbc488b36dd8646ad520fc7cb44bb1fc789766ce8cfdcbdcd69804225e0acb6884055eee4de89d799bdee2556f5e29e116f25bbf767b3270ee38ccbd36b3607345b94274c11fca2bf202e2b65bd678b81fe528f64ea1f185d2c702712656d77cdd5ae7c111c42d3195479a2a8bcc96e2d93693c56bfe225285d4e0ea0aa4eeb77a2bff401042b4b95a1a92bac9fde457c931279efaf0438892f0447a89c6cedf90ad6bb6a90cf0e9d5f16e7e0dd9a656c6ce6da44741a35f316ad8258f4f69a72fa42910272513eddb16fe5eb94d1e10270cb78c7864c2d08798474544b77d6b4b321cdfbb11ef0e349ea4d8dc57f62e20be25a1fc5052f726f1d6ebaf7e20971f67272b3acfb382b4537d5e86ad5b1381f362254bf698d5d3599b816517e56971e40057e8e661812514969ca9ab17da7a38aaacee4e6688a3e8cdf40d3b0392ce850b2b11ab1b659f8fe7006e1b1e7bcd3e498fedc18113e2df1a07283ce60a8ca932c00d314bc3be7f0092deb8df7a11101a03a33fc98d860e12ba37d1578269c26ab0e4da6915cbda1877b98b2882136940ae6e0d5b4ef4c81be7b3bbf560077e8273f5ad3012d20d037da87f7d31fb840d8cb64d63eacc5f4ea96717650895d1d03c121ecc2d504876dcf1e247d5d2486302e54030cefbbb59968b2dab5c4b5f281b559c95d2cfeded5716e59ea4718cceaf10ec98a3febdfe9973217dff87a40e5f50f5120da7c6a6c0125479160a275450f2926fb3ffd286609cbe0e5de1e33155c9bda4cb33d12c8b1ca5ce52c45a7d85c687b613ac070ad097ea8bb45dae19f11f6f867a9f8e30bceb20b0647731c1881f3cacc97edbccf2b9b6c49c09775c35cf9d28d49bb852bc02b5d3b4bd7c00112d88ad0646bce6f194e9d628702d6c2b7aa1ebfb546da40a53406ae7dbc3730b698a58fbe22960cea16c0bacb1035a1e94242334de4ec586ee436c07abc0cd4d5ba49722dd48ad0d929217ddfb85fcd7ffff1a76fc5cdc80ace0d8881397e148176cdc4af94a73f93124e642f658b08ff06c8e7910b2ebc0727d664f4e0eb5954814c677970f9ba44d524dfc75f6c72b7a92a1b5feabdc9319c4a72326840dd551fd2e7a2bfab048c0589d84e4b172aca929a77cb4450012e2e57658c8415bc37c9845397a596c187d0985d2d5b8d18300daade550de78a16595c0bfea6e9647d172e2a1b850ad1accaee36414ce1fcd0d3e2c9b052ed81c5d7bf3aaca8623fa767ceca80b668e3f79f3148e4e6898db006ec4b22a26ae6c5a2bb09edd58446c1fb20f87edfc121275b274c61750a8da5174cfe11fac31dd0615489fb069d86cb0251d0260c2d258312062349179ffb28c97e24eb6eda37cb8b0049b739435830fad00c96f7ce8537a05bc5ee9089783534eb4a04d09787354da78ee000741273a8c0c1290049616a6ea45a419db3d571e5d64209eca2c43f6c0268f39cb9fada7651b5e9f5a84c1f14c3249d856c9d1b3248665b033912e10ea1acaddd8befac8e792dd7b0bfd6d4eae818a1c07ecb090d7708fbd25b10329cebe5d3e75774e326f8a283c13e7603fbe3d676699e184f0e6ea26b429c42a175f7ad8488489828a41f0f6b473f4b127932ae56d91fbbbb819236029cc664a02cf5ddbd6516acdb8d9f855baf7eae9d477bf2c22fa8411a20b8b48cbb9901b2a84191867f6c4b27fa597f0b4a1ad77b256ec7791b827c6c583394191c9afbcbb780642da40a65ddd6664cb5980bc55c6a2bc7bd279134038f384d8e99a1a5ff9f1258f82669af15ebc96bec8de1e770a4f111f10afa2bcdb67fa84c9f85c4170bf0ce8ed2376126b5e7fb5de573c8bc4746c74ac473f8db49460477bb3776ece82925f1bf382befd4dca188a7502dfce199af2d7cb3ca6d0b9506d696955b9c0ac5b8083d095122fb2cd684d1651d81a89758712f51f59c6499cd13c09ca4562b4160d004262e51d54d334f5b1b64a0ed7febce6285ee41311ffffdf670de05b58fae81edaac149a946920319a0dc0e21eace061620b252a37012bc1a2955f3eace33a2831e0da9bf5117285aaf6389604450502637e3a1b7ce627bb52ffef42c59122e3e592f57031225b53cbd8d28c167216e784e5c638c97e71fc9b233769039126a9cbd22d281dd684dde55c40c9895248868e1a2415594f9f915db53f289790123c2e1d9979c2d929bf22136ef800a2b793b97aba96b3d3bf2ae11ccaad6bdb716d216b3a3d6f81eb1602f672162b5fd74a759559c8324b4a9a4d87363a860a40c9a6bc45dd24102a5c068e988971a1402929266fe4b94ade955ea857fe92740c37214349cbda0170e472bda3afc4f9fcca4c1199aac6319ff87c1cdcb771cf3ffca9dfdb88597fce5ff6e8cac4fa10c29d712df59ca93e148f0b6e0edf4ce261c433c8784920e6410d1709ead786ad5da7102350d4ecd74023babce7c43da545acbf8b3b91d842e761debf0eebc3eaf58d58b448859c51f29b93c553bc4e29910ab78d441240513d7a91e62e8e8885d5a375ca98093868433d4aeead071763e12d4ec95f5b1ac13a6dcc12d33808d6bc300cc417254258df6b4a430dcb6091b4b65e21fc367b0b4a142afd5c5e9897afe9e688e9efcd1458ad8fe0d9bc80f8cad795116a0e639af220d3e1379e2878abc8bfa426eb468d564c600b248b196c191515094fa764642a28bfdd88d3600fb025f88804a9d5b82a5ce9db65e88a102f0978de2004289b5aac5ad2ba244a456bc2b3fafa7d1260708f7be5f3180b06462042328658139e2d8932fab2a36f10ddf6d672a0607789ade1985e74efdd44a2a6b14895906bf16637c7a837299e80f4b64f3bbc664d046d14dbbec3b7d37b636cf2f8697fb4c80e6fbdebad42cda3954b4b9eb2514c898a2ebc7aa493f123aeac3452be63241933e0664a9ad23a7b582337e7576d4fd2a6e5e0bac445dfd2b63032fb1500cadfefe489fb0bb0267cfeb01de8582e8d5b3e01d8cf9a119c8b7fcbdf9f0cfe5b277d55b77ade10fadd4bbcfaeb8e95ab18ccee332e40a1b8aa31a782b0b08c0e6bb372b4c67a183b2f2dd10b12c44bae1a17c38893dc34a1f1bf6c97fe9dfdd19973371eed128eaa88cac6ed30feff3324b77370d8deae9f46ccebaf1d2892f4fa37b0d8fef4ffeefe8280ceb0873c3a1664da3ff714256bef673d733372ee8069ef143f8d361756d93de25be4f02d7e051ea9f3d3c9cf0840f5affb0f82fa2082e0b506d47ed37e243ae38ef0b773526580709a849150c56b2bb4bb3bf4532095f491b3413bf7b40fc3efdaed2097777feffa2b0cb73323753c0e07e8cb2c4a8acba3925a4582592b93fb5bc3608bf26efbddc2392bfa6e5c76aad47714aa369d7fb5403ee3c25475c034f62d5ad5350195d5474cb5742adbbd492b7a48c5fc4836dd7cd4bc32e0155887d4ba9a93a15d81ae89bbe485e2cf598a7c86965754e569db82d1739da3ebf14f8fa8a3e0c9b7dcd9287bf927bafa1c6341d9a783a1b6a63712ff6549da110332a9f0c3dfe16b9fd930a533a6f51e136d15f88d835aa4a34eb5b3dabd68a2e9f6fd95912a17b4f31bb7482c32c947c1416c1870d7d33d3af48cc8c2a8b1a0f55e52264be0a0cd7b60495c9c52aa7f262be71596bcbcaed1af25916c560afb185dd1e23c8e7c4fc6d6e7e59780aa707fb47fc8e30ab60933d269fee9811d2329aa28a4540ee8661d9004818beb8663f79b5d02bcb2d75e9637fd236e018ab0bfc299fe77cd23726c96cc443029c4969ee9cdd28391de16d00faef09e2fb4a0aeebf4c0417049dba0fb1cabd001fe48b53c33e7c0a68e8ffbe7c1c42f835475f5779e858b96db2657c8c9a2afec49c441630ffb8862e5795e7f77f0a62e5237057491dbdce7f50895d1abe85779da333011ae9819facf2344d1d8752e64e841b6a158e5e723f559ea9f2bd4579fa76b8e87595087eb1ee58db6ed3ebe08f3038a6f48dc351589b70ae292c015eeae2207308f21bd7bcfb940c3d3970ac3484969a62f860076f37165136af266d4e607e0fd20ca2dfbe9b7f69852b3a068f8d73998eb39d94770889aa67eeec3c6411cac2dca1068c77058a85c8f0c0c20f46979de65896e2f5d6acfd1948617c06220942a43cab64922fc2eb5198e7fdebfb4d5fdae368e6f23be000224df00fa93775647ff3a2e4dffddaf6b58c2c25dcce3176a80e16102ce49f3818186ec3386ca2c6f1b75363a9d0abe10da0d2c89b493c07929df18f84eed4f44c2c6269c92d7be0b3bdc6903b3bf257d2c53c2151652b983a0cf464e0d1a8b7cb7488a422f17c736e1b745d3511a636b24fd65bd27461195a8feb2412355e7e0db176a5045d015958e08f9628629019b3caf5c68c16dc79b636273b5ca07c05f21b6756638c53185ae9471f4369b84224886672436e7851bf4ed7575168282105ab48d01a166f3ae4c6dfba502772f042b4ea40e96941b5d44bafc31cf03ea9a92ffeab144bbfb4c5ce9c35926d2541987b1a58f410fa65222d74835ec34061e725aa69a661e618e680db7caf2edf472aefebabc5cf9084876fc4c867677d7cd8bcf8f733c64c8927705e1688b93b40f6ca9bfe1e58038ba198c2305fbe049b0ee63f6ca902d9c718b6e16274bc01d8de4eff2cd1e64bb07064e1cafebe7ab0af372519639e679a294eaec0860cf57f7a1b80056be04bf3cd8845800ea26225294a443f95bee5d75d2ce60fce5fbe63198e8fbd1705259f8bf246ac3c802234ba634cc00dfdb614d64aafc5ae228783a83e4f926522dbb3d9b1b9d2bbc4ed3586ba7d9ad59a0fec292e9570ed1cd30d6b806b6ffc6cac6e6775228d82192fea33d0be5f6a02baa37ec8f454461fe517c6e0dc11fd0e36ce2321b663d3bf4c08095e40fce8af8341b6f678df2a6dc82bfadec131b812c339f2d9e7f810fe7bc9da89a5e3ef6cdb95a924513d29053470f92730895cb2c51ccf4f28e6edbe192b6d12dbf9018f7cc09316a38806bcc4314a0c9e7cfa5797f7cdea2da65715424ae1e33cd6398bd2bb7a0e693862bf85a2f43fa37916a4fff8f3715742072fab459b8a37220128e4c5b5649beac3b1477db3d08f144df4e74888e05770f13771c8d8eb118f5755da70d6dd94e21d572d4fe1b7a9d159f96c79b93c9a36cb6b98bdc05b9a2434131678fd7f02a92a13bf39522ba9a9245c53e830bdc4aa582f7f48a06152af21f15a222463a2f441b6de8dc3709c61858fe64dd6eee48a2f00be8799c43f7a4ee34fcb699270e3100dbe8c723beb5cced597e825d93ea21ed8fd5ed9b15f6954f8f32c0e701b0438626187f63881ad08eb53ee1da802137ddb64247f9f7d4cb8e5189a8b4dffd833bcc6390d7024ca53eaa97ccc403b89ceba1e7a7486c5c858c7c51ba9cf7051cd4654ad7c79921ab42766db2b2d1de3161d81420fa2a8cfe023e094c3ece710aaefa22258087f05739f45d48f10c502d983da29289481a10168b6a1a02e0a2fa0c6a074f50ea150ebdefe5db55022689d55d875040daebcc902b44b7b8200be964884f1cc56684a71bbfa3538178a15cb27461f49325388149f32d6bb169c1c1a90d8976b570b94754c7865c07e7d182281b2910845fe108eb7cfe9cf7c2b5ecb7916c491b609337da3cc112de3a40e305ee24446ae01bbedefb078086b80cd95fe5d0df6abbb33b8cd81446f1894071b26802f68b603f0bedabab47b66567564bc9ba9d7fdea885e98f093b5728aa1bee2f24399e6bf36473ba3879c984664794b5373a5953ad08f91310cac26648d5871fb1d3ae705eb4882590de4c4c9687f6ed0553af4ad7f94c184b3d5a6543148ba98d6d2976d356100dceef524c49d6fbfeaf3b721cd8ee6ce50b9624b2ebb5d5b3078f5378461a6468ded8f3ddf90a137eaeca011a6b6aa477c16f8c59af632eccaf48e03078c68a0a95d910d37d9a0a4d7afd271ea7d07e63d5368df41ee24bc3515f0f85a2595706fd95ee08dbfc46b0b73e9e9a2c12bad0f52a48da8cfc9a6e3fecca7b29e6a8765ac4fd944d141e0aab4d9f827149a1fb09dee23c4f78bea3eb20d03d58cb5425882f7bb42640bfdff2eb74f23d8be970c188a5972c82617006a68845a772e9451dd4c8a3221d65730a050b8f7962d0cdd99ee867af27a6e0d343c1e5073c65f68621eb1ef0683ad65627353981871bfea614a6677b456a15de5a00b2e06e5af55c9b0922f4e219711170e275880f1f4fe49ea0335418fbda0fb88d23f3c9337289acd03244b0315360c185c555dc9039b44dde90361be1f823b15e45c3609f7c7c813e3c4464eef65497c39e7099408ad44326a433258d96f87cceebb00f9efaed3ff1da979243a37b80693172cbc98606dc076f1df7d219753f70c73520ce3a407ac95e48364aae4a438725db6ac8fec4bbcec4a94fd4b7f9d8b37f937a9a169d90e2d5504a2a89e447b4e22559472f41914937f136e3c15e8e8710240c1591099c9a51e1c19a44771274343f0c1e87faa4628ce2f30f65fcd694a327be2f1365af19ab94a462b503b7d02a5a5900ab2014b63e9c0432c1dbc73508656e83e31dcc3d05291a0e33fa65db8ba8c12647fa4f0c2a5db204dfbbb14ebe438d75a3c5367d65309255dc3c6ba72054bcb2864257eb1b041931735266fd11e01342bdb0b2fb81996d3029e0385c11e4522aae9b0d774f8604260dc56609803efdc02e0640db33c24a710369b8c11d7858747cc66c2514a4b2b64b3297ea44ef2d0c5b374ebbbc7d16f5739af032845a549e6f0a02df5c565a4fb85aba6483e4429fb19402f7e62033d33b9f2840724d26a84811e3a91fe6382010e8b2bc19e1e1665e6e59393f3e4e8aadfac91698a6164ddfda356c5c07317433422328cc1f289506682fdb9986945a08bd20357e3187e972b339f23e341d25adab4c779cc0d353bd350c31ac89f1101348b044d9b113ecacc1b021a4b35b1a504c8751058fbabc4aa51c3da17d2857577cfa9000ce59cc2b1705dcf6a92df419ca803c3cb2b6f9a88080a544c1a6b3fea0d55e976776f320eb95d1d07b4de4ff873ac9d53a0f6ac7571011432d7d0fe8a6bf122886676737a6e81667d353ad9051b2f3af6eae33c96fd3ecb8443696eb52b25b46c42704f4b0fdbfe94cda405f23233835b22f126191a683303ad178c325250c892f4d486b4a16ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
