<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc8f477a9b56aacc268a066b18059634b618e603e54803451d3f090d4b8626e8684166958b66b159104e00bc7ee2b608696c952ed4c99f6b53fc09e42cfc73b1f54b4b2a77de37cdb0496d3c9947b1e008d84d0506bc187b199f2556ffc77586a584a79361c26b54602dd107b9fa73f9e5a3609575960c3b7cbf4c093059edbba1c6d93eee1c3787cf7d25324154564b057d765fb556c995d167c4d252981d623bd773a209c2b1be14cbe2f7810492a3df086ff31580faaba8e64df291945c12394b2ba0e2fb66b67cd3778959f586d3b66777e0746b520f6f01180be93e53852bed758a0779787e150474998013dad87cb38a686e909bbf851211e943eb04143c5748258dd1dd9bf28154dd60ce26cd9e195f449596a889fc15764d55850e1d8fb6ff837a5a7cb7b304529221b2762991b2da1093ec6ef7c2826ea009fd8046fb1a296d93e5ce92a90f86221a2330d07ffc4cad989c192c8cd6ccc10c59c4c2aa41dd33e3d2294d1c908375285aaafabc1469cc6f7e977daddc4cd4dca573a6e84845fb402ec0dba61b4f20645f06dbc42fef27dc11ce60bb91973bf8262424810151a1386e57f408ec2df8d71db046cf3f2bfff9d148dde021c3c9e1b50d66cef316073ea22940db53f7699daca40ef9f2c7db6377745ec4f9cfd1ac2387e2f5e681991b75bed4c4b9cd72ea7e3546cee40a730cefa2c85bfac7ae1880384bc27a6f160d5c62de334a98259d2bb27e127c618feab9786ea0aa58bc0a907e0edb9374493063e376f4cccbccad9e9d3c62cfe077a572c0b627df50997aa41d39e45a713415e546117b14d76272220a09698e8a040e50900d37867850e488541a1a8a9bc8750497575a53275cc898202d5d2a93ac303f5189dda0859a794caa74928a92eb1e6eff2c1c238fb94adc257383cdeae48b49678d27c84036b90e16bf19f3011e05210aa47752292f0fcd281933468b92c31bf79e2be033020d50665b79f063a6bf7497b1e16fb6cc9699f110656c269ca046d421e3ead78d625ea6f9a9f3a097eafc42ec7d2148dab4993be2ec6a63992cf73f2f7b926326d65ca572f8809d49c4dab6911371cc622a19781597a78d32135d44831dd1bfbb77223d0fe048ec93308efaf9390bf28fbee6ab21de7b627d826205325b86ae2b5bd8031a9a755ecbc9b75520a56b8ae7b810fa7c3287130f9e67ddbe4fcffbb5c58f2a1ff3ed562d4986f65cc2eca3ca4615cb37153aa024fb84785c5c46e0d4be425d28435333f649350afa3cf265e268263611dcfbe21ac2c2379e46eef9bc0787238ebe5fa8173e5659c14ee604c8ae3e4aec1444751743be4581faad8633c5f491964ef8b6fc75951107494a51310f66c03e69935b38349cc46241945249491681663e34d53769a9227cdc4d3d60c0652129acc048f9d4f46f7448dcdea993c97a7803f6dd039aa6229d3a179e1262dd2d9424c7f52534ca27e243651a2a0a1d15710ed3312e9d7103b911fa44d56c152a5f595fabcb61ac4c7d78d895496b26c20a59d9f48a3b631256b434ec08a486f0a5f710ceb3c6ea44002c5a50df6c7f357794642a2c002c650c91734db706c371d07f3362e0ec75ab09578abc23b12e55ea6fe898c52ee86e09ac5ddeb43066d36268b0e5365b999f6e16cf1c4b47ab86f7c6b0a8d45616478963781906320aefe1c6ea08d7d861e9f5b485e7c701784ef5cb61e061165e4786a1460122c14ad4aae92e87cc3e3ea8aa355b96d390143a25402567258c8ab2c5eb552bc23eae1d5f7a083b24e127d7e436aef1872756b31c8372a6c773834a11e2d4c316b7b9dd4105b5315c7fa9ce34920320d873549a72487e2d98c401f28b1ef2651c3a2f39536d04b5849f92f838011efbd118e9817d3c5ef41417aa445b710e2c19949239ab4e6dc1469cdd27fde433bf4e138440f2a9f99b4c21347560950f22019e7b36db1c804251f7ecd1c2e680d179305c5df005710e89df93320b064cb9fcbe1309aaff0f6a06e046af4428bdf0448dca33b359c4e04e09cb9f00553be7cc89510f4863fa59bf83c6ac2000636137bfe8d291ac1eb7f58030235cf35c2f646b72531dd7aec152d255ea0bfa6f440c1863036efdef5f7c8b9c4de977e9a0d0948980ec0affc8b12373795eb1b0663e5b9144e974e4cd6bf9588420458224b1a920056b6053c0640a9eb0d8f375e03c9b36aac7dbb2b0e2a60899f87a5acbf540f37185286cbc1eeaade113bcb3195dd1f62126d9ea4b4eb8ef4df6c5c6eaaa1e2129ac43cd905d595677ea3e66c5a3b225244426f6579404fc8aff5c5d6bf0f1450ba3cad495804333ca0cc90db0bd1e22a5b33f219eb56625508d9ae516113ca5b3c3fba40f85a7b089ede6f21c8bab0024aa76b8e7d04171155e474b423ce38ed1a9fc0b37246a736429b05ff0b3b578748e6f3c86e8b7f8150175637d7d0287cdfb6b7f256bde824335966ae804af8b5b6d218fbd4fea7ecd670ee52accd6e7a3324f272f35d6bda819ca92fc9f36a4c44e74d145e38d173121f7aef703db1105c9ad379aa081ff296d4f480f4cb5a5f23890328cb76ee357c23e1662060afbc58d0eb0ec1b4921381dd4ce25ffc904cec5a9a980c793e95ec98c0812b6a9acb0bbd47c0335691df4ca762e00569b8cdad095d511826ba0a846826df9ea2bccf5a1cf220ae8c22e004dd0e0d381bd4e4bc4c8c872cfbd135a59e5411356eb1d4605bdb1556694e9ecf5f9b69d867e1505cb5f5553118a8ad7f19429a9bdf27a52be410752c746889cf9dc572256cf0daf9824ec42bb1e7e497b6d4597ef4bc01b11ce5fbe6a90109d73871493ee7faaa0536e54a9559ec2c24e5213bd8ff0dcf2d62ba97658ad7774f2787ef6fa5fdf19c7970ac51cba5de964212b2dae39d3b10d017996efd3edc02c317d33e0bb579aa9073ab43ba95bde0e9601e1912faa63abe950e22fae4a43e7ca5ca54158af6797596977c3e2bbe8c69241d48e2199cc11f45d7df0774d0e5730759e0ead2aa68b2fb7283a14360b48f4a9c45a411bc7804f6f50f74ca3a02ce581c19b7d463da84d5905019c18596501c88c42ede4fd9dec32ebe9808a907db5a35bc75b751306d4e4095a96394d2013b26ef1a0c8e601504b1c10c53a395c50f0a20c258e3ca9fe6e284a067f661173606e2b465ba6cb7409190b8529499e5256ca6949ec6356bc443fefdbd71266bfcd33073b17340a2d649788e32c352a68d2d37f710196f59d2aca281fed55db39df86c59699734f47b5a8a533b34281b48861836cf0c8f8db68d89c4471566c37d802167effe78974f0cb9c2fe667e601d086bc9a4e498e958e847f72db34022296b56a460cebb9bfd580b3b226e19912d448b6f080310433475f6067176d3f600c38b279a33531f15da94ec94c78942a81f40b01902bb2c2940708f418642e34766d69154e43de3f42642b9c16d1e00430ffb18c6bab9d7a8038874073773ef81379017f2c46f46605d5b3424a8a6b8ace1a7eccfef9c79a77a5069f834ae9093e83e4a703b44ed033adad9f3d2dc4d1a5bba4c19d630e61fd40aac31e7c929b2ec479bab7354ea50dfce91db65ff180301505f0d1038d9024da88a428de2c37887f3de1346a2e442347bda5dffe45519374f8911cc21da015d0600638fa291f069393e5189cadd83011d9a55f671fb3d6e0ac8c9d45f67f50cc420058a087e58f8680472d41e94f896daf62867e8c1dca5a40544858dad4ee1d49e0ee2a515cb675e2d1aecb09b7458dbbc48dc898e5690ff938d66f0351463aaac7bb05166d12adee605dabad2c77e456be3f41d017be8ae9b756cf18fdbe693cd2e84f26030433960be0485d7f59c4cae65ae6a5959464ee9447dab0746f4b89401018801127bef1fe04b7fb5dcc744005d82a45c83d68487ba4508d6edd48d9da10be634a24c275c394c5cb647d7ec27b2b14c3754f99152cfc9c31a93036e28891efaa09948316c479435c04c62dfe504ae3d3f245245b7aa12f139bb7551aff06c5b45c9fb1b7b57d694e0479fbe4812a1ed05c0b59931a232607fd72803f3eb059c0ad3293d3ed3eb356626bae5c4ce3ba5a9ae3e2577b8d057a2e781cb645b27682af11085943a7923a23a6d72135525ffbb3de7e038d269038ed4f4c7c9b029bbc533b6e3978575c5e7de61933b135ff6e5162f0364ca96ed5a44d09b2139ff8ec57b4c03a7caa34bc32fef1c82795ae87e6b413294ec602a7571ee32be6fdc206f8aa84455933e0cd53ee4a70c992b02c74676d7c7186c3a15ed6109d6ba2c3f7e615b5222f098fa3c5f640ef99ab701c317ebb56805c716ae30238d300329fafe13910b79fb64e43e44772d3f0f3f4fbc75d4d59d8d581c8ea29795e1a2afb4049b769803289d23389305fb3e46b66f7fe0d03be6f20cb840097ae114c90d116c6d5c062f1bf140b9f80418706980c13bca48e758e351a2008dbd024f36db2ab74f9c25dbe9fc9253ac2c1a9f9e4bbe2d595ccf7b28528e17579848afe374e0c27cd84aad0853d78d8436032ee3dfcf3fb4677c437ae4f8651fa0a2107970080bf04824662a17b85c06e7e38d2f37933cf67767c0c36abc05a15067254122e0e046bcbec8f4a0d149741faaf4854a57905ebc2877d48715c33cbb3f3b88349bebe410e67e75f5c14bd6b49086e228f4ae9acbf64924179809bbe63db303a4e160bd46670a43bc3c03aeb31d92f187697303c0760757721fe1b1e02e91f36e6032bb3364e0ad9e87293f57f5185917051abb455aa2cfdf6ef51e66152719c7b9b8335a1b1e410c686b61eb9cdf9362821d9653246ded52f50bad402bc37ed0b9826af6672f9a24711fb1cbd5f19bfab7be7c592d28d9f584e8ff9d03494ca3935f03e1a83dc6a8f521a4e8e54b74d0eef2a146b121171e8f31e5e8fa226e5466bb3cc20dbe4054dc1b5891d1421d02063de37e35fd68a79f3164f27f089062f1fdbd9cc8e206e0eb3addb5b2b0de273244a0f4a7eb233026390d795ff81148fee1a783ec6737c9a79a9c01fd535f16e827b79985ad4098aebd0d44d361f8759fecfead91b9c2a90a0f128dad28c96d303360b48758d0923b39812a9b54209af4d9dfdd540614ef601974c00d72ba780df01c994f7c789f36ed0329019c7a61ddbccc46b512b650fc0657ecb553e3bdbfc81590d4b71de0802f0ad93dde2f3fc941a43b12f76413694907298b8fd4d183f951664786e2b150290de5013cc01274d5bbdf1ff1ec979bfec4098310ba70ab2c061509479899cfe8e85b516c53424d2464a135dbf3838867159975020206e3d7f7ebc58d7e7dc7f9000bb304add66c70f5f87d9a25c64d0b9ec8ee78ed6aa3fe9a0f3b7e3902deb270cf6cf5fdf6746d2817749f49c7bdcd842dc4def27172f4a347489a76f54c42b8a01cf88c06f445f1ebc30452a0558632ca407a814ca63e6ea8e806f6ae9465a28406f5ccb60a9222458615794f5407b4db9dc6f76a8d6b40b6bc1e3ae575ddf38c04b6c1810b6d81a41a3b20e92b9b68f88456854ce0063d720fc147b048e3d8b2cdedf9614ecffe106d7a3f8a859438b5725d5adb886a5409dcbf76aa4cd6e99cffcfabf79a9eeeeea441d5780a8a9794344396228cf46cade2469046090fc4d6ef96134264cfa13bf9fca1ca458122e4c79e49bce66d5738cc2f7b01db52a9fe721023c4d45988e883752c37cc67aa8fa410f472162710a863e38df28207efe7a2deb014b016f37d771d50e5b9bb022093e51b9214b3638c0e9186a563f670f14d9c8bc70b3299f918d1bc15bf8d690c2d37a1d8423a0fb6e8267bda1ca348afb1a5b168aa5a36e9ab9a0cf809cb8f1d5f8fe181f934a70da3fcef854e7c8f6301bc59895a2e05dd499659d4422c4d10c9ee30a84bf0da5d8fb07eb65c0f8a383f46befd9aee4cc3df855bb436f8548ef38e2466e760d5e06030ba7875458b6951bee0c8b106d46d7f76d8cdf0e95e37f15c7103d73eeb319dac69384a6a2b7d63d8a7ce629c73267954ced26ad0f25d6c8216e0ef65ea6dacb101d6fa15987e1f8212b85563bd9a6bcbb08f45b72b91b16cc6ac4cfd790a6befdfa24b04181c79a4c3aed0ed1b8f3ceafd340ca8e26e62afd86a64380ed31f73a98847754b82faf2c73879b99c9f78b642517900530f457a58c8a8486e6c9031a6cef841a7cdde6f63e0377e5679406af2c36fceb536cab40add3ed9d8c83c5f98a8eaae38ad26f102d8fb469b57e9c383d815d645bb25697aaba16f62f1108d9abc6f3b0359413f99874b934187196858d80c77be18b1df074c92debe237865d9f0222a5f1fdd95877b0058a480b2696a4ee0f6331b5e84334a8031b873d91bfd63c899d38ec2da3ffe544b70f5b291e5295cf1ba4ea3786e1b9ce3105131143949a6358492f02fc4d4f956b7a8d68a416ee0653d15e7783fe090bea65f5b8f9991abf28f026487b3f63542686099858a5016dd3750cdd12fb73cb5489c78011fa11681dbca2df478b97d43a6febca8e838956c9f97a5a0a0660a0bfa398cf9dbced03d3ddaa557f47edc45a7466caad1c86ee26b0813f27f640fa97aa311953429f2c9cdb9f5ae6fbc9809e8082ba5f81464883f3253b32f9904703f26befe2954dda4f2ee08795238b27824a3893b989ffd464e3dd60150ffcf9184537cac7bd98aaf66571e68d3be5b4ff5d009577dac10e56f7a896e3a062f0043b09efe10eb1f4ec83d551492096c101164722bf350d6bff36c7199b4f92411bbb9412e4cae94a39e4a8a6c11c13e04e6ba09b7c0707efe26bb3853f5d60ed8b75dad50d9d4aa9a088adce10641e4a9d16b9a195c03c0b9344cc9b495b2a3db71b3c775fa5fb03f330cad0b4433feac6585cbcad29ae0af89176cf08cdd2e09ad161489d3b3dcb8822a3f6fb5e8af5efb15911c57d73fcb5087c175a297136699e875b3d485bb9dabba71c5a2a8e47b0c8791cd441ef742b53b941bdb15a3bd5c179885ffabbc357d92e6d43615c7833176d330f0e646e961c9e844428dc8c9cbcfa98408854d9861233086e9ec4312af2de51ef5c1f67d701aaea73fe77613832ca8aa7339aa75509e1a7f836538b6cc17a65275b96cda0cdb7c5a8906d0a770ab0f03307e952e9669dc75aca064308b7680d7309ed2f7375a32136c78b876e6bce96b439e72b305633a2c302b1c17348c4147cc2c9d5522c54196cc33066a3ae109e36dd41655cc534415a1a1f38fcda7074a44a09407a8d7ee63386eb7c96f55f8f10099c7dd0c439772e8319ed6b86f0c89ed102378b05aa35839919e5edb40b790db51312104b8331e94d0f0dddac1129fb6902b1e9055ee726e6d990061c0de52e7a868b9fbb4c20d9e644f3d2662302824c408457823b5c7268127f5f63e2cafa7739f5418ae6e21143a6b8f78264eaed0e7f90b5eb85bce88333c2eeafd702f8cd0d9a64d9da7c7bfc833bed53a2ee469dd0d241975e9b4755459a0d47bd307623aac884625050d2a5518d7dc43198bd557b66c4f89d1ffc5e6d226812f30ebf5a50937c275673d86426b87834fb285d3768568e33e0782caea77b70e9afe34f0079bd1052e649ae386f702b0cc3fc6b85e30485f808851335579fdcf48b2146f7444a3e93a021180901116714166d883057103b6c6cf82206f108cd976ae4650af4d4a662758f4db46922a1f8b91c805d64c4e4ee2ff80cc3b4d4b5c406ddfaf8c10b76455ec7443cd3a8143d8351c6ea36f809527e7316b4f100218ec87b9f010e3be3118d9e1c867bed0be13708966c578294b07315627d6adebcf85ca9d2eba0f3be5ec86d1b7ac22574d90c93bf73725569fdbdf36590dd0c0017ee803e8bc97249f3913ac32bf3ffd169ebe4eee8a1a2d6ce347060a1bf5a39b42f6b36adb6ddb345a1997c0841ea9498b841ff10f4e9beb1089667195e47995bc9d34a989c5d46c0f7b7dcf8c93bd6a9a96d9b1783415f4b16465549b35392eeb3999296be60956b0f4ba16195001ef646ef41337f4f34a826ee90a634787e9441fff310e8a101d17356d061a85dc65607c90fb0de3f131fb354af637a1dd5ffb9cc302a68e6db4f9c51843a87673406f881a2bc97278388c4e01a33de456aad04f0f7db24ee3d1792dbfc836c00c8272742c29753ddce9d2af6c19c86cb3d118043c3aad879b9f2ba9b4e5f1e2e34d876f53f270dd3aae067dc1f224405c02bfc1cfb086e6c7cb6bb1873c63e518759ddba56b9dd69b7bb38cbf89c1b244e956ff3b97e8ffe6a10e293adaf48e285c207d1b0007d3f3e46647a70d1a185e6bb0f5b6d04e3963f8a14d103387dc9c0cb7b3c0d6ff5bb77e864e312cdd3bafca6918f37eb9b63ba86679e8b3720c1dfce2ce02679929cc5594aa332956fa1f70119e183ff2834bce2133621311900e1a262d3428f0ff6e34bace483d2f772226061b2c677030376b8d394eb966fda0fedba5ffc4dc3d5db0012673bcc5615db5ee752c8f2d021f565771b53202127db60d4ef9bfe112819319efcac12e559919504143f4f6c8058da7ee265ba62eb4e20358efb72f3a9d108e6bb94899afcee765796903e392137ad48a74e22067b53c33902ac8e40f4e02856a0cec6057160f684ca2dda7f97aad4dd2736591f0ec838a8ece13dafc0cfa0e11d2d87e74ff74386d2a4a9e3f46f5b7398863333db781ceeb84296886307168e76183155b610b50f03ffacb1f2e0a1ebaf34e3afc7611adf506df1df95c94cdc755d829e6f11105f1b409e7f42777a506e008ffc74e3545ae3757c9e7ffbc6ec157a168417e7bbb52a09420fc23f40942d361f70df251226a81e7a2727b5280c6349fc17d5867cc0e453cc85059d7ebdb07a33178f5fca87a333380fb42d19a76cf7cfa73c1629d94b281b51b47707d370d7e39f4782df7d71fe589cabc1ba0841d1598a408d14fcedc64202a06a42243f1ca3ea2a82cc4dcef6cbc58c20444e0d762bc465ec4457b21d00cd17a2e342fd02f92fe00b6ac0eff20fbff563701f0e71296c44bb4b963f1e87286b19e85d049e8bb5d9634a030884960f299a9eba6c9f2bac5a46a50082f1fad5414f95efcee92e0a92f03ab54de922268c6bac381f6f38fe8ef9b4895decc39de76da37d871265e85d0669f01b1f81e8a740be7992ce9f2ba462abb17849bdeddc0ff74215cec665df52ef6719dccc6365fe592c3efad5de806a60c8f461f330e881efba7ccc7ddd91798d3c697516b42c8963e3b2ba79a26f5b6fbd794d173939c7cad736025e6faa0439d5f7d0a327a3b0ff7aa0fd58e4318f8c70aaf4862ac7ab08841984a2fab3899b69bafa45bf7379f76f24dddf1ec10d3324993ef02cafb9f5aeaf02540bacb142deb08a8641eee8a184934223bf24d60ce15fecd601e9f96009a78016539dc591f555ba06733b1d12b14bb63f81f3c7863c2f13e2b8d04695bfb502f733015585935dad50f860d05ec737064c298f67a09565584c3a642a64ffb86b24231446c83fd281f8e826b439047f42d3b25dfd791f66198689372e56262a01c4a91bd13771001a70c876683d67b5c271749a9fa544f354e4d2ff72bf2b75d06af56d4db8f2441143ec743ea05dd37c85f7a7673a14dad464a90e69aee15c6f8637310deb8f9b8ae6ca894bb5d6ecf6bbc033a38beaf5acb7f6b9aaa3a11b19a6c61becbc15995ed25d29a090c460be173d5ad6f23b94f89a2536b704c6dd094013a53a1df4720f555cee8578e9040e67594ef576dd075b8af4acf8b36f0abf40518ee7b1b5e662f90dc8993b42effc1db21e890cf40f3e7c34b7165ca45a46eaf5c8303ead1437dd5c5415b11651ad5e098a9a8e1a1856a4159458b0039ad87fe1ea32e58b5ab6f2075a253522fa07969f1b5b346bbaa1f9db21961e3b129928b5550f287c402515053b344e9671fd32b275f8efff658e5b961939f1658e4f31ee5e8751814e1b46b9fdb863a8cbe903e128fbeefb5ba80f1511f79f0a2c57599c6307dc66dd08b3fb795d369f5eba758df36e462573e7c7f777b89ebd75ce04c2548189ff72aade3c2281fdcfc359df8a344fb86de48d1e5746f092c1944b649e855b27ecf72765c97e4b5d831de7a9c9fedbc8964b210c3a27edef8d564fc5125ce3a7f49a71b3f7e8aff907e0bb0d3e6f99d2edf090ad653ee71472285d3e8c34535fb651c15dd724d585c700b4b2ab7de6beaefbf41f170c764d8f137ab377d90096dbd1cc566513689127e2ab9906f1ad43a7d19253884e9f0c50a5210b32531e65551788a73c73d2882ce2f715ae38c8fdc0be20bc3646ef8c71eadd33697dfc17ae2e94320ef8a2af22a249903c41c56ded039075c5fea11af8ccd4ea7ab851cbd1459c61bce4e8bdd8dfd547708e857409bc49063dd84d071fcf0ff7c37e79f66fa9e18025d57160d797704e7d9df5cba1c58e64570c67c8b5ca8df2733c6ce0c4317614e6623826a9ae0cabcd527e60727c0451edee1453a621a40774746eaf72b234f5d61c90aa9cc63e656166797848d0cd6dcf60b3c4b50e77dbd78f4387fad3df50b912af2d0c69f54221f08edf1b0a8d871820393d36e52c56014888ab922795ef87f2b48f3d3dfcd697841ec210408d4abdffee6704268a0c981324e8997f884892c32e64c3c33e10320601063f9c2fecf25b20af41a8dabf551de0d7d73a35f56389512d95261551ecd4e7405f91e155d5d44a26f715df69b88376a94fc76b399c0d1b5136109f283a85cc826bc27d90cafd57310f59511fbbf7f8e63f2faee94ad53980a4218583fe63555b02ec655ab63c4a922559a9793edf4844348227b6177eabef535215247c25079e8bdefadfd886e30f0f9f79fc0ff21c53ccb72b4fc3b6c2e8ebb18ea6e8132880bac7cd3d52fc6a879d90384554e867b839cb71f2be179ac312b50a3bca31d3c447f0499fe8a1cd8e78b81b9f4a5656f5e261879c463b5f4e4025098757c6fa586aeca957e1909e41884149bedbc4032be78a65bbb65fa377bfdf861f1ad74e09ee81ca5ec2fddbe7923ece34bbde7770924c67209468fe86774f5c91d2b0c967cddc7dd2d09401bd8d2ab1616efaf70ad732ffcfbaef9bba4236702a403be51988ab6806d5e16292148d49cab9380bab1399755bebf0b405d6e258da8127885305690ba18aabfc6b009937e437441994158e1c972ce06e810b60bb5591b9f54f3372b505dc20e4b5b9d389fb11d8ad72b34be602d117197bac2eef1604ccbebab25247fd1f275d669552dc1df74e872e321d3ead4888d9e968eb7fcbb3ab6b47081671660154d755d9e3e87289681c636b4e259abf878611bb44f124f7032a24cea217a95142a88132f8def73eff0f89959acd9807b4b35d2a87eeb81c17666bbcc5832c0bf1d9fe1ac988c10676ea32ac2f6e82c53fbfd49815ba391ac3006f61583939f5392952277c589e83d9ced6394982b75872747100582e02684b6af6e496fdb3df09c967a09ecc5dcb794307007701055946d3b19bfc5374a4f5c0dee5b9a7970ab12aeda38fb3ce193356e7f8f2914769c7b085eea3f935ddfe90a2711aad964829dd5b4453b339c7edaa25a7403728e2761eb0c3a48eb8803c15955ae94168b0169ab684fd8bd04efaa170014b682f72e44cffa6f027ae5dfd58ce1c04d24e619dedabd10198c9995ba3bda49908f377b99b7578f19264efb94e77773fffe9945eca8296caeb8d78164ab1d53eb51fa45bcd64d2e1c5e5637af1ed126aa84a86f7f2275239ab4fe2f1fc84ca85a91e94e82b943b07e1b4763bef8498febd213273aba4f8245e7a54803f5c956236dfae9acc18e986f721485e33c63ed80fe42c7a1869b8af34a9c7e8bdb1291ab4c0aa5e61180b2418c1128991859931c0ee26eb6c0bc7636ab376be6ad87c7f051107ccbe3bc4a3defe109ed3d9f1c9f60ce8634ea01dfe39a32e1db8fb9c724bc92ad498968eaa8598b8bd368b86c42fe84905c38d6a5049430a729d9eea61a5381551b61cefb1d5c9fab6258079dbb61ca02fe2811e8470837870bdbcbee1176cdef7f0858111dbfef15fd69eccf20d059bdb7e7763d6ef2be71c140fe458655061f2ceb54acf36157bc08698c1b07088f17ef70bf55b8c118ca3c1e4d0d31b1fdb9a249701016443861d8c4b06be78727efced93ab9972cc375c4ecf70a968da3cb69e6e9a4e6c9c3c6b8b5a5e451505a7bed8c4c2842c2ada1827a672935346253dd7eb4f8394ba5a68921f5c500e1d1c77b94ac5784b62501458e00ac93d5b1001b54021137e05a78c433facd0a9f3a505230e74864577cd9f37c7e0287fa1b1dc325248b673489679951a04b3de6e9f83aceeb4e80d92956d1080368e6b2f158503841bf8bc818f7725212442c5a69372ccd948ce3acb745955fad83ee58eec756fbce2e0ba4cfd9c12af8e47bbf7197e2504d260f06bef26724fcfb7db00983ac3853420dc460e98e607ca97ec4d9b87c01cf38fd866b7c88bf8e452072f5370a2a61591cad4f9d59f6c95393b40e1c620ad66b05b5f3f01f11bbfb9bef306050541b452541e32fa5fc40948418580593a6534e56532c6495ad2dc79c69e7f92e33ea7412035794b92379cd2d7205b5300fdf6b046b386c7d6d65bdb5827a3e6065a2a0976c60f360e0c979adc03106182c56fb1989a083f3db89484592a6e964d73091ca84e77e4de1bcdd7144a2e27e2eabafed2a8402077e4e7e06511976df5e4fa5fbc78b52e8b4d0aa0a603bcf73822dd211e9d682cd0730fd4bea9dfdbdb46b39b8df58efa0e0188ccd27645f998d6c1dbff6ec8dbefae652ee577c7a71a1e4b0e9889c4a2b174e03a002bb8636ca08a0705ea1f12141370820c3fcd7756bd867c34314e090b203323316cc1b0c7ac460008ed86b8a8881e229067a620ff800855acc166a512438c769fc8555a66a5f9a397e528aee246d972375b7eb9471e48e5852ab1a57a60cb605ae7bb8d2535bdbcdee1eaa5b5148aca361e7aa9f3b5c37086851b6caaa26280574c45ed779b0ff87ac41b8db455b00978d93ebcf381454b96d99d16e9ad14e2c222adab0d100c96b18a8788648d4345deb6bbeebc3a4932417ac85e45d7ec738d60e74e8a12a9ff8c2467c3262939e9c3dc051520ec551576fc81bb3a68b61589817d7ab5aba10ca0962d44732f70ed59ca33b53885e0155cd15b26a685cc1048e9533f0c7c080058afbe2bb9fd23e1116ac2432ecff488b7090ff2a9f785f7fea78f7bab10aa69b01192a8082589cc8cde07089d0f59cf16c47c9c5ba7fca28490d865aaaacf104b986c3f7949ba83dbc500b02423e1317bce66e1e23e3d303ab4741497105d17ed88c4226d82f5f975cdaa742f1f28b4cdad4030b18a3ddb5842c88e43909b542c3a39204e6808df1445e7b986d7b6933042d844bded904ff9b2cc5db6fddd90ef4b0b522d07fc7abebe6e039c13c5359a06ba73c978e21eff543ea43ccc2ac8badf1191984e00e855c56be6b198fbc7c55dbfc106bce5e572520e372159013c6677fe24c7bbae1992d6e0c4a35e9e602462ece28416261a74cf8850a02ba386006b271786115ed84623923ba3c431fbf5fb9a947306e3402d28926472bf32b1d9e4e4d9f035faf773f3698cc1290d874e817adfc7f0380c584de53514e756dd0cd1c065641545413b8dbdc998e48ad6a8f0baebf3d1c2ed8c95dc9a3974f863420d5b70b8691e498429fd0269f039ab09ea39dcabaf96de975108707fa2c2d303b9caeca8055e190e0b92405b40e320e38fee92e9fbb576e5ff94f39a546c3f97d1aa98b7a8130ba97cd7da6a1da584779c544fc8c1e3f17604154abf664055ff79812f12e7c76276c8a7148d36c20023295b67dee4b5c4dfe94d8799bcdf61c91db06e848639542cde9011ae89ceea34c3883cffe8c505680ecd62d5ffc7eeb7d3584c69d67d5b7604c97a49539e5d2203d117c47e61d03d57fe5ae6e6afcb7f51404dfacc95350576b1e31e925138f7444e72845d81de48929e49566bffeffce10bda7d5f21a3689e7a82949c9351ce1d842d607a0f09183f5b43f190cca1dccf58457b6ad54c567a3e320076b175a3fb697a498495c28728f0f1757d66ebdb005b478851b7089d1639f942cf87ca6dd8e5948e5b77b0caa1f3f0c1fd2ef47f91366d9bfade0a791d4c642dca0204c27f01f3f3ef88d14677dc1961ef8e96a6ae84442103ee157ea7478a95e2cbade05d992ae8abea900f15a9d0a7738951f7614a9dd5ca0cf063545396745b8ce6645bb4917ece3aade4943febc84d0eda4d0c2482878d4c93da68223a7e177513473fc13bff381da358762f201e7d6a864864e3d223ae9a8d89143de2bb3fe3b928d7d5a6b5f9d3d02bf8206aaf2f7242438a80d019680b1c108b3db8778c530b2389f020cb2630d06bf2a6d1cd5782fa3c9551649a31d01582bc03a8429efd348a819b491e180c556eb3da90d0ed38dab3f81170af19b5ee65e5d392f0135e695aa984872667b9a08e2c45e1474e1388b2304d71de9e11f754bb4c06fc90498a853fd63f4e9730ee644d9dcc6a4810e276babc6398d049d0ec304d090360d14ba1cd781de39ecdad071464922107ec939bd0ef3b3a8dc07a1025948f9e50ec82f3bcf8f70d5d44de27e7d7f3ac49e924c6294ba8bd3b23e3505cf1f75d49b39bc49e76cf2f56663bba48de3c661fbdde7051e5744c720bdb3d26f3ff6863c32ae20e375269afc54db221a9997718375bf13c5aec9a03067f924433979dee194d23097018ce10ebedbc9007e195c0970c0e578a20117123323c50db895ffe5b35a4cfde316833f6c438f0730083e93336e08f6b7a4a16ffd76beabefc9ce55f75f24426ad04fd86249f3b704464a7ca757979b934fc342d2af54476c6a046bd45bb258f1aaa9567ef7f00534a7fb2db4fab19d3c548ecbfb766a62df599f58bd195d2e97ff30a7ddc192ea074267a654277d559398245ace75711884d37882987f548672771f78c5e9694c0d41530e19283f9b0cba9f8af4154480bd39507a8c2b4690e730e90c3221d4a72c0334ca56711d462cd797618efbaf523bdf44c231940ff982f2694d815f8397c5c9f8d71321ff45f23fe83d0743b390957ccd66156c4c09eba63ae33b0bdff0c23b29b75de3d5863a8f3a50714abe59f489b94b94d4ca549c64e676957a9c344134fa01486ed2d60f094f58c432364bc3d175365dd024bade9594cf84f2c512c559b3b58764057ceba0a4f4f1f3384e5af8979d958bfe56436592fdaa6207fd39ac6859880f3bc9fa9f1fd18b4b8ca4c615221c90b5cb942599508dad0701a5dd9b15a431f56336620008122f601702eb7a28f384a48cb0aa191e344ce3e8abed8b6c26cc65a65ac62ef3b215a5f25539e011b990ab9b1661b2aee98fb51dc19aa5a715be32b9c2a4704839d518e5bc69ae35e55c0e83909bd4b15ba5878a2ed66c343dde12ed2b1d8f211d978af56284e2d11fa567a6e876c2d010246925c69213aef50ea460497237e8f4257d83b7cd3c7bba44fd0637e1a7aa88ea95d68a9d6f4968828695c92238f4c87dd92991eb51bbeb11f711514a88ba5dc17531b55fc22ace152f1c8e1e97169d9d713f61b1a661cbfb0ecdd71c48dfd69af776e3a4a4d3eac8d8cff5e54a68231982ce86e10cc353291d765af289266580ae6d73308c0e54d2b5bc5d316d5e8b8a421aacd8900573116c0251939646ed2ab500c2cb29b0638aba9ec34b4636387929ea5b239b958c52a216aaea863767cef8e22e1e64bc33d04fccbb8ee754534383e8b662a225a46385986110b027f119f376b8a1071423c9878ade15e5996917c34073173cb83e0dda0708e7c3c610fbe3831f4f8f3b20957d2a136a086c4af18ca2fa26fe555b6a8d740ba670c4e43f7eddcf842c795e031489610a6bbb998c5b5423469e78783f2ecf38b478ab38a2014409bda2fb875487e09c614c00c4232eb0b0f5b60582990430795bb56dc31fb1da8a0085fee32e400dc17c4a99cd7acddb480285e2d77d3a2d82073d949404793b5ced0668244356ea943d15c94c9daeaae008291c18bba306bb3cb36a788509998cc4ddaf7d04cf19806d176562888a6c8f94763b2664534399da962d6a48d8d7e8633c68a9fd7d39d6ab47471b8f75727979ad30b174aa53480e8c1d470f343933ce5b182bc3e6ea0a3e5842d85a448beae5bceac13f88a457042c9671bd81780e9f5f4e658ecd05230cdfe6fa36ffc3f6718f44fae07c291a9ca90ded32e721da97ace1e39deb3d4ef398de03921a48ba1a3db58e02401c7f2ba66577c636a4462ca84ba860eb0ec98ba0090ced4c4ee6d2e9dcfa856a6598369b96cd14dad6bca09cd22c1663533a76fdfd0b06b3a81a58a5b5393ddeea990169eb744b3c41b522b16a2c59d6c35dc711dd5c91833df185b139a907e7e9ae9064f87351dd7c08873bdc3668d67175bbfff1573fb7c0cd9f9a1b33230039bc08c2643b037d4b204bb2f407b935e3b492bc355248e95ef294aae8810442aca4b391d5b214ffa0e2bf7d999a7a72d23adb945ebb4db8dc983e0436d9c4dc8cbffa6434ba69f2129ed099932953a5047d2ecf656607dc5fb3e602809c03bca008660b566f4c432e24991b3723b2b81a31f54ffe1aa7d7e7bb333a1a4e6fab45409041423bfc86058c3636ee378b635ea5150b2976700fa20bfc69bb531f57684b5431518e759b41fa2e48e9f8daba66cb79f5200461805f22f5c17c5fbed1ceeef961ae7a12748d4fb12c0c1cf7f742dff94eaa930d9561077c49508ad284b891f7ee104a36d60e6d0d48ea955e4b33a21ad04aad570afe0a06cce221c6be5240fb568f8b1ba5a5b4e7f6da2f44773c910bcf5ffbd8362232e33dc98185bfb53a072c78797a7a61a6465082a036bda4226ac1763def73e541fa7d20cf88ab9996393ea9bcd71249ee34176b142a2512b58840d2fdba9ef9ca19e3f1e3ce7132dafee6f6d5c172339e9551ff98937f91785ad4ceed7e06c01ab813fd3f8c417f199890d7296767fe0292b7c2dab3fa429d1659fb687eda52f86e435743d8dc2c522e768ac4f47642dfb409fd00e0002daa6df558ebf155ca2675a510cc8c998de7392d96764340b39f8c8a118d3f1a1fed96821ed20ee2a6555262cced5e949d4466492f156817840d07a0946172a0c6c37869cea363b9825f2a54b4dbb3c2f1c53485d62484209108ca22e3eef1c0492052d6458663bee93b092131ddecedcce5081c006dba83480a5fab10ee1bdc4f5aca7617a4d59cb51dfe41c9c5c97d14e7a4a6dd4112b772de6c5957909793cd79c13ab19f5b5316b707bc3594d76d28a559a4ed55de76e9ffab6ac018e86b5e51e83cefe7e731a1bff761cd25aef168c35d8fa8754e476f75b8ef3ea023544211a9373e6ce46a79cc49faa3394e8cb3487151b81ef472b7681bd70eaea5a49fcefa20687d452595077122a6f9fdde4e9ffaf5aa7bdd8a0ccfcb2dea3650ca09713d90b16ecddc7df832fdb5cf5e86e52033de6e6f702ccede67d5b897db5b83cdb25f7df3f4f9146039a537f32c534d7609e0acad93133444a2648ad6bfe93f4b62820cfb1d240ca0004a5992e132618ffc2ef6d73c01f271e829e1851cea318656bc0e3db604612bc1bacceaac188b87555437c9965aa30b815d159bc147ce9be77f161468b330717b55814d8e437d70586ddd02aa8c0638ed9a46a5060ab97dd13e0bdc469ff599d233b663e90d8c4ac922546f400986c60706ea2d5e41e0bd01c240eddcd0b00ef5f65244fef2a0a9b7bf40a7edde6682ccb62120ba5ee9b36d6a422606990dad966bacd96aaf9736a78c975e3c0c46c3de80cf45d3fc7cf42ffeadbffe58337298499a7ce60f87c9bf2e80bb6873e57c4e2515054ceb661e8be0a0c2a8ef656c484431e1ce6fc658e93096b0c9d57fd224fd60017e54c6e63f4ecc663844523f7ed70a80514fb70fc259608efef8ac737e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
