<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb50c6ac598ba08afcfe55b1954b774ed2b9433ca7a36b3cdb68edc710e79c3a0b5f7f9fe021fc1289789fc667a017104b6acc53ef40f1349efeb5956277574b6e689ab185dfb82974c69542013512c74af681b4dbc8bc0afd55882f5ffa7ab3d3dfeadf12cfbe1a4a13a5c81e0a7000942558e52388a815cf9f024fe01fbb16627dfeffb81fd6560a56e4ce7852cefb1c38284fbc0cf425f1d89353b59b48c26a7e5af85fe7318bcd99c897027f77e13f3c94e415fc58dbcfa6a10e3e5f50200b92c3e223edf9c8f0b300b31e084179d76bc05bbf283b8faf89a86cf84fabf1aa762a634e419db03da371eeb4cac1d8808757fd7ddb3e19dcfcd0bd058f828fb0ede7422656fe73bc03e86b34290502f4ee4f133351139fb0e41ee07d2bcb7cf8fe93448b8c7dd832674dc97ddb013bda4025508e80ca30092a43378a45327050fa311921fb9edbac833a42eb49aeed7377ecdd366adfbf509c24a9aeb754647a2d77b2eca027b1ac4a4cb5a30d8c3344cf59b0a81548078d91c9c55c123af6aa5dfd277967cf60a771612dd365c91f78169170f5e6ea105121b79ecca400d6ef013b8b6b85bbb032aa0dea3ab77c256d3d0847222761ed1f6b043a7169ed1944716f2be3a5a28b290fa25e45e6c03736f71b65d9ca65f5b51dc8308e589353040f267e74bb26458424d4b5c38c6652b21a5c83513240314bc1cbc582b48cc4d4a900eb49210f5ca0ce468c1ff5ab098c208ec2506c7b0e51959036ee0839cd4c03775306a1851889fff43f0980f810c61555c7655e548d9339eb753d92435d9c003617bb9ebc8859b7872b7851a3892b99fecbb3329593cc5180e4a3a788ebe2fd88b1fad4311c7f5914186ae485444b7659cbb7fada5eb8eb0e9540bc4641e912dbc050fcf8a6b4e512ca6f99261c57d03e6faf460d54a518d7bfd41a84cd3bfbbf0c1a99f744703b060756e330d87de5caf8b305571b694e51392d8ab735ea3ff979dafacfda82cf0061a9c4820906e8bfb78f574116a8ef334e2f3e782f0e5e4d356458c25d82b3673c39f927d64a76bc39658cfbddc0fdb02e9468159d9646386a4ab0bda904f1340f24753173be152c297d128bfbeb73a625fa14b6a749be36869f383c7ebe33db4062aea9c6af48680154639b1db6da1befde93cc8bc6b1180439658e40bd1a0a1a914a40980d8caf9093feec4a78471cd1890dc1ef4b607ff34f9296dc94c6ccf5e92f1b3406adb149101dfd639653826b61c5a6ae70015e9e9a1207cd275ec890ac31b393858eb31b7be1bbbfdb6b69551b0a03bb1f31093a74b1c4ecdad38d517365a7b3a9c3b84e69eabeaf8767da2c8b95404a7cc41fab861db392c6aea52302e4b8f17aa81f90705dd00d6ac0de95e10c5b880d57287a221d6b39c30f13d176afe53be60c96c25c964a0233e8ecffd42e2bdad2562e3c1f9e2f4d011653268e9e6a0facb32a5e4d6af6c11a7ea78045f21e8523f47949fc0ddfb97067bb135055c0552817133ca5d7a18ebd959d9fd8418edb7d355ec587b6301ec7ceeed54cccd5546d083b64c4335c1356c9c4c037e2edae86ab5b54640fd5440a87f0b668638d68d488b34902e917038b42b3d32acb29360c9507ac9f26da0fe8278efe637e12ed5da74a4665a04f3b95e75126da096204b526e3e8d287de44a156f99036e3c4360a4a5693ebb4d0b64c26864d8db22fdfe45a2990c8eec8ce9de9a209ad6593b570cd292962fad2ac6285ca98a617e06ae42c65f5805328a856cd7e1d5f4d3c207e54c3163d9c402d0a431ec84f2c0e24f879772ac7bea1fafa5bfb8986265c781428148627f1f13c25f047a353026c08688fcd7b18f521002c78a1c88c3dfeab56ee78d531b588b3ddb9fb382d22e996701684a8b4dde66387d415ecb4a35148e2313e504c57de90549d4efe55bbb0b3dd75af1f41ce037ee1e4072e35db3d5ad6ab27b991af636b426330f72b544778335d0e3c6427835e50eb0bf010ad140fe9ee98c4626aca93abf2843deea45dedbefab5dbf10f33b5e0c9787d86579aecb552ea522ddbb263f30906a2f3d3eefe2ff8ece1ae14d88b1bd0b0ef65c37d4e08416c115a762c70414af19dde515643a9e763abad99cbf448894fc97515b0c07030958e1e6a2aa3d4157659269a98017d8bb51acca5fb786a30b47ee565e42bd72af46db3365172e0c70606eb630200ce1a644e0270785b2b26fddfa63d4d31f6187a13f1a779697191f1b34225d7d30c04f1c1915ce3d4e4a654483bfa5341a326c85b250557243386f834dfee7207ae37774bfac38a83447d8440498c268475552f95af8076192974d77a6228de974f98b10d6adc7524cf792b2052d40f130422dd4782cfc5d76f9380f67bdb2736a5149bc6f16f6c2e26fed01ab44f1af58979e557410947cdf3dee5c723e566aafeb149efd82fabfe4a90e33d2d004e007deaf4211446b08a6d239bef7c7430aee6d2a6d71c21c554aedceb71923b89dc81255f00860a953116992c4e27bab226b7b5d41861499e40cdafba6fd9b0c12cdf023b2d924d637f959b7d6f144344852fd3cdc553d67bffc0f29df1a32d3745c9136f7e01721f01ad22d1a89b57f5631c58cf37bb7e00bef2b39c546abfff96927d2e13fcf19bfede198c6183e17f10d9848fc533b2b903c2d10e6c20c7b3fdb048b8518ef3489187dba9a9a207ac9a589e49574a3f4c3cad3b1cb9b35d3190e04ca8db1a723a965ec3d48b4e7e9adcbe6388aecc9a32a50e42cfce6b4ebe83329fcd5905056f5e3fce2b4c54a48ca3d00b2b41046508ea2107bd0df1a9fbc3d61f567a4af6e86baee44d9f504df5418db9279d6b6004583a2fc57491ce3f2feb49011e85ac69c13e88b24d3d3614ce8416e0e4a4b63e101c97e5452fbfa8fa897ff2782e44fe0cf431143b6b47ffab10936fedb076c42b64e303f24a463427fa1de8188a511c562fc23273396db65a6728d7cd09456ca315956f09141afd5b97f09f4f9998ba4950aab1b6350a8e93c818f3d4e67f1a0ef940a78f03848b1553034e2ef29b509f74659d3b32ced0e6a6de925f73d2a603635a487014059670e0be9872ad0bf938f263d517c277044d2ecc3a33d19bf1a8e9d64087d3864319c3ea5f9aeeadbb2f48638026715ea392ac0926387e6050d0ab76931b6d5c030adb70a14bf5f1917c0b78327ac4d6616173077a5ca827d299527f2ddb0f9b7d5932d4d2749ad8424121e9b669f0168835efe6f243d8dc0c86c97aacbe85ed3ff3202d716e36b9534022e5d41eb3f6ab6f8868538a214b4a9796c1278cf43165a713644c8791bd5cc0702f5f5475e43459c08f8929933bda55ab86ac57f8d7c83b5d396094ef306f8c05ca52694f8d34cc4edb980e303255ff4c4e791fa8d446ac6703969122b1b9c535ad0e3eb39e0551047c8f0b0cd2c4b6d61ef15a3058164f216b1f53660855a18cbf93209314aecb44604c60b72c8f24cccb05ad1fe54824ef4ded0493613ede111010212ba20d1c304639e24889d8a561e3c78c3b97769786ce32207738312c981adaf7dae5ac02994b5918df98f56ff37466e909d1ba912c8312f7bb3f820929c50e4a15d499d6f244a23cd224c86529692cad0148be21d56add532b0a9481cdef2e2745fb560fd1832222dc28238b276d7838b1ff5d077b56c8963193fc861448c46e2eb1bfb0b707045a4b50b05b719c94b68e6e4d47d91aae5f34eea3f4140cd971f1e15bcf7147cfece90de7ba55dddb91faf95bee255cf6cc0e4fdc69d073fef7039eaa93715d1d804823598d470f493cb0757eaaaa805c9063a00ed51b4fd62f284949ea42089b3c59281409a3ba4d7e49186df459848b74fb5f9a11ddba63703cfd198a8d2e6f70c2523cfd205c91f38fa786e6b988c268d8f50dc3c02af80ceaf54b0f11ea69cc368309e7aa8334f7ff8614ec940f8e7aefdb64f56165bbdfddd87ec8ba7a84454677b7d9090b2aae2651f7b99bb648939b3b09f909ea1ab58a7b0cccab675a0c0619caeff75754603c4e90065bda1577f6463c0c036fb209ae9ead08dcf8bd4a462c56efc1e5b49d2cfd49310b3033e0470132c37c709eee2bac44e4b83e8a92b27e0a4ac5d748edfbd05515f009cfadb2436b7c02e8ea0b48c60ad74207c42453c3c0ab38f07ca8a7660bf7b6be93c9ad0d132c78296738bc749614135a4535068174596f02f2f38eecc0db24232cfefc59dd02582143fb8a6a5e61b723f8374439c472e6d0a21feda4d4ce1702598b82133d114b4827aa580980125244b111ab0d80e0facb7b5e4c839f07f4780031b6d99d5e8f8cc300dfeadf3afa243c6140a4b4c6cabb0677d39e75339bb7ca067e21371abf94e371b482ccd8c4cb01b6ac0a6b6068765fa6c97312a2dfc15c8151d743a1cc4288de102d4857c8526be154c130c84266c2dfa443282b018ffe86f2f31201db5e158e2b9b05934af9b9a49e0e98da68cafbd74fe37e496adf51db8975488f2ec0db2869d8cb47a1fdcc1adefb7726dda3e68dc60c3f17c5c18a29858cbc7e1eab041bc07cdb9dec03bde8815f971b97d0e5a59e5264742827ed4601eb8991f8610f0141e05fb6fbf865bcc4bb86d2199411ccb80911fd5792986055bd61c06c7a4e38b2a687e7ba07a3f589b2ee8ef7f1ffc27a0fde729e70672e54a4ab9c557a0af8bcbf81258249eaa5ec6c275e28801d6f7ed9d21c90ea9602713e4b106341fa1a1541bc353ef91f20ba01d3ac24f188392eed1f95ce108d285493bc2794efae0256239d6ef445e08ffb7b59f2596a24ee756121af34a22fdcfb19d72ce4e291338cf163439e1a95c53143493ff0861d96670c7ca29220a3ccc26f26e1367769e33ac57d7353b2dcfe8e887fb1c369bb7783c9ae20e2203ec3f3bdca717f4d14bf6cf21ef5b4c71ab2f833d85f0c791bebd70edaaa73d06bb9a78e86bb4886b8a480d2632e5e07b461941b6e0145adaf27fa75b13d5668e2a89e7006d360f4695d01b7fecd9abf36c0c9dfb59bd847838ed86b2a7fc09c99f44c338ee9d05bc0b238c4d7916a4436c68d59c0e8aff3fb3864644e47d4bd02bc1f9613948558cbe25eaba489961d05ed5b846ff2f2b21a2e55897876ea24e6921a15f756236ccaa26154c7ac6d320799d7f8be499e43f27ff56ff211b4797d070d3c91d093b69a3a0187413f66c97bbbfcaa82af6cb6cf6e272ff4ba9f6d08790fab2a270808d4631b6d9852efe7faff900d0e932e4bfa67e630a1ca5f3a1e3e6f335ddacf560055cdab71515c0a05feded1e7c3067e352d0444f904a5f29cf97f0899a97d75da5b29fd7b5b6d27d1afc87116efc206123edc3f1a94a27585b8fbff11209a27778f2e6045bcb4b9f87cee30c696375ebbfec87f3022b627af9a6627b6cb860a43008d4936eca4223d9552a8b0574933721eb2da3d45eb81746d639b08ff259f37d94d33a31fc6d0560d33d82e3e31c3ae296bcd5ef3622984e64698e1c3c03466568ed262edb54f759c5508d9eb7fcb20470173cb3f273c4afb75b605913c613867395e6becaa117ffae2e9d9846ff4f08c0b6aa50ee8ed751f42f80e2aef2f2c91c3226d22d832a627fb23f52f32343a9dde9ca3379b3b608472414e6d2b4c3d5b4b78177f36f73ea85c06a4c2420f07d2c9510848503d5a6ecdcdb6d42bdca091ec86a8959beaf1fb70ec0cab4dcfeee0a72cc15c2c51dc3a0be105b494f6d6e72ef8c1807a5e2a9c9920d7793c9f2d6722b17556bc3b8354b880a96cdea80952ba5191474a36f596c3f740713b13eaa2271298682b6c5b96a49a4917498d4e475e40a544ed60119c239f29f1ad8b1ba37d04d04097e69444d69c5c2c89a8d041bc54650edaf9c6ae5692f1252183c37828f9a21d3ff8daecc373505e5af1957605bfe2f2f7745821923af0129ae7ff0e73dc4c1ea75b3f102908bf0dd8327bcf91cdabfc7e8888ba489bc5c0a8114f144d12500ad800bd52ea275f4e9a3ec9d9dae0fc6c909ba3223ed02b4a2228325880a036ca280d4ff034dd68021a7844c5219fd83e4101d9d7148a2f0f3612da65b5fc590bfeaba2c0447264751a1a7231e230ceacf84097303bdc573a49a3786648518d47a9781e1dab8808fe0a979cf4b10f955926a3f9379e93f26670c55d26d6c23d3d0098ed837d3f04380bce652cf3482bd8c5574687e446d77deee467229745e08dc0a437cc5dfef937d0b3c8740b77e34822db4a4c8a86ef0a5f2a6014e8a21066becb7cf3ca53476101354a3f556ee9cb6817beeef583c9418f726df74e77a818306367d2491b3982ec879208d03a8fc9af86a4efee7b2bc3fae8eb66430cd0dca056ec02a7896d128c417b005fc3ae13de7323a7cfd71a2f51821c273d478a4e1a169ba84e484656bde30324c929a20481316a40fc43bd51c57e6132d02c6e7bcf1b1c92396a4834724a1f170e0947f3ff07b99556fc952bf741dfa5718089d0ea6f256da4ac1f60dfd4edaa0b09b8565627c37f5daf25609cb0761aa02a1866466337490591616bf3032ee1d4f97865ed863ee82ae9dd2f1a4b7d2af6d0f93f81bf41b2575f58b4dbe7524c96a1787a63f829d3e4f14398fae0e5674bf33be1856acec9d95bee1239672d4a19c37dbf13401eb545e556df790855010b388c37ebbeee32e7cb6c9b17dcc14dce9f208f19938cfaa5aa41b43905ab68c4935587662e70913c6c4246ab2930501cf85fcfef20836ce368e4fa9056457db29b37c3b697d150a7f49ac158e06165485a78db8b7bdb9846bcbed977963be592912d64aa9d6e3ff992ce34e915e2d50684705ee2ac86f45526dbba82d6d417b4aeffe35a232f708be47fa959352c73b3f83f31fc884b92a904341eb0e2c35608e61452c4be69c9bc46baffdae585a962d27ad3f00b6c608bd07c64ab2cc6f9a2edd86410fd453fefd628723cae6f3cf5cee8d05faa6823b3e50c5ca5a087715152150ccdf9c86e231088a8001d01e998041f96f422316365dbe2daef14d4350a124d224e61847533681e2991f855f239404483b6e8bf58fefb16c2fcd0416494a36fa2d0908142b02161b1c4f3cb6c78d9ee0be0bc29c062844af567c559c37cd7ab0376eb076df04d5ef39fced71893860111276b66819a717cc580dd4f52bfcf6870911bbf9b5eeee9653d4474b4ff3215f0bfdccf665cb39362cf15da0f11a35a9781dacf6d24f23815af509698b357e76f52ae83876b7de808e5191c10c9e7cf78b53afc9dc0de22c1d18c542c56ec8a86a6a85f7e0822517314a8e22f06cace50060638b98b0675a59050939b8e95a9c4d481f961a619926fa7112396fa1dd2b9771623c902eb472cf16dc765e939243b86f692f5325736898a4b24e3969d130faa028a299afd430980ac0bc049b2006880afa772c6ee59c62c92f2280d6bb15d3fa3155b1bdb1d12b48028cbec9e67bd1b760424dc883f8f0fdcfde2f9130a7ea07d3e862f21953b8ab4ca9ada3f22a1ef246b67c6d5635cbd5c300cecfd25fd90dab66ea875ba3b0ada86bd0fb00fd073ea447c80bc15be16741dcc29dcc71b83c98283b4e6ea2bb2d6faa70a6d61db07c4b17f0c4c93ca4df3bfe4710fe15f7a9144c91a733916e0d2b7d44dc10c7ac7d83b420752e9b459a6a77a4ee29f7608e0051327f0f16167f89c16a43013d4639c330edd230ee7773ec9fc513c9cf7b14c3540b738fe9b591d0e9724b2383957cab7c23cbfdaa4fd368982e4dfb5eb314ab67ac57cf740b20a8232d028d710b84ca69b67f181dddf50df3b90af47077569b4edab269947f615c8e7dc25ce5a87141354d698975b7418772a76fe9fe12977bdeb7da861ce7686c223060aa3046ac59dbae4989f85a78f5b6af966c37a63568bd19142ffbe5d02d00502b94bc2903e32e65ae3c7c7f23332d9080df67bf23e907753eb9a6b6d148779fcdce70b842592a3973b1e824e9b6eaa7c80caffd09182d5074c015f5fb6506c12d53cf55ebcefa8ee162fcd72935a6336835f425083a594139f771e25d316f30504ab504ba7c4ca526b63e904b683fdc3eb2c1e1b2b39615736acac299a4b4e9683b116b72fe50d310cca6e02265962cd5f9a10e6137145db25a0e752c8ce58e869d19ca620a7101b3fff6ce2fc859218850c7851c9b63415e584a9a7dd52c97c32e9a42d2508870171cbe561e0df14cb16f3c772bb33f4a0929c90c6ca92c1077cd334622a9a724aebcbc2dd446f821cb7767523dd238ad68025df543330c292818a643930ebbca3c2c33ee5caaf07f5ad641695bacd3b9277639ba1096ff524140fcd333b9b4621bf9edc087fae1c986011f10a3c2e15a5f6b0afc4468eededdfc88a2aac09e48cd913730bcf4942e1d2d03540d8fbcecd35d74aeb859c2527fce477affd1533478faa6ff34582cf048d4b832923b77a4d49ac31c3f422099e64c061b99050b0368c13e4ac012e3f22b84df90205a5b252c9a6fb46c7c3261641475b5fd7d1790370dcb4f2f3e214a40854ba6dbdbbe3414c609b10a135f6930b46db309a9b555c00865c9778bb1ab7515781c8c1c75d546cac1c4fca6ca3c1be48d6c82188cb1e8909a7978b06935823407eb6fcaf17323a32d818d9fa87bd877e19a4062132d8bfa8daa30cbde58feefb006681c030dc04f0fa1f9c238a4a871dbe6210e82921d327afab0d724bc2db261635479ce3a5ccdf2bc66da537206402b5fa45004f3e323945cb6f689997bfc0805754bbdd8a501212da18cf5186b7fd70b70659d392ddf6ac48dba2496c80631985b87429380da419fcb8c3b9e41b0bb77a759703cfc6089d9c9b38bc8836181c1e5acb4c0913a7af75f8c349ff7be012ebb61c6ee51e6960d6cef9d5b2d6be7cf707b10b459bd84f57735015748718c0e3eaa1413526c6bc4730c650ec9fadafa75308d9ca58741b2b323fcf14b1151e418414ed4587fac976953e5ea7198565763b2cb14ef3fdfad465ac918aff7cad5f30c08fc7215da0cf584d9cc2cbdba034298d11d315f0aa7ae61019183625c3f45ce7c676397599ea45b07cf066b677b4d01fc7a28ef7de22be27ab80f6163b167dfe773900128a11dbbaec0c188bf42fe900bfd9b374af9eb0595e69ceb47388b5fb64ccb95a19cccd0a9a7758652cc054940957e9ff45f8dffbcfd376cfa9962551b9bca42f73d47453cc9df9ce315635a94ad8eaa1034cb65781a7911fedab6d60d696b1d8a6a2486c2a5256c6039d4f0a8732283c07fda661dfb1098cd809e30eef2b6fd39d211c5c4e6da066595f20a42a620a1a5dcb8070a3fcdb3730568df3982a41aade63e7ae7eb04177253010b6065ee3a27aee1ffd19c623a464106465afeb23130bfc94b5be334bfc323f88ee35f76ab2afb793c5a65bad92da349d2f34f027553cf8a09140d174fa4e5bd6b4f60b03fb93322ba73d995c697411be493dea042284c5fab56454de70f65603b8150546fd45a8f5278a140e47f2705a97cf34cb77a25982b16a747438f8caa962cf54ebb627299a1c797752b7bad03783c866f1ba404b4168c1d49b90a3cfedb41bf10a9540954262aa8b6e7f8158ce4d6970861de0a0a29a8007d965301182c7d70798161a08843d8f5f4b0eba1ee0f3481e96eb797b8f89a03106de72a83d4e202b567a16c83e9730866685df4f337bc3c5bb11bed485c46abc13f32719793102ec6d36e4e8aa786e646c6b47c14e90e3722abf8c1c468e2d51378b71dffaec0b7a4d5fa8c106736636ebd8234a8465271f5224a687e1c59e5ac2dae3f02149b0872b31c1f9e5da8bab8d1128c6b2693c12fc8fee485d36c021f2f64b6b34d550867815bacc7b3cf93175cb8bcd50964838d1632d220aa113fe27e1b4a50711994732071ea9ff7b41b9e13f21288ab694dfcf70ebb552ef006b43046f9a79ade1ac3331e399b65c65d2a169328576593fd142f43de3d0a628a83a891812128c8945c67bf3e49222627e3ed988f6be6cf3ff58c66be84212dd1d347a187c0d6077d6a831b3e2c37c1826cdd91e63dfa8e5b58f9dd27f4cedfaf8f9392f476ac85db80c30aa32b272bab2d6626ad78cce3b0fc9fc79a23e1dde67abe9444b661a5d0cada8426034826981d0383f4f74e4083d73907ae12e6dd2ba456e82c8c5dd34aedf590378c1d2540dcb56641691c5f1561336c5dcb50983c83ca91b4ebbc435c022b6c0e73c309b376b3579b04b57a23f0bcce135a9faaad325bf68999f2227ff61069c84d64ad76177de2adc568fd90b1714e7b5cf7336e54c31866116fcaa7b7dc70bbb0f51c5f64ef6a0f2796425e65f033a6a686dcec31e0bfd7c5dbfe60016360f54870e570ba9f641ae1fde7d80e605d3578e89d0f983997322855f796d7eff5f11e2ceb7b31ac9219e145bcb9535d94a5575b2d55431ff766793a6a1e61642a3ed40b9e2645bbc0e43034629bd7c8641dcfeac992b13e0ea138d581837baefaf2dcbefc35a0d90f083e7b0940d1af875a3c38ebd034d6b0ba968d18742197b7eb8c471cf39796a39198025c65eb00fd62cfe4cf1465b882a6b7eec65dcf659ed4a2233e5277ce4ef8446fa01077c4f92f7a95fb8f313bfe9c41137d244d01f70e9fed7c6cc0f3b7767a92a5392b9b3609eb1dac0d53a21a1a9e842bf503cd587fc82c5b58e1c358d5e7b283319ae4cee83a55cb1c7665041e21b0d5ad2d3e58c8262214c22e436acd4484b1d8630010bc6805abfc0a8f443d7c23b42c51b6340679921c26c02444d16a498fa18925ffa834a051de23649064ddbe3479182451e4433a8b661eab6607386d15dd3c3c868dca66a7b04e6973d4a04fe148173dfe946938473aa3abd00efb6cb9736964c1631aecbb3d45d7d151bd1f8cf2ec3ca616856d86d4cd1fb00f56f641d718ea2dcae72651e8650f9b76cdf6b1d4b079a15f237dee170e7b61ec7e4beaa39d1509d8c0c9989bc63d902eb1d0e68379a0e0075f455a6153045752d2b4dc4672453d50add1bc1a96ffa979d9aa9b8752e3ebffa2e86084d79e7f4c57fd1a79c0f7de3246828950414c32f3a83d3da26f968dcd8e34f756c5b8fab7d73b29bdbf671b4e86acef2f85f70415924b4098b99463b40c02563b83ad2ad63d0f49708456f96411a32b86c358f3eea27c3dbacb00648aa5fdd58d26823bd724725c1c0fae657e0ea7fd565df3fb8e288168727209758471e996ffc60907b9268f9a7c75bafa7825c12cd06a2829def4e1a20e882dbc93e5f7506fa9bbe0b2d68f9e5e1337c8fd038878d1b0d3479da5eceb92d58b57adc5f30f809afe402942176b4f0c4f519c764b5a709530caadbfbc7bd5b910b2f2b6caacf750aec194a05f3a845936f535a69665053b886c37e693e9166f906602413de900889866da83097ec336ac34ba6a2a4f6e83b8210f950e5eba71f13416abec256be4b1335da27c99935215ce820d535a137a0a83231f12f137614dfdf359401b2835c987d94f0ccb701236ad1261e91726d4ab647f5966c97deaab76ca871d422ed0eadeb8438b82ee393a77f689b56ac20f21408c02f4a85b242944292536c60c39242e764d1c9cafd822a3ea2c1d823983ff9446bdf2ba34c6db4bc6bb1627734b7958b40985f87501416f9d0dc5800150253c5d26ebbf59a5f6c0e5bb3fd280d3efe57f270a871a9f59c64745f6d82c29c6ac325f3bc1001914afc720378cb5c4acc36f8ffe05b7ab30e4964622b67f0579d3afd1599b9e83cca653f834c45f8811739d81bce79bde015b06e2ad73f44fc0b15c63d5fd772ef0a7163145b12118b3d022fb140486a323bccf5b5e43aba1584d6d4657b565050f5d9dcdaa27ca97e6c8496c9edea0d679f81a6d77031dac7fab7776790d68df4814a68ed35713ce4491a3e1376553271872eb0ac11af5d47aa3e153781b41e8633fe0b16577193068b688338ba3793ff8e8439e93bc8e558fd543e9e78ab6eb7a89844fe0ffa6476e2795d058825a4e13bcf41754b23a518b59894b05a34304622e66b5d190c0ade560243998f7e807873cdaf63a6d5981524fe2bfbf7e79df8c919722b0734147e115f96bd0a27f5f31f8b484960d3aa97f95791ed7eb10b450ecff47ba52522e58cc5240141154080fa893204433577c1d5205295ae63ab6d3200112f73fc585c17199a5c22f35780f0613a93f929e51b7368bb7328d3de9785a68afcf2c2667eb229fba3fe2618ccabb54d8651bdf5403889a7c745d67377cdff3d0aec1511cff328fee56e6eb48629cb3578c0b79403e4c845d76e16ae4213ae5a678ab59fe8625122207441e3421e8c2d6930174123bb1325b9a6887f9a8a8c1fb444f1ed91c3f539e22ae1babc9231a1feceaf415de0f63aaa51bbab2bf8ff6c8ffead74dc6cf17359b8f1a1ea97865921b905e8f23f339527815f2b8395634b8c68cf6acb0d26bb48d105fea74ebfe1731a4471db384ac158f443692469c0dc30e81190047154ccfe9a2550df78e9d01489a461a4327000e6ed4ea1a514e504ced09243a8aca1a90e99c674d98b10eb3b4906ad3e697c414527b4cb849ad42ab5c59995f325a3e121c1bdc5945b2413b89df4132286477bb6e0fc49a904a122606195cb100bd3c70b574f936d91ab3c2f6a3301e865f50b5135388cc53d4724211b0ac0902c208791f5a86850f8d087483c32ac24eb18c6d9f3785ed92350a870d42cda3cb9c9385daf4de7bf368c18bffba197570be9b018b6acf6520dae484139f125ade7c9d2c3bc33db1a6618f7922c466fea721cc1209b0825a166b9a082fc7b032cac268796b0e0564436dd4c0bb4f2b6727469d6d7fcb88072e8e3aea70c50fc577b41a69c8f492668bca8ee9a0884bdba98bb86d57da94e2fb30d72184135098ee562021f6503f062ba012bf213f533e6533ef244136295db58ba6e0676ae4d4bbd8508495659aab0457085c1d165a00f1651083c1cf55b2982546b69064c48162b0d76e3ec3d3e79812e62161e372a2391a44bdf8bb261c449ebd3561a8ae11d2eb69112ac352f982991c8d80b5ba5f7d4e7013d1315c8f1b3be825b40f6939d74692e0d0a6b5e8abc46fe93bac333ffe314a6fc26f2a0daa9f40413e9ae40bca57bc2c887c04f50588be592234a25fcef1663cc7010335765c6a77753039c1d397a4f1eef8270e344ba0070dc2ec837ce305050c0c2795095c649459361b99fa435f80c45317cba42aadfab5de06a7e9f96e804e9df77d242b6ab71e9838e3516e985dbb2ea2cdb9c4c2767b2c14ab4ccd5615eb5d89edb6ecaeae4f3a16d0d78324033b36166589e51cb2f0dba5b268080effe29c0a51fdfc6c94e0bb242a05db9287aae9b760c24ada3c9352233b93832869dc5f92fa8446f6dd3abb593f3237094992e0949bc0c81e9b2acc70e99256121e935bf43e9224b4c7042faf4fe6ba6416f0c5c4568c3fdb86048acd61948f17b5da38356c9ed934f66ae1f236532ba77b380fe9ff624a6085ab65a7b95ce8a41d650b773d99f298b160e107539358e6568f902ca940df16d7b0e21fcb699e23a55292e43c0cbb55e20bed56c58221933feb915af587a004497fbbef53784a88addff1c39a395c53baf0a0336d569e3e99d33ee9fb0fec6b1a484cd0a8c79d40fd9801aba7bf8aa5f2e52a035ac8b65b421b5a6b0d379c7c82a8ca7b79844b96213b73f6b5fa8bfcaa53a3e6b1ecc3f22e2c146c45054ef582c0b22dd48e2486921396f80cd5e83df314c56d1ad1154c1e5b5c615087146925f51ba1d61e2a810f85ff66d90c29e1ae01a0695d1fa1d89288673f77feec4dc863a5935ac57d0b9f67298bb714a8fb3f4955b9ebe7e9c457b44a746c726ec3aed8acead42aa43b9c0a0f715f748a9b549acc71f63d41116a6bbc3113bdf4832bf61071f697f239eddb1329d13eae0562719daec0ff55d3a6d7e1ebbca68eb1169b2aef75acfe83569ede9f09b164c52c8c7b6364cb44783168b4da5f7b695b78de04b991aee816cc56a895afd14d50017eeac97dcfa20c1c7bc07e72299ef941b340331dcc15120279c9e4da313f9b2652c6c89be990cd69bdf9c4a0981bc6d0704700cb5aad1a9d8f49208f57b0b44f611d33af04a433b84033b621acb268173b8d9c6cb19cf54dc487bcbc940daba98af31b43014c05375ef182a80c04c54101352c3957f4b1db50ce7c90a8c25aadf3280d9f69aa8cf612783264392154cf88137f9b7336abbc5efc1dd227a73b26f4b3e57b3e7bfb40b72699a7ba7755af124c057874f23682b040bf11818f3df8f6dc2fe71db4f5216873cd137559d829a32a3173c518424870043e186df74470feb5d071e27f1fefc4d4398250f0ddd05676d28f5739bf2a5a49e2472b5b4935e48d69af5f08ca1b31522c11a2a953872dcc18cca5251c8a2f933f1afa4e37efc310112b377ce7dba8b542b83fcd98c2d755a0dc734918a988367b21afe2290ae7e38e491a0dbe358e50c51520e89a2de9e45c704b5d4600f2c2bed02ec154b337e30a1ba1d82b761ffbeb2773158352821ccc08dc2788aa0eabb84a974cab21cdd32840721b4fa5c7696c32064f518d292b4f2b43b4ec2cde393b05b9e6b23f7147a87c5ccf4991ce7a8e0cd30552d568550f4189c9a74b725f481dfa488977683302505ac1c51256d58120ba81f1ed12b37d86b8411902f8b3f1359173b15361878a34bc0ca97b8c5a9e36d5eab5498c8290047c9c8c2c985960ad3cabe69454817d16e807f0a4eb46df738b4238ea7bc7eae267c2be32918bdc553faea953a2db2014d5d4afce52fa60e854ec29bb4bf3b1c3f3021656d8af0dc92fb571e9991ca6bc52d8b352751e863c7aa10e58e5a236487f0d5c53cb25ff31c05e980f415dd627bc0cdea38888b89786d701a5afabeb06dba727cfdc9f2d369319aa23e28b59fbb9e20793f13aaa777eac625f6c393c2b02e0de32fe39ea35501ad9fb14da18bb83fc4fd478646523e5e1c0eb5b8b4e3e7e7d8348d52d8eacb69e6919213ea07315a845662fa2a27a79f8cf6be38503bd1335e4c26ee09382f2f3489492fdfe7cf8ef16adccc266733ebc108a566c4005b626c2ffbd485ba7356c3d9ec049b502e136ae6a4d8a2c4d78b082219c141162132ee3f2f8393f44868cbd0e2011ccd065e5edee68a96d6a0510e900eda9e35c28d18c64f71b856bb8193e454cb82f0c9379e06cdd23c487d26737110c378f332669a13b1fed3569013a4601ea4e5fa2ef777d19f24c84408f0f4edb586c259682f5f0b72615181bdfe64800057ae747298b72864ef896ab121eeade5bb7c053a1f6fe1863c2bec3af7a22a6e882753c0736046109715567def92bc0bd60115f1594adebe734fd6aa8bd7ff27be78e0c4c58640efd6b04a6b03ebc62e1500afa12c349d7fa28c74af233d995be1f71e4fa1aed387591a97894bd89ecc46545f66db2985ea3d989418b76afc3e303ee0a28d1dc49241bed6dbb7acd3e11dc0b08c5a61f2c3eda788d35d1ef7bb0293ccc8548653442dba840d3400f967579dbf0923997c453a620b7260c8ec24d9f3e9f0660f5e80e0bb72e80a1ebee903f7049e895a36d57d1f3b680b163d818cf733b2de0799d122fac515dc48db3124be0e72198d31b5b05bcbcec6bf63865372b4a946f4d47c09ed4cce8b6adf3ce7d70dc0a1c941cc2f4a11fdbab0faa193fe4103335c21b80f289cfa35bfd42388320fc972375bb8e49179154a77daf8b91e62cca91bfb29a128583650ba2c34d6184010c6098a5c31db9edbd402f4e355b46a2c837cfb905cda1a05cc0c7b817b40cce83dd22d0060d7d2565bc33feac401d744593ab48553411a078a3f53632588a31981b8e9ad3cf970b0765057d2e129594fb644ddc538482839bb3f22e2fd783a7a62eed4e6732cf8255fb1afd0f271de1f1a8b28b4185b6e4e9a700c1664371b10affad0a4b4450f1394b7d47b5b7ad9b7a94a24883b6232b167d2fd55cc6bdf9dfad10e2ddb2fffd04d3ad3a62d49a34f1c01b7c984fb2d7f883972388faea2ad50c7e4828b78d74e157d548996f81abf6d0f3a1485ddf9a802b49983834b1d3b368e3c8310c959cb034006bdb1adec1a1025da5010281ceb92c78a64e5c86987d5bda24d6e564e968619f333d516ddca219ee9940fcb7ab16e62ef2e5465724221da7d3d1f735b61895c73e25f0af8f53d404fbdd023e2ce7024269143b50576ee920856801569ccc5b45de95ac695d0e6ca3c3d7e3fd1a3d613edf594ac0464c04cd99cbff4f01b5cf69a1aa35be7f19b19c319e4c84b166d9aff259913fd552b97fd5fba63743b87dfdcfcfe0fb06c2a53a72def0ba33681651bcad43a7ca7f502731776051531847229eb0cabbf87aaed6bfdaa98a32fddea0a482a9a734425428e9e5dc2eef5f6b840e56617b3ebd128abcaab9db962d76a90eece53fc63cf6cc3a0d210133b51b395b4ff64b105f4c612ee65beeeae7f5fe31db041c4d9e46f8294564d7fc201173ffb2ca5d5f3f84a4cb59f2855a83f74e1f699c27119f5741a2f4d95979d300f09caafd39a4c617096722c2bf87fe167ae6bc4baaea58e7c0977d59d93b9cefa6274b185eaed3464ffb4634969367a9f1524058e83f27937144395ebf11aba6612b0c97c78b4ee39c471ad4d9a874205c63fd2d54257f4887f92b6a813ec47cc174d11a506a57a0a17aa8ec7020a60ceab795de3ba873a4d26352d5ad52d27a88f82783ec40cd707f0aff49b660e6ce39308fe7829792e31ce0514dba67ed7ded24fd0046d1eb48cae1e8e1871ad48b23830c03f540549b3648dfd916eaf50c7628854205abd3459a3e87bd42969085f060458af0568d91c5aba47ee7d94e2d7817c0cf40cb43a3a96f259d375cddd2b7ddea2f1dfad1bfc8c532c70e7ba9514c8090e8d4a3ad34b55a3afc0cfe389904614ccecc2ac8078a98ff24991867537c0f7a94e3b3a7b57621639a0e6556ce64b85668b8bf22923c679bae1b2f939a7e9e46fbe6fc33b59bd9b977dd6878b3c1c4cda161c52b6ec3b85c4249411c9cf169d0f9c3dc8a18926c1837ed7564f118255767515d34c8d3f76a61ebd5cd6545ba99267bdcde190193f625cc0ccf6a4aafda99716e98da75fe25ffee49fc4a9ced53d8a60f6134d164f73f95c4d1e153a8d95b272a727f509883e2f495803a3a81745eff1338fa50453c42e43b6b94db5df66e4858aed6f3cf5a9845356d380000cd5d3180e5e473485bfb532a53dd20d03737c9c9d757fa366cedc7cd338e70bf8e674d5951d6e11831ca25189c42f02a8167e9311656789377626a037b92702650e7d41747287b23d8aa31e0a09ca748f5d514ab80361d53ee3e736fe19f00dbc4fd9d6ff7f15891d8571301527324ed4dc73d95b3c8575c402da5ee50066cbb89c2cd0e3a42cc88223d3dc0d34f559b78e0245df89f47560aae0febfa776810ca41db4585cb0f4e2a0a7d11b73a8a13e08794c90744d0fa2b15e3d2990ebe31392f150c1c491525bd67caa3e1f6d414903dd62f9243f25c6bc1870b68e874c0b64d1affdc6fd1ab1513aa0748f539f92ed8bf01996890a98d34947e6386630a14b3698ab5e29e15b6bf7b52c1db0ae6e41aaf65b675deaef4422326ace85012fc66a2122e93f7aa496eab320e3e4ded7c82b98ac989736010133dec6e831b6ce17f8effa7aaf7bd3ca0128434c325a6fe87e09333551cae091a15e25885dd381d20e9245ccabe7a8cd51add539404100f8c803e982ceeb9c2f4b9d684ca0caf44592a73e13963fa89e32c423105ffd4e1b5fca00e4d444592fd61ebec2f37f8a16b3b3ae155029d03fcd83d6e213102daacb4ef7a086d5c239981a8b204f10c226a81f5b962bfa2daa7957964c86d1f73251d1ccecee9fbde67fbc4361ef6f2910163f2e7657ab63e669c402e91d61733e992aa8eb67b8cda2bb3227c0afe45c33ba316bef50a2bd74890f8767bcf171838b1ecb20d95271b1986c6bce8bcd16ce48d0609007","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
