<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d78e8a5806c241aa0bd86893d0ad2f8dc0c9424fec8f319764123967690ff86633f4cd9d05a11865fd530aec2364ab6313ee887195d79899f97b08f8eef19a96891e3012955660b3939187144feabb8abda0032f2afda22dcd2a32d430fa3abdc7664446363fb597f11096ab89114a92a72bce3ab73e338205c49b1a5f8d9b93fbc28baad304598e422ddbdb199561d739ea9811336602ce4bcb6d6ddaf7dc8297775201c39cf2f48f92eb959bc6616e08069d389840a16b34655d2bb6a5bf8662377fcc5e3e04692828a929ff31ab7bb56a10ca2246fd94893954562166ec0d0cd94ad9909fd5d24f960c0e63c4474b9618c73e0b2995f02921dbc74ae236533c47543a8fd16659df57244d50022edf450330e97877b53ba5e10254d9a1f7f7674f2497ef2cc9a63c8598cba6e278be30f2f54fae35bf8ac3b15cfb3d6eff91da299722d67dabd22bf9c9b2451a417af623b79a7c1c13c7218918128f9872b9273f249cd88241dab698d9105ae926dc571356359feae22bda3c442d3aeac13a837ec6108cf8f0de9e5ca51b006f4cb0f59b1a4a67381a5f8ac4305ad393f39ed5fd209e88a78ee2ee858e2d33f41d23e7f5545e9638f909395269f8e8ce2292ff95a61aa4d778a5bfa78fab33e5e768ccacb4e06e855510ee7c0e820616e642efd560f92ef0bb99d1027f761bfb92b3393d118edde00e3a12ea7f726ff9ec0b3533185e6fa5ea874d91817f11097273e215c1d5ff765f9e2764d3925decd4e011953f1a311d58fb45e8188cd6ef06327a97cd4eae0253406eba6b59bc12b7d57c3df4a6b5d19bbc4c760313e63e707f025fe0bd60610af31a1d6cf2e420481c1e823985c0bebf842b69fdfb2a1e7b9279d17e05d0b8cb1e0f3d4dc444c6e1db650797d37a666ff316d98a8cf398b565c5b84c001bf43566c958313280a81fb478e04237868a83abd9bfa96346917035171b127bc0d61fa094975507810f57c9d3880962c15887c511739b5cff92a7663f53127912dee363a3c15f159319ac508230bff9f45af18a877b53916e3429f9afa703c12319eaa70b55c31717791049770fa6d852003ede713901f23f0d2708bd0ad86eaf0a1bc85151fbb7d5a27900dc82dc25d069f02a35c1ae5661280b56e10a9d4e83c41ee6c0c523cdcb61a90b211f8694f6245e8556fd02af51ef356cbb3c5c40c1eb6ddbafed22bc0b1d6a73d0b88f0b32cbe4a1cea5a4a6fee3863514d59bb10964a125c2b13d641a1f9eba6f370c8eef0793c0f2513f35cf0fe1ff66d996b43a9fa55111d1fdf62f93a5ab4bf11c6237e911a92b0892c9780da7ea0cfefc160dc23a7720cef8f94c17bc7a977f2b80d11fd20ccfa74a59b9d0fb4a52d387508323197deecaf23cefbac692f775de11905a400b604d9e5976588177a2be0651c60401e15cb9ec406a68de610ce93955b4bae81e5ca675588ceb7b598223bb1f4b2e05e39f751a1e1a61abd5174c240fad04710b69f633aa3b55842ac1ff9b6c5a05defa7a80b9b0d4c189539c7d73bafeed1ff08c66b16bbd6bce18ca31bad5a84801552c56db4d13521a5e5253230578cdc02679ab4ed3aac0e1483d2cdc71a142e2a060f4a356e891ec0941d4ff51a72738114966cdd5a943d1d1b7dc4bfe1e97ea876270c314a208bef818c910a55828fead4fd51e2f9c26c902f36060476d59cbfef9ad96987551a416725d472885977ee7219d07c318346fbfc4c89e3bc2fcb7e0a061ff68bc8191af812550bb759757519932731200d3e72ce282993d03c4ebcf1567913f87788d1112747e548fdb1b34100544399497b9c009b24b5362347a97f749959ef48499b5de8760f9d7bf644c62151edc059d1805439537e3fc34661a5ae50290f2db605e052952e3750486164a1150451206a5cecf4802c9a2208d465717cf3c182eb086bca97d382555ccb782e00689b7282c53ecafdf8310697be10e77d70d13b0edd7e660376099fe247ab2c1fe6e835839bad21c21d24b57099051039896a614b426785cf73f0ee3feb7322cf706996eed1385adf72330cca6b6e9fe08caf7900062ae56bc71c495c22bb092f49cf0575a70e7db0de7bef506884468d12e4dfc7e468f290645888c4722efbfddcc33800bb82ec687a414ed80e26939cd8e67d391b04f0d9e1a1ae534e211b59e91155f72cc1f6b024b5a706a02c121e1608eecba8f8f1fc47d4a434f5e36bc9cc85c002504349f9532bc8c8015b6e2c9604207b929b99cd084077d71c481395b1216439acdca28a05fcbc2e682524ca3d94b944181cb9a83dd2c40cc6818ee264af23c83ea69f2db1969917d5d1c36a6bfa7de66d48ec07ab9b540a3d141cac3b6fe58139e418bc343f6bb2d50b2c86285eeabf6bfd3e0c0c91cc7766d8c78dd34ad035793cb8df563428ec3df1e9497aaf84ffad456bb78580019a842875b45776abdd1bfc21bf9dedfdd71f5b55fecdfa8d7b8d562d8a075f964d776e115f6772516021c39776c2d7fe419953599d68190e5afbe483b83d89f65291418659054c7050010dfe0d529306b9be541bb48cf34a73306ad98718db7f7f141d6170c7577096f6fc3919a1cecba1c883920969b5a4f587e87c2758faaca86b6b826548036658b4bf7cd9ca970610fb8e06aad8bc64bfc6d1622bb4034bd5ea1a67b7f5fccb0303d677c8605d42e401876e108f303cdf87a1b8bce676e430d7d57a3fd8d9f2f3b9d98695828b2cb290fca0ae629a0ab35d754c0a3ade543094ace5444126666a19388153d0eb2c0a90e56382f144d63ddd262e60e6619f67044feb4f2f49d229bab10fb696ea00e148fc3e7673fa6b7c378fd80400627d3f84b3cad038e7b9ee75387721f8b60af97fe518d62b9c6ab325bbfe44d14ae59f34f4baa65911b36eb3e8aed8e82c827a1627654d3aef5d5d80d3964f618ba6ca7cc243937ed10f4be4b717b156073ec1c92f5ec3013ae1b959080b9fbe866996afaa263cbd3b927411a238d1ac0a653a312c3b4bbd8d8287a04786dba014caa704c97aaaf3ee38c9bf1c3d8b496b770c02828c2fcb1cc70e96801d2a157657990f53162a2393d37fef2ab7dc10cc04119441f85e0d65dff9650b36d128521e19ede95b89b193c58c6c5fb795211f2ccbc31591723b81a1eddb983d2f2da21fac7f2a06ff684259f678558a9459834a8e0c11d38ce4de58bfac3c21ac24d22cd40f398f58ac61fbdbd9d88417acff4a125f6140eb106a24cb21866b2d93ee765d658f17b745344b1790f8e286a8365787a6d127f0353fd42844d797766d9e9ba8ca28d2bb3e1756a840e397d13c15bbe12e8f467382b59ec290881804c98c4f077d5198d9f7b98a0c56662c9403a8b8a26df151c9ccca188844d5577412d9af06e3b5eeed6b0d332b2d5f09995a18db0c68ed4312f0f582d3ed18e1b221a13cad52ae59e10b4cf7c2881f91474925be94e69905fddd289202796946566a98b93122fae78905f845637b9e72dd44e428e74039f80bad61b6b78bbc7772038f6a524d1fde9e46587783f296d542dadc63ec5e74d87722f2b524f1d804ed2016a17369d3373c6ebac647fb51e78aaf48ad44c7132d3e4079680233f504b6db476ec47bc71afc20b09c55e4bbb43149334fd9b719e6245dda0d5c02d9add63453ff672726bdd5c1b2726b9c645d08454248ca1b8c57bf4f884662a1383466a7a86e68d5ef08bb03683e72d36f7ed54e32dbff8513caf16a7068327ffe92ba08e9bc3ce8680dc76eb098850620ee5294c420cd50b78a8555030a41b3aa946a64ca46df60743d5540ad6248a72dbc9fd2f2799ff2e8e712abcc57bd53a7dbde821409ee61e8e44a4938275d6f450a99167a8543a946f254d278459ecd829e6c78e19d872837f8cbd8be4299c668372e51157a93512622f9cb9f1387e5b25c724b69e0c02c128bb147ae9c7be340129d3d85ba33096b649303d8cd5ef64b44aa4fb0bd411cc864cc7601a2b1441dc4ff98559f87bb1ee8ff0f818e0a0a383b9b837f4e84b7b89808aecda18768df10fae13f82e81a9d1c00f7fde0b2570e28e21dec26ee7312d81fecb9939897eff54991e7265e3cf46d0deaaf8a57e9add5cf9221b5ba3277c9d45dbd1d62ad7615dcbd95fed57457f44562ac7a5003585dc4b6fa440438caa145e0c6ce0f333c6f546b7bc94350c9d38bcdf3e4e63025f3c51c74c1abc41eb5f46a31219a570ee8ec748fdd83f3c4b13afd49114824398bc01d53b9b209a6c7fbf0431424788dce5853e138bcda4baaf043d425f5cec8c6144157a8cc761b439c9474f8d4c0c7623aa4e13dfc75308658cf50b48af6d9ecadb8601a27634b8bdd231ffbfb94a30e92770c9ebed18f6ca8f4648a69d278d84a03407e946a50239f6171944fb2ef31925476033b0b38839acf7f62b9927259a613181029b36c10c6a02a51c304d23551c11e01215b2f86b83ccce941956c87ea46a65fd6737b44493b562fbf1076ff3b3bebeac465a45b35b59ed6992d7e7e4a1a23e473b20ec505988fdbb83e48dc0fe2ab3e8924ea73f5a0d9aacca515cdb1f9384adf47b0de37f77bb6b35db7e07f076ae525f6d8a90cc2d51a0ecdb26f638301d79131f3b813e7d7dedab9f6adff8e276d6160e042de8a122c298ce11915fa0b06b13453dfff78e755fcf544bd348b3606af2a977eb92e91ca339820c38ab182bcd9fdc2438dbb77fbe07a5ca5ccf05b49e8f9144b66e8f482f70e1830c69b78c073a7baa755e429d74f1e2e945a4df7b55248b27f970ce021a7fa99590d04312b86f398c5bdcccc6982734cf6f4a34046657c40a5a20af4d7cb0970692a5fc536a2de0b3525e1792ffef9a2a9d6317e0ed24eee17c764ffe3a691a1f465f13bbaa342b1edb53ada2dec16e27b7074f4de8c1cef799435e664f611bf6f6d66d165cb2caf2bad2e0702ffacd2ed14e644d1bf1354bfc07c2c46de489f07d7fcbc4f7c26fce574f664db108d3cea5c2b54ac86e2773a0b879bc3810c1617c1e83b5f7bd77909255266fc152d95774fea29386dbbc418813654e3a62b44ac2b52faf24050676593ab178b0f62b7c28e1df07434303702cfcb0d3410fef4d80caa7edb563b6227ab9819cce025a7679bfdf13a8ee03a6b405a2dfcf6a4ba1d7a683e1e3c5eff4d6461cbb6b52b21b3c39835e816e653544e73ad2f94d641ae3d9dc69e0fac2100cd2a4bf6cce67f5f516df4643bc80db070372dcd3f1a6d7260da7b781c56da1a6efb456da21aefb25eba426ecf40276318d41f521788b0c4b7bdb9365683b04ed2de71fa692bccf39f7a28bc14049368e007a0fe229e56de3a110c287c0f1d1c166a10b3b106a599f0a45602ea23583b2418efdf8a22683834c0bd4e1b944815cd946ab6fa716c237d4d80d2460b7b435eeb232be9a05fc42af5b7570815dd8c0216aa339697f54b94ea37868638338d1cd7eb2889d4e760400c2e6ab82e6a2163edc8b8dd9b9f059cd5df03db7cf0a5cd9a7c543bf8a74ef9dd2c656359bb11a72fd5bf73a37424529d644e086e62299ccb2e4cfb69aba4d5960ca7b58b82da9a8d1dd195a2fa982e18daa83ca37377303c2f9269299245cb659a69b983b555d3da4bb5fc51a94c22af718f0277159508615bd7a5f8663fd3e4ca090ca96ca1dd642c053471dc20edb4dde9b0a6be19de5661f19816f1897d3da2d07ba21514b88c4eb222b68641dda4a02f1356663d74c4fb28bc17ae0ede07fed64ce04ffed709cfec04cfdd95467ce5595e986d0a7a91b1cd393390e8e165f3eaa41dcb3fbd1a5a7ed81e3eb9fc33a3672232c70383ec98ced098cd4a88e4944e8b51222f168745751e37afcc617307659a0cf9ffaedcf68710143930481f29ab3a3737117c1081b57129ceb195c208b4a314e358d881242800fcf3d009272d830403b0077df34c696b36eb417a97304c6d781b19b79b70e3758b8ef8aab14424bf5c02b95c1ef607a5621be97bfcab6b2cb46c2ec3757eae91328a82279a7676c8435581707e4d4b6a8a3cb18b05c6604f58f6d599d002d1f76da0ae35057757474a0333dab60c8864f006f19228d13f5fc5e6dbbd252ea0cd4e16c1bd1215a3ac961e9a01d302229abbbf2e9df6356caa926a74599522c181a3dd34d4a1de304e639632d49e6ca550bbc044b4ef95bab360197421b16653f5b8cedbf8e6219266296c3b3528c09a6e3b61e473f38a3b2e846156c1e1f03cb34076494d76d40afb87c3409885c47801661897f49f69f8b284ed00dfbbaba70577dcafe160fc95833aa932598658e711848d08098c3882baba8eb5536a78c7bb03724ffc2e745c2c05da51efa5e8f6f162530181add42f9e100d09c9a92ff6c7f2e4e6101f49d825990d724aa2de44bfd29befabbcf345f3e9a5044e903179bd735ce6ca54963a5477036ff93238ca64d99c6976595fe0e9da8c25b8952205d5d6d58d0ce7b084bac39f67d26ebdd2216cea94d3ba5a6c40943ec30facd401473b239919df31bb7e41e30e3dfda40fde5fbfc97ed4297f02422c5e917746e46d82750bfb4dcc3f01f78bded0c218e32b15ebc8d68af3e8ad689759b472e3fbdff7e651c8368d8bfd545c5f07ac46ec8f4b0da917ffe66d75342a2f7ec667f4f6e8f304ef5f1cee57dda1cb8d038b4daa2e0e0227f848e22dcb93aa4a1537d9a2935e4632abd645a2d78a596fdff3763b882c25fd4a6a5f925388be78db0eff42465a2657ba60a738e5a183fe7f85f757e39790ee2976540b2ec43d4fdf0821762bd599151a1d422d6620958f39a6140d31daea0d12662930b2aa10327bfa6bc44ec4149e7069d121dfce66572b5f20706e50e8bf3c33d38ece2a226d202a340f831b66725764be87a208f049d98c6bf8888633112c2a90652223ef9627e0a0f04e7709a733df1d338cf4eec575b85aed50f4903ac09c23c1cd11b11e630f3cc334d0d79b696c0cdb3d8fd91decd02bd0924669e09fe1ec16a36c39e93a9f196e405db7fee1f89ca0d2b73a83591e1717637a4ef12a70a94c72b4d3b4e7179abed37ebcde257265aeef364da7643a8e0b110a001d2a65404f45c7b9da8ccd784cac0405e224da37b7351117546f9ab6d62f00d041d13cefbd242ba72e7cdd265a2661274716ab889d83aec19e54d0c9528dce63708b4a99123381f3932f1bbe44f46fd261f3ade9cbc8f29bc397be5de538bffa7512f3680b92c7d829fc2498bc789f0ad7ad1d5d1f8e8377fff84e75436909bfeabaa81d366bf9e812d14134fb667ae225a18e50b44384d618f4163428a072d65cf111ae8352a592a3cdc36027b8a7df5bde5989307d96be2dcd2051a79a14d6db315ecbd1a052db0dc523eba1ff6885686cfef89db7fc3e48e38be83a3f0119ecdcc9acec599e919333f1485cad923deb21205e198905edce6cc066a79e5947e10f7c0ac05a124a0e9b7e69abf8077589bf7459bdc0f1118709047b36e1880e3ca926b344c26ba1f4ccd9c741d76ed31f0ed2caeeb1a67504bb81df46f17f62e654ffd252d62b0353df6f17285fda0373fa5d5566868ff322755fac24e5bdb62bad8a447306883bfa37834921c4f8a8fe38165853e7264dc8861ca54497e093c0a25e60b75221a4df5e63f0324f770630a21f72531dcd8f92769f0f5bbf4c659b19432fe6d8190fbbeb30fe7ea5adcdcbb9f7c6f021203d2ef80049a502c609f7d83142d3d8ed259fad24ccd3eddd09b5f85df1833731d48197660066dbdc8390838bcd1d889a31d6c4f368471b4b42b0086c6a9efa5809a426470638896815e8146638c923f60027c4a26d6d6839155f771fddd80afad017de5401b88ac06b2a21c28f7f38b3970a5b900eb7c474a75262ba21b9a7a5ade68c8b8c90a3615e58112486b50c0b022368b27c0c090b3e741c30b5557827979010bf0b2230fee33bd70c5e37364943f995ea5cf1ec64e4fb83ffb6862575e64cb1dd994739e3755bdfb4ca5fda2391b02aa559eb91ddcd17112c5676ec17d0197b048f3d514b24d4ef6f2de6d35820099c4778b47750988d53c74bc13e10b00c728005bab03531f487301ed3eccc5e2b68cef5f3ecff4110744e188e898150d07f8456752d6490b7650eefc09475991c47d143178577d9976831875f97dd09f545273f29213ca5f41cc65f8324d54208d9a5ed38e00cd25102e8078400955b007563de2e7a8cd4b05e93464181f294008ce436357f4a1c599d929dbd196ca626488ae0107f08b9446607e9abe8b7eb9e36f99042212dcf79880ecc99f32944bcd8c14248cad37a78dbcbf527d32fd744ff34f037dd31bca18421018d1a3fafbcb578a1115f83982484a26d3976033963deabf26bf2c0a107baee678fe6b915be0cd9ef82b19b3431d0a2d4a35c775232913b95cf23cb840cee05d43e8a66b5a5c89e251188d81f46ddb7885da644d000ddea0c48246100309da4a6af9c24e7adae0408ce87dd1f5b4a0a5d3d5b825e7ad3c6357f2150328384a55fcc456d9491c3bff29d91a18cc3547e33d6515f83d9956837e2c3532e74714e5087f47851f9dee0d97566596cd8f8b37cb31b8e3e4ff929a7a55708bac55e36cd160122f2de6b2ddb5fae7559a48d86c9eb6ffd70d344cdba36f2c28759a15ff4cbd041a557419e9bae34ecec3451c6764dc7ffd4bc566113d5f8fd49e502213ce784b96026df15da424278093a9652105f587cf070dc6f1a0a704e91df3bbc2aa948929692e4b32e1cf2ac46a32bebb7d34911f8cb60fe793c7eeb164e129ed15bae35a771a94dd2d03fd604bc1dcc9bc4e005791faf46cc3bafb94d278257215e35f91cc04dbfb523650843b8504d7d4f66d794a974e0939f7d41f88646759bb1bff074f615d86de067ab2b0b159309bd8d644cec600e59297b5a814c1b6b536858b3e65bce261da531a0cfb7208ffc2ed0b408e4e5e6a375b003153bba9748069bc5c0a9691e2911a2f406a7ad620e9b4a4a2e2b4fd87259a9d0cccd86054d67e770a3f9a8f2894d3b3ee49469d8a35090c5793d5f84752c14576c8acc0e7ae100f09f7c821f4fb1158b6bdcb2cb2258620bffe89c367108a972e455e887f0eccc6b97bd0082b97ac1a09faff5a2771fc2e6568f6a372f151a07cda24a027140022d952fe19c4115a42f7843523ac429274eb0ece61068ae47da54aadf236c6bb3fcb460bbb4bc0c1c97e243694a2bf97cd6191e662651405a70bc62eea67dc008f30bace5eec4ad6a45cb7cd4dacaa3b189ba8458b5486624040f6c3311a7562f55dc0e75bcc481bda893f0fd6b31aa7e86601d141070eaa38e713766b11d86ecad12deaed13b074c1e63e3e91c7d0d7aaec42b681d348032ff5e18d16f2b6eea3b11458aa094c7ed241765d402e9021a7918074a62e852241d6112cde844dedbc3cd98c9eae035898e6713b9528ff85a7bd8421c560a62b4a8f5c917a0594b1434e3b5783942ba2192426865a7798528e8b3ad2e402ecd04a11b8c1dd89e4de90481ff1194ef252dd4321da424de097f8e0cd269132ee36a2a79d469e9a234a39d156a7e8c07d7de0bafae8bb68fde0b5e6fee29718b90be980188c15f27a6e100830499b2d2eb1b34b3d061e3be7aed47df81a20b40c65aea1408ec770c4fbee4a7ad6ffd11304cdc679adfb2b4d7b8f53950953e5e65710a7d25e2a5e7dd4839eb84662ea3a8bd0a718cb9c50b2f1127e6669f795d347ac5c227eaaa3a3e0247e8984dfd6f88e58577866ce3f13748d8d4ac13288219f330ce0cc0b612bbf7f28827c34e8cb25e0c0a970162dc486fb2be660bcb5f3b9acb03fa7a3e544d991e0ab1eaf53481fa9d37c622683b196b4a28c03eebd3a2e9c4bf65dc918bbaa7f88bf0e8a54a85a2a4e011dbf224935ab4dfcbc116a2764dd3f4967ae28c63d456ae4346fcd96d3a1b83426e1b5e11cccb42445b41b9c967f2d24d301f8feee9c5ffd10039974e640668bdf2f42eee83a88d45e660f31503857028b00bf81ff96d516443d03bc0cdcf70e09c91d5689ab073731161067aa0d5fbed587268dd54ea34ccb3f37a159e480eb007d541a43665913ea233b1b6641b221bca68f9805517da025dbd61780f795529667ec89144c8574095f5faa4b9ad98894d2819bf2be9d1605ecb845765f9b76c23749560950a41d94fe68aaaa667f99b6bd624a83ef0bbac3e8e3d6979195a382a1d03442bd93e79c0c2bdcec3a154a0fb094f1e23b1d2ee5fbcd4fd9d9251771c16c2c57ca1eb20c7049cc496c8d69473af5b827e36782b9bf6254f6c8f777d208baa881717f5590543388f20df2e92b2deb806f7c1c12fe68b1a5a9eacca83472742bad1577b6498fc1f0b667f2e5a257466b1931d334a188452bc2a78f810fb58462b81bb51e40e00891754d019d4b378cca80e0c555344906f4a3c7a2ec328a3285642a798c6b5cbdc1ff0c5be85228c15ff56c9fdd53cef867c262992d6bb3ef71e0866d0fefd999acaabf22d73898c09a105a090e45eaa9d52100b74ce52de2c718cdb1300990ff2462d64d86addf4d272da3b4efca1b4684e2a044e890db4f62c4f04dbdbeb361d0cdee537ec7e6f8a792b79a6aa83533e721573e3015aa99a7f63b8549cdc6ef6f5518bc241b0e5f1448fea9a0706654f6aef35d4145cb46aa8531e3494c476b7b6e52dda158f8a4c0c50f74c2b6425bc3b06994197725c250926089343f81547ce59c4140cb8eef5e1af7fdb4be502d52330d26da6ec7059f0b7c9d80b6a0946feded94c86dad1c72c92b318c1e9b9074ba7760643f32b7c2833763879bc57933440a17209bad9b06f679485e6962049a7297aa01801672dfa76c017d11c5c52811ce896d455fc47d9019e9035a7bfa4af140506bf567ba4c582260adad7061bfeae9becca87321c8afa60fbf974d5ba275e3caf3a7f2df076db36723fbdf2bf21d4d2abc3cf3de43d213c8ad092e12b17719d697b018cdafe9b6754cebfc2352b11745025eb48537908ee945aa75cbdafc6781f49e74232b10f31f5845e84616f9cd356fd881b4e1ec2750d657973453b14274275b2e04de0107048c1ad0cd5d37a712d8f0f8b9d52b109db7c07c2ed4cadb6a4a7882a20cfbccec51eee4cda82ce5fcf216c054427a4d1e0014fb9e2d881bbfc2ea7a701ab6f6c20bd50d2e69cd4210a53e875f9116a45d7656d755678497a3f2d5c5d0e121306a8782e5fe61fe3e46aa7f8b870c6e0a4dc07edb3d56526449522947f9c4c45bb797442ffebf681a25c094975d2898d1bcdcc075f7ba69349e8f5e53018fd17dafc913ec4bf903baf42a5b84c6db80d91ba5257e424d6ec11e93f4a94ea2533775accfb050a4763e26aa915c8077fc505adc176833f077f7551541f02c3984e2fd56a055f27b105028e28ca9fc6b16eb30a3f53f996c746144088378a7fc672fe5f469a3c6e9224e0d3be57c13eb60ccdc5112f4189e89790e85ba32be44b0886d7d1c45afa98a7a8b5ed14a07569b96a8897d70deb997bab46360e2f1dee53b235b1b7abf69437093c7ac1d4e8228b1967daf4d519acc098591d20316bb451e28fe514436358e5b66b9af74235983df45e97eef116e79ad968411a89d7cb0c7dbb66e05cd40be5959724a310b68a70871764dcac160a45a3f9146751ec942d5455d612be61acb653c458e022ade6330f016323e7efd99e0fab87305c687e6245ffb99d37e0efe1fbc05b088b6ca90f9569a13dba7bc726f2d52de5f9340d0e15c095bf1eb2a89de16d39c9b4f3d80e7df8cd466c354740eafedb98d4494608eae490d9dd145fd23ccd2e91f21f764e1e4e48b44e00dfb3dae74e3679060a1eeb876991661e250af515cdb78b79c0582be885c7d4c279522f84ed0775decb2c68e5cebeef2b122b1abea564b5942e524da91074dcc9f4968b462b7fa73d234de8c1e2144deb0a8d7bd28cdea74c6a953de25aa1c0fbe5ed42b9459d37c1cebd1a1e7198a660b93a9d2c8fea120ff4434e661c83b829ee974b1896332026b735566bb4227ddc4da807f1684e7b11340ee8428dd41436bb53708d91ca27d739d2fe8a09f5db32206516d194867ed4423841ac2a52ef4aad7c0eec8da923df426f390b918b5c3fd564ed9cf3551f4322be65e21c3798c5faa0b665c47d04f771569a4a24f668df9108ce97859f4d3490d1e9bcef315aec0db6c5dee8587acb4221c3aeccf4546c2cbae9ee73e3eee6f1cfd52ad5811a3d949abc6a13992a26c927201ef074231fcd2762b39f20fca6e283bad2667a7f1c3880771d424c88d2cf13b25411915c0ed31045cca42e40a07ca23a67d8542d76e9ab71069da38769c753e50814f4a331315f3e26282b02e934a3a7acb321a4349850a4da80bd5e0e2f0cb5649e3a204f1379b6c77a607000ab64f8e8fc8128c0c60a6725e1d68514df3bbf7cbb2b423bd781cd2879403be4511894dcf5ceb0dd750e7ee8e81d583f42295a55939e5bba534744a31a10c5aca544f76a9721ca1990fa575695d4ba87d03b84c6bb1154cdfb851457fb24bb88df023f6d1fecc26f0880b2c2e0e9d6cccfa28420896462d23b82508bafdf40b0146ff22d07bf7e52921a43e1f152ae4fdba676ca5c2b3b813f3b1df3a7dd5d6ff5b4afbcbb16e8831d6c2f4cd0b0120915e9ca584f4e169937c7894efde0917c018adc5094ad61c44c14f8580a90608d4aa241e2587e9d4e5fa4fbe0437f8ddf8c34ed7c89853cdcc06f9fcfae12d28e635733c7cdeedcb050c90c03246be8608e3ffb780b88b971f8eba2de6917b12617f0f495143ca56a1c4956503e792abe8aa4311a132217d5e496be9e2f841cd25c2ddc613ea815dd489159ec8b05f5732d23be56548721cf07740f326664cf725ee1712f64b3de2a960e7e10858d81e2a354fce3f7738ecec621b94526250037db9450726b6e35b9fd51815eabcbdf1cee05cd4d513519ef8f3ee416ba06a1ce447c9393a2e13eecf970fac5b12c7a854d8183e732e8272bf830bba59f3fe4865dc47763b7aa9030cdf15ab329d3d27c9b7dd168b1211dfbeb9e737b7a5a51f38514b1da8f30fdf5cdc5c64273c459d4f8d50dce46a20259b18a3defe231612d012c194ccbbf582d6c0f2da735d143e152e818119d99d3dbf613da89ea664aabfca1f9ef5a5c1d473251cbfe3bcbda5300bf80e8114886ea88301e14f36e7e2e8fc7ed8fd1eed21b9e3ab181cb9e0263c3aff533d5f65640524d959367d7fce1187b8f1a2eb4dbc4176dfe212bcf4f6d06940f886c8534046b60ffc3456efc5d4862f6619ed3fa97a7c57db5566cf5a67f7e989764beddaf5ee0e70b7390ffa23cb677706c60d2f6537a05c099babd56b48b8e4851bdef17f7f52f373797197c916b2ed454251ed723224d7ecc5916d656f5248ed0807e0dce95b694e0c29343cca560369f0d9c5c492ab79086a78c6b7ba708b3ea64b9f5ea1a9be37541d8435ccc4168d3978b931eda39c56b6c8762a71decb241b7938c6f3dc0002778e1d4b7b46a5f4dc5586fdf8aaae3170b2fe88d7a5386db47c61831ad1079ab83ac983a4a98cbbd0fef66de8bde7ff44a138b68c3d6e2ad53e93ae88dd37e13e6327f1879c837b2a249c415d0c7d1d62e4a7a4b1472a2e6b15fb94f8842fb60d41e5e302a536ccfcb307b33dc5267b663cfe6c9ba19b87796e20bc4ca3dfcbc20ef78e3894fa7922a0f0b3ec64b10447da0f4309a39e217ba0da930d29c39159b096f0fa8ace2284890fbc27d7d161e12229af4e073a8843723e378efa2f1c7836c197343b5153782f71bcc17ec096a07ecfaf4d5653a8aae0faf2e52890dd285d0f0b9f1859ea4d375aeacfbb8b22d1b39895f6c2af613bf71957c15125afaefb22dec55f00a47fe1c20a8795427f45bb7700f4a04b98a6c727e5978fdf02e0977ea46cea11066a49ccaaf18eecb46b162df3e049c4983b745310124ad500ba557955a775d2271ba945c7dffbcea7d29d4adb90dca990c499cac20fa50d855bdcf7c45a4b851ee061e5af290a869a4ff09ec0c83039e1fa26db02394afc2031f41a33b55e9a6a86a89a6949d3157d314806d3dcb4eb6c96d7a933decee41bdb442d86fa13711b2fd071040c6b2dd875dbc0ac1017e07a2d351cf576a33ed5ec4cb8aa7f9bea2fd929b7b4c9348f4b12e13801f75fe795ba9cf5f7f6757403e27a639e7e41e27e93a129ba4366a8b77e038fb4a48d216fd432e03aeff7b5f1ffe50d6a8565ff93a14586747512cf560fb3d7d3a3133a4a1c4a7930ccad8b2f74137d3dc57db4702ca07f23b504999dc8c49ffe86c8781d9cbb459d14f33f30c613085d34326d334f7ba46cc68a1c577640b728e3aa962e3cc2af9c138febf6d71ded4049ac7225179a521ef69a7056466f4be2b6d379949409c6f6e1a833153b5206ca87c7471d4adb80e3180024bb5f447277c40a7a3373fe87f4cdc0fd53bd70b32b65287ecb7f4caefd35beae4b07818cdd904cc8b3223710792608c9baedd23a85e563bf37f2589f0a51a93b50d930eb3be9c49e033bd3f04dbdb41bd910732b07dfb8e0c2dd876671e3975ff9fb6777cfe07fa3fde34661354d9262dddba89f1874197719ef72626b001f2d6e250d15141d2e1ce11b46d51243df21b0267dbc818fcfcc99ea447cc2960b16f5cb6ca4b1a503f1f0383d90666c74e3f6548bd738ab166d02b80e594ea8026a57326bdd37c3e4cdca702eef379b84776805509625f54d176ce8cd8a67fe15b6a1d2d589b26d69102626ed2df13a398a3f5094837f471f4823674abb0bb8bc4259ffde794dfeee6b536c7999ea65cdb9fa0092ef6b94099a3423ba11b41c679d144c5f59f4a23f257fa3175bb90b79f50032bca85f3bf23cf442d9dfac407f80af00d9f4d9cfcb1d8d32a454fc73c5ff393118264dc3d4d70bec7a57ccd37e17e6ce6bcd7594cabeca3287e56df93a4fabb332ce3b232712490d4ec7ff206aca89a9ebfd877a8ed81db497c3de87b8d250e92237159afe1083d718e53a8bb75f562d9f6b39611af9a80fc137c5f2bb4af14e8a1c5b8845270dd772dcee35224f5eaeb7d3324b10c384f3cc723fc5044b268f0cb1cc82ae9403603d7c37de083b5b247196cf77b47925313e6cbf2b22367a8620e3c2ef0531e06021dc7389da239f8138044c4303be71a6c92595f9bdee9bc20404d0f8a66ac79d56a05b9fd3ce2acdd799f7b6e0d13ef55d50cbf7f9ff99ebe357a3c508a43944e7923f47283315af36ddf7e9df6b8898e98c57e060768820961f3d4376d0e90938110ca9a46884106bd5873e13e58c997d830f4ef7a9ce6273364607b70f05ffbfe276c2f52e1a0bf17928f622e2dae0f0e2f9ff56184502e38f8055e1d90a1a316f38c332de64ab7854a65dcf052b28154112b2a5ff3859c1c518023656a9be22cef276e8f368f700eb2ae5e07689e55a3723fb42e51a1cb884f216b0fbb53fbcc076c31aab756cc4c2716d8887ac6396ceccdca53fcabae63e2d594379b941b0fb28a29e499ae0b76efbf40f0d9bcc23a48119ac364cda3978376db836695cf6e5fe487ad5b175931f1fbdec58a9acdbc5ec624bf9c93e23609315ff6b35e3acece9010e36c415c059d6a04fd43ba9bca5b2b66326838d4574612937730763619b12481de61a1927c2cafaab57c93eb9ecfb412fc3fa7efdfd33fb2c956c75a9d7f3767fcdd981505847c4be360ed8bfed60ce5add37b66bb1330742781d20d260216b957399cc094e5ae25cc6cde1c369fae648af550c3525ee3f85f41ab24244b3de9c9220d50a29fe50b4761eee0395f0bf7b64e32f415a70274f54de811410788c51a845a5147d246f453a798d8934626314382dd809ce19fb40dcc58e8b60561cb365f06d6e0825f737c0d57b393d38f65416ddd21dfd95a53a5b52a379db0f1724644fb0aeeb97930416988dcc818a44e62e7357fa7ba106a3cb9bf413c4d14e1f60710dd630b78a50e0ea180939622b4642336bf19e70a93b148345706b413fe0aff2c2bd73ad615ff1b077131905b0d6841fc1feb5feb0e63915693746c4af50bd585eaac10cb6d46acda8ab892c042dd0a42f41cc64dd7857a1a5d71662bbdbf8755e8add735bf33e7578c55b72249ef47a4c2cb1eb22a4e0dd8f971bc64bd753d4fcb76e2b6c6895da4719ae0ee6cbf7db0b91eeeb0f80653f5d3a3e00663446479a07dde07cb4b49769dad39bf7faa56e8c10c743b1cf2cbad89806a834287952607ad825c54b0a43c464450cd9e6246e4d00874e0d2dc049a400a29e41c2bfe096988a4961e2dce6daffb60cb4d52b2cda54a7ca71ce0b702dc7d76420193b49f84ecbdf92c12865bb0391070886163a9b4fe1ce88357cabe7740bff398ca1c0ad56fdb18e57b823af7fda73e7a7113b4cd38ee7084b286429c95002084017160e3f9a8b277c5be684b55071ef659be9c48cdc10a6143f92242dfcc320312d62c802dd67a96f268c7999df151bdcdc98e3a0c99cf7ba74f61023c219beaff1008805b9a00c102ac4cd1b721b5f88653a38305596c13a60d47d6a8def76bf446e5adabc26fb854f4c69f39117ce213924c959cebb9efff37702309c646986b84a7557386f8244140310311f0cd11115954c37dea91ba77142b9a1f943695f035498f3ca612b5e8faddc6ecedf55cae5978fb4e1fb3ef092aa9f8b42d6d85ce1dd15eb8ae92cdbcfd33c78a2cd0bc608de4bdb886ce6be5d242f4596c8312c1ac2614f92295ec7dc9195b08392e4e68be1d0e878589f01a28a263fab4776f4a5fbc9e8b5883c1368e552af706e1f4397ab083666080c6165e3d2b0973041578a08f2c594fae159344d45955826dfd592595a71d35b537b7d569aaa2e0547fb1c52970c5cf5c587e69e64235d6384849c009e63022246cd1d5d3314aca0ec6a2b26a9fe42c1c0abb9516ad08dbf895f53bb77f178f5ac74e72e7ae7eaa569ae02c920089007ccfb44acd4134d3d8ae61fb3a794c4d10f6cbea80853f21896b20ab462aa6cf14f123d3ef115e2260ad9cf538956c68980492139bc45a308d31fe8ce015e381880c080c626d8ee9f36d8c71614ea76dd2c0011ff082e01e8a7d365b0ce185690eb85720e8de07a388697d0b7c7fc13c54d9fc147ac9a828df7d3fb41c85991cb0cdaf4db992f2e000a1d731ffc4c9b17d5164cb01c5ae81f03ea1aa59b9d3efe061231965968010ce07648936a128ae199900f9504a63ae760c795156d4de6c76b0d1ab03bb7c3eaee1cb21bbd74ad97813d3e2c8795b19a2f2ad0a24daaf6d22df5e463ce2cbc8306d5be096d2e67a1d61bdbc4ec2043adb7abbc96f05412c3e5612dcd8de7cdf780cce09f560b0b327f9b948fdd43bf30d9353a1efcb628e2f0592492f2d1ee0aea0f3061eac3d2b9db383f78ec300ea1a78f3de4c1539e3f0d3f92bc30d5f48a3be452f62addaf1d343705be41d751c9474bcfdce216b2d51c73c2356b7c20a9b8a23abca2590f2ea91a6f449d22ed631b4e2fa5ede3d7b93cff5bf42fa2160f1170e1f4cb722994e262dd038e715bf85fe2d392324fd4898a8f75cd732b07e904fd128db7c426f2ef9e1e362f72cd9d7e1e64cf16330e83f9231bf38f35bcf155bd359c91b06ed9e24ab30eda58842d484a8f3684bbec84460f5bc282c844f462bcc889a9695ebccca96945f6b474bf673e1e3932aeb68cfc2122a8bd6cc14a773aabb7e336e050f05b0c6ab141c659b3923e4b519639cf0d2efacbf5e46bcbc6daac20e22bae72f3dd311125646a93472e283b74954e7fed719b8cd8d3be470569cb9ddef41512800d31a95fa2d667055a4496faef9fc7ff13b16ee0a9a1167ae9ec37c9dc0ba525ada395a1d469961f79df9af6f4cf05abec4ce054bb40aeb6f02b09506cff66b11110dabdcdf5ba30374fdf15a07aefba5ac9592c7a1219db3f08b6b346dbc42372058fbc84e8bfceb6533783d34dc6910e070f7125f3182cebf190fbc5ffc5c938ef980c20f8fed24a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
