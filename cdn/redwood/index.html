<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b44dd92135cd1ef8452abc3f56e7cbf338ccfe80bff48e5eb91ac15adea9de4a7513a7be08847d02d60a0f39e13c6786c44c03066fd3af42f7dbda2e9326d4912a858cba369d38c18a70ed2bd68b22d9eac71af3d9eda204db7e273120ab66271df8473417784e19077fb9aa07bf27e556579c4fa5473c7324f96402e564991fd55f62af7cfd4b75486cc1777ab0d9e265c966e59a1f724ba905bec991a3720cda15dd42277282e322c3f655c5f67f50ff4925c1718dc5f21f621837e2e686d91d51fae9fb00596b21d4a7dd8d3f633826660008b561de1ecf868de8fc3679e64d98e88613281d06ea19c113193f04b6264783b3e8a4c5fc8330ed86a31a9ddb8f2e2a996631284e67fa11a56d4572401715372b0dea985741d8edc8743f19609bebec321c2851683f33675a028b83439b8f40b2f2687f38f6f95945b841492c1e538bf3c92f7a74b161c160e241bc9d9f5090790d6b701f725a6436545ebaf93abe0400e56366d1b7cb64888827e25208c0a2aedb1bb3086eb3cce15ffbe5c2ab0bba8eb98ed43887eac3eb626487b3db34d18e05ab3cbeda1a945ad46df159275da99409bdcb23f23cd85c2bf11ef84cd5028b4d242306a5dfcac7209d747a4983a5994d87dcf87f64eb07afe32eaebc9c8584a8be1f5d52416dabcd19124303350867057ea6fac1a73d2a8198984a8c5e9b3baae8938f4c483e30bcc15eb00d4487d9718809674365745a1f360ab001aeab40e8d690baf44b60f47f6508c621892f9f8475e90f1bc501608fb12dc89a9ed29939995f54dbd989241e1dcc844038599cf96f0f0b8f32e7774009ce5a49fae72f63b370c1bf5fba0cab5cd76a369cc2dc716080741a75168981e59baad6da45adeaa9f6d277894afc2dd137b573695da10a29a78d7085a8b6b346ed91317738d08df8c4af27d85c6d094d520b3905c84df8bd048213ba0b8eeb176a02db342d7c8fb1e8f580a3aae6d52413f7626a5549a6141107008d59ab9de7d795592e79da904c3efdba229d6bb158f20dcd642b40b40b9ae5162e073cbb2fe072464a91b6ae0b207c63342a49aba35b81bb3a3aab9d489da8d25564264ad97a4030fd08f8a6e35c43124c53259756e01207cdee34da8978950c43db9064f802263471ec52213625f455d82e84a749aa80a710fabc5368e7a9b9dc0e4c1134d715a71e1d697751b6360c4cb550313e72dfb076bf599f7007dc87759b0402b85fa5119deebf5cdce90d04519b0004d6cbf3b21b1c04c15ca08e83072bf40f48367d31d9e533f8f950581136ab358ac8c89b771469912dd6c74f6b6f60bd0db230847acefd8b5d87d94b453428fad554c4ad2158c2b1151316c1e1390c1b134304e4efd7575af6b8fda049f5fda80aec60ef8dc890970e9918a9f22009728c81e298b7be942fad05043ef6dcfd2c2233a481cba92703f6e597d9f0dd8d15808d392aee762018dbe8bdea10a0ecfe2452fdce54cc0f8b67088c70cd4156d522b30f948d72387e492740551383b9c407fb1aab33ef39c325bb1c7377fcd02631cf48c99e8223dfb94cc93bf8a8d5775c7008e96d231e5cfd29adb08707e241a4e6d005cab543abad8c6088c0c3fa51f9924e285eaee50102d440e8a3efe3e30949c20008ab0c3271a1dba6cd6ce4a9f27779ec4bb505ff5632bdd8183c70d0590055ff04c5b04e7fb1c3d0de77ee5d3a79eb066ae74cd0fb77ea36d8e4dfc4016ba7b031d085d195d246f3b00bbebaedad99143ebdeeb9417ed36294200313c51c659c4258138818584db78b5d4dea815d64f05019598c8132a696ac52d1629b98dffbcadc22c1fcf531112537c1894f68a80746a98eb517c41d9a1d5b5e32bd5b0d94e9718f85c64ebfe1c1aeea768ff2773ecb60f45a4f3f6caba8b72ff15cf6c4a566e927b3e8f09a58db53d956437ce571bcc1036825f895bbe0eb42fe8166489d22383ef5590870ece92fa9d265dcb16065abfdfc6b0d5963a1d2d35cdd247d41da6181e8f0b129bcdb218ad1e4dc9624814b617042d27c2e79e6a25b275c43a1d2774ce0ba5fe800b338553adf72c83e9a0c84aa5bc8024caddeabbc431ee8adfda75685301e981c3de89ef5cff9c9cea48050dff626d337d53147b5163ce3213513c40884918d0018e54a848b55c1cbf15686befa3673df7da5f2978302c6826e5e2c0d58574941fe200c6e8068df10cf7a8c6ba13b0abf9a1aefe0b20471cc2f5b5d5dc819d8f42072f3d9942009a9e810c9a81da42f97cff4b376c21f4553e2d970daafa9657cc06747c03cffbac677c0556019d31f7a3614e7eebf4b80a2f47f4af01946b33d418295c1a1388517253aac1f2d99daa8ee26d19dd0e7d9227adaf87a616f7c5a89f04ddeb89b1e8a214876dfdbbd21d7f7a07fda27b699e36d3fc9159e0aced02804db171707fd64c00279636dabf4b707223b7e6a63d51a50bc63d94c96702b4eb0d3602b4ad74765631a6e76f2f59a2bcf88a34209bf0fc4590947b786e1cdcf39c72261e35e29ea8d07920c2b6bc5dc51d6e5e5efcff3e66e2e8e33191f78040b8d941813ceb735b66e2b8f0a7054ee09f6b27cb795c680845cfc00264ddb1b74a04f25450d03305d4de03b3c7a4220ba039c7fbcd28f4fb6d980000882ef11319b9e5f028ade283097fba87db8bd6766ff52dca5fe3d7183afcf8b17007356f00d7d9a89cc209f0522d2110813702b97b30e6360df33c9819df51d3ccabd3ea5e82fbddfbcb1be042fccb1f20d6031a8b250d1f4c7f9d25e7cc0f4d7eae84d6577106a0dfc95b4b0af0b04841b32d55ec7fc3b27902805a4bf52fc8c34751d55881285272537ec059e6452755cda1825c57f952d9e07ea56dcb25bced61caae631962f10651aeafc887111457e86100ff372e08337e7f56b45032f7fecf0d6a971fa7fd2310ae2e68a4b4e92c681696b315ae49b3ae5348600f4ed74bcd694b7fd9d332023b832d494962b69ebdbc787032890d51017921865d0b374003ae4869b1035d2247dbe00ff52ac4d4d1a8391c027688aeac591642abe825be57244be19cc55bae894e9b55cac3e52e6cd819196079b4b8c0d907cde918ffee14258b74937682c804a2754fee62cd5aeba72c25d2851b4bf7b0c23e2926b45662732e123e543a0c993f0cb3cfd968c9449b7446a5cc3a1d93431c35370cbe636f44a641647c1378870524f42f5decd5e3416f241773136d21c0d3deae761d7d458580213c2c3a85b9a2f30a095b098aa3d5bb10c63e9a88e7bba783697dca733e60dab54dc395aa7d3bee1f2f1f1d9626aa7ba38c5143f8b7189384d954f11392c268843dbed6c4820b0955b2f297c04544b3b3a33bd976cf728c1ed0f090fe2e3512be33f217f32aca61c558fbb7e417fe861a8123d26fd6d92e221fde2b4a74eed2c325f68f21894ca8d9c985f7127cbbb30153ccc306f173338b7859c8256b46c1d1020e74048944159f6496d3eb034923fdfd8880342a2a9bbca3c24a3bbc7bc3272cd4eec2c777681b2fed4ec72c6d04c1d0d0b4071c91a2f9b6d0531af6820cc1d5a9a087e4fa5acc72aa62c6bb3fe3960467b5d476eff227cb0cb6ab8d51f15a05b1282cb4e9c6957fb8f9ce51bb59f9c88b80ef8ec4029a8c39771472f44827a8d9538854c266670f8ad09d7a75182949745f584f3cf4704a080f11b1b4411da09657a974ae1c42f85e7bcb0bcfd2ce073b4b31d5f8645aa268d3926848d990d71eae674f49e1deba27634ad79f4ef9dfcd4968657bfbcab30580009dc7d23b61ba1c924d6038349fc6acbc9f7721ffdff748f612d162da1fd2940e785348359d4c2a0fffa38844f10a60e0c6d79f370292bd2911a8f499c23ce2ab9dda7fd3054870c31f2fa3f5acab6251ef05e8a068c6694d7a62f5578668cc20b634ba32a97596ee6e437a5beb8dcf51b2c22764c95cb3fb8cc70f6325ac2a8ccff3028d3f50026cb3bcf17a2a7583f4abe8503e4d72b2b3e56a4b585ef1c65f1c3ab6c5065530c51db7668f55d767e0b0fb2b4abc354dec476191e33744601735f8a68803c857568fe935e861ee3032018b78f580ae8ee7a26dfe356dfb85dbd3a010b1d6a583aca09e42643b47fdba9e3264224a8a6676321a2a18e5cd46e3026e6d9546ca6dab211ca6adacd8ecb778646b05115065a68ca4ad2dbd637980fe4dc851b9c38107dccb52c35c7739e24bcf78892ae71daccac52fecfbda06908fb7c87b84deade982455667e312540a18dfc6bba54a453917ab1219279d3599df9f008b13f56ab2c02ec8789757063edc3c39cc35d3cdd8a64141722c4d1e87b902bef0dba7c4cc621f1e88e88b72b28b92765e5ac0ed5550580ab0919ef306b3ca9c5db32d512d6166d85c779fa955e54e65ddeb4baef6de8dd4f377d808fadb3546c5cefd5f87c84a9d2440bc9972dcdb29929728954b411b94eb3d3f2f91374da10bcf149fe994332625f78bc1179c39aa12f303540248ae58be96f5c1e7f3f57b5fb17f0cdca09ff35c54ff4aa522a98091cf84f6ac78921a3d0eda9c722e425c9cf2c631ea943cb8510ee3ac90e365a266c388c29f8112ce5aa0df1790b15b58cfa913addad8e420c5412cc424e0f32d08d69393bb2d50f71c883f5f6bdbcfae1ae990deaeb3152108400931b3c020b01734b8682f1aa3d68025f86289f3981755c7bebdf14895ca1d1c9482c06838669c3f180310aff63a509204e42baae8a4c8ac5b2ac33b65429e2198eb377f84270cac7b62171ebc2b5e6301a4a5d2b7dfcd6adb726f48d07c74ee99ce5f33d3313d2b7d28cf6134f8a91bcd50c651f9c1f38ecc21cbfe4a3aba4c79e880e52ffc2dd9c1192da2cfa023dfd4fcfb27b7c9b9918193388693bab0a4918e4cb82203e645a8e955a0c2ec061fbb107c1d6bedb1fed0e169e6045ae3ee84988904593228f560e564cea447f338153c3ffbdadce3d00759ba5c55d8df880807cb26c26d122f9aa0c166983363c6ad993cf1065edd9e47dfd8fecb5ba38f175148f5f6010daa0ff071ece699c0a91a771c7df34ba8782801c3f499997a53af4232fb9fc655219c579b41d784e30355c0b7f1ed26c13f55a7de2ce6e7ef6df6d568bd47c842decd24a75edf2b9ac5f4991a5bb534ba48ee4eb0938bb803dd9c61472a3a60d2c8d5893e9d60005f11d08bcc5dac503ffbac63663be6a48e080e7b2c501ebea634fb791eb0c3149e029f13722523f5053ba967862f6dd853269e8eb376187dc025f22323d38ba10a39fd0196729f6dc702203ed7e6b1a58c69285c2d901c0be63e5bd7ddddb88f694f140bfcf5f3e338980000cf38313d41b401cc68adf9e0e04b97ad28011b18b008cddba25411ddbed1bdc1c8ff56483bd5921cdd76b26e4640dd2db9a5b31175ff676407157b26569c1d3d748f9866d1dff317f8571a5d4b24afa1fc6ed657c7dc4b9c9bc128865781ee69432eaf33b93bb82152cc0c05604d5d1eff48f36935e2d94328f1a7b23bc55291a2a86f6bacfb10874fcaabbc6076d11d1c23a1764e04bdc43660e20fec2c7c42b029765c1fb553064776bc6729c127450d458e246762fb96798fa87cf3e07323c524ee45fd740789b22ab462a937ad991dc9c76ed49e755e56289dccb13b2dcf2975acbcec755cb198aabeaa4aeafb2da7d78729ed67fcbd553c621dccb30dbf87732c832f278a40c7f51a01da977cf835f679b5dfffcd8cc509fc9622b3ae74fcec8e384003c006c8ae8e6bacb48a2cc32b7627f048d50db706247487e54faa12daa716637ab0a2e8714141bc59449388cbf340fc1bf6c08f173d0e74b33f296b5d5dfaf058861530e9b9387b5b298d76be173205ebdd33ff28303c572c864d3e048d90c8f5844f9a8feaa13c1a709156859804bfe8c8fd6efb809fbf2a28133c6776fc89aa337fe9b020a442c2fb2dfba3e5d8f7017031577aa2a5755669c98f1e7d54c80f48fced236f10161314d6b5542b3469faf5d607f52db30005a7c463aeb20092fc3887cd9796f68d0fc123ba4d17dd47a549dce37f0cbd36b6f5f70f2f2533dbcbf5b941c7a22c8d745a78fb270581140e53ec2125136e4d3a1cdf5e865c9d7ba3d792bb94bfca61c02ce9927168a6910ffde55900e03ec00ba99e3a3efefe548791e9690bf593b59eafe14972f009a7a79dd9804ef92ee51fe71f7c1797975c98656456944236648d993a5dad7de10e5b42513c880cc40af4f53221384171eceeb945175894f23a3355378243f21bf500658d7e163206742dac99fb3f96932ba43447146bfe2c0b31dcc10cfd8e742312c790758d93449d4674eb8ae4bc94604ec2e62c16ac877946ad5dfa2f0fb8ebd4e3be4e1718e3f8f4b0f2e09f019f41c21a8c70a9737f52b58471093adb885a8703c1b2b153dc6ee7e72f9f998445c6654dd9f8c8b71bacaf01458341a1047684cad35eb86ac8581f012ae36a15f7efeaaf9324614f211867f2e6be6ccd6973fe21fca6b2d95d9f50629880386bed51c76dbdbef2428d1fa0a7aa2b4f889309f750314fb14388f0a422a5a56b24363d0ed942943943cbd239e5d3eba312e70954594f19c9f6f35898bb45075b0cb3381da931f1deacd72e57f268b91d13d3ca8612d88306f406e86bad497b821af7f922634000a283c3e08d62ee2029e9e3b9ec50f5e74afa2c77701f7c9ea897f2ca98d13dcff3d875e91776b3ecf0ebc4d9cce79ebb01d4310333a37467375385640140bfde8b4d1a94559f74bdc379b143550167e9e1693f557a2b9acc28f9c191424b1d9fd0800fe4ae9ad99813da7b677090f914f9093704b5981132ed89f46eb89102b0a0717cbccfb2a955050a239767d713e54ba8cacbac925ca9f20766245aa8469a404c31454053a05a44f8f585f79cd6857628f6d93f9e78ddb048908754d13fd539cfc5d77923943bc439ffa0432077855935a328355d65988e6ee9f433e902bd3e888a2d316e87880609e3e8502fc4ce3ee1b4d1d424183704e6bf091eb45dcefa75214406be78656f92959b145a880c6cc0c07013847586f363fab699752c2f029f74f41aaef2ff1ecdf0606b734850404367f031adbb6fee706e4b03b788267e99b3354ba458a931fe6f99a9da3800a08cd1dfa676f552f1c2c56e53bd38b4d0b860f7662c28e30a2a80eb3a396007d8bc27470588094f7cd7e5506057f58ac030fa3903439e2f610c2cf6edaf5b64e0d9e5d92d7b07c5f992c9270fc0d7437664900206f489446bb60013dd99424512b9d6b7a33108e54040f585af5e2a6fbad4f715db284de70dcc778d8b50f8884e918ae458136c7fc4d5d1747c78dd8e8753b78e459719bcc8436d3a96b0bd5e1032f64ba2906f52d1b3a9f8164cfbc8ce3a2a9373f57830388d6e727eef6d3b57c871a42fc7254f58c194d0b552f62a8ec641fd04b1be1013ae055c65782e0d478bceb6681c6f1af0ed748edcf4636df06adb92449a5a7e8936eac5f56e28c2e941c45d816ebe665caf36eb23f3759104576c3170e8f269d8a720bae5e2772e275cd1ee09bab55c51867a89bf73ecd2e05cff38981354991aa0215e102805880514b120d92a292d42f292c8c0b94b93423c8cde1500b04ca2bc6282ee38d89be390102d6f38623e09e89a0e756d14cd645ae26b1ccb83e679252b20149f380b6b75d12d312d4cde5335f26ef13cd1abff992c1b2c1a00f45c27ffba4ef279239efd2a27bddd7ac4a9267bc6612649717b3bbbba946f19f6b28c401190f12c555bd7709a99a169866ca7fa8fa71a248cbfcfa5a35e6ab051b9a71256ef5ae2fa863a49c1ec6db1d25100a2c05960d4deab6c4ef292ac1f544279d4f90d3803c10200861007c57c58a421824d90b0031b485ca110beb067181bc7d61736a60b9fac20cf903ef2137b66a537095cba445d3914a0fcec4ed597ada918bf0e80ad25ec924db8cd4c3b9f97222440bc81dcda1ffc1c9b7cc4fdf6be6a31d3ceee66507ae002f9faeb959926f68f4892f27d6baa5987b5a66688a8875c8e5edcde637a30736262ddfcdfbe1633c5eb0dd8eb07ef700e83daebb00f997506e23a9439051d3ece30f1366ad783c2ad86534ceb512d7059b6d29bfd32b5c24842a45462ec9e344f9f16d01de9a56d39d63c79379ba5d4d4d8f61350ce65ae49597fe3d23f4636f64c066aef940b6c6a5c76a05f8e6f9ca8aead54e15d17fac4acba56045656e91002a76b122be07cee29ca10fd257b582afb7bd76d216afb5d7fd856b14b0b9ef0c60ed59e94e7779d52062afe0d43b8840d596dca9744faae4eac62d83fe1c61e8fb5ae98a2a4359251963e5e915199e8ee9ae29b4ef528157678b3125f947b6268a6f4322ed50be9ad71425637cb4e06721e67b57f73b271c48c70c86b8d101f8b4a852eb94f82a8b2a8484c76a3c2af5ac66e3a1546f0684d8b0a01f5217483e6f0435965e7cc900d7babd03076c48c5adf939d97d678c66f8e1ef6996d574e463b523375490ff3bcef1929ab29e4a6b25e37fd510b6c35416972ac1177459e9522c1289ca98d05c96b45f88e8695393cba37bc91feefbab7169b6ed446539300ae4cb4f906905c05b166556c857a9bafdfb732117a18546c2ee4042efa3ba05eb69bf9041aee8d411abc63247d8647a46bbaa10376b9332a7b6a1841b64706727f94bb1eba6d8de4c8f1497e556bf00d5878fe1612cb7d5b3e6d5c18d23bca2851b49ff3e85b41659afe64df9b38433b46d8096bef72906c23bccc875f3ef32348f3799a9a8923a35766ce8d27b73a8f4b68136083d8ec1293257f475911b41d90f7a799d2c2c4f5cfe3a0e9451aca4ef059f29236fdc0da77d9503d183f640d1571d7724addbf337dfd7cc79c86a8242dd7be952d3deeff6a8d63960c4b2d314fc821fef5938159e9d83bebe80e703a03b3924e28343cdec8613646d67abd13e0a32211d0179820a952fcd0a3454c2e6b6633d9ca2f759a43edea6cd918859dbd85f355eb51b1d56dceb904c81156acce95aff48c01475bc3984e331a9bcfb7c08aa84780b44f59e20994d47abb7b2dd0bb3dd640860eea336ca94bda5ff4f4c3a2e1ae329a7131fb600d5a90fb54aeeb6dda90eefa9e8ebaa6e1c966f3984982bd8e21b68f0ad4ae85f2561ae538e74e2fa8b62cde8ed7c312121a01fea21eee5aa93ac6d8ed5a4f4f677787e999e9d85e12cd8b9e2fb9803dbea67afe56a36eaad13b6efc35643d6598992fd9d5cea1da6d2f7e676cdde8e0fbe90fea6a4a6b0352c9823f93963ca11281870375680e065706c3bbbad0924c775dd0e61a4d85b109633910f4e7ad2f5b92e9d822f6b9f288810fd427d0035d858329c22507a82c627737cc81bb28009e55b5db25ccf8a847c9c14506c78b0f521d4d05a48a51bdff26cba9b5fb565d39fb41ebb5b3d514e25f50651cfbf8b0a239edda7143e4411055c3cfc16728db85602b6a7dbfc2a3a5f072713b5783a89acf88ca5d2646683537e34f4be214c7ecdea9a73d120587354541c645c298e229b87cc79283f6fb7bd25996092b1b7bb1b30f24de643e370d39f7b7b934b50961714673bf3a2ba3feedb2bdfc28a765cd8b7459064e6ba254d2c4f347b0c529ad392e78d0e46a5030ac35e942ac48e0fe714158578ddadd997d99ee1780f1d75557a19ff5c37c641075217564f423648517ae8dd5f1f7236723001399a7597441a60364bad23ad56b5237da56aaf597d248376f3860d75b47cf73e333118177f528f7353e0be7f034b399d4caa0143465a7944796542434c2e95e1057dd5e52071858063296bf16af88749b503063eb23d52d97e18baf8b83104665cc8f87a5672d163c6621410511529692e0bd26ad4131bf8e20013bc5bdd46ec4c7a9f9c93a285fd672c34290ba7c7c44fe748d34f80f5be60d818b676fe848c2d698174ad5f751edb20ce6eef8daeabad746ad14f61d01a99defc8571e867966f918f20ab5a9eb0876952e8399436a60b9c782a9bed51cce75643154c1cfbe8d1d49e108e07f5fb82728e31490ac7150068907a3715596312ddc9bb0874dd50e490bf798e13177fb35309a55991084804cf3adabfabd32888d530248fb3da3e8f0aac794885328460c788b61d17c646af487365c5dad1b9e1835624841e4dc71ce0e6715df33ceed89fa44112e4045fd1e21cfb271cc2bff182d200c01de504d7bfb4557fc0e3a955e73d46f95e25c2c4ce9f07f04e3cb562b954113781daedeb3b71736924929a6c77c25f6ec94c40389a32870c49262b3332cddec48c98446762e583789bd87ab35860aa4ee7c038a483460062d134d40f2d4b67cac22e20f86b5c2f632bd3b4ac31de562f200211dfaf78a40d0bf51711bea8b1e31f7e367a7784ddda969c756249904c23f539c7c66fa54f5f49554e6d25849610de79e97c60692c7e05fea74c2c40863885f8c96556fd5c9ea6f946b246f27ac1fd2a5f0efc2265706171352942bb4d2454547157aa852cdff24e5efc986e33a9c70726c2fb6bfb65750fe58bd26ae67ff5f7faa3e8e4b6b7c6771156a89fde5750bc058413ae01908b6e44cdcfca1b2930295f9d2554590cfa01e11388c499b8864dcbdb23259c4df91ecd98165456bfa7200e1bd92a7d7eb788e7d49d93ee0752ce9cb22aaafb6bddeda56578d9091bbe87e561af4e73eedd91a4f0cac9801f9d9d2748de6139df05554693e01624a44f889d24033901afc51a53bcb70126c742a4571707d9a588022fab44bd9a95f9e49a7158a6a22b372ae650ad72623589fb289b5a02edae8ffb56232aad439432fa4e8339f449ce6bf114b682996538110e33f24e3669b35e0cdd26b50131731ef5feafb9af80bbfcc0f31e7289f0e9ab9415442dc2c38670e2b6e758a7aa03a7e6754c00ab739f7c7d8e94f8514f6ceee287558f8c7dc0efa3dab4a2713e773bf7e355e63c0c8d5d16768a11791492edd793ebae9b198fe50d4d613902b64c3d0c08231db6f1f82f946ff8fec820f36d9435a8559fc66fb918d6aa00522a4b7148d4a2df8ae06f62fa88a483ce174917f6eaa05fa626bc1265ff9a2a348a7711cb6596e493b5ee7fa6c2eb250568e4016a5ed809ed2769d4dfe186c53f5a2041cf336b0dd9c8aed3b7f8b60b33fa8ba43c457371c1f458740822e8fa7c9cdf8c4b05e7f45d9aeefc5edd51e0720f6097f8c04defabb2cc8064b63406481c42d22a2a103c7791c73f962b21f17f9ba3bd4ddc00f76389eed10d9d0ba4204c012282b5aae73aa1f6289f978b2db464b7e2bf15846e663dd72d58e192af32983fb4cea2a608af7f8045da642e66df30cd51368c2bb4d1d42554cb5a28a2f800c4046e8f81bcb0ad64b4b7a4c56ed04efe622c400d325927e96f31bdcd6fd9ba0de46184e9fdac77fdc3dc8dec3fe60c22d4e18e6b87ed9b46e2fa2a22fa5f7054f033afbb4e0d5cef3976b1d060fb74143fc1d3e875e381bdbe111636a328f5ae4b1d0e61e345f4ba5fc129ea8eaafc14e317ae0e9ae3c3ce0cefa04cdde2b82e6ce6f347209079b884b1f7a731204b0c9461b8d0b44aeb841e70137308df74fa57195b766ead292f7c34d908fdb149c520f090ca889bcd60c5eed4259e834e309159216e42bd5868749e22d972e09a513cbc7cacabe3d92c2f8232f4c33ac9c3a4fc723ba79ccc7c0a6f10e31cc415f53fc73ac53d3c0c462d7d104e906d266a5582dbcd8d92d636884a8df493b5f697ff427d1ec5aa6c6153ed78f48a2d2514087d2f496778bea0247944ab36c7a4effdc1245583747e730e51a50a7967a71584fce13a47d186c3d0983d6e73743cfabaf1a48b4445cd358e20b73654b5de72c8adbc11746fb82f850b46ca0e77dcd5cfc6eb720c6c70a95803e259a04ddc8293325d393083c546664e64583bba522ab2cc4151dae4c24159cc627a48d884679ce47ea4e0944de6ab8129afd451febf381918d7f2bc2c2cff3ed61109b5e7eec6e4512c878166e902ebca0064bcf40bfbaaf9885263174ab9d374b6e7258ba3c69d7db470ece9ac0180120a8619ba21a79a26520f0fc2b12f1f43f7ca70d6a8a852a1c9311bcf5fa8de4d9e0f90f15ca706a350ddf41410cb829ac480d3311caee82fd84492a3dbd8cf32e9b6957b3e890e48e9fd4a78604a00d0b37b1871e7d44b1a0cf5b074f9aee4c0d3371e26f1b885bae482dc82ebbc4d86a52d5cee7bac215346a3889a985772b37052e380d1322d0950cc81d484c1940aa17663fe66203a2da67f460e4d78f381849d42e80d97224eb8a38a7caa004701925b58ce230459378028df7b6b585c38734987354e39f4699825ea36e363f88752f2d850f228f20c127993bc0e76d8b105c673498b1bd584506cae56cbe4359efd4d646faad1340498d95089dfd2d883c785a0ee254c9ff6d0acafa82f42e709ad4e90a7fedfdc5e044928add3cb913724ae314c35b1b86f190dc9b7e635e6d2b8b7c685693552e88d4bf6ef877af42ee748ee34582473dc2128d32afe0a591f2bf3a2096b4b6a0fca57a63c1e96a7da47204c60fa9469e41d351feaa2fce488e2defe7b80d28d323f74c18fcb4213d4db0d3d2342fc6e2bc3d742c5cb8c1de46f41355ec5d3b2482dba4b5cedb3746a75c26a4ee25108236b5aceb3e50d6566b930bdd9b6fa94a89d51d7bdf7018ba78fc3dbd1b277ae2631d6506fbffb4de0337ba35257554e4988152cc2a3fd2b3be49df96093e376d0b024ae61a346c744123da7479b3d5faf4c141652eb93d91c36962ed36e0bcabd4b5cc99a00cedef623ef9cdfb6e69bbaae897b8cf2fc2aa16350ddc0a07ff3d4f1085d495d84dd5bd69b7e4952110251a85d7369ce693bf22db18651c7eca41c3a55dc392b13bcdc32776fbfbf43bb8954d68ba9abe91b9f87dbe88cbedb3411f43a9461dc53bb8cd466b86a87689cc6c243758a963abc7b9a3749cc4178c62abe9b02c8a90a860195df74412bcf2ff4783baa71e8a5faa3d1dfc536007e44dc42417f152c3cee771cfe42fea75bf42c764507a52ef4cd2c8ab9eacd385d98320ad1237389ac3be45b63c16fd274d9a42e238f917fc7e40932ef02626a6810f49d888ea0ca0eb95dbd4f3dd22c164dc37e28608b1ca2b05973a69181d78ef83ecedba79dff9c9edf4b57cc26983fadb91f84183ef051e83873d3b3b6d172e6dc8723148c94ac0d332e554cbe44eab1e20b4fcdca10ea016605d83903b7dc37ed6fdf737e734b77a7351a0ee6f60f40c1580aa3a626f35e827c11e9c634779e22c501fb26417c674d515930b65f869af78ab72ec65fba0b4959538b154c3d6505ae6a4466071bba21e43000d91ce035c3aaf8f7a004117c15eae9ee097c78385f80bc5110de4f2355f79c5ae6d3e00c932c6cee328274ec6dd412c372ff795bf043681829258468a3089000dbbcaa543be8dad5e76649e86dc12b1bdb83934ff7216cda940aa96abd27a2fb8790f0e8577ac16f76a7ad9bb06ccd9dcb187b1b84e944b668d513b992473a00e80c4bc01e03b443afed314bb4a416c511fdaaa42300406449ae7210239baa28399b6e39ca395b7780d46c4ab30cc0db36998d803979615c8aec1b140f0e26776b5f495d4dc9cffb6ffe3b38eb157cdf675190021158edf0a4b72ee7f3a3fa8ebc8e4c6a068a3ab0bf3ce972c98bb2bb92729b2d14a788bbc362fd334a35993e656822db8ab68429849e1b4f141d2a92f875c6c38f415a085fe8321878deaadb23798a3e174a70e499099b25ecbab553b9655fb2d237de12def299ffd4b7df0235f6e9fd7c02ac483b4b80322e61b6cbdbe370d7853e8bfc1f734ad138735db0498852b94278762b3efbe735b645a6d69b3522c27d3462669749db92133ab264c02cd95c8b5cad4d86fc88ddd41637fc740691e7421d8010ceb05a3d1afe15d936743aacf137a2bd44a1bcd3ece81d657d94af24e38f0ba964ad7c0e479b9b10e110ca29a2212caad3023b3b95ffefa290eeed64c4be7759462f947e4bdf2672b3afe942fc5013a2c3599a1a81f64136e48172d6a820f640f3bf1448ebe31c8526af9608a9355c193050b47202fd3239664df82e23dd48d4d9cdbd1945fdb9b9ecae7319418c374dc025f4c11ef77a000d392561e00ebbab2efad87b1f4e7788c2284e6737b953cd608e2f649860892a458a73a0cda51a048fcec807aa861bc346aed398c342e0c2c666ececfa57156d951d37cb3b0076869ebb1cdc920c52552deae2f1ccea7899def3cc523325bfbb2d60fba7f5d830a1be7a2ca74e24989dc6246959a769b966a3184f2274f3a39ce2152cac11a86a6a37bfcba4bb085bc90cd76fe04f25eace97f515e41464f9f8a19bae277999dddb03b57f1f99a944bc7b04704e5cd5ce032a16de1a456518f52f7654316911a7fa5ab42b711af58cfa05853fa927c1d128261054703eaa816ddc6fdef54bde582cc433106a950b800b24bec1ff3ae4abc22a3ab952f95e9bc98e535d9ede3a0d73d7e85357f5df41230394feb822a6c4fb8c0be788d68f812a1dff5fd13254b007064162f01b493e02910157f6da76ce6940836dfa9dc2252092dcee907d6c9dc335f6cb22fb2f0ad908893a97a3039f644ba3f3c6500e890c63737c90c813105a6df41808bb4ef7f6981c01f761322280e6683d3b1570a6115f90df60f23759918d7d4f6e556acc27c1f03ce51c444e34203b85ae25e1648593d61268d2ae79a38fdb5b07d91d0a8d74df015c758b8c9d091a68bd09924d587705b9f4de5722e7a3420aa65c930fd970f170c5e1c013182e6cbdd5bfd671c4962f887262816ff3564df1c16b5f2bec3c694a18945637bbe16f6ac36bc45d7e3016410e97e02ac7065f20053934dd325ce3f809b2cf3064013c8d961a93602cb6584a056881531abd3a5f337cdb023ced2d6bd7907af0fe4610b1e8872db29220bf24523b170b1bb88835d053147b481667629abcbbaf7c2fa0a82afa28277e42062269226fc1584132202141baf6c57a4d7d0f1f10f0e42a3390833222bf47890c5f5bbfe6da203290d5cc95b9c6dc855ea2e2f10cea345d42a5832c29e62727d69b9f227c641ef9fa166136cf8b53e067a13133ff0ea9720626fb85db67d8614196a329099e8e3c7d7d72bd460991d60af53f4ca356df3beac5d3ac9c3736f810945db47eb8e2eeaa157ab1abe3d957c8f49ee844ce674824d94ad791c775a6a1777e819d31be88d224db3c4a2dc71cdb5c09173d4f45b6a5b671b531e81ddf9fd3734fbd7f6a8a520a3e904cabd536c4737ae61fc81836a0b7d6164b4b3885340cef60011b582756d3feb530ef33d1f5f1f3656513fddc0321c0187b5227998d9d9688192569ba8bea90f98ee8865af09c834fd21a9b05e3f665778e5c2f8f2cc5b3cba62f73f5cac1f88abbe712611e9158d5748e87137a67f0f02da2b359017091c066fa3b33a1855c517c6f59d166736e9cfecb2c4c1aa6c9b2ee27a3a27d8491c126124da5f76cb22fc94c5d1f40f843004e617b355154cf2095bfebf7072529f752ef823455c2bcef3595386d65c93c404a8b5f5c435a74fbafb666515b833c891636663ff27d8900fec2ff9a529e1b1fc1f8bc12d628c1fdff1ef189427ac1dd61bed2d9b0b2bfd10549d2b583c6091e5a48ecb1ade5a0102805dd8041cbcde671726d954411fa41d702f3082e225b5ae13b687d506c7ff959712bb15c24151cdf57052dd412b236200fcec8617cd2db4c9d16d80923d32e2504d03b52c7a725ac1923272a39f9d5309fc5693cbb1796dd3c4dbe9a34701a49ad54253b128205d621dcfe2b7766615b9a583e0e0b7732f8c91469803d71b92964bc3a0738fff5003c75535f555cb5c363f058a3b623e58ff58b8b31937ae0f359ad406bbb119cde8c7f3df6561234d1823eca0cd83e7fe0ac1b87dfe6e32c825eda8175b0e0a75c6a569d06f767ca21cf05eb1bda6c923a2829ff85529289e17a120b837400c5478082537b8b42bdebc0b15bdee33fc147c2fa065788b369b2c18613d1fc617a7b719a06383833b3cab196d1ae45c49f5295327b7d93960cb40c56fe82d25b9b02e90df68fcc601c2229fb49bef8be64c34cd8a6dc7baf5904ba77bda3bc401acd62a2edee9889832eda21685e08bfecf6fc5025ae03e15e3b895b497a8ebdaa4954a6c34d3b030deef2f231ad63a83ff03d0cb9842f12291c5001eba8adc8c8983576a614db20e436e2e0c101234b34cd448dffccb1f3bc6256ab13da8ca1d11abc5f3065e84e5fc9123bfecd6e07ab5baa3c87506008ce98239e2cad24557bb1c774b8ee3ade777cafcad023be71c1f22ad79ac019a30c6f6d558b4fa916473371c15a0f72e9c37d4570801656a8748a21cf842f46c1c8a6f905cf6288f600fbebffbf90e099864b5b9da8d485088bfb91173e6b6a0579bd8d76cc105580a55fc699cf4d234b79f03e67778da8f4a71e036e55fee6bfa3d65d963d021ddfecbf13c6d71f5376bc61cbbeeaa3ac27edd845c8153fc2805dba86d220c7517edab7999f034a2f711827825df4c80c02b83ce6fc7bd1f17997b98bb7693379accc65621518cea70c2c72df76128a6bbeb545abe1db3da5b15172806d770077ee63e6a33eecd38a1f3cb5364a43e0031457406a020316e8c9c5b014f676be6f9c2269aa632b481d82e93f1e65aa95e451a2baebf1b974febc89dfb7f5097d9692483abbb568297611b357fe5c02dccb6a4234b4e3e40042f146c7d6d4e5ed22696b58efd4404ac91b90fbe594a8e92ba59e5e9f728fe1fa567b20d15856b7fffce37400b0f289bd0383fab2628b627282270bc9d0cf0f56260bbf589076f23470bbcf4bd416c7dbbb858de9af23a00568d6ed975fab4f048a795bf61e68b31541bc768887be047255a92d2da33639c1bba7413d44c64d5e6d2461d176928947596f3401256c3d734e75398e1febfd50b2edd4d78bffb32802a825ce498c8ea5002f72862bb2cbf6ef60371b9b7ac61d5ff7c407f95fd9c69345393e1af54f0d8bfbb7026c2535adc686e92614f07268c53a04441cf1537033889876c1bceca193e2025e7daf916309a306e6e4ed13c1031d8184ce4f8a0f78d4f634c0f33c8eff00e9c3ba572e726af166b0bbb41b6672c51b50e45efc936a3d96279a24f3f203dbfdee95f10eb548075e5d760efee3ff33e9673b3bb628e2216aa348f9a7aec23a2f3a5242ea5381509ea3e5467f49ea12c28666fdbcb8cbcda2be86d32f0f686d50502a35515f181159de76731b55a35886f3544ba9fb12be5a4a00dbe2a31fafc5a0136f9ae259a4bbc70a9fce0d15ad457478c82f15491bf14f4293ff493885f20adad9e8ba34ae99a5cbc03493874c6eb8e8489a95cd83e673c68a4b86ff8bc759d8125f4176c735d90a7c009a5675e95ef82b6a2d4bda249326cdbee7fa56102af50a52554573d25bad2bc5a0d4d19c3b6f8656304f456c60d17c9046cbaae840f31e92fdd36840fd496ae8471d35f8716e4b313ff25719a0ed744e4a3c5302507911679f5711d705bc653cd858149b60c5e46837b0abc72466fcd3788e6643f0775eb6e76f72a34f7d19133976eb9aa9ef98c2864ab1cf97c8789522b0b3d9a1d3ed14bb949568db5547ab8e50b9c4b139140ce1353eaef9736ea0a283d0b517027c5b2c1c5b36bfd4c53fcaa9c728484b5afa5e9c0dac221ec9c22c2f000838388b611a528d12d78b701062b1096ef8faaf0905cb590f730ad1ba94f143f321295041740ef46c9869b2a05f1e9f86e1759198f61b757fdcb1041f118386793cfba1719aac290a1d7b7973558681d0e83efaca82b63513f7b3fc9c1bef304e8d13509261f2c2d59a861b2603350cb51e0e57c91726909697bda4f3d5dc32b478cf97830f4a8d666bc62ebf65efaada1cca3162e5f5157ab220ef33a772be918fccd9b9c0dc0f8a048eb788c924c145342bc3ce2079a41fbe9ff513d7e796811341a13703248a8d62413a5b74ba67e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
