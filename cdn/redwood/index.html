<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de38c5ff2fccb3278adceecb2b5bf80dd2d53cb5d00294e62b0102a5491618c06567217641c9223aab382b678fa8c37a98dd26083418fbbe9df491959217f3031fd842c273a57881e7018a708bb693f7ea32dc9139b1f0a97ff8b33016002d0e431745df502eeefae8a9a6bc6c53cdf5c6775559cf8ba202a2d64e636a7b8d3c88fafeaa12348eb9c20f66499388fdab14450ff9343b343df5071e143cd40394ab5ac7d371565fc15b1356d089ebd5f915365c49d944f5ba73d6ba1c192a1f0be8ed8d47f9b51418925c673efd16afe4bfd96f3d95c9c60b93107dec397043ddc2bbc6b7e0e4a8cee05f1653c93bf20e4b0ba0c476127f9e0cf016c44d3e557d858de93f1f3e301eb07d30771a50470baffb4c644de617f21733fbd654aaee2b56e0df1738e085737ebba9c669b659e56a6dff106872cff38cb8370209ff1ba55f65ab834e96b4838bb6b565b26178f76a9ca964067f2808500e161bbe30fba57bc91fd49a30e7ffa7da029ff7257f8aa48b3140ad5dae7b7a963550f6913aecba09bf3e87657f19921ae22b9e2d44175ea1dc7c001986d538b18cb261fb382da3e5226ec6ecfb40c8ec4a680ebdf640a00c9df1505b451944044884430c55f711f09284facb4fc248dde9f8048d70a9487bc4113543f3c47bb6d43d9c83ba29ea90367f54502b86c9ffd39ae9bb880a4a44603522b1f193a5b918fa8a9e4218abefc74585b207e974bca4cf4c24a58fa7b0683764bad8e86df7f289fd778ff5316dd82402568903c3d4d9716aec33b8da4d9ac14a9b19bd9795d36c33156d5fa6dc841f78f79b4c0c20457fd24bf74174d70281c316abe8d5e1c31cac9570ad30cd53096a0b7b2a911851b20994fd5b0d2cc67b3b0dd778cee4ad1b252b144048fd4afa04da9a76dab0857a426955dc6071abff23606704fda5e1d6b997dd1fb4c5be8e2e8fe089bc4a59da0273e82530b5ce4b0cebb3ff14616f1bdea3a0df4990716a180abda9051e4c2a9a804972f81cb6e53b09bd6df6ea502de005ec3cf829344e856cbc62905bec50a832141fb53ee0630afd740c7e1fe7bf9c7e9eb18d10e5d7a6eab00f66fb5f69ce738c98ad3bd307f3abbbb192769ce8eef39c027cbaddc0d1cc76dc06a96d73492bb0239cef54493c3d3b67bc55a02d705012851c9b9f0bfa75b20fce6627b627373ed5577e862aad6633e7dfc564ed42103dfea38a4b218db59980f77cf91598b851f276730fc70eb9a29f7aadcfb17cf8d980d72e0ece55702b4f132157171b8a22dbed1e0777ea2216389abe91c3721507983927d3d0d82a5870a7f33e18334ed5a3e79c7fbb159fd30d056bce6b1329b3fb05173528ab414b23a89147ab243a65d285c023d9f458a2a756084418f8034dc630183c65617bf7953fbe8a71c38525a2e1a5ac1ad3c32ffb93cec158ceeea21a8b1107e4a48f50e9381ce521a38ba47ff2468fc7efd9972758c8d29c8fff8a794c02743ee86f32773220171abfb2397fd1824f47dd13a30d669d984d196c5aba9842bdde5d06b6731661111f83252eab6140a0a8f7127a64fe9d71b49e3ab444f706b32710d5d46b5eb22d3d62801be1525b56a0acfed63425aab0d80bb46a74a63161ac019b05db5cc4e8497efbaef546eaede680356ac83217fc5e15be5c433f0a93c464a3968f6bc623a47dacc7bb495a22057608954348e02de8f6cb245c74d7b12861d76d24ef8c2d1644191919790370115a0cb6f39cef39561c726b8c2ff5ae42d919aa78282dec6dd01c3d0223fd46a9ad5604bc9c5596fd1ba41eec35acaa881f43e8fe0c0e01308e34951708e3024c24113e0e51219b6ec343ea066efc6addf1f81d815c3cd682484f86d6d943cea5b434e064558ad273a141fa736bee8da6fdcbe2580f2cac7c73993ac6671f9083f1612ed8adcaa71339541c6c183f74d9f7239e6444f9703e0ee4f487abc8b856e21e1d52915642806022ff35e73b71b178de78f0ec4be21e50e1914209d415c7b6d53929bb3a220be86fad790e8f1f76aa43f0606e622acb0a878acfab990b5eb177753a2f117da5fcf0e4b908c54b24d48c4f5a0b298a728fc65185bfbbb9f1261955ba73cc1d90908f36c5023032d0dad36c5f4b665faa143d7d7e4cf55f91380f79e0ecaa6e86abb6cf6bacaa6bfe37c32a7428cfd9789085211262cccc6abec4f5c724616d55cfaf7de3da8ee3ff3f14667e75a4ecb2698beef218520d0ed308235ce0ebc42f86aa4b4eefbf2a599579a92f03d3045ce58a0a92f1abedc9be0ee2ae544c802aeec1a86ef1ec53478454b5b82c898c51e2832232ee9b741a4c08a92c62a0def9ec94353028580dbc4edb36c728551a4e910e628f49348f33028a91c186840e0ecc2f683f0c7c86a4be209b8b5808f5cb4f78b3f105a9f01429d582184f1d64e451506f38af83009cb94e238e25a1cb93002f73b52a783c4ade38469c88c416a768527f8e5a5810b63b6ea97d9ded4e215f382588e25078f26454cac5e609924290258931ae893ed9cbe9fb7945b9711c00ff69503ce5ca68351eed00147ea291aae2bc85778b4fb927ca5dfb3db1a23fa2b274c495a8c846c6496bf094dc082cb17c6b1df6c5fbc91cca224596deddfee8da105c0a618ff4923d3a190ff831691397d15a8f3bc1b5d355abed638598d01c24f7cab1ef1f06c6b6b08f905845359d4219717f8116029619ee705aadb5f8e4501bbc35084dc1e10e825ae0e072fc8baba1e07a958f5e82f102752017f4891ad58fa17f9992016984d93ec812b42aedb7021a9916ddc87283dadc28d794844e66266265dd94da7c8f2c7be2f7f2efff903ae13731bec0f95d40c6739c11bddf58dd3580700eaea7426a658453afc42c34d98a658652892b017594f02c45aa986898b13bee66036e2c6e990facc627f3a58bff57ea17a1dbfd953fbf451c19074d0acaf0b92d0adddb7246a0ae1dd707dc410ec413cc29d70a386e512a0247be8227f92450b089a4dab23af57cc8091c0d591ba84db69c89079df12833f95d4b0b092b6d591b5ac21e54dfd768c7ad7561af35b8a75449a07eb46a9e87b3b5277eb1e44179e9d1a03ebf6bc923028e7f410030e951d81e62e02445f2436a3656aa4cba7bc6e99a75508918709ee72178273ef689a1d7632df5aefbd34984181bd85bee2431712b9accd84435e7a9f1ab557910aaf1b7f061bfe433970b6bc92cd93645b62aa0fb3769de8336f2b35286c98f16b3c8c4c3778f7fa79e0086c365814b8a8f072fd8cb94451c05f2e8d66a9333834339918a4f1f5ad6b13894c61e0e4aaecc864511306e0a2f5380951f365d7833e695615da94bdb8df6016075b2253cfe16a71271b21903bbd45a662d615c2cbfecb52ecdd93ae42a32d892bdbec82f202af3a13fe7a012b8164df7f97fcec876f36be4c8edf9df099bd80000bcb899220cc1cee82f2e450ce900451d7085468581c1a0f01edf478686f85d1ca7015fcdb4e9796e07aa6baeaf2764b2411d03439f985da7269606082c7c13fb07b6b95cc69eb6287a29b23e8e79ea00a5557771c9e5dee943f5ec8dbd10bfc4ea6991beedda086133b989c21eefff30e28455a64ff9796588f0a6f9c4f3b290e84d656af7250399e69dda520d50bc7175e64c8c853b4b5510aafd7a4d20ff664b4344202ee5eff725a52d49e35ecef6e462c928169530c0e4074196bf3176748f3230faeeea0730158b5affdfbc19579dc36f8d6e6f9ccb12483aa986decca0c663858c40c6e70a476b39104cb4d1dcef556bde77a370fbc6a8455a6593dd9a8e125ea7044988a783f5c01da6517650eb5473949ead25504df5099d32e96702fa81094cb8ab3ca1c8db73f10bdfd6958eee0b8767aff5bb142c7070e9a5af7e6f13646fffb1913aa0c96958fba73e31365e96049f3189a3712428c51383251cc857819b0c8768acb2f9badf8c579bffa4aff0e996963b1d158931032f75415a541c584889bd1a192faa5a3fa12428b911b02b3b026607fcaf039255563927462a6c093907d30a40885a72520702119e98b43f6de09dcbef1887ac826e759e6b70f8a290a0fe2d998b2cb4629f56b72ef9e2b20c19397b733cd87402591b9e1643c99081919bd69e72c867a775f1153f351231fab8bcbd87560a575d3dd68293d53a71491bc56985ac64344182661703c3d561c918fa7776c7f63c266c4f9f4dfdfdb7144e9be1f85d4de7e3222984b2f404daa8b18656e12fcc2f91d4150822a63963a0562a2a707d6a2e6982db2ba898298db9aab52161e8d33e5bd47b31f861d1c658a5495e211c11525eb5a3216b830d4f8a1d1c918848cc166bd6575d3bf8fafc322c0062919dbc8a260425b6f51fa479773e38e7a7d7446301c5fd85a3468bfd250f80baf7bd48885933098e9c5539e4783a6d35f7b72553bd34c30d42ac4d1c1abf74e1df4423af27be8407e832cd4d6eab9e687887c3ba9d3e35d2f014d3483039077d10678270e0b2783fc76cc81f4b296dc460cfd538aa6c0b2202ee37a008a1a5318be0f5d656c0e751d5fb88214794c818327097a830c7ee14db5d0bc131567b94e61b6949b7363d29aab7921044cbbf7e417180cb24dd808e6214263325c1a9360bdba5e035678b30c72ba8e640fec21c9e57ea97edd5d0af4444b4fb8264167c8a2e82874dc3a08951d43032ac8bb6bff56fd978a165babfa9241150a610de5a705835ba41ec96bce1ab4f84033c7f31347c89b132bfa9ed2f8e6e99bdbedc735430d2f51b140982da66275f9a1f409574db1bec82f5a5605b9b68d3ffdd6f6836ed1ab7720b17f40f6aeb21f10bef284a2053dac3f5963365fdddc8a2fab267ae63d3e680da2749001ea5bf226a2b3111bbeda63483d7ff5624e6f84dba75d625b86ce428d3eb7875d8251fb17291298c44ad92beab92a22d2af1006e43303f27a8979b3c7c2042ac4c3f60693963c4801d6d90fecaa61da947841d88e89b63e8f306dcdccffc69a2fdb681a81013ec4c57182299f2ee152abacd91e723e460121337e7a7d6a086a6cbcaf08194ab933989dc01c9a90e69eb1a5e7d3f4f6075ae1b18d9f8f11d3905b8454d763916b6aae3ebbc73a9b0433d4e329264cb53444b8b30d8b973c58bbc3a7642730893c8b680b74761a78658459f7d34ac52c0e6b3b9e63b2cd85b1032c6dcc316f61b0df58daa4c31aea999e35f7df6f98a5a9d6195c05fed7ed1fdf203796609fc8492ef9be8d02f5b99b48eb6d963e7b352b790ec0c62407585a56c17318e951fc0db64466ae16e54a0519e1450b9894b5afd40b49cf33630e932a42dfe7426c724df0fa8c95512342ed7eba2c71cfe8c1ea9bd68a93487da3124b091965789761a636ca495e9a4d239e26c92239e0c8c665fdc145f8ddaa18424bfff8a9b1f2b5f0a483b9f1fca5a01c0addf2d5234807bdd99a2dd55119dc985761bf1afd0379118c9fa79df24b0f8f43551a7ce904a3024ce8bd4a26d880d2f3fcc282e8ad9fb5377d5c4b3d89b9d3aab35d4ab8c25f09bcfb17aa74af6d027f0c6f1825c52729a7f8c3025806522e5cd44ae70180f1dbaf8531cb8bb514c205fedd699ea49b735ca62c89a0eab78edb8ae587e9bf06c5cab3a4ecd6f26de4e41d4311c2298e77ee77bfcea6067af7f4182ba6bd8b6ebd96c5b544629ba72023e188df48b43cddedae9df46242d6dd7e40078129ad4072948802a7ee082472b4a6b367e0801baa649e14d9910c6449ffbe8459ca6f9e9e7c90326607c8c7eb822ccdb2ae73f264f9fec06c4d2b8f1bd0579f9c627650904df41db9c24173d3b7a98bf6686785c8a931f1697c98deac9e9188719c52d4c3b17a69e5f94dffbfbcd3ceb82cf78a4566c7ab0c926d0c7821f63c362b8ee228d3b44af3e08f4f071d0a8dabcb9750b365bb0b99a8e31a899d79e051014a63805c3677379cbf308f537e414302d6484a269fd68be8a31c1bd29d21b8d824ececa1023c9cf62e7498a61268de29010ede843a5fc8a3456db982a04499c39c71745d5d011a7063c411b673efa38c9beb44381f9f25296ef7883c773c7ef23f897767d736e8515e8265197a1ebf53744f6c3fe8f7da347d401deae1ac95cafeb8cba22b2e1c0b713b230907d2462adfa4926dd8b94d6a7eb6653114a0c7541ade825f294acc48fa5687ca629f6b814547be46a95bcd2f58de82819b2a1dbbf0e131a8411200142ebc65adf684f5ef5afa5aeaf572c0c44d2a3864e1d5060ab7600e0661a3eb8191aabcd016d0fca93383e941e4363e7a2039cccaf7778bda659e862ab844d7aeb3369457d5aa06533573e8043b9ee9ea8b5c26fdd746be3a07fde7f428ca20aa743e3b0e393b27e652637689e2caf887d50f654eb43c17bf987b6b385f1078a574bc1c4ae4bdad2d335b1a095e36f2af9e336e04208910421cecb6a8fa1d15e72d0e3b9e155a39b17d4bd0db3de0c5c79f8b0dda925a9960e32c6f22659fa919c1595ce65ee951d9350373e447c973198b1908f83f2a9bf3c715c261fac01a91d2f22ec2b889f180c9b6f31a744a2b296c38652e013bc1c5a8fc2cc3656cb46bf702bd54e012cbd28fbff8d39e47679fdf5b06b5119f0ac8c9c086f97e6811b57da24fb0549fccc1c5e0c50974fd9332fff6f863fc35488948489c4603f2330c194964123e01aa546871dbe93eeb83dcc973a63d93e641c24986df2fb72bd795a1e65fad262086c83dfbd5d3020897be4bcfca2daf0795d348682c821dd576f69d9f1139520005c2ba6615069dcb30a05b2f6ab128bf1d5ac2cdc032ff32942cdf1d4dcf7f370879165b6c8dd2bee82d15f8b19b20e031ca5db36ff4bf353c50429f856c2d9411c65ca48ab6e733e876df7c3fccdf19d2af26bd3d8707fdd3e3f4566733cd99acd46735f238a93a0733d868a519ebbe378e172abc8da7c00ddb958957567d2429d40b079b485a86b03e858d5337ded91726e34739776dd20021e81990b56003044d9487f98bd5b88922dcfc21ccc4558d76277a8d2cd82c94a539e00586086c805f73e934dffa5d3c2d5af38257fd390d01c0470a08c9b41d44952ecc53c3ac9ed266ecaec0257aaec2701baa208cc771d976ea97b07d8be534dc95acdca90b85dfc317189a8e0bc963c6bb8d975ca0295d3450dd58d18125073175396bf646c0be5f887b77940a792ed1d38d8b687523a8143bd1398e3fde1546c026acaae2baf217c57df8e92b0be36f540214a08775c5aa25dcba42d0cfb92349b23df63950fe1c4b94d3587ec7f94500108d9352330d7a94990c1f8475e00ec78d56dd13bab88bf0170d4544ea0b55dc6398fa72692638dcb0e0dc58892c3e78cd814b5294e4a23803cfe49b6cce421541d4c0b3f9c7fb41d8c0e60c17e7b5a2971672ef6f92f9c1c0328f6e1665f978894abe0a22cf856e2a8e251ec5025a45cacc2b9ae7845f327ca11bb7c5357077ebdfd0d9561418eecb3e6175549d445957e5abfe450817abe3e418b31e903f7025158c62a0364f6b228a701010b7d92734efd7978fc2c9d51e45f1d07c932111e72ddefbcbf103307218c5109e0ce85ace90561d41daf37b639cba25e8eed423292dcb82f544baf7cb0c8872f289f0b889fc19fd747aea0a2346c795b951d87f070c3444ebe70d671de689e9d9b827c0ec657ee3132851694e37b0d49c0a1b16cda95159ded5b5f2697710c4c8c259d593a4f475f9e3c6eeebd4d07e634f134767e224b2ef96e847426374f0d8f3aa7ade16a83f594230a209e162b5c745da68788d6cd61cc5d293f5169da0f504585bd519038792bb91d9924aa0bcdaf38fe97af40cfdf7aee56dfedd548cf7c768419bd4dd3fd5ff361c84c0582eff8835b5ac7ab6d79925119b6ac60bed6d45ffaab75c79c1125cc2a7a39861907d472363d843e7bab64f46e02cc2b3a76de4c2135a0be0e89f88bcf07e6c3648de76004d5da53b518f3e7e5fce69d6d9c02b4f6fd5c59df6ddf2633e7ca677bdba3b2c45bfd8792fef26485a4387af353b672a0b98f18895b99c358f62b186eabaa15f35b121ac4976ab0f277a69f2411ee3a1d2c9d16659ada0026592a2f2b22e40b70e55423e43230c736fb6942362506ffabafc542c9beeb8ea20576fb9349ed27f7c388cfbbe096afddc622ff3b5b198299ebf9c371d75e47c34832557a5e5a957a57162bd059fd360d6138d8ef37bcc15fb1a68c6dc212f7c7f53c0f8db31a693919166f7399e39d4126b8120ab449acf3a2fe67dae31de77aed08f88f59d4759f4fd8e6678026d7852b48f665d3eceb9b03fddd79b2af010b2abcdc7f90c6ab11832dc9077333a2b6afc231f0a452faa8c7bdfed19f3150c8a1fc2d2a5ebc025857cad4027425a5f7f3a20a0fc845202df0a19af8944931f0fec0ab6e89359843a0f3d0ed6ba61d0e080f70633b3d286c56d9a6261622942b0e866c01f2ae263c519d14cd4b8e8460d3be3694debf894cd22308a36f8594e2ed934c9e7b374f973492e5df9b2c82c8b66f0840b6f12e8ecac472e8ea9d1d2cad68517b3417d40b2ea39817e97678e6f58c05db230dc20ec8b0d8b9a4515e519aef1615dc2c152454f0e965cf7ae0163a1932d800fd21503eee5ab3d6d9b6d7d504cf1db2ca0d2caed5988ccbfe4450147dc6abcb82bf89cc74424e175e6fb14fde120c4c57779f0610fa496938b94d00113227b84be7ebadf3b0bc2376dc75766252643111cc92cbc9b685a829a8c053e42efb276876608fc1274f86042c646beeb35e5009328098ac453027f211f16da1a782adaad5b8b3384ebce88af9c23064c9245dae84955e513a82f86942d098adf224f05f9f9f6da383e41c94f981f567192c2b49f4e658376f39317708fa7f968743d1f0f5c0bce1f6d925b4ee89537afae6588a9b4a516bdfa9bb5250e2721c578d9e38366fb3e2e4536695b24e9d661c33bbaff35763a511ef801e21da07bb9431d717ab89e1722a62b829b78180ea4e4489ad1037c473f1df6c07c6858838915e5db4a3953387b98a5de553346c0d95f5abba1bf7c1a08e6d1ad5fcb4dd44d3ebf987386e290cd9daf7fb67068046b590aa432224eda1790718f5b6e73684dfee580f25be08ab44195d88dd1c4338f04d586320a2b50eda2f154a965b59904679ceca6d85cf8ea6ad190fbce9f16e95af8541271acc225f49cdb9903dfdee8199a440312c13c4c39bb42f88bca9144d03a66ffcdab094ecab0278257a82a0cc20b164c5b69d91cf408883a851848ca6c50fb3be5546030ec050514801c061ac9959ae6a81b59759b93e623b65c7392dea089694d7f16290c597f33493847a7a937cd094277ea0c77d0c92d1c7efc940fde566bbc83dd3a767c22e38185dfde8e1d87dad82cef80e41d72bc79b455c0c1d5997b83fbd315ff676d9b5874498d76071791c9b4815f773810cbb990b0c32104361c96a2daae458aeae7d270a9a8ab41029c652bdf25955039a42c8842f419b0326dfc3dd21358e179d62949ea8624b41f5f352352d90c94c6f4d4b34fc375b264129189bef4e9b336e541ef2aff041bd6186e5b4971838d1b8c9e6c432c610313bd026736cb8a5226077fd466e7817bb294d735b056e6e14b15ccd6e1c586eb5d0f844554bf88d8fd03cd4930930c25d39cf11da681561b3cf3c81da0ebb38fa31784c34d5f3838092e520a0e2544dedec0bf4f73d55d069ec0ec01d0588dd3a46ed6f19c4481e7d32b4a663bbdf7decf0e9658612270820a20f139007f3b41659ab2de1f9276ea3bbb286f2a45ebb3f54024302acb3f7ad13af50fdf55836042af45d6f9971f74fe8ea3fc137be1f9e51bf6026d2737a51e6a295ce4314e6367921b36dfa1ca2231c4eee94062f8538ec3fa8f8b2b3c348e6ebc09131e95c9b795d0f575956ebb1d8430651d6125264b41102201bafc9a8fff7d23d4013a5e7d1f868df67b800be0be82708eee503ff392bbd4bc0ab141c3b4c400141939c81484287aa0895b974ec783e5156cca3fe4a4dd5c9ff9449e093e17e60b1c6f77bd66c46e4d7d11f835d1655636a5626f467c0474a0b697d7f113b40fdf0f132c9bb0ba280303df1b6751b3dff6c94bd23a183472eeeff5871d3339334871bde401e52d3704c22a279d364b4087d0a52d73eb97922ebc50f83564b134c3e38434ed33d5b9654c327d8570583b579743e2d518761374181c550c4e6f7629d107b30d734cb3ba33e6fc66d8ca52a7a8f663220ba702ec348f94786fce0993269200f033dee24917ba2a6f3a29285d5e8dc2cfcff43211d07b539447d4fe7592e8da269f2ede43fe23b594f013722d6b8d0e008e7ffecb5f16e17fe4fe4dae4ad96b03b697ec762dcec95c1de00e8e231324a7bfca1eaa6de20fb10002dcb21a28ae904dcb8ac753bfbc98d231544d1242e641e20020f713bddbe3abc7fb56359c9f45f9f159762ee89b85a24b55f045aecd3d30b6abb708a62216e58702d1009414b89e50be3bcccc876b94cee6ba35c8a68a24a3b098c7410491452ef3d92df7d93bedc5d9688240d6f88227ae75ba4ea7792784023c985b13e40c988279d664be0a8313ef1eaa134cc7df90062541caafde184a8c22da7e3cf6f5e0fb791ccf62da72fee259aac32b0b330b1cb4acdf4473668bd892aa85bb8687a83579a49db5d0b22f145534c5742a5c94fee8dbcc40b4c78d0c13d80b158d387258c6b799bf8bd2ab91311a10f3daa12985b7c86c0860a73c49056eab0100fd7567abef73bd906ea79aa8389ee78fe68213076a4e1ee5fea18d88bb3ff39e8c89429631a19e0e6e777e36e9166842dc32d010811fbffcb7f1204173752ff83b31e4580c1646d2ed91222b06cfa22abcaa8119442b431a32e6309e19ba7ac7f7fdc899723a393a09ee9aed17d7034c1e77934c7bf6bf653db9eb4bebf2e56867ef7a9d10b1c467dc21335855f3b7b6bbcec737c5954d7a8cc47ee9172c9727ba7694a01b07f0193943148231fca3f29d71f654e3a2f621c799a7f2e21dd4e35a34b82c8fc39badf1bce7c69296d9494ff88cdaeadb30dcbe77d60bd8244ed008d3bbe934707c8d24badda7f32c856527748f25f9a32b4b754c46dcd04bb1f39e246bb7923c0f6b8cf26488c4aa28460d83e5379028a940077a8399f9a33a0955bda086658f9418087429e6ed9d05a824583e7bc34146672a921b07c8db7fd184d907c703aaa546571fe495b8c77ad3037e87eb8325e043d0cbc673d48011187c0c20902b95ce704c734cc3723e604190fac27d6cc5b6e9e2b2358dd41edcc79c928e15d67603bbd05d1722e6c2799a9f3d8e57e4c9ecd1ed96bd252258b8ab3ec4bfb8e7659ccb92a868202bd8f17c28ec5343ade61c0a241a3b692664ff3e9da0ebf982d6673e9ed6aa5218546615f922383c23e342498b349dddc7716184b9db7d538375e677730f18ded79b7909be0fb036d74b77eca0c4c8e3c465e72fb173c011bca070ab0536c9f99674d41b47a98193f6786e4284e5e89398bc05c5b13d99ec507f10cd919994faba3b44d629c3e8d763d28d7bd572553db09998f66b94768035fb9ab355665bc519f413b9e7e2d264cc04d3d18c43fe94d2839918923ff9a959a08c87ebb78bf0a2998bdbad246f349c330d535de1eb16a605f0f57dbe0c5d0ea6980fe9cd8b870929d308ce6afde11203da0239cd52e42a4e84460c022c88ebf3ff220e66f060486fa2e579501eeb2c0c74d7b8a54569777305aaf18fb403d5bb8c75c51c5d823c87d5f227234bdd0bd40819247b3a87f4aa7f81c82a3c7d248303aa117bcd613aff6e7121855670bc8a8fef1ba3e1407618cdf544d1b3f7a50f0f498ddf99e2d643d5048a5f8455a82ea7cb4adbbddbcbae0d6a9690fc8ddc966733ef06d5e75e784f730e9bd7a6bf821b9006470110cb4fb7a707caa866b76593a3f16252c315c5e9f9fe74f9240b5f0b1c4757196d68bd7bf8501de46e4957c2e69a79dd303add06e947aee448d08d7ebfcc6664ccc0967de14a76e148d9bbe9a36e149d5ab7e57be72521f542513377ecc937e8c241340d7ada861657b2ec50a419b2699018967906c9ce213ff17e3d271b37634a5c9d97224aba4362cf66f5a92149849de6968a2e7f420d2b790b129acc19baf46c085557f236f894d030ad5d8c083b76227991b58b506ba901ed4fc3178dd26924fb2c8900100677d275af4decc2a9a4bad73d930f059bc65748633602a2a3cb4fa5d004278ef2f0c4bd98fe2763dc9315b10c86fe18820c3fdf6c37c0827964c987eef437f026e693f55da6f54158e286bd41c1bef1e8f851c8fb48fc774dc0596ad8e46a066d3ee0bbe98c21d9779518f34f87566781a1ebc5c8c86375fd4624be442dfac2385d6ca3c4daf14c171ff3cf48965df6b0384a55e13d15dcf7136264703fb4cfa29920672fb8f3ffcfa5b8e981f881798256fa8b90be50fa2606c2f2770d500c1ec403e5a46107f4cab07c630404945ac6f800e7782430f3c3c216dd57ea37de675a1ae95c91fa54be5dda9fcbe419921ef4228a53ef4f521ff148dbba627f9379558138cd766924f6c11ef87fef6039cb326c3d33f5692a852be2c87e0fc5dfcabe2575a32776e2afe4155cba8a5840ac354474a2d2421af5e3f16d0bfe297173f3ec9423026db352beb17802fdf1e4b08bab1ffe8472e7356af2702b69fda3b52df7a986977fb62cf8e1b9052e97be1d7716b9c13654273c7aac574c90de08543b8a362324b9449592af5d0a164365d30cfc6b8ab4dfdcca530007d9134c89fc2d081429c459c68a3a480c52d66bb2ba33219f502c3c0f8f36ff4697d76c3ee90904b2bf2e89879e20116cbe49603d0981eb9ef540d09093170c6ed69a0a5dee3eda6a806de125a90b56f6bdca4fe901500915711eb1001981a3523fc22df9193b1293201a2368ec700e2f3ea7e5553c83207957d074a9a984f99ff6b5bbc9fb3f73203a3521eee83a50d518223dcfc2ac230c643d25bbea86f9cac0747145716bfa29b16ac1adaf99391bed096ec98ba9241956a5dc3a03be9463a3eb4db3945abc0d0a677e6505ac23c1511213a5da79896e410677f9fca10903d2d4ca74aa5c1d7c061b83f6eb1bb2f9827629badf1c8076250e42ce55a693fa100353b4931645c0773d162406c09ae0c8bb9487efff7593768008b71e90451315e3a66567006f9bbf775cca41b555038ae4c258110b3de31dcaae4daaf8fd10081349287dbd89c01fe0b8c70df93056cba54cd11ad16d13c8a2ebb338f6985d64f0040f9d1ce397e430ca84234e0515eea5dbee070e9fa752294754bf856f4a341601b9502a74286a03cee91a5278951a444805730e5a7afbb36ad2284c32f36c5e68dd1da207d4336902198b49060cf5f39154ee7e768f32abb150293224b14a1d60e8d9d1348d4a1c1df07ef420722c7f591f2e8cd12f71eeedf24a89f7410ce51e5ca91e9438d7ea5e3a59b88ecc2aa80d88844ed9b4de765321ebcc6fba77a256d9371f8c47f728728b4ce9627374e92f2b706ccda3a98be573c43afff19952459d642dcffb113ec7c55c66bd891db6fe4fbad409ca527b7848a767f87fc6e1a9b03962b14045e9bc4e50a3e16b3ed736139381826153bf1711a0f9f8660037ee6d23b0cb7c58a79de6673731b5befc4abb297b6acd84be201bfa2c5f85ddd7f0ea1ba7fe1e2b1bd22f46cac88274eebd1eaf89ca3ae0b13871037518d31b5794cf2ba0725a44baa6758f52640c9669f64eb51e2d127eed62e3bb10bd61f787fbad847cc7fc039a6994f6c4f52c6ba1f3c8364d1bfb2e81ba6b9a47cccb4bea57b7f802cf6602436f50ba9648c57893fe61de17db3a489831f5df51fd28888070acbecec6824a75e5ddd3d442605f3207ecee3c89a39c59dc5a07549adbf058675c4fcf7a5b60cf889498fd9b760e1811853b279709de223e7de33791a96408fba39581ad6b80eb23eb9b60576c0da9bcd3525b3ff47a9e611e6e5b9a533c863f24c0bad97d1c1e1ff84f258075b15220597a7737b60a14effd942287b12cfd6b21d3ec59640d13c635a73dec80e2b3e64c87e6572b675f7b454d31e0ab6ae591c383c7a05973b00ea37da93e3dd08ea2207b5233bb025288b2ad31f3abe70af2202e881a7d363b4b14ccde3b40fc34108982e31069e6b85eb57a956d2656e898396c7306f154d0a33a6506e2c26979e3bd447e43d33232b1641dc3b7b8bfa181f0b628331ed2a7783b0996699dca5df8cbf450a09f5f06df499b954f26acfd0cc61352afef3e4f530e41c0262fb7d9be6e89cafea8ffa433a059ffedf2cee51c74ce452e1ea8ef6e0adb3ff4741e3231e3692d5066fbbe98663a713938319f84bb39dd762c1d549dd8194fc917cbf9f3a7bc1dad5c8ebd95aee85dff41f6eb2223ede1894da91ac58b54dd0b25679c354cdafebb838c70f876566bce5d1092b2c5e6f39dda5b404b0da785e7ab3b846aa563ffd331f1202b83cadb2dfca3da4e20389a3e1cabc24d548ee6e975b393ed8f036fa4b290f1d51b5def2dac7020e272f0f55e49bc5da180b7336966ed8f462f431dcf2a3e7086e7cb64e268db125b43b17d22f1584457dbac51bd64aadc104f0f81863100b3f94eb5f3c8b48b457571a1ff5ea8ae43e944c7a7e66b038f5ccbb803bd0fc3d3d760b350f5194a7220dd01b9ff373694df73674ed4957fc85d364bff7bd9436c2501b790918d8ba66c614b9cd055d9ecc8bb18a71f2e810dc1b7ce0d21a393ee9e876b3db51aeda17c09c2cc78a7150c174380d62165c48badfef1ebe2c09b9408d67056fe22d891b64e443bc98d07d913acd40224f672d2ac24a4bf6975b0886f37ffa8c5db2a584ce9ff47261a8c17a78b751d9364f1ad9f24dd8c3aad7f193cbd580893c18b9180944a9e97ddd2a29bc398841c45eb1f7d19d5f8dca995f00f4196f2a16271feef7b37cf15e583e79cb6a9ab0905805bfff2b0ed11277f975606a610f92ceda0d27f989574078d2af3cd7130e689bceecbc286e9f3453e7fe12d271a4dbccca81250b5391677462be0831add37c642b083d6f9e2e05a0e54135e6817532d61dfc9056b8e6153d8029726b1ae19f57a9eb201974a7511fb3cca64d91aac6329664b6c75891079b095a1f4e1b10e21e01efc1aee85bb4f60cbc1ebad3d2b6eba3668d42fc2815a4be41025560d0e0ab004a63edf9231596c8b34a87ebaaebd7ab49c083278be5ba583818204f9f025df174274440392df29c7317a9585b4cbd98f61342b669687cfc610ec5d054582bfafc9636bfbc48f0c9fc9e4ae269145b80d9509e4fdd8ae7328c940cd96189e040f876b6c9a960f4f4b23588c5d99d1e4c237e11ed7789820d4c07c5575dedd51aad168fd61b0ea99be157b7f78b43bf4c79f2ab5caf34dedf9a33a34c888a967d9dacbb62a7aa0908e5c6706985061e89c29d5b552b2f91a49f8cb31365b5d41b15be6a2036e93325fe1c76893788e934c8e524571f68234da4fbcd8cec29e02baf1b0d589c27a00cf234d3e289e536426f738918c75297334d3dec3a0b159d65dbf74599d04f07aa94c0d53e2ec4d79bb7f1218feb9c499f2009fe563985851c5efdd8ae91ea09f089c59df8a04dab36bdc51ad69bf16d75a3260d9c1a9f254de5aa3b9557f5eb429de723720d721e67a2524a1d2d32915ecee9479582486e00423ccd2cf7e7e3845c34d529e9b4436bc20842c8852f0fb7b0f740f6d3c2c6211f1a567d17751c6ad5cda019911cdab24273dc5665a16f47996c526dfcd63055c6e6ce56f8542bd3bcc1cd20142548b8d7838542a9315a18cdb76b2a7e573a87ac19b6b8fe2dcb6c2629ffb2a32758aa3aa7143185619f508891dcd2bba7aca87f322a587773f9a929c279d7eb2be6a8563f1647d85271aefe60f7626c0eaffd1e6adc132d212ebdb26420d5af91e76896031849864f4cb7b78a6ab8e3a10343d559d6c656d2e4e4e8e83dd746d9f552fe1c39ea5926b60405225becaa5317848ca6d71698d8cefe61c4bd57702d56241a4a2ef4de2b0de95fbe14d02e2dd83ba399a3bcc0ca90e869bc46648541e238ff7b1f7b9ff15c299a54619f0f6537d695897cb33b404b6a92cfa4377a3adf51a23e5ec20569d6c0f57d58fa419ab5b5f3836d2f5161f7745b42bf54add0538c2915bc8a3682992b271bb859f5259909f9a462e462a3a1ea16f8ad72a0d70a20ea27e790e1c3ce30ae45379405a2a0f40a04ce4a7a40b25061fbbb3640828c4a229fc524c9b448ad10432e98d01a01ba7cd8cfd68d821084e9be25f1a66dedf346cdd85bfcb8b5f15a2111a100bcd9096b9d4537b1980d7279eb06d09d95871717d9ec79f4d2ec1d3e60fc3007e229492c9f1884afa866951d926c0d2e0b2af50a3c6ced2113f73aa3bb1cd806199aae516eb767a55e62b0b3f9f6d3f2bedd21878ef34e14c1f6d93d65e849535be8b9dbd3f3ab2d1f182dbe8124274bb0fd9be0175ffdf9845b7c46b61903aa70ca24e08fedcdf8d29a9f29fd80121898d9dc4902691c8816f80eb70f26d2c36abbb1b16a9b8bc22d8108e46a9637d53ab366d0ae50043390ee44fc47c995103db1e07f73b0b10dec07fb1af64afba040e65e7bd4ced3ac55923af1e1cebcd5b607148e7022200b999328b77de7c2326238147d01bffe8b23980fec8295e4eb5c8ede5c0f5a38a896e033c63b71450c73dafca024ee08ef06a1e329fd0868807ef2965812d41066fc426bdd5e46033cb3c92b88e33afe7e46e9d8f7e9e568072ab09c464688f6a5cdda9c43e9e8a882333678fff0ee7677f4a3b1c15f7fee22dee6cd66902204f92505098f6681b5036ffc2e4a887cf4de4607238a242b5808e337aeae29f51c2c3c186dd9dd9232f186582938780726e7f9b98a406d9f9582fc1a0f6bb5216f1d7ee29eb231be0eb61e881b610c340a7f4dea33e36424deaecda98f841d1939ae24bd6221263d5ad289476358160b2dd999de9fb5867e169accd92e40a3d6f1ece72d358b60f2360093d821989535fd99e2f3434c5749240fa71058c9dd0bff03a1bcd397a7b27c50f22f498f85c92c0d469f438c82d6424e1d9b5a3a0ae2a6b23670ca595ed55be18fc2a3f0e4fd6bab11b5bc7e0a24f822f9b1ef33617a6900a31b7fec90ba274f4257dce9a9d6981d133ca65a7a94947f024f251051762f657980131600e5cde86b13c96eb545e0defe45846d0dedb4621977e367c10b406134f96b5aafd6604313a9c43cbfc3340b45d5073b65fb01c474abbb95c6f4a3687850900d14f264e98c0a5ed9713cd8bc6a199ebbb334c9502eaf5a72ee9df86f46a3274d22a23d9ad54dcf53dee37ae2d26054af651f4928a4a7549a912d7d50061054877923dc4b50af13c33708bc8b3e49005ad0c25902ea6129bfdfbb85e5c88414f70441bc58eaa22e425801c1a33afe6d5bfbb0d04755f519f557b787dff0671a4362c611d07fe5c42dec7d38439b0a0cd933e60d379eab31492827234e9a54311df274c46632258fd9c9d63af1ef7cfd88951a25e27b947d85bfa70d0893a8032cdd5225e0fb124478cb908a56a08dffd0ff75db75500e02f42e4f9a222124b5035f4fe0cf2720a49a096c0544fafcffec51db96852f6c9e4d08d4f76223998e34bfe8806ba2c4f671efff99c6d668a9d3d3200aa0f05a734dc5efe8856ed364b51e6ede85a80229f0da7702b3093aba54fec143d7800615983ba0dd7f6ef4c8f24ed908e54d16720d2f41a470967d19d375d6a1098e271fa48d5391b0a3ea2f3f98929a2ee3d69b40a7507058523451b2770fdac4bee0b8bf780b3cddc3e17a1493f85b3f5cba72b2ed93c3d34d95d527b6e7d16479dcef78de78606cd37d86b4ac6c1a96d21599f6870ddaa1c5dcce96314a704b7e71d859854fdb420296564d9805774aab39a1f1252a5d71faa975a8e7db361b967696ae5b267c423dbfa3308dc963f4c8c5964fe2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
