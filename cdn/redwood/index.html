<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47153695a697a42893220c29489ceb4c7318796c04a25e9cda1656a00f165e8cabdfd9c4551552bcfbb8cf2235690e544c2c893594c15684d7d795b52f4a471cbbd7d8fa21f125218129e1dc4a89413000886b9cd626afe6fb0f463ea5c32d4be5c40a2f50ef33cf1db60a4f25607f09cb7c3e74b956fc3e2740d46204af29bdbd635c78a134bd4eab2f1b8d998af50e440a8acf856cfbd0920eb3849f764c44cea4e1623673300e9e0a71eae985477fd68fa79a95cd7c82260c8968635b9ce10133931317792ed5f2a13eff5c6d3c08b0cdf8b0f6c6f36df2b93b28a6503e674e47658fb15d96b2fb5968b9235b7643531e5bec7f91b8faf16b3d755af5882d72d93d42e9c367983f012545818a8e5070e644dd8bc146d2b0b7e3b34b66e4a34caff2bd4ce74ee362415acc594b37dca7ca4c54d3387efad05ef6ff8173b9b49401e083950874689492e9a4874f2e1059b8b2c44d9fd691d4e2473136ee2ffd5b2aa76f08dc336ecf6baa8b91a0eb166b2e9ca5ce5a62741d9decb53b74e036b250c8366fe768236cb5f87cc888eb60e981c8a215e3f6dc463a9252d8acdf16042c22c0ad8ad83a869e3d0cfe0d7c371295be90aba26890a0f979290b931cdcd7ad999dea925d4e8a5cd9303c8b50a4971a14de19ed5847fff4e5eed7a00e56cf84b840f3b722b4a11af0e0bf74ab430c8369f2052ec3716ded8d36c5b5e5852e1596810eec39f2bc53dc51a84617bd42f80bfff35efc343e08dec3e8794f29b5f1f8f15ad627d19ffd6e4b47f82934e27995add92f40baa623de305bdbcd205040602d999aa54041965fa9d0b2773c2a31b2cc0a56c22d79102763b60f524e2d7a3409bdd6576935012301e67949f69fd69d16d6b23b4ab1a82abfa07d8794fab50161900f60d441c348ebcc3ee19cbb9f01e077e5de1ba67a60ce73733bf6b6b36165a970c7839fc739b1a1401c5574c71444730c8c9ede2e71899a23c003bacb686b66113a9bffcf9a8082d03f59ddbbc3f5a88c1b049fe31c7889494bf08130a57a2ec6efe7bfe977e1aa0120fbc28222321d0a394c48c73303a36e6b8f6d14869d948a05674ba5ec55bd9647a71f1c90cd8cde8d4e056f5a6034f33da89528f80f17c8cfb49e07dc3ed1118081e63139574afbbf6077999f7f4244dd841d3999e826254469b47f6af22112af2b4d3bd7a072b07c2a0e4ee5312905957fd9d35985b51c5425fdc60a6fee313b43bac0c78b6d781897909a7beb17634bfe1bf93e524fa94acae57227842e627955425866cf6d61cb861391b2f6154da925df49c63dbc39a14c850841e69dc1513498ca2362969e6243243be9ac6a54e0b1ca3c3ebe4588e1f8177d4d8192f298501f9979c13568d696cf5bbf61bd1a9cf8a7c80195b958c759497caee0920da971cef8b0826605fac783938938ca7ff994a72d04f5134092645df4e11f8c66b38759d444c117e449b9a656578f0737d50df34fc689c2632e001269e08286beec0173488e74b5e6fb87b09bb7fe7e0f63d6d339c8d43275fa74762dec3949693a77c92ee7f27de704e32cd2f16f20be6d97c9e00f6342e0d8555158d7faf7f5c922044c53c7599182fa0bbb83d77c72355da7b2ce82e482533251c99c48625c3bce98bad5ab3faa895ac9b06ef1c458f1b38686b8d4eda3dcacdfdaab2e3fc85893e8cf0893d5919d27d87ac3817030b634a97527eae63671626f80f65afca0c826390a63fd8988778baaef114002f5d5ca50c227d9d9b216a93df67bec7a3e4e3dbeee8b76e8b0e73841136f55ab69ba7da1026a21b8e839a05b20b1c9f9ccec8161a01ee5d28202968b94cd5f6d9b0c54aecde0187646326ffee04d15687b138ca163b9fd365edd84b687e98ebe17078a3c331c055cc111b8c3bd65c8252b65738879801cc21e110a3a21271bb7138528a6cab29fbf029bad4111b210f9920e75e01ada87f2a51024741400706752303e9a1c19b254886e9449a0269023761cacaf0dea2111d0aafe8106ab0f774814a91d84404fb3deeee0baf7d9359298d67de70f1709d9d571a80910672d901636cd656b615ecb2d99dadd875fb6146316dae7ee7d30fdf41859c8ef69c5f0be352333dd71985a8f9f73c2dcd1be74b5609ed5b7a418d0d473abbb3dcc7d7f08a43e8c3e78ed6b0536ccbd0a92d2e88afa3b2beedba3e111aee3486f51a7492bb47774c7253725dbfc93720a7adb41976e257b57e25da6514966d00a893166b157297aaa8cfeccd3f4202b5072492a1218bac7dd07157946fc5c6bdcecd72c1daa68c12acbcc0e5a693b119bb34792d600d256893643fbb8c1a0a79de8c0c084fbaf22b78f9535785a474f28fa02451fc7734cb06a2262e8a594d817c8ff7fdb33bd3638bbfe7fdc12273edd851193a938bcb2295b97799f8842e54ab1fe9bb49646fbd76b082202ec27cb081fb453d0aab4e7539174336af87dbc329ee8f45fccce140fb861551629193b4b9d2ae84a1410a39a81721614c15e8842ba23767ba7e3539f5cfb6c65b6fd887e3ae7ccbac29359fe8a56d1341099ce4dba172f8cc4f8d939b6fe3b42c0ff5f859d7a08a6734d0cf9edc5d65046a7b01924fe23340d358bfa40b9fcafc0c1bda21717ea76a613f9cba83c5285ece569c88f087a1f0dfed2d13b54a56cea5a0d0fc87465694665eaf2b03dad344f11276850aa32b0e2974bb95b1620d8ce8b032c5e84d6684c3b41ba78f4c725afa3749e67a43439f805e03242c76d29e7b99bee6ef9d37e6780df9b127b0c7417454f6fa485d5eb130da9452317ae84a56e425fb6d8776aee8c39a5ffd96d5c82bda18375a47d972ec870dafd3cf4fc3680769650f5a6b0547e12a810471d1bf1605356611600108d6919e7c1e9440a17e87ed08e1a7360bf52ec39f56f7d86bed7ea1b1e8e4ad2c73f7f79c576c4be7d013a05d91d08ad756e167d2959be01fe2b34b466e97a7d38a0964f8b0a75638f936c6869648a9c4663906d39d034c20169160f672511f85323acc37c07fa2923c4bb97a225e292fdd98e1fc618d315efb55b42947e32b225859b722872da764d9908ae04e77ca676564a93526543ab9ed9eec21c8b97addb631e432d7eb4a0575bf1788dc5efe984f5fbf7008866db60f380b3cd9b31724bf1bb175e1514c08846e55ff052f57624d9b090cca66e3d2cb638ebc5b9dc3198c85cf45b74a4f36b24ed82d107e7a1a4cae03b69e96f15dea553091b1dc722adc7b4f2a98dad89a161bd13e8c800feb6a6c92275850c0de5aed0dabe05f5f88e1bb1f60a355c4b8c421b2a01c42408eea63e5fd1dc543c71dc46703fc9c4b4440e893ccc054ff3e75559be010b239997f8cc76fb2898c14a9746b589f05776a9e85959232b67f1cd4082fa4f86f2c5c703fd22684d4ed90536cbdda0a2ebc6c1b10713145b3636a513749e248fa26e1bf034bb83ff885b9466e19e7a5f90a1c34108465d1aeed68cbcc0edbfd3875905badae920ebc0a887115d6c23814a164ab5d602eeae642414a2f239e7f9ef242f3928eda51b886581be01900b2de0601bfb0ce9443b8f4eb9f24b338a6479e57b9b1a8df0752c0c4c1006ea737669632eb66e6b677995e66924c107cb5935e2e3805d8a3e5efbe6f7cda4b34cbfb2b9f0953504f28f14d972deabf3cce4be36c4c5241d4b57e9a2d01ff4460c274041fa4a1be81f989c20777beed9730f66c647621c58c6996ea5fec9ce3ac35dcd0c6b868298de715afd5f1053a64b3f176cd2f72b9d7f9bd24dce367fe3f7c2f7e86cb9224fb9497f9b040746ebbbf77b16c9248f922f1e307a3ce751cb8d51cf94f2af187e2c1e9e6a1be8b8996a86297fa7c4182a39daa35724a68ffbad57073a14cd22e3915d8883ed69edc3a44271f7f5350ddce830c649fde873109b4b0a9ac08060da6df0366de6493be1f37c1539f83e1f182e9a96eb28f6be3ffa976bb53b5790f0c66afb2c9f719f73492157648df0a5a1921f36ce888879d5839906aec3d0b0c694d8e3c920874f9bad65978a1f2dc0aa97c2a56e9041580a5f1d591e0758fb316608aadbff424b6674ff41363c8a17e2024d4b828145fe03b1eac3eaf54524411762447fff32bee1e193aa3c34b71384fbc65757cce0ed02f44bc756f1cedcbb40557b7f5545531f04d2d3f91c07bc365d1aedb6c0892f33f69f43d0b2727c20a0abc686b1206f991beda5981872ba7a8fe6dc62fb8596175db67016aa0d2bd643e3f739bfc443b6f5a30f2139a80ef73795a192909c13f460ba1fa4fa4e0db1a6b1bc3a60e6e908898d74795c6642768d1fea2a0df63912d8cd528b23f89f28399e521725b2c0836be39f56b0f5d20bec21726650efded8959ff286c5a66a8e1f22e18bf7b3fe25aea4b51c13e4bb53144a702db035cc9f7daaf491ebcec393acee3b43873918f78ab757f9a31f75f0861a226703b17ecad8b8a40839d0bd4b3bb56208be2f2fcdc8f9b9d23adc5373504817e64a48567dec79c40d2fb438828f3a29b03c228c8884f89b26a9c151c7fa5d174202bed2ebe6a32299c36740f4afb5a1ac999a2697466c012a5fd135cffaef3c0ef4e1c21b6590f6e9a751bdb2a44b510472b2b38d4bc1b3141cd361d4c036365f64fcd5dcf8bd90a2d422710bebef30590ff401e934b9d15ccb13db3acc74e21fd8906b12a606a0c1c7c6f0b9928d2774feb2989658b0ad5a7b1bf0a9c368c439d05eef4098022f9149afe9c3d43a9577d6e079b758d4ae8842faeab164f826affc731a8c22ac08f18a63a07948d2fa30e7edd1edb7be138de40eb15ef8615223092645ac80d20381c6e1461ee274801cb2d9668c2aeaf3e7b48de7a4e5a2511f050d7aa1eee0e77345870fdfbce129dd068f7f0632dac2c8b33dd991f83c7caf4c20fa9c7311c1c214886ae0c9f03e068db63ffe4e50cec32fa68f51207427fa783f7fadc41a3c16de6b1e41a5befcd716731b8e97b6c7684c7b737f2cb74b2ea6175a866feef33787de33bdf46c661508eb20cb05e2160f1f20df0ccbf3cbb913bdfe83359fa66fa8bb19f3f6f0d5a27c81109164af26a88de225b35d2229fadf4155ab731eda5dfccb20001e22633c0ad68b729ef7eaa563fb1fbea0c66bc1766843616ccacf70d80e799d9ed2eed1bbda92926f42c784617fadc08de820e8a4beae43c7fab1495b37bdc4e71ee580a064861e3dbf15797b5fe27bf5d075787502db3a8fe1d464aa2debe84dfaa2c73cdb22ab50cff73bc6a0672fa7a94f2fdeb044fc23f9bee59967e337a2bfe300ce8adaf8aca5913cb34d6e3d83e91ef14d5b86009de7a5466133b452e254be486b4572c16abab3988db3439a7bdbd464f416e2a7faff02f8f05aa85b37b7f9905f951d74c9671de9f854486cbbf6cfc9e48bd6a40d802e32e8acff5f34cb40de691b82dbad541da7877d1f592b16500307ddb9ec9af699d7866ee6763f331a6258ca3bf425658f649a8630793384599a65daf9d4f048a81ef85457938a0be4d40db777779b8835db80f9d3572eb044704ebfb55e204c6064d8816a7e9fe3333ff854288aab1486ec1ec83fe9ae2082481ef6523805ac35ed96968bee0a33156cfc5e460bc71cd27971ef1e0da272eff5038900fa5372fa9cbd369dda6f1b67dd12b4f42b3080af20d36c3a2297b07fdb2b3ae4e19418e01d264120ed1861fb73a8e5a0b9f900d3d9ab10706885ee28c45ba49a706a54a8f9ef02b60523b5da3cc6a7333d7d457fe523039d477b1a3fcfc51aa14aee7f318e7671536ea6e759d9c7eb9b2e95a1756b32bbc0970aa9e0823f6098dd060d0392babb6ab2e5cd3e88cd8e667ce22694ef26c7b043eece5487963b0c96c3a10ed615e3792aaa524e6b788287e7643ff9650a3c2e22a59686e4cbc3f6a5e777d7ae7513e91e1416bef03dc761e5ca50638292f46ca61c58bae2fe55be21ced227d2fec21f7182d9d600dac4eef9fa121dccd60cc0380b3c381116432b102db68c3be827a512002079bfac2191b0a3c665c32c0571f6cc1ac18b3573821277a7c8d1237e988cca785f75b0824d2965fd047681a7a208bb5431fe2ba4ee472473fd14204b0e41711335d2d8fe892d15e866a232aa39604db87a8a7f5382025bde48b3e39e4c57e1c53bf6367fe47ccc586499903aa7c307650912d65648724fdf255388bf6d72258a729c98a14b5e7f62573447b02cdce820b62f0e430663e8a79bef6b53b123ab59f49ec3a264767457f65353e56ef7cd06b6c0b01347d57f5796ba875ec849ac16d3d34d108dd62190ebee29555461cbd40f97e409a772ec57b087b9b989cacfe82798e76fd181a0288516abd267d66f76b80341d2f2de796c2ea2c07b0edae6efe56fe9a6551beab05f3c73ce98b99c82bf42de4b867028d629809ec1f671ef2f47dc09697c9ad351a02f50b1b59fec913b9e4c0a52be4c6e28c18e63d4c5773441a70be68ff09c924319b043556b4538f4ba05c8fea4d97ad654ebf3b55aadaa45de4d27c2ce1a1a419114f39a1de76ddf0e1cc35a2a72c72d67429eabe02adaa299478ea7b39e80867c2e92a4df1df63c0e8acace06829a68cdcbb8b9a3233f17708d40e2096121e40252f7e7b4619d8dcbf7cc336dcfd781b93698918a76a1ab93f84e99d630996d2254d84bf639b9e8500f746ece83192f8f4e33313de8b5c8c9ad53af5fd2098105cede337c6bff5dd81ec50386679099f74618088ee35e3a699ffe41a1a50ee289e13cd53204f29b16082d04b1d7352bd2f342f1f12c0741b28f65be3d4d8ae6a9f526154afca52331ee80b521f8258a56dc718d32fbcb22bd9318486c38e31c6e8a7c9d1dbba51ee15aa5c5b177150a6d85f4fc3947a37395ee8a5ae003ed415551686459493bd02d40252c69fd3fe0d0d73ef5e7d7e1d7875d25dd9091c9162bd80762dd51f103c660ce8e7df0ef06df358f99e19d24b35811861ef119f055c68ecba3f756e0cc6bf17f1f48ff5722853de9bfad275c434ba042a1f828d6713790e178ee9e411f4f8a090323efd150131b32d43dc1cef9fafeb21a7cd2a11568ef4a13d4cbdf0c4d24673e7dd66e627bb89b214dde9751deb2e999982b47d473520c1148d941ea035efe6bd7645228fb44c5ef80728ab7e532c46e0be68a76e9c5b64e76aa7c9144600b8406f876efc11a2371494f2d9e0b4c5957ffee1292a50e6d71ece512bfb47daf2e1fe035b981e44d6306861d5386ba8b989724014c1e50b295315d7c565d136d2fdf7250d806da84ef5b29689c5a74d0dd1ddd3afdbd14e95f2a1d63d13bc5bfd435b8c50549e1f00cd396f71a2e079ce5e350410ce628ffd18d03283bc48bd500096b642af646ae5529965e3f1c8b89f518f993fb68ac861cb9c2b5660c7faa208b31d54af36d586e58405b901c1fb8cf5e252529511fd43015e8a4da90c783fb2126cd4b7746d4c6645e6e075e87fcccc68c5fd616fd01e7bca5c24dcd348effa7a09be7fb29e8d452cb365a304febcad1bc9da6e7a9bc7b9616922e64e96f25759fc01ce73d8fb554200c98c4ac9cd19f6934b4ca4619316bce008b08574de407ae9988413136f1187ab613ab7aae34914e134bbca20dedc2c9eef6133a694e6b6f1c391796bbd16fbe4515e32cf6017293ea20b7bf693e5476af00a4d4c01da5bad35b22d30b7073668c2cfe5dc24edf041f8f803e51e2c1b8abdb0b6982f7ec179f6ca3196a8adf92ecb6898c6f52e968a6301acfbc457e0fcc9bfc4f87de4bd97b44ab8fcfaabea7f6c161da64213ea79db0467d2d8ec5d75b21687376a7cd1b7834231a05c23d8f04ab1885bf5f8019457c8793c9116b80e35fb1ee1435e2fa5e114378d8f1eaf6f6d61ecf80468cc0551b3f901e08814e265b8f840954b6336bbff7ea8cd3d1819fe8664a64449be007322139a5909d95344d429d9a60925f732db9894fe23458d449fbc4ed122f2063ce3b1d97d137baf1f25b91e179aa7aba20c1142f6d1cb88ad73a786e528d062fb94a3d82678470cccd87014db02bc2891b602c8ac2de4d89749b160ee33963ae6a4d75a5524ddfc27c2207556e70983a8a8be701e1817256bb887527a308d23f76cb0322f4cda4b6ac32c716e89ce261109977a37d9ddefdb74d271b37df9867adb3449eb34fdaf9beb1190cb9a5a322e72323201dccb485288e57a885ec9599f1ef521a82778b4ed253f7acf29c367ea9e01f4a03037bef98ab58ef0f466ce2b134850c366001427645c380eeec05e362dfc00e3f7deee2f09ee9f293687f316a112e75e0395c9baa2c7e2e819006926231faed024b46b972255259cdf00764f1e1534b16dc5383c2cf4b64032a337997ef697e6d0f2ee6c381a6c736f5465f3d70920674ac568dd5c38530ce28dedb2a8c2ae782e1bf9ee9da5e8d6adc65aee0b8ff3746fd9bfa6df3879fd4280d223c36162164c2bc3b2d81eaeb95477645b3163843fe2302e089e52b64507421e4699e630a33ee399c0d767bb640d6afb9e82978fad4239cdc3e7cdc38bb050065009d00e3233a9fadc7b2fa5420d460f6881753b4bae685f7aad065d472ac960f19fb87566c6157bb23a149e626f7ea6fe058c25e14839a9b0c27be10776fb2a2e59c4854def215b4220ac326a6f3ef2710985256678bef953d03f98934a2a9fa371269ab16ee11c3e9a54f420e0c3e5644f086e3eef2980d27b84108c2b3ec501bd0a60b1d0b97f37633de5e04c92dc9c9a4ba0fe5241d554353ddf68a833882c35dd06b2870ba9391a7d07dad88383ce8f7633737e05f2a967b305fd64ea68fc29189fefcfd7381f9a54178547f063795cfad0edaa0b9af56b0b243e560ae2693bc76c5d6b9a68ff2b3b6a3cb6969c6a4d4444109cdcf19844bc312441cbc7f5cb0d29cfda940eeb07f472f720ec0386bf9de71a0b08ac6dafe84647234457625cd540c042d62848293cc821cb100ff102d17aea20095cc398c4247948b68fad2ae188fae83e7920c1f35cf13f3108e14107e832a8e0231288763a491f8a819fc7bab439d8cf7407aca3d09a091600733a1dc1e02df8f31435b2eeb5a866b25aef9411da057e131458f35ea39239c5b00178570569e02d4f574108935eb9610d40ecbeb9bd30e0fdf2aee92a720217a0a709335372dff7a03356dc929ecfcae3f7f5b2109b728deedc4b3420607e6d83674a36c43eab72a6f11341c40c2b9220879d183dab094d008f6c7b9894a93728de1d34b89b543f4ac5ca1355d800f3ed7bbac4e9d9ee18fa1ded753cbc6ce24c87b1308aa452392aa84c0a74524f8b68c21a47546015e76c17f202e2af31d7e7ab3453208677ab5057950e0f74f540ffe0b972f46540b378608e2beed8491312316eae79c0a2a59dc89bcf781c4eebfa5f2ce4b1b822dec98686e2a25508808589e0ee8d7c659084de1955e3928adf420c88566734e0ffd952669cc5146aa2b76421289ffcf11cff45ba540f0c87badca82afbe0ccf7ed7fce1075b1befedaed62d61adca82296ee3b32fe9eeb6fb007ae038503e04fb8643782a833dc4d3971ece597a92afcbf1b418f4752ce666d63fbe0a604efb7099449eeb7a250c1009ce6187e8c84035afeae8963c3a313116cc4ba9352db06a8cc2fa7acbaea2a73bc114763baf056244ca781fe14cbeedc1f291e985d622f77bb15759c79b333336c1c5998a0f03fe14efa35f65c00a4397fe64f96cb638a612a7a1c6549400542d0b4574159203b1d823935d2ceec246bd3af0581209091e73bb579218a600a123a5691feb2bed28af61cc52ba89d8c0314aa3ec05982c8b2a6e4e15a504cd0d30f87dcd4f38528fce9086d79a77298243f4492fefe9ba06d036c46ace441058e592f61e4aa69e2f52add89acf1a7f7bd630e9ac4de47947eb044d8facd7866d1fa0728a24eaba4ff5203ec9808ec15f084e6c33fceec11d118f62003a5637395feeaec24e6d742ae6428562ce710c52ba9636cb2b93bccf08d71d6d8137e99303aeb1b2050ede858e6e7bebd04485235718fb6e73f292ba015182854f01b69db1b3ba90de0ab256de20b6ead21846ea16d907794555fde854c22a8f70fa72ee7acf1633e9a56ffdc903b00772f0487cbb5b4f5e738e72d06f7084bf0d4b2356f92d62a9a0dc7caa82cc675e882c02b75c24b185ab849c4a51d99bcf479cfce7cb11f6b064419d2162c6c43d5a3a13c6d87870716c3decf46dc49d70eddf667935edee0c1e754f260ba8add904ae300d3640b7286caf762a63866c3886d822ea34e7090f77d63ac5045c3b7c05bb3ccab552029cb908ba82ec8deac6e5f3361def768dad68d502920e20bcf2fde2d3e9caabbb2ca16f39c92ad3363b3b4aedc6103b2c0b667bae38ce33e58895c65ea7aabd4b2a39119e7cd1d90937395218c943f9408aca535b13e9bf2551825e2ad4db7aed66cefa844080c4b68c4f1405f930b0fe5bba346229a36958b3cda502195f977ef5f979492affd6164a03509df6780c58f23ec80c3ef7e3aeb0ebe162834cfd70a408d6f265dce456baa184ab771f580b42d2103595a027a36bbc15b9701debb8dd1656307972dcf95fcae8e3a5b600d81c7a2757c197980c537ef2fb465f8d26c35621bb571f8d77215a2bafec5bb5ae7e1f135da7735cb9af367e13ab9e619c9770bd0f5458c1db838f7f6356ddb44a995b4d4c851b3beaf39ed5d20ca74296b87c2c3ac467604a8597012ba08e049daa4e14f27c11f0b36069bb687cf6728333fe2b0e14754d4b922d995bb8df7e5aa2d8fa402be0da3cc445f1df1a012e28cbea950648c52126d5194019d960d7794b5efd17dec244a30f4cf92adec5a99d7c8d89cd8ec13f2f7a16f46640830379f0bf0d7b71c8072ac2416dbdd3f527361180cc45988875403b555e75eaa57134cec6a977ac0781d9491c1c2aa1cb8778eec25db92d355b25ae3ef39b7c4f49f7c642a4b681227ab8adb01168fc118d127be0ccfd9879adeac4cbad5fb4ff93c03b726ab78fb3decdb0e677464c12c66b9d7703cc1e9443c897a8147bdcff1a46c3af9e1ea8405b2606065304582e1bf4f4a4acbcbcf9209d2a47fc89c3105ba8781ebf81c0a6798b7eb71a4b6e6e1b2e36cd084045514cb9500a5fcd151214b0cdf64ecc676af344cefc903e5238023edb3e5137ee2f8830636c72d10e90b49354a91383c31274747c66d24b43cdbb2a328ee49a55bc4b677d65c53c81bf0b367589c6a1359c5f320d996cd4e9eed2e609de20a7ff74fa03313ec9e9cd746887a998f1bbf194427e176d73a421727b16bd21ddc56e046925d11e3c9063db694f568e3eec004767238afea04db3ce5ce9246fa3ff434f14235e5cbf0b8f88a505e58a43d9609c349e10b60c1d4a02d8792abe35397d9d81acb7abae60357d8ff5d58763467a26379e19eaf69de9fea985e9e9787b801706c4025bac0af6888e08e43f86b755b1ad5f8d39c5ababd248821d313a5d937916005fe40efac66901ebfe408507bc5f7f4a2664b2ef776011525eb9cc6dcba73064bade2a0e3b4f7349a671ff88d6d86f691bb600c63f2c8476602d50f29e551636b43f3050592d782cb14bb93736306764c0c754c9bf59dd47d17c7d502759e45e11599ef86f39c44d3f1e3a499ac247dc73a9ebcf23ea345bc47b897cccc89106827b5a7b0278545f7fb89b4e97cb7baec24c3800009761602e6729250cde047bce543e6930777b21488a93b2872c4064e554a3b52df51694664ac0ef18c765171fdc113d32b90a8316b905c2b655d07e058f8677d813a3bcda0aa4e249e359426f0678534bd6afdd3e24bb0de076444512cc5504ff76c27554001ac68bcdc47ec25db162ec4c839e194fe38f9b9cc3b5eb29e4e125d8928bc263edf035960094e0a036c60b3f5d3233b7935e8c031b0b1f2b41aa7ab6b70f888b0a95d2bccbae17d153adf09230995922b69d43befe9a60e8a405feb8a7f61b2914ff84d0e7c050f2eff9830a91b4017b3127265fbd5fea6809e9f315f6f95a0f1e0b8efc6625a345f7951defc92f0488d29e4fbee9d4575159b25a834f670ad1f957e8be9971d6d29eb7eeade16d390eac4222291f9583937d9cd926a356dd3f5a2f3fc5e4637e6abd35134cc259a4661bd165470fa6ace46b200210fde55dae5b5a53ff212175f5cf5332f167ab695aa3e2679a6ec2ba474b7a8137386f5201dc9b086905987692a3c7bc3e759d1994a656239805519b7af9715e210dfd7229c5ecd14486f87919473e32a8c10ae7e4f049c4824470ff7aac1aad7eb86d287724b71a6da761f0cd012e98fd3994184a401dd68a3ae47e968a69d7b455756e4241691c5a7ec8e26114504c6e80a1617961fedd25130527e8154db439ea113cc746173cd2bdf45c9455cd0cd8871dfe4e771d7493346e9a74e7d6476625a1ee7228eed160d8d88629ec4443a0b5fc017960a329e5237da8b35e62ffd55e28030f6716bd2a41f13b994ddccb9364c76287b258fa3ead2e8990e421900e598cf5cec4d0a4cc081d884a9937d75be12d1db466b26bc9f1cf13af369ebb8890bb03c0501c1bf137fd08ba6e7b8220eed85a790692881e20c1ec2a2fff6ace349a3b2c1b0cc0aeea15fbba49e9a0c1efe90c445de5618b63fbf99c808e5e00b9243b3822029bb0d8ba9750002e8aa539bd68942a1dbf5b7c0a17409014de3724c2127628d74c3e9dd016c031e0fe3abeb682224a12d378806a08f9b1e1bc038747ae51285119bc80eb6972db6bf8a55887e55ed7551b7f5abb82b8c2945218b5cabfcb6fb02b3a8e9150f151d72c8b8541eb9e8d49f85b82da51f4da9f407d82909700a6b005da982d0240029b4f6ad4f48399e412182672d33dc27f9c832eb98f9cff0900cc2f4811b7c48a9bfeadacbfa8414001756c8d349f9e75826da55c5f11c9312b82d445c0f8216185d9cf22589073190cd5881bd41c6ab989e5e03834e850c17a8e893180cc5c25acff1d8905b9f1d34f313c69e6edb1fd4bfa3c649e12ec71edc01c4d0abe91378c33e7301f24583e9228e229d5cf927bab492b811459060f5dc4922636b7f473e0cbeb92d825ea95b39f59d984121c0340c30ca7f90f0b3876a70c1d9272498b474ae87be7eedf8e673ab579ed0a908a942fb84840dec169d49cb28c23785ca5a9bb835b35edc1bc28ecd8e816ca0ed9ec6f4be6dace3020b469141013b1596ec8461c455a8f59048aae03b656b27e24b599d320253d643e34ae866a1445734ec5c1a728b5184094339ebd59ad260ec383ea727737c29a34e1bbf29b6d04926755f288ffd66365b0e98435a205b17bf756c69a09debffca2028ea1d3715e466d9b119a1cbeaaf5896ca516efed815d93f8e8369f33a4ad9c7c31f6c45fc424d76cc1dbdeabf7b3798cf5a249dd9fe3caef5354cbc406aca189cdf792ed0c369387680898938e330b1944c6c34b05eeacd79d2dc6e114785b3d64d49fbd1f640a5987322fd59a31a46329d9b811f56624f1968ca022fff7aab643be233678f118f36f4baa23512d40dfb00e3eeb913c0aeed6492eba896f4fb0f4e6ac1bfbc0277a7054d1864a6c88324640a2f684456fa3ff274066dc7da849f4ff9ce6c7c69218ecb826a9cdd4a5691a67d29a98479d544c461f9fb5e5acb48d3bdfb5b883a2a7da6b72f0937df0512880251ed4db34056d9d1369c37e115c3f1849ddf05dc9f2a54cf9b06f36b8aa1da8bfc34f47dba96e7c63a864f7bf8495742f35a9a6a108f6141c64c4c9ebd1004640f87ef26d13f8ac0089f966801fb1e0dae4b49ff3000ced53c79bd7dd6a69590346fc34236927951f9b26450daa69809c8b00869bec109426aaf2f4716780795949708be9cfbaed46c741d2c88e0b615b619234f311703cdcdbb23f95f7b955ff45ee365e36c48a775354323ff611d87623dedd1ab78f301a72263357bca18a7c3104e9d9be6ddfbd7c48179d14ee32c3ad6691b0688eb0a9d2f3373e59e5138dd57a79e9f8925fdc64c461ca2a4ad5edd6e87cea484a3f5a3ce0536464e0ed6452a0097387a700d8317bd510f3a54554eb4c27182f6156fcc6f09cb810966aca46f0da4c1e310618b851d05d9a2b2bf34cfa3b2a74764c5396085dd674b023115d8a9b949d1df6a374b70c576a43a7b791a890c67acf9db90778f369a5906eafcde67d484ed093a2f7b4bfece17acd8e0bb64279143293fb1b9e2049b8c02bcbeff9426555779da9e6143167a4a2c83a690032acfa11300ec1dda2740e68ae4313844f9a76bc53f080114945c458db9d13378397368159609b5e744be498bd537d54323ef0382360d56fda99ece615e1ff87987fb10ec41bdb7bd1864a58653b1fdef067b4356174d212f1d033ac3cf4eb5a74e7cc2daf77c2acb21cb34c610fb7c9437b1f2bd8275dc82c198a60379ea6afe009ca954b990387ccac16133fd5c0e23a25d3119eb807f99e9fd7a8b712e0a462a74bfc73977cf3a4f1355f8d96dc970490c0e56ac41eda00778397946031e1a66980278308be7b48c7cf6cbdaef5bc0cc56459609c6d75a60b50e52cc083e13502bdbb6c6eef13ffa4c2d4a56b4e75423b61ac8f178a28326923ffd11a00c85a41a6df4d487a3e0d26d1a2610f665e3476be4d1dcbb7d9ce46d442006b9750a6ed661188c1c07b67c0959cedefb72f7650b84108d061313957800769d9d99ae97b034536557fd6ae62fc85c608ed04b7439a97752a84a9e5ad5b8f30dda74a284e448fb992519256590a0cc0f558b4e63b9eb1b104b0676355045c585fe2067d06675cda0ff6efe641bbbb766e50e305f09ed69fba697316af5b0644be2fdebed00bcca0cf371a947237bb1f86ef1b9f476a6e82636bade195ebe41c4e5ffb15a0f8f3a03555c3e9751ae5b055e553657887d1272a694ece55f82491434222cf90951fd7a4dae2fae8b341fecec2174b4939c4f9ac287ab316f69311d610425fc5c269c9520d10d2554a0cac19ef422f259b3822620bb9075df3ef1cac0fdc1cf6e57e09e46bc7349cfe03740ee821c064a4ab7bed13af063a6d7625e960324792c15a1aff5d7bbb87f37d5f1a705b5d7388424ffb1becdf9e90de3d356d9ea8452f3f02437061c564115d11bd40873ced52131fc98909b5c3b984be097a0a64c579352bd3385b024ed484036a3cebaa53dca263c147cac5e90a2d8accc8ec62419e109bfa0d9aad1044ca1d991110957614ffd82b2dbf5ec1a2100d489a201a5c2fa6f3de8e273456692ebc9b3ad8c9416279881bd36a0659c0d50e39b8a1495dc8c069371c32c5049ca0f5412e04cbe34b67219886a4168bc7d8d947d39b7f0613f93a7b3efb85e784c3a69cec600f03ac0cddf0e565730b9e83ca15464c33cfdacabeae472f02aefff4ac1bce3451c9ec121af118e0203a81f27847417994e0310665456c34e3248afba74b8f4fc4df22ebbc942b3352d6c27ba85895ae21cce5d8200572ceb8f7b4e7a56d82ffbdc7af0abce99c5eac6704d692122c2ec3f85f73ae72bbf8a1c55cc094da2a0cff0df7f150e117f0e269606049e634cd35c596d61e40156d3b53cf6b7427535fd39108ad90f679f2d091433cf3981da752776352c6890075195752883fb02c5de8d9e140e1c73072d135effcd4633516b58da5c6ff385158f4596f5814c9517182170a0b4e50e1adf5b216552895cf795fce0781b598fbcfec9f7fa417c4f1b0714cdf62303c156b2a96dc65b80cd237ed54e96e8b2582a6e641bb81b4cfff9fba5e3c89e46cf5e976bd306e8ab907119259b5d2a32e2d6384333248e73900c3fad2fa317f426459dc9b229076388b6d0930454b2c6054391420939158f57b89c28235ef5d32528c317ab4e5641b2ca77231bf4adde65b6c5310727b04717d659c1a7744883f1dc8da38a10822a56de3a58b300aa814271e727cf65f5c27c11ba7b0c16be1f689515d67bdc7e3f0c7b2aab5c5b1f2bd036d69c850cd73fc39bfeaf32e40fcbe318576a0c30257c471b8677218c5c70197c41cd1e4f1aaae92a0b679d074ccb658303758b4b9ce206f5da553383a331da767644032c4fbd02042bf4e5eb56493ec75e30a92dd0fb9a2e757d3fc0bd383067c76df0b0e47d988824f0c7cb0ab08073eb8fa9081dc63eec1d5f64e498e7427adb8735d4ee1998d1baf31445d1927acff39228613dd9190973a1d98903df300594e52b241bdc3007b9c13780c7631dc5068ed0a468685dc18c67e2d00048df7e4738e40245f103f53a18bfc67c5852f39ac771c9a74eaf1cb019f78adeb2465c2b486310bbc26a13ff77cbf90c7ba457b75a62096d839f4ac63a0ab4cc1988e2ee314e11101552d62ea3ea6abdcc72f5808b59d31b56b3fe0dc8b643e766b99ed63da2847f720272b4ccb120452c047fc09d6cb477388958479d0c65cbbc7fbbb58178e705a19f308efeaf9ee779a33a9fcc3e2843d9456c97d91cd8007ed9836834e2eea8f19f33ded82eee5957c838df68e674c709684d72f939d08b3950b6f9433947761c8121bfee7ccc2dddd98ab54b7884bcaa557896600beb2633f7f67c62e98e7de595bd446c7c32538283b6107ed68d0d305e373d303d5f31e0f621a067fa86411559525257e25ebec9da57f2d9a648ead21f5537197de33dec3439823dde7b129c703be1bed81fc91306e20df9722e33a30c5c570f5cea95267ba06b50e57f91e59f12571f3451ca3026606970390fb94a3e7cdec7b4d1524470adaab84bd710676c6f6c724ef519a3985e7f3f49c6b47cd24fb8877b3a8ace595af95af582611afddfc627c7639be8d6755212a3f5d8041f47194f892bdac2f5bc04c5a2950c872e75b6d45ff944474a5e3acf0c3dd7c48af6fea43916aa6c3e6147cf60bfd57cc9b1984d13ddd5f7e892db4ec2a4ea6b49d51422b65c03550a9fbdea32f401f0d7db939d4a2ae79b717f445d5c97165587d46d96690d6ab3d1f845a93a238f4b06e86a4b2a46ca750158a8c26284f509c65c4a23e0369dc33749204eaa202641decb5afd2c87addda3d4e747897bf9f4d4e39352f4b9d95ff6b4816549b8cd3b1248ab6598d3fb864ef8f6d500e8ab43570072f2af744377e4207658926509b7645c1e33daed2456cf761dd6a9baf517926b2657e39a3145e107470d302968cc228f834e2449385475d48d99eabbd0d828028111b0a7f62f4ac486f35f8e90e6c7df697efc6e6eb25e1addcf7365fee8d68ba3e5edc07ac7e0c4e76bf86481db812ab28cb218dd7dad4d1ec7ac1c04314f98cf73e39ada9f731f5b1f4d5ee26da25132f3f2349bd9a409e6f2cec95872c43ba8b183df980e28a3a28d63548514778b0e315ae5b423aa3c82b4af4023ad01c197d853a81b867c7d08b0088cba5dc1c466f6069e740603523e7bc62ad2152d0d0f298691206e5a469549e6ff7ae092c884eb56fe33ea71ec754f625a6f62fb5ef0f1c800123f0111e6bc9e91bc1281d5853d2312aa7bc620dc6c1bdb9a16853a02bc60f2efd91ad14a9746bac814f91a203363329767ad4415265535b8d4a22f640889b817d3d9ac7df9d052ee46abed73b5417845c21d501efe39d30221b725f6f1ed6f1dcc5ff70be68489fc55d031f8a74909be920e3c964ed2aed90b91b282446eb3353cda9d6a7d8e07da30d95a0cfb60e728f33f8fbb6cc53935e3a8e63019d12001e67bf02962397cfc0c9826ca23ccf3982b6f29e0226c731e5cf481af17391e81c41e7f7bfb7a9dd4e1d8cade7cc99e42dc53d6ee410dd82ec2e86da99ec9575e60952f64f9773350c09565eca8a53b9a15f6939cab184c40652fab597e5ab058b2394c5c4060ac231a32f224f71560bca302d1965e4ad8ce1a01fae8d276ad72dd045112b6f3351769b29081f5c07590edf1ad507939c47e1022b3fe09b7fdf6d7a5b6d4d9fef64687fe92901433e51fe01ff98aff73f87f2970132d8050d7e0260af1c8a708efea8e4886362ae8082cc15894184","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
