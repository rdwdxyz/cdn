<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e2a7fd1c667d15aa72a42b370184d25ec0405c1440e983810eb21648e9a352ea5d24b4e5e85e1769fd2c286bb2f526a08bccf73eeebe9575254d4a343711ad2e37760d801bfa91ec0a77a3f44fb32b36d556f14873387da6ee09c342edec6b5b5ab90238d5840a269ada701cde87f639b3d33de25386152ea7cf0fc2bee1449bf0ff7fd0e497d6e9e574cf7619f9808e25cf24f2ba6a26093952e8d5aad6d6a8e71d41ed0085a13ee8488a42ee061d51ce2fe6ba8a3f30d1ea73ba9ce587233b59fbde0cf767feecdb08afd0a0420bb4c9a22f8e81f13530951a97d8ca3628b0dcfe3d2efded054a8824efdf92ec5596be88463ca0d9dff10d4c567eddaf92974fecf822cfe0f6d97cbc5192e263eae3caa7c4f3017ddf7b9da87b2f17b76e2f179d4671565251937e79114027407d0f8209152c13b3c71ca29631fac79df50d6963b2678cd2422efc7904642b97c101dab4ea7824926b9d7601622aeb142b4446d4d0f8e9435a2e1ebca3b30e4491e107d0f6915af816016ac854b585513b54cb9b40e953f8374f639384f1a7fcfb5172d8847623395f33f539ca88d3e98603b47dce14e9f9e85b3bba30139028252e24f5728ab4b46b6841955d5883953ac60319ae1cc212d168c31eb2100e05e5734af12501cd75b0eba574e2d59da2c02cfc31ab016d69be8c2cf62caad2d99d91158162dd9f908d899d200df20f203d69fa81e25c973e9566cf0e2f8d73cf979484ed634f90b4f543f67e6f23d3c59cffe2fa06f442eebf51aaf6adf8386d124afdafbe8ee3843af7dff7dacc4e827eaff5700e0ae326f1722548132acc554766192707b6792f1d22704d83abd4728a3bef7446fa7ed0dbed1629b424601d0dd2d7ad4aebe80956cf54b1f4262e26b75abe47c52cb06b1e1b0fd699516fc0b6bec95899b865e49f58b1bd8d4d8965117806fcad07e90fae6ea0c1db3d06cef02a7d3fc39c0246da5e6edaa76542ffd489d35d6b558ed1d4e509717cada9d292136102922bc214e1f550ba7a317903759a6bd425784a5a4a3e30ee927ef4ffca782cd3dae18ae7409996a73667866887c1a3460b84924d4f4307c549eec4deba7157b8542ae0e7df55a4bbc6907891e482616f219c68168850bf33ee637ce20a1d4af7811fa90a5b07c57ef8975b1accf6e48690bcaeaa5fec110ac3fd4d5fa5cbf33581649e6a2999089e7597b5bb9c4ffdd2f55ee1fc1c5e8f92d55e453ab958be347c31c1759feb6ff298de77c65c194a64b4c801d6247c7f8e6950618dbc9969919a950f4df61e567d25ae2aaa111b99025b8b367d3325feead9200b11daf285966b0e7a55cb382dba87d9c090ec34f54126bbd800b6d86b5965c0e47396539fdf6a3b442ad35d26e972ee463cdcc18044c66a444e39f035b410e3c15d3ec05a4759ee5f8ecc217ac238a6eff9c706122377da8671cb032b87c34529faea6aff70578ded1c66a80a79ddcd8157c7117d35b28c11013362aa7d8ee7ee7b5b8383bbdef79479284e7b525250a72ad4700df14cb68d874f3b79d288f63913d434faace33f5249252dda0333942237b1a1ba81c9844aecc3ba0b4ea866b7cba5c7e710e5134bf0dcb1c3b6d7e3a7422f0a87d8ea12ab552f9969063a663ed51a55a9c85be56db9ac5633dd799f4ef6651c37ea98227e2404e94216597f83c209955d27d514376a058d9c71357f866fbd16867ed88dbbbab85215cc8ea1a4c5d99566210e72a55dfb77d5a7ccd6c1316ad98671761577f763f487a5632ae665e4bff7ada5fe8fb6f260452c39dfa9b83995f6e52fd0163228672ea1a0f3430e3b1aa68f3eb9192f3f76a3244060d25c92425b21cd6f93c72d3c2e4170d18f08abd55551eae70a907daad29478a7f7875765bcd5560d0cb392169c52a0e718ed186db284f310b9e1ea25741bd2ad8555941729ecc85d66c9a7978870315587388287da2179e4461951dff4e90063aa734c09b3242ab5a1d1db623b5b3b192c2d35e8e73f93a80b8bbe98b368a41757dc0c96c9fdf61a96214bd0e29ca8084bbbb553df48aadb8909a3e977cfa001ee8a078621885a7dead8882163b833f600c47f8729ba08ff9e1f0b0043079db4614dc68790b2c71250db06039c2ed357fb2d74fed83a04195b94200265eadc9375c1de51e0059677f5687dfe180d32064ad54c15ceecadb537e8f5414f7a954034db2ec218521678c3b83f1be9f813a0eaf6feec38e023e39ace152df9305aeec613ff6ebbf4c296902d78f9d730e04164a23e1a17a818d54fa17fd6622e9c10924b4ebd3e17f89f102faebf05c0ef615aad2b2f39c6aadd59db6fe8e64c0f81b2d60cd809ec9080f29cbcb2b73a807d58448ae691593580a616ed5118d8aca40bf7dd468dda4af5f599a5ca7755b0dd65abcde58f8e491250c045597cecdd6f06de8be1104584de3bbb3ad378d4a2c5d6b4ab7e67dc6c4091765548e97b70a886a0d565f90c5369c885469413856b74de963dbd445351a4d62995449a11e7c2c0eb72d5cbff798798cc7757e1eabd9198392735eb28764112cd96b962ded9070ca12f1f08c930397562bd999b74ac7ea3c39683c0cbe2b457dddc59bd66e7d7d3b87d7aef9e439f1946b9e9b3925ac24b19710b18f98d7baaaccfc1e6c477b720ab2752bcac40af2a9497b55960529d0ba7367824ba69f7fa66f9c4dd644cccea1b01ada40a0683aff00706a94f2118749fc174f3864919922756ff2cf4b62948bdd2321342707fe4420777eb020207ec420855187d115c2df58ad65fc9ce82567afc0c70a8f64546296ba02d748a84093bd701a69353b4070e5216294854f3a3aab63b9feb405fc9798425824543a83b966c625e0d9631e94fa1caf04e3e3806ee01c9bc730e4148360cce22e3aebb90179c67ad190b711406d76e30a986ddaa7bbc121049c4592ab90fc5e42cd39f1cfb989a629f37d77017626fefad62071fdf4452ac0236f19b5afa1cecf6abfe50ede595c713dea7274a36f3d55107beea6487e3133bfda07a27b6fb96606d88ce904d6e5c19c972b481d295b100d3c4e6e8da0da0bd19feee5b4ceac7b61eeffebcb38fdd68fa644107fa4595c9c690078ff05d50f9c4bdd62ba9cbdbf9b4137aae45b0fd620176ee9e8c1f541acafa6a2bee1e00170e986dbdc1923f9efb43a1dd1c681b02ce6a381d044fc2656f2a4ec2680b1ab606bcb318bd518b40e5d1bc3d1f358ecf548ebf65b0cf0f35d75a77d5f20aaeb6279f6aff7ccee0cc13937db3f38348e9a3edc823d8aea3ccda663c6a5ff44ec13db4ccdcb10c03783e07805afc3399781f7c1917ddd225ca0ee62c13a952d3d3b34172120f4e5397fa4f0a30f87ffdd19b6af63007dcddc6e9de428c04e888b7c4a6c963e2b10626f3bad48199bacfd98735b19a39f66e3db8278f35bdcda87676b0d6870b4373c1086de23f187b93417c12a43fa9ac0b63b2bafa68661bdaa90164fc19ac06b5f8454cf08665253975d3e1d25204bf61f5c8981a30b8e76ee281243b76f4670bb1ff4ac44be2448c969bd9e078b8b63694d6339526eaa9356fb9475762d2139f57b75bc1321bacddab7b4edcef73d7340e0bf26dede5c9baf2733f308f879eaee83f34427e6e2413495854fa927eea4e6027f4d6721e0e88dabc00efea39f21587e0cb6fe233c667b36aa72683b0d6f9d0758ac387282c893deb5481b62b7d14085d00bf132c1fc7e05e433331b4f6a8df12bc9d3bd5fa293afc9d2c5502e973ef0bd7c2b21ee374a8e8f56b6de2e81099c5ba309ac19fdab11c34d154834861c406aa8477544b22791e065ff76abdc6653c88cb44d54a2f8116dbc15f5563fab03ab682ce53d4d7d4b62fe2b195070c7e443f5cee94289093ce2bdb5ec9e86cc31b1576db4b4d9d2cfc7e7233cc7d97c7cd558a9f7762469b36a9ae16a1384ee0e7e22263a2b2f6f29044e60be58b8a92548ef810c1fe559d72c49ef68e7e15c52c065a2dcc17963a7d8fa0988ed006910028c8288321d40f5c69d2386d020ba38a225a20e100624cf7107a07e1a5448ebfec9ade77fa9baf5890e95d366b0cd1fd4dc897b9d28cbd048834d14d2a21e7eea728a12b1997a739f46f2f8533ab0103f85d71f7933f3bb15d786afe867d3d1ed6f98faec1543d1dabd70f804723c33c895c6a8a7b66ac415cd262f1d34b08728e796ca1dc56c25a9fc7a91a534d412a4c1f7b8741cf17330a36a0a9c4935d2e63b899a764ba659568b6601783cdabefd27ebc88cbbaa8d85a426fe2a44ef5076777ad2d195b51b4880230d394b2a00e76b6c29ccffb820f1d2e37449ad2fe18afc58240ade0ab511ee7cd0ec690fb4ee0ec8306d426ae1ee101406ebed73788909d55d9ca5db97181abd5d4bb998809d971789918f2ffa40b91392380f84849060f3ef21ec23abdba2d4aba0a1fdb2b15e512747a9ab1bb1ee274c6aeb76db371cc7369944cd0d9004e9d5ee6ac4abb1a1da32ead37592c36991bc333fd49a451281e1a125b77b21c6f6762d551a833efe03b4d3f409335260f865472b8c1596be27967f1d184962073529e130b28d100dc0fc71a8105265f34bb8fc5eb583716620513d9fee7823210a56b46c046c2983d8acdf7e249b3868e870390e93d4beccbd1e7f9f114a97932177a07cac7512d76a5db6acd4acc9d39e92bf544a484f5fbd2a1b3fa689aa39d0fd4961dc6fbd4442301ddefe2f6e421cd77fa16f7e144d31d1dea2d952d6ecae07957245ea365cae35abb97e3155bae3734f21d32826940aae02a44ff2c78c12ff93a8ec17f392113c7828651b1dc19818839dfd4231067f3e5d512c2ea70651097a160aefcf0f555237b3a0a0a048c55b0c99aed1b64434896ee3ba108682642962aca40d01883d0352a944638d7cdf93d6ab38cfae5cd0a0a168a4a569ac13b7b79f999c78191ae894b5a269e46bf4136c3fc589978807b0bcb894d5fb1a0802666a4e426defbfaf6153df6744080347f73155b3286f86e86d488b93e8935d2196d93233ebb06db4b894958ae2ce52cb8f8f9a1699c7c4da690b0d42e85e806cc58e06e8baced15268a788bf2a2c41c704bc32929d5b59a5ea0eb72d3b21754d6c608e983fd01932650ea5e2e51155ced73937f849e66a820aeaf99c2b446ecc28d1e26b91390743ce58169f67beae0dd3acfeb7131b740d5c4b0b334ad697c015112b3a16c475e7aee2cda692b9fa56cac1315f35533d98f342e2f8d8da9c773e92f4a48afacd6e377360f0eec92e49420e53254233a3166815683eb2d89f7bc1a38855975bbb54107271c1a46983d6c3c5eae7d7402531d5952ab5b8792ab96af59b0800d0aed4f60287df126d503e916d51fcdffa35d34063c0b1c43e56c10522ec2529261d0a3f096d17e1872aae77df222bc0bb510b2a97fe0cefbd69685362b365b0134e628ec57958ee9584121a826672d3626c7a4916f42ec56086e3dd4ae9a7dff66535b9432bd6a1dd35bf91ea25fe9c4755540a0102c5d084759ba6d871a67216fb4ebecd57fb298cb66af84331242af2436e50ad40c7a70a1a8ebe06f21453b4c42cf4826adfbe68618297b11e1848e9b9767f906512127cc0e16e0bf07f1178641992f4f81fc3f81cd46e9a0de2778f0142930af2d51732b86381a1f314afede6a9b4f4ac266282a6540d631b36929e99cabcd038a049ce139d54a2e16da263b68efea9cea96f20c1fdc14cdf712d20fefdfc703075c465ae278ada555452221c4f49e2e04501e57afe5b1022b060e18081b68daa90a3f09debb9cdfa9a75a22aab581cee839c68e1031090e836fef11b81619fbfc37a0754cd10d5040cb5f47585d11ae598bc2009e768437a2f1a4de41fb6fbfc7a09dfd08669c3e2ab2e3c146db98aab0b4108f4e46e02abdab0525a8be5d67b207ff3eda98a3b0666f4655aa9084e56bbab22467c97050278675ec2b26e6c2b90c56e70e36330c0ba1bab0054e59f571cf80b73e008fad2bcfd73402608e38b008f39fb6ee59bcc5b8d1b278a7f9bee42b30ebbbcf9a200f8f9b49965ab42179c140f76502a253791476ebcd4f3d35fd01bb74e2e1b49fdc6afacd0e414e94a837effd27b7cbbc8e28d5411e7e7d858e8f32a37d57d83abf923551b26062ff6232b5b7c1c91e926a1c5b0c276594961c68c712d0ff6098bba4b7bcc80f126b929382bcb119c6dbc4b18219cdd4d6deef322edff97d1a44698c1a7f25ad07b338500ba1ff5b0fab1b79e774cc5ad657fd373d41f0d64d94240989fbdeccdbae82d5c8d4542b7fe424221420370733c8b183f141b1df2dbacac890e1ddf310aa08f1c7b11fc05325a84449c5e2aefac17482344659892bafb63a2bb3ef30524d74d1a0b5586ef6f0402efe0b76493c2c57b89efcd7ed3fac06e648e16590ae686d5a61574b0d008e09a35b9c1f566b7dce0feba99d5dedf250b13a84c7ebfee0453e157ec3e4b3f822c7410f20152baceb6325ef0506ee6721bc4f4206cce971d64c73de2829133d1550d2084a5c7b5c873d77cf9118f8ba602c985033e45ea971e39a994de5f6b240e8bb7d3e2dd58d504b5c632afbd252f4e319c3ad82a559dea0d71966034f35ebb65fae31f3722dc67c54ff68329ad885b5854b8b2656a862b6d669e2e329b77077543e765a8fc90f2e355bf0be5628c7d9206a1f53768329240bbd23ca83498aec5388086ea7aba4d5c0db271ec1df31d396cae87a93bad584d5a10b84a2bf218cf143f82d587b63d98f7355ddaf3376ed337b975ffed0036758088ca5116eff3fba2724cff926292afa3191031d15b167d40c28bd9b2bff1eabfed8690255c81fe6cd5e0649d26fd05b7d4019f301ede11ea5ab40decd8e92caae06b3ba2f7471663a9cc2b065d48070520a68a7047440f28558db4ef357fb5f7be516685253bbc999752c5f3437cac573197870f129bba110c1ec4ed74982c026ee3eb4a55bfa13dc8379d9af35bc1162e6ec3b34c96790a92a2e321f02c44aad68ab41f48ae175588352e23ba356a456a6a0e57fb3df604c7630f9c36d86725a17ccc3ae1f8eb42afa187eb179bcf36ec31cd42d5a2e215b801c3735eb34a017c6b6135550b5efc7b4e993a34e3dde05ae218a8a5f45cd4665445d20b82a8bc1dc57cbd15bc74b0168cfafb42b77534ad0bd965249c33d4f26154c3fc0fb2dacda2ef086eca9f42d55e2aa3ff80685104d2fbc5276078a5bc98866f683f679f988a7c376bbd6e895744dc687f3c7edd45e81f77f5c8fa1ec98c65b90024347b196b2ab59dac13dcf4940b3e2bfd25d54cda876e7714a6e475eae19ad74416ccd8be6876001921a5fd79e45395cbcd3333eddebaed941a0c0968088b0ec0e5c3057359e10364545c4fd7c7555d98cff1ba5d23e4512649381db7c53e450b3afe6a07cbba7893edb418bdcdd7432d1c9ce156ca39e8f5d86e13a579ec3776c45e9576a10f52bd63e34390c285b60b63b1f6194beb8de559ed8609e7fdd59ab0f0db29bb9aa8d7ffdc8c3da4e7bec49780bb7e32662d42e54209ed52c8dfa8fd8a9efd87ac48110e9668aaff3e691bbeb55952dc8f9db1c8a30c62cbe7098becf072b45ee851fe17ef37d0349fc4f9fa5c807add5046e854813283db3a51cacdbd1e84dc789cd22b587f2bbd817f1b634ac2e3d65ce92267e721e53aedde996a28b23e63810415335e3ee6a19ca5cc339da38b9b1457c6b8a20d7a08b0aef4a774854d3a629801ca01b6545f399c73d5f964b9a3e6fb582c72562c0977f291c09e7d56acd6aade0ac84a48f623023eba00e3402de1cd5117c73e5eed3df33ce67464be6f03f4cc325541139183ad6635d2186f98c842c441fb18453585954085d54edceb60dc207498454573f5cf916ffef19a22b2be8b947d62acea33ac07ccb57ac6692bfff89aee7651df0ba02407115f14452f5822383448f2082c40de6dd8bd706de3a918dcca2be53c5a5689c3bc4172a49bb59d8d3714123d019eec79deb079d47ac4c71136e95c9da0112cc64d0f59893383a7cab1ee8dd9d526baf540a0f204595a20cd36ea948faf8bed6f247e5c07385788fba2e8f89c8e0bac6685e16193b7d0b857b3dade9366ada5ec850fabf52431db4891f2f41f4b37e83fe2fe28819e00165a6df82450dbcf205741fd84f55d625d11660284b5b29c7d87d43c67292970042581f9ec0bcfd3878bcac1178f4a8d68e34ba02696114e8b1e5631fa4953270a5bb386d39e97ad6543f02bb904998dc5cfb6d8af6dde78812bb82605e15bc63fd9a96768876a24f13332a285d356cd41191d4f975ae9ff4b3be92aac68fe2c671caef2c4f8c8c0fd54d3be60d63563d95e2f2625701da91142861eff4ca7fa7f73c6a6df1ca20614c2db3dfba3b57d19f88259fbee48d2e9f58f6df1db65039e660bd464bbe2e04c5a4d506d6a5eccb79f1bc2fcb67fa7b6c9eadfffd1e072814b36b4164e7cecba3a10edda5e3bb01162bf041deda82826b9ae3da84e5a030f86dd03cc1664969a0dae2be95423751be16f0c240a2a0e8c103b1cc3750d0002604c25bd3f67727732026b5c448cebd9c0e1ad011212a4925a77a86499ce76acec551c2950c048dda021f98ee1c24e0ee8d673eb141c647f39199265b9eca3aa88aed5d67fefb4d56dfaf765c2b8ad4eae9f6b5bc8567548314c821e079b4b270a0b2adbe739f4d16637241845a9840e5f6912d999dcb8d39acb19759be1cae40248ae2c0c240ae1d7a55e7a9839dbf0d63360f26365f0c5783290edd90b2a9d56eed02e8c1a166608eeb2e9b7a46187a46d5019a3adf0d42b78a16862ba4136ccc35afe3aacff6137d7b9513aa0a24ac69f2f6c38bd8e864458571f9a4b3c6716f93736ef2f0fe0b96dc1ccc45f87976d32c27991fc378982776e66331fb1c53bb3a0c5587058f3cd2d877a56f9dd90f356f2995bcc5316ea52a3a3542db87c36d7f18f30d680f5919207434021dcc239f7e0a3e605a5b5bbdb6a5ffee941fe2c56b382432dc17a9ed22b6c4adf848e16b14b1fd1c958a596feaf5aedd5c0e51147c2aa61cbdae5b5ce099ae6b0422d9e9b041c7a525119c122b3c03003f1e2276a820fa979ae12f16217dcddf51bec932673b145d5b0b2e3066d5532a4b853d89b052abceef47e444ddfc139f0e9c9ea1130b99a2d6490f6ba67d065f23fc2ee29df13dffb6d1bb62b3c938a4b36941cf3f4cc08b6079875788ae0a885a1e167481aca0bf71c4fcb2ff2c6d28a14554315f11c991a7c006fa6e699d937aa9f512fc0e8cbfffeef383a8aa0c12f5cb9812555ca867d9744424ef0e24981e525056cfcc53058d2c1332c142da9d58f9925f21aed7cfd3bf1dc938d8b08503a63eb4539b9fb4cda080c5f4569b0b859dde376c0d0100abf26f77be2c865157ba49cce6ec3e4d8da6b18bae2e9ca8c70b5a5a8d8fd55c81abd994cea26e5a45a024cea7e0154a4b709b06052bd32f732d44ee4ebe9b78c77cb2b614295714f08d7925d1f8ba0e1a73eaa0f751c3ae380f20829b94ef4561f5c3cdde7f2ed7013f726bbb4777f02937b0d80d3930f9761f151fc845fed0986cdcef24e9b336dfa9d949c1d7695179cfd3e58e85572f61e31ee131e2c8caf8602b22d7b23e4028263ab6d8e34029da0311eb4949d99a91aa849e9e658ed525411c9e95482137bc36aade8c858fb37f6e6a3cd18506356a94cf87ad32cb450d7d47106795698189ce9be0608f37ac2d3b59276a18b2c9afe28f9369c9529b8651e96ca59448b45134c37caafcae919bdfca4424d562578f4463cafe9b8278902ad2a6770da59230748ff48a41783e548a3beeceb2ba2406168b4ecc2ea596e62e6ea59e3aa8910950433931e906d79156ca212d028dfe1a2eb8ef5ea4571736fd820f932dd8bbbd8062a44eadc787317e4b7a9cd95c4e9015ca86e328b6a105fb0687dc6eb1a328b7c934f5da2540bc39b6578772d5e15e7b95d893f71f8439f91862f1775651c646e52d4d174f443ad87d8188a1ebc7b4f534b23b98bba44ba017f193ebcbecfad5d477ad9f70c81f762a8ce4c6d1bc07176fde111d3ace1f79670c45e65c280249e3c29ee5813be85caa3e4fdccb893074a2d241a5ce67b3b8f614b4ddfa9363f3f706232da966b2009da8379a4899c8e1eea2259733eb7b1edd71af558e5561378ddd6130f14178b2fc95322201c380c3774bb4daf3c7a5ddd433c63ade12404bad616d2c9e52aa6c645f6fe11ef77d21f664dfaca36ed990cc1fc930aa83eb4126591f99ac31ac63c5773982a1096b60de5dd75a7931edd2075f54b22fc37996d00d9533ca1f51ac0492af14442123fd7702e7e988cda2e1862cde1454008c66dcfd08eef3713a6846947159b6053377a658add008516b5da7236392ccb54a53ec06f45248f6f515aa2420e3c12b91dbcfd37f18f890853e858dac319d5bdbe3752222899a1b07dc43da3dd7fb220554fabe00971c9a7e52c6baa7e113807f3e533a8d399d008d232cf9eba9236924f12fd63bc085cc16dea1ed7d26377ef455624adcc779220b366eaa704201ebc37846550ea0689a7d9eee7fb906d49e044ce6e6819fed60e20f8680e39ef5be7d50ef22a98a2251aa5b40c8ead5ea27f67b106fe1cf056bbd32f6ca34678817a91db865d8b70b150c6d78ab9170b21c5df9aef7f35504a2eeb5b4db3a110c82a864456466a30ab26d14f1d0e159b9c4f07aaa9f34b6182ec45559a37eba7ad81d04cd1c9d44e53dda7fcd12594666a833dc679de291b71d6b18b0ecfa1954215a31a86ddbc764665b593c32da4b5f012e477bc29334d8e8683cde91ee95d23ea8c24f4fec4b2fe8e21c6272291061a58145c330cca5ab80579fc3c0949292792187e18505f37029431c4c641d41136eda0fd533d2dc6193fa90cc5d74cf4b7441c475d96801081259e2228d37da65c477bbc3ea2bbc0f157708139a712eba6240706ded435792927e9a9de749ddc739180ccd04a782731c2a6e1a207c07a7f32f9e8919769864ef06723f8b1d099df14f6c51965d5fb738fa468b04b4ced0cef6904da64f80355e3e28aa3bdbb7d8ed865dac54f6b65b90b511e0167d6ae59f0b445d261f04a5d087b3bfc60d7bbf455288f43713fa6bd8a66195c5380e43d11cb7518b3c8c316e006de76373de0f9c9a5499370260937f1aefb580890217e7032a403421922bbcb7c8d654fa62acdb9ba88940ddbb13f86e48f11101eeb4544134f3bccbbfcb31a041b78c209c30550fd81d38b91cb6843a189865a2baec937c6f800b2199446ba4c0401cd166a1ce887208c213f58aeab847283463764d87ae7155f7ef8f2a68b20322b3f107a6d78692594b8e85f13b47b7acd100712efbe36f45c4d03e383411555e50ab8c4bb7de8ad4f4a49b2545ba0f728cd15ff92111c1b27e858d337168f14d18f2672130581e0fcc97c82093ce9b5b57a8cdf08c9e58145d4f430ffe984b2652111792a7b82cc94535ae3c2133e6b759ed41bc750d67d63738d488cf07b0055ac5d92d6f333e3a0a37cb7237de99c087afc7859a20b5726335b4f3236b91c44ad9e6a6bbe81f1000db0ecf0fdccc9099ed0765d66fa7ad091e5910a0546290eefc20f02e3a7d1d575a0ff47722116595b477cb30dfde951b1dfdd3a8bfc0c80746b0d43e82de760ccba635266f85d2e4e7406fd0097a36cd78d0e7ad0932a91a1a393485dde9cf02ca24b41fc1401687ef023d0b755e89aa8566f327436eafeab2c30ab1e449943bbcea20f142e5bfd00a6a7ca305fe7100730ccacff945f3c81d1e7ed86739efba0f73cb7e9172a7120c6f486a869d6357ddfab3bb6dd9041c22c201ac07df7d9778d11a66fd36a49dc2e506a1f654a7f69d652db727afbed124de791468f0b58ae25e3f337aa95f0157db3b2e6a50cd695f6e572cdee3521e31412f52f29d3feb57d4b1917f03ee2684b5a085be8ca242fe0f0a4fd33e5ac7218b97b00f2ed94c57f9ed5a66c180e1f646b505dbd2822611c9a4521586a3bea2c4aa9de9bd5aee4b08dbeca012a1be31f843fc5b9721af9f80d592fec97840d258b42f1a16bffe1950ef46fb9d8181081f154e8eab1cd0a760a87892c4249e16b82da15311bdc0d7b0440d27f08b34a2232463c5370f276dd88a4a509f152a4beeeb8b36fcaded1d330941817e16dfd3c05c0d2f706b2d4b54e4b4997be69594f4110b3d188c17476083aae2d65ac4a5dea8df7355b2e8b9312fe23c82df77239529f7b0a2ba0f9b2fc8dd890abbe31a579d419c7879bfaf8018ee2a22673ef77757743436b0bb0ff58f1f71cf969a6309c44e399685df63b611219a87ab4ea5dde4958fc86c0ba92342200e7e154beeb482bf40b44602b084e017b165066950af7dac48505e4a9da229e2e7e621a87351a8694147d7ab03407e9163bae218ceb3adb50895b6ae3c57fa19d4bac3265d33b5764cb974d813b2fffb5d1d78376281e3a50c854c31b7b9e4b4855ad5ecb57ca484b66b8d39627da3da35686bb806a3e628dcf5f070dcdccac6a0423dffcdb5eb97f970603e238f03ce3958320da077c04673b002785df659b34760c502c183bc1b2757b21f783f90a769c3657cd0a820d6468ab40fc6d575be3af6bd819112327c8bd6fbda0a8dbae676dbc00579c67746185961fb9ef606d895d3885d59dc56fc7d624e335b6053b811b12a802f2dcb1135354fcd601517385eea55b0082ecc4d1765ff914e11d33d58e76be918ef0f8c26337dc92f457ab9d73ac33cff0eaede90ba3e10465b388224f2165567283ca61831bead488cf301368f066a14ec49912f2e5b0698b8932d3efa85ccf7e2cd0fdb37d4015ba32d4f1e0239badc6ad715da03d389076a0d53bd83a64a77640499035b2b3565a8e0ddce8ab1ed54c56bde6dbbc0bb65ad27dd1bb2e69f47d2ca9abc88e777bcda5142c839fb49e01423bd68453af07b7ec8bdb5fcf27c5c5743518ccda6db93ad207c0141772bb89fdc17658cf96c6c81d16962c2ace79e8ac34b025560720a6a43b46992daee2a3170abefe1daf3ce56f1ad0c30a8c61a06ead19c6e486ed8458efcd997d8094a5b735013818e5b76a6ef919bf347fd1c1d04eeb9db031e3c2180a46c077ee4c68aee813a3d444b87d818c26e8d373be03f394264dea73a4d087b1a6d4678cfe1cbfe2bf9ba7d46ec980928b1481b26f0fcd57b4ae973c6e0e28f0675bbf67b3f70b317407410b393b8296e85ca637dbb41eaddb1e7f361b9e17805cf34500d69f7432d28472c4a47a0326cbaa1c0c25068089481a706d4d67b1ac5e7e5409b904874379cf882c613477b8d0d03b09539b7a9354f4cfc9e8d5bbd1457bdf8f2177a3a477ccd1186c242c63bc7663e54ae5fdba8c5dbb86d363174f584d85476b4acad152f7c0e47be387c80271236978a23a40fcec3eb10ac361c26f05fa6826ff49adf481131bf48a9f70e8f8192da0684e21dba260e0567e451ea2fc8198d0b4f9b8dde9f8370cc77252c577c7874ae4abdc9a36fef9c5f83d91e0535fdd339ba9aa20b06cc29cdc2e8940de6b67be5cf51c89cdd25d94cfd93bd030f1c25bb3e452304ac0722cb8fe4692ed58aa7cb080ffcaa40ef5a12e913e4da1c15cb7a5eb5d77885431a955bd113886517519f002ac1976b75106a68a0479250bba61a2b1de33b80d815493566f56095e38ff128f3e0a5ab3310adc6d6a61564f5ba3651bc24f5afca62d975b8b7990149a720fc30945d105dfd74561c097f6e0b9a56ba28473a1f0db79f37a4560b425766baf56ce6c0276f73dca733b62c948b04470f1c94386f3a9a14eb6d842f74cc74bda8c3bc52b5cfabfd9f833995155b79916275fe4f9451ff75055ddfcf6664c7253dc154af913e23e28deb85a091787c5d19d72aacb559f2228cb1e2919f9bc608c7d7b3c7c466c146f72770d0dda62e770b2aa6f634e24b452e41c94a2036201dab9614bc803379f170522f9345cf64ab756a4ff6d5950c7130e9d53db012dc789c6ba814108d3aad9514aaea4695dc2b92120806eb82f135190524ef1dd64bc8dba156c70326bc921543c92de8e69b62e41f2135353606a29a8a4da6bbde3de394ab380bf52edf71592f53617ff573a1002ffc8a252ed46cbc4d4c0970d90e5e554710d979eda79252f88b9d191bde52771d6b3950c10a6a959a89ffcd62839b1409f3fc64db16ef33cc11dc23c1932e8062047bbcc48f47143f3b3e6fdad853cc0f6941b3b82ba8cdff9c7db8712bd7df8574b6693feaa9ac3b22b38c099f2b210482cda28c811e02ffd5b76caeef9caa6cd3dd476ac49d0eb1ce32403b7a683271146606593c4d4806c2018a9d2dbf7a5b5794288dc979560fb5e19648b8b27df8ab9a9f7aed012609d14945fdb504debb25c41155d661322d6f8ac30c967e5bb08abd691c2c481a67aafd7f07869e1044457889ac4bbd0bedbbdb15ecc83d3be2d6a2d33862ea8834da47af6d8e2305d7fc7b51f7f35c5d46afd949ce8c72264b1ed2c2368d4bae2256c2059d7021fa28f36b6b9274d896d09a346020944504be518cb9901a2f9d2ddfb54cebcf7db4670da35380b7b7276d95cb884cdec5ee3e6f690cdd201a59212a30e07f0aed669955b2859e6b58b14c3eff88574feed8084132bdc4fba91868db9f0529bd1e91afd9e6390f82b48403a5d14ae59d34e115bf5371468b6a8dba4ebab63cbc25860a3ccba17c3f51e645c6eff0ef563abb4f1993239cb5f8043fb61f1edabce3d3790c50a24398d211cdfd0ca169da1f770f8a2f26dc1099b273fdacecce4ada2ab966327bcea69007232a45b44501b0f36c179264aded9e5962364c8cc7c2576c21b159ae8abf4fc6f4781b9bb881d450712ccfa5169ac6da03f8c7269f678991d6c639122b9a38986373dc2313c8e330fd797df95c70b7192a99525bca4f6c019bfe387a8b2eb1c843caab054016afd2023236d4dc28eae7d288a40fee933516efe3071c5cf2b50251176365b923cda9188626fc55519ae4349859898dbf6a5db1d093bb4bd5b9318f097ba1a06363c81dc145a939c8eef5f926354c0dcf9fd6bb1c1abb8a1e08e2e054e719e52087eee7927b42fed26295b5003a3a9c9e230e89f7eaa0317959b7c281884fa7d6274c7f48bd12626da09f64ee6bbb737fa6dccb683db0e487ba2d6db0d8a32733ee0f7ab0e667996baaf5cb4f17396cf718b916640f4fd1fda4a54402ca4904c47a1c608374ca0a9891921f86a64354607d2ccd026d5a3a43ef5311a374944123a8a9578166ff01d32cf349b4b17a5187bd103ef9a9d92ec51b84bfde3e4203538fd4c79cf306871eeacb04d92242f2faf9eb46236515612aefd98b673cf12113df4132bbe7f8dab733fe7e54be499a37324e485334018b72fc0e66fcf5c528b71d35918feee84306fd90178229850edc444d87c0ab8cff065f5e4e679638fdd257b84cf8e24a17b7302ae12c8db452b8ab27b08f932aa4cd40555f3ecfaec10dce3890bd527c83ff6978137a0a16a4ad9d064614509da90ad177d881fe8045942ef1ab69ccbd1ffbf1852d91aa49a8a299a034698e3d0c37df5d39d97ba48f52fd8239ddc2fb91df3950f657af3c5dce142501bd9a72bf0fd58b19ca013f9b69fde11c976741b0a4376835156e01d5718c35b24de85089cb3ac5ddde1af053f197cba1434c216e9e6bea937cb756ff687f5b1372882e17cf8e48ff3040187c5153ea4231c07dbfaca0bdadb44b0510f8a0750db637192b6e2a374087a42e7238ffdba8fec66027fbb882b70f87a203f6cd8a43126583bd3d0b2bad9da50f869ff5502a599ebca2ab8ff8470a9cd8d09e79a04e1e6a84d42b8028545471f1a7e85686b212b16fb93bc964989e144433839d609d5f17316d9409aa91ec7e956e79cfe5ea3f7bb6b2cdbb63ccc7287103db13c2f0c5085813450745482364edefe04a4ed19f65adeebde42a11eb59bcdb09b4b73fa4986c26d1b26ebb06ed53196af9559e1029984b55378e49b9b6c07743584c7d8eb26abb8eb68a16c3254c674467e65eac1207189d0efdf40aedd1e5b649cee3acb75c63b44d262e4af086594bfb8f7e09977a9e4619f0b4ded57c4bc02cc13e639caa150b519a2fade6f048e8abd175ce955d3af74e5735eff7d753faf3788748664a615c0c867eac29e62e7d2ed03c285b1e8090a4e90f70045c9a63b98dd788280e7eb86be377b31e71d6837c6174bd536c343b34bb52844f7e20190a719c282a81a060dabb06dcbbd9c30faab50173fe5763bf67e08ea30b81e416fff219c01d69cc24a7a9289f1a33ed34990bfbe2804c057c23a8528e97f4843d9bf329cb122a1dad1ff1359f6675d8b1af9809eff29a72af44303907bfd97c41f07e740b589c0da617c39c3e6e8f65b1bb90b08ccc15a09ee4578e3575dfdc0969bb35743d9fe5fdfb24ca5e58817534af7dceaa0eb4e86d6c0813ad9ac170dcd62a4606273f3791922e7c4362495b97fcc71abe8cdef255201cad530aa0ebaffe7550f1ae8b7b7f6c10ca4af6d429517596f6384e38f2b03be8703ccaeaf5efb72e9747ac48834fef98aec6edc5a7e94505ef7433e24bbbd6e663959a11804e382c2804f3ba19d8656117f806efa5b2da88481b68b295331604687c8112b38e0aa2f6ee723bcfea9b6cc02d5679974f9d0f5fb1e4e0bd57efc23cf1db2f2f5ea77942f7dc56d7c88fc78f20d6d83e8213504e2b7f7ef007c835481ad76d74ce428243e5e79f37eb084d3a9eab1ea17bb4e7c36dc538b8a680ab2b047f1a3cfe58d802b243bde10303047cea1042b5581243447e6404588d8d6ea0d8f0c5c7f58ef76a275da4814967d2a78cc97a7137c41182fa16080d9a4cdc5664c974e0a9b36ad4aa2a987e04bc6771fe4caa7a86b13dc534b48ef08b74b169d85bdf6a1630c58b079d7b8cb2ff2cd3d55168640f5043f49e7b27df734f408e88adc93355350d34fe5b56fdfc8661ccf3275748b1128ca0b199186feb2bdff03581403e6b6f5c80f240bb5923ce9f5ee4a87026f3421c10b8c6133d9dafce3c1e396683455e56330da82b846058b16c9e852bdafcf673bee53f5fd04e75c2ffe48677fee0222d63e018981406cfe7899842d82de4f9aef151c4ee110a1870fe88d2f8cbd06e43570c63a0eb809eed6a43df3fe7616e7c5722071200ffd04fff7f3727270447adf71cad9232c9a5f07bdb1d8fea76dd2368c85a6db9ae00c0d5dee2bec4fd2bb1ae3308e4a4edcd40e6a3e0a9a8e174b72421a9f45092e02c0769ea8fdcf3ffe2a0e4dd2d538853285431c33f012c756ae52e38796455f75dca3ba7330190535101d6b5a2ae34e3a162f0aedcdd1da461d4418f7439639604ce8e3a5f76146c367cee5b13a79eab63ab023af40e7bcb3a291c8ce15d27da733300857cbb4805a29853daf3299c6e8d454bbeaf053170d720587d491c37e508906de87873bd138b9f4bebb5603819ff59e4520e17e3c64b5f11a90651e9fc0d7e5f968c8de2ae935cf1bccbcc8e7c22c0f502f64ec426e0f3d188fe53d9205873dc96b55fb20f15564a9d2c22e7147acdc6f9fe7665f866fb38fb6c230f72c6338dfd16a09aa77f5884189938c1049e8bc1447a3f06c7a65ae3df23ac5cf7ed6c20b4c430e2467bd17e870961b4c6c87d3d9acdfe3a8040fe0c414f9b2fa3ad5332c10bfb944ac984ee191863fdc43f12c3f34c047c312e435098c91af13da8badbc444ddd2f12b8255206ceb593eb6f3da53aefc10a39b48223799333d1de768571a86e5860acde2eb7d854f092e0f5ffdd2baa3d251f06eaf3604cd95568fe71f772f6cedf7980e755a3f1b753c1872bc58c8e9b9bec6c3458b00d3f2bbc153a5cefebdce4726368ee64e832e257b42c6b2a41c5e363225f7461d93b6e12dcd8216f785e3f0d4cf0ee0c34655fa6a9a091bca7894c530646132abcbba8cce4eb93b9c607ab171474f82b06ae5b9ab1d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
