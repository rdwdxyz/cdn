<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c32b8c01381b9c89a73729b64b7b76f199fea983e5d06963817bcd2a236c97557e41981981856cf1da0ba939c7919deaf68f55a190ca06888ef79c6657ec3b912d9acbc36f0775a319e96139779e10f1376ca7f2e86def666323c3282cb23f8d3810bc5eadafc1d1ebcdb4759c2d087946b4c3bfbce7728843066b16aac3fbd60fd7c4c232fc0193574dcb62d465a8ad1a8ad248ac4dc5f420b570dd9b2ff43b2b74cad62ed16c47a7ef6fe3f9f6883994bf520ccc426a9fbaf5e4a1b22db2a5f32f9af5f9bdf7a1e0ae6ea60d6be9e9e4aefe649fcd28c8e36bee52c81baa7312749eea6db35c5ceff5462b58964442d68d6f8152c0f0751395a5a86454a3817b228cb9ad83ea90ef71a4101fa284b22c22173d6a3c111c8e0c45d0eec827c6bc5041ae1fbfa075e3a3c7f0a0dca54fd27aa136881f92bb84ae89b3ee64584cd04b52066e261bea3ce84eb47f650a3ee012699b0a03f62492beb2465e3807b55ccc86ad75d4bea5af42fab0da4c766b63f12f49c6e7b38cb8e8def23f00d3985d044c223b4c8163f4a922f1a26bd23f1ee5fa5016839e9742e721c18b49baab49300ac6200e2b46075f37f515c544fa7fe45da47c45fde6b19682a304a964f2204e8876d3061d64bea6605a45c899d08ece0f5461c3b2398b39f37888a3dc76b2d82f7f652475abc2f604f53c9f3fc5089f53746b0da8fb653cb09621444639b5ae438cf8cd674770883f3f98fadc036025ba3365f6e73eb920e9c09d94a9328beff5f2ef462bea81cb964e36d761cdde77f2a1bdcd53b7595ec73298e118623e6a72dd6de780808f67ad70b09793c3c127223940c3ab37ea344e07d99f9dd2f600d9fa1e919e897013d62d76dcf67bd73c6bffb7122d7f0c318c97855d53587a03304dadf16bc2a4610954ddb1f2dde61d0884b72bbda27e24cb08b79fdd41159790ea943bef7cf22b16934a685b3aec91e63627d98e1c83bb4162df708f543aceb9f86c0aac4bea7bf210bfae951c58bdb3f177347f54e25760de563f93077cdb69235ba62d1a1effce4fa0e7d9f1be93b914d98a4af32c19cb6d02e0afc3d5df9f378793eee966536d938c2b1cb490d8c1e1fd8ba7133861a7d194b7c40a17d52ef41dda327c916b1d3bcc70eb22f422d34925f53b8f76f02f0f2a9ec7f6c5194e6cd946cab48ad35be2d1ecb3ca2ad2097303d6eaeb635c496269a785f0a18571c3c155ef413d187f4792cd597a767ca65d17ca6c603743d87d2ab7a68cd68928f75816adb7f85fe68e0250b493a2df446b80d72c84800d2359d37276c053fe4cce28eac68e2eb8d81989eb2013ef80b612c6ac584af2c24f85361b2cf34ddaa3f41e4192409e2d835dd3840f8db969351c326207375cbf33af8265273345fadab7c615ac88f03e0b791d75ce730afe9c8954b31562393ba0d59fa98a521927ebfa0d226d35b5aba46ec08978c4d8a3a61c9402b6123ebb00e36f3f50a3f35af9e331accf5fa163df5f8d7eb50f4b75ee391bec6b802d6a691f028abd0cd87fb2864247d3bb34b4ae04552d5d9747d3c2011758adf974f3eb17da510c059acd9cfc1915393719b33b9492eb2751464b83c9b4f308cf042b23109e305e04b3408e17f0a16e1a4ab3358a1733678837ed0f9adc9ef691c3e5fe1237c43eee85b3a04dcda36df8114507af0889ae56e62c09de72333404f8fdd009b742220146343ee16778b9e96749182d65923e6d20c545214b881aa480a0867a21063f0914ba64bb3268f018164c7a213abe5d37226ed976c9e681781380591a7982f58cad33f0055276f75b90401e67593a7d2a03d9490a2adb7495f8dda9425ff62b164288d55bec0e9a6e9c9ee7c244021c3eddec3d094ee3c44f897ff64d798f9e031138c46b1b42f3811a1d01de30f9408a9592f34aef4c8d635d96846e2829d3fe38028adf840e4d083acd7314c99da059d92d3d82fbc92a5abfd4f658149c879970d701bcb949641151a7cf07a4bd93572110fa0a8f443669c39bb777b50cb766ae3450448e3fdf09eba6b968207f8922cf7ab07e4b40bae368fd91e8fd6d714f720dcc2344f1703a8f2197bf17ed7ccf722e8cf3b5ba42d4dd8662b70d30dc5f7e3304356031c601fdad0302d513239e1921d4f82b74c0d06abb339d800a33869e061899a4544ac77cca8dcf24550826b27465157535e07749d6e2903dcefe4219db4e16c08f189c42735d9903b3946d3d1fdc8acdee0b4fee0eda20de6e842155cb102e7b0de3fca3297cbbe625578cc0c9120d02f8175faa4904909d6e9f44bcdc95e644d02bdd6f3f04cfa0b8581a2a3716309e13d51bee5e9763d43c930689ff73d7cd98c746de5fdfa5e697920c0313184c49172e15d85947f80bc4d47b079ad1aff9a170ba7334d891e8672968cb205bb5f70a622a46fdf8d23eec9aadf86212b77a670356534cb39132b61e71e1b0b73114ca4d41eec5a94a362eccf930386b6434613fca9729fe35ea0474342108bb1055458e6b0660fd86d137d540ee06c1a615408a4ecafb826ecd951961759100bb35808aa2d588fb667f83ca0d9b4fb23f7c3cdc98f46330e3a615771a9185553b534d97501a290b086352bd234e534a83d40e6a9d9c8b2bc05710c8710251972bfdb45d64eafb6c57eb394ac2be9385b06837252974d5aeb9e01bbb30bec7c479047bd3662ab8752c41473fbe78180cd9c73e87decf4399147596cee47aab11f67ecef79f433917a2150de80d024bd79d1112d9813e9aa5e618d5671bd39b33879f1838162ed40358c6abd224d520becf16fa9c5c506c0d727a7df5b79b05c99daa934ea7aadb99040fb5ea7dd891039dd7649b51a2dca99c1af653ac449784193ea22143cf3e49997dc1e4b3cc659bbdfea7de5b69c6ef654e33b1b93fddb7b9256509e58d141bd40fddb42cbf95e727b94e354ab350c1e7b694b673f4588531033842d9b25634680ddb9022912791dc2e6262b0a54876c6a930c948601a571b6f0b9d48a66116fcb2d5f0e479e14419ae1af6de9e3e05cf0ced9fc465a3e49ae4ff468b5b407000570ffd2d9b2b613b2f2a69c4e5f5caa25f0004b6ec255fe98ab10a6a711e0696614cf5ca53d656686f0ef379078f9d54ddba3795d0481946ef778298fa84a1adadb208420a32199c5102c004788fff1c596642b9240ef672458ae688c99ef79ada59c88b0b2620a8a1a2e3115e309be11b20104d75f11ff855ab61e3ba49ca7d2f330ffb5c938dd4074a823182e1ffd85aceaae152d17adcb369b20f86a01a1863e2265df2cc7934ac26044f7993a0a9444cd9e17fbab76df8e2d02873715b5989b59440097b90f819847d7bf698c2d1339e15471d9c9a0a1fbc4fa03a450fcd4e8fa5d6f21aebae4dd715d9cd78ed9661b16d6574ca73bd4321a40cb9ffcf4d33c57dc1fc73d64f4a08bbf45ea1ce32035b5e02214575df77ad78afe9b1522211d2888676ea7e5bcb95624f690bcb9b10331cd59f0e2c7ee8372d717e3d914f7aed7e020357579494ad7abdff38c7bb9b811e8f09cb78a4bb0aaa6b6e64c0a529588003b76ec79188cca689ec6403397dd37c45f6d6c57f4311071868fdcbbfd6654c2e6dd04ed6bcb5821f4d0f8f27ba3b2aa283f168055ae5161655a710715fb76ce4559a460d2df4fd4a186eddf216d4bd2bd6ee2463fbb933e4a6959520f2c081dca04fdc5c80a0cd98961e26c2d1638e90d479eff3e09b14dd9a517548ef02aea2a6b3a97feae4df4c70e52a8caa6d6f16393f53da5cbb8e3faec288302be4a150baf6322c29683d5024416f5f0aa0222b1d5eb0283fc15acd089eb2e6dbc74a17254dbd404ee46a302e6ec6b1daae5d86195f53b69a9a78b642bf2ee1497cb1ae09a2465b147386b1b4523b3427ee7beb1dc782a26fba201f74d7ff4051f69f34938053fe018575bf1400f6ac0f8bb425d147f31d817be09af214424085adfb93cce064595f7d1a92735260afdf963196a56a94f15844321645cca70af14debdc558bc1e835350ca7f6412889e6cfdea649652500b6ca113db771c5833001b3b1ab7c883adbda37cf6f8cb62777a7e01eee35d449e33c81b9e70696a1ebd7d34c66f75b92576c3c9d880739f40453f29fe06518e7c725a1d4cf3a6bfbcb9566ec7baa5d5227d9e645926efe23fe7eeeeeb615face51c2c42d0e2c60923c2c0b08104bf26d64e9d9042844e6182cae97640132a649c9666dfaa34804a1f9ef8e1f44bd77061ca05740627c00815eef8ac3bf420112d1acc6db29a310b699bcc451d66061f2eb35a0138bdd02525ead9635446f8698bd0157d2fa6ca4e555520b8a0debd4e5157b988680f3276f474f2a65291a10a3dcf4fd7679e4e79acd1b1675fbe6bbe0d52fe01e74df09e149d6c1cc074f0eb5e3a9fbc485f12c0874777e4c8367145a0037777717a549c24fb10b3a8c3a93d7b0b1ccf75de7e4211854909e6a4b2cf1352d6ff5fd5879b6f84a8ea7dcb007aa4596382130f046323ff92b57ce341808b2cda270a63d855e1996ba6b84bf883916c39025812ff3403680cc02b0a6d8422f51ecafeadc2a579be9c0fa884507e93c7faab76577e505a62b4566d0ad5b1521fca44618c6d595e921bd719545e36565edbc82f41a6dee67a83a7491f75d48ab65327ef457a25ee6291ea32521ac70aeeaaeb15a47c898ed9134361578ed2e9590ef9904ada5a5c92bcc051a4b4453fb0f4d8a20730a9fba0802f1a32b16c89ca216b6754c1e5a2b486255c290d9194c3731809cb87ec456f554757577b6f3c689d10809fd03805a46716cf8542eea6165668279b64cc6bafbeb04128eabb8f70bc6548b24a2b6aff9d33012478bd9319067d84cc4234b924792b2ba7b825115ac7b21c0c5c611c81cf56d9d9c7f7287279f9788b61608c061b31127fd7fb7d353bf377e16069af90332d1e59ee0217a503b6e145ca86e3ba966fff02f5a329d8c03f8dd361eb73ad07925119f22e4c6f78f92ba4112a0f3a2cc4722f20c463de994e67c396bc9022cde5d7613e5a4cda545b37b46dbcbe5078f6bcb20fcbc5cf7a39a69ee2c2c6a390daf890cea4c19651d36fe2cf97f3f1681b8bd0dc574e830cf4e525f1739a202defe4d2b2a50a02991d146b2d85c4a64059c0585b5e2f6e1ea34d4dcf29f8048d6e51ba29bc4e3e2b02c04481e4dd880ec29edef4b3198cb3539abc0d22f1d42755c9fb2133e3f1d97b5edf9d94fa0b61187ecff37fb3535edfbf2845aa2aef2fac9cb77f5ef7de15b04e5fc9f395d8828685ba2b2e5966d1f30893fe0a432f65e4730f7d8eafd76d5450b4b9e5518223304e6a10f99a220fafddfc79dfe4edf451607ce6c296e3aac9c708216bd1deff3c8f7c61cb872005109ba843111f83a74f6b653d2cfe993f4dd4034a180f6f5a6ef08042d6fd6d41c7e7616e050169fe8225e8915fdd490f27974678b17b7d1c7424bdb7a9f4b1d1e22043f5785a9a9967419dbe37ee77b06714b7e0138e38121b1751ca81fae43faba53b3250ff65c74f20851c6698b90db9f51301e58e8aa0a4652568bc531ee1e9bdd46a18c12f0da1f539b941d9dc5b2079976ef3a4872dd1d53a54aa0a867ab8531c61e00e49df6a063249a1e765d42f64517152492d784abd76d9494cc71dea87ab0b7b1e3110a5df5fbf3f9bc069cbf7cab1e5767bdd1d48df9dde829714d4ffe55ddf72e084918444cbc451c67fbc4d7b0ea01d94b4ae25d2bae2c189c978a7c4406fc92325cd391969b3119b0f9a925f0b2e7aeab98818aa9e935838ae373d7f1312476fe8da5f8c1c0201b2454aacf6e64574c857e9c0d820defd88b4f3cd93057188ce724b6ea2f7e4033d1dbe8ac6fa3d007cfa3da1a896f92fbf115cb28eafebd2b364b0faf8c53955b80b00e3ca864f19e68bfb8fe413338d552c92646222191522225c3765053279d100bf1f6ef86250bbe8f51572e81170b2d5b63eeb9070f514d892e7861784b0517b4bd1014cc17de4e6331af3214ba41fb0fb5e33d3c253e9de0928cf99b305618156505814b4f832c40e4bc0d67950e7e880aa3467bd4fa351405f87271a4894c013a864b886850807cb08e9a416085e69fc2511780b7579b6e5a023e51b2cde33750a08286169856613599fa14c18b8557334c023dd0fb0e3c9df560d81c782bac88fa4fe44b540936d09cfc8298cc394737ac8442678d04122fced5c27d6de59ef3e876efe95643fa3b8d7565eff58b8b93946900997e92d6bcfc3eb8f0f03ba750265345bf7f094609d99521aa8b26a5e42cce8650c1e74bbbbbbf7e38622d9e98e0a8726a6985aa5c9db2d5823fd3e614aaeecf36a017d10096e921c50e62f4af8cc990cdb9f8ce39384043869618344451f4110fc51e3f8ab5abf25f10b119f861d90e4cd0ab91291d6f16b786181caee1b195a06a74af8c181447988d5fecf39c412dea2315513bfdd294f829adcd8134e824ebf0a845353b58e4c268cc846e0bcd3e1b53c6fde794bdb793791004586ff1a58d7df9fab8afeaede99fcd4cde70234e02dc931933b921d810e245b060e2d237e14163d6caf6876cbf305a17bfd984edd24f0c706393f70e83b879c57c07f93a2d7cf443812552dcf693ffc95648129aeee3f3dbf746b604666749be49065035cdb5e1faff25aec216514ff433212ea6949a393906bec8ffce88fadc6a96d6be60c2162575a0ddd55eb5bf46f513931bcdb0ed71953b08953b81cbebb69f73d264daea9296c6ff384bc91db41e8d3db300c4f0153ff7f10fbcce38328034ee5a770dc35f32a296d037129659403dd8967afbc1ab086489faef5eb21a1ebb9ba31368bcfdbb02a49ec10ad1f48039e244c01ed1405adda76004bd9ac0d2ece12ccd8d315bc7207c8ca53acd9de9c700a3489442380d4643e82a3347a91f77a27ca4c741a0186f21a5676074fa36d0d33166c5902ada5a63ef1d8d1023a1328291fcf46841d2c52fba43a845f28c500049e429d3046dc7e69c2f8b61f7e2c6e4c1a28a9509847c786c4ac68d2227f1c09d49d5c815ce194a6bc3af1ef7b2ece34153306d6a301657665fdad2f94566f56b0c9c5645cf015cadf140d7b73ac6f8828b0d08bbd512e47f1cf2cb37b068433a899da3713b70abce5b5a145bc65c63748ea84febdfb1763622dedaa9820304f8a3ee645140c7ff84bb0779b567fae3fa6c96a4f4e4727634ef197f0e715c5a2b8a4b8f63e8ef92b055ab77423f1d86c56f0fa396ea14d5b65520ab4f5809e1489262fe2f542e004de8aa0d6cfab57564412b64e58dbb18bfb905f18f7be20c8c8f249fc4919f117ee9647a2422a0fb3c2e2b1bc261b8e7500a4fba68a951b43de90130f34f02244c4bed1156d6a2a288e35aa8501a67f73373a72de344ad9e8d71f47e38e9bf4a5b63a6b4944283ed1545a874fc9f645a89869e7fef24620bb531aa65ba767df31e8cb8a679605769e502a1cd1d93e1aeb13a9c1c15085dfed43f2ba11ab0b498dc5a41af5d51ef89d78187304e8f9a830f0cc3435f76d7b6d667e4e85a30c83cc662205dadd26cc89dfb3645bc84e73f4d75b703ddfd092cbb4916f96b930469a52de233012101885e2a0fab4aaac9f214b2433e4d46f09342007893ddecd5ee2b201f036617144303bbdd628db1bc40abbf246124d00f809381cdd09091f89cfbfd76c5a8e2760f1b1ab597e9ac9786994f5cb0afcf235e1acd1641262da019efb8a8c19443a8da0c9d1faf71701d6d76eb28b2a50954270571b6077be169727a5e8fa836a62433b14a8fec269788b388d74603e60748445bc280fbc009701cb5c8cd88edf5a25d535bffbe638a0041c32560f748af86900ecdec8e9758fcb67e3a67d18ca1c89d25dd3e0c9fc24d1fb258ab47193de84d2bc493efbb1b89ab8c1307c4731b6ca0c51cb65a25e7fa7f9f7ca27c7f1ecd3c4596f11737c19eece38b2a024f2bd8a5a46a7dc4551cce16e4a719b4579afd7de04366ce4c79fc80069d47ce39e10165c546ddfa2bd560d1a11f1e4cf0b72070273a530a3724f93b23442d2942e6b889ba0f71d4b2ad49ff9c20bef4643d8e8a68cad02a3ec6b34cb7a13d237c38a02803d2859e0c7f8b38ad7295ee78758fb046b0e72dcc7913d74c89c5c26b6c58a5c0de4916ba24c6299e95432ae851ac6d4f87d07264869918acbfa4b40d61164a55ce3480cb207a3e5a4ac0b14ead7797e79da391e2801ff1a477196b1d966de37d6d2ed0589d3f3ca9054af295d6bbc97102c7ec2c664589677e97db4a146de7204524527ae640b9a6015301a91704fbc9d7f95fde9ce375c52a2d40634ee8727f5f935d67b756abae936e9d1391f92e53190feb5e3f9412d0104c9ce93f5731363912b61292069985947a5a1dd579d710cc610f5ec5d53f35af178b8b06e6b24772e3791476c03fa93310f264d3ce42bb682e9df7acfc21f5e4139d164e8500be75d72179f21f8c1914c59cc9a52842c29863fdb72a6c16390db63b795098351fe173c4df2eaaa10e7d69342cd8bfa29301fa891cec21ee7ce0bb4f2954bc28ac92dcfc9ce16bed1e15ed9ff93a4ff00564697f37eabfb620459419b21c31b68c131ee11c741def4b561007b94ae07a498081b4c810d14a2d1e3afa086ec39bcc58d71c991f08b79b7f860dad17554feb7335905e272f6efaa0749b76b69dc19557211f588f84df9fbd085fff9fb69865ce7763b370a2e98913a1eee993ccedf3d4db8e5335520a37f5a7a534f4b2f328aed00718b8b4508b1204b339b3b305691526cc56fab515a2675f3d0bdd9ef47f605f7f494c36c6a4933e17a58d066e48ffbffa39f9a1b142294c84d1dc18f3ad080c56218b811a4cf57adbed256f63c9c0235ef249017c68ac51ba82da00e474892c1390b46a26af7e26cfb32c6ca0365be5da70935f94a2a29eb41e7caa9c664b8c78812cc68ce23f3876d21b6123e3da7b3ca4210b1268eb24ca5c87c65d6815f21f5a5c505eaf7c54b563071c1fa1d7fe190bf6298f4458bd7282881a7029d17d99d86c58241966734fbadf5521cfdf4b2e068a64574a59fe7cd91bd4ec6dde40152c9f473a3ede4ef3a988969badf500b16f9cb1ade73f6ec0093f023145ee9527eeac0e66a0b6ff8cce313ad04de41e9ce27569f7f8d45f8bbc0397e7a7ec6e079a66cb6da4cf5968d069677dea4b92423ac16ca67bf8db8ecab3b9c9804799edd6bbb29c6b5ada8872adef0218629a75f0f21fd40caa3451cc2f8e030e696dccb08e0d32f7fac5279b72c4cfd499e7dfb62b29db09dfccfa5c1503f5db75eb9f7a5539e745c6b22daeb6dc8a92b4b6ca5c8fcf322633b4fd3a93eed57eb1cb0f9ce9e465c3ff417582b85b960d1f59dbc891ccacd83d41647db562aea493b32303acb1f9c48b479b37033559a2c044973127eaa5276b8a803603ae52d25982095d2a31e82b7933f2ef6b8340fce031dd4fa6eda79dffd5198f515564dfb2ec50f1cd7ba7736dd59eb7669eeb9c3a499913f98f35c5c3f533d9928ca0176cc935f1a8c96af5fc6d67465b97bb70022de536e2a29c1c7a1d2ee156c1e60e31679e63ef2c31bc97d400ae585904d84f9d3b00de29b8fdf7ba228eab9067699b1cd6831478531080d6dfec62d2c7498e31642eed43260df6812f450d8d127473b57de629a9595e843520a91f2035956a8e83b194d1638a6948c6c838b59a4eb36975fc76a54393bab7451ec0248094fdee6f2fcf6a8fe1fc1f2dd34df18ef700da22f96e60fa1472313a241d289fc010abb854ae21bf13a1918aea7859a5a6d414a628cc530045a9136db15f7801b2c41b8f64bb06fdf75cf71562415d88d52ce66a1266e27e0e5da5b5c6139ad2f70465383ac3aa3b6a97ecd05fbf680555ace5b77e6e1aa750ec3f3374a4f9a6b559cabd735eb9157645e4742f07563d6c4faf0fd217f14ed10923e883b53375dd6049c77a7f98982c35ccab8b6b253dd4a63ec3d68c62c43da4d2a2f9b1172c729d74e8ca3a23e736f31412a32d3aa4274e0a801f3a83a8880a0bf02d360394ea3f2321ffaa0f9d6fb1c728adfc0de9e20a20d8eb50bc5f40c5893541ebd8d2491069cb5042f5493613930aaec7d27bfb9768b265b7983ab78aac04d3c2a64558ee25c867cd8e361c558d5e40fe05c684bb638d94551edcf65e3731e24c5af6b4b32d44959eef778ffa187d50b794b677f0ad63395d633d17df2921bd2b26d316af834531414b10987e30b7b24223bfa7db0d913f46531cd59b9d6766bab064502d31bacd5b7972101f5af7aa2be2ced2a9d9ea695253bf5a244fa37b269f3deb6026cb67a70e956f7217b687be9c25f642e29dc86fcf4c8da21362b57b1926f774dc6ad09804501e50e0536adeb6c987a5cde5349472849fe5edf6fa5ad4de1c45afc9e99ccecb105d42c3937d58b3a6672039231317dcf7ff6a6ca972bb3eb46ce06efaa49782f1ae45fe850271a0be807a766001b0e9a706be3e56993b704bb327a0eeca75856ca08f64031c81225dd060d81aad923ed586256b7c8ffc5951ffb2f8b5394229fe80c10022783b1454de485f5e99b845a1bb1805f7f9b4f7b3b32b0d65e71da2aad1c148f133bef710fee3a4f83c37c16b86a7090db9a8edb8c6cf48f429b866cac6b365057a3fc3faeba8e603a6691200c6022511b273ea053817606fbaae60887a7f44412979dd003091088f9d1a68ea4a5225820a3527e5b992dbe46841c75f25ce0efeff548f98d0504ca1db02a2d52958ae7173e4c8a8530e10e0aab26d3c236021c1fc55204695d6d7129932210ab7420cb98ef7327af265589348d82489e8fbc615509bec9e690d3b3d16f2e7a98fb82c0f3f6b3e4949dbdd94d90b7354ad69603531ba37ef3e7eba0a8efd4401b9b387c8076158e43614277d8a68f183ea84d3d702f17e11987d9eb21d651f9b23eeeae62f95091adee7ad980122c39be14fb043d7c364c0242860d6bc12301831a182aa8b11f223bde7bd79c718e59104141ade017ebae8bf79ab911614d6e33727f3ce4707ece29d187d5a09bb29f3de490c9132fe4630355cffdb5e6d91cb861b7ac61b579259689a928980c31783acf29b3049330de5f3879bafd3bb96c84bc17eab80e8d281e0bd1f09b3002b66cb6ecd3be80d0eeb20ce2475fedc1257c0398fd89c408143130bd02b4e5c334840cce1cd80bf8cdde068ecf745661e44d0372430672e2d4b5ddef740ca45713fbdc0dffb48d89d6944b33943471765a650fbd5db16ca81976ea8dfbcf68f36b2c0ff8f5f5dc9a84f54c0b614a288a33755381980731e6b90fbbea75e82c3e8f2b94d4f5983aee4a39413dacf2c9e350940343c5e2c37534581fe4465d556a96f26573517831132000e8d6d5e50c4a310419325d48d947b92fc922deade4ccc379dfc969bb5604349afb297912f57f1548c70d3be675d709ec1d3e17d76aa5592768e5e266b6600f16a8b03cc5d1edf5183443cbc05cb0dd782dbe9e998f7da8169918fade375862d75738b3c4eefa532c1171f38db8e4e4561bf3bfb371bd2c6251a0092282c672a854ee5df0cbbc70abdec7d58d2c6d1ee6ac024841434f87f6f4c0625e604299c53df14cc774b5bd8fde5290c3cee90f662db033cd010dc1aea5d161c733dc11475564b920f5b89f4fb0e13a759675cf81d98900004e5a47104457a8668c2a8fd9e4ec77786a51679fdad2360d7ef79bde674cff9eb0ce1f3d6a9c5979c548463fd5e9ef5000450b738f1fea8d693008c13f48db4b9762edf0bceefda5b06306848ab7572edde80149c7d2af2b6943187f0bacf1789bb03fadf1c1147e0390e7d8fe6a67dfa786b3226035b1e4c324a12171dc806b2d5bb9b1214f2fc169633c33c79ea663f74652afd8270e9e77c97a9d6eef25f4a1ead1cf6c0de8387d96bc58f9f655f53ad6bb4f79a1fb6e52f1c8836718e4a9fb644fb82973f7ac666f15edb180c79dc9d622d85501786f7dec88df355d64ed6889e32de6f52bfe4ec94a7314cd5fbca09b25af9959210748c2e9f15b22d20d06790c66c73987a4a67f94206c28b770a89f1a1579c1b66f4267b30094f3d22f164d2e4491bdf9ce9d8aebf5faa3ed9a6cdac35481161fc42b689ab8f896a3ebad568aac5127f507cb4afa16c0184bfa9558bf06389f89a06ff87fafe909d9c11e58a6ca6c8a79ac99dd7a9027536c91e135ea8b7b312c96b54b1bbebc931341fbd8e82775d211fa89f7a3d2d9e725dc84bc452d53f443c00c5f179fac6d67127009765148fb7adc39b7b7d4e9968f14a091676cf0b6e0e36abf48871d7c0d58211a52f3a2adf9c9db0e1f0cc0b0219ea95fa6e6582d702d1a50d2cfebfe6b74cb335c34f480eac17b4f45b2f928511cc5c26ca26c30c56d378836ab98ee0b5e9f0c821ca7192d439608f4df95cec02fe69f71b66cb47311c24bdf57063c35d46c52b05e8fb384bc0065b02ced8781a1e7944559272296f8abe2d0efc5b3d1b9f9fc5bc6ab8558ef2735b13c01886750bcef02656f6baea970ed2a864bad243932cedcadd6188ebe6beb538ec6ddf9941f36fc2b7f502653e7e6df5798a6db761950f4c4976477d76cf9bf7b315ebb7fbcf0035d229cbd033c55e6c6f9e97dc20387a0fa2fbb31054180b7ed0e6059ae82f51bbf5da185986fd6280e707691242e3ae610372cf91c32fe244970622b936cdf5df4ce8d9e96d2b8c714a9ea11e5ea20db05e099c47b8463f46a55802b3e95570c52900f889eed7bc23e864dedebc0769af5402b93acb6229468db84e005b2fc7a1ca5fcd5f0de421044156b7425ac6738cedee20259ca0956decd9e5c4a0bb252bdaeffa5bb26944824e6a0c738d6107a5d56243253f606bb0ad733161d3944fe2b0f2b322ff32b885053d8bae57f8d72707d8d5b262e6f832bb7eb06a0433b59a8dce98527085e3576d59564e1e6346a4adf9b899cb4fbfb5bebabcea153b267e56c8b59d063f84a91c209467eee9ef6d899e00d83690b6c057dff534069759783c155fa788004586e485e28c84f5791a0f37ac2d8890d6ebbe2fa664a9b1b72a877f3260523354296679a10e190757f31284eb79260f08a39abddc09d5d6148e1fdc9552388f5544626b4eaa4fa842a37d0fdbcff9fb00548875301291a2435fcc4173090ad12250ff1acf56915d7ea748a267d849237bf9b14efa20a68a14a2565fff12cabf80c340f545bf1c18475fe0dca1281698dd8bd4e26f23a73777e620b4874ce54316147f9158f2e81fd175d2179684a8281636d6a591ac031b0ae350e4996a3ffe8523957b7dd11a8631870527c5486076f2d65c6763422c17b6c4e78bcac0577d765fccc9f6ca67a15a0d29e625d36b27525b059c0aa0352f5bac27d54b55c3a3964544344212600b032921fbebab072b94c0807ecbac57b9c2511a139ccec9a58f14ea1209b2677f661631b2b85ffb7a226d7a2d40b606539213039652e689a65d91ee7c3009a7d14d94e3ac23882beb52613b58a671225a0e4ee7f9374b35e17e4848cc841e5a64cfa0cd3621fc7ecc4293bd5974572c5829e6fb729d4fac565a56d9ab0ca953471cd2d2525b8aa7ef3299c98a18fa1691b9ee244e80ca04f041948babd83eb181b0ebb0fcd7fc78a3d5d189e62b6cbde9514fb0ae9d35492be63b04934c0b59791d352a3f4a198932dbfed93561338010d6bac82e40def84fc3054a6f0517e2e15533add5bcf84d1aa36767516dcdad33dd2110b64ad1a946aad9abcd7d5e9191b38f956574b652e2b999d5371865d1e1e1e72272dd2ffb4bba10e606f6bffffe946857c6fccad5b38be14627bf08847a433d49b528528b9b8de8fe749afd3304e4fd0b9d1a38f07f2c3cb0ca69ca9323aa5b9b945c79e2c42685e3731114a4802edfadf83a6eb23ec0d83edab89d326dcc950a70c089fb3a2cb3b121d2c29827033dafc3d27ea6b2e494a05f4f27f1cef990abad08d9a03c1636924dfa358007664f517d2c22dbd79c11d81b19322242aea0f895495e076d9d25398d23aa84284e694d57c32e0bedb969f93860165179d9aab3c7c5ae70edabf7ac9470d8e76d3176ad300b2a24e3b7a873c767b3fb5ff3fe9d9235265831671afa0a351b8f58fdc9cd713c9ddc47cbb8f4ac24c68b549da3f3d6876a8b809216d97288d4bda3cc2f84dbe6d4de7f019bf8e364be66abc3848757d26539ac5dc4b83dcc3b55d3d809136989b45430b09252c1bc479fb7f532bd342f109c99877d546cfda9b4b6ecba714e8bf0c818102b8f1646a8c1f379b5db3a48b0d2c3d73e109c9fde210743eafefc695424b59e72c842b620f0fb0db71c089606790e242410e704bab6ff55504f775158c5f14e230f7004e1f052c5772d32ae4866fa7d7517498e12bf8652c4dbccb5886a4ea9acb755b6c8a0223a5ec9272c802b80da5ec0fc84e62a6d58ce24a2993d13c115561bea357793472acad772acf47862c5253cee0548fc88d262ace93c479e04b753c474d5e21c063ce4511c553742c2dc461f3dd627a4155ba7eaa8b100aeac7a94ca3e20145bf6146b852dd67ac4e6c36f67350ca81aba680abece6633a6c3e433006a4b67108c27c7591faec5e752189e85a1b670df02f3909cb5a19679f14e0f670c4b956dbbd6e7a758c07e1d3ece8c78ee3ecc33da4e9c798beafdef981d98bcb7c8cd938e01895a0cd9afd402f8214f1af4a0cadbe52f7095708d46fd17703eea25f65ebae1b2a895d69f8dfe59482e171dff4d02e300a20c41105b6447625dc1fff64b618ce3cec05ffac528da5c8671102a1b13be838633ecfcd3f5088a930108e0b903dda55fde7af85382a9f77bd83fc666b3065d2745f26ad51089d64b4293d79331d54f53fe09edd91d790832fe0108447b1089ed2efabeb2f549440757bc55adaf3d3eac3850f06d6abbe43fa67c3a490e93a96e6dcf03bcbfe3ba10f1e06e8edd21e55d3e93091a1beb532cbb28c696a358d60985496ae683be72a6cdc62cb813a65f62e55b8626414e2ce22bd1da6131d7dc7564386f21042515a750291154eccd8bf4f87ce0955c2901077038d0df6aa1992e79cd259646b6edb8f2c892ad38dd3f7f8b3e5a89a2178f64d8cc6e49e73ec373ed2d2c6911646cec3dd4f3ca475c1efd3f6c8dc361886201e8c365442a6b575e61b901e95a55ce70a27ebd2352d504d4a94eaac284b8b52475497c864c549e3d9b0ce9204fa6c0aaab7c278dfa49aebee48ccc79f5fa0505bb209cd431677133820b82affdb93feb02adca10001a0cd3dfc2e8852de42bc5c45633987176abd23a90516c4d2227a0e3d7512240d7484655b40540d0a9631c4184154f423e3c8230c51f14f47326283827249c186c33bdebefa8dcc320813b6bfc66901b1a571b79b97c1f0649f39e32695ef653935076e995e529b061d0742eda6cf99e59561c3c0fb969eee42abdeb495fc9fc0a7e6759c05b2778c2aa2786c74134f92807643f526396aa7b72b8f7f04d96fb653f6d63f33848a1a2b610367643c9f541e23dfa5a393c8322ea3d08ec1e25504f6674b02db9494814da0ee8885351ddd036da7a2a8c989d340091a6a71f9e01bd012afc78266ca201286b9ca2be9c5ca50c9146dab9e54420dd3c2c5f2ecc433007ee73894c53c0d760742b5555d2ed8daf2c131dd430704e4847fc035d1e2ff617b1551d8d08c5889b00ca0d54026ff48ff51d9fc9c951585dd38283679a11fcbdfabbb6405152fc752c3a84ee17d2ceaf3919b062dd55a6a8f6db3e696623efa9a1768b1f765aa3d043e0b9501cd9b3d56b4a8847616627b0617c86097094dd3bc3984ccccd2ec1ac9abfa73bff541e2694beadb676b98f57b0141097efde98b234e2f5fc20d7910630104a94c9014f2250f1010a0ba109069896cf8ad313343a5f528c34d2954506996a037a9dbe0be1adc43ebac03c39367452b6f4e876c5617524f5b34c29442fd5065139e38f176365ad7187d898c666595317a4a78920a5a3f7d5ec94ae71f57444700a33ba248de534a4a2df94f00b9a2db629c3b6aaff550a9158b01b972d51a3ffc4d86d0249a1b1141e8ad13475c6542f3f2cd9010c9bee53be51cbfc104cfc2f9bab8b0846e48a281087c288b75a5c1c1ec8b17c2f87174d05ac1989dc3525907c1121da6d2d23a8392a4c469bb193b72519ab39bbd11dea1407fcef1ca40a19ca20942648abd14c8c5629e9b9c87b9709e59280bca59315e64c48ac314854849fb836b38f6ca5ff71d60b5338d6602e6668c029d430ff4ebc2ceb00e6f8a4b04b950cb82e750371c5de1c02d9023e8e4db8f13e1bbe77c99da35d069e7beed1448c7c1650d2cb2466181ae9b497a58f4422364798087a0d76bef2ee90ead571dc8b26bc103bcb996287cedca8829a7cc910ca8a1dd5f555e57b4880f2f2941db9890866eac11d150eaa92681f496b60eb9d937ed60332d395cf8a50c993f989d0d64704c978db65ec7b5fd951329806dc6d242c72b99a97a46b115bef79d69776ce1e0c9746d5da8386694ea366b68699fb47ca6418f0a4a6d735a477732e98ffdc115507cf333f692797947947f5bac20af98d8b8a8d227ef87a9322c82ff4045bd75a596dd14bced505f4bb2351db0a44f1feb4dc31ab957bf5d24b7549cf11843fca7cdaafdedb815072112c588c39f90ea953b3e2515beaf7a2403339b75c725c86a51ff50519370e9a4fb4106815548904e552e6ec6107aafc67939a90f8c41bc885ce7a6f5a400e223e6be9be58f56c9029265262b3e99acd5f52c4705f48a11620e7e496993bd7f01258cafff2c8ebed3cd5b71dc0ecdf2bc8297268c3cc782106f99a17501a301d724cc2473dc52d994004e3e87cfcf2e13c11d9880e8fcda6e05df7a36be72d88ab575687f51577aca4b0de87a609f16ac0a8177f2cb9d48755cacbeb41011e9139db114eb5536e80f23e1537f9d0f18cd4adad45684d0b37fa31f8a5ea88f26571b6ef89276984b1666320ca96b6b9395735e6b621de409427262847600beb5c51889eddbc60cf33dcb090f7896c57289b53cf106bb34269311a3080ab3daec94ea363f14b3494d01fa1094eab96ea8c81494fe97d69dc7a5e630e858965c6060535634b296fffe0cca305401872bf0aa1c6c48af57b097a581c0ba5e80e65b20d66805f9cebcfb6bab4a0f4df7534a56b705ea953b9da79c49050fd64499bb58e05c6720fb5af0bab03e72a423351bea6d4861800adcddaefd82295afe76fe3155c9083804b11e9512ee0acf6e64836a9310c643149748d814d9638288c0b9e20c5431f68c4da332e20a260a864acdb5902f01abe4ba4ba66a979f6f1dd3a6c7eaaca70ea6533446fe110cd99c8197a12b6f52a488e764490d5e2051173254e69efa869294b4c0ebdabd0505986f0b77c2e6b6117c85d20e821c884adda5acf42fdb271cea42734b63c7a314acf489cf3de091e95e3f2308ecac9fc11c095302929fcb57992fc40225d4b79a954e98adb0701b7dd51efbaa5ebd0a1475218bb09e275a066490426865ffc097c293afc6e35c7c12420e8bbe50eff2e1d9653d51fdaec90fb08b820d4c52067edc8f3b7231a45308fe6eed9bf97b3ccc84309bfe98c27ca71eae36c7ba914497f3de730744294c0d6412df650b8385adedaf5e05e4cf9439da5dd9962d7a435911856518f30c2e0346e65e6dd07b25e66791cbe3035113135286f1ce06ad8a5490a299af0256653c566dd911f1c26d9e88bc1a3a3f7d1fc9d39716299c29c1339dc66f4e3df2e5003ab70558a0361639756a9cec61714faf7b123bf3681cd823e1bd1370a311a8e76a24c4a09a42d3d59c69583707ad5a0aa4fe50908bb893e56555493619bf4626d7f0288cbdab132204af9886205f6010f734281319b19b12f0a3998317487d5916589f0515066e4909d6c06e49aa1733cfa0924a3ac8a2250819fb0746dd56ac6f566d532caf9f18fb8dfd19c13a527abc7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
