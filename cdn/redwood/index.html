<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f68e995553d3877bdfd854784661b9652771670fff29172fa05e9c3534322e92f970800cb9fc49cf45432d45e90b34acead5c6c3785fcad3982c6477a531caa4eca2eb780e2f1606d281e18e137236913ecfc5da87ee3e6095bc167cd3904ee5048ebbb35844de42ee653ac96f80c36b0978b5432eeb1ec184721281d116bb4bdc68be91215911d39350d96bec66958793a294f3d4390673e061d0196afc320f833354e37a392d7c7d873f45aee46ddee2ab7000687f60634f254672e4836681d066868b30155af04a4f1ab8851968d32a663b7ed504140976a23d78a36dad540970cadb02fec90b9ebbb5359e319221fe51c2ff3bab9f394cdce73e5f637c8599d0a169c07229453fb5416204e2f0c93974127dcced7f974d57d4502f0f4323f4d4c781099530f30a34e331cbc3837b6c7817f8528d778b14cf4759e31ba07bf5904e6fed7448b2d8690279fd506b93f07fa526c5c046edd2404257f80ebfedfe4dd6159d528855cc60c486499206deb57b55e7e801dbf92bdddff43fd0f2c452387adfaabd3714b2bf91b346fad5986b137cbe6515d8a1615e4027589586a2682c6d8185e7590efee03c42c8e95559af05ed747835add081ec4c991f53867a839b581a2c78d651001362e35a904ca1468b4360c1db6f63fd84fc3373c6fedbf8fcf8656a1a6985580e9ff0258f49ba038adcddb73e4301a6c7a0df4821f7f3586996b4c2884e2a83fe0411a88aa01680aeb9b1bf03ff2a3836ce1ac0341b311800bb0e5f7c2980a6d27f964a24068275486f63a39284f391bac25b2632af5a511cc8010608d9bb46d3c40b4aa9d7a7b508608e808f5155e3662a29ead24125e802b7170128400fa10789ef41f2d8167226ac66b962f6d0a12aeff36d329417c8b884c4c33241c903d67c243a71bbc0a1b0fb8bf4f5858504f141b28d7967724bc8aa373449082fcd4dca5f4494b404b4c80f47971e4f3d678aadf9ca764fca25942021dd65ebfec7648de8455ba3e75ea6d8094d276a87334bd985ba2a58cc4588ae1780d302eb0f7a577f66955d4e94b93e67b4246e3bc091479eaae2f3e4b2abb209a57ff2cc304e56f6f4a24349ccc3982c3b9ad773bf4c824bc2676f4067269e58af943c2c5ac46de848642952d2eadb8ffb47dd4e079bafb4981488ccc7e75a5835a571a8fe09e6b4cf5aeb056cc54a3b8423bdb96da67c77da26a3e8fa7957c5cbd858a7283063e2be177705d0d686a9f22c379faf7276d3e26c1155324fb97de7b7fdfea03d4f630da76e04e7486e8bc79117b1198823d348c030fe760dfd0bc78c0d023ad0ea67bf6efdb910dea123b2fed756864113071c46866dea213ac01181dd7804594c0ea83fcc7b086d1ad5aa38053da47051c109fed01fdfda47d343d30ca8543f1a7482d3c5163ecf972233d47fc4bf0266b0a28e095bece7a95b1415fc3c49903d9c661d63051c57745f00870afed0b3c665c96d99015a2e6dc3f86a41d1152d7f75ae27f7f4f3d8b0eb1df13e2dc999cdd83221f05cd1114d130bd1b6a70c98d308a2c6059fadda5303cf72c2440a2ce776866c8e6702aeb45d0a7e9a5bc6435707afac1cd05bb92bbbeca4391f82232f13efdb45688948084fb5151397a799f4df6532939892c4b2b5c6e7db4994315bf2ef39352e5b299428b54bccdd755e263c94dd9e2cc644f1dba23609d65dbce20e96a350fcdf94d130b663f9f8ffb10e5abc4055ce996127a2b77600572213a205ca36713b3f72f2b197fa2d23de349ffe41ecd1a01b12b91227436e0cd938177e2e1ff0479c905a320853409200ef4a97a0f2c29f88f3b200d04b666913d02038cdfac7b287f688ce6d9f39e58383174104e5c6b06d52cd8e356825e5941d7282190109ce687b4e561f63869af9d47061d6062f85ec8318b09d12ec2c47619900df5cc16bec68060deb395494c7342ab55b9f18b5c967453e8b9da062a875c621c0a77e3350d64c679bf443e97298db0f7a352203f61c6c8e0768f603a491c01011e80431f44f0a18032de3b49394651d835b962adbda40fe3ab62d92eff5e4d04da72f6edfec08418fce9c0fdf476fd79892c8755838e951d1e6e068fe9e0fec478e2b515839517e8c84b6ef803e0328988fea72f1ff1e6d820de598f95491b29406251ee1b2bc3fe8d48e7e530db49e4a403778fce6c64686fc869ee7eeac7dc0af78ad98c940a98532ecb224a35f08c3027237a0e4dd658b70f5b710b1c8d426fef7aa5f9b35b1fdbd9bd494d9aec021c557c1e01d875e18ada0820fc8aed7af1d1341d6b10a2e7c107cc08edee07483b760ab9042bff78eca1c6db9d69e86896d2dbec9db29d3ff59d6550e5952a9fd25b030e3a9c3098a46383bcc6ec24ae3aae03981893fc368699e81147e896696fa6be02b9d2636c4583bccd91eae04215220f1e3b4beee39a03a73c5f26a86440c1ea4cb648d2f8826512c75579eceef41bf126556229d8caef0c359eae970a2897885f944beed532cc255c867699f324c26c374812467e3a9de05f420a9fe832fb08487553c1fbcbced327246a0f2aa5665c380c57a031957b4db1936b177cbd579d2b8861fe39efae73e794e76fb566aa915209b06a2cbdb86e385ad76ea9144f5723255230b09cbe7fb8b9c151dbfa653482ef0685302fac6264c8bc99de4eeb211f874cb383b20abb930f621f9ec2753cd23a403109f1f94989c6d52143caba29b53deab7b2cbf76e46bc07cd1ce5fc647f7bfaa35a0d2abf59aceb950869e9578b18bbae7742ee8ca8d8b9aee398ef4906521da7cb20d1558e45a86385d46f77c04f23ce71f488e644f35291c2a67057c44423129ecb8fe196f217ba9723494a6a2481a76c1af58bd218e367952b8c2e8a3d326541083bcf1a4c03b9315b3e6445e30bf528d9e4208ac27852ca526078b5f6c0fa179f69998fe940c22aaceb0760eea5d133736f9e7ce2d231c26dcfc62bc0e1461c1334820bab410ea0c1bb575a8772c3bf43c4faf6afd0f1876acd99c84ba4c6e0063c5a3b3d4c6cfaaba1981f69639e751a15f41e05d4178ad5afb252c7e4984f31133dbea7ef2b8ab78030f2b45c8d87e6ca3d33a87adf786ee28a10dd0bceb1ff0d24c9d7644ba64d49cec968ef620645421c047293d8607584fc161565cde6174843a7cb2514b0a4c9480b7bb6e2f1c20749923f6175b125ac4d982efc15c8923e42a2e96af6a5dc0b4ee0af8b5f3d460d2475e8493591f53529c220b24bd105c4822d47077c294a3b8425dd110357d3f3351aa3f570e006216b5050ab3f12196732f8431d683e9f7d87cc8dea74b2e11d77c87de298111be18e3759c0f71d0fb4229f087efa6c2d97985b91f9d855aa859af9c60ae90b29ce553278b1265604785158c9b28c5e72607c7d6db2fb7c28aa5f466b7903043c2b4295f37bd9ae0b2e6a5002cfae4452f161b071d0096f9c0e75805c89a5183ef4702bd178d9199de0ae11b8aa9b1a24de36592e09a67907a1eae2a42ff38d3228451a3db4ee807ac353dced073af2fc39c6dd99f8f6a7616b0780e4b403854d52256fc361789a0e0dfe18dafbc4facd4b77549148b652b51c960786783546aa854c0df7889c63e9b0789084b029b810a8f95a1c0594f05d18be2a251a11e73f242450e989b202ef1c5c682d658f5e7df7fbc0c07ee94d225588ca921274d8890f7e7998df96ec60179c8285b81e3ca162d298e5d4ed078681337ec1be5d5d2e4f6809fea176269b02d34e823f619db1911f3858e474ffa436c8f489156aba3829cde19441df5753b43e0850093db33f04ee397b074b0a36d32e93b02aea113da225057dfde4eaa5e183724b23da6a88856a4dff1f3b821339c43839343a14c19af2d384fc1e80d0b1fcf9607ea8cddb9eea67bca077565ac9a3a5477ebc278ec123c866eb930acd62b185cf0ff991df43f3ad00e54ed1a42155eecb52d5b748f415481500ca04b537db37db71f61ddcabea9c62868ac991186b36c8e782f1f1fb916be8d2f29ebdd45f8fba53a32d1e7ec8efadfbc366d85b65664fd0bfe8f0daaeeef218808120e79fa614432dbeb29b848000bcba317e05b25934911966fd13b0bc23f3afbb636e878fdcba1d3bcc2ed8e41a969bfe2c285db83d4211e9f22222db6b472590a01c59341a8fd70626b70b5a632d41f7500044d3148fc4f25c549d0a3a84a1d1fc52abfbc7791772c475dcb55ca73351ff694f7bdbebd592c10a0500d4b5312d74027cfaf9aba37d1f4e06706d272d6c228a3cc73192dd0ee1014a6130b7140ec7ebf529bbc534ea6a233bba8a2be41ba3f86b91458da13a0e0d51746f89fb67efe4e6fa71fc16384f8afc2c88db3ed77d4e214ae122dfd9ea77444ca434cacc1c3487a66768e82d9fc737d0325ba53602e34bdeac277a59413822ca6d563819a61d043f2d91c6da5d342a428a8f947af16d74e7c3d6abef69f2119b731a1888756393015a95a85a85dc683b5d2a8ac756f39c1a7f765a70b9e9ee627dd322160eecd929b1a8fc84dccb89213eec9bd46498a71d6872a2f1b2dccee3f992445cda5c9fce81b92c9486046452f50423eab3c624dabe3f30746659d1b08b85f73827944f2cc61e13b3a34ece6150fdbaac2722cfa137a038d0ff27218c92386a513cd9f7d9e5972635edfdec31acfecc2d878779c3e0eddb77637310758f208e4382674313c86fc2d1df6e57deb91a20602aad621b7045c25ff52b480c9cbd3de44ac8b36ded6b6e372294464832d5f1f544cf8fe321fe3330ccde3865886162cafac2f6bae961274ce6f90ead3df4d279de253ca6e7729861e2702ada290d7a0a8a4ea6c4caf7d06d56991bbd1b3a194452eb780437d3b7be725133ed567953e690182c20e1f83876b50a99eea352eb6186790c1cf04f39fd14bf97574a9b8d8f049437839a6e5f6a141748f94e3add3ad99031f3366b68952b0b13e8bb0c904c45db00b3a595ef50b3a61b7867d363a3256d7800dadd3324d9560a29041191305e0f45e1bd21298281f0e543b353746fa4e713cbb2b1e53b323870cea22cd25334536c3fc4b41f75fc78fbc88e4a449eff52791f273ca927df6eccb87d17f188818310d0909e7ed34adcfe57ca23771db469b614157c0082a42ff6182ba646a008dad2b9f9e0159f438c5bbd1decd0eb2ea003d16abeb4c0d8627b3b278d78081d046d3cef2bb67de648f45ada7409ffb15d63665c0a69fd6ee884ca7e43959852a6a83d33bb9f8d4b0bdef75f9364fb0a5d72fdefe4430a0665af942d1805125784170075155059b5040f5d149b7d81aed249fc5a354e3ef27a4a8965ae991f1a4abb6ccbdd1ecf9308b2380b668352231d29bed6f45a9a24ee731dcae81f3e52622ab953ec9d67465587389d5eca6238fe2f7ecd0b2007fe4d2b5557993ace80149c9b07f5e886438157b5bfd607e5c6e8d13bccccb3e287aff21e0c79312fdac43e63b056771a0435193374781787a27a14e6c44e46bf0016b49d4a6af4583e85a97e6204481343f06934c1de444e3b086c1984e9b724e836a9b9aa2362b2f59badd41a2d84931c0f9569050cf973c5afaf097894670c6a1d93ae7ff574aac626ffb95b3a0bc74761d535a761c28bf2067d32767924a58144cc4a368e982571ff30eac35829e2fc82d3e30a5e987caf78c4012194e9c0abe6c164d9f0945d25b93435bef4eb86ced41038e90f5b2f2d7c9e96de131eb6d5e17b70c2310711a1b562988026574b21279da4fa283227d896eda4d683749b3f3d6f6a74f792d90eb5b00e37468b54a6e560ca84020deab78b2944fef0d4f8cb285cdd996cd4e69e84538c379ffbd659185906ad54d31412239471d77f77c0d408988125892e860159ffaee7e0747cec051a0d38ad0419a0750d1eba5f02b4d8418903b5c498604f153bc2367d3f0d0ab8995ca0912be7293e45694230fda0080ecb025a4ec76eea237edb89f700e4303089d0c9bf2ff59dce347b0c9a2735cbb1f7b1b3d301af15cef7c9c106675c7f0edc662198c51dea554918c2d42fbcd17b593bd4d25ad642dc90df1cc5a826e9bbd6fa74a0b2c2cd8320a400b5c6f6dc47d4a6fca44ff7ffd8f2e0cf986b55ffa77e686f1d2e13a1c5e9ebe821c778f8ca936c9a0b122212b4c2132c0600149d30a42369c730d34b6e8912e10eb632c37a69b76fe6719d9eec2d292bf68a621cad58cce8d71fdf5f48787fc356168ab46b3247fdfc62b62d8ae8503a012237b3d0d4f1e57af9a6dd8be9b1a75075856cfb4f01f4b0a7bb8afc98aa8902e8513b44a807e5c160a9d2d7aad6b7d71adf47024ef952a4e75198bd8a231357d2e83e0359c42ec1cb81625c5d12d93d8da51a4e347705dc2ed1bcc52e6834c911455a365e452f1035211f1c1fdbfcf317eb01e133fe6e2489410f238103e23f99f4824024337ef29167e938309245d4b382db87db0eb9aef08c113dd9075a35d4361172dc5ce1a2182c450f41c86e1318f5a778cdad9923a9457a944ae58eadbaa93d0a3910b8a5d6710bae4f29a89ca7c943d9350276e80583517203d30a7ec0098606b79ab5d9d8125dcad03596c706d2d1c42180ca03708fdfa196691be23327595375f5a1bea6fc66e161afd3b8ce3d838b7a1a033e9f86c7f2bca187c309e566e54c72ab25a160ace12b3d830f596ff9696807ddedaf0125656432b3aba11dacebf052cd78c90eab476df6f69437593cf3ae721f904b74a9bd5a07af3226a3362b971f77a628df92ed2ce6b51ce7ab900caaf2fee8bde342f40ce275a0bd97ccfa04ff984764daa0a79aafb023108970f55f4ab3a0937b5317dc10404465423a0314ba1f5a24b0a04ccf3d55dc8391c5db1eeb7303d45abb55b7e6fe39d604cc28b64cf586a5acb5c4cde5f5f52895ea81fffa4c57a73c3138394e21ae0c599416664a90b733ec95e56cbd2f129da78d58273dd1775b244d39597d50df4b63a8e90f87f4a24e6531627cc6f55498a03a7d7d7c6f1a44240f55c9569214567a56dcfc2dd5bd138b403bcb9853eb96b542a6ab5ac0ae6dc7266c7309ecbfed74028868580acdd174c849a83e80d607b4963475983f8f329648f97920467cae6c8d7d3634d4080d2b47282277da9ac04363018e5d617e1bb6dd942d6467fac12659a39fec37f1ca29436bb319ff0beabda41a42592f22a741b5d4b17d1caa5b909a95b258e75117bb878e8d36d7c6f0e214f2c4933be4fb06963ec0d9b5008cf93f135bc050685169495195e23ecd238b36cadac14e8e814fad7eb0cedf4180d32ec054ba257960e0d48e3bf06a0e48672b48281941464f1dda8df9a73fb081193cdc0e67414576e1f6f87a37482cbf2d511aeba6e192ba182b089b6e48e7b319b60869e6eec9deab65f281c8cf2b98842657451c4e3a2c6908b07c379940a7826ce7999be5b18a1632ec2c4f60002b917cbc3dd2fdf1ee4dd14d274c8795347157e021e3bf57f9dd8de300e7bd2fd518a27f77c48a78dc2a1a8e46344d9aa1d6f6b802f726c097bb6df3066e74e243bb868503dbdf957398c31c53a092f2758939589bbebf663cadd88b3f33e6a2645c753e478d8ca18b429d9abe6fb8e0e6926374bf0b5479b74a5e605c65cf97a34a7d76ad7204d219348c966968429fd7ef1f1c50660c0048994a0bdc0ac2b76309d24a22a9e2319b0e2764c9d316e4aacd7e0a7b1e7c292187ca4fec6386337b7d9d3560a5590a136e33d3714e74ead2b2fbafcc20eb9f0d6bc688cc5f281380b9340a1761cfb34a741c9e35d0e1ed64e1b6cdb1413126910ff1d0187dc49d9dbb892be153e7e3141026079cea3f77c2e3014f5dc93cb2eaf22196655ba85d65c244c32d98f899d1c11c312cbd05cfa66b87fbcf9f65c0da4277879a47a13c4b0b31a3a8d08395d965d758dbcf194d18e3fcdf6f2684a2f4f61620e1ae7fef235094b234ea7906140352829766607700d28d95aae72cf078bfcbee456a68a50c9868ab52f40295dafc66f13dccf1069a898c7e11bc1cc23ea97e4632205d8fbf06185e9d910ec05d4875ce69bea39d25cb80f06a9c49312ed0b81ab2f5d64d60e7b04a8865364f94958653c8c7b507609bd51f98afdd48a8b6562b195cb105346fe022bcb7a759791d2cde65de2545dd86bcee1ad9b0b8c5686add2ef56b289eb4ddd37a27fb443c66feb7a2a41faa46e4e3d3fbf1114337b1e68bfcc8f40277692accdf13a09a204952867006ecc7bb5c4c0e3c72a47d26402f1f8c2d92430cf546f75e469b90cd2339016d831229f34ddf44722626d7e9c1192709e82fcd5ef3c8c6df4ee4eea39b40a196c3d18495a5ec19b3f72035a876a9e219cf77a6c89dd334ed5a6a71e60d149be4597beb86c9bfba0fcc739ef2e14832cc95a4833788da79bd5511d857c069c26c3994d60bc3adf52fcc8117616bd4c99aba74f0daf5ff0f6ea838a05c5be2a85785ed67a5f8d8d4bdfba595a5bcb1cabfb529f34956c19303652eb2000bd139f4de35046754480109dbb921152c5d615e83baf8670a2128cd3776a6f648e4f0b953ef39d34200ce2c16090de00fe2d6e0b2c4700680119a6e3797a68f8bcb709d846103a5a7048fbc4b47aa46c67d4d5c8909401682d8f3417e45843bc2c170f654f4ddb3bd72a8782c1994a8187118a82947d2c41df6ff604bbda60ac8802b1cb33b5f4e3aa08a994e2c68434b0a3071f5c2a96b6010381a3a8f74f5dddb27acfa5922885d53d7590a8d1b142c104b8e1c6131e5b0313211dc73aefef6f0f60d3fbfe17c66a2b5e453ea46928284983a18c54fbfbcbb183347b0f5f69e625168c3457011dda0aea3c8bdde81ddcd0087aad79fc8da906c8993401c200a6a5cffae8ba5c64df6cba9f305cca338de25b54b294ec1d63f85c5c708ea3f334dc305659eb03e68ba5178bc454bf091059294c85ab782a46af3dc2881e9ecffe8c6224815abac9a05db19c3f9a96d149ba62bcb2163c7c9bdd9f53c06d93402e968a188b04905e193c62a80912d0a0eaaf52994e300c5d8255f6f9592ed7ed151cfc6b2379aca98fcc8d1cec32dc5881fddd803fe6ed98bde515554bda0e8e249ae44e686084456c4ef40f0132654ff91ed72d6616324bb0b8bccb93182af8ba940ee94835179583977d16314c22889c894b44337e39fb469516e699feb3c1b8de0e6db46c8c2a6a40b3007708bbf2cf10245ac0f93f3164bd0ddf1e23f17c1234b3c03cf50acf64604b40e601cb7b107cef8c0f6ed76aaeda7aaab992674ff7be21fb818745e5ee39f97f1d7b1bc6f0fba9f82b8a4677d6d6df8988e6c03fff795dc68cf2b9dcbd9db05e72ad6122409de5121efd98f985afa23244d231c571e774cd92a7deed49d304b047614f38e3b702f3bdf80da005f0378ada5fd119e7639e3d518a0103ca0b230af2b2de7e6214cb6fc575202693f60711c083402df751d3ee4fd44d754a72158fd2c2cb544e7c4c3b154aa27bc53b9bb3d86860affa0b2f6ae70414ed04443af525e8fa47cd85b68a8c52d1ae1a5bf6d9908da77853c67415ea7308d39b24bc2f905b6f1cff08b5390c36280d6b51f1ab7d8db398e69eff03b3b5e03aecd013baef0604759c0e4676b04aa991bf855bc65235573d584e48ba07731fc54e82a37881b01fc93379ce764b7c65ee9b8878e9abeff14e94f9c76958553e48015b3c88c46c14560bc5cb617dc605365937d322c9aae4f144d1ffb8bdd959ea8e97bad864fed085f513db4e3d442d4d28e0ff36d4910152f431bf9fc738c33344412d5dea374b73f2c562f56d3d5e045b08c39bfe01c3bfaf05fe3f20e81cb6dfa6483ad69454fbfee9f7eca62ca73621111976a8cc67441b9da839a30a2cb0d169cc9ca9d3188b40b4109708e02cb764ab8d6aa91b6f57b5bbec2f1b8926d77c955c117b3d32900bb6bd357b15476bcd47ab0c1077aac59720365f5647a956dfef0c422b08de9ae8a6991791568aafcf7964b52fb91f592a181534d107ab126c8c864a87b4ba913b1dc8d9f6acf68e3e3315463613e2ed5418561e6c2b5ca160b2f093c283ac73f61820c4318e2854e234df201fb33329de6c0bc4feb646e2dc3e40f688967023b455aa91feab39884a12c3928652d66042b925970498e48dccea77d3a1027a3a76656b8925f3b3f50ecbda2981996e8fedd447fca741edf239bd948ea7e7aa7ae1180e2e239b545d8f75968f47fa743c300cdac8eac975a6503b869ac5ac731abd4921b988a6330c51aaf6d45301436d5dff8d5357f174d2f81e0b623ec349447e0f97c0d02c164fd6c2e70d28cfe2e5e5ad2b9494b43a1bbb2793cafa5e61207cec5b75c3941c8f11dde43b734b2761ddd0ec62fb187cf7718f6abc18e563b09a6d5b8a1d1f9bcda99b3d01bf542e4bd90af507cdee1390fdf6a508a6aebb8f833354f7782dc5b9614f10a3f87cd49dce707ee2c95888ac51d37f5e39acffc1c297f9666d1494b2e77e851f4db82ae1f59f9e21adcc5865bfeb5aba2772984ffeeb4331fdde7c50b30ad809033e06776f09992be8dedd8293befa7a16a4c5cc7fa92b6bd11e6f8a422ac18a55e3b599f10e5d200404aa6cbb4ea5b3911206de5f1b2c31cbd58a7c883900119c7a0e25d11a4d5feb523778e8c7f9540f8f54c377cca010147696c44de45028fe219ee479cb2a47ba234a11fef61216db0d61b4c6b60457208ebe515e9110494cfe6902e04ca0cd688c15e1a33b29830e7a55b2ca0c6a42086b53a096967c9c2cb092cde68338763d1e996e9a486d2ffff2580cc14c552b53b39bb5ea36d9cc7f3cb7b6999100787a8a3dd2b3cabd8aaa1dfbb77acf8af3a3175e54613cfae5f27d99c254b63bb44271e5ca7e28a9d2fa260806467fc4bd189558f55bacd886cb64072d5bd8de9c0efa337de921f04d842b64ae82685c9d860a30924d607cef675bb1237938a1d5ab3527f4f310e0748475ee00f1ccfd5de2edfd62e8a1f9beeb1bf9d9b996d63886e91021ce527f6b84179998055c21064091f45cd4465a78a7ef1e218f0f46b2afe9588a092a22365b4d35f9040f3106cbf94eb6e9f301b7db4f7b9c644042bb68fa9253946b04dc26f3737d6717ed2fc4631f25a528bea904d37fc83026b9e59f4907dc3b654154a9c38866e1fd20a7122ee417a521ca5b567cecdbf0157f3fbad215f02d2b70f60349e5b4be4ba80b67b507457857660a4740babfcfbf12a857a9583a330ad11cfce0c3ab14520d58925c32203290d9ed013a520822311c10706c9f9763554a949c46d471d4a4bafb28dd131e3a31aa84d9dd90a282879484e21496e274c0d03a4c783eca064128df14c6963991d22adc0b8f2371aad075a6eb65ee6f0641123395137250c5a0a892c8d01a56b6c8960644fd6960d6f7bdbb5366d692888be7df330ae07e495dfb28e4583881b1c5910d1d8cd4a2c36f01205c7e45d890711ea90dcd2ac79fb0d7ff5159ad8dc27a75533a9b827ead007007d60a5485a8579e418d688c53e4198909df8c45ef8537029b5981033820dbc48fc36fe7a8984ee7781795a437ea83407ff298b2b029aa79d2d882f325829727bbd14729165d7b5dc5022e52c4223d5c74f38e96370d6f4f2a6f1ac2f6f80b9d1ffdc4e983085cb58743c7fad351b44aa378de82440d804698acd6e195945faa248889e1f3b3236bf85ed4471e271925c10a488d7c4f0e5fa3b465fdb3fc807eed04c920dada530c01727338977b425da144b1f3af9d709b8363a7a18b3ce4cfee4cb121916e8025a16d8d1a03f387bc1388b9dff01dd13e43ccb627f70c9b81e5d2aee3bff363640da7fc3911a5421888b090474156571d2ec3a1313d2f5a99295989613b4d8c8dbc1505e67bdc5290d2040a9252198233e459cd0030e3611a9b0dedb56b4eba7fbf5b9fc4b8a6e27db00ec6683ac63bd038817fb87abb12d101af6acd9bff539f60d39a4c76a538a839ece809291ad9872b41a5d6630a624e3070a888efc65a6e2c2e0c7943cfab739c8497263003cbc4c78f7a8ed6b0b82c60076a780bf5027e9777530cd496814174504e58c74f0439207efcf7c08859452e161df22f1e80133ecd20b4ed071e458ef1172af6d1aa5987b24faa293bbe3d677befa96a1768c97236d3931ebbddf96f83af3f947b747b5b519f40aef473c54be5b6ec898626df42754aed91fae04ccdd85b29f084755d32b33c94116bb8bceed014fd2b0d1786d3a4277186f0e53121920c3ebc5149d9c5266df5655dc9776d5aa64463175c843d8e9943c5d9c9d48f6bd3358d18e4656d66689cd80c8d298782427f297c16107772ae55667ad50f6361d8e47e4be9b0be0a654357be9816ba7d91933f3683b74b14a74621addfe511d0012fa162c7c2981ea26d4d2757b0c9de157e70dc3f1b118d8b7ba43bca0ce11aafbcfa53a68447ef312ff4fbb201b97058b100af18fbbaddfa93326cf6742c513e54e2396eb2549c24b539a691c14e218e8058734e8cf2563bc0ecec393379f2e8dffc335f40a41ec336f2e9bd027fb160c6504b926836780e7895b2dde475dcd609db7c9b7bb20de7c4ec6d3bb7a94e66545b742c15e75a906bd7d7151652b7f12e4e3b43303e3290a3af5e16b9af7d17d1a53515270bf22215d0d92c946f59c3add308b3da950770b6f55d27db088fac03956eeceb17e6a2bd73dd2cdb45f7f969ab522fe63f16e4e269c6b8f2d17ecc88043f335a6639c6451efa1fd429efe2dfc8c620faf363a2dbf8d249958ae39cc1d851e40497be04978b27d81a1cff3a7ab515adb30f88d20fbed7e876a3ac66943b9579f877f15a269d3e7415ff653ea60930da9d37ab2cd76dbc6730224edb0c6922ce7864f979d1733df0c12b2bd3a77c84227c371750ed2969c79f6fcc81b72c177234c06c03075f212af876abd6faa75e03d2f4d585a8e5522f9e231759d5f2826c56c16e3f1b57ea753ad97c5672b8db19d48fabf8c643ea1c0fa4de7f4f43d61d4a74e681ca53ad926747862f9c3b5898085173ed6bf902de319199dc729f2ddc8fb1b57177da459c43ea9d2c4fe08169abd7e5ac95a6a590e03d65fd9490eb954e5d7ab2817000983cf29d1c60e45810ef7c0a048c5b0156c357d0f6b6056e676b78e394064bd02516ba0f1e85fe23c4f17f9435e6627e4080276e5c0806144bcaf2f602fac41dc2bef17137edf4b30a7657ac17af5aa7c86534f566cdb600fb9c06ccbca834793e9d075c79507444a1dabb0936cdf6a7fe10c1e432911a84bc41060d5f312990e4c74a3696f120c1a670df1e3ba2ca3270b361bb6e84bdfff07dc9e6a41f389880293b80ce46fe12d362a1f54d6e389e8b8d0144fb7d541dfba01995dfaa2c677b2214ba8c2dc4dc74836a9fe5b208c68863f01fb8a0a57c3ae03b2a5f40fd41e5efbc7aeb1ef92c0498b52567f7d60b1aa7539e4fb345ce27d3bb92e23712c871622a849cb2e3d960d1e7d012e41d601d877ec3bbb67f283b0b94850b4216c2ff6f67b0fa238c15b36c512e59049a2ab063905ac97c6cfe693a66efda736e3c81c3463f2386a7cc7badb7f297e03650d2dcbc8ca98ffdda81f59ebc7d39b479cf8b9a68d0eefc0e5005d4ecbecf8d75bd29ee2706ef719b3cfdfc237c2b61a88c328cfc0b491747e2d16396b99b163e837b443959e01ca901f81238092c3d5b7f14d3d9e57e78f14a664e54cad5a6caa6b3a33c158f416a0feecd63949a9d09358a4437363ad06a25f867442191f0b05bf31b646c09d7e2c7047f2d1462fc1226a04116b702a201dcdb71c5134c20e94eddbbeb9d954c79f30cb73156e96a661456d7060d49db8b896448a1087e7fd792b9e90686dec715c35a510985c9bff3d2bd26feb25891f9951832bcc8bbc3fe2cbbef367c7ff89f4ba8f4c467b2ebeee1bb843cd011614350f34dccb3e211914fb73abfe4aa4edaaa2f2dd73c1b6f937afb22fb2053e65dfd1b09a7800f58ea465a53801647e3085b780e3806de8ddbb46af8e5224224f088cc90d1fcddadfc26844d14fa5b5faac9a7cd8be458b089b0b76f338b06552c0a6cde6ceb389d7293fbce700e8667757e81cc6e7645113014746c34febe672e0ac0f60090f76bbedeea3c7c286a2e0ed21c45807de6b59bed14c71453b09f2b0d92e884c5d223d3cd0e2af1c8bfd3ab411481b5bf6ef6c125987e1252f9d8bac055116a85577aa3bbab17204a992f8f0c48d4e72bcc866e9e889484cce0dea4fbbe0fbf0ee19fe6933051c83b6332b1e5f627a54b13f074bd5bb65f7dfb201b8c81acaef64cb40109843e9f96d53230434701040456636c1e680ec75cff5be9f92fea6818f630075deedbb4e7b688bc996211da15085c9f02104eb388533148981a4258663779e0cc5a9725c80d703d624ceba4af81e2385672e8250ae8485c0b878d8aa1e3aee7b9b1cf7392905f306785cd4b4a33a9a3b57d1c90025f5c4f2ec0c9e6514a2681e419bfd30c2534796727b91268a76d7f76df98f894f200faab3e444cb2a25705a327ec9fd53f4859ad2a3f1b96ab78c8ede1e2d36a08adcd89ca3e138b03e5772cc83ff270c619dcc1883350a025337a2a0be9759361442a6855d8d26a437fde61c86d0b9d204e4e038dea456c6a2349d255d930f6de346ed6f5ddbdda9c503cd6aec0262a5de0992eefdb9cc652533a196bffcbfdee2c70de19231b9f1c81ade0ce10d21dafb3d7af02923216590f000e198cf8d2564f3443f18faac1e3f4d5429a4bb61b142b56af695e4c46a478b5eca975f346d4604be521d25aa46051954c831ad3efe592010c8cdf6fa0376e23164d93778701a1d3338b3fca83e4f2e7bbe1ff6b1777beaf38af47fd8e6deccc0b0da08a27c49adbfbe58a15e0409ca57dac028c2e001d0c65eeb4e67c2711b65e387c46f3b047559d60dd261014334b9e7bfb2a16d3a91432c488f720a2fbf728c92bf60795a01bc2c5f9b16d391390fc1080029cd2354784eb3c9c89fe0a3f0800e9a9f6a8973b66a48cc3380a18eb1fc979ec9c9d012c7130a00897dc5de6379b56d5a9cced50baf813b9a4a247bb1adb76d8a7b48a515c27f3661aabccbb067db5e98381e7dd5d710d4fe7a76e0829e9ae559416a364a7cfc2219748ca71251538b4f4c12eca9e1b808617db934312d96b9b9321854a88b705da1cb610b81cd3440c1cf0ebd66499423d2f1768d122e0198ae55a2260fc96a1d907d9af5c306f151620244520ea21ec71eb51af48a0a7687a4ca93963c0ea71900dab65b3b80cbf3bb7f84e768fc5aad62a6697f4271845e7b5799bb893b5fbfc826446caaa1ad5eb264980f42a87d1bf1869ce0a2a0b12ac701529f7d7fa6c64c86b2cba17771717346ee27cdeec355c480ac420f63045dcd9de56645300ad981e752e387a0004cf2958bfb7a21e4cb0094a3b46531329167ed3a206bb2694ce306d43f71f443dc233395723d596af087d9e968e8a2c121a2dbadc74192775e26ba2c6006d47c45787b34522b11fa1b8f25717f72ed916169aed6d8c8c1432b5eeb0fd4d1cfeb86f8d70113ad5f803e9088e95d2957153eb102f08ade31d7b862ff8edf77860815e7ab5d03028122d8e2d912633f3c8bf043675144c5223625f4fdc9d330134f9cefd91a24eff99863e02cfd2b727501206eb9f08e495df7a1f576db73f1e40fdffbe234d8a07a712644424e0bdae5ee0cb899f1d505e549a51e72c818b0177e71e722c861851ed696305ad3cceb0c0444f5cccc33afc92fe0b6352f72770d73e8c72dd61d987e753481a2ef3a2e5cba98a388f24201a3fc6af7aa219805d962bf094fcf586843b76421e3ba0009a83e9da830366146e9cf3ae5d5ac211b02314893dde5d213be2ad4452c3d80b4039ffd7e3a06099c2efcb9928928ebf355ae479e5da5a64abced21129cf3b38772c6e8ee94b58639353764d45f57d7be32fd2826d8a271bcaf67747ffac819b8c2c5596cc93dc447e3441d0f1df414698868dd2a8b7600064301fec57253c9646b28dfbaa52f81e3aa4d54bf3a804a85ce34446ad7f83183e26fbea6897e811633d92680059f0358ec430141917952440fbdbf894f56d2ec7ffa1a35f756d2a3b983768adae9318a00e5df86858373250f6ead25c9ceb962755dc9416636e858b05adcd129f0f717abe4e530518d7a99f6edda08c1f33308aabbfa1ec53e95199e893248667283ad38018ac26066ac492cb41fdf8faf552a5c71e39b8a73b780e219ba09f3c45039eac93bb73ebd0648f2ebedecff417423d3e59628b02455ed9d542fc94fbe9578cd9c9d279afde44a9c806c9461bef6551cba0dcf05b3d9eb73d901b4a0c63d4404d61050b87649644e6a461a81be759302bedabb6741791494f7ab64e0c2bf6550ac8b85c23f29b71b1b9000df128d780f24b6c9f761355fbaf24f75ec5b7c651c6429031fed5f41818d5a86e45ee89a1369b0cd9521fa17cc46a660d4cc3f0f1b590e6ba46595f6845d1b24b4ba3dd69f0c44caf228a93bc99f7733769e31dca00d2ee41e780c260971381e53bf4f80fd4313d3f004dc183009978060f0be2306676d36e0dc8b1824081f283f5c8fe2707b30586abbe88d66f159bfa19ae79a37ae6bcbe3a9e8f3191c98812adff8d4c19604a6f6555b26df864bf38d72acf7ed6ac9e324ec0c2307a154c307af66e8c270e69f641bf7a95580aa0e8cf359516a0090eaf849a4f51a156e6e9dbf57d5ef4368b69e81f16f9ea37be55beece1fb7610271694431e02f6d0a1f5c75ecb762bcd83dd6ce3aafadf4f4c0c482b4ad091c60d3732f895c07a17b11d191fd2c40b3690c91f9f09dfe1417d30ad45691acbcd57c69779cbf0fc59c0cd40c9a254c36e83cb9ae0ccadbba839f6e1daf9ff375ff1af486e5fb6de564ac9dacce7f3b23f5ed4a3468a55836b3ecd4587b36c75f98804a064df25a094aa07da79dd4624d1c98367d121f991e41b77b46200e7c0dcd8ba6183f445ee9f15ed19bf6bb3d45d4e2c5da128b06ed7be207138ba2ee61e06a75bddfb63cf59731551516ad4b15024d2316bf6e334bfeb367a60f2b198cd2ee101eebc487e6911201f23a8c129888e3e6ca63d7a4a202f8ca5df24bac0529defbb55e657fdb7953f803d3e4f862f0cbb88595c20a8ce5ecf5fed384e2826995bb55238e06947d02358e1f8c70c07998e6798a8c2212be12f2579fc436711abd473e1e5b7aba24f44da3d509124b1fc6f41c7d8d21dce233efd30d67770fd8a16429d39a89a1ac4b6725907695d08097109ca8aca233b4340b4957e68442cde5cfa8df7ca9977370c530b698ddcf1179b37919010af0d0dd5b2c2f892349455943c004ef177caf653091a3399c23c722ef2687d891ffc3af451b4ad1dd1e6d255f5dafb3ebb2596d7eac32a85fa55fd9f3d569d6d6cc342d24d9cc967e01af6d1079c4a59940d6517cb2f1645a4950960593cfcb9a8194b8e4cfe51d7034889f9ee8d163a8e175bddbe2de9a0209fb01e30b2201929147199692288e07ef3e455db17ff19778a6558680fb3c8160c06f7c898ec38a6e7587bec0b4353e2d339e6beaa86c9bf6cb1f099265e9851cce96770152adc238a31faa39d6dd4c518ec876c86359ddfdb176d8c0ace76faf278af766fb3e751155e3d51b7338d27228a6568060022436d2ff0ceb8aff9923481ac842c2838e3425f1f76c641fe1ad90d59537a30948fda97b9efa44f3077c0cf80ef3d71ef35e22e13fb65151f7fa42ce3d8b899d1e4a053a111548ad9210e983ddd8c50a95289d0d18ce229efebc1569c563d9a285aa2624d72e3122e359b06a2bf0ef5cba64592152ce2482f29ff5bb1485c4fdc28d2de495e44f4bddebbfc2d0f11dc5a44695f93ce20584de6913beb8c4778fdd1214f5d0c7dc4a97e9016410e208af5c2ab7e93ad25f124536d889baba42379455ed81bc110b3cea51998605aa9afbb4cd3bf9a6a62c9682bbcaace3796142a84d6f36756b3f75b249","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
