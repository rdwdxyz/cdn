<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf04aca0e749563381de4861ced87a7cb3e5451cdb40331cc4d8f918aa30db19a2ea914379445688a8826633de5b1c6d52f7c1699108bf3b12a9f993693a739f2d08c6b7833dcc8207f94f2317a1b05d45509c94401bcf3a03cc67ee236c61bf8e18ed8c5554c5a44b259c005ecf1611da7758513c5d67b43d0f39efc47e884b47d64264aedbc046a55298f8cbb534603d9973e5e740fce2296f126d64edc0478ecfbc747fedb63b0c46bfc6846ac309517f9e2f58ab1e844f46865ae3ffd92ad603ff9af2f6342ae332806a1e1c473fdfb6af9f8c0edb58aa8a05f22b0bd2eb0d5bd30d94748924615537adb75de5ce9d542f988bf60396faa715bbf8238f8c0d8f0d8c0ac261872be8d28875307c741bd49225acf1b1e2dfb383e11b16d8eac79455e043d8be2bbffdb755549122ec9f89dd8843d53a94cf6aa4d33fbe6419aa263518259dd6ea6f0daa44c0d1ea0e9a85dc95403eb3157cc469d8983cbb62d3f53163619dbddd39f3ca2b542fdff3b82fd404b00ef73fde1832ac701f2a9b59aa9142d04a7e61090b77b9bc283f1e2057008dbdfe20346d942119e0f2a448406cc396ee57f77e49c9b03bd365f551d798c34e1491aaca8e5b148be2c50e0c54e19a2fce028c9de010eea16d6bdd144330ef83984c6d4632bea4166863bce195cc6c03747e915064c4bcd449246383a3ddfac258d95409e5c152ba8d9005e0b46b0091d1b67a606cbb555d68f44ed11a92cc984ad9696aa7d6e652c50ba2603d56532d96e99001b961c7a592577dc5277abd54ca27d11028168e900b29cefa1c223a81ca31948b20b491899013732c36ae4edb65b17a28af98d730a1c7238e9e82e8111de90c9d3af9be7f3adaa3314676955845165c2c0cec744c5d375b0a14b24580885a914ec23121bf88353af38b84b67440ec33920aac8f8dcdd74877430249e0258e7966d5c468bbf9b9ee9cf00400bc73f3aa27ec84eebcda116a1815bbe348ca9b3decf5fadd5da7a611f370776599e117798b0f0924c045a93ea6ed66df5c16ca5706838f76826af052c7233c3c0edc3e0bb21fcb99a998147bd0cd2db9061119ff716f8bb0bb8961b404efb2db758968903a0b633a4cce746601c864232a135eb52b84e8189a0783bcf3cb5a223ff13f7c451dbcb6d107be83b12d0e038808b4ba3c2b24c879fb3a2d1f97e31d388488ec525a9e715fb44c4797ff348fd7911837b05a37165114610f0badf8026800a56144b63ac48d153e1b418c5fd478dc48fe9fa2c3abf437713525dea39c2b096241359817e7780f1b343b4ed335d9d1108be73fbb113bde47cf03ce8b07e8c0ac369839c814acf283edd6c1409caa510df4e5d1e596699fd242f4da8d89ce974cf4417e75e64e8cfb7067cedb3a190591c5367cb9370840837c8a69b94e174ebfa75dea7fc3764c8b76efb12a6eb985d97018dbe902142c9abd841336f05019cf4318a3c21453b1cbd6eea2614d1fa818c14fbb38a0c2dfca34776a40e2e518156e4500e704b915693cb056f9780b25f20b55724114e67c8c1d373632634866a5358986a4a45a1ed4ab373d908b4b84ef88f9d5659a36b1d6a30a1d913c1b4b74b1265ece86b7654c8ac2a972855cd111cc83a1277f0444c5ec7664542e4a3b6425262928b63b4a8074712d50bdc00961725f940eec3521f441543960f389e1d2f38ee9dc48adec68451abdf96f5c60a7c5fe7bd8b47e00bdc29156bf61a45f4a69c5554e2479ecc6cb7fcd13c720dfa03f0792cb8b53e76deec7cd55e773fbb604162d714644a766df5c2785cfccdc397e2ff73fe0d606c416337e76fb955c5475acf816ed71d321bd89aeb107f89b7b80ab2dcfb8313911021d7fb18e8842720e64068bd5c8977ae20070634e70c090359cb6206612cd21ba4f3a6df3bc1f5e87577a642479352d1cf705580cfa9f3dfb4e652d58c708a11a079f70ff891d6f0d80e4cee8e91ce4320b55ab4f87dfd5a37cd3d44092998801014a53c2a47858ad77b8544807c4c2ae0200a9566c44ee30c55651c248fce2e9adda2a630883f69d55818081a54449f0ecc13382c4188523b6da4f1484bb84dc506f4cac911d0172858cb6a6f2d6e87cbe90775a204850504183e18291f55d6a166a1dd632245c74b6967bdc549b7ddf65a0619df9ac61b4fe4d16f004f24a8cd574bc2bb750ac01188ea5224ca331e1227d933489060195ffc2392827e9cd99f6debd0b248efd744e690e886d24b4e7f3f8e0fdbdfc598424b86d2b3e87f82922dd9deb6e9ca84e5650f6d1353436ea4013d2d59b8f55d6993a9f21d72eadeee6be98eff51b3224f47fe906ae9ae149e1809c115c90cccb3678ca8d9a30b671c34f106f5e6f7d2d91012a436c60ab7cda283b611a173e233347ca374d72b3b0fc364747071d02b999ecaeb459798283a1bc214280b00a5f644fd9ee82a5d83619918d382fd889e2b16fbd699b0e42b541f5440a2efe7c4f26eb111561aadc45908a3e8eae73f13c847c970e4b2f371b45e25ebe3dd96f8b107af24535fe4b4d41c8f2577b55c76e72e2eacbeafd02eb00f251111dc900a11c272eec5859809d4e2914995bc96d5e76d2243bf866421f7b5d48dcf9239bc43670e47237af63f82036278f478c4a9b9116443326e9567fc5caeadc8dd689ebd72dfbeaa37efdb7a93d74e2c84fbd47661fc945bce79ac5b1be3de521f782f6f2cc7c788c13d90f654c4c2fba6572d9a4dc23a0889843f8b498dbc1218fbb9f612a7484bdc225e8b50108f3c0fb519b5c90be6411788015450640035f81dd37dd82b23f83ecbd5fb460260fa63d473dd5e55dde13cd17376d85f20bcfba1d5d2e7c2dce9975203924d9ded766a7927a8153cfee8e374cc0bf1054a97bfa80f47f3372e00bb4e7eb4410a7ea505ca31d54670235b838a82c4295f04bb8cb0fed14fcb4376a6323b12d60b12fda844366ef4b0f275936b6c37735bc0b468c0f0eca4e245ecb2e5e364b0cbdcd28bf389bb7d8346b81a1865f2680925689cde73def35b35b7adee40ec7887c00fad1873b6a10ce1758f95cad1ac34d08956ec9a31867d46a19c1e313d340226f36eab948e02e0649fcec9042b4c9dfcda2d2ba81d36ce020c331b17e02bf8ecffa06286deec9f2a435793e7523230487249f0dafcd95ed0238af332cb5cc6407b5b0cd07c83eb81d7acca8e613408e61ab6c9924d727cd4400982e6ab4eac3ffd5dfe271c9301d9fbdbfd7e8b1949666e81c2e1b2ae5f3451212fe2f53df6a3e2e49e04574bf8b8eb1c3803441774a779c7a1ab43f06beebf1cc5b972b94da84d44572e2375b215150d55d72a53296b065c1a16c462d96c04e931640cbb006e470d347cb3f01ad96d2ebbba9715de2693fb314548a7aa1a12524bc7e6de08426f146896443363b265d55f2a363b2c81a7e89e763b1b928595be56df6ef1df71ac2fd424079daf99172041015fd8435ab103728b2ef7206a30d3c35ad63a7ddfdcd527ff3ca56c65ab30ee84714f3b514456cd3cb3f3efe18ec4ff07b882608ff6624dd8e91d3f402f799bda6a1cfe52bf2bef7471f553c1b8a8e24118df8b2505f5183422dd92d14e8bf67271e92cae8c65fddc9ce1d90a39da1692a1c8e0d46bc549ac5ae5b5b8600fcf9935b8f8e54d870d44bb94e33daac7b8cca31d7c0cdf27f42d0046601ae523a7235579b1cae31f6782802d9dd30b63c19306685a6cb791559048e29310d80e2c50461b7d2e875924d6990ab8e0e4cc299b05f4a7e3183e1d2a02822f47e5198b0c9df7606ba72c84ad631b39796643b527b868bf17202f720388d3d54302d00345268026d202bee96889864189527c4e13d13ad15d04620eb58cca21dc7b87485f3ff69796892255e9ab07d690a77ffab53af4a4237aab5cdf3667f722cd98f909b0b7042a49d53ef56c4cd736247f0b053fd3b4cffbfb6a4efb2e7fede81413fbec3464f2cd8c8354e677b097de5c8ae2f3e59d6add388583164e6200b04d38ed07dd948dd47e42c611e6af1a9b7a3cd1a526c7815f94feafb81f7a0ab89b831eb814fa913d9afcb02d9f16874fe7b9e42ea61d4a67c80cfb22d8c6aa3d37f07438a3f31245ca6ce29a9e9bb10999d1e8dcfd0e17c31e00c0517ace20ace12cafa2409ca7d9ddc2a9a977caf66f55bd3e744e0c5453efd44c8c8de54e977d2651abab4ad7a7b18789cf10d39d4aae708132a5d24ab655b6783d34ddc947ab2237dd30fbb945a2a6181ca97b57fc6953e66e7c880dac018fc581ce0d20bbfcf5b1f4504634dd0d20c4c91700b1328249af00804e958e872877ba6687a736d7cc8013069c872ee94068fc697cc76bdfd20f89368c092e82881e96c8a3b6af93702789a81788c397155b8a0fec3855e5bff329f7cf0d4b75f1275e4ff19847d3096e0204a17ed9bae1c087ddae41baf60724a3ad5bb321b742ef59c7c486db5907c889ae8eae6f280a75c435123b2af20d8d4615a8daacc9bd7af95ffd4f90d5498335dda85cbf131c7435a67db4d20732640f3c9956bdfd5ec6b31c3b48d500c3cfe1ababd32bef1219042530122ab75d807c7f5b7c7f2671abd3e3e8b45e4bc11878eba890b76ed526739604319275f70e50b3c1ff9458bfd4603a90a888dba7b5ebc8107c42ee51ddda6133e06009ec808c2a173402323373f44f0899d2048e2bb2a7a7370a2bc944570a9344ed9e8c7f4bba9aa7c109c1c5fd1d18d7f8949db205c5fbf0e5a96e3b6267bab1629784ac558074d57c93709848222e0cd11fd71a75dfe1156ed706443c5e665b87dc3dc893b2ce69ef9a2113a88220cd8bed40936c48fb0bab9c87ed37cc68e45a3a0b6722c95763a9f7343faf60e5e4746cc3cdf6e2c43e0de792d2cd0e7b7b9dc87fbfc700e3c897317da86a426294327550dd69eca3e115801424211349e4d6f8a5116e0ff3bc9061cf16b2ef7e5eec22681874efd643171cce1dc253213131a35d1295e6385a1a15f0a1f16246b05a3bc243e667f7c0da4d5f0e44a9c0d1ece96a79ec2530871a09a30d0e1b2d1cb22cb9d0517010293bb25c9c24f334bc146678fd39e73ace2a190492f9170ec9a602111c1022b9e524a82c6d2f34525339456d714a061594d62151188e99d0028d153fdb3544993bc8d0b0ef19c3e4d7837ec653a48f0ba0e61dbb4ae7a0ce444ef67adb2189898e2ca5c97c92242edd4e660d05671c1fa0a0ea0fcd248aff9db7315457c3c9f844b0777ea5cb1c5f0cd447a6865f6b93df80d1dbcf6b1ade98757ad815014371087a9b1e5c0fb501d668b67ec712f7abcfeb0c4d2cb038adaaf515af3ff2b0a4641b72259fb2b493a68a94f287331967f1c21368a7dfa6b7a7eb29f4a26665a3e400772761d89991e83103ab56bd221da4722e54f7093ae8bdd4e905cbd7d78bacb46ce1110307b9baa021a36e07fefb66ce9a6de3762a2d42d266f1a50e43cc0ea2a1ea552dc63201579c0c2fc7df46e7ccaf90f058c8a99a18811499e765f8b3e69177361f8035dcb2c8bf5fc8fa5448af5cfacb5577ce0b8cdee2ad2e86d25a3769fe0e735b9f360efdce084df3170f2248b969faa52998f1758aa8d4af83615774874ff8c72c68ba7477d8ccb13b9c3efee5ec8cf407b25024f7d1f5d14958be61ea8bd6a0f0b154cfd2a1b1a192d2d6461e1edf4b39686f7ea475980001ae1264fe2a69a2ab4373a2c628f274ddf89cfdfe1f6d31da97976916db2a78c2e1fc86dd2db17fd62be492dc50ca9533ebe953ea162cad9557c1f59b068a7ccd0ad32981a8589728ef3c48188067c919640261c05c8d62c3f8bb657fb4500c8b3507c9e70f228a45d048f19ec5eaaa60457ffbe8742c9f525f5938aef02b558a32a7d97b77dffdf70696f4fe1c6b5b39db4aa6e4a6fba57ffc218f3169f90db81f5470d84aebf6716786fc96d5fa33da1bc2ea7bc3df83cdc2303456a7108d44ce7b0b28e04b73aa62a19ed800738890b4a12fba4bd903ffd6e2f52b9bd1fe4d5438e0e633453163b764cbd040f3ebeb9e74434283bcbf32e6b3d5cd27653b7d90992618e73305aa245339b6474b4ce5b6fb1004a6e10e110745f1f0a7051147a2b7c260e8a9feaf513547acaf20bfd76c33f31b442d88078b5eca99c9993fe215a5372d193398e271e3c6d7d1466aee5013ca319538f9f11f002be1bff81b3f2a264301941c00eaf4122cb86aa2d6ca7c0c8fddbf7b008e2c1efdbcec60a99a120c50dcc70d8e393c5140b53d43de1f26d6a9ff0990167cdba9e03662ffd18bfa7d823468ca7045dc21047adde8d19cc5bd49d83d53521e8fce807b4e2a22cfdb5cc6a6260eeeb0f3237bdb6cab827a0d5aa85d939a3aab57294578efa7a3c8ba186ed9e299188fd29536aa45d8fa70c12476fc28b4f789da317236f367cda0f68e6225dc6089db592d3ce62cc346d6b8b0bbef1a4ab29739f8e95b285327e7c95ede48345deb3dd3340a07fcf5979ae3115e378c0fec1e5aea82b1d65ba6882df7c52110c43707c8ff7f09b153c21708eebbd8ad183d6dda1119a16ad92b83e8ff3163d74bffba3feb8ef2b2c6e3682e85a06df1ea7fc9a82f17b19e2e2975244d9a2400e8a5e6f54fcc37901c73d88c3b31bae179acf9f7eb89030e64c623d1faa719c7ddeeb45e8af21a1618bd563391a532d692071a5b26328e7b89f81e87a85650666e9672ca4570eeeb2863bf66721752378887e145469a43d5ab70fe858090286b463b9c00b20aa53c9ecb93514cfd48bf97064fa8f4acdb39dee205f18b0b8e6e7816d827250cf86e2844cf8364da03700c22cef379ebad0fd388804f5d998830a1fe2382a1486072ab26b8246e28a17df487be69716f4721b0b54deb74a97c4852b0c3ddc26e51000d3545bc7fb58aa9a5f52aebc3f4bc6f9631193fe4b648ad7c71ce31e1f8f9c34ad8499ed8f5ed228fbdea5e7b6c5659076d774cc003c7e39fe394970c4126c7e7b2bc6d0b2bab5c26d78b9b84ee4b26ab801bf76e92c6906f7f22c42c991317bc7fd401a999c7734d76d15933bbfd7f4cd557234d779485f373bcf9616f1756c47cf1636f5a1eb3ec88cdcb9c61825c47ef4a8c1901bc211e52b0e868051afc64ed50d96450199fd3a62ff0bacc88e5c3eb60383895d432e15c564757a5d5d832c671608da060ab5a6280443cef4426e0e7540ae9bcd8075ac606eee9ac907af3d2446fdc3332de457d6016b9ebeb312cc97f6f28482d29a73a877e0e6a60975be16a46dcfb0d5ec3ab1d3ab2f184d34afb579b2ffd4e5b7bb7ed528e1348ddd51853ce4446d8fcfcce8f85d9705d51d272a57881464b513e332f9a9a37589fefdcd732f9a6664abb92fb2b207d146ec7ccffa2fb9d5a0129baf8d70e66edcca82568cd1900e9516f8d7d6a6025995233c7d47781af48bf03866eae864da1fa83b7c0679249972c74e0c5d810cac46ab5c823b582135348f7a8d7afe2e176521a5d927d9a737e5c42ca7d8def99784cd932e27c1407505bd2873f5e7d34f9f94ce0f89809696c8974643d176c7c191714a60659554aea91ba9f66d9967a2ee4b106d7af859d99cf429f7d8f80c410d45f75d6e9a44b65dcd1c9d617e9d59c14023f45b6f659eaaff87ce72c2da9e24370ee5f00a061690ac9d5901b4e0c62c3f7b1b76753d18417362b162b5a98f728ec3d57d90bfd047d17b8562eb512f54ad828a655418b1803934c06ccc92590b9484008fa89135f6e6f3b745ba75d9dd3402008533e0f684841a5d97864e462a8fc281525c4a017b0e6aa2f1996e52c451390617f24faf53fe51be233e6485d14a01052bc1b18c6deea892b348250c8087f3ba7a48cd22704e7de52abb630706db2350a35e9b24b71f2b9f6ffbdf1b9045e8a2832dc48beefb60a738aa9ada6d0d39bd4827523883b0c699f889878a89a9c75904615fe36eb439ee4a4d2cde65c73145b057bd297fa57decf54f4c6366c3bc4281fe235f3eec688fe9bc877bb4f03a127504abfe67d724e9568a63089260b9576eb4d498be365d1e34efdff76283043bd90739fe176bdc74da6eb2f927672396a53c8c0dd013425018eed69182498fa0bbb595c0145414ea2f13b80601ca676f62774779a4dbed67064409aba50c4821d39ab2e29b875e1b49649a164e2263daa865fe2a8bf030d230f6bb140366f084fb659a26cfdd764454c065491036280637107ba8b58c081a57d77c1bf10724688a443a513e36800c0e1010a488348760e6660e3d9fe48b4b56bdd600f91e0ab20867a0f44a92c8abff79af1b811f985d66e15f7c9ccc8c09f277b0f0167459bfb68243a686ffab2c42e14da6ebaef1c8e7a62d5c131ec63b0e6be6969e082958bd3b5d256f453f4a982471bf758360a91316f387005dc577740348de36908bc6c48b648b2c7cc29991b041510aafa6dc4dc126984d74c7e75e761913fcce6ae59abdd03fec000237341ee97c9b404d94724730350b85611fc891bdfd135fa4a1b8244e61d0b5550f432e306be9531f1b517e929e8cf4e57e3814cd033332e6688acccee332ea80f0622adf8fd7f2955b8dc14c6ca4d8f3fa78e6dbe193fb6e4a58df3b8fd7b6489ee4ccd8c81253c0b451f99f7cbaa26db010cfdfdc15a1b59f730f5fd1e4c92eee8c06101d71f09a5cf4e29c2d7aee342d35b139b615d14b3cecbba93c4ec8f916771cd71f6bf10160ddfafe820c3f26d44ebaed051142101f73984b280c9a80d854e8b4b49533ffdfa121197a688f304b4914b355812fb64310d0d84017f3266587b49498e0bdcb071d0eb2f96da5bbc573ecc0e9a8cbc726a5e553904c6954fffdcd049354b5676117b89d8bc44634bb722e8f8a7e8f21715d40f22359a476c7c6c1a1f1a28bb3b2c6240c3c20660fa228a06b9c55759c8902f03b1fb475c53544e9dfcb3678a93f3ec23acc4636c658da991f8c995f3423aeb2bac911130045bd15eef549f58b1a0e41dd2649f84b149615f66f488cdc704e3761659e631943dc6878855eb291502349ee652a1aaa9e6914fdf49797b64050206d3a9b42c315729d48bfd7242304fbefb65d8a9010e1edb6df46361e74b4d2759d3a14b29f6e6805a7658bc255da9e9524b451438356cd3ef10cc89298c2862998becc00e2ea556b5c28de2518d680b6bf76275396cd46d05efd2eb962452c66918dc614a217c847a9efb2cd9143619232e595860979b77be17ff2331879b9368e50b11716f0f24235e0abb37935c2460a1320f062bf00e3738c351a6be459c78e94e99f9e75cfb6ae5e5bb5426633ee0c45528607b98b9baf6bd50caa77b8e75a6e9b2a6cb18bd68c308dc65fa1bb5ce8bc0052f61fdd3f08186448de5c67f330223c8a660149488b01a347aecb41f34c903489d6239b02dfd023b922a3e4fd23ccc5a7d20a484baca8d6b2ec6ca79e5e0b6666a29e7629153cb3899db90b68d50f1bffc014c33f52bbee102491f682ee4325d8e7c4d8b873b1426cbb1598a8e0824c293945f2457451caf373f3825b6e94dc3363ad43ad2a4c346354477910526bd6df667b61de863325548a19080fb80b2b8249d01f52a037597e328ee691b6381c42733bbae18d0e44948e76bc5d4d2f23dfde77fe815d0a1d1189fde73a8f252660443a0c324066277975aaa4e4d2ac20f8d6a2c0a3077c00b33d044e46ca74cb4cfd842d2eda78a68947a88fa2e4104f31d2029d1f432f2eadbb92edb3ab3a9db16e95b78be0dacfbb83bd9e35bf062979c788a2b508afd08c43e6409a6e6aae67e2661c2c06399c6c0fd679e0ea1cae5df8fa67f8abd5710ffb54f5efc4d291eaf86e8937a5721c49761d4fce8db79046c12a10ee8a8123fc7d0dd26aa5e9c6d4cc88022f164b753d335f740d6acce4b7e130b753b16f2c57eee58863e1d50c6922bcee5efee0144fc47f9cef0a0d5550228623c5e896135e99cfb26c48cbaea1134028e0426280e707008bf38d402660d23cc93959d6e07f3233bd3d3e0b8f76e39f1c274acc5bdbe0f59c1a8b635ca95e1cf35675ea8a1861c445bec2e7f01effcbae11507c02323356a1d699e6de7d3ccd97db4c67f613b3ec3f4eac5af04dbc45e601da91171b3f1b702b279ea84c03a72ddb102c96a917ca4a5bfb59dd9963e6d81bd6f6ba1c6cc7134a5ab12646cd1c339a5d33ef65203a49f85c698c7f23832b6f5df4a23ad651f32edb55f23c56bd8e72bdb2c99e24af3cfd572f972d675da776baa4332e4050945293d0b1358948f9141c64b38b69987236ddab231c4658a030a8993f7b1e251a36d8a081481a3b37a4bbab2e4844b10d3c8f9145848590368a674b5e452310d929f588bb2e33f4e3157f370fc323fc514cc6196bcd1797dd622f47bfb56482888eed8eda9610c2bdf260336bc0bc3f5e0e2c079854fcd013e3c60d962b69be87bad07394ec6b955d2c2a739325faf3db32e9e153c27326cd3fc41fd03b2e57a657d22dc5a0f4880d045e0204df7a2c7aed5cbbc87b8b5ddc56f48d4f56eb909ea4efb7c085eaa81a1a35a235474ee9cd69cee7830fc684ed68177ce0d4bf875e971061123c5c8955a13cc7475109742112a5f21593269e81c03c9d90f31dd701d5710836b865660ca79702b3d9a54851f37f9822b2530abc0b347d6fce28920ffd7d406bf132a1d0816276edd4f21ff0bb20ac65f30d038acc6f01a6afec6843b1200ca0d9dce871396ea862bb100018685f045a41094b3701a7023676be65be9af5a5cc22260ee4c199ee44bd8e246b6503fff912c67424625b6a1409042d8717d889dee9c85980f76e55900704bd70b27e067d9010ecf890b660b2c5b14ff94ed881e57c9c019a6ad6fb84723cc1c17ea6aaf241e39d4f283f7b8a7ef1652032995895fffa7f21dba7bfb890cb256e6965c52861ef110962637e1a58bc7df0657fefb28fdb16208e65740568a556b5782ba48e5e9eddff752af6b4f1331d51d4c3f865c3b01dbacc033566be809d4c7e6a02eb4f9250f361ba36dc9e906dd775870e1a4603a24ae48b0d42d2a34ae3c06d78eeef1271891db27924a59c9117057efa4d08063c93df60d41de12937c97194e27d5403175c61df3d1d810d292bd178f3867146019e2dd274ef41f9d82ae44c75d48d252e85aab1577fcea496c4b417046c510d228c2258d5dcb9d5b8d9618fc0f7dd18787fcf6f953b08fe04f6476628b45d0f449e094a40898dcc6fbc025e5a992737941aef98ed339af60f4039a7d0f7bce0f31ad57585e823a7589ed5e29ca87c57edfef2429a6817e0ebef29a0ba80d984d15e711c2e5521c6f301beed1b528714d3aa8e4b6e50ac9166cee17c50786ee2d723941f93afa2ac4d46b10395a94180aa6645d165f06c246d4004b632bdbb1ffbf0b9e832582f4f2bdd1654cd8c781103c17ef4e76c7b1684506fca237d04897d65bdec325948bd3553d23d7e05ed9d8699e32afd57c28585f87cbdc8efb845f8cdf1f2807158f0147f8043424f167ebbad8f0c846d342aa00796c9a34035f3ba4b07bd71d9912e531143fb1ec4487c8f3f1c5812b1437143a61b8bbbaafb7290097498873736278129202ddeeb7d8cf24f84a4b5ed0e6795927c0e8f5b766af9de34a51368e6545608d0f74938247beaa465117007963cef1d3d3768e20d1ebbd437a0155a94bf244f01330e00fa9b65ad408eb012e201157357b89219567af52c7cf51109f2f2f8ffa3e82c0a900cb1ce8ea8b844bc89eada3974e8a93cda8aa5e4320fb779632f4de8c84d0fbec4e9cba8af2ce962114191a937270b768aef2db60555a71c3b32bc061162079f7ff8d1377fb4a5d024276467526b78dfc9c707cc4e9f6cffa01c1e35877f46b06f810b066d8ce903134d2d4ae75979b1bc8b59dadd79c921001853463fe71148b2e78019abf1bfb778525088b6af8e188cb2aa10e79e754ed18a91ab05b76fe8e5d01bfe719f77a813c93108502428efa6f28b99dc087309f0f4a8327eb896186c3e8d56937b2884dd555187970e0cf1446d27cb9879f8602563e92f469f19a3bcfe1b10f08a6055446cefdb4b7901ebf128aaed4af5d9bac452d15b0ea0f1a49cc6e8623393bd870f738bac0c6e22e2a99bfcf08b0d6f03133ca1491ae6f53452f4feb220e08ab7010a2d42f4a092fae07f80eccde0ca9bc8897ee247375f76e3d014f5ccc438d36181c2be3493fb61d3b1b15aa508ccbe15c5cb3dab9eb6a47679d064bcf5186ee357868a10c874bc00e33ee8ada49e35e5054fd3b9850befea40730cb3df7b129f6aa58202f67b225eae6107bc05b1663fee42b2383a5a313f98ce0c1a66de91e8c4cf799cbbf062b200c7d7a28aedb21196174c3d744bb6f9e4da3d31097635aa0d39181f170c954dfb2b39d2f2dcf9f4f9d6ac030bd41a97d72f18f0024a06cd6028c1791ef1b2f145bf68e6b1328f42d720fcb9eb50741955f34a4645daacd8aa227adf48d19bb21b85be902c794b38914398cd6bb32af613a6722b1227519798be238ae493280d23fad6146940266fc58c7405473e986bce211b64f1aaf95c573a43d402470ce57fa2f2c772253204e82477e791430d63269186e8b9dca0f842b398e8b4f22062345a9e7b41a4f43fafb8b75052e5c305a6a1d61166c4e9de8614048fa3e06f3e1f7c90a436398a19b42108b6580d821da8e1a7b3e9cbf6b416821acca22ca9bb7e25022e62cb520b0ca7fb536490b591abd8ef57625771c4f9e35712b3bf75df4cb9832f6094f6e3575ae4e17a7b4d2b7f9e60b70855245adb38773c9b8c2ddaad1fd6cf5a67b6aaeb93b44542f2889440b212590bcd1fcf002a66ab581e7f021cabffe6ad3244575c0be06ae004f134ec52815b8dde6788d4c2cceb874f70383f3983e8cd349033b9874d85eb849abcd5cfc3dba658a4688eb0bf830e29c57596594c569d833c9b170e7f8a0bb87abbd65a47d7a8918027217661cdc9d0b6358a05d8d620ea236d704f4d3d1f2b5c58a7044b580ac68f3f9df4291d58c749322b5896b025a14b09c119605b4128b70961e1f2399be110979b3bdb2681b6f480535a9b9b19a13cb287a99543ff88655e40817f83b82269c81dfade3b0999a80768654228fb1b8d870c23bdb9d6c1d0c19f1b695ef074592407d576b82cae4c2be173e842c7aa8fb4e64809b1e46da83bf03fd521a3b7a225e419a609553ca8400b2eddd282843757d04958c01dc20cca33bf8431df1a6dff43a6a947ecd0613e3d640b170cf0ef849f71d6b9ed3441f14764966da374b253f51e86fefd974e7ea26c963fda0312c772347d5818382c0667faba531a830e0fd0b56f9535a81cf7a33f0024dc3cc85249fdc0519e2648387769fcd509bae72ff71c55ed116d77916f137bcbc0e4f026f7befc1ac8f705f425d85791324e19097c81285c9c8d53b4d8645d24d10eccdaad3f62c89584bf13fcd6984562535a7774c73abe669b5d7804bafb1e69dca0e2f670cf99c84b899452279a74e1a557853e7c4a455d58aff9d85d938e5ef9c36e34c1b5555fef4e3575bff10b79f4ba5d4f9bd72404dcb83aaada267739dfab9f86c782865a4db015235e809e95381d702695388413036bbe8542b52a378f4f174ea0bead426e40ec38af96705cb56a419688236097503205c542d605bea064ced335cf6baa8cb7ea3a6bb6e473f62c794eab95f79a321660eaf9ad0495a85c276be92fe42b8c1f70f77bfcfa6634c58974df538a17598669dc27e4e517d82a4d5144e754785188d6f3549b242796669352cf9f42b16fdafd30485d7d0d94ab21963aba568e1ac48d842c80c15c49884d855d115b9cf7bf4851c7d4d844aed3a21499618c1bffc6b3bf09821412de32c0a2accbed3aebb5458bd6710a907a27ce6c0f28bb5b12c4edd774783fcaa740c6c4155f1dcf41699cc9a07c392bf17c76969cad374e2b13c7e7d5d1dc63502a02996efcbb24b82a6996946ef049d65ccc1b254d1c079dcaf6758c42551eb225e465cb8241fd8258f4e3f4d787705eb97b59e15f1a6bd05d535458e586dc1e0d0bfdfd80141374f6b6066984ad7eab310423814f337ab7455f79379daee6457fc58b993dfd7f8b8b851889871b2076994dc8ae317fede47f2265861b83fd387217a47caad0b4ddad776d06f4133a868fd8b5191ac88f424add754a840d49c375e93d96661e1e10d5d93110a66cbdb1dd0743073fbbeb07b55e1bcceb7ccc05d939b550a6350115f45855c37354e410a1bcce83ddd3ad6a1faddb3fbe4c0ff9abba40e174077fb8c031081c9f4fe8637856cc4359200c98c5281d433513d6fa3ca664a9681e211fe674802b2f79d7781c6d8a45637893d6c386cfc4b66f6eda35036ac1457d42e5e9edd9e4282907277556e52396e3606dbdfdf2e1a5bfa4d1f6e1d0ece4e151ab21ce53dbf11e5ae3b3494a8a58a0b7e4bd012989811f6f49f26382f8d668b6752402c7ef723de5f2d96dcae5977aa696d1e4cbbd25e206972875a6d518b9b351602b21c0acd4cdc8a96dd3c075685cd2ec0a75c0856b39d9c4bffc6fc9ee9f803872b567ba5ad088f2b8df99d0a54f25ff97712ad2c3689785ebe67a663c0df640ffcfd7e2f21ea2f50ad6490958176ca0449136b7287e8287c063a9d05678d00dc3db2ccc4f82dac943ec0502f33cb4d732b4e2659854db30a60da0670ada18f91861d7882647ffb7db170833a370318b8c5fdef66ea3f7be475e2dd9c88bf0f34293888fda27102c1bd1c6139cde7b2408b8105e2212aedb721abe43e55f4c6b3b3a64a6a6413f1f204da7e0aa2dd45055d26f4db78ea03f09c6fb103c85c690ffe52aba845bf580a97ba38fb134dba35d0db55f4b9ed8aab548fc4b4ba1e4f77d6bfa0cdc44ac45306151e5ddb9d4950297a0232ae4d131bd4979ef4897f27a8e736ce64bc6fe7a6300a82eead2c8273997a45f40c1b4d77fc142b025b8302066dcb938a516e73cdf1856056bded8f835f1d491987a015afb9f49f2769247c89ddc2f91d2ff9af307ff4a97b5cebec7b323af412f727dd5730426825b7f6fb98c5f32336d575fb6e9dc3619e38ffcb1afc63e58aeea5f1321e188abe67fc3ea60638e0ac8be33c3c595faf4ab2947bf4e06b4d9faf8abd36ee7a5a307f4608d2c1076fcfcd1cf4ba50c2069180be828e18d70db8a7eebcb911dbc444e974d5c82f235cd67b4ab5a5fd48c64aedf7416b3d75f32db3d8e4f0ffa115657e1f0400395cae19123a55ce01544e4a19da0f5478c92449ea2ca75348f2c2a1312d20c5369631074c26fc914268447ffa6ebe414a1aac86361de757624f75a288bf0379c93fd5380c33c8b07b11a0f98a759c55924d54ebe266610b6d8a09e1794c37549a6e60de8cb0d7086a3bd71b7f2f01808b59b4e76f63f0eed8fd958b1063cc825707bc2f7b12dcdeee2fb15cca82dfcaba2855ca33cd53358f8c53cec193aec919f24ac58021f16896cf1136c1079395a56141a7f2eec97e729f16191043ffce7527c8eed13f90e781f17c54879ab064870ff56e96bc308b8be44b11309138626abfdc10a946e3b2becbfc9acfd364ef4ed53fb15ef90e3cafe0cdb8a1ea22c7fe0b81c281407b537dda9f7ac83ee8d84139ca1b20a2bca160da4ae1e800d6c9e230aa49c2f042c471cec303188a30d7e16c0020c0c75530efe413293584148027f91173ccc0b73d3b39121cfed2226c8ddf3f0a7a0ba3267c910e5128b316dadc1062ec1408e9b75b2d0dcf3c5b90e63f4a3a1af9451dc73882d95dc5cb87816653f655010d9835935314d0c441f54311b5134ce7f8d3113bf78fa27ed5a8c7c7b100c2b666cc4dc7e37ad2adf6614250857f2629051cfc0e83edba8b419c64cbf5015e08790173f067d77ce3a5cc96397cd77af2935c400ae132a52f8672d6c6c394064eb1b528768f6830d3f2ab28bd71de64d5bd62bfe8e153fefb7172e950c113e708c6ca2b506061af4230bf8b8ae7c4f7a5d28864aaab72dfcbbeb7247f860adf1bdd267eddf25976bcabaa0235a4b91bab903349dc72df654066271caf91875205a113b5b788b1baa46fa7bf7a49b1a9263fffe0f0ad152771d2db1796d4a0dab1cc22eb5c510df7afbc68bace958a642119dab6946531e3ecb0a7d18778b76a52ef9c420408ee73446ea9bf94a37b4aea94c297c73266aa14c340359e32b9ef7f116b59a1523c47022c4f091e71fafcc47b182f04a876b57c00ac24a97e54effbc50b7201f32fcab3ea5fcfdf38423e00c60e604942f723c56170ba80a9de0ab4fecaa84254c55583520a24923744c3fac27ea0acf8c70988ece588b43c85cdab77853546944c93a08452089fefc6a5b617ab3ae1c90ca9d047658c9554c801db5693d48ff6b65b1101f643511641b03a125409f19a10eaa93d30080fc7d7370dc693584abfe43e51da2ebbf74ec152d1491ea928f98765c5ad53076009a587aedef1e80d313d43df799e4a4efabf75fb41a91b52ea0bb252e1049e7f76d0f1cf15d256a155c8824f5fe094f0ed3345f253dbeb162479e5b7c74858bb2df15a37f43a03a8991abb6bd80f55bddb28ce594ccbbd9e8335cdabbd268ae9c42acd4b905a81898769d7f1708c7f0d19484e4a33bc61b6ac107628e0b779c63dd2e4dc9dc1ec4560be60095b50914c260d664c546c8569c3d079c9f17849ea3ea5b5273bbd3784dadf0a9b908cb4fa11c4bf5740fda7998036ddcb32cf191b2d8a1bef6e5b8baa50a6df7fb9022fad4cb5365c3826fa670042837e8300c7ec0f192ed5fac1b9b02625cc56dcd953cebef5d662edd9cdc84ee13bbc1aae1213873dbcec7dd813cedec1e14b70d167c65da7dea51e5e96d16135a7a1a68a5208065c43be3acf8237a1dedf44a99b449ddcfe3fee7afb897c87af399d1b7f0feea5e54b9fdd8b3838f1f84fdf3a66629b42a205a68311671118300f5cd757669504178ade5d12181b27bb1d61d57f77323333592673008e90c1e0bf92edff666698afc2a91c690c217a6204f4f91d80c81cf885a901dd69b46ba190baeccb260961099e82398f6f9433145695639e030a0b5e8cdb39e4896c78489d3d8dddc14d2abdc8ec62456ee2983191e8e8070a76f23e8e73d0b3866ca4fa602affa9b2eef875d24daef0651df5bb3fda0ebf33067d4c411f61dfadea1faa3151525f2fa755e06ff2be8cf9d608dd8b0776c840c44a44f547fcf31a92001ea85a86a8992a85b14442b926b0c4bd9d823e45fd66f48fd7ff1ba2105b9beef41a8bfb0a6e0bc14d3c9b3738703e4f178054df26da90ae3b5be33df7e94fe7f03c3580a05a204a3759857fb1227eae9ea4668c245cfc31b020baf269730968434ee0cfcbf95be8398b56ba6978af97a6fd7da1a55117aa7a31ea1a6e3435b80bd7357472583cb10a4fc3d6b4cead72c561dbee633af9a1dafd484c3d1b02bb5b21e270dc405f500832a74f4feaffd2354e51dae37fa1f8bde57bbf605478b72ad3ab2409be9763b88db5d9efc72a40c8d37804ff5fd0f2fef095d74f134aa3410b18172a34e0a1e754cec51da67fe0a7fefe2c63ecb63c973d269cf00176305291af394bd0e68156d38ed716d0a9654e4250d1c604eee53d7c5458b092a164c404d1227dcf36985ca114b7a9abc485c118093a46cc80a3e0395917df7e55010a2a5d3e55c7f3ebd288723f1340d05623e510f0a4861c28a4b915729afe855228dcb5fdddfbeb99ca72232ec1386d51437379d973a93e9d3f96bf0c5e737135d861c5c450b50579392e84dbf602ecf3776f314b401092a8c4fd3615b01a5c09b77ca9c0aeb2e3fe95522daf8257a5df8112f289e3ff2808fa4392f90133f8467dba5b2110b57df73bd8dfdffeeed224b1cb76e88dbfeb4425545d4ed5a707ff46db9d31c19d3b28e476cdde9339aa9d600d11bbfb93a9640e846f763064e33719c076a3b3339954c4a5e15b29c88320f94cc6231e858a7f71580aa9ba706644b92da624aa001bd43b71e646704bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
