<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ceef27fca8074ac8a5705091096cb45a12d965b6b4258009e556555176c171d7aabbc94b995a382587ddd4cc9e6c99f6664e24eaa927aec25cab45f0ac254508875545227061e195b6078900846437fcdfb7eb42ef99bd8c7a98bc9fea7aa1fb160d0598a4c88e17bea317a51d15787f5565207e711ca8a706b844fd45868678887a9dd8583a4c5121bc78c4341e59905baef59b5b966fa770ef44658551591ec7ab495b383dc61e8f6bbbf74ed1bfbf84b511f8ece165a8e713f1960a6feac63610bc2dc05fa9f88b312de2cd9c59cb47f999b0258cb54d1cde779ae25712fd47f77e316d85d3e62c7fe36eacaf01610fcc994a05c9e6e3934036cffb0d773badeab339d8787baf70480b1cfd0265bb9ee445d72b41724eb7b4df1e91eb02a30bc878b2dd08ce98c5c16e4e5bdc11e8d0f70fe07efef70fdf441c0f5a6b903366938d8760b84dfcbca8470e333cf83d3a2084d412696684c46d7e9c42b0e3e5c0e43d2f4e516d70f7d56f944d7fdc92f694a81423bd06692797e668b046abd49d6483c1288995fed76e927dc2db61ffb141b0dd8ac20ac9c9a770ecc6b5e66dbb5ca14b4f09c8638345463e86c41614c16045cbdde1993ba2dae9c3e3e3c0332b957bf6c9300145cbb8324e2c473c6ad04bc468050b987d491bca23660f1a00a932232dfcdaf807bde7329a234dba7e29f527c059f75676562357d6c04fa8dc77ab7c8c132bbef08e266b23e4f3cda608c8f621b1ba471d5db393255d50f4615c33652769fc9e97ff2dcda395e04e690501d4e954b2100a4265d4852fd38fb6cad842f06def5bf2c36686c12c948b50b8b41a9158ac6e300bd1a0f20ee193ad91af95c3357b2d96e6a6fd4c8ae382cf91df4db537b41e5f3b542c90e6233c5a6eebfbebd0e4826673a86ccbfdb896e93f9fcdd8053b1b5f9e883d44e6453ea2607d05484d975825bc391a5f33dbdfa7db4b2c7c3c1f7e6f3add5bf0a7fd3ac30fa7b0e532d013924659a4eb12f1e46dbf37b6ade734823e71e5a02b65e1df8dbe71a8afd222c08ec37885b759471998d971a1b9b723639c5f444b533f0a68eebd63084e5c5729cf5a94e9e9b683cda679a1bfc74de66ddb1227858efaa4f673acd39bcd56faca164e7f6bb012ef674ab568654b5ace06e43adea894015b45de144f1d5be56b6b7debbf04fd4b54b6a0614b94649de3148f49fc073ca26d09b0daa632fec7473b14d93ae00d4199f5a8f27eb0e52ec6d16b58ca0fa26dbbdb636535d693a3d93a2616a9db6bb01b623cecb61be8257fd434a7f63c6f4c42316bd5ce69a9d9cd328b2ae5fdfb309e72d4ec38b07322a99aca74dd3a4d0cea8734aff23a8b8e668f4ac1247dc03f9b2ac6dc9837b693cbfc57d423bdaebf24bc601c12b67769e1c4e59648c0017699b5967895aa6535283cf1a3986eeb22f8ac71d50eaef81d47666cd2a3290c98e7826c145bcb91b3ec864d79b1500149f5e414649dfbb91c59e462daeead27ca7ab2a5dab2beaedf78f7df954ea335bc0e3889672e2092f868ec7388a87ea29f1844028f0683577c8f5e4152ee8b3cbaf6aea77a9a84b198cdd3cf277f662446a3fe70d7577524739735d4071e3fd76fb8e61be21909d25b131cff8e62c784daf215305023b34e8d9e11492fb149aae7368b9b2a6631195de8aa7bd4442fd7464aed1ffde572b1f9616828edb5414942a036c35bdb479bf542afcdc9e527d597b11d87621ebbafecc3c7bdfbc7825eb5844706dec1ef85ac5732f912e202a354047572dedaf5e30e91838078115d9e16c12c7f2f7d6cdb9d94388ff8cb556098309159416e2b009fb39c68024621726d563b15c9ba3c48c333c7fc84fc3b96dc2bcdf700a29f1c9b76db15f8f290a436f50ef1e15f99e714e322dcffd2e7447e89e809e15dc51e9455a46a7c7eb2e0f1f344be92616be1d75d828ef84cdb2ce82d49d81a84696f8bec6bbbca96249a65820d7fa00df24724f2aafbea47c76a30fbe0d9fb286e2a3ca954b124dffe3db575bdba804ee6c3d6d7e446530158a54d0e9983fecea61b671e1c1a27dea9acfe5a7a7462b4e9cfb97297669588b5bdf3c1aaf481f816f7b0b92b8df39cc3244aa70a67c86d1a5d9ae8f6ffe8bb32c498e59b4cf8b6b502299ccfd2813f8256b5cddfa5d3d43948ff5e80ae6dc3b869b0b0c9baa06349be32656d8fb6feafbf223984a1a292bceaae23384e34928062f8c9c130d1ad942a42466a5bfd485cfec2a42c5ff2867cec1059eb595bc835756a980c3d03f86b89f43f50102bc5cec929e920d419b3f4cb423ca5d28a34ce2c81a4e1771f89ea76731d746d637370d8e55bcbd67db1711d8a6cfc1c9561dc38069c9df208491bc3064c4a95a557106802f44c43254aa7305afeb38e0303487e7b262308637578839b40053ca2369e41f52586d9187734baf493775a5fe318819eeae5f9d47b7b46e2af556e1109a386c0fbbec52822f92bf8622baf0eab9c74ca470e46d50d8314f49371f348c6f7408c7d05193949eb1f2df910a21093e8a4895605d021d6f2b50f546bb313185024ef583f4ebdf2541ef0adfab79aa12200923df813ed8eee02f466f8da7e6b949d2dd5d9eb1c4ca7ccfe3cfd95d218bbc8d0f484da7dda20e3cffef2d03a3adc3adf88566f7d67a74158759745e12ba5297c5b9959f34f514f633bcca3e90c63eb901c5a1d62153c0a94d6b6cab0571b22e527af96a316293254da1cd4461b42cec0ff3cbe89203611299230a7d260d65549bf16cd2b6a9e2478728382a1a808643a78596bdb57d9056055240cff003d33e166afdbad62a0b779ec7f86fb8449363c39a284cfd1b158a0d1e544f7c76bb096e4179176f4a2ac62ec0b89dc163559938f9ee46957a81be2a76813cd832491f34a577e969ef99e6b18ac1f274ae77d4c4151f1986e3b1b340a9f4e748d01272b80d682a8ea2e8638ba380e8f1878ee054df93256837232d829e7ae154d288109b13d068402a4322755a1f58f62f5d8ac79c05c582b48061e262db6239f710613848e985b6eb64acc1293ec20c487e6577932698a3453373e9b4ca01bc9790a9c4933b945ead6859513aad51d32926afd0b5f415d2f030b95166d8b67e8d9542924089d25e38b100951c39b7ce71eb756f0aa4e18ebd2a7970a91c4f33ce3bb6ceb4659695540dab6e42bfbc72a0d0beb58e273608362b5fb70ad9aadaaf5398e4be038f5550a3ddee0a8c226d05cbf5e0e887424f930c8ab35ed1cc93a508c0e5eac280f180abcbcc684437b8b809494dbd8e971bd37ee2067f99903d23fda879085e4e5187aae1179592b0285fc3c163370a1131eefa2386b1d557d9f6e43c34b1fc2cb4cabdb4d53c452f5c7e1966263d4e962df1ac1d19aa258213cef65f7c949286d94ee8f9e67a8f3e5437552366333c0184b150e9d05c1533658f40f22f58f6eff349fe5c5529c242bbf7aa1a107740901142ebdf4d8cefcf303dc646793fc207cd79f22b4157943844a0196974af5dd597af76ac33efe7fc01d3242d564d82a5c5e022a56ca59296de36df7ecf9ab381d6e342f3a284cefe2e93fac0d02487116d88ce9592599e860afc55db9dab6626b9856830ff2bc98e1d90d5a1686da9ed03585fa03eaa2c65d81795aa8f16943db4399a095983380e9b190b3007b65fbeeb88a85268a76fd86806b6af587569859814ec2e76ea28d8c8321470eef89af59b631fcc3b6c7ed4118277eda3f54f5ca724a5e13198e44867f5327ec6082b900ff3a4b9601bafa6914efe076bcdf252b465c69441c423d07c913c07775b8bc3a7364bd68ae4ce85bc1b4d69b377005efec566493a81bbc4b1e66a01377ee2b03da4fccb46c8863a71de8422a76f5f563f4818ede866c27f37d968a56605c2ad460e610e9fd9e23a0287cf51a5e529075e5972e233c7b74c30712d53382fea5b83cf4d5e8fe931b2dbda600f24e4add1c6530c1f31f4fe3ee2ee2dbb0ffd462e7b94508bd09501ce202dd0c5fbb6df8e3afc1ef849c4e9dd30ffed7f3a2567d71f9d6cc25585479934514eaa27d41d4fafcf15499fbf76058d1198bbaede9138585d2f61fbef3016fa148c8241e1e98f7970618db98154c7be116a8328c2f27c4471c2491c32bb2eb0c7955ab115a7e6a4a1d1d12ed635e1204218e13f9116192a1c48a3b47a5e2cc90b259c31c68b3d819bfb5953e54de700fdc3c26c7dea8d953e0cc2534176124da9ba4b53294ff8e1b9583bd8f878c4378fa68fa7f2a94c69cb15a0ffe106e0d756164d7b079de9d51b8ec0bb9dc69d91c2d147d3f885e115635e84825abb9a8101004ae13e49a189f416bba5f9818d4aa2931ea7abe7572c8cc01fecd8def6af82148bd0be6e52aaefe0076b443489ce924d3b3ce314670046245690a4e8bc066b3f29a850679842601d267c435cba2ec247ada518044dc5f073267edad6b089c26f46d2d6fd4dedd8834317269ccfc9a8aafa1b4e4dc0afe23803f2715198772a54cf2f51efe0eb426b4570047a6bf10a94db56f34a04201ce5286fdcaa990651e11f5331e0dfc3191a03e5631a632915d433e0a1c469f0e7e1d5064ed83f7b3de77c312cf02582e684eb5a3c3ba284f6e61b1068a6d369a46adeccd86627b5c73a64097230d5098ee683f6d341bb51fa8b8a8401f05b8b28a288d794cb92a0fd1cc5d3ccf57c7a8856eaae89e0b3494fec0c17163a538ddc767438440d9608eabf9c1c78229c29a8548ad4bea8a8c179a9da691e69c50bfc71b1a7fd7f369aae426c2b02ad92a7fbe03374ad62fac00a248e990556a660073240bffde4ba096c196717432c372fed0518bb74c319fff38935142a065cad8ec994655df09b23734869fa21ac53347d7ed39359592954c4da289d05c05e614d42956fc3a55d0a10a7349eccaee191442f61ce7dabbbc473251cdc8f83a1963904743ee798b11975b813c652acca1305bffbcced3718a2af723e0e7e003e67299fc81fdf673d2c8810d76abeef2fda7f07a6a4a902098c47c539871aa4216ed1d9863f3559d20d46741cd72f557289d6b2a7442b75849976b9210207dc2a586ab6928ec59013029d2df46bb0e9444e7038e151f0f6c93db2081041fe2e7bf7ed74393f90d5d3036a87013b352da39f4fad459e66e29dc9ac9eecc89fc87746c7b895f8d80617babb5da069e1a134c58e1635c7ada6d8e74417923b969e48f3c411f7d0861a0fd11c6706d29e47d354a3ba7541bc835abffcc303b82685ef73e5c107315adf7b33ca8f7e281a60588f55196d72041a9035e3a6b550462213820a63e4840137e25138129ff6dc7083d690b3357d1582472969177cfccf9a63717ce7d7346db8eba17fcf2ea28c78f317d1da5f40034bab1a01e577761b737735a53218e0474475d3ef69e8837fd567e4d9a2b4c1b9c1bd05a9c70af55f1281283b2adf8d0f75c2149134fd08e8be7d980f73bf445961d4184038e413be7e0a691a31769496bb329d62246387fff84c60ab084dccb39cd0a9288382ae6930b2d1249a3df5d0d2d1fae5e612c743cb1dc5e44fcd0758b410abfd8f306a87898b9fca2180cbf0cc95f28bb23934751226d63414371827b83a792ded049f14cacd0e6597f2dffe95e0c2fee4cf6058e7be1c8d97be6b10e3d821402c1112f85dc4996e997b174eb541144b4be8914580fa452ddf4eaf52b992af8e760cc420cb1fc6b9672fe211cc193c22ca213e20e48fca5d7c95f586586bfe63d3500c32ecfeec9d57f060d47f266f2248ee678aa32e6f76cdbfd36855c22b9b6cb8fd982bc8a2676031f843d0f4775823f4714b24acd7d888e9dd9a22d24e1e3fd3c870c39e26fe6ff3e501e6444c8e4315713243941c10c3d83f15b8230379693ff8fe257a3b07b210767fda53ce23fede953ae732e1771e506925f99ca9514ad9d3327224368409ae52173e198efdae153f792345445e7f7de8af90afb4e5f01c3ce2e53fe4b1d650dade82a16e3efdcb2df22406dc53ba4bf21bb8376ac964a88c42fe25c851fa4b5348891a409425b866577fbc92be3654da3812a830fb39ff1b56960dbd7eeebfaa91d18a3dafa2791a5c67566b8016695fef05f57312c143e27c43744794e54538bd2a92fba2b4586a4803b25f3f8208dec73c370e46e1fc2411562b1c9417d6b6723c2d1963e6e3665a25935e32213b09c09f4091e1cb80d043bcde25c725f52291751827f89d3d1637232ca76f59e1b605f30d3e3f23eef604902ce7f6bc32b65ed5575f4386b88912a5e01ae0930ec84233eb5321d531857ea6eb8440f0014ebcab55aa70ede6355bf371cf2a2598d3f4592adc0fb4147517ee2e67c0ee8046d36c6147e286625ae34c7a61c62da539b7f36282a22934e627689931d713e5a3a37f655a9352436f9781874e68aa5fe8adea1ec683d44514d5cf63f1fd5f2f1a0fb72c857d91c5ab7f1c02bc63e0b4d7b4767f7f010194329bd116690e1d3fe3c07dfd2ce41f61e397958d63ee2916ad628bd175852c6f674bcc64720849366ee021bbe7a7ea3ba84d0bf7c78cf7d2ff4b893e6eca35917e88b94223e60ab0983043923ecc045293463176f4fe03e3c75d9be2ea1115d663a10b17b94dcdfa7acb9c4a60a692bf382b610f3ff72d139378bc9d276f71d081ad2683853f2802c3daf02b19a1649180ac50963da9dea4a2d12d138b3b2f88aa1fae18eaa38c6fb93a877334af2ffa533ff06c71b17b2939fb912dba7ad79755fe2e1db51b8483afb1ae2f4a4c7e82491961f0ae9d0a9c319c9061eadde5f8c7ac51d76e1652f64230e1cb553f6635fb77668716b37e1265f81d31f344a49d5d84103b0d7ec301771bbf779238d76e28623ae8c05398f1f799117704223542d52ea7f71ef507d178086218700ba365f4693c624d8df3fa5a193f4fbbec3f9f5f8cbc8d70372e206297c56d19c8ddc4853757ebb0d0b727aeac79e0ee498ffcd4766f78909a16bd70f2c25bc0434df29fa2aae223d6a2a1d009052e9e1ff30efb83fc94039c0d9a1320f3c836462237f9f05fdb58990c80f96a3c5c26d6c4f4219655248d71fcfbb81ec01c8731be50d15d9eb668ca68ebb397ee076a16158d7034d2968fc2825fbdca5bd3b1914b01e3e020314edb52583fcb1dab9e00206753c42bf520fc179dddf5b58be4830560dab36ef9c4c90f11a403ceca8e26d6d38940eecec87935525a9480cbd820c8cfb7e6027266330aa24e8dbf516c24cd26f8e5e06056109f1b67bbbdbc911d2eb9eee6acb34aa4de9cdc81f1925ba0a33b817651fa354959109379a63f09a270f3a2893aedc31904815329240e08977609230351ecd64c7782a9bdbeada35f8edb294d8bc31292b3cf8b0b302ed6f400a9c0a3cadc3d3ca28fbeec54359ad753f6e5a9c637cb54bec69b134a995b9076f98796461792e5f8e897b47150521082b3e74aec3df660302bee9097e595999c5b66a045c8698a9e86adaaea1650faaf0c922c550d5b6bde6e53520c0f5aff65c0e0e338a3006bba8cb60d01afd5022be8903690131e170bc2e0f7a359bad71627f948ef51e553de2d2757262f92d5c8438efb5ee74e61930014021e8177903be8692eaf85ab7d28df0bfdc026f1932b81889de8e91d03b8f1f6fd9961917cd4f19b878e32e30be9d23d611733cd0cd8a136eb12c1dcb7e7ef035f9038348aa4985ff9a94377322ba3c8cb593899c161c96c0e04110a18219a4ecf7d218dd28e6f06885f33f2c29400b65b13c1ea1cb7843a9f1e10cddb9b62577ef047f2394b378a0f60dbd606bb9a197d837e8d79d3424098708815257a7befc82fb041151770c216fa5ec3ba4027ab1d460ac8c852a8e912a1d00c2d289e5afb150c8091a573afcc12e4fff0047c7a19da9475cd0d961b6287b3c0f2880196654a33326d61163b45847f4eba8949a998e7c2df5ac3ff02fe80e1e1711ea2be80dc5dfee7b844c94dfe32c67a15147853355a86287e7af2531758f9f74a1e52d773e16a99cb1ff7f97319ba0a67b7a10e71e77c189a5063ff788c530eb95eb3065eb4af18b2a97206c35faea509b249c7c29ba231a07ba06ffc94ecf5a7f7c82da51b4d012af4cc092f2f99c6a3156a300383d0b72138f5288be32de5f0116d4f06983136925d1b07f3fc6cd94086dabfcc7b1e1fc06a98a4fb4da437e6c6c22a65f7e5a45e408bc9db128d7a4f077455fcb08fb7df7ec8658d890e37743117f57092aca04820ac040dce26c4d297d7cb02ea32e66577b4985da3b7cf5ddcbe38d94965fa380628808ac04689d9f46251f982b1dbc43e3ae1e0b73c6f5e6872cf7c9d01ecffd026b20a4760a1235543e0686cdb055aa41d30c42c9efc4db2a347e0403eb23ac31dc00f61f9703667df9a1cbd1eee6182310e72d27fb4dfce33fc3cd124016081ba588379c8706c64f5a7a8f096671480a9ec3864fb34978a075bdb74d26dfe37035c194611d3daadbd620277051b62f023a6a30d0f732cde0754dbae7af1bcb9b81349d2fa9e468b1bd24406bd4a06755bd72ac59afa95558bdf2e5adeed235f613335914c5cb00e4d6357be448801eb46d9bbad18d5a7aa106375013c06900449fa727b149a3a4e795db2b9392ab7325506ef86808072652d82acd720e3c9e41b410e0b9686f3c045748fe33e416095af5e2b4c07ad559979000711050e226d153dd1fa8d99c6fecbb3b5b3b6bc8559f21a92d68526552d4b69d8ac0fe535a8ebccb5370e3bd34774333ce7fccc4caab612895da360b7c64919a571fd0c1071dba16b31dd479ced42e97beeb664eee0f459b96abbac5d928bc10a3f3c3ddcc3fa73dac059f135b88fba5e4d878b167c1078b78ff5175dfa74a072f4c6d48063558c2ee8fc6c7b2ca370049e00665bf395d719c340be18e00b822fcbcb0d41089302c5ab4ff9b07a18d57086bd3725eb3c63b277245e932d2bbf3ff20dded6c0c95d3ee3171649ac99e7cf60cefa3dee3fd86d53b520f66bd52cff5e527b7f2360d1ee245ceb68e0e69fc61f2f98f0508d1cf6ffd99fc55cd8f9cce49b804f723baf324884d0ea78c25111c4380b9c540f50d2e3399aa588050a4a12ac96b07cecaa5ed2431f01a758b26d8bdd17db9adf86a47bde4f1a7c8c19c0e346498aa56eca1c66a5b19d59c7c8e25168915315111389bf1a0d9dcced4c29fffd5b3ed344db09c3fb6aecdf5be3ada1a6f20d9dc18b3e8c34950e5833a2005a8503daf820cda50c6136a907aa26ebd0b5c7b87fd7247a199c50a4206e0d72146d8d2aa790ecde723efa2f2fec1cd41816db21c2cc6b9c8a3fb7bc22e20cd70940943ff90466b79e7081ea79e33a7292159a36f495888131006c3c6b18e7348311c9dedcf57e82ab6766d03ca98cb6d8e54f26a84eaaa75e4349ea3f2d940721bf984559b425480f109ff1909fbed53291db128e72818566b78ce96efa02227c6560e29c5e427de5aeeeda9b4aefda911924579c10a251ecc80ec02f4181f20809526a5249aeb3e1c031a6aea520501304f374085d2277083aa3da3242f26798b69d3ca1b0fcc0ef1b29a0f73d7da7b1ec87d0c7e28e49c74de1fa5e8175a26265df62869ecc36b6f4c7c32c8ba125cb2ce16e9b4638cd35dd766962661f87e9e4c7079a9e46beed7c47459f707bf76c827b79b5ec68ad94ba08cb9808db06416b7c8f31e4207b89a3e8343fc6ef8ce37f147d4d59f46ba423f88f1b7e5fb0f9fab93066972289c2a2e75212c2bf8343a1bb7de9084a988ed90376b634d46c6a18a60bf0b582457cf9dd47a9518813bc4401ba08436b8cd36a336a40c63d4f873cea2e4cfe649b467bcb1890f3f3c31854d0d191627d71f56bf2b4732ef0988ce4f713b14a6ea762e251698f3176893b79f9decdc7dbfa939a097fe915deca1dbc070233881da24839b550c4b0c7b4bb557d5fd29f6db66abb25f5c34326f4712790de8afe014f2eb4d3d8d83c3958dd47bef20e8191307b59bc26e1a4c3080fedad30835f62ee35525ced3a6e6d9de23198655d716c6c014d953b42f8e6f65664f385da1bcfdec921416636077b62b84d93f9f2107490fd2b5ecf6180dc5e13118120b6d96fd328b62f1e090b66c292bd45f90a57ce68f8d0ec8e64188d92870fcbfc5cdab80ec63326f68a112cdd95a926a2b8b06ed05c574c928e9579cafede549e34e027dd4000db73a42022156485f24addb42bffbabba03fd3c745df476eb891f1920f7be111013c0412a059aec40e22584c9d990454addb32faff120422562b920840653e3cfb871fe95de8a71c6ab30d83031de72ef2715393f34bb53fdc0e3a3bf8dffc6337f3d7e9c995e96bd2120c7ad65946805e6835c92f33214c2d100e6f1c19f5341904c2030abbc5f8534c272b6a3ec9ceb4ea05274dbc46400e42d6f19ad377194d3a1cd9ba4c31deebdde5e91c9fa433e6375a5d5e222548b370d41d34abf0f90a84872dd396d7f8cd9f73ef23965d6bad4e1b94644431e6c42827fa34b7c5309d3b52300a1977821795d72b5ff47b501d645f6ba19b6282f213bdb2167776a460d103be32f6540337dc708c4ed8dcf1d73d0a752f8a52d66ebe8006869f571e5972dde2e5a61fceb9d0907175ad12fa2ab7ac8da9a7d390799745d8fb8a10f0b273e269275e51008711356f91019cade9718f303212dce969124cb57dd8f50a06511443edd6842f76bd50e08f4c67123b889bf92f29bf5592401d2e3da2a53425b7f56935e59b1613311402bb625a92dffb5078766a089913f56673d0a7a2d188e64e3517afc0149e8b20135247bb038ab8f884b5b89cd9d1bb8f7339843ef096a1e10da29110e71d1154018de644c739e8ad8001096b813707b3c1b09ed1e5cf4d0900fcc46c4869b95791ac4155b5b68d7426ebdf65db0ae26e3c81cbfbbe846f7038eb63cb5d4ea80e72a4ddf1d50d1bc1c0bd8d9204fcd58215d4d8c0e2e09731cf1b8d268b22e108ac3000ff8c87f41c3a50463cde2cce94888c6dad1800dd547db3b50e6330515cf390fcb06fd79f3fddcd4ff9bdbdb8b38bc37b11ceadc22f972aaf91d86dda6080b41d4e43b6c8f7da93add34c43137755791426c3e42c5d1caaed11103ab48adb1e8c92605bf375a84478f7274f66e7cf3cbaece6b9c43356f988a64523542b0e102c23e67cc89ff92e4aabed74b5f974549eefcfe0f5cf84137661c941c5d59247b728831bf416853d94008255b4b560914bf7d4900f427775429a61bd13cda2f136add55271cff9edc8a2936cb4255661106631ae798fde46622b0442b8a8b72262d7dd2df0db105f4c850f54f5d1f44aec946954d8466e71f3bdcf6a9a782ce1ecd0fd911965fa56c7eb5469a6de566e8e9007e68046aa36e28b646828fd49bc13239ab083583abaf3d704e77e448e4d55df9a961a67780319476ad3e1db1ca2b1f1ca88abb3fc64f6387c04080845674a0def6888ebe321a21daaa17da67d0a6b9e9d620f57ddc6e6d64f47739622e12dd16839a9e1da56e15b0a8605d21aad8a443388f80272bad9adc5f47b39c244209ee6ba662fa56aa73ead96e0de9295628f966dea845027c65f277f0f9ec4996002e3a6cc43c4ac3b5694aa05179a11865847ac7577445ecddeb7200942c32eec0a2b07f2830832055157b4f1362bcd4a21667fa93ee9689bb36cb426d5a55dfcf3712318e8d328c7f649a08a4dcd9fad595aee5ec3e37247f1c25c8daaab0023673a877897af146bfa03023971940dad1aa1d72afb83bb47afe80430dbb15f7bc3937c3a352279f335290978ecec6d370522a862b2d0b1db2a8782706aba1b7b90bb19c99a8869316a663bb679ce1ea0b279d44b9b625ca1bf2b95e3d451be7c1afb92f20a7bce19b48f4a5ce1fb3aa928dc1bf871724ca95317dfdaf98958942d68eae4b4cda0dfc396396e5384360b0281b4f11e03ad4ca37b79c8327b6b3324e3b246c4363ccfb1e1bc5d9af092f5c5c1d2ded5b0424db3bcb25df754765d36ca87002c4ad125deca62f5ce94d028ebc03787f89bf500b9dcc34bbb541877b1d2a3330c416213e1e24f1ba80205f39a1dac08dea0c954ba067201b6fe3e37110ded0454ff28c9eef43e922b767bc7ae100749fd781a582d00517473e968fee3784c105069b6dbf7d095c12fb0cade3e0b0a9203675c8366e2ceb51775e33c2e423710323b3bc6c9e9081cdd751864b3d686b96d6240a48917b2a20aa2879f83e49b0ad44363c57e25ab99a7935c578e3316af5ec47939f7c649d1fd19a3e1d144d82ce7cada0b5bed4942b2387a33c059b6768f0479293f93093149b2447f4e6ecc7fab4160c60034b257080c4ac69ac6f28a7f56e61781cdf2c31964dfd53ae238f0b70494ac04879fcab4808a8fe26b19b3afd1b411b767125d4146c80f3ad6dd132b3b1d07770647d5b9011a4b8e5c12a5aaa7f323620f11a3defbb83247e7e054d2c4895d7e987c7c77a0b5cd4ffdd2383140412ee1a8fd8b0656c334a779e1c2b88b0757ce470cfc3253bdd64cbc59eb556f3bd3bfde2017ad98a0c0ea752b2b8ec27221c13b080c48f350d7d53da6eb4f5f5b9923f0e0e90fc6b3ffb76ae6f592939806d1c61a5363b12731abdfd9262ee7a3aa32318ae58cb0c22d31166ec1f7e5c92b138442377fd7c5342980c949d0eca7c3c0623652efad347373acdc8bae1ca558571ca39442836614d5002d65e4673c11419fc6ffd0e0d1a397db3af6c1b57f5c5481eb3ff47158aeb4ef8c733d35d3c2e0c4e377c0875eb2f0d19a1f8c463b09eec62c6492fb11d28bf94289935e106f60e3823248741fab486846b85f6fec30e80c8a0c5c09f7713cbee2e515fd09062ea72a82dc47a14d6e73407d5063929401f76b273d952a7416af7e356ce404774742ab27960a880ea2c8f732b9c40e96200621b319857d43491b00900a909e033ee43a4c03274c66537261504063533b0299129991c36e25066962cbf64bdec065d5023ba6a9719da98239932a9d746c5b691f548400d01ed97aaeb49927b77f68634e8a636aa27dcac586f29779332425a80070393dc1a4c9c7cebfd2bd3286564dce905a60c8d9f7142cbf9ec921546641d4d8d8bc858a5755daa896d1cbcce979eb500ee75e8e46aa619a19d90d6f4933f68fffd69c99dd09a29a62349107403e1d91241d69e5840c614d5b2f366860a3398292040aa4d35f236e724475c2175c33b0b4807bddcbc912534f9a7af486e56743b07d656ec025a3fcb6a0262196175c335d250ee514e4d1f660fb1c13704534943c8793469f3195dae52b558242bd39a417c64ddf402f6d2e01c9db898091260200c32866d9fc9c30796d25cad7486c4fa266d72d8eaf9578c1e0623794c51db52d68dd8a371c18f369fcd9d123add092b5e94a6d0f01b2610513f4f2cc2a01d1403ef953a5d45c21315645800d209dc5926b3860b6e130126b3364f812e30642aafe96fb33be7b47a2ac9c4b598a26e4a0cee3bc0b84347dea19183fb45351af6091af3c09c1dd4b4d4deae36b7e415358861d1f986a7716f98d4675cd2f0c3e6aee6bced8764876afb778e6b14164bda77cbab88d6eaf17a6e28e517f3b4dc2cdfe8cf39ae69b712a54c63c2f40c09a54d3b74cf87e36cfe94aac33c5390abe482e03b4e81409c0860d1a6a68f44a227b9366e6744cb84b91cc599358bdca6fad69b8930cdc1f9d90a88afe551419177347911509137b3ebcad19d6199470965e15d734d661c041afcc198a7076fa5d0a7e24c7acad5448c5d822c3a9af58dc5a43d221f7475d19a6b5f1f42854cb3b0c6e3821a76c3b5455f9d6429745348c642cff3b83eac85b819ce7cd91f7299a82ed454d69f6efd868cf3f7acc893902bdb6f64378a0c41afb6e493a7ca1b08368228caeedf6255587c2790310200156e27686c46501d67ae6609b30a53fd8d824944b740b11b281fddf873cb6d0f4b8e0c748e76291bb7f8382d90efc4f16c4f30cd62649114497afc764979c42c3b6c11e6837156e36afd8a30760a468c48eaff68d92e1e737e5d938df650824e6f2cc78245fd660105380b22fe7fda16e4ea70ad66ec8746322ffb901b697d47a210722c4b647c90ae868491db793cbf2238878319dcfadeb1063fbabf6ed71e4cd2ee29ca310fb369c01246b85ae4ae26a4bd004853c05f75900976e19aed3000009a55fffaca86c11d3dca03ce711351a5931558962ace3ae403e51ea43791454b47a1f0097835b1d074edf26bdd3c3c74ae58a5fe71fd5493f520ca80d131fd11bfb3a7db3ad3c47d9ef996c052066af1d45fe6b4c05e22b6b53e40385c9df8128598c68e714dd086b146e13ea83011fb247702e7e95ebcdad92ebb34bdfc4a14ba6653380a46bdfbf39a83c475a63b1d31fe33dc715b98ef008485dd1198a617bfdddad0f4373393bf84d456539d9b2cca2586b45e1494756519e8a6a21eeb63da117dc952a61b1c87376eb2a15fe130e83af8493682317da683a20c8fef919955486fa72feed6b971c10df3ce5037524883cc499b0b77e5330b871e4fcc8ec4a219767223f8b7e149ef15b01afc5a64484530727f918b8cc8f544f8e21331dc1a85c4760266b0e67a0cf8dca59e1f99cdc24f363f9359a8e4041c251836d0dfe851367ce61519ee6332abc8a92a4417fbee848de28c05ef3dafc8b064e9c962266bb23f2b71b37b7df39a223207881f9b1b21af2c90e2c976679d0b6a97e7427d9be334b2586b78a99cac8cbdac60e5669e22de9d813eb7528707c732de3fdf172ddac0afab1f438bc0b2d298a37b2090151dce74d68d3246abf189682e9127f6bb827c471c2d3b2f1d84b2f9a3e04300b40022447e81f02f036cfdbe74adb717989da3ba3f6d8a35ad2b142c7e06ca91ca76a47a8013505c3288ddff1a9582176135fa594da97cad53840568c09dbffa7f44f2029443e79d640692835572ed66b862e8fee067730e1795742862707765796e9f14fbda681bbcf405beb2c7f8251fcc2b8f441c721c93c6e18962c18e0027f3068fb523737e6ef1613852321190892dd12d1ac554cbf062f3f429c5ad407043e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
