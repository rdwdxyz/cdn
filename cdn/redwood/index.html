<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5dade49879ccc2199aac637b1e0db5f4a8ec699073d2cb1028e664fc0a00d4c93376080bdc937a264e0286297487bb25cdb6fabc5187c68a5f56d519f69cd0bbb366e7a465293d4dbb96a7a96cd1159a5327e60a7836b4747f6a8e28c130f5bfd7c54a1812eb1b47c933b0914366be12fd278679ea8a36cc108ba5a3a4817253acad8ca06c6a0b7f533bf11c39b845a423483c17b2947f3f184fae7cd7930bd5151e43dcc374fe932e2e5671ca2d5edfe4302e391904fd090ad1f7881784d75a3f0cdeab39940523bf433b403d6d9e03633c2ca3fcb5d91920c3a485621a7009e5776cac6b8a7e7778a5a6724fbd26f81bd95480ab3c4c9e853d91a55d883937275195255f7dc52f2f26b37db1d54db7f8acefbd2d9f7642a5d49e4209fd8cfa2129407105004b3ed5852a269ca0b92ea96a6fabb6de135937befa2d8b49aa1e233109497d02a6087835739434911132d2ddd8c3c3d362d8389cf29ce74e023b0e3e7a41b8be5ffbc0504a763ea31bb96e3fdaa5c5403d16e2e1bf4be513d42093e69746f6dd8ed13f33326a1a907774114bb60d9fb2d953e5af985bd6cf00079f3c6af226146cc2859ab42f8172ada41cb10a7c20040ca34c208afc73e63cd5f33d5987bb3b89f01be9ef58cb2780755cf35b82b3028ba5be5a62d49a7226d9eb50c5e157ff43c8a9fa7010a72a54cb3db1e7380c3e206001282cf4289a13773680a310d3a018afa6840a5dc9e11cf153008f6b4e0433e7cde5610d3994e7f55f4086c35ad6b8ed44a65e0dcc531e6f4f3ba41e7b780af8a5bd78d1768d33524de1bcf093fb84c6b955a70aee0fade7c31f8d8d4dca3ed7617447eddf9e598a11f0578e546ceee126f468f7b1ed850bf82cb2ceae95eb02839bc8b6ce2492a6d5567ff53619397584d8a6a4496fc3175ebb2ec98dce1ef0566b0750653c9ef8677deb925e4503ad6e2dbdb45586d676ff74374956b7d9f20035d2da7f0e3a07195cc3cb18265d6b9fe1990ef0aa38d80a6364ae4bdd8f9ff865d801d5720071b143c68e651c81d237f51b4c70e85b11cea44819f17fdd5a8b647ca12c48cc8767063c2666aec0bb7f0be55c5b12f0811ae26ea77756253dd1d5bbac77094606dc3826a81054796d5342f3006a5dab7a341c9f1233af8ce067cb8fc2e2e822aeca9ee618d4006feadb43a17fb8d116796ade4ed43eaf64ae9b565cdfb77e41114f64dd1b8609cea7be77513809acd674ae3967b2589b3b987a6a9f5dfa703734214a83a89c105f4d2b875d278843a9e7fa5c03002fea1903492a0a71a256b7af8437966d6d967122898d15214a0d354c0006dbdf74667b3cbb7f920c2161f707f2e101cdc75147f2bbffef4fae690448a17d530bb0ba0a788aacfcbd9447a00769e978f04536b07d386953cbdb20007ac9f3614a56fad61655cfbb42f1edd1f90fcfd6df5bea78577979f2389775eec70611c24ca592b5a3e02a9d94b1b42c586168907d3318b37a0ea799db9dc8f8d498b3b2efb069a4d4e65979294445e17041eb8a1ac9c817bf61be428ea54132d6a2203c4e325f2394a10bb97470e8c2c38e993401c07df89c4107808f20733921f26b0dc2311bf342f32ce1b7db511bebbf8192b2f6068482b49061f86604770f2063e42ffb492c201e8d6042d2ddf8746521f728e1e966b8cf360970f5e100c4937311cafa6893264e9e6bfe7d9c32c65f7fb6c90c729b11fa8c88be41e0f0c91fd675d03796a458f5055f66d8d404c7b8642751a074c596a4bf83c6d1f8e0939520079980294ead52e73244959883328cd218887c608e4a8401a9b24d9ffe749df532ba1955d32dd1d4c727d1ae7832125bce653ef8d8835045d0c9e7c4159f6f0025ac67fe3e324c1ee472747625551cfe2a9cc9c3ee93e3aac6b66005eafccfb1f17095b0f3232102cbe3caf3d3352b22247fd302087764ebbf1294ce57472a6c2e9581e9f5d842b9e6c79800419719dd0c3f75728f5376348333839d82b936b3ac9605b9d8b283d1ded0f5b53206e37d14231528f8dadbe830c5c368380bc31a086e6cdbac8cb99180650bc87a65185dc24f1c02c4341caf55cdf9d91c70284eb98040fb2bcdae2cd524d1f484cdc2703248cdccedca681c394432f1de8fb7ebcf0fcbe675fe4a4c07b0ae0754f714a23947ac313a134d725be4dedf403234b45dc63e848e0c1818699cbe1c8175c2ff834457fd6a15304331911fd8f006612ebf2e72a5e8086703d23507fdcf718f17404db03e50ef209a6da072211e170b295208d539c3b32988c9b5ee607193061726af2ce0411f9b52390f8e30f0e06c617e3f0b2e00c31bde7a9b5ee9718cf818b9cd53d5d1e9a225b3809f52d5c700f1c5955628ed8ba78f0638cea245847bc18da83da39c59646833370097f0c58633cc3e761d717ebb3c1ece4845a5de8e3824eaada4429b72079e9e1cd51bb2f25c6b9e705f48cf01f8c46555359162655698fa6c0a58a53a521ae5d5fdc8e561b2f1c03a7b9eccc834259cb5b4e2b467d02f48bb47438b1da0b0d96d49a23ac5174754a6d8ca8d8a4e8080fc55abacf13a593814de115458995c0fb9e464b3af311f3bffae1a192cf77299cfcb80b92fae0d7bffd23611ea90317d79ff732092cae34f2b64ce47b3125c262aec5d812ac63b5b7cd9656131730faca1e2870ef0e713309bdb684f7be795b7f1e3e93371addfe2de8898a193bbe3b268e7246a34670a7316071a18efb07ab428f84e50508f899b369550c8298b5c241273b3987e86d6a91009f3cfd685eac888a9e9df05e53f6c569bf61a9896d5717b4ed9d5cce0e5b122b2b9cf00d275ec9364363929c27bfac03f3a1c4c67dfa294ec6a03de81b561539680da681ec3ee35c85d47443427c0e7c3deb9b275c461d6f01f4040b33666247fefd11a319d8300d70b0dcf7c35e3d85719f2ae12ff01a21dd86113832a1e4d396c17e2c37a977dc7972d643bac30e4247f51999ce0d51bd8236d9a38438a46271f45368db2b0b0e2ae3d8f34d10737b106da041b623496a7bc995d7a362fff389d0af79033140eeaa5f0c40055ac5094fdabc5e4e942ec820d12e1f976c93bb5509b4671c686673b4fed87c7273f9fdac02f75ec928523cecb10c17ac9b266408acfc6377b6d2f5944a9e5e285bd3dd75ca8478bbd6b43364c03345e6e6599171c9d3fd3e25aa70e9150767c3924435188cc1031f205d49642262074bd0e437a645335f1d852c0c433592a255868629db3a607439f93e1834fc463715f87f91088345bad76faf31e2ee5fa1c0c0992699bebf3d54e674fcb9d437c0f499ab797eea6a6402c5e90da999aa9fa6d186b881618ad97dc616f2013719f701a1c2b4b69c9465f90385af94cc205828ff6ba7f3f0c2de39f3e370969221d4c620fc84586bdc1f76afc1df8556347674c3d4ba2c049bd83a2c9202e926b2a53c82caa3ace24d823f1b69bf8239de5ed37b1f1e7b7442a521154c7632e0d4414cbd10380a021d459aa831ddcd91a3d83013e81593e6385535c080dd97c48d26e80080e633a6c68d9fd22e321bbf131ab502ab631ad96075622dcb5dcc2e0809a8641d59a5b2de2583e6c9f55f580737344e3b3c9ef210f862d4de9c59435e481b8247d82c3f6d0e42830c28ac27784ff64dabffdd9b12389eca9dcac976b98ea55287c65933b80e57b0eca9b53cce1aed481d874190f5ce2e1c57456c5a4e3d237418f0a2f9080af474f0e4516f8b046ae27fb647eab56e2547df179ba638ab46dff249b444bc6dd0fdf22faee6ec8456838480eddcd4ea077470a3ae718aad61b2433a4fadda89cfc2b20ef16f43466a9463be21107139556651f1c336bfa03ffb4131c7e183db9368a16c14e87a8e1ca9071902982a4572be1a4bb8bb66bd452e7ac703d77d8971d8700ab58b18ef57dc90be3caa2809f249cc243884fa1303b464d095159792ae946504217da09f5aa2f3515038cf9ca1a4a8fb66b34cd5e759f047b94d9ac7ce6e57ce97f6e204ae6efecefa4e3e19627d2123835677042d10d651a0e888ea5d140a64dddc710ddc6851843f68fb1fec7da93038d5355acbc1e8c819aebd4bb8487ad21ef4662e8ae4ee9da96c20226664aa9f45eeb629f470038274e097cd08009012d742cd2962146ac4e6b0ad6dacee872febe026137e90f3f45544bdaf99a0f67a40aa7c1d7733cc5c192b9589d83f55ece8da0a969aee84cf65586977f72a4dd8367c9e2b892ec0615322ed7e15c83e11930220343e1504dabf7829e93e6a362ee3b80df65ff5782891222ee21795066330303bb39cda1cceae5dc0d6ed68d87019cb7cd2658b45ab3e6e5d70aed042884fcd078746c940fff6c52c09e075b58a069343cca722591307a6ec8069911d6c320f78e18a4e06022f58d7928eaee18adb7418e1a34fac65b25b934d193e84a61faadb835414b3bbff9295fc8349622b11afac062f4687b2d21e0abec2603d5f48dbd2fd965de51887f2e6fbac09f929f6c7c6fa57849b8b52fc54e43f946768e358be0c12ee7c1b2f62eec91e046748665957b64a12c2a152217774775ee7db60bf71366a2eb10083c4cba8eeeeb9b08bbe69daf588a098dbef67f1323ceb2112846756620f31d370f3bec7f09eaa2883edc2837dbd0e9ca87d18850f048e96fb09815b847c1fbefe780e95ee71438eef1daf8e4cbad655b5919954e4fa2b5fce2f32b3ed66b4ae53eb800fecae9fb6a6519e2ef0c61322c62b2078cbffec5f114f7b5ab035a0b7ff26fb7873ff0dc7e234d01c712eec785f0451b5199a95b1fe773e793881cbdc67c5574ede746f98ed35d2d14259577a4505863421797d01eb2212a9e46fb8ad36fe71884f53c02047bb2c7906382a95d9fddf45cbe65d5bd92dfbf3632d221339509b396223873de0e372bbd45c2359b656db78db53db93156c65a7b8fa5e23f998665bef2bd588c7462d630faf69659f4dcc3cfb09e29865c16913f59b8c297560ad6c3253db3fddda9b8557668083a95043a74d84b2ac97af6721d67a280a0c4c40c9ebd5f97f22c1a824d7785c9d3ee4dfa8bac9ff6423554dffcb364ceaf529feb87c1af6301a602c6b45b77721a1db28d19ae1012ef9ceb6ca4f525d10af2edad5509108b96cf48daa5c551ea85fc6ee492b73f44a379f5ceb43263fadac1f44d5b1489d3e29f6f9b5548ae8dda47330e23bb7c25cf229dad8ed632c5bc88e1083c3600f830a31071cbd45fa64c0cf3fc4c9a524e725d522f79c3206f33b6898b04213a42e19c7191baf3b4bebeeeb34df2fff94186887c6036222bf40b5d672e0495405ed1410a8eeee3d75e7cc70f6c731438c23ce9d347bec464aa63c3e1675b3d0f56d805ad9e23ae08cdd696a8f87a1427014c8e0fcab72f9c35b9b23ef997a0faeb04e61348bfb7bbe790ae0012e81c8e4f337139e12103b401f0b7064fe4ef53a43b20f87ff05c6722c503ab6e1c04d6bf130d3b5e576c32675b298e2477cffc3da1f4b3764c15bd51c296f16b303f718387e3b2b629f483361f1e5dd53c4e473d3f72b665675c64ae5ec8e6d2a671114bb8a0fa321d3e5efcadc81bd937f035d42cb5b6bf543e9a7923fb4d8cb648138ab0225aa60cc20eaba23d257d71a7681cbd666e95f52633d22ca4cc9139ea670f52d67a626d2d8b6e6d661876ee6fa8509954919d45cddee3bd119b60bd0c3a96a3b051c1737c841a8ef4b98b0dc96402e6421644f9f88ef491748101a50136fc610903ee3f8e772fb436e5998dcda1c7dfdddd9d6c0824b5a12785650ad7b56207a7cfc6a6e95f86f87cb3bcaab456c7e8921f3b8dffee74616aecf54b8865a29e32343bcc2c709975cb7897e62b8e49f6f4c029ac1eb8752a2861449ea6b64fc16dde031dec5d39a90f1c2b898aed5d510e14853d9367bcde4c8f7725e0ba47a20d26f61a9ebc03893397e819f80d2f907774945d049a1f5bcb191970430d8e3b56320fb74a607181cb0cff0424bd482742c0fe42fed7406d4bc9b0c840b3cde2a112ca51c10be6d09779bdbdcbfaf4a046170e1e921f531755db19be879f5e6a59b7e17db5bbc50a149ef53f2cb0f842689d0d0daa3b2d4f60f43100d7d28ddc66cba701db2bd5144170fed127ca55b847f98f59d678ef2757a9032c1f3df825d17a3fc52610682fcb776c54873256a8fa20d8da6e8364fdb2abf2233ff368d5b8a01be8db30528d7d3d8e73cf30dcd11dad3c6c0cbfdcc4720226c1e6160eb664cfda3dfe56e9e3184a4d1bd37d2b88dcd2c20ed9d7899a7138f08905a34c1ef27c6ec94671e525b6c1e9149813e4db5a1b4f8a186bb3cf9f9f28704ce34df68f57a58fde40e2b76a096165c314c030b4973ce1585f6eb8a26745149258bab20da98f9a0f100c304c47af5b2eca7b2349906590e78cdf254199f7112070fc2faceafc97bada1f6516542d15e50de691071e74d47247873615110bb20a91d7c9ce4296af4f30df34e2dad6d4161850d66f120da09c73a68ee6083ac2dae0e7848cbb7351a471a186c41997f08d9730d634ff43e1272300f674104866f2dc01f7bb851b517a4623f681180ff7c51c44c5cca23c116fcec9df35dd3bfab869df17ea7700697a889d83eda7ec6fc54528a39e4eb6fe1b80437306c4109536377264e7cb33cdccc23387eea27a622071f0359f34e8ef3f7340ff29cf59efd8b19f364238a1bba87f0d691e94a36c0999743363b43b30d2a13df898b58a3bc920e73d670285fee038409307da553b17de9775d69a8fabf0ecbf53636ac63dbe2d61116f3af0a31f925298392c89eb7af8b6fd6b08d31eb552b3758c941f22649e2d255f62b9758742a5c870032044a9e47a15604e0a2417a0ed5fcdad321f495ff88263d67e8310c0954c441dfa52a5f65d91c6a9a08b184fc37071d537c706f3401e6c0b73c9eab26bf2b31549a0dfe3357422cc6c2105295cf214ff6d0d6d932af003a8639bcc5a358f864021de2315fb0ae21ea6482ae4b30c4925a9ef9f527f9b2af5eb13de2be99a63ae021ba7de47aefed63d0d16e7d125ca87e9e8cda900cec2a5b44d4c45b46e71d707a825f018283ec8fb6e0c4dd844ad510f360e34255f47b695f1eafb0fd082b6f10162e119589a1332692abb686b945e0f2f371d59b05bc6058a01fb7afd6d9b90c24a846d71b22c60e867f5d6e298decc909ef10c2a8b06ce2c59a13e0072e11d3e29d26ca30387bf0c788205431fdb67c88345b46ae3c5b31fcc4e790f0873c4472619196846cc8e99257a9ed43a2cdd5cf8254294184e6b2c295441e9f2f39bb5f48dfaf696a12bd5fe0cb0ffcc1ba60a0fa9be1f4d8a1918286aca5308627ac82036e0728bd4c31b934a4f00c4d6ec8fdfce39039a7d61d68a9eb11e959e1a11a1ba4e611cffffb6a55547ba1ac7f550a373a63bf9d3f0b0207369aa9fb173384d52557a05fd4ecfc7df647c9f35ace66e1e1e18a5e621baae433a9fcc7592efb688bc090198297b60a0f9d00a130b73b0599e854eb05ccdba64d82be068613897073e9bb956b654b8675f6e9c11e986a1de4d579c6b67f38b06ef921ac31890cfe2ac57922e76ba968c5fd0ef75f904b2d906dc3e753eeda5a133163146aeaa31334bc6e751aeb05670dc84477fcaf72eb61e44dbc417831852258f7566d5da74d830b61e49a285b74c6c8f299106bfcf6cb65ce84b411fae74b9222814a191e1534c42217fc96a0687fb91f5ac4565199f7c8872a80d5673540702fbfcb929ab103cec57ef7191f0b04519e543e1947ad1248bf79e369cd03e0c8e09b5f0dd2f75c182681235d6377b5f6c00adacf4293dc61afd30087b3962fe69fd4d42574c91786381c99cfc8f8e0db5d5409f7ae9d4779cbbbd5b8091ac81bd23582ea981755522562f9b1590bbd7db710b01ac462956241c651de7d5c5b1599e88fba9c0b5d218676bc1f22fb8b722e5a3964715b09617034e5514aeb1af4923b89b44857b43b49880206b481e499aa51513eed5cdaff6efb5d54f98e1ace461308dbdcead0864c7838926ae42521c82d6c2fcc744d82c5187690c6be53b8418da6c74693785a910e6a6a6a5a81ed22feb74363acd15202489794a543275b1f003b17ddcd53213e5049689098578321e30f04a3bb18410a8ddff5c2d2779036e49f68002587978195bbc11ab49d8d1891f4ce9888217b2bfdda6b969298559777b9512688b6667f413d94797567926341d5556aa386a3e69fe69222545f942de198847dc2814e234e824e266f9a5c744fdbcd59b9daafe4ebf19e1f63058e7d09af25fca379a1b6123130948549f0d14249bed579d7e82feeed9b6ad0978afbec40a7ee2e9f40cd9062746a248e2e36b86cd884ed637228a69551be98aa6dbcd3d0bb73826ba42a493dbb0742d3c5b9cc2bcadd48d7e15d1a38fbff98e150b79d78025c11e0e073bea0166c028e9888ea085f0406c356fe110033ec01cffbcd30825edd92eb0651ef714f58d3c52c31df0f269473c7a3c0198a16de72fe37d437c5c38f646e717ca922320a8c0290e0b89e206e60c7568cf1f9187abef338207ec751d43053e635546f55da56a3d5aec18cbd8a42490b8233907384a89c458c3fe412e0cdcab72390db45af2b1db8a7af40cff1f7b24997b914f81c6a7dad6f710bd0f384e73d9f04d6bd1b924050968a3a9e7d5fdc2263516721318b52d4e3c70abca10a97487bb8ea959a1650fd344562076c10e645a23dd5cf217f58c9228a54c2581d2998ca4301e2369d414cae0ad692bfb156c30437556a6c77ebe09f43450fae7f6a2981e528c939cf8bc0f39ca25b6cb9d6f401293bb189461de9f7af07df9054214c098d157a4d2141f57b7ded099c923d74d3289894a4309575f75d751762a3cb34814ff746aec15e0d27e176350fbdbd8c8de4d6202f24ff30152dcdf43a255d4dfa84d694e8a0a692e91e8c96af7510b5377dd073d7881b09d3323b6f780f9ae15505e06551748e5641454aae6eeaf1184c4c68033f214f88aea61600b7f86156aa5c2473fc40a0913ed75e6d7a306b87a057297833a8fe0c2b501187dac3d37bc8f1592addbcee1d0f93945be889c2dcb97bfcb98edb9a1bbb85c70ec8dcb3aeae1cbf23bbbedb76248ebcfcc0989bfdae6a6938dcbf5c9a460b8f2271560972e09902b3e7ccfda560de06186b182d3b06f6ca39fff265e5c90aef2807c0bc00fb07717e38ffec73651b8488f3a2eaa31e93e41f805eeddd1a7420e22cdac0dbd08b58e0587292da743b6c8a5551ac2e3e956eaaa23632b723226c58c92e3ba824e97ac8aa4d2f9a1cfc959e161dfe8ffec0be99cf371065e82db8fc1d872658cc8580b29fda89f5aef30e73140e98dc5c45e52beffdb43e8db66436e6bbf0ef0a09af75c3ab3f29acb990a316225adf39c4279fd22130ecee21411c1f70c9cf3320fe9a2d5d68a57d60669f784b316b5f58f8694e3c3ba51d5e78e6d405d0e13650c0a39ee75050b0df325a482dbd17eee0ddf4e85ae9db13d671a1dfdc2c10448ff7db36bcc10415907b7bf2dc3f5866fb2116792fb56949fb8231848552fb5939b0958f5e7df5997591e2ec7916418e61141b5699fd1f0057d8937ac310398ecdd8b00fe6cbc22287077b1c671c73476920fe06e369852b8c328e2dfd83956645a6cdf7a28e0af95c23408a4a514b4f3a93f758dc94281aa93d76e68f66a4720b11c7b4b43eec409cb91f21845ba612020bf1ba229de415d5cdcc21c9291d7e2758cbf3dd83a6ad5995fcb8df7eeaea116fc79f7ecf9d9cc326af40e2d2b6b473ea961ebd9a18f7fae7ced2e7f906dbf79ade51d8182cd5bfc044c6e3673e2a78ed03d4d6c96f5955b666b2ed2e85249549b0929536b98447168358560d6a58893f4c727e5ddd477869cc190a6bd7664441db5ece86062709eb53002f9b22710ee3eaf8e3c382c656ba3ee0e89813dd8596643bd0980c41841a2a125efee335abb29a991019b272ef7e2da10eec360754b79e8f8c83ce38812ff5f294f5aa93dd642f7ae5f2491021797970211690cb91a5d30c08ed09d178616032bde5249112b8d7e96a35448a81a9c8b50873341d623fef7b29950008f50a2091daab8dc43e121c13ef6e9650938ab9d4dadd08bf48791061ea3de237be4c4922a118e10e20a554d5a8b3b62fc886e9e4c87ec3a232c644b9d60fb4b22e00a60412402d139879e396f77125dc050764b69a02bb382cb4c04c2e2d113ebdf26543b3ff22801d52d07decca001ab5270bb27113824d0eaf484a350e74bb8eee9112f2e6142924e6affef4212782e10caecb5f33a3fbd152961939d27e6fbdf344f6babcb4e45e9d9ca5f4bd4d4e69822ca3a1cf7061b30f2ac9ef29e48885f1de1faabbc14e783c371f9e6434cc42443b9c967d44f4cdd9406361cf67ac12c9675ab4970bea3887ed97a4897c5aad24f5f4f01365769594e0d88b0bf5c2cc38628efe02daf217d7d9f2d79554e03a27dd6242cc5a62511b164140825ec2d67cc2db513a9e339788065160ee0112eafccc55dca8549ee4df36912aa8bb935451070c0b82f2d32d03b0e0d1c264ae6454f612992908624208246fd809928212ffe56d5b54e2686355c16bce9d35fa16e1468cf0a36228b097b4b96cc2aa288acc5575b0c369cd9c465011c05585f1ea753e631f46543cb020c9684f8a1a9daadee9342d2462249733b4f18e2a1657e9a863c445d9d920386fa27cbf52d982f72b4ab16fdeab2d1eefbd823eabbbf59b969845fa3aa2882f156bf3b64ddc7953c30d9b544e1590a9c33ac8149ce01034958b2ef5811a46f8511cc2e577a05541e5e00c212da255311b777e861e530bbb746dcdef928865b10b6c4160b386b464dda6a7613a3b388668c683173067c90a5e74ead8ac8889270c18cb482be7e3c446953c560ad94c4ac833cc96716252a822e61cd664edfe41e1c42de297df4b791607c02320ca5e020472ede80228dfc1d14cb924c927539007f02db4da879ee6092b1c1a56e792efee047647098db9b3c3ff46a2b774de70a73c501f69eda95cca298dc72d1e0a0cf65b8300b5304d89c4b0644c18c45422e449d2f5b9957a6b6a10648fa83cfe38f8f4d12a0d010744a835cfe55931cda9936569c0ebb3590cc6405e45378e255d9ce9eaf8479cf7a654410b8e714451db93a503749de8078364c4ec7e89ebc239b79d2249639fb0bf5c17422420d7c5136ef59619c39a66b8a47933ceb596f9e949c3fde8b5b7dde16e50cbe2565eb81769f5d6cf0d9c23560f782cecbff06b67a4a4499d86a5b6ec5b83112d8b04e7aa364daa5efada7bcbfb946bf0e6be45ae421f5211716e8ce4bae0620bff4d962f6cd9e945251dcdfe5ae1951a1f9b35e27a2aa57eb97b3b16ab61a70535b564e840e76cc6d44777bbec1ad87bf0c9eda863656d3d91517f8c0930dc3e5ce10a8fdd7f18af58847a312861b4e3cd1be745bc39a393f38eb1edde18f7d309158199caebb8803fec09d0fa8df389a93a134486ce700f47746263e02066d9ac4c79c82014d4a80f5c03082d522f896cd4359551def6e3219132f4ded0f590bcf02b853206899853ecaa17eea81e59cbc0da11a78ae15ccea7747a700bf3545263db633ae1d8a10536216e7ce8622dd0b4262ecfa725b6c53625541af31c0ebd4d5f7bec2ec48a55fa15ef6e2cefb2f99c14c59ea39c478e23336602c50bfb449295d61d90689ee2353b1a90499216a8870432dd83e5af3cd566ae5f6d49d03dbef664200ba4d6ae3282bce46b5a3699246d101c455989dd41502620bb38d888c22789ef0ab85aa7dd5914aabe48fc2637f4e3cb963f7d81f73c9933be55b1b9050c03d4b7362a8e53fcf1e010c24e4f9cc0bf8e237dff74a01dbefbbea7e8feae206ebb6afc4aa07f2092341614e4350533c59995f2776a2ebb35c74fad7a2a8137bc9422569e509c80dfc270b7af89068b78c1bd5663cd5dd3afde80e238072c24e90c0d764c7650a50b9a401c7fd34e3f47e36b6c393bb876132a8f72c69f41198834535ec9cbf18d0ce9ce9f756163ef7c9d7504139d61fb61840ec0a2cd2b3902e4fddd4371bdc89f485d7136c9c48c11c26f9ffa8e6fd99ae756f1b3358be72d79b54c5805342d430373e33cc959128680fdb18156e927d5140ac34b9447389f683af12be357d7292a76bc8893ced0834a8a923b5da482ae38f31048fb2e90155f57e0df063d3b526fd35a1afdb391edf41e3b19b5a990af48bc00847d27edc09c4f8f09e82598d932b9f0758a40c39dc3d8aa8bb234576ae6026fb1ded153df1baa3d5919d5315fd16560a54f2aac0876a0ebcf786306a8c464b22a2df79dadd8d7ecf4359d1dad5c2e8c1384e3b0a4971c9b673314b258f3f3216f0cb309f0bad1cf10bc8e4c584c4ce12acf5b46485683b8697ce86880b61e9b7d92af8be8420b1cdfce98ab974bbd16e74fdfdf65255ab14ed7b37742593ddfa246f0565cef66f1a587ed5f37802f8f3c5eb8ff6bff19adad95e3245866601b63a254d396e2da75c780895efb7d6c0899d34a25d35e3d07a8594b7b77cdbe2dbeb58024d9bac8e412fe53e65b02ea5195eb6de7a68e825036d575cd830dc5b5139d7fc91525fea31f446ea4c669d0827f15d160a5aab92662caefe8aaf48dbc647449eb436f9fd174b79ad05503111ff0dd23ac3a4c4978375db99d1679173b3c0e06afba5b5f6c1344d5234c4da0eb9a812b5f4f46e203fe8efcfae086107838901a156826e0c793fc73b7baedba16e02f1adf745c12cae77cc11626caea8ebfc21932929d57090daf58598e50241618575ced034b6f19ef96e5caa2f5812ed2388e8a2273bfdae4333e77fce9ac8f022c34d28e4e0a16be526591389504e968ce2cc53d520c77c67b91138d50a59cfa2a3e8e1a22a8751406017eac57ab0dbc2a72b0a0beaa1ccc869d162d4f3f153669a7d3a7761e5ec493976cdcba5980d3fccacca9625c9dda502f7857c502f360f8fb0d7ec5e294b687bfc03f62d150a5422bd7add597cc1e350a23b7300828134b76fb6df5852020b75c07f45ae23b5216821c2575544d166e2de0b5ad128344555f9db940e9adbfe743d6b02fc298fcc6f7910f8dbdde7d79b4c966839cbe62d3dccfe852c4e3c3462173bc4ff12971c1ccfeac7f84ccd5b4d7417976836628ffbdd4e37e33dd4e72006bc70c03d0fb54151e79a38056337ccc6348f97a95b85fc9ba859d1e30be0d1013e67b1e7406a1ed544f0b283abd0830e541aaaa02894cd4df5f063cffa864457858e985b31a7c4000ceb8f75a280c660dcaf183029c9ecd743f3f928af7f7e7f8be89b6fc1ecbefc5b97b9ae5c3554378766d6e6d4e1d74e9608eb9007c683e69eb0e3dc79acff8c8d04a507fc254a14f6d7827960c70e4c81a57aa649b6b2e802e61358b5cf865ab73eb60f7aab77fba2be16a3cab916768bee6fe684d4f518ca6e7adbb7456edaa7ff05bce6c696d16e08afb714bdb3bc1db86b49fcb868b3d40f52d39c405fb2942a5f16c759c06de3195fe82a3f526810e00ba6c24827c49517eb9ab2f0b9efb8632596b3f50a452557efa9b3c7c804d193bd06921663f500769a224a134f447468225dafed373d977b2a3aac4051d86e1eae157db8d0f89323934de5a41e01985b742bf754083f662a6a236fbb15c45addf8c86edd28c3d4e672897e3737bd962e98f7dc84b2f92880cad625259516a41f45870aeac3e44b03ec35bfad0955519d8067ab437ad15cec8c15d614eff57cf100065dc4dba64c7e1c3bfb6b542757e08fe653e72547f134fe8cc29ab79f62f53f055cb6754766771a1e8322d48ee8e4542b9e102b5333f6ec6da1835c20465110bfebdaece70c295e9bc07fccfc1baa0898050bf918f5e0717f6ffdb648e3d234b19a8c69075c1d0bd2edcfe96e21893e2d35cc6057ae1705ed3446b7abf308ae96bd7e6034aba2b5b8117296f14eaf236f3bcf71038ccfaf2d26b6188f234b6e003318f4f0005ff76a00d729fba858e62fe4e26645c1f97a41673c88a89aadc4f043a9fb5c1e4319f7ecc5450e797eaabdbb9e1ca59520eca9194ff29638cf30839b2b4bce90504cc5921e489655c2545054b0527077f8ff3af2c87b21718e676fff2cca6d1571100b4394b116b0c94f9e75805e1976e07260e714cfc854aa4fe1bd951e507a2091153177b69897f70db156e9c160626b3412f911f8c90f4478491e1f2570449c39b33897134840d15fc1a22ebc51d2fbc5dcc96572959a0c61af30492746c6ca58979bb078031ea6ad5c7c16c1c571c1d387571385da3827f8022d13f2212d330bf501004a896083c5e269d54ebe0430e286a583dff641508a3b4f3f7a31988b14cd29e00c8f753720694f6037e417d7e4cf7ff7542beb28fd285ebaf0c3ff24585f4515a52210b278ae50928862aeef3c2e281534cafdf2b5c90ff3cd4e9d48c719d4c9f07190cf066b4d7098d354b812c60eea2f0773422b71ce2160b8c7a9a2cd12542561ef3245604143736844c337b3187f832d0498c534b18476ee7125328903aa8c0dcb911b9dd306ce0ac1d00ce4b473eadc7f66846e8425a9a3a827eebfe9ebfc08269874ac67c6c29badfb68adc2e5ad3028da8c07189ad6672f1abd62e5d61026c03768a1f9cd62d3a225a9688857e951ffd79bba279ba6a637044090dc9a4eb7714659a2473eb32e173ce8600e06e919ec4a43d55ed83a31d798be3fa3f0f10111445df23ae229d023c78c1a2bff13fa5df9c34972320faf20cd66469ba27904748ae6f4bdae53bc112b1eabf2cf6b7836d133fe3c33e897f9855f859f7949aa5cf3dc3f6c421284f0cdf2654448f033e08a92b5641dea60f943d6749e76842b5a1cb8089988db8fbdfcccb263f4c6ef448c7901c36d3a566c7937384e2acbe85dca6590c2a3bb0a26c941b8afeb68432b76ec00d210c5f058ff915cb4c246453b4a3c19261df4202347f31612f91b60dead48022ecfcf1b9b376aaf680b7dee8e998e411da4e8241be1c82cfe6c7471c89ff9484ac47d094253e8ae054f3ed69242ff72e2230cb1bf633df9adc18aa429ebffe64a53a9ca8b98366d6c02ed4621a49254f908775140a6e50431b885fb68ac5102ea3d2db0ba4a563c36edd2cf97974e3b8f874957fae700655fbeec0cd524cb37953effa6d81576ce3a1cdc94efff200c2dc9e2f581d9b01bfd4aadc8ce8b41fd8f6bf2670d8e09145d8cdc63ebef4366046adcf570c712da5a2f14a8a21977f5867bb49b1240e50a4f70f20a0db85b4fe60612e00f5c97c2db98ee1f0e08e43b0c6383c5408a80a9ba151ceb41de89044d072271db0cf5c96823e6beda173d0be6687718f23365e760b09a18d899d8dfd910169497d60e788eb1077c12e21363e18aa22333b99d309f21b2bf99ea70ca37769ce7cd9ce945886b09c8dfe28a8ecdbaa098796bf35cec95d05b4da449acbed1179c6d33cac9f40f8206c6ec65dc11b82ac6b4816d656a6e4163f393f91a8be3e9369612d136bffd1c042d3bb9960090a93550830cb87f1b8b7f51a503d1bbba9cbd2383e7c3136344d591e63d4aa2402ae3c5a347641b011fcf15b01b3b0abf40bebd995a4be922efd2ab88be55fe8bab717f5c7ced038eec9c05d68d6296ca55a2a60e8fc8597232401c4328a0b72a9729f33587feb0d0a3b95a4b36866b26fd83209cb448ea8e1629622cc53dde6108971199980d5123b6eb0be18aabce41f5a217fbb9db6c4c0b73634b9b3573138f0a492b3539edfba390532535f7a20384ede9c2a0a39b3a64985cc2643a2bae557ab570115da72754440a8a8b6f057a899a84ffaa5cf73c3ffbe684ff42f89a528aa5cfd5eebbc412ed8bbe8580927dc7560004e205b57dfd5d30e543e132f55dd4561fbf52549eebe558d1e19e86683482719d21a0a488e435eb0a6cb50e5140678d9564d3e16ae9bf03db0c329f86aaffcbaa3899f23f76c1877f02e1e1538c3eeb508d9aab7dec78c2b54587e4351b362273bad6ffe23a6d174758c184eaa5997b3f5d0b7bf473a40ed21931f491aed76b4e3e2d5211883420dff2af5149f332fc99d45c2d0f20240f15bea2fc61865997b21747311521fbaca6434b4bd1af72db98424ccbabaf9a5d318b3f7b24521cd4fb443acebf14b8a6298cc44d059c0b562121d4c45bcefc8dc537a5353143ed8acdb7a682577b0cf0d0923460b17647777769fa6916e7ff8de3c22ca88ed8909e0b029a25424119aa0cacd497fec099d0f8fc70ecf2561b613614a3c70e31096386937ab32dfe1565cec5c57bec48c892a3d87810c6c19b65d8809054b59c5c35fded3cb315f649051e873f145b8bd9b6c62af55c26b80dc3e4872118c9122d43757d3f07af3516860cb71b3f300cbdffe838a8db5b70cb585a2ef6388d115302d26ae25a21d49cbf6f595d1a9fa3b99a8577634efb12cd5564235c0c35efa773dbb4312a54877c57d622f05fb596feb50c328c736615a40e3a7266503b92bf4e2fb1530530234313c6b401af2e71770046ff9131f921a84f8c26760db16e20f8464a817ef65d9ea120482877b7e29fb28c70abf628f1ff164d38daca1eb92e77bc3a784d42388f01e40d85af8e3a88c80316ce4075bc06ba122a89548996ccd142373daa0bb6801c71b907c7e54c4d76b7f8cd4cc9c92b74500e3b4fd902b3cc09afc262799cee4d3eaf1f4c8167559b4d9dc1904a473812c558099b281aa7b79804fdacf44dad6a1e36676eed5c286ae914a47dd240e6c7cc531612f3901d05f68cfe9d94afdef81b99d16bf8af7646eeb3810f4cb7a796d9be1df1334ea4e8c41fd73db9f18da0244c4c4908c80eba4ddc11b0f1a47a4a3f521f766081261d449ab673871565e0c13aadd02b7c531492b92fa4013df24d570af9a4b89bde4c432aab510d06bf9b044de9bbc47f25d64c1e65c66457b01b04b73e20224511b0210caeb335dc39f94bd91132698f7522a1963f4d6e3fd25fe8a7d1433d23e4cd8a67722a4af94888f8e39b1e59f819eeb2fb300fef35b9225abc960c00fb702b592b48b261f443a1703b478f28eb83786965fb53c99b0eb04885b8eaf4719138523dd282a12005cb435646d0aca12f381c72ce556247b594dff534d3e7850f0a4feba6f1db7b7e7683e2001557a474b1e87c0b76e64dc405cd0a3086193b190f7da09eb347464069c65fb782896c6992113a0fa6100ac4f2d526e6f08d32a41edcf564e59daee73afa5155fc6895b6b88b87263df0ca1104b91106ab73775ec253b55cd7d100e2c38037a47c6df43d601e01863c6d8e051cd240d16d7fb39c40980208c13283580ccd6fac44a29cd6e8fad960bdd099fe9c2bf1487b5b74ce58f8f2a65828603eca0a67d624ffa0701047a99717db93b99c98f8ffa414dd1a4b6ff8d8b7ea5ff128b734d287975fe9de2c3a66cc8c2354b65834824a2c21d7b72e2d46a434686b3ef2d11f756a635b29aed96411e88d9c5141f960d0536039982b21ea13ed67754df0ac5f2964ec20e38dc55a9dfcf8af6595cf056fc8571966e9ffc5297def7373a040e1b6b1396be65f9ecb5eac227b18d3cc19f378c112dbc7a5c7651d74c78411872890661b3363163ce41a335ab0ec207a16a0959e1bcb19604c6d6ec1b91b5ed3a2e725233fe9930731cccc6c15875b972a10a9c8e7981db503c419981217d2173a9f9f2ece5c795b5fa2081d94a91f18c3347bf2cdb5c21a4bd9adf961ea9676b913c9b4420a3f7628a4b7ad7410e6a063bd30f2938acb23d6fb65a11fbea064ca245bd443bb1befb5926bef3ea2841edb4be586ee5cf0ccd46e1a164925ec93e6b5c4dd3e3f022293d37a5b71f59dd6708a48e32eadca40e555ac7b82bb0e22d1978b7d700fb095b6f54829b50614378fcf0e6688a6d678a443dc821e6b7da440589f099e580eb97c4c3fdde49056dd29f8140dc62c3832626687531df26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
