<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0c73dbd464e62ca70fcd9ebe822f339ebe1e3fc73e7e8d1ba0073e4f5f6ed39ff0acab82af5419cb3bc53db9afdf517794d2912f1daa4cea61b32ab78f867aac9b8f3842e34e2b1932083f0156aeca604c9bf08d3d3f9b6b2a61255fb59c0f84cfa3dbea250e4545503c69fc4203deadb0dd6f04d1cd646081a8498154adadffd425f7479190962a0905c3e2f5af149ec63584d3177e0893867be0863a95cfeaaa2d7dce2314947a1da595eb7ad2458d43d2dd02ad50650b9ab581be3154dfa1d11d1c2784ba5dbd50ac7ffaa117a563efb79bbf3b3d6aa3d0363258c473076c9d7eb458587031fd4e5540241ad74ce38b71e564bceb8fc61770f00479baeb62f587a944d2a1f70bca6b731fd87ef679cf352e8c19a74e33b9e1dce941356b161a3010c4d43bf0f3ccd99c2b5e951e9ed380fad455e52b3ecf30425b400ac9798da23467d5590e9bd4f7d09c50f5ff334a201799d7c33f7b89891cb759eb0cc5ececfff532d5d92d4e6ff7f1ad8cb764df43520d3a57fdc9d10bf8a4687483944677c1842e02f89dcce0e30bf2070ba4101829bb1b2b3782b4415c6eac3da4051d34ba01ed7aa35c5f815d70c4b74eec23418872785413ed8d6ec34eb4ad66a0f27d0909ff9bbce2ab6a6a224987170c8e26010d257ea31e088e0d53a4f645bdfcbedbe7fbb88883ed46d78f23110b049953d77c5353b86b49b1a4a96bc6fa4ba2a574db652b8619f593ec0f83f21c50705c52dfef79d46a7c6330359cf72b698c4bc715eed1797d98ca20a65b76ae9aecb583b384388d363bc68a847dd4aad2e94f057bb5126c0139b6b0d81f63b6932307416252e56939fc6abd1eb6cd8ee4cc556288a9444dfaec93d2f74803ef8330e90c1d8cf488de487a9c36fea825aa9db553d1a15fad2fe685c05c15eebc68c4a9ab7c43b2bd3f87b61c46eb0c1d5505442cdca813b1edbd8806edc8ef785ffdcb02ae2704ea213ea74d148042631a7ae1c31a06b6d2656c360c7b7e416ffa1efacad114873e9d7e6b2b160d3f1ea99eaae781e74265cecb34d681b071b73350639da0f1712dfa998b4cdf76fb817e2634ecaf4fe4953854120f37e2444a8daa791b79a42561adaaf37b6bb8318106b707986097293209120896b28e5514bf06354753834b3a4d03b2c6096282bfafac838a653d739fb476219f6c9d15830a84a4284a240d32282681f8443ebcb9c0f7ffafab4f4ca487896eb0a151cecbc85b69b20854515861fbe154b55a267714cd5d6422fc0d34937050f4416e73db05d707a8037512ef28a05ec46f144a004c330e728da5fa97a0c1dd25cc30613a1ec5677fbb0c0438dae77bf8c9b4344d87e27333f2a198f7141862286721c59de2fadee54e2c4923be2efb9fc8d81e5eb4e641ddd67845f9e07550225310743ff34efcc9de4e9bb0edfded68ad751e1e5aceb1e5d6b893f0618f36a99f70ebd9a6ad3d91c255272709ac7b4bd319686c93e023eacc820d394ba8d50f8d2acbd131f37a3ca4aab2ba86ed1665def86ff8b5626274d795db0f05867456be896c21731c4029d7c2580ef0b2cacdd97ea06905051cc660ffac83136e8c6050ea6c7b615ae5de659d3913df0aa63b161eb2ad59e06f68e6e4f971bce9ca93a242b8b4f6cbc21dad0c6291091213a1d55efdc6d55e549e878fe6ab1485880af7d4b90f425db132ae881aeef392c0ad8dd9219971e93c45fa7461e999c72f8dbc0b4cedf742e28c615e95e5313317fbd602ce47f4b26cb5e11b5c6b97a7edf16e06ef88d01435c1503e67cadbf74c76c0ae004ab47819ec90125ceac7554c64fa4beb316dcdc33820416bf8d63945d4fd2e99728c6cdbcd926e1692e7facd0cb4607ede28a7855cadf425554438f4be984acb6292cb8464e5c6a8e68a1bdbfddcba07b862b0b23d2dbe54dfcf2fcc55e8d0f06543c4b3c8c2d4c2313a20449a137abaf60796a48f573096b0a2ba81de3d11e1ed21f8f90dd37dff36fff03dcf436d8d8cf78f1c583f81f740951c0426ad99ccfbd9249002900b967db79af3a1f69674465ceb3459510c9f1843e94daaafcbb7af408cacf1ea9c059d5f65fa1b508a72d3a9e63e622912f6958b5025def404c5da233b21afae7da5b968db1bf11e4cd548f9ba95a808ee20abf077579e3a7dd5c3b70952d196dce7eb35b446f6384aed44a544402b6abf56617563381024e5113e6c7e9733c20556fc7f29e4370ae754ba986abe6b1e18913f2d15d0886c882bc3f254bd92854e93f5a95054a4582ffa2acdc05fe6638ad31d112542042358ed72b26aa2ceb6259f20a15efc1f85ec8a7704a52cb691a08922e12edd60a1a7608f9414efa1e4d1a131e16f04f439406d84d149e8038761464b89803584c09ee777e61696b3caeb0a20a7b286c271cce119a641976e281bffd9b45338c897ce758410af5db0733d6e298cb0dbd19cf60ccd0dfe62668549bf10ef9f46e9096ea299482d778e752cbc1f5e0599a0e5153e03907de77f47b46c533389b310f207cadfef601d67ed03c67bf27abffcde871840ed25afee1e1db73162234dc4c190074f36155b4bc009c53360e9ba4d7bc1988896b54b0e687e4ccf6687ddde0353dee67bb26921ed0b1350776d349eea6787361b5a6e128bddd40f3862a186a4628c3f094ffa6b6f6c459f76431b2a4ab9eef1e2f56cbff1cd2cea3346869174698a57c2e8eb45b8e9b7dd5885c8568c8e9e86800971bc3c4f4452bcd38acdccd16fc0ab20b7d90d7e0c5411b4d1ba635aab892892ec8a592d244675b0bb6c4ab5760a8fde149b953e9b40c3422e1051ae8b3abf6635b891726434c200bbefb4df20c9633165e146ba8bf7f2db75e311704f0d1e898eb78c656b9098b4a95523dd3d129165e3bb7d2e23785272b8f41c2e71bb9a3395617f4b12fb87f04cb5a3aa6d89cb65674c0ee8360cb7410052f14c499f50bcf330f72122c1163640ad2e25f7d4b91e7d1ded7a18ba887a02de7dbc68e0a6bcd41d1ed326b0c9def641a4a1550e75cc39df0ce09208a8d95dd01ca74fa525435311457bc59eceaf9d96936bfa68b1b2f0899f28bf619db46721ae339b7ea4d1aad4c2442db636dc603f0cbba3dc8d6a7160f8c71d0d760a502943e275a0982af7d82e45254c15f246ed8e97d0ec7e71b0888f87df0430c58bda76e668e01c7a610912766c62b47eedc056622e51e066c8ae7f7bbc394e9b89daeb9d281d83af56de4866b36db364db5241b7725597e6ac69d52b2f01104c8e35327845b9136875b9791e76d516bcc9761a93d47b407d13c9e11d0424a1352aaeccef2830be02c5786da4d3a462375bccdb65e34c0e12a045be262f81c467938fc97156cc359501e21dd755bf816e074a9bf69018f6e2525d53388ff152ea11dea64fb80c7a7674d977249435d4912aab88caa864ec3b968ebe7990ba1c5bb705667cb96163eb679eb7e497d4ced32ee8a6f94911ff0a63907a6e7b5c4014f733cbff2d2ffc80dede3e483942198597a2e13579ccff1fe4cafe80b4071d67d56c6d43d965084e61eaf49f426a58d39f40f4c56ec1696b31445982bdd0078ea841aaf90794e6220ccd56dbb5fd7d86c52513e4558e8b6d016405026cb8c25102c2eb7baee6ee96f28ab4439db4bad495862bb636856ec6e8f59841b61abee8dfd4bf0d38fc1bc2c29853aed24f280271b0d08f048cd6be33550316ec29b867531e0f4dabe26a7c57b7d2f15318ffc71e5ca30f6585fda60ed623370b56371c4388eaf61313abb1b76e37a09816d47f356f6316daa7dcd390e8580aab4768c040daa779175d39d2cd14c13aa7520adaa3ddbeb983ccce4f64b7f0ae4a061215f0135bddd6970a8aa07e505879418d0f70f89435bf6b9dc3c36f58502b002587c3878baf850eecabfe93c38882a5d3ee068dce3eca32969dc5f1e4c113fcc4a211b1e0c695e17ab70a989323c0877a514622965af924b2aaa8a09e1601ab999b6b962893f1c3fe79203b084ed1920da2a2ba924e01a2ebf9e69edf02376d8b7b1c1cdc0630dfcdd654241782e5ccc83078f2cf5929b9f793a56d58158604f11afdacf498077ac11a32c63a7ac35f167175b313fd2cc7781e1672c2be112c7633302d4b42cf6b97d04bec00d2b0d94ec59540778377622494f844f521f5003ede8a7defd93a6d50ae34971ec89bb03687d7bc16d9f7288b88f8edca760d227c61f18e2e9b9287479c1795d124934b95699cf56817b00fa32dc2e042d03757bc9a784bf10c514a35480afe5f4fc5b08c407d8ae8a3e2a269416be43d11f4ba7563f464900cb5ff0594c840cdf2bd782bb770eaf3dee6f27a9edf3a3239d7c360f2b877a9ffa0dec64c9de8685d4354636fc3af483b95e699bc86a3824550753208a73e27dcf510d7fa187f31005e53c2ca7a1a63c46cd5ecfec0e45097ec2820a6f03c5f684da520810800485552403b87f8719c2bc16974fcdc7b0f64ea0b0bf9d41785b2b9faf405107adb0f01571ca84146605ff03b6958162f4885d3e0480b07dbdc15abc0819628b3c5914368710cc8fb549c8991b5c75f99555a91ce7ed060ec610df343a5ccb256269663d70789a3dbc55021ddc0c3d3961afc3c93ce6e76f9ed2a37e0cf5c9a5cfe511a1fc52bd1540a79ef48240b7af0e2026eb891388f91be233e19329242af0ae6e657ad5242abea47eceab58a3c34fe0d2aeca0522dd33fafa2cdac6c520f696ba98227bd83234e0667e2f650b9f33d586f5ab52edffe77fa7d9303cb10867be645ddc7672f36c49fd90cfae4eb1f03a8a54d951856fde12a08a08ea5aa7d06a832f5ae7f4fb75522656b22ccda178e9c5debc26102737b63a38e186f15b0fde9958401c91309c2c2c5c1ecc59a228a4a100d8b9d73971833e7f9669d9816b20b702d0a027edcb266ec8f1e2ee25bbb63b2586df68a3e5d8180f28dbf04aeb73829038c89643ee5d423e12d77d9d70e23142bfac7f5d87aa84f436e1bfeff5ba511daf94535262453021a0ee76e4da1c2f8db02762e5034bc6be3b095b846451a1b36c0eeda33913bdce0a86ffdbfa4aab0f293147b4b3df8bbf5a43e99f4a940286350ca5818bb4709622e656ea2c752fb89e735d30b752e1ac7a4f8dffd0f1397818493cc7fe94a932130f0a7b5d2596ec29103219681918d3a97f95704b640c9a36f8e7192c43df0c96d6aab2f030f1fe43b17746a560b0378b0a1bceadf764ac8a7326df8e0dda5524556631d2e9700b5ef5c76c664ddb09e4e8c5b7ee891b30a6650d3eb8023bb4bffd7c68d4fe13da305d78868be0041ff2fbee25ddeb845cebb8b19e39f23f1192b7af05add43815993e7f2d18c239c203ee215fb18c0ef1ec4296f78e4715f9b14c7e65ed22670faec5b309e0ad7219de8cc10aacb6a5765b486ab4b23c1438dbdf137651aaf6c3f106984f573a961b66343ab01dbb1b609b209d3ab158a54e5abbb1e7682a4cba0ab5dfaa2d53e2c44ece139fd14c33ff895f9902e08d50494d9238bea640d9d38401813d73b42a4076cc0f4bc1c7415128c9d69a8cd42d847759587c15706843f16444bb010f7b19880c4b8195097d34fb946641a2540e2fdee218c04e6391b4be6aba7d34c9920d970c56395564f1956d2429bf25d13ba9a146d48f727a57d7c0b21770f13f475b017c8e16f495465a8af0b41b0372ee3a3ce6ba9a7eeb1e07416d5c9c0da7c850c764e24194e425487dbe38c2251e29235b269e053e685902ab491aac7adf660fd1cc3d7cba0fd41879147bf438af69ab73286ea8d9eda79ccbed424fa65ee24716aa7e3c85163b4fc108a495e451622cd3cc95a70d1329c545889afdafe016af85e91e246541f52ed3a38a55cd7c2726f1ec6d04b7c43720cbe9907043719856c9fbf8b613363fcb8da1b8de877a449e699bec7bfe9c4b43dabb26d77caf2a6d908a3a241f73e35779f768d50e381a937e4f486615b8584afa3a30c19caf7487b959474f63ce9285b7b8fc438ba81bb9b703e1e196bc2f4f3f74aa50cd74833d8355f1b3914fea10a844d223bb767941016934fd53fc6f494a1761f05d76cf6ba335d299353a587cba2fbc51179c84a1959698598652bc1b1222c8eba8dd0046062a5fd154c0c6746dae778eac19ac58c9e5534cfbaf41155a92d47ada0a888c533f51fdd2089d86d7093efc1388eb67efc0d1c5b0a7dd67042b17a3659a29ba78376032616671be71da7979785e581fc6d22d89eff8b856430206387902f1ba98de903b85460dabfcaa4c6127b3502b5b56a9da5ae7ea190bd58593732014a87740095fbae05f146543bcaaaf5122232442a8d98048cdb480f5fb244da2de65078fc2fe6e5b1463d2ed22c17bd58e330e52344e5130120cb609a157b1305c9bf9029ab4f2a698dbb644f5645e388a5b11236d0ce558388cdc2bd1fec81470082e8358cf6bf4f93f6ffade02122482b61d5d4791a83e6beee2e551fa24a18783d61b0feb66f5bef098008ded7f876922a4d37a26efc635d06054969f984eef1f79bdeb131fedeb65e88df6996ccc16d8efeff830a968865da560181440cfe6c6b7a60df12aa107914983d635ec2713c05d3f5412db97a47f7c0e1d8bcdc74ee98eab981cc75b3bd714589462ad0c7bb421ba24de2c0b473129501812da63b9bfdd8adb7250273ba2e27ff7784706ec480cdd1fef5ab9f15d39d5ec9d222160c3f00390f4e0e63f7f675debd6e13da4ef337843725339bb2203a4e3eb64b4b690c9adec3ef1b6a9262f37d6f5d7b22d517be27e82aa3843fd7761216310cdc350ebdc8d1bb5fa4b6f00037190dbd329c7247efffedcc359e417c98f314f03ec0751c925bdafe659c3b66edd98043fc3345e52278d426d7ba270a95659648fe09643cb34d66d78c7858b918298ce76458194f3fbd6fb642b01a620d4e6107eeab05a206d88c3c177a1010ddba731292c431f77647612c66eb546f6ecceb9c271963cb6967b2b2aefc6f395891446259704d43124fcf8900defa655784ba923ce5a8c2e36a3d78f3b839bd93d13e41636e074e53d8997f3729c4abdb86d7a1de81f273c1a9f957b99b5dff74912f8f7b882aacb4409455f549e61f94a1459715843c1a85f7343b128bf5fb3f404728499e086c5df5d3e16d1e6b16fdcd3f136349cd93e164acfb6a74be8b7a6371c7b003f07f303e280470a765bc9ba8f8a54632fadd131d681c06c4eb410bf4daa8d85a216ca9637407bf948b1889415878f39012e657a0663d474809279cc7b410312010a69e4a39ca49793751a3bfc1a6f4f4ab332fc654efa5f9adc9853597c07a9cdd77a650aebf7c8b3f5ffdc0c222aa9ef2376d13c434b856a6dcdd75b084f3fc400de62285f595140f9bc784c49a8a1ee51c824b7423effc409a672e0d34e277b381541d39e0a19d225ce812abb4b8cbb21c08d57c9e1dcdc56d1f7db823074694596882f590fd8a8567037895c0b041af15cfd7a1418e7ec10d604e896cb51bd177a6ab4164837544e2071b843a093aad5f899495578a91d32d11b3c522353ab25ebc8def5866158106a56d335b66149ade796b34b38358f0622c3c8e1c8e1eec4e2432b9428dc2cef3bca0bdaeb8d2547b875a8397d5e5a38d60b7478f9f4d426fb5c6f3be55e25259df5ca55ad23a4ff6dfcddc9ea7f0f9adf5a2685a56ce742f6cf84388a9b114ed281ebe402c5788eb769a22d333d5c28f5ca5a61f4507d174cc1385b7d1d34118be598f1ba04c57b933a2e88ebd2312da15815972f7850e2d52712d9e1a2ba30575497b1fe91cec918883026ea371213265bcaebfcc3a0fff9568b8548060b2e71e3ce7ee683c34609e14456bd131671a9a68ff4e22f9b615b585a1fca10ec453528c1afcf8b60df082605d325eee34ac6870989e2a6bcd1f82dfab41d09afe99cea5c3c9ace29b627193035e4bd8131efa3e81f0fdf1037214af02fd9bd9b859bc5ce95050c134d611ae990093dccdc27c4378a44a328e12c4499c5b32534db5f253c5487770aacb96fac33c16f264d68c67237da0fea42aca09dbfab691e0190aef816d87df95bd0149dc300e42b0a40d96fed895d8869de1428e54152eb25a27003d10b1880faa0bcb3ad75d52e1474ed48b0d80598069a8b4f5cb067e21d202296cb092e7ef89c89ee2c106ac377e6ffb7328181fb1b567f1f82b72da06704e60529c581e6e599b432f11f8d7771bc7f510a286f45bfdbf377b999f947dafb91781f2b82e3e7954f59376fe1d6d0973edf438e087c9a4cdd0fbe56e0f4e04ebe99bee1971be56ef9a0bbe3f52aff23bb87d0bda6385605404dc06e42fe2d79df333382f7fa4672a413aa90ddcc0582f48a66b5c85803edf3cdec20d8692fae8dad9112ba4a6c582cf36ccd3529d7bc1a265d640fb293a02ba6395deb17bebb7914a5d379fe20d9352aa7d91548041f2ac4ec3f788fd7fd2a3c99fbbf1a4deff4c14843b06fa695be764a0c8e2fbcc15a759a6f1d129912d7ed51ed2c6970360a7bdda7ccc7f6f1357334efecb50941da0f361e4a3fc77989c431bd1f5afb8b4ee2945b86ce97d185eff4914006d9db1724638e436f3dbebc5cba4798e6ee9e73d885279fa81af4d3c924f5af998c7ef082aa4f47be2588fed1b1320dfbbe34676dccec1399e32044003562518ee2ebae5d31c38d0a4fbf523a1788a79d628c208350cad17b476115c5359004a3c8d65ab3792d350a8c73521d603c85371d9b97757a01e08b43024ffe6c9aac0d2f8004acc38a5aba6f93f2aa7991f75d0537c0259c8a23fddc8ad25b0dcd9a4582dadeb5c62974cf172fb48a8f09c8321e77d91c02f3c38027aa32c0b97da97ce768acbfc00fa1bf2a5abaa2c7109b6aed4ee4d53cef0e7f950ec3147c3b0233e11e0483d4eacedbde4c5faef78ed527f6250ea779c803db30ef5c13a1c2835ec0b0ae4e2122c822969932640bbbef2481b7ba43fde0887735a23795d8c9d996ed916bbd0408510d25c5acca7caa34f5eb317ab11cb026ef48bad572ef82a4d7e45788150630301b20b9dc8c0c074bfe75c8720537a6038f11aa52cf07cdda48fbd95debbfbb3e448c14855f5c70c2d399621ac7f124fe52d81aac8caebf481491b3b2341c02045bef493e3aa80794229d0eca491126c55410c95c387e28f9c610dbcbaeb9717eb29878b8cecc1f2f3007df8f70fcd69a9d0697b0e38f2addb5b07d1563be1f9f4302744d23cc949c95ee47fd6f55e2e800d3ce181fb6d1c502e29fe59dbe1c8aedd00f30087c63cd322409d647a21acc850bd23fd91c70e8a1335212b4116a79e0c96fc0b47d51512e204bdd2bb891921d2b43042d8f29acebff6288d4fc95c107061a1e5924fab919322ed0fdda65ced659fff138140d81900ac1a3f2e02c6eca206213f565a22bcc6e7779ec67ebbd2a658dedaf236342c4018d644c19bfadb3d1d192a66c01ddb74fbcc18bd450fde62e166c1f0223ff284da141ba1174ec7eb718ab7bb5891d476dee7a76b569c51f6ec10c79c15667397db99660e89525826256bfbc8377d3a716834fb818fe62cc4d953291eb2ad48525eb28bdcb80d4ec8271e11ab90f59f9ec3977fa58f1f0007811e45fe71928a5cef0f0093daee67956944bdda144145b7cfa0a07030d427c08ec58fbef1802c39bf08aabb12f62971ca3b7d42d772635d7933e9583e6dac24a4091c6ad7ca1f60dacfe7c69aa21d1e5cc8ef943e16a5afc7a015ba0a51d6c3dc4283ed4684e96db3f644254bbd751e48d94ff8a8df2091a34cd501491d697a555f9de177dbf9234bd79971c2b207b7c53d53c8c59183f312b53704c93e45aa6fc152c0221f4b5c4bdee97bef4a2979766e3d140b7d5261e85609ac3b9443107f18800e3711e4078e1c923fe5f9c1022174625573c360752429d5b61890f2c10e2d768174dd58ae2c6d325fa69e7c238b1fd236d369ba1b14d480fc41dcfdc00aaf7779ff65b6bae0a052d68db962254f47f55fc1d0c4b75501330edba9219a832657d11de65f90e31053f580af7e52f071882075d7baa312e31ffc32ecf757c113f0d1c53bda6216e9a158acc6749154cae02b648b662697da197952db324bb91fce0b5d0b2f9d59ea647ac5c439ff763dbaed234ec9e66e7b3556be885be263fa9ecb5f2f55a707762a2ab5eb28c764c9522a0974e8ad1d6fe294e3e98f425982dbb5b9b605f8621536ff4dc100fb99c673e933eba182f48c6f756961311045e1ac0bd4522e839e25f102a713555d6be2436ef57082b85fa35d6eb625de9d8056e79b76e5e88e4628dd694944207090be5161e01f54e10494b151fa88912bec22cb1cce34e467e91aeb3e6ddc8355618d9ba9f98cc144c4dac005fc2bfaa2c91f4a8078f99c3dab9cac68c00e721e95b5bd8f617656ea81baae5d76e424b2bae53f7048d9912bb2756a14ddbb2849b215640694582137d752406933f9e70173252901b36f262e528ed1f2f1a4ac5190710e590e83f4e3c1371670dfb95cea1373acd29beaa7a5d4036bd66c88b00ad8d9ec4129f64cef8d0141fee5ee3307fa3ced0a53ecfd0f10b73a5036e7afc200d3d48097654f550c3288d9020fa0d44ca599116f76d4212513c07a4e536ddad0bb4969ac114f29c29b84120a6f8fa3dc42b4c9e0a53fbc9166ac41c2a66d72fc8063dfe8aff034e6a3347739651b229d676fea24dd34a50b90eb2e7c96cdfd079b7cb863b06863eb8c1c9af43a8f8091fc44dc137959d336381f2c3543190963bdae87c54d7bfeeb86b1f856d8420a91fefb7957376d1f5ab4a831b5c128db641f4ff35bdb1af46b02cbf873e836478e7f77ccf655adf8c497814f27f541e3da9bef687467960a3ed63db948a357c52db1581a7b27923b1a1b6ba14bf6827fedae8deb758698cc857822eb7c82944ab55dc690c191142ec48cf7943278b921c654b2cf6d8d36722cb49de5b1cb54a788da59c50a01bb8fe3a7c7b8b0545a9013656056f3d15a0fe5a26795941cb5f952ae669e34799c38e648eba9eed6676e3fb8112f1587d96f206fe8ae4841c0bf9a0fd2382006a550ba5dc2aee045dcc3e52a6ceb6a83ecb3d37ab69fea3b1053262450f3c6873ab0d7926912b4065ef188f2c606abc67b2ad3ce7b8c718d9d06e758d95d41641c29cf261cec1feb6f624862664eb7d242f0509448797af69488ae90934c21fcbf425b4543d379c61a4a7ac93dac82e1786457e531e7153bba127bdc6276a214d7192ef70ef59f43ce37b9004a985ec00132c332ffc9a7baa6ebb062ef98575244926f9e902d4e32a19427fed9d4949fea16ca930fb72aca332162051b1bc0ce2edf5ab5fdacdea642274d9d52ced6a125b04634466abe9af18e3b33de55881fdfcf3f233a48d0a29d7cb58759be71169f8f34adc98538e73962d25a06fdad5bbf17c8aa11786f8dacd223d2abb1d3bd9d9096b04d43ca795fd1ce3aad2570fab1220a825060abca8d1de7e5a38942f440e7d0dd488511f0aa450ed697659a33118dee9193f6c346c2c69e9f8ef275c6857101b3a71a4f423129365f75ee5f8a84abd3236c389cb489ea50a350526af31908e1c8b2e2516eaa18a8084fc8a8d428360c5c1817213d7a782cf60b6ebd1a67562f42b121707fc5fb32918dbf10486729800d76b89a5991f426e15fb150ceaa453cdd649fd6c1e288d585075f4cdfef99ad49e5c1eb4b65a47e297e151e30a1b3677240b1908cfd610e4f902cfb9cdf5161d7371d6fa3243aeaec44180eaf4292a394ee3cf5589cb56987ccb778f0f94c2497e1e401b28d10b4860434653e587330e8379235e5803e0b7bceda23cbb3ed251fd20b2222bc00188122bb55f1ac69cb53cb4ef866dcfb24780bffb2223c4f346534cfe2ae7c3abf889b7922f2900c14453edd29a4dbefb7d99345237a7fcd6af4c5367f512d82067813feb1a07e88c843d7bbd6149894c46a077b7ba701ee6c00b6f9a619481fd58bcf51f962b2f4f5d9b37982fe8361e888cf19c594d6dcf2336a416920e081ee6cb898515544915652824daeb03a7e4005b09dd47313260e3ff7253aa7de408ce2574b30163e96f5e10e9b9f1b20da51c9474a90d5810944a6a1381f3c6c0b331f0cc229636f0d7593aa23319ff2632bb2d30e9f419a77ae49b7ca21308e43523fc3ebf79954ad9b1014b75a0fe0dad5a994403b0c868c8128daddf48cfb45c1f48d42aaac002e8f5d75c62a71c8ca4c59016428ca4b4e50d494d11becaf9171ec53ef285409f2bb30f6e75745f06b3c5c3d95e3b85b79a7e2ce197bf469e8abfcb262022127f79fd3bfcc3ef67a1555ca91420a6f3344a764188bc9a2d365e1ccd4e2b321e9e6529df34c998a6cf5c39f16dcd561b2a3719acc36643767f524ed780a5fc5b8af36f102a2926adb0c84212f9cef74121724e3054677ea2dbe6b4189ab939596c0a2cfc47364ac9f921c27d5a4b2cff8aac9b8670da708c271347bca70dda626da97535767b792086f53b1f5fc7a383067f548e9113ab1ba6d997ac044c81e3de3b7fe440853fb6642e5087fbc66cdd2c005d01e0a67391ede650a88f947e7c0802f5ca4f3c1c8557414403b7cb2a929d849097f31e9ebe5d2881d1fe710eba2736396bb6f3021142d8a568289c2b21ccc8d6a9a15a87f4acd70e00b4e038f16c43f2e3575a01fb90fb712a903d60be4a3382fae5015240598ddbe90c2e4b5f19958f7e8863e04b0c717b088a503c920004d5cf02f4f9811bce9494b0329279d69edadd87ad822153d2f30b27df0344920effd1eb0a3ba229c2b7693b57099fd2c1431c32dadf326b21f023fae2047054131a8149069e88d29f90a4ab387d5b70187a6d6705fdaa34f88be8b4a3551ae6fe0fc4ff5a2d34550f502a95080a98e67f8dc36af737cea3d823ec87cd20e4b8e6a97ca6d9dc1abda8ec891b869073cfe737502d62f39284f07ae19add1930729fc81d06777e0773a24b7970d06b3733450a6f04b3b981825e3dde460b77d0d5c51e8058bff393bb64a72db2f83774199137f713e6f3e5915d086d067e1bd3303aadc81b09b04987912b78b231c0b0e316d62a5e3380c6b225a28e897bc26ad3e1597fc2cfa439cb963cc9074e38d989bde389ba7ec526fe76d7d20b810f005482fe1d6403047181fb90f0147795bb63b562813a1762559ba617b28efa61320e574da91a36a864ce0b47d47bdf2d900677019e644a6f52539ac014340cb84b0f20cfabeb10526cf01c839452545d656ea236859fbba1938f53baf38e00f429963abb83f4c471d935b18a8e76e2b34fc9803f47cc33537236518d387e48434c7adfb77f82b36951ee4e0d0998661d85dd28ee623f8aec924698007172eb574e41e279e8d9942c93f6cbd02ec8759ebe77270da545c6c29243f4b02f7699ec4cc047aa700859148f417d7c9f5e3304ee8b27d0085bc05fcdbca52dcd84476442286dbb119fe2b550a21a3e496affe5144a194ae57010a60dca1cef4d06635871d70975b99bbd1948304ad3e84130adb961dcbfad73c9fcbcf9f3f9e97d554021d9f6df7f886b5ab5d4a1bdda59265f95535d0517ccfe2a69f426be8be384364db8a4064fd1029f206541af4d524565a7a52cd75e266a66d754de1d3ad244c2a78ef8f4249d984750a43e17dcf5ddd02433f96d932aa9c5331b2488c1dd66f1581b34f90a42e29f74032e97cb717b4d135dc5f3bf2e8a1dd54bd180eb407c0266c201101332b3ed97a88e43ae9ead392b7859d9ee4ef579d8b22cd5feed915a35948411eddaca2e62fb07cc2b9eb23365b1f54eb24ac7620c1f5fcf47c6c6a120ae8318227a8e883c02be540e57c9a1bfce3c9c6bccb77fa7422d71886d62bcb69ec09772990209c6d0492bfb1eb0f07f2bb1fb9e58dd5b72a5630f2ed0e8247f36b941905c74093a8e018f78286e3f5f434001d279436cfdeedde182151755f572c3a72675d99bf429f30078efac809ec1c1eb00c3333482a84298e6c22c944ac36c4398be5e1240a873fc462253d0ed4800a934b8955085a7c91bfc518968850cd86e69d6eeaf8feaec8fe0c4b4782ed06ed1accfeaf50342978b7d0178e17a193f98ca4de875d2912660b853ce1686fc82f5d1d2e3facc6da13cdaed60f2e3cdb81bd55d77bdbbb9b7ffbbde13a98df98c2f1b50482066b0985ec5ce0b4ad0160fe2f50c77333ccbcc6e7a9f181619984968fbfd7d96ce1cd0efcab79c41cc481b305c0e4e9e0c4bd1e431cba5a3769d2f7c42a5e7794afad751f5e9f9ce7a5d94d35384ea8464ad6767c145a075f1944c95b8fefe609c9322152f6d2b704dbf531a074ec74412fac62357f3914d60f7919d75f1889e2314e3d0a29048318fdecc85b5599e9c0faf2a53c37b047c3502452cc1cbb5f94a9ca17614fa0ac35e546349c05f1caa1226e17f38a674b193c27d8b8f51a747ec6a10903867d83ceededbd6292e20bfddcf39cda7c104979f725b36e7c51664822782dba0f596212bfd88d5f71aca8a0757bed885119c216269ad3fc24392396fe9ecb174ea758068a114376fcc06a938c00f24f76a71f6fcf46bd862912e4823aeb09b70ea2502579779913db5d585f24a94549fdae823a50000e83ba66a88c6a99195fca7b0c1041206a4093db2fce9fa605c8a146f86607a3c71f6048bd45dddf0e49f44455ba9583dca3ac034bb9ab01a4abca158e15f657e3d6dae1aa36cb9201bafd7fa5c4976a4a8a59093f80bcafa5ddfb4763edc1bae8370b2e708993c3551530ce243b05f46d09983d4010a8da0db7b8674fd7ac266b7a03b3f4089373045969064b49bbc138d049476bd743dc7012699b07a8944ab09de21cbc5f3acc70c6ee5d75b9d8998366fe3eeb611f5930bbb6192c59a05359ed8be1cd1ab97fd2eed65ec676a87731f633d66f587c267fb73aecc270b3a08b8f4c2494f93d568a01da20001197773fc9b8abceb7c71240f0f9213d8bef4a15e9367a5cf7bfe474c9b3ec74e89d817d4860847e9677b374f8f3cad69f6feb51e95f247889dcba0afad87cb621489cbe607c38eff094f0196247adf6b5026558a6ea2e9bba489c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
