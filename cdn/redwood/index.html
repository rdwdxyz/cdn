<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12b2abcc4e21f3a13cf974694d4df5b828c3948e9ee57c675ecbe1a2f99911b61ec4c14ce3409926b8950a289368b4aac4c1365e915f374f3e27a9259422fd5bdfeaffe21c51a5b0b88c5e821e9e5c56442f2e0be87d879829918f55595b9e3acc1a99859ecde70f1c74aeab68100bab699832560d7a0f1e5854d900edbb7278da28b96f11a61c8e7af01ea5f05d7c9ce69dc02f4ed41e8bdbfb58b530b64c3b91e91ac061f5ab1ab03f0a4adfe0ace247bff55041017734b37f66544e8fb27f0513aef801fca218f0d66ca61e7e1c0b1ee58feafa2f4f5530182bc7f9233b10e3835ffb406bea9eaca690223f236013fe77e75623c61c4184010901e44a3c5113aaf90f393372fe718d3acb1a7e92f4e04ffa1984305dfef12b322d9eefb09907d77811939610f08c3e44bee791ced17f3d7dc285058b83dd60e1c55c1d8684729078aed2038658aca408809014378312cb9b9d60e2e79ce0b11059ae310e0d1dbbdec46b189e5cceebaf618a5e348c0bf2e476643f4bc21b2a9cd1030fdd82e712e1aa783903a2dddb250dd6517e4e32a9465c611b7b816f87cd03d216396b386a36c15bd7dda568bbb20bcec38e5c8c62474d62d7a60437f60057d544412fd1e1e535606027504f359490ed0c41016f560fccab524c4bbe187135161a6f91b2567afe644b54df17be32c3bab69bda618dd76c7160681dbd627b99524c32da1a8b619c1b1d35295d01dbc40199e267bdbe58037c6f2e44ebe2498df11e546b933b6346966bdc84c7e1f532e8acdcff38fe7d6bb061eaab270b9fd2608ca822ae27e541592ca3947b7dc59bbeb026f880e648bf91ef3c6d90976c29cb0bcc2aff611ea1675298a83420648bec73f43849a8f1b6b4fbd83e33c451bd0606492928417c0c97dd9cce40173f22f1027fb810023664c8a1524325e56c37139f2743091423e0f1638cccecfdeb90769158f72e67352f786169cbfeddaef5e0624aef5210b04e3e5f07bfbf26b4dae81c6312456025137d98b5252981b88b31a1db31e40a96f62fa15e6fea12920018df3422dd6ea0808460277b00b4670cb0be87d0fedddec63435e28340990134e0723492369546a54a32dd03d5456ab90a7c4dd765dc59e458ddb24f9dae67118e5f4b592621ee11219bcdd9eebfb92ee21fd158ae59078aecc6d1e73b1c738b44ecd1e9139589ecce2d018f98c62027b00f14a3843e88ee9a71e8c04e614c05aeba3634ff0f5a699c91016461c3cc26e89d27e080421b11587b909a7de77c6209b8133b53b0f616d23141033abf5354dbe8beeaf74505ec699c5caace27e9ac4ac210def3849e4119f80510e0bdda4ddcffbe6bc4df0ad297acbb946f3e37a81ae938ab0c75bb814cd0eb8d701ca077ac3f329cf18270255742847e00f75b2cf6c492f4958d57ca570039201b59bebf39c6a4bcd9b39d389c11d1fca325bad2743522f59f63cb79a9962dcf58618eaa894e026d636a73b593fc36fec120a836dde01bb73db7ab5c99c26252f833736cd0882fe6e2e50d061bcc953437a294a3a0662ca9d764fb27646b10bdacd74af69ce30c44ca297830d33d3775055dc4b443c773f286c1f36ef87d59176af7da2afcf8f140d422dc69c35818f810d14d26dfa529ffd8b23315741a0b8a27e2eb3f0bd4ac61f304998f917be88ff40d937e87953beb117524f82d862d82fa71335fbaefaa3a6f304b03e454aef6d9069da24bf7491b3a564b6881d4a639ca34b2f86ac419628da263a775aad5f25c03d3b9f15402032a3bfde8117573223bd8bd8058d7e45c72763f987e5d9845e3c28f094c7cfd0cafa8e2fa7865195f44ce9246b63d2aa6c285e960d111b37d14fa711f87cf02dfd9a08e3f6a505a50a4f336c3cf72984dba43b7774b9d4812be966ae9d1205fd8bbbc8daca5a65646a0034b7a18dd616d8b819a023b585d2ee10a71cbcd0893892c8a3e4b1a4bdd5a73a7f770fa36da2d81ff94c60d91371e210c473bb025e80145c2890a35f4e1041bfad254074731a2756dea5639b92d2ab90c86fee776f2fbf0e4a657573cb78f2bcf7581e2693aa527f79192a7a5a0e5f182916caae3076130d4692dae0bb528ec7b6ee788be2f26ca1e4befe358fefefc02de937471738fd15d5b961c51d326d93ddadcbf02e65340daeda81933babeff75a15abd172421027b4eb7817000892edceb69785c2c3a56e04cc8d752c500e4b12ecfe5d5aebcea0c2294210bc75b5c69579f57df49ebcebd2be2d4e9c3ae401ab21a6301028a8e6ae50787b8e598ff4561a92201d833c36a5720bfcb76a54cbfd0f2bb63f09f759e1fdaebdc9aba5d38e554fe1355fd70af3f6acd9a8cbe1752545293bc6d97dbafcd068d3e9fb6c273cbafae1db4ad14f23c5656493821b9574a6a57db30383c1b1c115478fb0436d6ffd86ef58fff3f259a8fe26dcc9b11cb9da27058f744516f55d8c8e13f814983dfbca75820a5d1f511786a483acce88a3f6b56163ecb20002daee9ee51782530342a5262779c6ecd62f3b4fea9b819f5696aa4f173328a4a879bb610e20d8b3448eadd7380f39a49bc8fbe7d2bbc28e21d61b1b0d2e11874d0887d22af626e6dad6890d9e63e0c1d1fdc86a7c78cb83f80a7a78b4ea7cf1fc5cf19181952ed5979cfa4cfb4a40df221e097e4ff6030b4df552593ea71c3454790c0a6988ba2aeb586fdd5f6b121d2c928a99a585daca1c35210e2c4e7f364e0fa6fda65f3a74f54fbfee386ca77305b6b7ca6409ef9ce3603ea8fed366d5b1d8802df24c8053039f00a7c973b8040f52aaf3487f952222404946b9345f1c9ac0a2142c3b9b140e5938e6a184b0da6a6f9fa693bb1d636ef2a30706f5ec561209c7de5ba462e66cbd445d00bcbb5a63fc3900730bded4e56c9ec68836ab90a19963b95924a982e10ecf8400f66ebf584ab114992288bbe53575fe9f92da6ee1af813cb5038e10d51fd4952c112fd2be4e4e1963c00797003d79665e8f80fb9eff18b27701df46d1835dbd1c2c2f78e731ec62e95da8a3bf262c3037fe696ea71deb66c8d70e2363a454f54ad16e953c20c45a9b745311a8a80c1e699d005628191d3dde89dfc7c93057d6a655b80df7dc00f81d04380b4430a9382fd6380f14fa49ffa86ce71bd6db49e9ae143a78cf245f765cdd6bfe44e38509bd3b96afe842d71d4708f65533e8d00439dfb8600ffac39098b1341ca93169937fc6f310113e5b353336900eeb3d921746cd7879c7e659061748b5acebca30e8fa4f423596920511464d0e55fc17dfa6867dc45f6ccf7936fa2165899e3b64f8276bea4f740f03456605c77f4924e2bcc727b5bde712022b39f7fae32f65bab47ffa109a52343135e8a34f6855f3199f4875098e87f4d1bc7d9acae58899a01aad7f9c9074946b99df89d3a72db4b27a0aafb6271828d767116c55f94d97eafc9eaa57a18bd1421a083f03456b0854d97c9a46d608a3200e2272e81fd70a69266f266dc6506a6ef4ced70cc162cd1524a24f3871bf3ba4e02afd4020870b20c90aa8837f555692d891fb04aacf42b5a1c8fcf1651354f07f0bc2de375705c76dff70e05b21e1e5e01114b86e1b6438478c8488ba3931060de5314f5bdbe1e3696183cc328f52d534a29ba607c3892eabcf008fc2ba5723ee00d319f1fc0f15b08bed4a72e94b497c01fc94fbef5fba8f9f1a7a3c55663da336d3009c6aab3197af6dff87bd7db03bd76002bc6ca2342b5c8ffd546f63b1500aa6f54e0b43d99a99420b27bf3ed038d6181263131cfd857474b4b62ae8e8e1d869ea3c192560046c758a4137a5ff50aec7baa39febf3c3f70b855b4569e85ceb81881f6a5207b041aa53829370323259cdbb7e29644d14be45ddb0a564b8959c9f8e7e2e413ac9dec8133cb5b47baa4ae6a0ee7946e0c58f697c6386d4a8d28fb90087824630102fcc17c48e38b8a189ccb6fcd4b2672aec35890ecfa91e0ac5133bf50b96e4d6b224dff131cc5dfdf884b9ec0a28106e403aa28aa734629e35c58af0e4e1a425b8a5b88831ed3e357726b4ea6ea54edcdc6f2f4c05a1073b668bf6c57309e65d9b19a8205a97f500a52e727269098f36618ec3645d940c61d11b736ca13fc3a64ea701f7506eacccaa5d1cb63b0751eb8f806033d6707872cdeeee90f32c23c8917e2641dddb5fb8f67e0be6d720680f46fee81f3ba6b86be4572af68f97caa8615a001b48982616ad39ce0d383f226016ba9def41591fab29dda669a3f93af61f8566a3b3127197acd74e6ae2fc1e440203ecfcb29f8487032ddfe8644a8d654232c44ec54e425ad381c6cc71dcd7a9dbf28cb47754172f35c41c4c96ef6a1e7b468a11518cd34601428144308f142eafd0c95d5051ae10dab32121fe7150f6948356b84ea1028eb6ac118852e8af9d662cc2d8b959225e395ed2fb75bb67322819bfc1f08addb9ec4f53d5927731416b1c72056c35a3a085d3a5ece6cafba6d9cd8254b351bf4ef4638f0f850b9f4d1cf0721ab2605e8cc0e681d11c20eafc552f0a7969d5476f4c79d5147f1706782074c678c8e789da1bcb888fc9b5386d65d91db5be404a6ac9de254ac8f89200b394486011c0e36023a4491ee61cf8365676d5162d527b052ffb8ef791215abb479d775d071f898f9de217a877fbb74f1ab842f032cc7e5d683103f39576b175aac46a0e3ef859e8ec78085a9ecac32bdc72e70b9264b5b68b1f206bcacad3cf00d13215fa50775df6991b7258186a3dbfbd00a107ef51a150027fa43460773aa1027410bda308577ff66e792a80274c3a31b13c7e69f77b52a0b6e0f670488588bd5b4e678a9dc7e48c0fb0acc7c198445fa5dbefb7d0d3224bb65991c0cb054492a311db327ad7eeff5e48a1498d963198dcc576ead41e8b8ffd27f89786b239533492c60742f87125029ab034f1ed1e61167cbdacade63658492ae784c53c267cf7ba3c090e45c7bfe6fa687732cf82576d559d2f300eb21be1d0b4354c625515e48bf3ec0e30f4254a23cccda5461bf1ef21f165d022a567b17dcc56f5898488db99fabf5985c8cf1b956ba4af81867c4477b2c3384f9ca5c5923bb40e04ac7973d0e37e206cd504d35f9aebd12e0a43af5cf1a1a9371674cb60947ca3e9d73fd55f1a3fb72bca9dbc18d031c6abe6e76124a6d19d315f79bf756c83bca4bb419c8be23df8e64eb99fe1493bb4b6a63309a71dc6335cc8fde9189098745639dce3c6dcffa01ffb1f1bbc6f046c8f184a6ffa3f5df49672528c84aeab92ff40e6c49841ee75d5e9b89501efa2bba189969ffb97f924c075e690b3174eaf7fc9ab5b2d7f542567107621139318880c7d5133798ea63d23dd31ac536c1f44094fcd02b2f114fc1ca565d52ca17df45c8a95be4f4bc905d6f6ec8fc4b1c63932a4116c69040b1c45b7fbca2a8a00e164c44612f58287cf20719840937c3d3de80bcce98c6222a54e2184067ac5969cf67cb39fdeb7221202b99529b8a93231f8f24c5f35ae964dfcf47814d68379656df5fd2055e2f81aeb06c414bda38ec6a8b90ceaa9ef08f4076dc6a5d10f7d39fdbf0b29753af0fd16857c2f86fc0270abbbfb06f5f407a98ad1c95d31be942f252bc7f0dff86358f52da2e990262ffe713c6c042d6697b3ffdd010d28d6e3b9b31cacb9df2edecdc0b7d436b9e32f21392a4227ee2f8168a21f37e96a15ff778e07fbbf1e24ff006ef2848ac3bcc9a21e67dc29d11ea4efa0e461a41777ae8f66402d647bfd2fe9e8b36ee9da4a87e50f1cd279baac2f75593bd953b01cc68cad77f75bdb5ac7e11f1e902c5f91864ce7534412a3882e8b8d93f11af4c2e44e7062fe6895da4eb041b39639c80dd220d13b57bae33829fefbed9bc865d3b1084df33d46a02b729bb5a7b532e57536b0aa1dc401c067d52398f108f6ca3c54d3b938405c53aaad9035d73a7e26abfcde3fa91d43bcb1fb66ad57ed5707f7699e1fe5204f4547350f38fc91fba39f68e74bcada4a4dd1c4aa789659076783b7a9684a5686fcbb185ef74b8cf8065c81a4486d0260c023998bb2c17caa2fa448ffdaed1646457e92d9b7834885a8e8d504dee4b19bddb05d6ff65a3ea1317e2c41471a3b2f33837823c436d7617115fb81ba0e15bf301d7b921dbcdeeb1b3b2ebe83702f111ad03db0f72ff6f59f2cae7f52ce90892840a05ccb5c3cfdcf593c89a54e697918db477be4fa7c7b734e805a08e42da474b940b19a5cf20d142b360c41278adba712d97b4ca8a90e585ad0327361217455e576aaf7f28e47f0c105bb15095fb82187e603f52a0b7450dcf47cedcd128362d56702f2fee4ff97789357aadcb295ad4da46e910ee037ce7c74231bb657edb9da4fb40f5c0927d1d410052aaa6253d5b9e51193b96b1e1be2fe686e3f3ee32bde026c8b86fb981fdb55eaae05f5c54c35252f65e2854cd22b3823488caf0358a191b2d7cd3c38d1b93a929881eec50872918fa2b39c55465ab951fdd461cccd3cafc1a06170617dff7149229237be767c821f0981901fc6e193342d9b2a4f7a11dceadf8f3a7fb8a5732c9d4aed9e4d6c02ba6f3a1dc39edb06d9e5f0ed92e637aefec9b648d2c105bcc0801861c792c2547edc4f2f5801a333f7c6e2ec7df8e7acc2e11c9a3306185fb5486353cf906ac28204517c9f7b70ae848dbf1e6fbb4500779bff6b5a3ab30af64fb89b00ec76ce085dc5850e0b55fcfb605db482587c83bd5663b88605e82a93961da24c0664e2c43ffdbb0005f4e9f57295db60890e694349c95c8bbd5e8030f5a6e5ac0334c60c49483a8eeab743e0d065f45a6f3c2f6551253c64655e3bedf166dc91ac9dee8e070fbddc76758007d26b72838db171adb29a723c79ea8d57d28885a52ad400b7843f2a42e6b59e23b808a72041bd93c57073b1511384d6db04530b77f89a4a3e8d610fd38887aad44facebb9398636f963ee6cd204191cd390e12a11e77f5cd9eae47823cf6623f8181e4f7cca57ac9a7cbc946629c1b476f7344714f43c470b53aaf1f2f497623dd0a970c199f6e644fbe016ad067a722818373af578e15320232efb06e0824dd1d8ccc22c816c7de63817c0049cf56b763ce795f842dc5d9241dce6a0220d8b5925b6b40812686b3a2c84b2cd14274cc6feefc15f9464263d3dc6bd12cac7dcdf63ed4366d6785e211de2590e23dc4fd2f3645fd160060ec96b5c6e00daaf5892872a05f452aac2b7a15801ec4d506e6d12ace495a538c787761bcaadabaae0c96bf4af2168e29896e8400cb1ee3b10a0fddb0cc1659701ebeb6a675559000d7e0124d68914b48dbc629bc5bb49ddcb037b17589ee7e9e2caf91dc03611c948bce44f1cb3aabcc5b995ea2275264ad89885b5258f8c17912c15756aab53402f42afa3fedd407f58253ff9860289eab9f5e74bc0c4d681b75b8646ee24bef90b44688efb10008d66aaba02ad4041cc7c607bd68b84904e0d7c2334d464c75b4fbefd538feac624bf25b26ea780ed249a3c1a782da4038c81ddfcf50d746227e8965e9b644dd1cec2f6460ccbb3c0fdf35facef02341f2be9c26edc0d2166ad23bb701e7e6f646af83afd61cd2c76e9c388cf47b57a4894ecbed5dffb37e5f3000275484974e7857c1803c63559e1acb2cbbb371d3f9550044fd724757eed2aae7cbad591c731fc9217896f1b5f1095da34f3ef97314e71200332c017bb5fe7d0d13b9e9556067da6dd62154c32be13f1dbf46bc99627904e2036a810cce6340a8672be8de931d03ffa72ebac8a8645141ade50c6b8aa8cd29f7201b9993955f6a90430fc0624dd8aea21fcecba5edd015ebf519ae6bd5120e4d153f629b14680827c278278600ff3de1248d99f3564904634e9da0ecaa9795d1860cd24da9055454c3fedc51b953d0fb9bdf9a1d8fcea725982396363301fb3596b6693d24577017bd83c18460da0650561fd9e21368c217f54c6548e088148284ffd874586d8f8a1d27c9a0afa1fda69151131b09bb387e5db56c8ae0882862c746f9fa9610af893e860a15fc0b73e3a5e19141f9efdc1bb4df2a7c016ce6a12cd1f163669ef15994d317b26d5896ab73ca4b1fc726bb70f68190ca97b3c245a5dd62acba92db5fec3d931845ff621981bf2e78eb5145923bca93e093084a915aa9901e3594942acb93fa23dec4d34c4f2f497479f3231eb1372628b2f49637a02ebe1dc7a19ed88c6222debe0dd27feba93b5c7affb847e5f660f3b2f5d135eac327167f7e4339f0d052afe8891713cca7b6805b9d6262af58e2ae56458b70aa553fe7b5ef5c02114b98c52c0ecfbb92408421ffcbb9c3d56af7f8b0abeeef1780146f43f7fda3d820bcdae88e2f0c0c618f2a730ac095f024a948dd6aacc0ddf3cfc50e7d9023f2dd0b0c6a4f3f4e201518048f0756ad3d90155fdec1ef8ba28f521f9aa1d8fa79cccb978ef984cb7233be4f02844e797c36dae237a49d3ee520bbcb298368c059da2efce219e3a38fe61e2c547bb82dc330a2ab8a25f79bc96acbef0e7b4588c21732741138417d15edd94daa425f52610d1fe0b2548d036833679757bc84380df68439e1354c0cacc77c87ff5dc0db6ee0fe5ce48b0901bb804c23ef32979a5d8d504afd87272dfa234d0b171180bc4c39e87f4f6830890e9b72591adb4b8e0b073f473fc0d6450c175bd391d349fc583e936f605e66e2d7248c81499ae5391ffbb6e492b03d7ec465330fe01a9889e0e7db8d333ddb9a4bea3d4381c207a557456bad3077358166c7980c641cc52ebf7403cb8f4cd2c2c39048a829d2249a2e1eb7341e8def0a1591579ed3759d73e651a275e2b90f23c8d79fe74e3db116db715f45e494d8a627122d990a4f298580eefa7b7b5978792b84613c567ca0f6716d5471b902bfff045f4a386093014c336d9ec804f63d95a0fe47ca16435794aa680c9e06e184294d5d552fda92e473e2b535bbc5925731ebf64027c81f6909b2a0c22b2e9a259ec90eae5582686e3d71d39fab9c3b2acad92193461f4e641b9ed2d7b0c116343c9b0958ff77d2acd41162f1a1b506f8e3d9b06a08192b53dbf3088e215f39950334fc230250d5dab5682590cb600b912e5064ada088b55b330e2e418d75c738ba2ae59472e489ccb7be85dfe1d8b96042d5b707c99cf7c4a96d91aa524731d27b3ea95fb9a160e569ea7f3d03be2fa8694337644332b74dddc449591e66708333d6d0521e8949572b42f032eae3f8fc25cb3c76645ef106f52cf1b270d68acea5f42b7188dd78554304a41de3dc8b8d116237b8b48b14c496b08ab75f4717e3134f789083d05e4a6911478ff13a5d68fb9ac9b1a899c06e9d639e120e9d5af202e07375257f33896d3d9e9eb4badadfa20ff873cc18c711153667493cd2ff0d4c4e8532b26e71968da2e14fabd3db3e3935836ad1e79ceed5cc43b749d4070b9958dab9c1733885dcfbed00ecf62718c6bc808f9ec112d8ecc9e689de76586b200981bea2516307c445cb89dfbcdda316363519b440238f0bae7eb8ddbd00927c473f792922aa2c4c6db46256003dfdf1d12fc0591cb9e7f5512bce0e17e959dc124aeffc3c94e9f0e607aeec3446eb320716ffd2f2f85c208ca487896c7db15c612ac521e67267ab5755d3e7835c06c9f6cf29e894ef83602854196263d20ac0aec8ff6772ec6c2785cc11d2b6017df33384f6bdacd90d0e8c7d544f291ef81734a2443a2acb474a295cee89a5bca7d35198dd1003ebffa03354286a7f3c93d58538beea0b394f64d4cca72ee1b9e68331a2db06b6dd678c791e9aa12d37327cdc89ff753e58e192f8b3c94e23d31c872b511c09211a8075b71e11e8f71dcd516b4e9cb5a7bf077b4b5cecfa6c499f1c5da00b3f9486d387c95a1336894bc852545de3e9f6a3135ae43079c5fe1671688c143e99e0afb34371070d060e6357f23889816470ee885a3d6be160feed4c78b7c7745f8974b219adfd343fd80c5dd24d05d1b7c85e3c1d4aab52fca6e4c160df2b7ad6957a75465a9d6b17ae0ba7f929c3ad67d4b1581c963d81e4349b5e5d4f30760b3487d4125afff542ddbbacce3d7341ef401dfb592def9e48ac620f6be47cac73fa94ca0b5447831c530426f4a56c4131a7cd66a72b8629fac4a4972b63a1b5cb045de01abac37bc8b7afb26de1ac98afa928b5da15a8ffbd494bf78b713dc4c05236e400d88fedb958552fbd10517a4a865ef3c9313d56ebe637b35b57e1a0c97d2951c8606ff72885bcb58b9655fbd020a211fcb0ba4f5e8ebfcbcf884ff96035c08ff729f69636af42e54f5ea9eac3d358c7ce48f6e429541453d9ceac5fa5555a3251ccf988fa38a2334d3cf10139dca82d0775b2deedf2acf6fd20f9422ac42a697df6f55f7c02efdf368814665d98e2d5a090c1252b6f45cf0124296078d549bc69da124aa69be3ac60d89d478269af4c6740ef55e15d5e1df3e4fb7ca6f5bfd2d79ec6d2f1839c6993a8b0069c460989d17b6edd9474945fbf37b3758996ee5d89c8ddcd40e92a41f15e748cfe6f8cc409bab326a750f3c880c53978f36cb7cb9c6f384da5a535e35da3c3166ab2783afb1777c18461b8adec7ae49901fdf116b82df9ac165b2bca25ee400d4d2cf17ec0c75d8a61e8d3d729505714c557d45612fe7462eda63c18d1732dcba2976cfd7aac8e715738b08b589cea8a97b5129fcad105348b84492adb849c3e1c124ac16358c4bd3689770c0b98a24393efc1d428223039981c029886dfebc2290bef211990c0d712eb24e9b49f0805895093077fa3f8ff1477fc496f393a068390d2144aab7b76759f93278259b88ee520182d737f52aeaf413e9bec1079aec612d2a0583188fd1aefa985015a64913e474fccdbce409fa62193cbf54e871b1030422a645bc74a6edab9290bdd664fe445954718052cfee316ca31acaa2b3c798075e3b1da94b24babff6de00e81718cd7fb0b2af8582812a954e95ab0bace2d97d6d8b30c7f6614632abc4135d80104a3c4064dd5863da17900cb498dea1fa6d86d7b407380099a4fd001040c6def611883cd01e277851f4427d6e86437e23cba37cf2fa8dfef29c7bcace5764857498f4a9f3827e0160dcc6ae8a1c0702b60b9dd895a37065cb3a1ee334b52517d350d10cb25a0a75040764ed0129b0b6d39067193e96401d2d77acf7096d2d0b3c2911261ca16b76e79187d7d4cea3ec13e5f8754f3e4599b8ecc26913b113fc53341317cb9d009a20c0958dcbaa51cf1234b6ef113fa9e40351d58c6f9039bec7e4fd98402942138424cbfc2139e674d27ae0ca2b274df75ea06021c8ae13b8bb51ff2729de8baf2398a91fe4fe068b19d77d5e8a4b5eef64befb06993b3194f056050ebb3a9dfeab5c3a11bcfc19f35e51316c3d1f8ee873cf00e3279f477b622acd1ffa0db1e3c22d96597f299ff5a6b7f558ef3c3a9fa8b1461f258677712b873eac82bca5d18345342e298bc2e69d964edcc57d0470890f2fd967fb305dcfc36a55525310b2058e7c4cb598e8158aac5ff988d705b63889f49c78e6b2265d116e51374523822e101a186d19117d3f8aaa06becf70c9b7de87a607edcf833d3389d005ac2563d577e40d0771da93fb666c0275d0e295bac911dec4b17266addd69b5158c3a7aec0d74057b683399dd5cc42493023556ff7fae5bdb767a0496f6cc12ed6b5ce0735f3159579a58a178baec9aa9151d9b90360ab589d2b6d7c985b12132366522b4ccbb41decfb5abb0db9fb7e9b097568489f19341914d6a48e1f7cf62933402e710b65f28a56613d393654b84e3d9616c77e0eea9ae5221e142fe9c7b5f9517cdccbbd88326c053d55cedb755c8c2b22bf189adaca6408f5eb81d81ae3f1694ba5a03f535f1a267601dc87810b9e37c10fd7410deaedafdec69772c2c733907462dc00a8f30a0cc8786e9cf988e0e6e285062f76904b2d695bbb6c800e94bc1c01a861c5201f48a30ca04da6a21221243e2369bba242e3ab09a1d9909ebc97724b4a7968ae3f48c31885c61398201c574184c8b6a278ab7bdbc711283d095356b049e6e1aa7649a3da5ec8f3ca5d7ccb1de684c861191b0c0f7a9ac569e7d4f7b3400b1432589266ee06f146f16048a9ec5c746e1077a614a48dd2ee9cd8f0accd0aec3de02fa1c845ae08a6fcd4468e70d65d7e5ee23806153972d281fc26cd203078f4bf8d57ed52e1be6487601023145eb7cf54b649605f8ea99e7833af155eae3ee934f9c5e2879b828695e27bcc26c1e802ff79ecbe049dc5c52401803fd2bbdd323ed85bd51fc6929b3d46d93539022506ceae07b2ea2540c54560cd23ffe03c51c6092a084118a0443f9ed2bcb4331da450bbd5decb6200b9a7c6ed30e997a7401a2b3617356b40471b8a1dc7bd824175c064d41834b2d095a532c476060fda9c4ad2b69d579fa4e9b5e7612f12efd2600ced26b5ed259dfb56b561ba1afd2aca52871a8ba3b8833fb7d83838047757d3013a8dc25fe24b8eaee57bfbe33788f453c91f49b30b167d9e198db8e0a4c6c37c76bbea236290611e380f589a3063e1a78d3d61e3fbbdd0dcad3a5ec7313d319c878394f9c3076b454633a7771afb58763587d15837af032fd13edf9ecacb054964e9c26bbb3a9e5486a9178848ad949b4938f187c37a0741a7266992f5cfca6cd7332df3527c24d9cf1dde1f286e55b867425653f9dff697889328bff50661e0affda0ea4bbc02fdccae03d3191a3385d190c4d7d22620de01fec30f3286cf990cb5b4b3c2670a4d5d19dc344482e16d8d05307c701b7fa9cf49318143cd59eb1208951e5ded044d02b7b377e296d56af097f597eda77e68cdda94a800f57ea9642b5a24e35c6b66e68172e517d6e204d1b9d822458cb8fd4296256d95d987f093732dc9559c7866344a9f63a798aaa6658b590cec55bf1822e0ef33fa2b65c21501af33994c3457f22d50fc2df9179f79f3646a87f1cf9f4570c1bc57d9052d757fee31a693fcdeeb34b4fd663c424d8509a8b3bbf5851549ee139234f61f3a557ccc74b462410a7624ebce5642c5b33b025f0238a178a2fbbc74f7141e3070f55aad587fec6cbcbe88eefde293421772d3fd239256f48f1429e3ff44feda1cc6150d6dc8f3e673266b9581e177d93fd0c36a80de99735496a559f926c9a949a8a50c74cbdc504fc3148d225eaec859aae9b27d7515417383efb7a3f1ac9f49dde08074752dcba1d52e37ed427719f95bfed6fb123f804a9c7c4dbbf69bfa470fa78d04e219f58dddd9f9667cb0d7dcfe80e9ef3d096166e6ffba5a85604d0f2d3a8f4bc046118e124b1474ef63051d6a3630321465da0c7b7d4ffc2b319a959dee28466f39c8c93f7e9d9afe6a5b09e04975202493f1524e4d3b2574a961fe143a294a17cbe3bf224fd63b1a3b781da85d3f86db35b0df68540398ba32b70a6639761f8227d731233798d1cd1dd0677032753c1f274f883ed6c77a338e556ced4b57ef6102f5da7c21b8d8d30ebcea04368a29d28334e3666006a5c97c436679049f353753dddba2fa32919640dba96c84e803b59bafc5e483ad2209a3651cbb3378d4d45ae7569fbf6881e1dcc0866b9c860aae582c17848ad20ffa2d95318b2c575737c7f888523cd23e7e7ef3fb4684cd434300acd37aa7bdc16edfcd573b605317504723d0fcec5e5b6c30a7e379821a392acb28f827fd1417b8d2a8b289e95c626162fc4ed9990503fe845395d18419a36a01d4c2ea6e53f90600feaf26f961b51f4ddfff6d7e275e6f1c82030ae24a627e11922d49c6c73af3a2588f21c35aa8cea41108d97dd2df8f5cea9118faa7986a491960c56caee687622b1caefc9e1e3e2c900bed8fade9e1e9898cd22e947be773b4ded0748d9cf6a0fb1b8aa9427000fe5de457658d7155de9409e9f1183f4e48484f14cd505084d1dc3433cea826a237d3cb6205e58e8d352bead817a53c5e5279ff2a4474da0b89e39f73a1fc9d10728c3a90d8632117d4f0ce724abc0a257ce3514355fc7b6d7277a4c8e52dec00c383642deac0979b2b0f450048939e7c3d5d4c3053a4aa739a8ae609c1d4e5fa60a34edd960c93e267e5ba82e7d2740af1864b8db0158ef68c668b8db9e80404034cbd05014b37a89ce25c36bce9db8297d144e256840c45cd44b68d3fb83feef19177cd11e3a4b503ba91c8bb6cc18f7b22b602b50077399892bdacdadcf49825970d10e45d4d5c54071d57435625c13dad04bd6c3572e06688cc9afa1b40c08dc7a4dfe695962608121131620d2dd97cfc5c5813e1d3a8388bc6f3e8b6a6748237993cd44f38089ad6c5140e70f489db23ed99e35aef961299e242a72d16224ede8dcb77ff250751d8f9497661eea6a180fe4a30336def5139c33ded360b6ef4c8be4aceb96f934fa689082c204f8113ebc73208b45d5da57cce8297953abae57fafbc01de651b63236aca4ec9dbfd8bfcf2763b9732d54f3798088e091d40abb52fede9f4d8dfee22a751168908f53ee8b172319897ebe49010d0860e8482532c396d51b9bd7e8f7c76df544d1c34d67136e6882735214e3a8e25eac7bef5ddffa77c1ed434d84e496e5c00687530ebef57b07448c9fecd3f27d801ccbce27b52e6adbc60244b4b6df5f173b0cb99b6c4a3d8ecc4324fc07c133440219401f7680dae6483f3899a86d13618d07205145a9b9ce113f9c0f188903cb0f07ae4bf347a06f56e2305870048443829cc705f863b42599b4a59ebf0bc24ecb69294623646e0cd273c182fd395a3793463545932aff854bbc49d3ba099dc94cae23769093cef6a41110c64992927aed47362f523c5cb46a3dd5f61d3309c02039d78d78f36d02772412f81f5a74c698565739f2c29c887c54d42b7fa68a8ed01389980d43a262ab507a3a97c90e8017410083999fe1ba83d7d775393e053fe8e0c5433938af5e0013b6b5c02a31b007f602a644f99888a3b975f0218913da443b7dc1fdb80f50ed2784def29feb08f3b78abfb838ca3ce47adde02b60236e82de67bc02f6963ad6c768eeaf62fac5ef385048ab3d8d854126982a8e83973be42883d2c4b789be2c35a704bdeeebc326e7127c7f0388b899e26d8f25c62a2647a537efbb5a34b684890e04e28af053e98ebbc0798a98680110bb3742135393c9c56238e8b0b409deeb44e6bb9fe0c7f1e82c25fc143558e6e398d002782ce91b0fb695b56d6b9c908ff9ea95190be73a105ee40845f9d69fe1a01053018db0f8ef52fda52b2d971c43d80281ff5de87ccf2be92e0287b69e5c481ef9c321ac2c54c5eb41bc0864827e52b9729a55c2af4d0e6ae82c237bbe192de0081984d6ebe115ca7886735b7ba16f9b552a0f5dcedd559e4f4c2371ad6beb6b575935f00448f7eb887faea74341f04e7a4eba9216b3172e9a45e701cafdc3893a0c337e002783c379e94a4e2b5d4d3abd18cab3cded62d9be73763e55c988ec2d0b7c7d03bb6443daf821d083b33f37850a82a6809a99944d2897bd375f61198ab64d951eb1482476906e4e60efd117402716654e4288ab28c23897b81898ebb2b06661f337902a9bd835ffa6b05d2f6fbdc2c056213065397c4282cfd9cdb15e99398750b32a48c3678c3c9cc6b8396f497bd2ceaec8c6d89f0b34a5c2257c9fd2d650ee7ea80c848dae4569352797f549994246aad0c66c8e557a01b7c8764f5a3d49d165ae9d9c457604ab2909db517e9dc79677391a295ec9d29a857f10412929e3f402167e9feaab90b30155a6b179404cce34f59e860d797b84cb4e0c0d4a31ceb8c5bb13dea3099e750c2b3cfb00420f1fbc47f75a8bf49bdae9de922285befd991e75fb4218d5b21d83368642e0cb1f8f01c3e94a1bfe7dfd8d236350f8410c9eb8d6aa5c94c3bb65baeaa25206c4f5dd915765324877f1562a97c594f68967abe0aeb62a538192db15f73a79889f30b0672d52897ff86a318cdbf8b2afc5bf2e17c0fc3d68b163e78eedab8e46b99134b4d9cc67fd2761348256c9772fcd5d11a7706b85a9487f4835b27dfe4bc316d7c91d10f232ee22d1cbff9aa805df7985b86aa71435d476cbc321a62ed480b6b98317de2a7a335931711133edfbafbb402b57bc8025eb9c5aa7951a29e1166f7ab92d77a683badb0f752971b1014c35d971a634dabdbf67a756dcef4a6f5c52d44efae2a6687aca1c86f0a7ec9570f0ada6368d7898689700e1ba37770f01ed51d1f277c5acb6f79279a3c3549020703ccb2e639780b6f32b9c7f6fb088ba2bca7533d3ae3de18db7f69dcb79fba743711277c9abe46d3c8c08763018c63d2e61bc957442ffc6d40f1a137358b847c37699b03d31e247851deff2d129ed9055921a635e520e3c9c49e3a2026df527ee23751f14811cd38f0db7903cae665cdb5eebd54f7ce5d0d06fb42451e78956a5226a50c705d8e8d2f226af966b3d8f6d76c7a6a8a7de5456fa138c420d17cd901bbf44351d98abba2ab505ae445fbb67adcb7d365803169ae06e57191cb00f333eb7e0ba3d5a83a2a0ea639444c7db77378016872b0ab0d3278f9c7324f014e0bb679ce93958532db55c3a7d35b73aaf5e0f14255f3b593b7878badf7b1a7ce7b3219c7437144a145e69bbb3d1d4bf6f8bb01fc8663a874745d8d2bac971e6a769861233fa76238f8d32d53533eef42555b982a6604024cb68631fbb656b9b0e7a606f029db24837843fbd9f62fc8fe418ad063509938a9ac9b14847b7f5b4e0604ba22a105b4e6ea411b97008c92f25c6f6fce793cfd5b9dcfcdef776a14d39dd9991060d850cad098501ae2bd1e2431de55262cd0e56b6ce6a4f0368c48c7628c6eec23b61e045852e5cbf76029d6aebefbc0920a09b447a1b1ea6e220302b99150d4e8ab538e659a2558ebd95f716b3558319f61a8f4b998e0ed92424e06ae21d241b6f3892001b52a431e2e7add642c2fb7b60e25a7701759a3a1b2995926b387fd0fdd341631006f1908ba76aa2e87f3e7b8a0128b135f29e9eeb8a72603d3899cb4bd8c4ca262daf0336522017ce9403e5440468376965e1703ee7d4a94df2b56e21097eff929b6b30cf4cc9769781c78d729b47aae5440333822ee26498a2251205ca8c12347f1268cea74200ef1efc6d68427aee8f2324d4d7bc1098d218cdb1907c389943067ebe8c11b267caf6b2b166974193935caf70f97b102433e4abd77971d615f74c42f6742172ad4985b84c8397594fc95a357637a8594bb638d1ebfd97fb20e862178e5ca03a5b23d512e8efebbda2816ac80cab745f20f3137e27d540ae8a7440b8963aba326132f5a886bae3c9eea19678b152f01d2da57b219d8b1e45f5bbeb0936a4b2278dbf15fbf617cac1e24699b8ade62683172bd3444a85721703ff4f081f54e1ee703dbd096495c457814464fcf8a68252062e0478f75525dbfdfedaebb3e3949afb41f3057ab511dd994b901fa11cf6f0661cd52f7c147b31b6b69696a62c45948c6ba89f1d63ce1c9d1e2ed871bb2cf8a22608a53e19e053bcdcfa447e8052e904c9aa8a3bd327c24986fc89c409e36d2fa4af7b994aa82da2a6f88faf4cc930c91f10917296721b1c26d3f5816358a17edad750cb72c3cc84842a0fca636c1b8bd1d06b980e8993e3f7aa23e2a409467b156e62efdad35dea18bd48a00560336f14ce2adfa19ee395baa64c4e1a4e17715c5a4faf32175e3a95bade6f4aef12e152e5d25437d99f83679b645a04940264a15e69d61976a29bd14160cc6af2412a332e3604a03dc104da3e72777c9b20c3979a2bbc6ae0a5a41fc01e5210414b12453e8c7099a4a9021113b1dd3114ea46576900c356bc30607a7b567f444018f43a61b9b3b6d4e74466a5e17cb224cb8f45e791de84e29b8a0d518c8effad3fe0f3cf211cc8759bb0fff4fff01cf4e72c0e1efb820d0288b132afdf53e35937d507b21408c1962391d1c5125e6ec90b968123d80d2b50eb5e5db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
