<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d499ba6bf0d0fe39028f43f9edd0146dcedc2a465ff769952963725dc1e47c6cfc34e5749c4e214435c1f0d7896d8b9e8077b73bef61449da1820da0919179cb1c0c468d3034c6c4ae7ec366c37770735460b35453c82ee044845b30446d7127de10dd5abb38c9994eec80b8ba7169072c2523d09600aed425bccf0ebf976a8f8603b0103a998e58f624aefe57103a0537bbc812dc66823edaf1631e712fae795ef13b6847abdd14f25cf291e1aefa5eb1c89b154d7f60804098c0d6951034c5f1967359945f2595bd9eb38210e3ce32b5b44da8eeb69f0549ddefc447f36b68d3ff3e272c03038a7854c0e88a672b8bd6948a39dc371b73540c8f0d16a2efbb87c0f12fdac555fc296a446c75bc3eaf2eb1188a7f22489c5f7ca8887a42ee40bc02a621f5503d955bb2ab9d8bca3453e9472f8dc038ac0096e4c85bac8888286f74f5b26bf7048e3554468e55f362129cc783d779c2ed0d14ede688de8980c74c91ac179229da022111cb360f8241002b10dedb90887dec8642767309f22ab2754163ee7ee415264c9c1803fe3c1602aebe50c294afc4a87e70c9124f07402b7409be4b6bb22426aafef93cbcd3253d12d5308ecb40b228abc262c9eaff5f279902c918a78a685c6b5bc5f8db924620241d04edd2a57a5cd8ac4600ca15d9d5bdca6ba02a6f3b76a1fc85ec019393aef9f431dea6950b68fb41b838e61cd54d62bbeffd1bea8aac8ef9348b00471b26f9608672f17b55855e03b12cffce89dbdd223c5aeee36e2af3e9061f0e769ce05480d79446cdf1ed6bf472e3a85d27cedc7db57d894a7b05d28a405e8368a8644a360c9735cb407befdc5fb3214deb898098dce0d85dadb4983d40b5592f9f7091fd55348c8d5829d49da3e9c85358dcde7defa99c7df5782caa877e3cb6fb80a270e0b800669b288fa38986293885b18a3981f18ff5482b39b43e12679e3200ecaa65fd23a5af223cd819e3595d75d1fce6b3bba5925b69d8962551d6f33b1afec752a07d7c733f9166ed5674709b130d7dd9976954823dde4a5ebff77174181d3676a5d7fa53e12d126e05eb196c565601ceeee1f983b8993fecbd0ded2c34f16b29c02558072ffd6e5900ffbaafdf84709e38f3faa8d861f8efe5d123860e9699a8c7cdcbb1db602013776ccc64b9604e239889fc23c314a5ef0be9edea55b8ee95cfca7940be230a8a2be49c1805968210dd334a1f56dc77f9cca5732029367227158e84a2a9abdb26d1519e07ef92a4b37d8d25605680e6aedebd5f908ad80463dded9170d7e1683b36cb3a3d77d735eb07eb2e0761d37524e68177cda410501b914a142266b076d023fa49d11ab70fa1fc49ec77a23372e69ef5994e004ec9a64109ac21a81124adb4caf61093095b8ef4a6c2b46b0db2be4e0a55f5314cd68919ab3ad25bf374a0e1438c4a874893dd4a16751ccfa1c66cc06050c59e22dc81b2e665028c671c4b1fe7b29ecde509ff233922a0cd242d4e7e3357962d1586f0f71478ed4f42a8c15b96fabb4b85734f8e1f60153064411e2f2efa3895a5932d981a669b9c39b1561bfc1c68520aa2e5e5773523b771e68a05eec1e30811af56d2debb42f91f77d9f47a0da43a201675350256fadae3baae3f8c8582bf721508717f3569626228e2cba058640dba726b38d1983f03a6e91a20bfb508327b8b9406d3723de87f73073261cc466508c62edd05b287d3e792f51ef605036ad82d74e04d9ff273f5934aa37bb9efea31a281187724bb339e3158b042c385a8a1f284a2ebf9e5a7d0ada9d28392d4a873862abd0a1384dd1e0fbe8caa44cffa236a7e6860e5d8c774f1600ab22e40f8bf3038b28a10e8f404c8eb8a006582f47d1d3c22331540d7ce7347b425b04a8c8abbdd982bbf06ffc2f15f65fbac945338bc615152394abc4e60e427ef1706b274081c64f445b7dd6d140e64671312ed414c9d35fc5952c64971b194a935d46f6827a778af1b5cf574ab8e6d91966b0b197350ce72a6dfc49d4a94ddb94ef5974eff446d479599fed7cc440bec74f2493e7280d8c5c8397d5d286d74edc8d92fa9b6a1237e2330918385329bc8438a741a4d192d3f4e9c0a3fa71c0d755cf0f6d89c3f46ba0dffa1f2ff1c193a5be9448500aaf3270e254c6d2e1a9820337735dabe3a5510e599ff9065c25f25075cdd7ee4aafab087ff7b740ccc27fe825a2c0bba4db4f8cb3619d17dcd8d89ea534c009939f2bbf0f67fe655f992aefae874ff03a5cc7ecb755a8d807b7bef57a426f995354aaa492cbbb52d0a40c0b24f8c4a5df6178076a3a09abd1ea76786228261fd00f0b398e3226cb4ddb2e968727c82ac038af76a72f14bc3ff4cd06e736b2dbfec49de8c41e6d7b1215883e4b417b06b434029f7e4ba3846190e05519a57065d17466123e8dc525d9e54658ca0f3f6655a56daf6571f0821197bebcd721dc0ef47fbf83635be02d8454b42d0c546747ff83ad91700da9394aec6398953fade47fb6522c0d99a934c3aa3a1e92d53389c5616399ad3ced89ef8f9f2fee81332191b380150d1af63b0797ec6c68285b16e3c0f80f6147e0aca7fc4047802accb1bbae32d6a05ee1c594fdaa9830738f780bf8b47c6f9748b63ed23c9a124584ce043d5f31242e8e63a676f8e386f304fe07360ef2238d1706a7d289410c595fb18b80b5e06b42c618345f919f49b0f8c4d622d2bebfc513bd696d333f2b24ab783f6a1a3377f7cbc816542e2b216f1308b299ed735f252b92d21607a2b3c18264c291b1c82022d05b6532020c112d844969b5a22001c747c7afbc8a8a91b3927980b9e4c197881b5db0cf2932c7882b6b2ea5a260bf8568320c2d9836283ea159a3dfe407de6fc5db37361da5d634b1950df5d6d8505e5888003cf362a23e4ef0598615bae7e55f3a52015f5d20368d102ae28f5b06e13e91aff4e9a89599718c584e14d107d799834bc3ee74906cb6d53dead4b57cba576421a8f6a886e807c18854e6d6df6ecbf4ea4bb19e4e2e771ab87a578ad2052b6a5aa7d50003e6ea9a163dd838b5feca815e564ace1327ad7eca05e615c66acf927e59ce2960ab635c28d68e08961af101e772bc0332ca6f604113c758e9411c622bca9a8b67b3d3fa287ace0af5c348b7fb240e91318ed0f48ef9b5da65b6d7e7447947f5e678888d16375cd241c6f452b676902e9823266b6781751e824a1d217389530f64b617f720c029b54d0cc6e931ffb5eb5d80305a097b50a206d78bac4b301b6d7e89c1b069e1b073f13e544c0df4b8597f619e8597eed31da869454827635c6eda657dd84934883cd3e2c8aa7694edf37248fe4ad7124e32426314fb9c03db732fabce4749f83c9726ddbd2f78253371451a7134e04fe56e4b79c6c4277f4e14ace239495253eb1797e62002a57a32b50194b350234c42fcedb299d6ef64b4ebd25c0b5322e9c5f080ff735a2e7b9bc5ca6af6fde21ef12c81299830f2db678637838963fa03206a563931e10587298f758f8b9a03598e8e24bc0872670634c75f5ebdd3c58fc8985f4d2899c0fa6e06948374ec8f758a53ff0ac98f82ce34ccbb173ddb140e50192fb6888497a4156b48e8a1100c8aff289435671d65e2fbc51d7d4ab03c51fde7a127c4309179bd2f492b5f7c8fc1885aca7827dc4f4d8e261e8a893d3f8ab66156783dada30e5abe6e80099afd208bcc4966e4c84417a35711ab10a9f689eda686fa1300a1565db9e9e6347b2a2ec2b5afc58b74fc0b74dfb8e2498193a51ebdf1dc96a93db328f1f95d60d41e0262d3ff7eaae5efd13053460244adfa62d1453c52af5176c72c7d8cfc953b2c85af2e17f65d4a9137f0103761f8406f420bd395af52e756ebd9fda6b060121000ccbb9425fc290aae75f7322d77da2284e50c4cea00beda78ff21fd1d1c38f653c340f44726463e45858d58fedf08e8466c732ff86aae99071cba5dc0cc1e136f8775d366330a9f64c13fa20a5df7b829af701d9c15b142c433b2b81212731ed2aa56c3ab7af37b651e9a86f60bae1ab38f6b1f9d6a65b6195ab1fbce458bf572e0d7d3c93bfa5256a556a04712123444ead76cf1ae09ace847dfece959a4ece45af11810890728216868ab1f9a453ecce7000a31a16a7ee1bbeea22f6392e230d44b4ec7ede2610598d9de948271bde660b85589d864c999d9b4e37810a8951564170d2f831e898d1e3c0e5cb1d5566b829ebf131b5dcd2a8731fa5879d1eebc3d1b24d118d3b2a1cb3d21e6faaeb0c765b30b53db7e1c053324a943ec1d56619f719baa6cdaf3c2df8b9bc1cb7de11b4ab059c1c1b238e230cf7fff0c2728b7711342773dce56667e6a05f48ef0b868709729f118b1c74f550f9302944457f034f4a518f71b88f3610fc6ad56ad139625467254b895553ea69a5e7703af71f8389ba194dbbc5099c66b4e43f00c6369304a1696dc9197921fd1c86ccca07eac63cc623710fe5d3c0619b5952ebf797e896a5c8335fc5bc8f6b466224a0234c32b9282bc2b541ba3a922e42d47f3d6cb8523c729929d119ca10388336d9fae267d4c4ae325310e11a092facb623ea77f6391e5a7d23aa3f451bef904423edb1456a7e3d965954fb47585b2937fca2292d5655535c54ca1266cc345b5db395e47661b47afec33ed8936632dd708a990ec2260ea6733aced0a473a846758afe8764e83f53f53bbb09ef85bea9522d845b9f74afa8532f663cec95ee76e534f70af19ceea6057ac24f6e1327d4228c12407414656baf7e976ae3b34cf5905c06688ba58168358450f0378339b6cd2063820f28f1bcd3f47bbe6660d8035c13fd7bb521091412dd0f7b652b87cfa28592902d7b2a41f7064413b1196ff2f14fbff965622f51b6f32e19404cf50ce7d6186db4713ac6dcc89e36bda32935013c49954787c5943de95529393947650fce018da0d381d5b297ac7757cc77ac7c2f11928af92dcd3a1b8fe6fce9b3648bbd9b81240449f661272b4f609deb4eb235c8b088367f4bf72ab1749c478d12e718087b6d76bf6e4e09eaef2bd54caac8e435b6f1025c2fa1a64d655e78afcbd4406eae5ef550c096e2ea5cc6b8f7ce4dff2fdcaf520a570c005034f387359a4d291e5246c89dc57776742577cf76ea8e1b9114fba6f75c379274ebf0b815f7c6347d394f84efeda2d825501814566ea681df829b49e03a9f93c0fa350aebc6333a70d86c40020b5a07b9ea815193d679be7eb17854d4fa7065903127e9ab2dbe011a610ea6fa21d6ea7bdd7203081efcc907447a178d61c32b47594b1bce92a1a584f1c050fc5607695376ab728761091138ef2d198684f9778979f3fcc40f436344a5e8def51075c1e71ad4e288b9151a1ad1efd2a0a8e67a2cdca6ea7fae2afa501727ebea021737a5f9aed2a4fa6e59edbfb08767f285a5db6b55fa323ea9a46a638dce2624fe6bf0ea99525488651097db9556dc9e69f7602454d67b06a49395322b6fd27fe0e1737494d28c4deef70e78fa9f8e191631ad95316176f9be90ea3a83b8f79b8ab6331028f9dce4ef354bfdb0c2465247c35096344fa899c72580b20101196258053acb1c4aa59f678b1dcc8bfb92dfd65b9dc52b2f6b3b693ba36c2222057401010ed7c96042ec6469147fe88a4ff39071536bfd34153f1c861c9ca0419409649dd2bb6af948e7ae54bf73eb328c1e076801021750ccedc52b22eb23bfa388aae2d067a40c8326d1f32299fc610ec78d6da56a5a321a3b184c41333eb927e5200f947ec417237681ca1a10a3d669902257f4e65888abaee844e20724700b5958d364c25b858d74d12376909723caab620f7fc17458d9a458406acbbc796cfb38822c95083e10c7e32cc7eff1802e089040b3cf977909c3813690d2c1bb0fac9f1e3203c023cf5f37dcfd42086f4eed3fc4056b44c7cd863b46dfea9f72643002f6373bc1f20e72b7b9f31867fe9806439793e9849d21cdb180c5b937e7910048a02dfbd90635b2634a9efc0587c93cb8480e39f899a0c1bb0a1b7f23c717158fd12d159d9b2aca5eb1c26505b72c0cd116460ce08730c0492958d9e31ac9365a78aec0d65ba783e180a69b8f0e88ac8c01cb73ae8d9f774c8d5d0b0bbaa4e50bb7c6020de04f8c57ea83546a226630f8a03110cebf6699dc9362bc517319293680185a77c1dde92f709d87cc1320efe114f59b3a345e4765c1e3df40151c369f019bd2f7138af0e992fcdf3bd464fd5538f7661df3e0cbaba112c0338f01ffba99fbb05b0845cdfb6fa494183d43dbde908b76f30bb6a1c5ae1484cde9b471dee89cb9d6329d9d6feac2c6fb42e028c72f60eebe4d403cc0d92c157993b606f769ca451c766e8a12d8ef3afccb2abff45ca1d9bdba65ab10ca0c0b0b0f4319e18481972a789690fe27daeda12bc02b26e87f07fbaec260502bf05a24292f8980b6901877ce4dbb3db4284ca5555c26ecc3642113e60409030d839790f7d2d12b3e8996a90e245a19199ddfcf5ef5b2eb09ece1738b392f63704c0ff4dba6536b9e6a2ec642c303e477a657a16fc7e8113fcfc3928b7bd8c4925d38e9ddf32126e92075ce6eaa82e4100877b612fc781aa6d8f63e80d76d13cca6f48cd8c0cf019a89789f39a1edc1c6d456a0a366c6e7e71b3e0f468d5b9da82f1e01b970c7121d674e7f3dd7a2932cc735564765439d4cc0248ac18fe3970b23a05c64abd9eeca807215a733d110fa1591fa2a2fdee11079770d38eca613585879cfa2ec282a1b3cd403f4e03d8d67b66121eaa429a35e20561af5bab196b6551ab38c49f03520e2056bc7cb9a0483806509916497b4c5ae7b28de34e3ef9c6466a0ce763d5754e74c80d9eade9c0d328a3fd19d6dbc4c99d6e09553e690f83d2b5b4d215bc9d78ebb5a1167ced7565a18c2d2018590d4a8fd96bfbd1088a99e5daf007d8dfd7456b39ea5b5c47e15756ebcf2a62d40017b15cd9ca33569169a920498edb53a672be7871a1e9944d7abe1cf1f78188d9baa0b73d788a1f2fd63156adb76010e9e26c3d22b39d5735b52cbdf66216562378af4c5a3772395682b2ebf269ab1d11548d0dfb6251a79cfe9d9757f64807461a8a1ba83f69b1410568bf3ff4ba73d8bebc5f2eb703dd43fc97b03c392d8dc3ece5f40d39643d33121a4b41e9d0fa1efe668a94a534f9451d35dfbe9695be8ccddbe574b3b16575e6c067e962d6a797d5ecc0204ca1da773b502275be421c6ea915a5c2ff54fc8838c0507f49e6a4c14db7857475c1e349df3c2b1972f6c852d87fe89a666c7b6b67b50a9d4c0087d1a9153909026c3e7210763330e510b78d3664317f7f38e02b884ebc1955e393039dd934afc8ca99f149294f328b45091311d995666c80e42cc7e535fa27f25b3c98ccbafe25ed57c76f45f6f993b2e05e547a65d4cf3d5a824321bc97441011210a86f2c6820db0322b10a2ad7363ea8eb94982520c0e0750d200489208b5275774bddf85929678a411bce809e1f125ab36a14e2ee8952048abd9922780e947e8c82f150599e19e7197c721381b2c0fc59476ecefe86b2b87352d351e4c0fab55523eeef4d85247691ced79510dff8af77d360c877bd63a55476114bce8c12bf2ebd96a947be1753e9e921518c5460bcabc83614a6f3eaba0a88196cac4b56befde367e5b7153302c741589f79703c502c58f38bddb0072ea079849b83f4ad96199620a9670c16dc50680a2f29c53fda130bf87724db855c4495b52355eee687b349080ae9a30fd0490dfd57a110e8137120de82a421bc87dd5364461eb132388610191e0381046202a4153e54f74b9c97b6c3e2a5f9e641168df66ab1804aaa7ea6f9ef07d1893b8914aacfbe0b1e5f47f0e76069edd025c7757ae876b43daad379e13bf5b43cf26da74d0cf805726f003dfe55215db300fe20010b018f30e5d345d3ef413af50d7ae8c76f9da3ec0c9ae63c328272c0983f573f84d6e029c3ec9887b26bd5c4d431e35eafa85f4492cd6f79154a512c5b696fe1ac654f4fea9b94c75fcde1792357f7c95dd4fb165f1671b2b61ccb680103152b1f8966c19202c52ca411a6308fb2ba1cb804a2e01c08cc74551273c1c4956bf7e55696c0df5a57982d9ef642bf6def674bd610c5690af6b3f7dd36dc3affb3a25102803f2b55327e205e912048282acd71035a0323c7485ea51d522fa9395c6df93b8beabe093380dbe5cde680b74a5be93e699933b80210a19a752fe175a5571fafc579bb1949aacecfea91de886fc8e55ea1845757e1e0c50fe6ec3086e4458a3209f33697ebf5511e473f297e88310defafd58a0e33e21392779ea8f97b793cf718e41bd01dd8a8f2af6cd7992a871ec90b02c17bf2ca70bab9ddb780af90729a1c6dc6c4442ba238b9705ae0b2f47969a8c7a188414438295cb7f749d3b58178f7e257888230353732d1bb0b08a0b10904af6b4788201ffc2541a2b4658d064d0512909527c43d9482e7a9b5e14d2c392018f69491dbf466fc06c62261c73e574349907f1d0a6bc5864fb3d736a60f6bfcfdf1326987625046c201d56e4aeeacff7b20db03044684f7f7e46f9203a2044cc738f0833810d3b0547ddc6d6319fe6a26a0e427ad681c447a145483013d4ddca4628309b180b3dbd780bb9f542021273cec07103330d6d775f7d9adf0399293c243256db4f7b89479081a143c915e6f17001431cd67e242a07c6616d9cfba88d7a07cad69c5a5e3b44d55039628656a03f0ea39296b4d63bb686ed612e6afc32ac4615b3a53d5e5839a65f76f55bb9bd65f59dad954b6e9cb8e9d64abc42681e4cfeff9546d67399f4baac297df18b149fd2a76e7ca812b8b9af217af3246f490a1e66ec4f565fe3c80058732efb643cdc0eebec249f67eceef8da696c77cfdf7e3c5a4391756d169f91da775aba9453fc229603eedf97bae1cea70c99667cdbbb412c7a9eb5cfdcc801b165f10a0459fb891ce22bc663279b5004edb872a6b1204e941ef2720f1bcdf2e612aede0c9806e9b8f956b395ce4dfec2cdc7cc2c1a1c2e125472931bf61aa1e35920d81df8d93eada6e4618b6c2cd2a1ceebf2748fbffe10533489dbe7bd011b0a03567fca0150d89fa269438f678c1b108d937b4bde24d95394f0f4a3b4370f8b42e0f7de9d0a6c0a744a324e097adb213052b5475313292d26c44b509096b656748200043a07212634530d11e8ade8ce9e8dd6c01852a46fb4f8aedf4b9e74e9ded543e197436d361d3c4fb612f6d462ad5f06ee66a2d4d75d2bbceaa66e70727b6d35d1dd62f13f95cf6222afc018902bebffa856bd0de83326cd0894a20052a13354b3857df8b6f9e529e18380d42ef366deb6fe38331809b0a09d721c17cec16792a13829b15394e922d74acb2b5e89190e37f849335698eaf8f3dd75d785e4bfdd3ea9f38ae7efb0c0bc043a1c2a6322f0082c563709c1bfc81f10bb88aa3b3beedaf24942867649ffb82f5d5d9e0acd49df9c1b4743eba662a507dfab671f54126b11f52c0bea8f336e713fc55f5cd07333b696816449976cdd78db2b72e952614cbf5ad81d69ea1f4989cda03ff48339a9b9a7b946ee40f3dfcda9bd11a3c5e8aeb5a3f2a3ec48ee59a0e33b6b2b6e7b7ca4e7e012d05b7d88197a5651252498b1a9708999f102e9dc467d6a67878e545e4ef1df5345296796e698fd06468c775dff960fe670665172088816f88a23d42e473174a7182f031dcc114c7d57f47b65f8093cfbdd1d66037ceb07d0bc40131a1b123e447bba0d53ba659c31e21fd905ac48aa0cfd82fac3666097fee8cd277aa6b79dd3c1cafbf6ce3987f83619320a4b4edf20efc5819a9082e6fac4a2289b7479efba749795e3d97f1c5dad75846de69bb15d7e55e97b7b71241c1d2e3030151ca058e7e6c9b045c0a420aeca89838e369d48531e6b9aa65fd217798805007c320a6c4376d76c3bcba8dea0a864a529a7d44c4063000246d18331a7eb9086da5e8f1caf2d24b82d4ee8633ba2d92b38a1bf96e20a4ec8a1bb59554dd0f8a7c55dd561ddbeef075dbdea0c1d770defe4551037158c8d4974875c7011ee318dde9b1004e43ae341eafb96a83f0e46bd4944c4c5a1daad4d527df16c5a332f44800cc3029477cacc7e02de72c717d12a8e3365995b3449c5f3c4aeb911f5f9a09b8032b700ddffc19b8b035c0c7007b5a632c984d20b3a3c685f5a142950cfd04e0f3fcd77e06ec81a5189179e6be9948ce4208753dfbcaa92307cd50b965a801f29bbe1ac6b1ad47126bbc413d0a6be4bf2aa1805c43e27192cfcbd560f50cc76af303e8b3b344ca1e81278aaba6536aa9ebcd6931d736a72c9eee0be96ec6b8a6e58bedf635802fab9fc0310152381c317d78dcce35df429db70d151504962887ca1236a7188aa019674be8623bde922b7238e511c60977a18a3a17323393da540e1629110bb051c4c5e01985eaafd4c4143ac737e51c086b876705275b23365b8b0c97f6bd20e45cf50261c5c8f5111c376bb807434a248e75878e1228c1e952aaf92ee7c9b1b123c1244897fb4d009e901a6a42e79324596fd0099eb9b62322ae00c3cc00d7e6d95981d034e7b97c6d3efa5d5b7d6817f2b4e028607a43014cae177c83002684c72458beba02bca23d0e52a3490a36e699bb5eeb22fe5d362558512e295d83e9a01e0b6f4fcb8a21cfeaa54ab0bbe41e61260f0d4f5df2e79fc2af014d0b72fe12453833901a2e5d67e9a6fa9bb9ede63e09f5c01468153e4b68469d4858c39ce19e222e9961865629a3f03d29f63e5253a3f1b7e4573d5cb0021113c27040335742d277de6346c5b4be9e9daa397f8b3150e9db88f6830d98c04d8867d30782997df8e9e0c1e75dac3eaa4733bebc628bf916319ed55f2d0139af616753aa499b5fc5535474ad31e649b544f4340411f9f58f7827ad66ae85f6d30e3c3fffaa6b727ccccf79bbf833db76242f15918b7996cc491d18e3836165e9ba1743e8a4ab0d319984303f5026d93beb6f1fa4e8a54637f3e66b11cfae7338042de39376063d055374874127080c5e367aa03bfa48081ab85739359f42640963f2aae6d19492776fcf15a27fea60d1bf9aee64d61bf53585d645bb9d39306ece6996056fc6fbb9b6e4453518592977ea676042c08190ad363687603308a9fb2ab27ed119ba8b8432d8b6d1eb7ea8bd6c7c34997c8cbdb0a0d8143c09e4fb12ed610bd6c9f7337a694c0405ec7d39015ec4676ebdd80791f38b4785cb833d172165c018ea5d484ec5680cd588b3ccb8da6ca3d30d142510b77079b590fa95d6d9f6685c4dc189fe6e5cb97dca6ee809df0c2662230b9a526c4d85912c153f3fd0e931bea6b6bd4c3b15a81025383ef45f813f51956f378ca28eafe43ea43e8d52d48d863bb93b65f5cb4ebf5805e5df38bb7bc75f044af14711c187aa5cc9d535944b92412394d3730e6d9bd1a4278b04f2fc8003c12e96a7c5c4eaced0b8d7fac8d5f8fbe400fbcd329f63c59b487c8f45af33bc211e7537a372b0495839ec0c07a667c71bb3c433fccfc868bdf02e2c031db04f5f9ec84ed63ecccacbbe7799d86987deb84e7a9900223846764417453e7a36b502035ce046b26e5f0cade9eff6e2f0b9afe3005c5fad22cdd2725c22ef7402947a5e06d847fc57518b069995cf44b4f98e48e7302326dc0ae65ef10c63afe7f25e33cb41a43dec869f974f0317a69d8a55a28fed8588b81852ea0a7765f9ae41d614024ea8757a16882c495c46799943b9a5da16fe412941ea82f0fc3bdbb0fc9b7cde8baa17f90abea9c07fb3a7cd8131ed1e4a82f39dc9ec4d0b09a83c6d2c2e2e8be3f4bc4d4f9c55fba51ecc72290fae6bfbe0f607a8380a1f4ae562e55246168c26ec8546d1e4cbec605eed9fa90ad047b89c0d0d669e05bafb20dc44c79894e210c26e399cd5397b4c4519921bded0c4cf6df82770f20484970c1731ffd2037ae208b294144d641ff467235271c492b5bc6a4afdc4e2d17b0af8f40fb6aa5fba89987ee9fed835d4579681c92990c546477166e01420104feb81bd484d22ff1e619e45a2a1d0d7df4866d01463581112397c4d39200721edb09890fde41bd5ab82b967fd2e8899a20cb0b15f0b57bdbfe1fc0133f7cb995c240e96fb554cbcc9415c0420a7fe3e6af2453e2207593a2b2f81ca772235af5d041bb2a0d5bf21ebe626a8f11f08ae88878c338945008b4d286d0981f48bf5a1c0665607c18d97d8db6757ccfd021db7a023b102ef9f9157dd980a52d28f926e6b782dc2bd94f2521544900eef69254fd3550053ca9a76c1a4047dd1a516c6fb7fa3b41d0fb5cb0f4c5674d8efcc091d1b959d7c4f756fe6317ce082eb3231e709a83c4dd3f543f9e294a9c47bb114d07d3b635150312c299dbdcfe99e470133d521bea8f53fdb8478c8a953b6b44ea5669493232182d010353a01b48d133342419ccc06a7659e579e9049ccaa54f3b0abc86f6cec2ad4b02e542f15fcda251a4d696cb23524f612e0c82b680206d92c0cf84d38e8d10d0cec542f56fe0ddd70956bdd56c087d1bcc1ecbfd2960a959431245c9f1cb984e7797f5a0d172d89c0477321ca40483605a24d93dfd7fa37baeb4094bf70a3f885f15ef3268e499c53a7775f11f43dcc8f2f9a28226eeb0ce806a912fc279735b8127a6c6f85eea2fad45306fa1f148fe5f1446c2e66a671f082eb5d1b425a0038a2f6ef476e61da0362828bd3ab3963e16020d2a2e5525bb5be3b1803a8eda6bf48880d36178ed9e103c5517ff13e11fe9981b4fa8de6a17436dd2e0ddca5e3ceb231761a0a8825e71389bdd96923324459fa47e6d12908a2691065bfe7d7c20477ac60cbb253ea170d2cfec29abd76e4bdf87a1e6068c2849f3cbc683ae316d32a7d093289c2c59ef57db689b9909a29669a41156418af6670077d80a4e46fbf5b2ebb1451c95e03641a13e523d129472bfb4d0a80724b551b057e8e083e26f13f24e9d65450069a0e1cb718d6a3a3438ad38dcd3270b48a88ace96249dded0a38cdfa534a71f59d5ff55f80ab1b5e0cae427786373b49b773ab98274cc541a587500955393b3914343cfbdd0c4771b7ccc9d2f41f12c7dc9e210ac196df808c2950eb4f06b2d219bee9e9e6a9d70832532f8f9477588eb17aef28b419214ff653b3703f988d42825f4d71cec0b64b9b2600f92e0fcaed326671e33bf40c20a82cea84ecf07800ef81ee309a8c642e3357e3d3ff2d6ea6b120df5b09145aa6017fa94a02da643a8864b4684ebdb5106fba7a750ca41a2df216c5d0ccd779024bfaac2115c16092324b53410121dd46faf724e948d4159500ed72e87e4b1b9d348161e47f8878ce79863482ed6a28a501cedb0c55e0c73338250923e1e135b3af318f39eb87833f0370a5dd60ade294bbdbb2058ab3234a8c8e2c91083c075114dadf26364f11d65038c45ccb94a3bb447c5ec488fdf82a8a7bc327d101638f63e14e0512f7585a93c80fe0bf5b5ca949b1e067acccb356029531f30d7cdceb11b7f0aab74a5e51d865e1bee21f00bdacabde4837f622793218c35d78663f83f2ffa302b5698a1318ca2806889328e84e08e0b01f59028f90e722b67f4bc0c7c6903146302311faa5ea4b4d4cd0e50ea9abd0d8a71e252ef3ab4f2c321dfffdf0555974fc9cb2c1815dfcff38129139c6553bb05d192d591dace9fa3d3808f45d6102d682d8c20ea508c1c6f4b4c58b6298ae00c4bba9a03c808d637cabda44df9cc89008fa83bfebffb8a6a3d2462d13cd3641fbefdd9d2727046dac2a54c92bf7f708c6780768de298dd8cc71d3f3da51513327b25dcceeed157ec05a35d4c4db67652e5576b5ccf2496953ae69623623355bb84beaefab33d0af50006bc0bb8a2b1699531d1cf734514ee9edcea4e9c7176a51bb0fab0ef207d33bab2b6012446fcc74e4e212a5e1e4e4acfa03351c19bfbe7f3f170d726a47c0b238ce0973c6adb2d450f5a0120267227caf6efa741d6bdd96afa7ed48d67cc8f11430b262bd9ce66ca494c322c4fbd4b15adf23a67b4c9470d6d5070876e3f1646cd8dcd300a1a8dd14d4256df204866b40b06299158c62688edcc96dcedb802cb1b26bbee1ade4672cdebd98be642ddd52dbd965e33bb2445aa464980e2e31dcffe81aac9fffa69fba44403534dbbd609db835b827991975b51c4cd7ef9b46739f9e186517698992ba3c303ca21a9dbb907ba2b9b06b07602ea0f8bfe165a2b802dacb28a609787bf597d244e4f2579fb0bf19a5c8c3a1f220b9b8665fef0ae269bff329e866861fac39437d152c8dc32220a2adbc854d4aafe76c13a4c324eb23e03da29abc47a14e8d963be96a230055fe8a0ae087b5fcc5ae7cd1a1d40f7e39039482ce9cafa34d796be4a3bce2648d48efe1457f6c323931e8750faac0276052d0cd336f2128792b20c5d79b1d7e130f6df536779127ece565db27601d480f9bd8f715d84c1fc276e5eda464834db5b0eb77153ee34bf734694f30e20180b3f6c52496a495c8838a89350ed88994d4f5d4414c643ab61146cfc81ec4bd5b107cd16b9e1a88d4f716bed64f02ed92925f26fe427c5d4dd74778838da2816b2e151b76bd50f7241fbe0e2113e6cb2259341d2be0f7146c985e91874d0a77f36040ee8c8ee3f10ef356400de407d9ffe9cf2fb0792f41523db7562acdced734e96932e291b68f2e48d2607899b32967e31047343f13747a9d4bc1543a5155a146033828a5517fc07a7f110b78108a487890d59d15b6f716a173156ca8c4ff7c42d0c848edde189fb1d20bf471f4d66c819be2c9cf3af22bb84e9409aaefb237903bca4caff765e2f5778f7f5adfa3b819ef5d334b5193a8c0bef0fc69e78c0d8009d8a25289a969fb7d33aade5bac12a1148579cfc5889f3c6e4f5331ce9854e847dff7c8c0f88d3b54f13a2b68df67ea7e352bfa1d8e601c82280082692eb1a2fc905881c71e56a5f78b8036fbf6f7389d3bd36d0e10fa56e261acd59f8f45dfe86a83b8027dd953411153e7b1debfbbe33fdbd447a775ba1f5f4694808467d663bd44c2efdb471d4a92abff04c3871977885c177b75c23964294ee91c6b9bb3c810ba2c28009bc7efa0cb7ef13558c8487368857b36aa9ad4fb4e65deb307d33484f7f25ff34915d0d7faf2b037d437fe2730db59e34a55b1689d54d8a80225520659d097212059fafb35646a17eab7217642ce55cadeee3e45b2eb787046a63412b3bcf3087cea1d1d07bebc87bd0c1fb3cebc627d17e0599423e1291bfff9bf1fecf7abdf5d8dfd9e265d0652c2874a5336a91338ec2c80db2ceb784d52dabe10e943cefa400cc0c0cedf3fea90604d8fc9c3e813f5a5714ea3b1b01824dd5f872b33d2feb97b6988dc6dc6b89daaeab859875e422465a1019cad320abd7f380fff7c78fe7213329c8879ee04b93f6d8a86e9c8078143fdfd71bd9605f4cbcbf2b75771423800c64fa244af8977a3cf2dd0de9068ac1abdab7ca9d6c33f6326b326fb81876698146b30c377b9b54f698fe4e1b21035c5e9cdbbf8357514013864fe31e393e86178cacb0478720ce882ce6ba88e8f9d767da67c2139a8cf5682d83d2d8aeaa6065d365f015b5fdec0a735d018eb412e372d187e8ca943fabe69ed47c2ee76e8a60bdb92fb329642d3f859ef15c7673299d8749add82bfd6347e5c0894c72657f4c4555d7a2c879e842d737a0d7200615fa0cf6b01a7a04a9c37ec305dbecf66a2b1c6a1df144803e9f1118ec345f465740a31ba4fe0d91a6817d83db58e0fbc8cc73d52bf912b34b1d4dd03fb720a75358c680cd4622359df03cc2e11ebc30edfe074e66070795e8c77a3ccb3c9fff58a4c62f5901d34ca1816f955e06e082d9c007a949d798052e4c246dfc106bc45fecaaa1dfca5712a2f9810819dc7569b63c03a2593028f73336ebe2e6d4c1b05f575418d4c4d9f3bb67969774b86c47b4c9efa237b21003b473671a22a80ed52d00be9cbdf18cce63b5b4b3dba4e30bf8540262a73fcadd106b7ec41a76475db048844bf499dd23e034f143fae450f5364e034aecde5f4da7cd4ca3c5dc89e78f959678242ef41d04f9cae5d190966347cee08618d71b9caefc112942d3910f3ed4dd256e44d5efd9f6c6b3bd463a94a3783691fdda8d3c08f658c7f76261a9b7dc4de86be460e2837ae0c50de94d1791936129f41a178d6763468b1330ea8c6705f2e0d26714fc173c0a543ed79e575fb0c79414ea0830493477319907b934e1649c5a77470f8c1930de4ebb96ca0cb1b6e17f5302bc1ee6e6a8d4dd16080b8a784aabb4b7c599e9ba301cdb005bda5d3d6cfbf384cfaa589173385a257963ce04a2c743b602f3022060b103b8651ff68a22f8a0401a6b43d05189a82f21a17c23d19d507cdc1b10b33716d27b7c529f707f66c5db9c41e5307ace7776516a1a401748481f70c1d5be68816d9c7c1210db8e03c2451078ad257edab153fe83208e4a7bb45ed867b3b470c722232da7793a59f0f38a3ef75ade7f3f661d3238501fa48cf13867a4054e95a25fed377158606ec8ae08245e8b016ba603b61d1f14027179ae4532d32e278d24964aaabdf59f664ab65fe8e24061f8f6baff989acd7fd511d16e0b3c5544091d3ea3c8ead117b1afb00c29314d2196eb2fed7a2bd2b7c8d16aa956a30deae4b585817fb14ae52d9719f071e796a44899136a6975c088d0b7c19a863e23e4173806d7e12bf32173f90c982ffbd1644c0b2fe3c5e44268722e0f88938fd430e88a8cd2f69136e6be75a72d345db88253b4c5bce92db6c6e3963e2ad75d0f9c0b3078f2e533f688c73597ca333818612d990ddb71240e089f3c7e66cde1c45680e8c5fbd6e4b1c0dbe0b5a263cc5903e3589b15143bce35c2725d3e437c2bd4c101f6fe5bd042c729f5c9cf3a1823cbe954a0f9e05a88092f18471567c1c097ee7ab8a0406323850040355748c437056064532fd9f2692b367ffc877a051c2484aabc1ca0452837ede52e8dd609627702948e1e80f6e4c398dc182a7df45267806876c4518a1e72d415f91ddf7b551f704b852180d8226d661387b30e5abeba052d6c3da29e3aa9505e99f0be9b0af8f05c283a0d1c49790b2f9d6ce9157c28469e828e7b865df69d41a0220e884a99e2d0290f6f307e133ae225a07b3623b7e9db0f8aa2d6d17d8a6752ded52d589311ef979959cdeeacb189d80e01dc664fed336e450d41e3e77df997096dbf50e9ea76d84525b54cfc28210a2b927d04ce79c40de9f9f851fa63e78fae79dc771a8d59abe89bab1a1a3945c56cd7965ef672924a248125d7bf6a244573c3446b69b8141d91a6f489ff306fe0f24b7e07b41d315679fdee0bb82fd76131d99b3b18b696ee43407b895adc6f486b71fe4b9a6582c4a1c256586e7a95fa383631d3030c7708d1de63b9a8ebdc5fe850278fd51d868092f563dde1072474e6f8c4a207a7d46490c3372c2dfe32999b257afb2ff669997d9b3c4338c8e31f3beedde2cf003aa173d47984d43460784d0b82d1142b5e197e0378fd5e15fd44ffe0b0dbb6812ed19b347a1b89b388440272657d254a631a0b8e48e4b3ee175b15dae732967004ffc6badfad5f29446e07b25ed141df983c3a98b17c687f5bb112c5cc387ef18b89c17b1dfce05afb0ef7120ec3eae445e4904b0f851d111c35f96c28b4b4885324ea4685d20aeb4733cfa84987f3536d98a2779a98b1d6da9c9ea03d7c2fee09dbaa53c6bf450a008230f3611c37ce5318857f73b94913ea5abae6bf4a54e323eade4d1da2d3aae91501dcf865268daf2338f18b105711f986120bdc2edab10946d6e74e1af7be779d5f515ca838d9058181d96569f07fe8fcef34659cac78746512300523ab9c2155e0525fd14766de3eb1a18e8877891d61a55e6e9b09ed7d641861fa0215183e1a44243235a7c314f9960e6a2202e6f0896418d3270e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
