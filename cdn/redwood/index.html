<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0de7a77443bb33a4037fdaf154341f5c19195b537b6f0442e9dd4bd9b41906ff0ccfc8d6f7e7208e72fe212cfee73a7f2da1264f2fd21221951461fa79409754f70d3eb39160a279e4753939bb5fa8a13a0b18bb0d2da95381afad973d44d2026abe339f605f3cddd094e0cfa38b262dcad8ea862442ae6876b3deb079a0619a7406bf423edaf11950562a9a334feb732078b4321b26ae8d2001b727aec136e3937717c29aef23da5f7891a795e21a37640d9b4c8313e3cff1610f85d48fe9f1000977c629af8e838add6b36005e068f47633c98098f85fa75e577d432eb01b22d83954a47d2176fd977f4e2cf86d659d019da9469196bb583f82717210140a1fc5856e09889eaea85497c1bfd067dea556f2ba4e029516f325fc07665eb34915937098d880fc457c69849cd4469c44dfb3bb51e74b017caecc810e44307b95085669712721300fa44820411d3e7c79729d802c706d56c8285e08957359bc27542261e40774afc561774268ad306c871141bf8315dad547a0aaf3cc777996ceb5ac10523b8c4514b0c28d13b45bddc235b84ed216920c5cf47ce4f76cbd5c61f67822839d5432d4533fa5e8892c9c9c5827a1ad683c736df8a71b9cc2243fbb2c81e6ffa2631ff8edac656367d446f1bffe7bd455e8f6b34cae0cc8c32c8eb199aefc722ccb35b5e183bdc5262d27cd69b2f6eb1ffe535611c6a18f247a3a1251bea3509fe01230bc807382081e2448b67e7e7e1fe5ba29696194f543106098cd9de0da4e3b272bc759970c14cdd380e0b9b591e7bb6a96b88d84491a0f9dd96c35a1d7767bff26f3d3907c97627cb3a3a978edd2285a3a96c37401f06f42536fffc0167e6ac6585df696ad4518dc3f8bc8da654c2f2a1f0fbb3668fb27a4ce13895233b95830ac6cd9ac7aa322b8d060891791b174e69395e53015cc17f7f26c863d4c2c794311939aa80265b2dfdbd3c0677d927855d2f6356769d598d28724473ff7e9f3c6b68a2bd5c63d4827cdad69c204295d141254a3985a5f80d868a8ef542eb9c12ce69b18bae5821a28b0e54bb5b2ea79b630f5e605a64caa78d702880ed378e202f70248796b88906103a7968557a5cf3c0fcd5923f944b56b4433f39b15bd29878c043f002d9d7918ff17a51662c15e462f6dae33762fb714745dc132acf940e5850d0e5cc4ee9a5d15adabb09826049d8ef0b291e2be05a73e5ca6bd1a07205f9bca9a70250c4d70a9ff328f8715db0994be80d368e4e6e82fdc6494a405ad6db5f54eb71b1e29dbe10a71e1cc3d0338e11c6e9ef1c7e5fd9d5dc3cd7317475854a87b89d71ce6b5d8cbf1f4a18ffcd21d5c177b13fcbf1e6ead864e5cdd3abe8d369dbaf4da6b49d73c23fd17251ef5b26ee0e3933cd30f387276bdf099efdfb58970abcc53163d6b159a5e6fadbf8355a5c6a86a34573c7103e0a4ee1541a9bf57f7cf4b9233de8f311dcef68823df260250256e919243a5c432d887912ec2182f081d61b9776de63e0926178cf555b8916b8fabc5a82fa34fdb7e584730184fd0604c3ca8206b534273590950642d1ae15b7cc81ce5beedb264ad0dc40ecdebe2b7ed4a0c1ec63b45159e0e9c826f50c850c1a8911b6730014a006dc7012d50d1f3e5dc1efee987fe49fef402fbbf4709380b79e159411eafdbe4109b0b31f37e4a3a577a07802fc25231e2bac6f72758f3005a3c4c7fbed5f90d4402960d32d94adb2cedd7f7166e0db04695fe65be4ad52ca2df0871396137aaa8f6b7c1537e7f52b020dd2c89421809ebf5d7f847f80a48626cd2d97d731e0c3c9c643bc317cb5c58f166129444896c33c2da70b864f41c2e9cc5ae2a5db711933be8428377475dd86bf39886e500262770f1e5789113bbef792675b27b233e6d7a999f275c1e9134831ada8c3af1c0180fdde2a229c3d4fc4545fc8551f7666afcde1ddd854c12a6a105b634e8798e1d8408b0d636fb6481ed5eed1b8794e5033e9640dcfe827c72b28631c6757ea8a10fb035541679c1369c99014df311a27814ab5ee367b0ab9b69ec973b69a158dcec95b30e424b602201d730718faa826ccaac157c3bc28475561b03b07f311bbb6e766382a3ef60ae3c2de86d788cb41b34a8cd94dca63d8d11ecadb74fe7d7c066ae19ae1f67ee9dc081e5f5ddf76c2657873541b61f2ab5f2b9f3963e3ad000092c595dafc498fab007da7778337bdb8b91ed19a3ceff52af7d4b4c65c0428b5a4586029c8454d77b4f508f269be1aefd013d579c880f7c41b9dd7c6a0342f15246891574a4d4899e994e38fda9ce602f6399f67d6ff2b81b04b44e3514673f2fc0ee8ca619f93d2ad4ebe267200c355f7202be42dcf1cbc39493641bf16058f206e360f00aa4855d04a6be61e4c0b232b93bca00335e0376ef0b6f5ee5fb2ecc616209ff124b712cf8d94684e5c9e7ae22c88603caa7ee627a957a3c82819a5df29948820c958a8662230a326df0b4259d63ef4790467b7b825cff7a217b5422322213bd59107d1ed5b9c772caaaaa5659cd1f399d540b03f6fd3b8c92e45b1e2d38c5ae074143022e9da693d34feb8fb5a3eefc90e18e56d8d6ec3634d39bdb8bd1035710f119c5db761281ceb29222526ab55eb1d7c3c5b5f9648c7a9749d777a2e7de65f4e34e465e5b1616e88e11a20683815930a52c70ce0c2a5e8ecce9d19a42b928dd66254567f15e434c8749d2e2f5a25a6bc0e3f1ac62cd6bad47d06615fd469c84b827929e3242a0228acc2b53a99c8ebadcfdbc08b8b86636e950f52943562e2b38543c97b58a7698d11684c0ed493f4d6bdea321e1f16b7efaa3f01c1e526efa51180e084275ae14abff67678bb8cbd7b73ceaf3fec72687f0d9aa915f2468fd701308081fa7c72634b5487f645af9c7499b0f4445a2fc8fe828a702ba1d54f26fa8ce8d03188f703720b2a101ec0bae57765e77b16c850f9ece9ac10bf8f6551cc28bb9a6db746340666d5b3f1eefd7080f369316b6bb70240127126fc9e81350f49739fbba4a30cf4b0457cff32f9719a6672688d1a498fab9916c152871824e116c587da91f7f322aa1fe018120bbe11242ac0b0c36c81046ff2209cd7484f5a0eeaf5c6f0e8d63758634f691b625ed9989b7ea6ba75e8e143a51ed49026e056a8cfbb17455edab498063e9ba6f4a5e102479b55e2320d442648561e8724facc14413c12e13e45c260d7deacfc945f733c4049b0710d399e756efaa3ba108591ab15825797969048d6e6f6b123993d08078d7741002105a8787a5fbb333f84bafa2f1c82029a62081948f838594a85c40f3d1ea6a5595ea27639208c1ca0a7609fe0e2b5ca66a9fd1b73235d8f28c7d27e8c34820a85df186534f51cd61649f40d2012409a32a13e4e573536c5c7c4e4ae30a383ca6fb0583090b6e1705ca9140b4e813cfda5f0915913d572f22b3a129b0e80cc1344760510258ed2b009f182ccd77003c293a51923ec36791961e70bd5e4e7e9c3be03a6b3cf0c56aa5bbc7d7de860c0b038d4e3277f9c67054a64e26e1bd005f59c91b4f01ed96f27eb6daa937b774e60a33e680056c8454e94c5e7f8968a9718ccddfcd59caa03266184e05c4382e0ba656c12455f31fdd8a1633807a7f8b479db8d0f190c7589d15522414137d00956920ad8a91ac6c5ddc1f9e579dfa064ab8155da53b8acea764cf42372919d0f0f23e394ae27be1e39159a1657221cc83af3b77f6f9a1a9efe6e0b91dc262f6e925806a9f367c947394cab59718888e5738c17f3dc437ffdd1a36dbba2fccb8ac9d670a20d6c52836daef23c120dea6289b23ec0fc9cc6c8ec9a4f8bac68271ef2b469ffe30946db05795f815b534905aa9a40c8af433c242d8d157cdb754d913a4e8fa89f0465efd2dedc4cd63dbdf98d28c5dca48da4e0b068933e8f1faca8158e54ef03057f6150eb779150be60a8f2cfbc9a5e7f09d75ca72ed85a15a617cda5f33ae83e41523d678e55c00fbae2f4eec636e837cc0b281c1677d3055f91bb8f555f53c42b1c2c1b5654755db11af36881e3375b4e1939b88eede9b1e2b2feb6d3c83c7ff8a70969bbfe3b2b435d1f12e5629c586336a54ba1eb455a56f30973090be80f356693c89ab053a30379bc9f8e8ce7c4ddaf3975c077f3431dab82d40ec74662169764a8e382b14194872b82c84b54399313174bf56d40f2e11ee4879efba289f92ee44981201bc05900b7e6837ce1f8b857354d7b4d27a79de638acd4877a17922e4570415df2ba7cdec27bad8d09decf1f62e40ea00d6b7c4dda4fe83907521e3ff7b52be4ab4a85e61010e6e74a1c7e20150a1cbf6dac688348231e9f3e2d2e402411743c7136d278db2f65b431d605a66c7e4016cd5237d7aadf3a149645f7ee0a1fa4341dc21540db25e15289e522f862e62a04317746e7dfdb6454b3bdf4088236d97e7606d95d470ac5f214529b5e3872cbf03dd4d4a3d640bfea525565001288d47ac83f37886e29f13c7498c99ffdfa065dcd1eab579dbad23b225a38eaa0908dd39a0d55047fab6f8093d5bfe8889a43bd5382582422f30f4419b0d310a1109977f7ff4031ac9e073bde7469a5d59f459303af1950a60b1827a30b7cdc08ac70233f336daf1a4bcf7a6cb40c1f4997810759aba8b8271290c049e6004292916431648f2c06316a7d196c031c3aeb00586c2d0b7048fa303bfac2c4d42b738af133172c3fb388d012ce50ee00d44425aa77b5b380771b352be99e9ffae02b359ed7e5bc8abf4028ee998a1da27276ae58fad474f49458e6c201258bcb1de2203911fe574d2cc6f8ed96ccd97acb9467fad2aa18cb0cb252f3c60f5b12e4ef02a4cfbefee480f8ed4ddac807db801e88e0ffb7674b68206e5b84d0e4ba9f28c63ef46b023470be589560bbf9137b2b477d41405faf14a1b4dd858cb42fae1f9a15dab60432084b0b4c24a44e8b0fb6daab1ff110e42864e90fb603b810658bcff73eb783096834a05d5c3fc0148ff0be62fd060925331ac1abb42007125d226c56b7adefd8c965133088bdd988b76116444e66f90004dd2fb9afc230f56b3456969e2560297d469314cbdc32f018dcacc7567a9d12cf22836d8b11ad92a0d9bc4fdc67581ba70663ffd94c02109ae7ad484739c417758483c1fc73682ae44caa88511457e6d991a70da2e5fa51c8ab4bc2f94d1993c0ca1e122fe9d1066a77ab5894f8ed543ccd05c7eacf18085ed721ab0b3904cfd8c9a98b319f03cc05311bd120bcc9954fcdd21008e0ceef91c14a413bea07e28d6553816b2d09ad3bb4f452a18ce2bcc48bffd7b7dc1215e0ae7e877b1895b90b9c5490d1909b9b083c951a25f5ec9a0accfe7998fc19c9049cd682fe5972877281f89ff22ed6e64f9043322b3d844573cfa0cf64cefaee611de4f826734624173154996f7383278e49acb1f75f8a675438f27bae427d85ce385654e23ba8a740547e7537f9b6bb7115684614d802ebf3b9d2306642ea850e39ae2ed3757babae993962f5772b8f2ff919b66959d8fc5674428e9cb27252cbff016b8643d1d898202edf6b56d976b7d7edde33f08ee80c8144bdcf0bc00474becaea16564b278a0078ee6424cf5d164e2eb3dc796a0d219a90c96302db815a4735194f0fc04ef0aaccfe0c5f1a2016b3a2639eb6114875bc8b645b8f90a68cdc0d18dfe511f081981c7ad9c44fe4534bd7d351988fa4264d1090b04af2bc5a03a2ec268577440ba62d084842956c42bd8f35d4445499c9b4882f46a51a2a733d5b731cc4fb61e0a41379653cd4df386ceffdafc267f4bba19050bd5a86103b60e7eff8c43d402004ac48e9bd9eefad53fbdb6f4c88024b1a27effacea1b812528cc73920c86ef9acd87d435097b4e91e8403b703680549a7e28b5724913ffcc934bad78a0fe9ad1d8a8e6bcbcff188d3ed186ebfdd5363ce5f78d144b60cd0e7d3d5b3cd980bf673595d4b1f2fa6e827abcf79f8e7c53a9c0428652cd854cbd5464184e3017f3de08985df401f99626321943a882bb13a6d1b8283291bb025f6c0fc0b9bb3d9ad450a77439f96ac912302c00029443a202a60ff55dfb28530667b562201f6596b683b1ab29c9ab7194be183fc5d910e4cf217f70bd5f5c5a43a5ae5cadc6fe964b7c55dbcf3b82cfb0e42de66dfc6114990e591c7d808b793b394341ed64cf2069b803fce622107f8f710cb09be1be5827aa8d3dd0624a7695dd145b2b9e95db620d9e5ad935e61a05c9d9f0ec57203d8d554848204dab8d21e429fc9d83cc1314108f9ebd8992d8de755193705ed6771be2769e08cfae970b157cb307a832af7ebd1e6f138c24f26a7226eafb7f6d00fb7fa1b3d209b55a3fe769de9383dace385bef314a07b5ce355745b9b70f6c0dd1a8c7b0bff0d5c239c7af59f36eb735673d76ebd35d0752fd105d4420697bfcbf841a17be699ef60d82ed4de147d87aeb7f9e2c1cc21517c7d1611e2251dc0baeaefb14facfdf3a291182c5a711e0aaccc69103ee695bc7b732a087a2c38a8dfdac103cb5815d9caba2d5c3bfd98cb9e69a3c59f9782adcf494af7daa50f5c05a372e12d587aed761bc7efd78149b36a5d6faabc90bccbe2d55772f5c8e16f7e22f02b7879a967870f4b48b2d52ad6aa47ff1c00d163a8e7991ce3ca757b20f23697fe499bf93fb0fbd1f018d835623710e17b998fdb53aa615e925f11d389dba206dddce5acea167d19a21d5a7c9fe352cafd207829efdd27206d2a3755124d7ce54ba106d15babe38ac691c7d3cfd0a85f2be95f39b8e740347704b5382e6945ec3a2bca72f67c2f74fa0f341d83b7be417128ad9ed94b780ad6db6188ec028349c54e13a1bef9cbf7c1d4dc3c0cb5642caa580f6eb7f928fe8fdba6fe50091b149a6b479b1c0c5c56c3b6c524a29f49cc0a831db226b5cbc9d8707977f5b6bce978556965a80b2ef0c88cc1a38a227f31ba107cc39b23be8ab6d0ae45be7a4d8d515a58e3e23ff215717f389f1c17c11f08727465f1b648390fad3f0a952a2b2f904551b2cd8f5c44300b61218f1ef4ec2d058f734cd31ab7d55297505c55c38eeae17aa2bc94398ea89d6344c50db21d3e9cec9626e23f0c275f7eb871982be80a3f1cdde60e225c26bbffb4dc8e12d4835237d0410cae8f574f99870fc0233800c5b12f6e5c3b773855b4afb8d889b1c1b25efb5ffc74a9edb4405138e5ee1839862f824a54bf7845d38b304fc8e98156ee7282b649246aca849ffa592573e9ec83e9a9041f6bc1a9622365107190a34cc7913edaff920dd0f54bb6f363c632e207dc08eb48be0c861e9302ee7bbf16542c81c3e27b94f902683bc74156ad2547406271db488a34f4789f27e017cede5ca6ec34f5aca0092ca57d343a867cb16d62d69a25595f1c4ef97556211d30d441b568c764d258cacc771aab47ec33b7bde60ba9377d989411f40374c29ef424e1e8ebc3d9961028eb80ab663bcbe497ebee4292e6f3008d9dacb781b1bceee06815af8d0e1d6e1342570eccc6c5630bbe66506a690cb0844e201dc3790f350a33fb8fbfbc3fa242af175cfb1d69b2bed4e140aeb47450f7e514fcc7d87f2e6c11c11d518ce08561c0205baf4439a67dcbaa5c115f7344f7db2ffc49eedc205e7ccea5a8b6e09cd5891c418fd4568ad9b4e3b46cb1a923c38c3190bbf14fe40537dc2e9d8e3d3044e7a70eee38b6821feb549db80789cd15ea07dbaf184f838e805e88d26d0186bf6b4fc4522610a452c8689d458dee7e76022c1b89efc6a463166c2784eff9bdd5de82f35bf049233a4b5d8ec3dcefaa7bec080ecb900f432c69da74a3101fff075bbb1e3992adf7ddea3f9fc64ed07c3463bbfc7a0c0b3f2e020b0448a1abeeed6e5ca0af32045c3dcc2b82dbf354ddcdae93660e75adc9f6b68401c9c1830123dbe78b75009627961cad18fa7a8da749294101408ca87c97b27bd3d988bd0053d7197c4016a979ef963331a8fb01c65188f4e51379c8744f15d76506e909b9a4ee9d7cd898d6e1689983244c2b3b6b6f7af9ba5ae4d09e047da04c584d9a3687316c7208f5da845b68ffef621208f2163ddb94f57e61fed12b5d2441d69c2dfce313ee3abf9e334dcb4660499c5ab6f785c8159bf207dfe3bcf0766582e3aefa170b5b11dcc99c699da7b11ffbde4020611985b1cc22fc3b85add91b11e74d9286fe65bc870570a2a467494d3ea52a8b8cc13d45f65a3a876f88c6b90659fead1912edc793cbbe3fa101e311edb30dd766c51c6ce73ecb87617278e3ff5644ac7b8ce31145d3f8880e082530d0dd71dde4d149272488ccf692b3935cdff69826b905bb417a1d8aad4cdcca8accc8509ea0cdf8fa8b0d8b39709f6bbaabd8653ab988a83318f0f4ed60454f0939eb5dd94222555d1e9990f20b56b839e88aa19f4cf4bf4252a8b7fccee92dc3e07fbc273fa4cd849fb66bd7a5827b37ad9a720e864402485f7cd94b3f7d7b88dd6154ba499c154d555009ea345127ca02ee532be392768cf931bbcdc8e3ae6bb86e83a2ac221bc4dcbed4d1ad9722c488b8e8b71d048f950802627b8221434ab646467efa132b130c8bd39860d757822bf0a0d8047632dbd7b5bd59524b15418d83b0d41cc32553b9c926cd37ca3bad52a4ac7edb5c82f90e081b42c8114a3f1c6a9e4487963f33bf94bd6a3f5924aaa8cdccd3faaec2e8d3b132b9bda706101790d7783216b032cf6af69c43c3af3e1c80f680f3b7a8bae79bd2bfd67c918a53e2ba09d92fbba8f449ed4150b1a4d712c504635a9eeebbe6b73ec3eaa06795292d262daa35e1921848c8689c5a205bef80f9c84a036c77cdb903b170df3c7254eb2bc11822528f1da0f0d013eb142a614586e2af113640cb83ade806e0e82db8d62834242116b343d2569546669828d161837f0f63be35d186f7bbb6e81edf84c71f641c9156712e17819508e8895dfcc0348cb18f5c1061955d66b63317a99b34be549b5fb4012ee4e05df380b4a5f5e4973846b4e5115070096f5401f721a05c523b4e70cb1f52081fa3c970b03cac9c12346368fe266ca23baea025d73371854d5586e365fc12cf755be705d211da5c433a59f45c295b405b22146bb71d50ccc0fe3e7825cf6de9d0ea523db0043fbf8b5f107db06554a2eb470b6628cc2492c1c604f9f4deec1092a46879cdfd51f3dce9d9054b38909b3c9e9f4f7e2c96c6e75578acd13ca24152d00f268c6f4e799b8e58ade40f933ca6ed1b7755d189a7897369a46ef5704b4153197aa2ef38555add1acf02f07bc8f155cea65506153f155b5bc1b111f7e9bdc2abaf95587fb1390bdd83f134ee6f0ccd00a81c35a2eaf799e6c3ccbe91535e85caa658368d2b6611e869fcef5959938c757ae2940d17ac53fc12e41004b3b36b01d198b95d716c430e5ede64a931595931e4b38997ed23c0234efd245db89eb820522178d03630af7f6ed58186f801280fedcdfcea36ffd55e91eabcaeb7d1a3b510c5e3c3af0043aebc51a0194399b8fd6c9581eb02f51e15f097efbd406f4e9a0621dcd04ce99d2f7e05cd9171175b27619522eeb93001573127c95e15d896c5331e2ccb246913dd5f281224cc37058ebf21eb7eefe4209b033ab2ebc246c901d669113d08a5cabdc5df99be3ead156f27375d83cc606021727ae444c7f55d7bd589185429bb746969f39d22a7abb157811a27a09654cedf1ca89d58606ffbea894de02ece90900f974c8125c43e01d961f125ab90a3fb72fc96679131da51460f064716629c42f5a306114f38bef576a2e159ccbc0388246abd22ce21e51907f41a1fe7518c34cd245ce84acfa9ddc34732cbaba7770211ad7982d103f5ccde254aadc0ee075818a271537e91f42ac1a1359ab0ec62a55197036ef52b9a52d7a82b2f03949ed1dab41975dea2d820f84548cb91c76ce91869b976e2e89993d55d64660588b79d1180d85da56d4e08b45e0c026bae12b3ae86416b118a15fcb16010d3387d1f7b753ab54d43cd595459c8cddc803f6a96eb978925ce4b236ae820b0a194ecc990779e746b02919e96640fb87502a2ee69e47b3b0a6e798afdf37adb7140c0a89d5c446dc5b6143f165a191b1a6c62f0f3dbcd8370c1cdc4124471712a9b5b46a01121685bfe961adbdf2fa88c614e8c7f641a91ae7440a8a3959e698d9808acef98b2b191d1fa759946191cc5119253377e84402057f22737af0de074ecbb18801b7b833db55e479a5ada49f9f873aa26632c4080f477244bd3314cf758f25463b34cd7598878a868c66075214c79c3786ac1749e47094af8048e3fc143da6802af7b2f659c12e34f44ebbdf26c751ee3bdbccd6f2bb15f3f7a5716b3d4edfb8f69c51db86c54568d6a534c76a18e82418ef98fe25b5a2338020d0c33307ecb5c713fecd31b0e9f065945460cb2344fb1eda69569d172b7872378f69abc617c19598dcb2b7dbc7d6ee7e26ebbaedddbf73d78c2da2e626219ac663b67977d31336ab3553644ce93d8c4968ab00cb028aa4816e78d7dd3ca6e9385efc37603a5eea13a3370c1068ec01ffe92f112fa0e8c5837bbc3691127f51a85805acd9f853860942613bc675c8fa35c7fefc712aa3df1691fe4277a3cc30be718a84f3503d43f0695dcf11ef9e6a1e2376be90f1e06cb525da296175135dd92d30b343d006cd8183c83a17fe575adfccd3f1211c39c302d0be522b4b40cf0c41b2b89545a9a9967f8425e47ea57cdeea2f18f8c687db3d2c3cbd6f717b9f3bc0d7754e6a1814574ef95b6dd635bc5215e74273546239d52e61e8cb3443b0d2c19b439cf6d0721e00e9dc19f9f43d4e29b6e9021cc92379302060212a12868b949c1f360d3dc929d3a243732f549070b6bd35ee1852355ae79902258c1747c618a9b6c49e06121d06ae3d6efe90a4c8b07fb1a3aa782cf076512481bfc0f559b855cc8fcf4b1e12e4689953d0e04d184302458669acfc2915561ea700f08601ef122503f163d20b17900dfcfb845ee2c00a27e11cf59f20f41f7316d87d2dcf45b6fa5e569ed3c2b0312d1a8262e34bd30d73d8aa89cbd044e02b8922fca6660b059e31bd1938e56218db7449c5ca35be7ea81451f96bbc35a3f5080b526a7e70667bbd96bf1913a22e018f77cb34db415c779d28d5dfb9ff37479957b426d88df6a404f37357adb0ea02b9285dceeacd73b6ba0205216d130f1eb19d848322092e1d3bea4e8e026d81db0b92efea25c24b57ec4f7eeff4698f1d1afcc87366bb63ce3fb83fe9086865aaa4f7c599438da25612e35a96a5b73a0dc2967f9b4be97cabd4cd48b089f1d258f4a37b1e117de0ab4c8f4f53e74ff7286de0fd54f6d9ba8d0baf65014182a25ec4fb96687a007e9ad3829046485f4c7b2d36c54d9f0424fd87d7f01dc7ed0cc92e0424a98c0215c0600a04d1e520944a57f894a406db44611971a4063a5dfdb03da34da57e6418b72fceea4e237891783f3b963ccdc4d272f37e9580ef739c815d96cc8594b217f47338a610404b259075dc954dc59cf0be858c7b0414e725f5d05cfe4dd59b5be5357486dbe37b67cea856f6adbe2a37439930f2d42d8443321106c11e7db166f8f9718cedf486ed92c5baad4749e443ff8feddc4c7ce1d69f5227474a556c35c1cba9ef9876e6d7f8dd9d0bfa8282c95270ba03637dd1bfd3b2bebeb00be45b81e0bad1420edd5285cf6c66896facc812bec7f5732ec8d1693374deab584378935b34264f4fd05b041932ab2a1edfebf80972b8500684600ee2ac8efe5ed2e6bfb23d13e69dc60ecd0214f1e7df89bd3ba2b38560fe6874f78b3814728d54d4b42d32f2155756c711c6917ecfe9990b38f41935305bedc89ed6f0b3ead892ae7eac5a7c8f9fffa1629154609ad99eddbd335157263d814973174e0cf28efe070c86afaad250649659c954b5706ace47310f4deae1928bc786f1414fc60c50125c7c1d95616be9bdbd2158d450fc3ca91911dc9b6cbc7cc8b2b5b662331e6f5d7d8c71beacc2f8ccabdffec2ef76ab798197d9593606001d79d84ca274157b198c40dbe483f19ad59a254bc9040dcbd26c3ee459c36c368a44ea5402771f195f06eb1ef3a38fcae7895d5e6023ce8dfa459bd3d1dea3d067115e757f89820235e20c82fae1242e7ff371adc1d4f522ca204101b956a948753c408f284986b12117dd54d4cd8c3fed2142e636f00622c4f2b98ae3b0705c89b1cfaedf1bba49645f826eaaad3229945989c4e982988130b8b677ae790a51e2252c386f3a7cf75c0ce82ef25b0b0102c879a3452d0bf3692bdeaeaa96b271b3e7c94c562aed1f0312a0bb7ad196aaa80b4e4ea3ff29da2275d209c564e7abf1240057f036ce82e790832631f3e7a98974fcf3953de0f162d89448c6abf1b651282a53084eda019a8885bec41f2bd0a6d8975983db098b3f4075173082e0a08fcebbefcedd09268bf3be6f68a327b8bd7834ede5e744b353f5621f25edcb0f129e1b0a4ac148894a7fc0ce746026fa9403e171e05f1461c7a32d1153cdc1b9bc9d802fbaa26fd53e6066945f9216a06a22fce31bc28dc752e99d1bb0711241f25916db5c87b05f8f6e3cf825bf30be2e1c5c29570f0f5d9c586c16a750e90d1a9a7ca6ddd56dc0b8b4ae2144f1894d2582ad7862be96b44d038ae3ed1921c87e4c21359cc4dd32adc4771dc6a9bebbc002805db6b17e05e4931746c347aaf89e5979daa225415094e4cdbf8802f4239ceb38226ab888fda063bca7a6e2043c2a15579c72ecfc204e3ca7cb0e4bacd23775740953e33b0a0175c266b07f4f4563e6dbd401bdbd5f8c5a8879e5d8c532db9240184ca869f7ada761785df06eb334cb49ba66bd60a9128c5c45de4f325ba3c6a4841006297f59dec750003cb9c9f92a30021e8fa40c5dde873aae244e8001f711cd0f6c2c762574bac73f1840f58b8b0f9dfbd03f5197066d5eed1252c43338f7398612fce6d7fdf1ce8a060c09b1a488683b7c2898d8c1a149dd3f0050153a7a57b5513a8f43b1bcd34a8631082197356a6c559e09bbce29a988775e59280520bac3f7f71f4e5ae56a0e6438973ac658b43b06fbcda8095ed593a6bca8f3e10203c646a0ca5f4e63abdefd51e6da49df46cd8a7498cda6525910d3176cf627db2405f64910e9fc776df6dc5626f20a18a3b4cf0ece4c8f768f8bf08b80f3fff0b660a32d1b9344e1ee20e7c5cf7bcf62ac796729efc7054db904f8b3db02142dc7824619c0e5c18e6c124267b1bdbb2fa397214faafeb384fa86f78616929c7185e05619105bb644f6a9bf2891e4ab86b160515b3c2b39b38d5be826f92a3ca64137c9599a932b6c50c488e47d8a6c7670642aa3111f52729560576e1b55f2085e1ec583b293f1129e2cb20691ab8913fb41c78a3846229cc16d6c155660629f2e133184857369060f0827a99bcfa30f3d60e03d7478401f510047e832d1c65232d3feaf56db4057c02053a886332104f5226c9a61f6dd6211632b451efbc7e46e634e14162217169f041d66f68b3a7a3846a2159bb7d77a0f23367d7f2fac73c3c8a4f0e02d45c880ca1457fc9f11cb422da09be9416129bbcd966de630fa5e344eaaf403ef925f44154cb4e2158da5b0b152393bcd72c8098f318450e523ba8da964a8f80d29fb697bf058289dc384c2965ffc7331c3fa50a9031510ef5041ed1d8eef6ee8fef3348a324b8ccaefb5fd28de3019f1b5498c4fa6d06ea8e4beca37b88c702fbdb629752fa67f89cffdc890f6ee2910a489bb1d7849876952d8ad95e6e55747735c93c4076e666dc0b556e7ca808a9f01318156f3f25c9c0ae3b61e0c82609c64c420c22565787d95205d5268d3e40dce82c6786434d6779b3296b63589405dd7890a846d332177574f466147bd9006f9f611836c1bf76467bbfc00d79ef526c9b6a3fbf0991b80f9f55dba5c94a176221af0897fd1338042786a700451522bd0f8c91b963e409ada870ed8bb549e5e3c203b86349145e3c72ebe3895fc0594cba152c4b2e403713874a5638b2d876355898b33fdce61a988563cbd1887e8505b708767bbd1d2a3f0024505a66bc979f0155f82dbd32eee18f19ad5a81c48bc2f4bbb48f0d02b15c9afe4ca8d99dd8ab8de4d3b822d4acf9bef458423db872948121571c3051cc88ea74e2131cd221454ca555d2fb4a9cd879b512b20e94891dca2b163139728da7bee0a7554727bc5071781c7b3feec00357e7c9e7e37c000d194efe63864cb6ce1dd3a39ca902c0935d7aad111df50e9d90c88c75e31484201018b8cf3f59e2662c61cb08210c54a2a01e79451cfae7a32c63b33714e4a9acb72280656fac5636ae0460aae0a648ade258a935f1ecb0898c4a61ee8b8e6d5eab4f572989e1bf21477a899bd1afd647a122ec5896db84d914e1c4c8b27c3b6782a4af66e42a481ed836edf0b0203a2bc7c61e9ef27a92a41df61d60f54247ec2d10da57858f5dab45c4ae56c8c2e7fa48038f0a49889c27085835f8599e7c7854eeaaaf671f7452d8f407804dc08cb4ae97cdfccbd015d3b4fa24bc00f16d3ae34c7366c95b8610a74b94acc57372f97b8920eb12e87270625fa1ad0c1dac95959d738afb915f1f30593cb65808fe6ba7a6c893a91cbcfc840a1ecdc76c3533ac50451f5bb507820838346309086b70536c6b83da87f9c7c03eeb8ff801768b2a259c9ec83bbcb2cb2ea9a90caae3f4de664047c30f7363a6f8a13b89f03292e9f02bbd409b902d8ea51695a30452347610ad38c26a2f9226723aa2e604f6a8385e1548df17d19618e0bae6d586fc2c23f58d80347258a3e876507cd6301a28e79b277c42f71013f209fd0fac4449698a80477dcbe1d05375ef1dd5b22c1d580484cd3fe9d4e29a198e32307b8472c9d24b5d0208cb819a37e2d4ab51f366c5ea772cbeac2f398729db32db3af1ca306a5f3c89f1de48b22073988df9c4c6290f6334433b4e355cdcf441bbc6edcf3c2f2bd8411efb2a27e4e63a733e386d3f980911d220b5f1a8804d6c117eff272afa77703d3100ad0f4dca4699dbf41cd155d16b4ad7b6db35dd4cf46592a9e7e359cb8a18f785a04e9ced2038aee82c4d3bd414be36ab5b82197d334246294a45341cbabc01cf6ed7de81e2b70cfa58b3f4f4aca30be975b5866ccb6c72243c2ee42d48eac14445185652db1b6492f239396ef0b44fa6fbaf32e40731f7f0f162c7ea59fa0b04ae4f8f3f39e25f131593aea4379073b88012071f977cc0eb104c464f8ab8ffd95b6b8b985e75df50ae89f4928ee026bbff84232b1ddbc2bab281955476ad61954c3c67948e847a7a54bf0fdcb69fe0de66983bf8621198b6408ad6347dc1cbfcb104d1198694201f61dc1bc58f7b35acac4856ac994709601097824f83cae48e4ab788512abfebbf11bf6d4c2d1f292c5c1db302c8c9fc38e547c7934b0d8e9be39a42b9549a6cbb137867ceb05d47509a298c37253616028c94ad70151a4034a58866738bdf3650acbef02adf091b26e000a0cbc23c42d4c3bbaad39e3d629d21c35f485d29c312ea2a48d7a4634d16630ec45ef3f7451abd75348c9107aed0bf01caa0098c44a5a62db9beaaa6a1af9f688ec65b14ae1e014c35d634a399fa064fba7a3f0b726c35aa7b3e5213eb8a44f03f32feee5c77214705f0cb8994d175ecfe3b43fe6cc399f311484a0b7fdb1aee934c9abd2c4a83af84aee5b307197c9ec16b90624adeaf7bde18d4a07f9d9b5668a8062f98632ef1441249f7eae39f04341f6f61b719097f35284155fa5e6948d815f786643db2ab3ce26a2433ac52c8840c580d1ae7c7be7ca7055c987497b9e8cb60a0a8153872474c884246b7a538f91d3487bd38e4822349701baa726e6b5bc651999eed76c3623bf38604793c05c5ac7bcd643383650901e2b420131c17d00440aa09f926f8a7e66b09282b1c1c3e2880ce65af9c325668a230528dd793292fb50a9b2b360daaa0d7b0c6f7a4a9b2bcce37f1b8adaccfc9afb680fcf1efe967d2cb4e277c3cdf4c4b0b62da7c626f7ae54097a2ccd99a245a661d5f18c5a6d56e6401be667daa1cbf5613ed2963634bc271e26d64431ad8e01530229971540d932af1370bb157b7406c00570e12ad003da57bf8dc1d7266cea0d760719ed562104e2d0633c92845b324cf2befcc99ff9ff89a401400ec8a55e4cbd2ce982dcfd4011f9f54a7423e3e106b1e47a185635145652dbef43bca58a325ee410bd8b335c8ae94481f844509985b17644bde80e93d22dac9a7c43eab4befd6e75206b6090693fb15a919558a493de9ed05f6a7fa425140a11a7b9cd9b0e808500ec9ab52a63c0c479762bf47fa30637dd0f9e28539b65d173289caa80ec3acce22630949300b6fbed517187d5c3a7fa4139c29551fbf442c17e3950ac24878feb52e6158da4bd5b856dded4b29467ae38bb8b4dfcb13d4941222dfebb9f4597c5eae57afda6db221f16def931fbb300349f497eb995ddfc84695f03602905c634f5fcafcce95d5a5cdd0fe7a0417d26e3fb2fa800af58499479371111624e6ceaec75d94a4701bebf02e098e72922e163d59d6523f3547794c55ea002b70dd75d8add3d3087003aa1f9e6cc53daa896be4ec741ae796eef97365e5ba857828c049a8106270c2238cc1582fb94d61e0784c5a2cc2d5fa6fe40a5cf9b71b94f184ff9d84f3f92d7410c5202858e09a13cf843e3c35b7b656b67ab424aed4800aafdd5080e2d673c3a3ad7e3fe4e757da674f85930852e88cee4babda4e1ea6ff247d49d253881dfce96377d20fc4b6fc063402b533e9c493ef217b9a44d706b2c173ba6e8aaa9791cdc634b8f1b4abf2c67e9694a5fef59bdfd97539b8e5c74742c84b33cba8439dcc8b2bc99becd383e618fa0ac9142b664877e74d31cfa18aaa4e1d4e3bb705a5bd54a6557f9f863c7e3da720359cf7fc15ba9bbf8e7679e23043841f4fefd7c2cbf8abff3c6c41dbd82b1dda5f3739a74297929ccfbb3c34766ea2d7d4f74deb47ed1e41d6ce20be758e305102236bc362179afcd854615a22d31c9f927b669aa6a68af0ecbe57d087d50788d9365f5271a73979303d77f515f72d1190c96db594063746352db926c85ec905cae283cb0a7151e1223f8a657a8d8aaae8300b6173f5846f419492c6d601e67ab91f4c9731268747e30677b76263d079cabf11f1bcc375d21c4b541ce361f152b52bbc893e1556a069a535dc6d48bf4fcad74fc0783725fe1100db42edcba399544c16aa2b5b8c7a40851ea71ecb9e66a80b02f4c743282cf1fa965703d625bf70b12437c87ee34af55ad3adf4a7caf41deb64ccf361ac571c3ee404461be81bb096644cc110f623e2aa4ddb44cc9549a2a6360476e8c51f74912a1f267ef6d00b00b69c4701f831155544bb8f812daff1a24c96c2a3f172eaf3f627330708827ad1a60ea9e84283060a361cc2b3c1a7dbb1d0fbef5c5bb39f8afbd68ebc34b46042bbd9dff0a854dae78fd4e492833c39328cc3d7fbb08d2a5c6ad697e957ed63534bac77e1aa10af7776419e74c526928b8d6d1f5bdc29ae506ec1216b4d628c09c59e26a5d592ff0d866b0795ac414c8eb636d277ef900c2983138572a8857997c88039210b936d62a467bbdaeef2a4dd33f09e4b6ce5357a93fabaec8364d78a9997aecb1ddea7fa71758805284385bce2615d4947b5c45cf35454ff3926ce2ca2220a470e74bb1f395a1f24a3f6430b3323c7aa371dcb727121476110828ab75c2a3384a9161bb92f2bb7967e43d58a72349beb931d9b787ea5e20ca88600d3c915df2676b4b28e5a85e41a9d7ebaa9608be4400efe32be80a287f7d8623349e4699e48cbb1c8c919b4abf9c24f4fcf235dc6d476b11beeaffced5c9b818c67725578cec8ed5b359337ac5f3636b7c5d54bc83de8e20cf6a318e4351e549ff9c2dc2b63af22663bb13a1ba1a4db8bfb79b60a27522921c1d2f0fb2f073","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
