<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a613f96af65e6424a3d1b952b43e759e10249cdbd3f29a6fb8c67c909028cf3b0191c126ec66b0f91a29796d3924ae5af92ca948ea4e6b60c7a198325941774cac734fc983d2e15da664a15451cd9c2b84bac7b27578d6dcc136c0e16e771a3d1bc03de5eb08113cfd65b371500eae5f0e25d63333c86a1c1519e684843fa01bd0572d47e596f644d3f8cc4b095b120d3930b23d51816c3196db81704f9aefc0dd3757f49819528380517c8a105120fe6b51853b5d460152c3d30dacd956a0afdafa890c1bd15bec0976e1d6f1635ea64821ea5dcd3c30e21210e95888f2ff20ea743b19729e67d976f74ecab2908e391f47de7e62cddb99b7a7548842a00dbfc0bf0b408cbadd020a8f9a9305bdc046fe2badf4fbcef8d2d2e81c4e1d6b139e6d98951eb237a7c6f9c41221a04b90e7f45d459de569a3eec223d774c71083c0c0efdc1ce9a65b7b6fa51ea6ed9202367bfe378871e38534fae6afbf25a978fd861cb23bf298044a2a360128154f891096dbe6a860303bce05ee5a2d4957314dfd2f548068d1b339fa0b7b84f2d21f137c291c227a596eec7204009ba88d19b24bb345341ab0b8510bbb06c194ccd370ad6b931ef1b352c2eca1ac1aa1392d37e7f2b564a0d8a5715a63669bea38bf7a5ab3d86b93ca886e9b1e0e2300d623bbd0a4c92e5d07962d936fb670befbacd7eaae9f494d9da83116723688f26b95de1f69762a8dae9f978a34866cf0c10e5ad3e9b8fdc3e95192ee77a99a9e251dc8e313b1b9147720519ec329d504be7c8f3c10334aeee12ac73709f490ffb5c7112d54c2323fab197faa695468e20d561ec0aeafb87a10da07eab62653125f4d1b7c266f43ceaa3d2ca06829d613f83b6e14bc5b51c4fff99e57e0d487502843637f602e01b2f57ba5c34f383340b83febb835b35c356a4a295a52cf8fbe76e337c7fc1f88fc98a45de1fca6b0c88d0d2a30f88cf0b5e8fd1ec7a53c2b68d3c8f1f448b919ac61b155d10c2062205c062dfd1a3682f985e80d7cdf7432de78d1b7799bbe5ad3ba61f8cfa73218f8cd99672a85f57cd99122fe6471e839e646cd96a324b21ecbaca924d39168d9674f5012605e932d6fa1e0e709f4611ce9113712183ddc098332846ea809529d9ff05cb67909b4e12b7e783ee118e6e51ad3f48e051c147e46d21025ddb4ad46cba6bd27ee8d5e36165775fb6b51b58456cbcc5d445e16717983881b46a9957390a5c0863f87659305b183d5fd22c7b540ef8bc0ab9641a6e38c35fe910ab14f66b5326c666fac7b010cd3da72efa9202bd5039e37f4192a172e1ae2895282986ac4df62d632add00bfeb976fda5bbdfd9f7e48af60fc651e73d9f04af333ebdaa7fd5c5c4b0e006682be229c145650c7e0caa592e9322708996d2544e93da0b1c32c0d0c78ff5ab973e7568fb19bb1cda62dd1784adc0edac5899bdd14cc1a258776f379894fb36841f5ac45ae68a4771497a46e5cb61d386d4e6a13ed964eef2370d12b02364f10a7a002ab50a2c590e288c2e075a21e579d248f0b9b1fdbf545fa51b46db83bcc6ac1b77ed18ab0b6cdaeceb63effc3896ff1f8587b228049a1fa9f371b5c3444289f13719c83a4f039d9b57a2daa84467803177e2c4adcd2b8a3dfcfa3dd8532277eb5ba1cbe0c167459c36013f28f3b5a6ad11a4c2c96258c2b4c0394b05407e45814b716b56013490f86bfecaa25c0fc74fb9a6a6ca6e89c2baacaa2c778d80381c97d4df9e0a753b97df068dab6dcb8598064097807bf0bf914f703a163533d22c9ec4f3e74c85c9fc29e36a80c31d72fe736397ec4516bf560f5c8e2d331af850a862bb4d4c826b62ad985cee88c13f6bcd852a0db1863f6e850559dc5104c95d4f8d5d715ff24e5edc9d6198a8f9a66adf9cb83d51dd1d0749dd944d631a714797e53ed7fdef12bdc1ec8a7b6654c183f9b77d0f04ffbbfd5db0f86223dfa982f4d0c1ab97ed956a392e865cc2a9c3a6dbc9b9d72fa14c0dc4db95aa534b41dff42187bb2aae2c0a910bbb9c85d2f953a3c6555e18a21e0f1faaab0dcf9cb11d717f31cff4af22be75518e6a024e453c3b89d1c6935d77db9f1acf33f33ca2921a537a1058253d05c142096b6dd7cb3cebd7c7b0b05ae66b8829827994ac64b6b776c1b3e1417883f1bce49bdc32882a70ea2a166a96d0491a9716e08227cfae82b672dbc7c34cc95fa400e9301b11138dc7458582517bbe1e57c0d451b5b521a88b8f530591ade128a2bef31570cfe714c328ba2d295cfa3b651ac3db489c4d962092ddf2e38f0dffc8d7dca826c512de3ae3f96acd9383e58bfe6eab523fd4bf0f8f946e7b828ababc1f602facac91b375419f0fa0fe4071d42750737ef4a6169fc4b740782a55f8f8aba82e422d4cb257b1468d59e16832ba4775950e19b5a78356e72743072ae809f134720313fa6155a2c1b2c09103d92f605107c15b84a6fb9ddcdfd5fe123053b1aeb38cd820a0d6317bfa96e687e644647619501820351a8609b59d2ce592607272393f14b0822fc74968274eab4f3d78b9b450a74cf96803db14f645233aedd4ffa7e7ace3db113c0222001f3774e966ff92e79495f48007cd97bba2850fa832a24bb28c2200a86365c8d641874f366f8709b697e19155d71f1e91d1ddc145312d1b19faa16fa64c9a9b19095db2a678bfe59af04f45aaff10c3c07aa1f05a5b7e674e843398d9fd1c8f240fb21ae7e8c62088c78d8e1d807cdb6d8dc114f7fac5a607fae93261db261e39a7768bd17e27f556822734901e8a6165fb4f11ff8783ae46238096b9d79a9f4d10f23834410e36a553c3d2fdbee62d02189f44339e1b9d2ece7aff622cce1de02d90ca869a525f802dac25f7a8a1769bb9d641b0ff148a99b98ff9805a340db03cae3b027ff33040f4e01d81e04b4a6b8edce17bac3d3f133b130a2c9ae427d503560412f6cbd79d9b04eb7310530010b59665933687283777f90d56a7a879239a1d3bbd951c82a01ec5ec78c6e73d20b095fe9958c2c7b01d733de768e2be479eb5924d230a3ddd7576e9d95ff8c9b4f414066a59f79b547da0c6de1e6393bd4cc53d241493209deaa9572d4debf4972f72d7fb4abb7478d01202ba6451ceef6fa3b33ff170df6ff46bb4ff035bff0409d1d2e5ede1eb88afa9b7a413a35113d3dc35a26717634af06ac45862f275a81533954429f42c5ac27a1c22eb4e7e28884a2d746a20669538922cd65e94fc2a336fe3621dc99e9b749a53bd0b6c41f610dd960945ef1300e9948d4eb463da243149139c800524c4f919ddb46028f472385724a9f9925c7f8a4dab02f839b95d1edc01ff79f953ee9330c4079f054e796ce96744c6d9a418ef0cb31b2437d237739c39c1ff356466128e017f14ee692d8153492ca106d745795f722b225384a674856b8157274ca8340306dbe1ced091866164bf3309d165a412ed77c3ee24b07b097eea0ae80111a7586a82967e69bb6715197436901da8020cf444e105b8a5630d65ef492afe6382e4a065347dcbc2f304043564760c343a40846873557d1b38e89b02dc6fcaf0b6424e42d066f096387e6c26f157ceca128bd5abca9891ef17e0bd79ae3601261b1c56b103d6d3c46fad49bf8c242a104651233f7c728e662a9dd8de6e30578b7037a76db7c1fc67ae55b7bd6bf3fc610da1d8f75c40368f8d101989c624c8c685984c935494d68a0644ceea54d1b6ef5520547e0771718306adada9362c20059fb856f2b179daa0da1d33a56d1fd2534bab775cee8ffa72a9764f1a9dc08525221dcc4f1d69fc912d5126f43258c106e7f7c3650509a89ec8a74d6dd417d7aea2247f56411c5c30ebf94cef6bff03ac79044dd4f21d8af1fbd2e80c0577e9bc1dd579d983d92f0474df3d3e89ce9621a0650b1370d90c9cc2c3064a043d888b4edd3195dbd40d3662b04b68b993ae16382c0fb857438a8985b396c3158cacb9bd4f6a18f260b90b7c418cbf5ead531a99199957c26d55d05522c328f4de489ceb8aa84fffc853e1b216038785303da256dd70571a210edc668167f46a68d0c7a4d2d3a0929909198e80925ce23a9b75576f11746d205f514d7b8c906ba8d0e5dd6bd30486e3bde0601e348d9285c40ec54e75360fe51c7468d087d60de20110d188477bd0b0f02de71d7b8399bb1dbe7f154af51e96278c4ae3facd14b4bb181fea8a76af763f7bc8c6ed1ffff3a57a247e35b39949220016c17cd4133d42ef4ec426531f03f0cdb5fae407bb21d7afb51cbc09899f205f0826cebc44ae39cca7b41f9d7c5ccf33300f5c9c48679f6bce09fd788c19bc639af2c5bb46e28a004b9bedaf847554c75f6854331c4660a532770edf3a57fa20fa0a93c4f006b13ebe0708296446ccda4b3b351b4cb5d3c62e884a8702938a1d4e9626858b10b64c15cd724c91dc6541d6c34df59ecb3a52c884fc0e34cca7f07f734f13fe9ce6358d87369ac20d832f2f5e9b485649f39198dc8902856133d1340cb882a557a02224932286c99d2d74b7d10f6cd1c417e699f11c1cbab590eb5d712346e7ff41cec87f5a5b548ca53fd16eeca9bbe4339ea2ad545e7f092f5967b53732112f7beb987b0d92caba9bb60b0c92f3ec636f1b692904f4c66c2948809b471c62837266cd1513473e90e9244003d15aeec14ad77279af129dc95fe451e83d7a98cd3c0fc21b31711a38bec15845e27198491ca5fb0f602d807c6136ed92fe2bb9796f1ac0d6489143186fa89197124114c37a938711adcf6fd30d2848425b507053c863a9c82d5f0cba0ee644901231e6942f199b2a881108ff18da7726835b05970257a36810d2fa2cb425c7ea4df792b2867aa42bea1bf8fc7cc06fbf9b99c0bb67ebb48addac588170d9c5b39023d021f4f0e162db92f1d2116c9bcb65395a4d45b32e4231b2ff0e8d3da55bb4fab7bda93b82edfaa45ebda2ddc8cc083ce7a8e383917653bb4a301bd6bf8de41677385e667ff88560af00709b67ffd90adef806b28085db59b55c154c390775107edbfeba54a85c606666ca9864f00c07835df2fdd2225030b03d9dcbfe7eca9d382410dd68193f8a9ff3c6b4a22cfd525a199dd8d53d46608eb8ffe573ace28937b2c16d530b228e77f362e08aa6c178d916c2d7bb47e70b55fe12e2f49fb65431f1e4102d59b998cab59bfe0b42d0bee2f128a07b4b8fbfa594cfd6d3e99eea4cba6d57d4be02e6725a645ee22d8909dd1711594eef88e91d99d8f6ff0c4424f5db1e8acb004a0f6f8c604c451e3ba1deaca7478e85451aff0d62f6315d6d749cf3fddae356bb31464389413c0d58a3c97b5fb29d8d18585c75094b0dca5d60380e175f8d841e7f80859f461268fa47441aca4282c636debef0e21616936563764ab5feaa6863709a172d58dbb8104babebcf49ec8133396332fa9409d6d982aabc867fce3b2e263e357a96bdf397fab1f2e8d463a659727b679a84afac3dbe91bfe22f8473833e2ffdc0ddbb1d35aa9659581be1424b73a5b38c7ad113f9e24d0064c83b20b143dd73bb458fa27c937a60341bee5c132f727540a6b8ed80c65e9fa618e8ddb915fb13701dcb334981546743e57663ebd2937dbacfbe9b19a320385b5f360541334982edaba229b07de9bcc2f674ea7b0befc013f6595689bc728671e91d53960c6b2d4f2b5f78353355a506c22a8e8a8f5629b8426aec325590baac780bc83db8cfa6e00d899c59ad60f0d3a1f69e87d3e2e76631ff089309a25c1d9a58f679aaa7deeb99cd018e28cf1a225ea31e9f74e527db94dd6002e42fef2d57714a87ddcc5db4eb2ced19402f82336ba5d2f1fefcba8850c1f39e66d7e99427171a2e0898858bb1a9223a1835d92931a8d8cc66347d5fb8d0f348f219cac08156ee42427a92eeccb96d3215e52d968e49ed0d0f7c1d4397738721e21b28d1f0e25a61321370092474fbd743285fb0eec1a9c835154c38aa7f3c6c3f139fe720c14f2ab21606e109a64b42654b07e495fad44179f298ec0088c8be5a3eac00c9a9feaffd97869e67b404fd37f9a290435c7852e4d0ed0333145a2fd8e5a7888edd1e588f3e405d895e336e41071a9e7880166d834638784d6bdd361a3b9c291167a2d1fcd9113b5836da01c0118ab571dc0839b0783d6cad6b7e00113128ec4b570045d1e9720e25231faa9261971e2c425cb978f5105d3abbe5812f773f2630b1b492fad3bb9612ce15037e1e6d289827f1356c0c15948ba86331fc306318f41a8d39eb70761fd6908e6720b2f0fb4e3c12653b4f46655cde244dd0a020526aa51d860f9d424c98d5432cd58f8a2971215b8fe3bbf3fa57c47b304f40216ccd47b0bfbed9778a0f774d4e72f5fc948315a58ad6c298ffabc25acadeb6f24477f9541a2eb0aed6adde3c912ceab0fd42b46579cb4cf34b9bc166bd1c79de8bc3546cd652daa3f5a81490992ec2891d41ee993d0ea7688624e8683a7df602f8a2db27d9e6ddb26c4faea08b6a5c59bb6db9bee041b3fa87e1d191fac973f0153081f0feee148e86a29b28cacfeed6cd789c26a5921cc6c01c0f94f6b61b4ff338a4f2f320af880dd2e3afa41b36fa651f6024a3a6704f8578262e2e045a4d939c80608225df05ede50b3fd8abc525ac8351b7861779b4042b8ade02605a042cf23a98dfe42b83e0f808e85441c334051eb8dd4520ccc9d2f28c7fd680c7c8e94f5808a09a270796e7eb1427a75aa78ba00e35b0bc637dd5c30ff9bdfb2469570f6e5bb55717489bb843acaaa48c8b53be07bbc4ab70c0008e91a9c0fe6d2c8471847e0a57a53b379b7c06b977efa44b553efe7d599826fff3d89ec006dd087bca3dab8eacecdac1a37a9c41c765d808b3a99ad740eecad75aa0ad723b60068dce8b183a09452f601dc1d5c6b1a21983a74636b4f144e6848cef55a4772c504bfbe6fe86fd29f2d475a9a7a1eed2c1aeca0b3259527c4421a961b044296183f6357bca077267a5b5d2d479b7872879526ed245b2f88835c9f45cea76aa849ec1b67d73e89ba81bb514208031c37b7a9f2db3a5f0cb06d142cfda5530ae5acd8293e75c7a4c6062be3ef16800a8f9ea745a4c703d9c9749d5654bfdac19e4affc6a5d0bd2ae6d79b96bcd51bade7b47bf730734348c26e2ecea17927c58a6d21bf3168321084c4d00c8dd34ecc59e87a7ef2b942989d561f462be15218546257aeba9dc0999c4cea9ca85d729d8df61a2e396ffb5c1a6ac79c4c4f4efec1c9b96b765b063c2ae628e5456aa41cc92fd5875829e5d905aa1344a126c89b348468552d4a48cd55443a3cb9642a935c852616c7c391f6fcda205bbf87794c6c2e5adc831ee72e5c10ce70d2af5e04d0395d6c692f2d94b0946366d3de43fb19ca0a1ac34ff5bba3e95ba86626de6d4a3e3917b07b172d27cb61fa862ca7f6e3311c3c3373da84f954502a8e340a8026ba1d8f0fd7f9ca03183606f9e08e451d570a55bc28531e0d5300960d240115a2a50d1a276f3f1e47dd40d043e27b0c8aae91b227e6ab6fa7cd51e6f66d1eed66881dfc9deb87de6a9f739f8016c6f44e8ddfb572650f10eb6f8289b345c9cfb06f478cbd91ba28071b7264de3f530796bbf19868ec86a187cbfdd16730b0e6b625289c267971611cf73757811afe7ac219a261552ed32da021bd520ea0f9c9f82d992af7786771c8979fd30d63233cab385ddf03606022c7cd5df475762f57934c7edd6ea68599fd22cd9c39e2f6debf38648309143a4d73345ec1418f5e3f687cf6de82328c80828b8ab1d5318b1e2225f66e0037f49f25530a7ffb97b3030f1a25deddb5240b8799888cb28c037a1f52d21089c3d86310f8e3db11f52387e13b89a08efa11ca3e4fba16155233963019d13fde2f7d1ac21ba30ee67638b538a589a9be1b1dd20312a62de586adfc55d30cec791bf1e925ab25fac91023340aafcf483b97bfd5cfe7781cb50750bf3b4e3dce4f08564affa2264ae515e547acaf6dc28a1e604cec035d8a60c64b841863b04e980b8fdd2af1a6145ce42f7a693e7dd6b3026366eb77384baa327c7e2f7a91f57f609e1e94ca88b750ab1f9a45c57bc8ad5176b64afdaaccf144513675131d7692092bf3d154ae16b4264e749a1a06fc6f8e23164989e7753919c6d727c62faa5dcf42acc0a918b2af1f5137cebe81fe81dec31b3b7c74c333fb5eec5d64af131de32932be48784eed00bb20fd4f3db90008cd198796b25c137fd634a6442ae059db1e91a368cdb698e0b3f4f467a008b9e2dae9ce5b5acb4379eeba5dae24e1f3caa2874cec73e1a70352f76754e5d6c4ec4ca748dac78370613b606c33c6f8d4a620c93c68513d29f5c16533056519d4fe29139714212b5dd4eea42785af04d269d981c62215e31b8013edb45ab69cfad6bcc3dd1e5b284f41b8a837e9729f8a9ad6a8f014efd73d114c0b1fbebd2b105857ae101346ffebbb58202d84c050b41dc6d3ddd835c3eafcb8da4264c8f402a34ba2caec7cdc90856eaa981e2ac196a46706b80b56b642e3dccba23f65a87dc227003f138f77204f42cea20d01f3a69986ec8be125c6d0f1e75bc33e1b0d0b71d51619a1896a49bd15e8e2b8cb5d2c282917c5962e6cb2d08fcde0a9b315f17472d691eb7ddd569a659cb57044f5576fa1009afec6594554af1019c6864f8d32a4a8c61939845278590a96e259cbf9d7c359dfe88345e07b60e049ff9a317f060c109f5906ca6fc29d14801f1b3b6ab4db5e6b2cc9a2fc55586cd1e01217be7e0b539376bb4b31a054aa4a371e4cc4d89e5e95bb2c7fa5d117d7198e6f727d9a64b4c231e756c2ebfb5a8a1ba6f5e14e8fd82028047057ccd9d112533319409ec2cb7060868cfb0860d28a8b8ad83e00d8832bdf357a149661d138472e2ba536b48950d42a41884acf517ac21293c124115171d5e7187b3c729456d89681e6a1cf747da60526339bab23386119d684c480142f5989a4ea92d3e689e422c92e02c50802505aabcda8cef041f1d5ac98eb875e0a974438cab394f355e0062f292b1d1ca95a2a64d2e61927f2ac83f209cbc58b44a1e591d9e6ee08cef1f531d3ba9068f15e451cab4d4f6d098ec9e0f068e61152b0b2a0343d7d7befac915ea770ea3dced4a22f382de30664363ecba94eabeed765497f72247e93c557cf00d3d8ffee4eedb5c96adcd9c89638655cf311f7d47426b7ea4176be5c78e47cd4dc464d97388529600327ba415b7fd00b188082bbeac71c0eb5304f15292a3960916d911710e77999ececa4e305acb8466a61d2862a2277c7425b82db82666b00ed88c5027ce8654d46591f1958bacf171a11cb6adefe23b5238e3b97ddb5c5e887f2e7819d175dca2827bca9626a8d654b81e690840e03c38db405d0cecb5c4b590b288ec5efc3a329ea0d3c234b279956e7b0a8b4ab73d4456256bfe01a17371a664910b4015847bf66b933660931adbc60c52c50abe04584e9e8ccd82fc2d25fab94ad27eb6b6e7e400995bde19f08053491ba2444f107dad6ebc4aabca960d74183f38468bf35d2ce9a51c580c8856a6f89c90554da486e33f8c00d48cbb252b5674274a2057a6f4c153165548c596f6c371df545508eb85863772e8d679425e91ab70515cfd60ab5a2e8cf8d7af07fd5cae66e6f440e128122979287c9268753b7a7779fe757a8f81d755aff487367d7f602170fb9da06aa51220826c5ba6e7fd0161c3f1e3fd45ba8cf9ea979df25bf6ceefb53cf52122020a374c5c212fdba18c0a845c49a07dabe8b3096264924a1357b233ad1c7409f4d2b89fa764f64c176186c6eb1907e17361c99ca201072924335fd55f42e2e30cddf1fcae68f4ba57154a2b0f3722a5c54c6786e687c8a393471468f10be24d766b8732456f36ef1ac3ba54f11a870c0159a8b05c199afcbf868a0ae9d4eb3f9b30133dc6611c14ba6da296a43a6603429901f2dd715926f42069238e1560910326dea30ef2f4189934baa766774b98946554255e1dd79b0843ad2357898bb3e83b5c9dc79778257bc3229f183c2d9a8a4387ad71b0a527feb861e0f8a647cb03fa621f21af0e49f23465a2bd631ad11e092c431cacd41405ca55dcc22d200a6ce8393861682fc81f997f9c9c157aaf9ea02d48a1519a98491e785cf69417698fda4bdce46f6328215a96007e73ed52c14a8f8f2434d5892cb9ba9e1b860c8fac454d12e39772e6ad5c0d9272b9ac9e263d5cb60c305d2a231c795912428f299df34e1b0a5b1704f0a7b55c9eefd7350f80f2362c033a463be42449a9f01d540e2791fda060f8f20693aaa3af2d11f065c789697ebaa28038e40b8dc8bb528500fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
