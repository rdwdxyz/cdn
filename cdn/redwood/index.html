<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5a7badafb80b8a5bedd9edc4cc04dc7ae6f4271eebee0f5d7c8191aad665109e33159722851b80ea0d686f4dbf6638c119a65e5acd97eeff9a6e7d4e858457cb5335b2802afec21eed0df0d2c02fe2e199940e9e055260eb331e389e85b8d5d7bcc6b3c839ab2216d7f82bbf133b3878e0ffedc14bfa05d635add59f79342336fe5c8cfa7fb4d4b70cb02f74acaaf924e41bba4e1fba7624449fe670fa78557747177272c24d2801ab832a2ca229dd1fd63541880a28b954b9692abc8ac40842b4720496a79481a7ca2468577b6ff51840354470c0335eb96fca2636e4a6476a12223f23a86130da42f6aec282691303f6fa8a7de3ec0d904ecba6c4324809e0f07e9c562b3b1cff35627c0f635809fb762c2e2380a63309f3e431626924e813f018197c504632fe85544d41c676b375ef917b2131560c486e3716fe1dae98a97dca9064dd9d15ab1a6749e1f68c48516996140953d0e7e02f774a3bf1da30c4d190457d7967d69962ac581f17cced6a2a13182910fea8a4ebb3703a45a16dd95a4abbb583a7c3cdca7a7f910b389802a57095a5bcfd12eb0079b17f4be9c6193a1d67707ffe4059ee9b8c56079911d4f4707d736a24abe53b0cbb732aebec06d61a91cf2263390fafe2c1fbbe217af6484efc34b051c53865719a1ca29b260f5c5dd1d92500d93c87064a7c3a71545fa55188f089d75930f82d34dced52a424bb23025a5db38e29254ab25f477153bece78347c9348503dfc38609aabe218a9f6e1082d399826106142291ef7636e0fe074ea2f957cd6991c2efcc554103a64e04b93396e8417a1ee830414c55e2391acc69a84b23f9d25ee9d8ddfe3e09c86f4fc39083aae7069768861b8a9dfb2d4d4ac6ddde256afe1e2091bb10c9c8b94656c7d6374d86e47b9b30ffa7db4201743110cd8256e3323153686bd97883fd0f03045cfd4edd6be0de4da3f62fd26a0916cd418d463ff19e6e28257a0ce4de6d6b076e0be461e0b8644484df622a6cd0074430cb70fc9148a5e1767ce8ae0f633db6526b22922732e8c84c4a02756e466f1807823f05962d5e3e0a81173244e497e08a3c7a450e21c1d7dc358a27c11552cf0b27c2273d96c0f2f6591a183d24783365c1034d94ca76d0bdc0f5242990b1b42857fdefeee1b41698bfb98391a9152cb464587c869398d3d112600970df3b6bc11b9a40ea1a29f6f00d33ee6461cbcbcf1a79b574418ae52da97b4724d706ad0ec9451217ee1e8c7fdf98e3b114a6070f516e27a3f14339652fd6a20dc18e08ff426f5047ac2539938a498aecfd4151bb8352234b74fe3e2f93e4418114467197c725e3dbb1f4604d6ea38f47b125cb2db32cc6d6e25befff369b2d22d07809f72bd744fa81e4e4fa94c9193bcff1820954028b520b4b72466719dd94e0ae162751bfe98ccc1989017eec92609a6aade43354320a41df38d6398bb74ae6d44bd698b861efbf091b0fced35048405f07a3ae27d0a06f5f0e81a217f5358df7bde8529d5573a9f12956eff7ef83419502e7b7eca4d270d1ecdc0bbd7c0144f3ccac6130bcb403aaca2fe98b392411a8f90ef57e81924d8c3c290f542483466e5825046f31e502f5cb90ea8814ac2903153d896723edc4160157cfa41f312a0b1b0ec003505ec35aa4ab371b9f1fc8f23dbfbd2000c44c4104a1a1e5e5220f63333f4c6c08e3baa1f507c52cb99ee6d05acd8fb4cd1dceb340b83a66d4edb1d9133664599c65df42b515a6ea3e734037c0b963f903339ea1bac863411f365bc7d75ca3698c350bac9f2c1ba9657d7f52c83b0e41c730a7c1a39278cec72723214991e40ed502c9c02eccdf372d063b11966083ee4b409f773a7ced6d1e7dc4228ca730b370bc04dac1be0fd8e4636cec39ae1e857b08424756cc814a4d7820ec409cc7c78acb48ae20dc44bb9c4cba7997e5b04d3eb3c5181d83df9bf2e49055cf38185c3e9080fcbe2ad9f06f21f7e7de91defbfd5eadb65406a8d97bac4761bb6d9585356762c7a68a6d24d1b023fd6f80e34073deddfb42f6cce1b01f270e38226669590895aefc49300aa57f88bebf5766c6c66236952d407149cc073c37df326d9d671c31beb4b32ee1d7f20b70de88c0c0bc680d68313c86c3b91e0721df6f693db3847fca1a8c48a9e2bfce7bc9cf7f07bcd8459ce5304a54552b148916ff238b2ea77c14b75861a1640996694e49de868032062f3aad6502f22e66d12c8087f757b5784a2854ddf9ef4d3f7c5c5b1b575a4cbbae1f036cdf0f39998bcbbb342e63d067913edf06461ceaff92e0adb4c847306a00503bb386d7f1cc0e9b8a0673f89d0e54b7e45f590aacc23b20ab88b59f7b2bbabb7a529aeb0796fb32805f796e8d563c02e851de50f14b9e909ce4c6165d52f66c9b76f1c111a25e735156b825db4b7ef778bb13c418027bef6b6bf02856047712195753bebd9956481c50b41c525dc05d8287422db7ead9ad470a27230eac4dc883d34f33acbef5ad2fb943fc8f8042d5443cbcce5c9b366c7ae025a590e21ae5adcfb47a694e099d077248262e334be1810a1bc9ed849c67d0c86b2234cc288dfc1f04094b4d4cbd2afeab9fc75a8206c1474cb7bf954d6db8226052e6278fc6cd2f4bac01635c4775f383be8660939f878672cba5f6d2e7737a69bc777ddede67bd196df40754f4b2788283273abd35451c2f6c9ba09d0eda3a38f4afe51c9bed07f9ccc6e8d6097f841e07868961ec5168f0a8781b8e50d5951e7b3880d7f011184939b469e05c125dcf38072005d06dd2ff78572cee4971fda4cff7ad0a0edd2c6a26178c1901aa806eecc6e4626081740587289c6c2082be82c5c83c843b2f30f9609d9cd79bdaec489b06830fea4c0a67aad8ab8c48b620721895fe592708a44f2debf859275b903fd59cd78b2299b09cad4427caaf2b2ea7e56a99ec0fd42c7c6b4cf324aca9f287e9f79fa2def0e28a9693cb8b6f434f5c0db33dac615d6ee63af62a5ee7a20197cfbd1b472aadeb347c27e055d92a77da476890135230af6ce68cb05254099f9c91cc96bd23d9402760d581ae270ae9f67c6746a36a2320f9837b6e430bdf0cf6461a26ad4ca8efcb754dc56546ba76a55c80f8744c9c9190831b7990a9598190cfe21b4b03be140b95a4c6599b00518da0282b9b9038bf9b309b2a57c556643e3ae2ced95b2afd660700cff8bd360107a7790cc2e76bb4a84f0f004fbd7fdfc1d67954669b812f18bff1a11a8bffb006d273db2a727d78a22123eb42f19673966d5a6a6f668f3c11c36b9cf47ee67cc3a77210013c6b89ab85e3681441b200e1e4b163816e7066d3a68bc86d9dae6238871719734baabae990c7f48586eb79448c74142479d550aa184dcfc44b9ce0a40954623354f3ed346e4f866feecaa5caee727c3bb7b3d0d07a058b06d106796d31bdfdfbc7ba99aef9a50a40025f6f400f492a6ec10f7cc9d8efcdc231d3483b346a481e1896ead3e9b512dbbf6240069538bfee6152439f8189ba6da0b4d51122433230a7876d3827fd21ca8b57185db5bb750e7e7e75dd6c8bfcaec2ca60ee988737f470d39422b7cc88ddbe38fc472f652fede13796f6ddddf00317210838c3359a2a96ea7c9d7bfd065f40c1ff3a4c228e3a29da9799d22d3559c4e4050c88a7c35411d7a1a4e45f3996c4887756f3d6cf498aa99eda9721aff250d37f8189cec77f3f5812ad6192af1c750a961c532337fe42f00c90afc653cf8368d264d0a2ac253ecb9ea44e3770aea426b50e4ee9582bc487208ad034d4676b324adc98882f10d8d87265a431c8da11c5d285c1d79d3fae25a09fd5fa27f5167e6357cd53d7fa2d08cf22c817b7e1a047873310d37dd6745d0dc042f9785d58daec44f6fd427a3301b045e82137ac7d6e96891a4eaf678c9319ba7d0056ee1d559b29b7257f14274412c1ee5ea4062985061a7b9f8f60383b64c745f901749894a2a75d7b988a0b817a79aa71077974f1a6a05bb6f48e10f771751dd332d7ad7ac7d8f6069477a164f790cf94b4c90555fcba3312d0e6226cc74bbb8b17340c3e26e25546d17063e2c819d14218b237db3aaa48315e141e6739c1a1b28d5fa62b38ed2e8a867ca52106ee96dad8f940ee2f5ee036d2a2db6125537e92dae0d3746f3c814bc52a6369ed835ba0d5f6177ee6c8913a27d93a80d0417338d070c46b95daff6c357a3280dc4fb992996deefc5504e0e022936dd8532357cda71ea1a4822c54ea72da41b7acff3883fef75d3a2508930d31f23dd809779861b0eaa9d7df42b6aca2d2d196173b761ab50a59f49f183769adb6c5cffee06cb0338ace85ccc9ad34d741fc7fdf4415fdb1be6d75e0818ad55398dea6f3af5815c14bb68261cc57f88620b55918d6c94130ecba4519f037d130d736149ea8bad283d32feab4f2795c8c71ba75fc85af0cbf7147b8f2088382c52352aeec4491d291aea31ca026e884ee171d32c0ec07b815f723d099c9a0c3818f95a21e1ab9904feabeddf3ce715230238235f24920a5ce3d0386d5451a959e8c6d52a9a498e4b4197a01faa1114262a8b53147492bf151916f63404c4a26deedfa9e3f8294bb9b308d3dccd47a4ed4075d6c15f770bdfa95713f544244e7767a2ae6151d506ede1315d2914e5263fd40e2ae2e0755fcd3016d444de9c59f1634c64605b483bcfcac34af0f144521b6fe6c97e1b7b872e4b86f56bde1706e211b2e4ef72e2a6b053538d87bac94257ea4780aaf8cc2ff96931a27e673b9f9cb3f6e77d1b3ccaf223cd4fdb240afcedfec439f598a456f019a336ccb0c74c77f689507f49bc04df13fc0d18630108d1ff8fa0f63b35eb3c24946e970bddf8ea5d6f8543cc8a3da9fccd52c68785e0589c16867c24d84b72301953ef46ebaaff8b8fa1d982fd1da85e5256fdcb11deb0188dde837952d3e2de80a42f9e5535d81efed719365cdd3bd7b5d4645f849696c181fdb6e8f3925a64b19244b244c0413f0249b12852b964188e22ec034460ba2a728002bcfb1ceeaa24f21d88d237e69b7439cb5817639f2c1166eaec170364937c1b2e6a71fa67b9b6c4da35181e92e59d6e06f2ec153f5cc721fec052a00c5be44f456336a52b6bfd6d6c74d9bd53a944c3f9606ac5c8d7ff74043362fedd402f474882c677cb2c6ba581c8b2f09552a789c7f06e53a0d3ed468574ed098e52905c22e0377954a5a109e230a1c700c3b32b9d6791993f36f526da7762a7c92271b7ffaee6784fd50ad83ac241a409eb640b6f2dd5a0014667684dec63f4f921a9aed79b943645954c529db8f5af0f68ea29dfdb4135802bcacaf4d6d0de98906f76afcee1f471f251e94c1c486ed602c8837104478f82791d7ad401c245580b267c288c9bc120d8acf35cf374c80365714e995ea5f1c687d107312ca32dec595488a31b7f4d4351db0aa839e998fe9fe0ef6a7a18ec5d77ec7e127c0ddab85264f9efb6fca5e380436bc9ae6a5217bf22c46dfa26b728ceb5f30ed134cc81d3999e3cff0cab27e303d9b36ef9c38f9613724945f706f5e9790fb77c66b4687dbc5d97004abb6267fada2fcf5663286ffa4ab58f1fa560c3e1ead1ce457561ef2768c877f6279df0b2e1eada9df92cd16411c2cf84de809cb975903da953bd18d18d5bd0ad659ee143c0ca935f8632531b15e4b727efab620fab8e642ae6dce8e1e7022b3b4c5ce39b663f8c73db6e83edd9d49f2216eb8a6dcdc89a51a5805a45f6769a179344fb96c3c3ac41128dde98efa34d3ce8c4218873ccf615f01bdaa328eacba31e87708619799d1f6bc29597bcce03545092327172d10c115d24e3aadd08cd1da208521878ab777ba6254fbcdd5de374aed1d01ba1b3fb17ad18cf48e345194aa31d8d69acef013e69b4c5c04490a2145aab9070e2597feaa490dc1ffd44c4be46fe8ebcc743da76e3155bfd3af910f3ece1d7aa3ba84e969e0bfbb46c3af18eec194c895abbb05803a2b440907a2d4f9ad540e979d3336d526353a9cdd035420958a58e43ab1b4ec8798ba6877cbf731f9361fec8a9b1e0907a4fd0b4cc20d643d7b714feb869fa36c6077db834543ce84c7acc7dc3a214ed55cbffbb8ecf9a042ff147cfb6622073ff0ee6f160538b3224458b037f43a2bf1154866500c4d9ee6611444ae0476e84d1a1e11a170f6bca698d724a57887a222ebae17120de26c660442f9a473b0184c03ab86f0d2a0c393bb2dc4fc18cff9a53d1dbdecbae899eca2b620d6d7246f2fdbeaefc68e3fe8d0b8b8065949522e0de25201d236eb8cbf31f84d7c5b8c3a3a52d06a8bed4b137a193f6571b404b6033504ddd6a1dd41bab0772c85e0b8d20eb149cbffeaf6f2f272c004989494ef8bc796cca1ca20be93f6db6e363bb1f599f83278b00663bde89979bd46fc97d33cccb90865b160cf20e806ff4b97138a6b77f810a9e5c1714ff039b48fd1ff7b2adee4f54158174fdcf23d655b4ae116c90bc90056a41c8d9c967fedf4788890315d2cc4ec968818d47f168829d8a3613447325f81407efa04beca45f4bb15e6f76e33ec35749fdb3523b4e8078eb7384c2eb0c56fb2818bbaf21b50a0246145a99eea2f27a5a0ec62ba86d7601f6bc583873ebe1896d0be83b72edcfeaae166fe790b34ab367a55aec44181795a5dcb334ca647e914aba7b774a190e79ddc0e5df6b42217b16fc3ab31b3aa318c195c9bd1ebdbfdd797334ceb1e27c4b9e5cb3629dfbd2d2dc3bb9f8fbdba8b672bc4959401141434026308cef2afb714565fa51ef3b52dc085a4bd0539927e50e7fb448b3b0de254e6a6c20fa9e41b4cc57b1f4b554d7935a95b2762934d1a5b01ae8cdb01ea0872e244be185476d341d2d9d9ecfedb6bbbf73cca4f9aee4afab22cd468441fed145d6ae3997a502c0c180848ed81d70f97052b13a989452adf533b0fb9e1e129ceff3cd269303e18182230d50a372cf63b9ea97cfeb5a010ed0402d9aabf6d61024fcd5c86bb0937d425ef36b5125ef58b6426b74e4e3375a0dd178ff027938042400629f69d41c5e722cf2a445f19f646bd8df8f95c5033fb4e4b1e1408b32c87664f3284f46d1cd6ab41e8fe9a43c8e46b1d52d0ca5da2a31173ce745d83aef75ad538cbb19f8172691372b5f2959b002e15b77b5b275399a02dda5575a02e4b630565ed1732e3cbc8944a7bd200837a209118af3ee6bf486a59a3dffda04b4b3219b0c885f4a8dc8b2a8df39d2a30c2d5a067975e8f339da2442818b9a2b2d270ffa8be4bfb0c30a6260b0f2ad61b2a38813529616c953e1e5f36fd3c565b1441be1e482e6000d864c301f61a18eaf5596ecf5e79c4ee6ab978c9cd50c7a7714542c456493e92c15a3ee954c82dc6d1177e63f68676c3866ad5fdd62213043da64eb427583c361b181f1d339cf991f0b67cd34e4d5e60bdd5e7da1d9766c674a41db8a3e90c90f770e4cecc2b08665684aea1c44759d15dbc72396fdb6b92e459e4841dd1adbf76bd48233bb7c11923648e2e0f1c6e0e0ba97a7de76b94931c7397aac4de0e3456dbbfde340b35bb59deb8a8010979daf27d4e0aadb9447312cdc7083a47e8805399754eb4047b1859fc10ab0381ab3380b73a0d8e4cf817eb842a1b57cbe64b73064077bf7219eef55876d1b73aa3954bda6c2055fd0b5cdea6ee96eaf6c842bcd005276d56aab4c5c36f63b2d884d472bc446acc612199f873388482de48058f2c5b332d2be86f124a159a4161f022d9fb8cd791a694428e6e50d15717fe26670f749dd003711bb46cb92a587e77d86a2f28415178cef8f4cc88ea2a5e73b5762e65e774de7a8637cc78cfa5559655eed5f732042141230dc1fdd1b4a3d7498d3c2b52097c22078d0366df07d57872e9ebde103a39745968d54422b03ee2194fefd5d0da09a19358e74e1df09a350fcbe784ca582f9086b8a1c5997f15a7d293d07316880f74b9ba3170f7d952b25116ccac115fbcb46da43cee2c6b87ef996614a223a3b99d1176be96ba9b0bca9d9a40a1a8320176ad2a6e7b81e4b3140af79c9a4859da7c11f16f4999843009b2a0755b4e2f874ba8bee2a712c55a5a84e723d1a2eec2b5b03d3cdf52c85fd1c9463b41ef9bfd49d028258b39b34cebf8e6313dede3bbdf286d6c75e7cd255de74f67f51e96dca7f6a4b04010b36067c27cda5143b9d3b835a488b58098b4cd0b7fd36d3842d67957074d607dd9fea90aaa0e49f29ee95539750e8f56fbaf578716c462493538340b9545429f4b566313b58369e56ad8959363fb3cd91c67e55dd1cdae3d6846d3906f21f146d8bc9bd84ca51930ae653fc28000f5bfe18f7036a556e052c2b4a0b88ed31172a81bb1796d8feaf8d903762a3a0ba053bad7c536a087e4eacd040570a5d4bb9b6b17075717bcf1d775f6ebb09c79a611c340d8cfed1aa04ec0ac975ce574520bb67efcafcf48fb42ab01f04bf9abeaf62012907e9f9764ee8480d9dc3b568ebc2dbe19879ad05696f87cb0958f0d564097d5081d7ee1d39acbd3effae59e85f8c2aae8990baa6466c55c89b58349d17a98c48b815a42867c57c4c02e2ccd7296f7a4da7f9b96ae7289c97deaa7868e650cf97453b0713108b84cf18a749eff60d3895ac969dff62144fdfadd32300b1a326628a11fc4c3f81383557440f18c2cadcc6bff4b587a0a3c4757365b706f7f5f6ce7acc7599031982bb36985a0f96d716fd05831e78c68c01c5bf4a3dd525529d31ecc48e06fd33850ea2c2973d670859e2df4fbee70b09b54f25c641774f46c084735f8eb9a1a54306049cda2c41d4fc98d1315df35353635011ae482644184815974e0c2369272a0b78689a6eba697d2dba77c0236b7b46c96862d1954ae1266d7a6c3e15be8d604a5c3d98733c6540065f6ded0bf2935f38950771a8516f380d46dbf200d8495e6e11375624e1409b9a2f57dccea94422b7f879f30b4cd0dc48d311c9a7d99d2f1f22101ece610461bd3b607d2390c65e34103f64f5d7ebcc78ac8d3eca164c1a5d53da70f9512c9c8473baa8e14e4a78058f9a877d450c12115ca9d87fd43b68e6b6c92327f44edff0af61f3ea11bbb1df5749616576af08213116935e101263c1975710bbe51dfcd9b214c31b4684de2426352eb209b4f5c182f44c775389c9e34e5da2730672b3e44e7622a33a4a5130884d9dd69d6245bb73ec1cbabfbe0a61b11998edb0023b03bc46b76070ce41860a1418ca1c282b9e8d30bf3c2eb014619b51e605a361be07cd08c1948ab89b40f37225a1cc9d229a62d08f29c4ba6a4ca92ee2ce83b0d080966bf1485de3ef21d2483242da63d690e0d20771a637753b74fbd1b41cc5b5057d31df55eca3b99b0a800a6e04fa67b59adbc4370f5844b253498255282dd9bd418a10f38fc56efa8a924b15cb25159d43349c29e7dfad973be59482bf71bfced80dd9ee85fd7c7558f7ac1d991352e1024546964c162bc7a2c1bf2007ff918b2eff6c729f1d5522911f4aafea37d42a2c08c530f8647a9f251889f16b75157d3e274cb4d8ff8e497e82d7a49e3a95d12139650d33b8d93fd615584cea31195c2974798ab29315a332987e85ba2a06cc7ad06ebd20d4d5a5abb36af70cf0d47af290f5f7cae87d1567c481ac4c76f4488b40df4ee48bfafb6b66a1634c6cfc55a07b772fc22da76b6c6db6d23e618c97ae381bd78200d3e399acfd47940c7e2b7912af028badd37090921fe569f7a509b9f75715bd252a780992f669ce4214a53298ec99efba9b90e9e8d90a06e911fdbeb5bec0fdbe6ac247737c1a9f517b8e65fe9cb5531bef576ccfb08e07aa39101aec044a4ecd48c2705a8d3fd9c8ee1f7b28799d5d6654d09d39d0e2bce2a00049dee9725d03cdcd5d822d178ce440ac9c1cd344feaa900e4d9357d86be49e7b32c56d69ca35dc166845f6ca0fe3c59585790edfcc885c9967556f8e1d99db777b39eb12245cb82d6a5c5cef222fe67f58b6a69417b102cde87dcaaaac3503ec4c261c81157493a2b61e93937dbe13a38e4c08a862313c4c65029864c3330fe2859381f58d43fc7b8f72fc3ced50af74a80c5c492ba94e398a1321e4e3dc8941e7a038a159af99c208325f2317fe318b0597721df2cc32f74e1f9677d5e59aebe9d18b4b0100f6bb60a4a9131ef7ff8a0fad6e28477d80bbe1db94aafd3a413a4bf94b16db02c436b304f04fdf3e9668c32f350fbbc9281929b045e9b90f73364d357e5b5ffa2e5147bb8924ff672a480bb8d189b78592d0bd2c1fbde12f1f8971dff4d60dd3a78522892bed8d0fe3b6766d6c21eaf3092e9959f4d711f1906e95caf0c8270371c25d5946a2c99eb3f29294f6a6ec4f62ee5d3b91cfa3ff1f4ff9e348005fc9fff582ce9bccc4bd9d1f5be03cb2a342c58d6b3566b09124d2810efe15678d0be093e6a443c2b79afb06c580ba47bafc66c276a84bcfc6f77d2b64c4bb8a48b658c9f1808d3daaf0a4f77e875dace4acaf16a883f2a99b8e98692c11b75a8ac10e04b2c7ac2b965d00cebc064f4c669e9210c37922261062d172b8d5a0931aadb649b116c61835fff055ae9b93f71826cbedf4a807a2175f69cb5fe312ce87a9698b949a7c6abb99be42705ccc06e6167be2085584a4de71ad8929cd4f3ce3aa016e18a72247d2871f67cef85c2714bc7056671b2c59a5d16825f9ac9ac02c979819c0476d908ef73a4dfa1c9a9322dad24bef6d29597aabe794d21ad4944a62264b2cb0ad164adbc372b70fe4dde46ae72fe34bad200aa22f1463a55db107fcf15acd7d332f2374d50340024ca1567d4f50d86e34663f82410f1f72ec9205623d4528af0461682bc0d2808b9cd18d702aa0f64f6ae2fc9fcd5d98ec12b4a5c91bd1f213e835b7c4feea14c91eb104fd979dc68014f46230b55361d8d52ca4de939f34974d7e9438468a5038321912c45cbaba1ed40eab0f4d74dc60590f506e8552fb2e38c3b0caa5a3421f845d00a47af56aa3248020007fbecfe5bb33114ce5f8673f8119e3801aebe45c694ae77d19ab580a43401364351a8e6396c655b31050304ff05a740fdafcbbca6205e296da725dbb6e2042a2bb9bf3f7a08ebaf836c4594c32aa63e51db354812ff0c7639eb00e7578e2d32fb933c22dde2d15a0ede44e0ca8ce1b57051d8ef19fff5e7d6cad14a88908c34ce33ccc4c28523b2571cb7e07446f129d284714601d8854d020beff282a10c55a7cd41733cd2ce12539571e2e24c936a2e26b540523966269e6603a0bda987b4011820f3527c765613b3fa1e8326a74c6c35695522a85a17ded536527524a30cfd81ba76261ff71163de36f909ee1060337ae1292521e06a2547152bf4f9cfddc7f211fc0cd263e2e6cfd7c775cfb35299c8c0c26e021325ed05e4f558757bd0a87f797cdd305c29e4ee2c48afee58df42c55d5810e314c0f73b4c2dbb25d204db88993fa3c5e03789be9151bbc76055fc159b14755f62907b3cc84a4f535aa3c487c119472a49324617a1d727684198b38508f86697aaf41b4fd3cd72a013802d27e7ed1bb68f54aaf7d1735655a6d323873422f394ae74175cab1598e3a8df8d2ad8e57e0d9adfa94b6111ca896330e507e8a1fe550626325b69c7507d111baf9829b0d4ec06d649708fca8f292ea3d3a2a99244178c41a39090a419448c432aa2e50ca379d195d67e0b0bfac5d40744780611b383967ed26f6b7bd93dea67c103af063cb793c9d58c3085cce0df807a126e7f1e44dbcedf61045c8bc4b5e382fa1940428ff7c8a01c19b9103fe10c5636ca4851d66b9e2859613647ea4432c8438ec9bb2086c727dba0346d2e173d9296dc5d38dd682c23ccd531ab9f3c248fc026adf2f028bfa58c4c5210d697fe0187ed22a909461a829a1ebb8eb7c255ab1ea719288089deb0d1e92ed7eb9ecca2b217fb65ad4f6590d045d20a0f27ed512924860c87ff9eaa75d39f4415da6155db72568680a882d3f5d31cbf27bf2f05e9215003608882cb8c0a6847016d08bef53f2e952f2358ab24ad95d2309d5478ff944ae383ac49a62b43976e1a17788a89e5c448bd9b024294fd3a44608ab3abefbac37237d32e57b25ac7e49970931150a8b424b5be87fc3b8d14ea02da019ac46041893cca61c3923e50fc7ce5589faaba8c8e25d3d390db35040c0d7dd96f2dfbb011ce0d6a05fec6d3a617bc8acc7db1ae306d9a5353b422eb1506b5d3c1b54026a659edbfe4161b1d6955b8eb3b737b02b028e4cce41c595c625e909111231b5a3fa1b414b08427381f9d52e579ca4494577f83fa4e931caef1832690440119cb27bfe307a6ad60228223124203116b6cfbe24fd01903ed045c844befc08cdee8530aa427258f4725846b7676d6d51e6d85200a3b69805b0dc5e560c5e55b3cae9dabcaf1d875e47ea67422ddc01e8d96f7e28c8752b10ca5fe2807173f55a925dd85b77b0960b3343647841a17a9d9df0473efb7cdd2d09265aa75833395433a1b7e3320192efe9def561435690b622fde567dee968bee7097acd3bf47ca1a9942b3efb78703005e1ae3ca4829344f456d73b26aa0886da44642d1905ac359f7333e0e58582bce500269d5a249b75d1292e750ba123456b7048c276178dfdb23da737a7497b88acf2770492433cfa5f268862328a6b1d1e376d3f1c024519e1b326b2e4f18856bf1ccadff4e6ca7d677212598d46fa0d3f4adb9aa8ce900c13ad77906cd2fb6339c9109bf9fbd63d8d805b1674f88ead94a0d8b2c12230a9342eda5fffb52e010299b8766694215e2bd922ea2c7735890849005ba2355e2d694aaaf3f73fbecd6c0e38309e1beae444f5225ab586954a76f0c68198f116ba0adcdf88ffcd6b695a4f3457871b0f87b48c6fa968dd669e55bd2096ed556234cef32dfd115e75fba30ac128ee4bb9d66eedcfe42a4e68a7033bb46851b338d0d8cbce3f4aa847bb6931a7c584243201b3f157957ff628aefd79ab843471001d6c790945b417531e47644e412fadcabf80ec988454b0680406373422c174a4ce4f8de2eaffb52cf64549076eea39155ace176ddaded19586faf5918bb489f167ea6f713bad4d555ee4098baf116ec1fd489a75866da050917d57438cc15e662187320f74c4c35d356882a99761ddf4a7f5d9491a4a53815fb6ca3a41c9f76e390bd3162cf455ad5764069cda6c1a749051e7fb5016b956868c5861648d8a9ebc538172e16dd2c180ef9852f00c6e199e983b755176036f4248dcb547ab93188f8e757cb30bb6dad28323c432ee1f56b48ed0b02ea7a92017a67f31c96aece4984450946147abc5174a05b534e9947224191915373b269e01b0573cf63f9aa4e933d4635ce9e8f36920de84447526fb07e1f6c96bfec5747ca0c82dd2bcaaaa5c2299d07d3259e07c42c71efd8562e1be250fbf69ad5b79708bf458c30e89e48a055d97a068678a4fde9db7effb8f8dce2a7fc41a4121a8b78a1eb5f4e1bc521803afa7d06b78e8a8dab937a3462efca11ddb41f05ca0867bb981acea1dd713351620b22fa7b7f260b8e9dc68559598e2001755d20de4669b56e0f70a86e2d58927f563c2f72de15fcf72e8310611346a1e5b165dd53ba22a10dea431238d2b41a7dd536e580f354cb953d6b463bf3626571580c694f294036ba0886305ad78a4efcc05d667daaa5d3e399a8269536e6bea8f7e688ea30b975287bbaa8acbabaf7b8e360f3c0183b916e8c4c5540a681619a86c6abda3cbc831fdb8781694a9011b9dd5e14d6c7f27b680fda18a0335519f33b1ea958513e4f71306812f97467acfae9a2f26c87f8f5e13832defb689398313e10d86611b548457c55f21b76f184549c1bd2c7d082a132554ea85510419bb2662d2f541f96c2b0ad7369263568c8d2edc309725043edf2d1c5a77a9eaa0acc0385612cc9922481562e005bfeeae23cc00ffc6727d27aa395029cbee930af3f0626fdcb88a82ff04484fd211fa38fab6685e37b8eb9546ccd4b54abe9a485759cc0064f2126dbc2328ca91892899295d7f1f45ffa2e05f95a662adf041aad5fdbeca4cf414a572ecfd00bb53a36678befeab9baeccf33fa6366bdf928756cd129bf4d2444d1e5ff5fa5bebabe6e93a6160b807f7ed6e9e8eea2b9c78a8a6c1c92d94b6cd21d35d560f6c11a80a9a9bbc69cba267bd2cbab8463081619d1a1e9672df58a21e064e19c0828611b90a7ae9a0c9efde801e4ed74a888bcf0bd6d76d2867746b9f778a521184e5838ce31bd0e6af5d7113fca12a9fc66ec6cd8ec9590febbc661423cc292b58e21cee261fb68e326f92276938382a80baf785a292365b6439d2c44ad0866b4e6b500928c7e31c2b7cbaa6de3edaff199dabfbcecc75e6a79feb38f267abd4a6615c6e9349be9c8da99de1c6c1fc246e6835542321821872e8342bf8ee6131b4fde176efd769fa3e737c9970c962a1ea97cbc633151f992741bc4abc411aba78276c3a9b629ad78b6e186ab2f8fbab396f4cf81042b81b260080e794befb93bf479d8cacc38a3d765d3c5c202a9696f9f738f4ff7918cfbe85f406dfcb650aa90f1973febc621efd2755ba487e53c0e7977fd3251f10a54476cfb95acafce7baf663135531d20fd4e297fcf30994bbfcddf0fe31acec6184f0decfa240a9f48d6413caab0b691d568dfb0fd446005eeb9cb1ae154f793ee1b61da3d449bd20dbf57e95aed58db126049197ccc3c7b1640b9c5dd93e5da64d707ec8b6df509f73dd37711847ffffb359e8d4344379db4961fd7152dc1bdb9e9eaebe2af41276d2d06dbfdc1c76ade0010bcd0f95dd1938182de299bbef95bc803b269a900f2d9e32386670701230f5701b643b90825a0d037fb1d5108c65e7eddb98b198c256957b37a22050037756b7658fb0974a48fb90f3c0e65f2240bd0028d65835d082ece45467374db6e1644efa0ed2a5f5a02de4a08c37284099757f8422691e48be1c02c13acfcafa99e9c03190af9bac9fcf5acd887a21d1ee5c0c49709d57c9648287dd68ab9cb3cd4effa8fbecfd07b4cbb18792c7d523dfdabb8e6344178f2898f6c9364ee640268a0affbe30ae4e2f00edc7f3eb8726626564103048ec9408200a40a9a387d8b6b7b977f2631ee42470f1f56e79fa926901148112e101f0a58d2afb87c28531e22daadb870d304df2b6d08941de611ae42299012faaf43146b1741167a9897e0e402932cd7edaad4dad2ac7da1881ce18eee99139eeaeaea178443b2dbe59a9c48b7a508d1dabb9021e7b065bcd42e57e68ec1c65358b20092879e0189979a390f704fba53161e38ae49635dc2625cd3c96ecf053597fde6b6ad6eac771ba10b7ff3d5b99b462346c2700c334d605a9dd904b9f25d1146556e1a70f4f79583bd1a76bd2191a70182a45a6094b405675e36450d39309d73acabc9049362cde7b99290de783dd3f166cebd8917d925f7b8c74c14661024d9b612f24cb49564fabb3045fa7fe7f9bc69191039c775be13a51277c5cd1ff558b6fdabc9f51b631368d6e18848028b112d54f7ed1427fd6446fadd61af27f10fe11dbf6663165f570bf2d48b44a741e0286ae86cd21bb7bf6dcab2316aa56b22a663245b3ae1c88868655aeef3af5577278f174aae82ad7e7e365ef0debfea9d0ae8e0414ade165c54e427950d093138a09612ff20f7118fec9df67b8fa9ef6f4577cdfe009cfe3876d5d31c0ea1a46d254539a86b9075049863a558a798e33f634213cad991b1eff7f8973216bd6356c9b515fffec347aeef6b5126b5d48eea2f0fd0fec4d2da8f1690f69c257d56dab68e39924ac3d96978f68b3171f4b8eea57159f67572e03b9856881d350943fab6c4ace83e8645f788ecd9cdd5f1865fe7dbc176f44eab170a3b2d8355db93461ed4344443bfe909b8e38e924d865fbc8c1aca90af275ff42ad292dd2c8f49da0a54bf76f7679df39e53ef8211cc8d548962d239fd62d82f7e61418e19fe1cd28c46da802040f4241fd0a29eb5121ea731ffb6d039c11d82fa9b93962d70fbbe1cb14b6855e6499ee12dc3e0741230e326e6bfc427912d286f36e7b56b18d8f1ee8c825515cc3c41be07bdfc3397ca35b460a464d3c63b23c78db31cc79fc3d8332a4bbb6e8d69f0227a1230246d64542336a097e5550fdb26a1160fade502caf08589fc0928d69c74af2dd6bd1d8b56c23028f9d37159e3711b7b73ace0b4903bdd553870f0c3cc94451ba804db4f013ff8c9b190fba7e28d9ceb3f899c6cabf57e0bee1855eda3c2103eb2404cfff14ec86e6bf67f1afff537cbedbd70b4c73854269ebe77ddacfce12c6ace0184ccd422fe3cd576e799f4a2d5f20cedace14877d68fde4826c782c506835004456c330793ffaff54accd5a05da3159308741a5e0e8a19765e0304d227395abf408c9a5c8532c1f6b9f2e5dd80d9ee71597608c04196df78efc17f8f287eca5f3e61278a18efd8f6acdca296b7f1a2a7e3e8f5426096c7332eacf64d0c4398238a04378dd600da01df5b36170f23166c0d2b521f4dd731db18385133f937790035d833c741aa65681a44974f4688705cf627a78edcfb95ebe9af94997a5cc1eeb7c4133956a9d30232ef58d3b7ca88a6ba1665d22d053f2f05dbcb04f24d08bb51d456c9a95bc605bebd52396b27065e396ff2493d1328ca52ae6ed4588d273b7a82ebfb71190f1640480a4a3a18d63e87baad757bc8b9dd993d04d7ec8f93c71ec6e41b6bca15a11172bed86a0660a22d13efc4110d4155623a292b73d7925806ae0f3e96c68f85e41d38b9fee7286f5fc08efaa22e5298f9148871619be4765a8e7736ac48f350d979d8ec42b402a5efe382282d862aee0579b7154a17426604116b940cba11e47568900d0e9e8d128a5b81a7f2b9881578c6a294c528fbd23f511bf9a1b46afd3d487c8b8da9b87de57f2330b83e3f3061edcd29cc5761a80cf510ab5784ed394957498c5ec754b72a6b44688f45c85c02df9b33342ca0e002d281bc8aed67694dda21cd463e7fcdc85a60961587f79746b561127c4cdc66116084456c6f7bfdfa377db421fd386e1620dd1d6a426843dd84e8fed3a60d12d4800ecad531b85cc8a3d91fdf48e64b162fd058b94a028300ebb77c5d0a37640ca6e5cd6c78d357e4bd9e5eec0c9c06db5f3c7487e5b50175669c8d80a1adcb18b4e7afab20cb27a234882e30219072ea4414e8261235554e5f54621947b4f0f4834f24fb624b204e728c620b5ac59510eff7ab596f75c4f87704ef3a4ac5b8ebe58b21465c01bbabec792fbb42df0f33eb5a6c53fdee3b755e1e3638b26816abe4fbc7b61d59c2698d5cceb8689e2a8385fe28b7991e7cc73d917c3c2e852a9cb08cd3d119ffcf9f449c22d3cff912b8d663bde76e5370b5833d0fcae93dd161b90e7b2e65be2e543badd463b17f009d7a9f28c9794047c5754bae226ab0ee73206c9ebbeedf992bf6773eb03f7e888622c7ef049d7068edd7169e9671c3b45d57b432f6fb63163b3f3c0b7b7daa4b91def9cf3352236fed4e7de68b7f12362326ef99c16ec9494b8b6402de2eb4f0bd00754f5f9b8b1ea5cafd221db41aab1d4775374b533854e133813e439b3116147e351d01dfe3eff5aa4dfe5f4ab13831bd842b5403dbdc1351fb807e94fdba117fc40f34d86d88bb8e48d7d90a413b5c4533a45819f5e7def6ec739e1d8cef5595ddaa33fb34893be26f9824babc71c86c86bd3173c89873cf491536b1b7357cfdd6d2c347096abc5c75b9db4a59b8b767dad1407fda428e878d0ce60f8345177381bdd29a8d3c62f0f9a6664e3a31be4f4ff61f31dd06dfc275a17a0250f5271c01e2899ee1e27add4fbdd8844bb82b3d76f4e38730efebde13c1783b813370f0a9df51590a621d688737735e7f0e6ee24cb43b6c43ab916c43cdef4132fb839c7159d5902f707a6a6dc6b08cfc5904aabc8d365695a13b58f6eadccddf96542d0d7cdd4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
